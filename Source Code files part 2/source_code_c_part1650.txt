I and port of our listener
const TCHAR c_szNotifyUri[]             = TEXT("notify");
const DWORD c_nPort                     = 5000;

#if DBG
const DWORD c_csecDefaultTimeout        = 60 * 1;   // 1 minute is default
                                                    // subscription timeout (debug)
#else
const DWORD c_csecDefaultTimeout        = 60 * 10;  // 10 minutes is default
                                                    // subscription timeout
#endif


HRESULT HrSendSubscriptionRequest(HINTERNET hin,
                                  LPCTSTR szUrl,
                                  LPCTSTR szSid,
                                  DWORD *pcsecTimeout,
                                  LPTSTR *pszSidOut,
                                  ESSR_TYPE essrt);

CSsdpPendingNotification::CSsdpPendingNotification()
{
    ZeroMemory(&m_ssdpRequest, sizeof(m_ssdpRequest));
}

CSsdpPendingNotification::~CSsdpPendingNotification()
{
    FreeSsdpRequest(&m_ssdpRequest);
}

HRESULT CSsdpPendingNotification::HrInitialize(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

    if(!CopySsdpRequest(&m_ssdpRequest, pRequest))
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpPendingNotification::HrInitialize");
    return hr;
}

HRESULT CSsdpPendingNotification::HrGetRequest(SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

    if(!CopySsdpRequest(pRequest, &m_ssdpRequest))
    {
        hr = E_FAIL;
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpPendingNotification::HrGetRequest");
    return hr;
}

CSsdpNotifyRequest::CSsdpNotifyRequest() : m_timer(*this), m_hNotifySemaphore(INVALID_HANDLE_VALUE)
{
}

CSsdpNotifyRequest::~CSsdpNotifyRequest()
{
}

void CSsdpNotifyRequest::OnRundown(CSsdpNotifyRequest * pNotify)
{
    CSsdpNotifyRequestManager::Instance().OnRundown(pNotify);
}

class CNotifyRequestTimerAction : public CWorkItem
{
public:
    static HRESULT HrCreate(
        CSsdpNotifyRequest * pRequest,
        DWORD dwSecTimeout,
        const CUString & strSid,
        const CUString & strUrl);
private:
    CNotifyRequestTimerAction(CSsdpNotifyRequest * pRequest, DWORD dwSecTimeout);
    ~CNotifyRequestTimerAction();
    CNotifyRequestTimerAction(const CNotifyRequestTimerAction &);
    CNotifyRequestTimerAction & operator=(const CNotifyRequestTimerAction &);

    DWORD DwRun();
    HRESULT HrIntialize(
        const CUString & strSid,
        const CUString & strUrl);

    CSsdpNotifyRequest * m_pRequest;
    DWORD m_dwSecTimeout;
    CUString m_strSid;
    CUString m_strUrl;
};

CNotifyRequestTimerAction::CNotifyRequestTimerAction(CSsdpNotifyRequest * pRequest, DWORD dwSecTimeout)
: m_pRequest(pRequest), m_dwSecTimeout(dwSecTimeout)
{
}

CNotifyRequestTimerAction::~CNotifyRequestTimerAction()
{
}

HRESULT CNotifyRequestTimerAction::HrCreate(
    CSsdpNotifyRequest * pRequest,
    DWORD dwSecTimeout,
    const CUString & strSid,
    const CUString & strUrl)
{
    HRESULT hr = S_OK;

    CNotifyRequestTimerAction * pAction = new CNotifyRequestTimerAction(pRequest, dwSecTimeout);
    if(!pAction)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pAction->HrIntialize(strSid, strUrl);
        if(SUCCEEDED(hr))
        {
            hr = pAction->HrStart(TRUE);
        }
        if(FAILED(hr))
        {
            delete pAction;
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CNotifyRequestTimerAction::HrCreate");
    return hr;
}

DWORD CNotifyRequestTimerAction::DwRun()
{
    HRESULT hr = S_OK;

    char * szSid = NULL;
    char * szUrl = NULL;

    hr = m_strSid.HrGetMultiByteWithAlloc(&szSid);
    if(SUCCEEDED(hr))
    {
        hr = m_strUrl.HrGetMultiByteWithAlloc(&szUrl);
        if(SUCCEEDED(hr))
        {
            hr = HrSendSubscriptionRequest(g_hInetSess, szUrl, szSid, &m_dwSecTimeout,
                                           NULL, SSR_RESUBSCRIBE);
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = CSsdpNotifyRequestManager::Instance().HrRestartClientResubscribeTimer(
            m_pRequest, m_dwSecTimeout);
    }
    else
    {
        // Failed to send a re-subscribe. We now need to notify clients that
        // a subscription has been lost. Compose a pending notification to
        // let them know this fact.
        //
        SSDP_REQUEST ssdpRequest;
        ZeroMemory(&ssdpRequest, sizeof(ssdpRequest));
        InitializeSsdpRequest(&ssdpRequest);
        ssdpRequest.Headers[GENA_SID] = szSid;
        szSid = NULL;
        hr = HrCopyString(c_szDeadNts, &ssdpRequest.Headers[SSDP_NTS]);
        if(SUCCEEDED(hr))
        {
            hr = CSsdpNotifyRequestManager::Instance().HrCheckListNotifyForEvent(&ssdpRequest);
        }
        FreeSsdpRequest(&ssdpRequest);
    }

    delete [] szSid;
    delete [] szUrl;

    TraceHr(ttidEvents, FAL, hr, FALSE, "CNotifyRequestTimerAction::DwRun");
    return 0;
}

HRESULT CNotifyRequestTimerAction::HrIntialize(
    const CUString & strSid,
    const CUString & strUrl)
{
    HRESULT hr = S_OK;

    hr = m_strSid.HrAssign(strSid);
    if(SUCCEEDED(hr))
    {
        hr = m_strUrl.HrAssign(strUrl);
    }


    TraceHr(ttidEvents, FAL, hr, FALSE, "CNotifyRequestTimerAction::HrIntialize");
    return hr;
}

void CSsdpNotifyRequest::TimerFired()
{
    HRESULT hr = S_OK;

    hr = CNotifyRequestTimerAction::HrCreate(this, this->m_dwSecTimeout, this->m_strSid, this->m_strUrl);

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::TimerFired");
}

BOOL CSsdpNotifyRequest::TimerTryToLock()
{
    return m_critSec.FTryEnter();
}

void CSsdpNotifyRequest::TimerUnlock()
{
    m_critSec.Leave();
}

HRESULT CSsdpNotifyRequest::HrRestartClientResubscribeTimer(
    DWORD dwSecTimeout)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    m_dwSecTimeout = dwSecTimeout;

    // Do 65% of timeout in milliseconds
    DWORD dwTimeoutInMillis = (dwSecTimeout * 65 * 1000) / 100;

    hr = m_timer.HrResetTimer(dwTimeoutInMillis);

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrRestartClientResubscribeTimer");
    return hr;
}

HRESULT CSsdpNotifyRequest::HrInitializeAlive(
    const char * szNT,
    HANDLE hNotifySemaphore)
{
    if(!szNT)
    {
        return E_POINTER;
    }
    HRESULT hr = S_OK;

    m_nt = NOTIFY_ALIVE;
    hr = m_strNT.HrAssign(szNT);
    if(SUCCEEDED(hr))
    {
        m_hNotifySemaphore = hNotifySemaphore;
        m_dwSecTimeout = 0;
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrInitializeAlive");
    return hr;
}

HRESULT CSsdpNotifyRequest::HrInitializePropChange(
    const char * szUrl,
    HANDLE hNotifySemaphore)
{
    if(!szUrl || !*szUrl)
    {
        return E_POINTER;
    }
    HRESULT hr = S_OK;

    m_nt = NOTIFY_PROP_CHANGE;
    hr = m_strUrl.HrAssign(szUrl);
    if(SUCCEEDED(hr))
    {
        m_hNotifySemaphore = hNotifySemaphore;
        m_dwSecTimeout = 0;
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrInitializePropChange");
    return hr;
}

HRESULT CSsdpNotifyRequest::HrSendPropChangeSubscription(SSDP_REGISTER_INFO ** ppRegisterInfo)
{
    HRESULT hr = S_OK;

    *ppRegisterInfo = NULL;

    char * szUrl = NULL;
    char * szSid = NULL;
    hr = m_strUrl.HrGetMultiByteWithAlloc(&szUrl);
    if(SUCCEEDED(hr))
    {
        TraceTag(ttidEvents, "CSsdpNotifyRequest::HrSendPropChangeSubscription(this=%x) - About to call HrSendSubscriptionRequest", this);

        if (!g_hInetSess)
        {
            g_hInetSess = HinInternetOpenA("Mozilla/4.0 (compatible; UPnP/1.0; Windows NT/5.1)",
                                           INTERNET_OPEN_TYPE_DIRECT,
                                           NULL, NULL, 0);
        }

        if (g_hInetSess)
        {
            hr = HrSendSubscriptionRequest(g_hInetSess,
                                           szUrl,
                                           NULL,
                                           &m_dwSecTimeout,
                                           &szSid,
                                           SSR_SUBSCRIBE);
        }
        else
        {
            hr = E_UNEXPECTED;
            TraceTag(ttidEvents, "CSsdpNotifyRequest::HrSendPropChangeSubscription - HinInternetOpenA failed!");
        }

        if(SUCCEEDED(hr))
        {
            TraceTag(ttidEvents, "CSsdpNotifyRequest::HrSendPropChangeSubscription(this=%x) - Called HrSendSubscriptionRequest - SID:%s", this, szSid);

            hr = m_strSid.HrAssign(szSid);
            delete [] szSid;
        }
        delete [] szUrl;
    }

    if(SUCCEEDED(hr))
    {
        CLock lock(m_critSec);

        // Do 65% of timeout in milliseconds
        DWORD dwTimeoutInMillis = (m_dwSecTimeout * 65 * 1000) / 100;

        hr = m_timer.HrSetTimer(dwTimeoutInMillis);
        if(SUCCEEDED(hr))
        {
            SSDP_REGISTER_INFO * pRegisterInfo = new SSDP_REGISTER_INFO;
            if(!pRegisterInfo)
            {
                hr = E_OUTOFMEMORY;
            }
            if(SUCCEEDED(hr))
            {
                pRegisterInfo->csecTimeout = m_dwSecTimeout;
                hr = m_strSid.HrGetMultiByteWithAlloc(&pRegisterInfo->szSid);
                if(SUCCEEDED(hr))
                {
                    *ppRegisterInfo = pRegisterInfo;
                }
                if(FAILED(hr))
                {
                    delete pRegisterInfo;
                }
            }
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrSendPropChangeSubscription");
    return hr;
}

HRESULT CSsdpNotifyRequest::HrShutdown()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);
    if(NOTIFY_PROP_CHANGE == m_nt)
    {
        hr = m_timer.HrDelete(INVALID_HANDLE_VALUE);
        if(SUCCEEDED(hr))
        {
            char * szUrl = NULL;
            char * szSid = NULL;
            hr = m_strUrl.HrGetMultiByteWithAlloc(&szUrl);
            if(SUCCEEDED(hr))
            {
                hr = m_strSid.HrGetMultiByteWithAlloc(&szSid);
                if(SUCCEEDED(hr))
                {
                    hr = HrSendSubscriptionRequest(g_hInetSess,
                                                   szUrl,
                                                   szSid,
                                                   &m_dwSecTimeout,
                                                   NULL,
                                                   SSR_UNSUBSCRIBE);
                    delete [] szSid;
                }
                delete [] szUrl;
            }
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrShutdown");
    return hr;
}

BOOL CSsdpNotifyRequest::FIsMatchBySemaphore(HANDLE hNotifySemaphore)
{
    return m_hNotifySemaphore == hNotifySemaphore;
}

BOOL CSsdpNotifyRequest::FIsMatchingEvent(const SSDP_REQUEST * pRequest)
{
    BOOL bMatch = FALSE;

    BOOL bIsPossibleMatch = pRequest->Headers[SSDP_NTS] &&
        !lstrcmpiA(pRequest->Headers[SSDP_NTS], "upnp:propchange");

    bIsPossibleMatch = bIsPossibleMatch && pRequest->Headers[CONTENT_TYPE] &&
        !_strnicmp(pRequest->Headers[CONTENT_TYPE], "text/xml", strlen("text/xml"));

    bIsPossibleMatch = bIsPossibleMatch && (NOTIFY_PROP_CHANGE == m_nt);

    if(bIsPossibleMatch)
    {
        // Ensure that we have a valid SID before letting this continue.
        // We enter this critsec so that we will wait until a potential
        // subscription has been sent and a SID received for it before this
        // code continues.
        //
        if(m_strSid.GetLength() && pRequest->Headers[GENA_SID])
        {
            char * szSid = NULL;
            HRESULT hr = m_strSid.HrGetMultiByteWithAlloc(&szSid);
            if(SUCCEEDED(hr))
            {
                bMatch = !lstrcmpiA(pRequest->Headers[GENA_SID], szSid);
                delete [] szSid;
            }
        }
    }

    return bMatch;
}

BOOL CSsdpNotifyRequest::FIsMatchingAliveOrByebye(const SSDP_REQUEST * pRequest)
{
    BOOL bMatch = FALSE;

    Assert(!lstrcmpiA(pRequest->Headers[SSDP_NTS], "ssdp:alive") ||
           !lstrcmpiA(pRequest->Headers[SSDP_NTS], "ssdp:byebye"));

    if(NOTIFY_ALIVE == m_nt)
    {
        char * szNT = NULL;
        HRESULT hr = m_strNT.HrGetMultiByteWithAlloc(&szNT);
        if(SUCCEEDED(hr))
        {
            bMatch = !lstrcmpA(szNT, pRequest->Headers[SSDP_NT]);
            delete [] szNT;
        }
    }

    return bMatch;
}

HRESULT CSsdpNotifyRequest::HrQueuePendingNotification(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

#if DBG

    if(SSDP_NOTIFY == pRequest->Method && pRequest->Headers[GENA_SID] && pRequest->Headers[GENA_SEQ])
    {
        TraceTag(ttidEvents,
                 "CSsdpNotifyRequest::HrQueuePendingNotification - Event notification for SID:%s",
                 pRequest->Headers[GENA_SID]);
    }

#endif // DBG

    CLock lock(m_critSec);

    PendingNotificationList pendingNotificationList;
    hr = pendingNotificationList.HrPushFrontDefault();
    if(SUCCEEDED(hr))
    {
        hr = pendingNotificationList.Front().HrInitialize(pRequest);
        if(SUCCEEDED(hr))
        {
            m_pendingNotificationList.Append(pendingNotificationList);
            TraceTag(ttidEvents, "CSsdpNotifyRequest::HrQueuePendingNotification - releasing semaphore %x", m_hNotifySemaphore);

            if(!ReleaseSemaphore(m_hNotifySemaphore, 1, NULL))
            {
                hr = HrFromLastWin32Error();
            }

        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrQueuePendingNotification");
    return hr;
}

BOOL CSsdpNotifyRequest::FIsPendingNotification()
{
    CLock lock(m_critSec);

    return !m_pendingNotificationList.IsEmpty();
}

HRESULT CSsdpNotifyRequest::HrRetreivePendingNotification(MessageList ** ppSvcList)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    // I am just going to return one item
    MessageList * pSvcList = new MessageList;
    if(!pSvcList)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        pSvcList->list = new SSDP_REQUEST;
        pSvcList->size = 1;
        if(!pSvcList->list)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            ZeroMemory(pSvcList->list, sizeof(SSDP_REQUEST));
        }
    }

    if(SUCCEEDED(hr))
    {
        if(m_pendingNotificationList.IsEmpty())
        {
            hr = S_FALSE;
            TraceTag(ttidEvents, "CSsdpNotifyRequest::HrRetreivePendingNotification - no pending notifications!");
        }
        if(S_OK == hr)
        {
            PendingNotificationList pendingNotificationList;
            PendingNotificationList::Iterator iter;
            if(S_OK == m_pendingNotificationList.GetIterator(iter))
            {
                iter.HrMoveToList(pendingNotificationList);
                hr = pendingNotificationList.Front().HrGetRequest(pSvcList->list);
            }
        }
    }

    if(FAILED(hr))
    {
        if(pSvcList)
        {
            delete pSvcList->list;
            pSvcList->list = NULL;
            pSvcList->size = 0;
        }
    }

    *ppSvcList = pSvcList;

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequest::HrRetreivePendingNotification");
    return hr;
}

CSsdpNotifyRequestManager CSsdpNotifyRequestManager::s_instance;

CSsdpNotifyRequestManager::CSsdpNotifyRequestManager() : m_unTimestamp(0)
{
    m_hEventTimestamp = CreateEvent(NULL, TRUE, FALSE, NULL);
}

CSsdpNotifyRequestManager::~CSsdpNotifyRequestManager()
{
    CloseHandle(m_hEventTimestamp);
}

CSsdpNotifyRequestManager & CSsdpNotifyRequestManager::Instance()
{
    return s_instance;
}

void CSsdpNotifyRequestManager::OnRundown(CSsdpNotifyRequest * pNotify)
{
    HrRemoveInternal(TRUE, NULL, pNotify);
}

HRESULT CSsdpNotifyRequestManager::HrCreateAliveNotifyRequest(
    PCONTEXT_HANDLE_TYPE * ppContextHandle,
    const char * szNT,
    HANDLE hNotifySemaphore)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSecAliveList);

    *ppContextHandle = NULL;

    CSsdpNotifyRequest * pRequest = NULL;

    NotifyRequestList notifyRequestList;
    hr = notifyRequestList.HrPushFrontDefault();
    if(SUCCEEDED(hr))
    {
        hr = notifyRequestList.Front().HrInitializeAlive(szNT, hNotifySemaphore);
        if(SUCCEEDED(hr))
        {
            m_aliveList.Prepend(notifyRequestList);
            *ppContextHandle = &m_aliveList.Front();
            pRequest = &m_aliveList.Front();
        }
    }
    if(SUCCEEDED(hr) && pRequest)
    {
        hr = CSsdpRundownSupport::Instance().HrAddRundownItem(pRequest);
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrCreateAliveNotifyRequest");
    return hr;
}

HRESULT CSsdpNotifyRequestManager::HrCreatePropChangeNotifyRequest(
    PCONTEXT_HANDLE_TYPE * ppContextHandle,
    const char * szUrl,
    HANDLE hNotifySemaphore,
    SSDP_REGISTER_INFO ** ppRegisterInfo)
{
    HRESULT hr = S_OK;

    *ppContextHandle = NULL;

    CSsdpNotifyRequest * pRequest = NULL;

    NotifyRequestList notifyRequestList;
    hr = notifyRequestList.HrPushFrontDefault();
    if(SUCCEEDED(hr))
    {
        hr = notifyRequestList.Front().HrInitializePropChange(szUrl, hNotifySemaphore);
        if(SUCCEEDED(hr))
        {
            __int64 unTimestamp = 0;
            {
                CLock lock(m_critSecTimestampList);
                hr = m_timestampList.HrPushFront(m_unTimestamp);
                if(SUCCEEDED(hr))
                {
                    unTimestamp = m_unTimestamp;
                    ++m_unTimestamp;
                }
            }
            if(SUCCEEDED(hr))
            {
                hr = notifyRequestList.Front().HrSendPropChangeSubscription(ppRegisterInfo);
                if(SUCCEEDED(hr))
                {
                    CLock lock(m_critSecPropChangeList);
                    m_propChangeList.Prepend(notifyRequestList);
                    *ppContextHandle = &m_propChangeList.Front();
                    pRequest = &m_propChangeList.Front();
                }
                CLock lock(m_critSecTimestampList);
                TimestampList::Iterator iter;
                if(S_OK == m_timestampList.GetIterator(iter))
                {
                    __int64 * pun = NULL;
                    while(S_OK == iter.HrGetItem(&pun))
                    {
                        if(*pun == unTimestamp)
                        {
                            iter.HrErase();
                            break;
                        }
                        if(S_OK != iter.HrNext())
                        {
                            break;
                        }
                    }
                }
                if(!PulseEvent(m_hEventTimestamp))
                {
                    hr = HrFromLastWin32Error();
                    TraceHr(ttidError, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrCreatePropChangeNotifyRequest - PulseEvent failed!");
                }
            }
        }
    }

    if(SUCCEEDED(hr) && pRequest)
    {
        hr = CSsdpRundownSupport::Instance().HrAddRundownItem(pRequest);
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrCreatePropChangeNotifyRequest");
    return hr;
}

HRESULT CSsdpNotifyRequestManager::HrRemoveNotifyRequest(
    HANDLE hNotifySemaphore)
{
    return HrRemoveInternal(FALSE, hNotifySemaphore, NULL);
}

HRESULT CSsdpNotifyRequestManager::HrRemoveNotifyRequestByPointer(
    CSsdpNotifyRequest * pRequest)
{
    return HrRemoveInternal(FALSE, NULL, pRequest);
}

HRESULT CSsdpNotifyRequestManager::HrCheckListNotifyForEvent(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

    TraceTag(ttidEvents, "CSsdpNotifyRequestManager::HrCheckListNotifyForEvent");

    __int64 unTimestamp = 0;

    {
        CLock lock(m_critSecTimestampList);
        unTimestamp = m_unTimestamp;
    }

    bool bFound = FALSE;

    while(true)
    {
        {
            CLock lock(m_critSecPropChangeList);

            NotifyRequestList::Iterator iter;
            if(S_OK == m_propChangeList.GetIterator(iter))
            {
                CSsdpNotifyRequest * pNotifyIter = NULL;
                while(S_OK == iter.HrGetItem(&pNotifyIter))
                {
                    if(pNotifyIter->FIsMatchingEvent(pRequest))
                    {
                        hr = pNotifyIter->HrQueuePendingNotification(pRequest);
                        bFound = TRUE;
                        break;
                    }
                    if(S_OK != iter.HrNext())
                    {
                        break;
                    }
                }
            }
        }

        if(bFound)
        {
            break;
        }

        {
            BOOL bAllOlder = TRUE;

            CLock lock(m_critSecTimestampList);
            TimestampList::Iterator iter;
            if(S_OK == m_timestampList.GetIterator(iter))
            {
                __int64 * pun = NULL;
                while(S_OK == iter.HrGetItem(&pun))
                {
                    if(*pun < unTimestamp)
                    {
                        bAllOlder = FALSE;
                        break;
                    }
                    if(S_OK != iter.HrNext())
                    {
                        break;
                    }
                }
            }
            if(bAllOlder)
            {
                break;
            }
        }

        WaitForSingleObject(m_hEventTimestamp, 2000);
    }

#if DBG

    if(!bFound)
    {
        TraceTag(ttidEvents, "CSsdpNotifyRequestManager::HrCheckListNotifyForEvent - not found! SID:%s",
                 pRequest->Headers[GENA_SID] ? pRequest->Headers[GENA_SID] : "<Unknown>");
    }

#endif // DBG

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrCheckListNotifyForEvent");
    return hr;
}

HRESULT CSsdpNotifyRequestManager::HrCheckListNotifyForAliveOrByebye(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSecAliveList);

    NotifyRequestList::Iterator iter;
    if(S_OK == m_aliveList.GetIterator(iter))
    {
        CSsdpNotifyRequest * pNotifyIter = NULL;
        while(S_OK == iter.HrGetItem(&pNotifyIter))
        {
            if(pNotifyIter->FIsMatchingAliveOrByebye(pRequest))
            {
                hr = pNotifyIter->HrQueuePendingNotification(pRequest);
                if(FAILED(hr))
                {
                    break;
                }
            }
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrCheckListNotifyForAliveOrByebye");
    return hr;
}

BOOL CSsdpNotifyRequestManager::FIsAliveOrByebyeInListNotify(const SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSecAliveList);
    BOOL bRet = FALSE;

    NotifyRequestList::Iterator iter;
    if(S_OK == m_aliveList.GetIterator(iter))
    {
        CSsdpNotifyRequest * pNotifyIter = NULL;
        while(S_OK == iter.HrGetItem(&pNotifyIter))
        {
            if(pNotifyIter->FIsMatchingAliveOrByebye(pRequest))
            {
                bRet = TRUE;
                break;
            }
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::FIsAliveOrByebyeInListNotify");
    return bRet;
}

HRESULT CSsdpNotifyRequestManager::HrRetreivePendingNotification(
    HANDLE hNotifySemaphore,
    MessageList ** ppSvcList)
{
    HRESULT hr = S_OK;
    BOOL bFound = FALSE;

    {
        CLock lock(m_critSecAliveList);
        NotifyRequestList::Iterator iter;
        if(S_OK == m_aliveList.GetIterator(iter))
        {
            CSsdpNotifyRequest * pNotifyIter = NULL;
            while(S_OK == iter.HrGetItem(&pNotifyIter))
            {
                if(pNotifyIter->FIsMatchBySemaphore(hNotifySemaphore) && pNotifyIter->FIsPendingNotification())
                {
                    hr = pNotifyIter->HrRetreivePendingNotification(ppSvcList);
                    bFound = TRUE;
                    break;
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }
    if(!bFound)
    {
        CLock lock(m_critSecPropChangeList);
        NotifyRequestList::Iterator iter;
        if(S_OK == m_propChangeList.GetIterator(iter))
        {
            CSsdpNotifyRequest * pNotifyIter = NULL;
            while(S_OK == iter.HrGetItem(&pNotifyIter))
            {
                if(pNotifyIter->FIsMatchBySemaphore(hNotifySemaphore) && pNotifyIter->FIsPendingNotification())
                {
                    hr = pNotifyIter->HrRetreivePendingNotification(ppSvcList);
                    bFound = TRUE;
                    break;
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    // See if this is a bogus release
    if(!bFound)
    {
        *ppSvcList = new MessageList;
        if(!*ppSvcList)
        {
            hr = E_OUTOFMEMORY;
        }
        if(SUCCEEDED(hr))
        {
            (*ppSvcList)->size = 0;
            (*ppSvcList)->list = NULL;
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrRetreivePendingNotification");
    return hr;
}

HRESULT CSsdpNotifyRequestManager::HrRestartClientResubscribeTimer(
    CSsdpNotifyRequest * pRequest,
    DWORD dwSecTimeout)
{
    HRESULT hr = S_OK;
    CLock lock(m_critSecPropChangeList);

    NotifyRequestList::Iterator iter;
    if(S_OK == m_propChangeList.GetIterator(iter))
    {
        CSsdpNotifyRequest * pNotifyIter = NULL;
        while(S_OK == iter.HrGetItem(&pNotifyIter))
        {
            if(pNotifyIter == pRequest)
            {
                hr = pNotifyIter->HrRestartClientResubscribeTimer(dwSecTimeout);
                break;
            }
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrRestartClientResubscribeTimer");
    return hr;
}

HRESULT CSsdpNotifyRequestManager::HrRemoveInternal(BOOL bRundown, HANDLE hNotifySemaphore, CSsdpNotifyRequest * pRequest)
{
    HRESULT hr = S_OK;

    NotifyRequestList notifyRequestListRemove;

    {
        CLock lock(m_critSecAliveList);

        NotifyRequestList::Iterator iter;
        if(S_OK == m_aliveList.GetIterator(iter))
        {
            CSsdpNotifyRequest * pNotifyIter = NULL;
            while(S_OK == iter.HrGetItem(&pNotifyIter))
            {
                Assert(!hNotifySemaphore == !!pRequest); // One or the other
                if((hNotifySemaphore && pNotifyIter->FIsMatchBySemaphore(hNotifySemaphore)) ||
                   (pRequest && pNotifyIter == pRequest))
                {
                    if(S_OK != iter.HrMoveToList(notifyRequestListRemove))
                    {
                        break;
                    }
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }
    {
        CLock lock(m_critSecPropChangeList);

        NotifyRequestList::Iterator iter;
        if(S_OK == m_propChangeList.GetIterator(iter))
        {
            CSsdpNotifyRequest * pNotifyIter = NULL;
            while(S_OK == iter.HrGetItem(&pNotifyIter))
            {
                Assert(!hNotifySemaphore == !!pRequest); // One or the other
                if((hNotifySemaphore && pNotifyIter->FIsMatchBySemaphore(hNotifySemaphore)) ||
                   (pRequest && pNotifyIter == pRequest))
                {
                    if(S_OK != iter.HrMoveToList(notifyRequestListRemove))
                    {
                        break;
                    }
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    // Delete the items outside of the lock
    {
        NotifyRequestList::Iterator iter;
        if(S_OK == notifyRequestListRemove.GetIterator(iter))
        {
            CSsdpNotifyRequest * pNotifyIter = NULL;
            while(S_OK == iter.HrGetItem(&pNotifyIter))
            {
                if(!bRundown)
                {
                    CSsdpRundownSupport::Instance().RemoveRundownItem(pNotifyIter);
                }
                hr = pNotifyIter->HrShutdown();
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    TraceHr(ttidEvents, FAL, hr, FALSE, "CSsdpNotifyRequestManager::HrRemoveInternal");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DwParseTime
//
//  Purpose:    Parses the Timeout header for a subscription
//
//  Arguments:
//      szTime [in]     Timeout value in the format defined by RFC2518
//
//  Returns:    Timeout value in SECONDS
//
//  Author:     danielwe   13 Oct 1999
//
//  Notes:  NYI
//
DWORD DwParseTime(LPCTSTR szTime)
{
    TCHAR           szDigits[64];
    const TCHAR     c_szTimeout[] = TEXT("Second-");
    const INT       c_cchTimeout = lstrlen(c_szTimeout);
    DWORD           iDigit = 0;

    if (szTime && (lstrlen(szTime) > c_cchTimeout))
    {
        if (!_strnicmp(szTime, c_szTimeout, c_cchTimeout))
        {
            DWORD   dwDigits;

            // Ok we know we have at least "Timeout-x" now
            szTime += c_cchTimeout;

            *szDigits = 0;

            while (isdigit(*szTime) && (iDigit < sizeof(szDigits) - 1))
            {
                // Copy the digits into the buffer
                szDigits[iDigit++] = *szTime++;
            }
            szDigits[iDigit] = TEXT('\0');

            dwDigits = _tcstoul(szDigits, NULL, 10);

            if (dwDigits)
            {
                return dwDigits;
            }
            else
            {
                return c_csecDefaultTimeout;
            }
        }
    }

    TraceTag(ttidEvents, "DwParseTime: Invalid timeout header %s. Returning "
             "default timeout of %d", szTime ? szTime : "<NULL>",
        c_csecDefaultTimeout);

    return c_csecDefaultTimeout;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryHeader
//
//  Purpose:    Helper function to query a header from an HTTP response
//
//  Arguments:
//      hinR     [in]   Handle to request
//      szHeader [in]   Header to query
//      pszValue [out]  Returns header data
//
//  Returns:    S_OK if success, or ERROR_INTERNET_* error if failed
//
//  Author:     danielwe   18 Oct 1999
//
//  Notes:      Caller should free pszValue when done with it
//
HRESULT HrQueryHeader(HINTERNET hinR, LPCTSTR szHeader, LPTSTR *pszValue)
{
    DWORD   cbBuffer = 0;
    HRESULT hr = S_OK;

    // First get the header length
    //
    hr = HrHttpQueryInfo(hinR, HTTP_QUERY_CUSTOM, (LPTSTR)szHeader,
                         &cbBuffer, 0);
    if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
    {
        DWORD cbBuffLen = 0;
        cbBuffLen = _tcslen(szHeader);
        cbBuffer = ( cbBuffer > cbBuffLen ) ? cbBuffer : cbBuffLen ;

        *pszValue = (LPTSTR) malloc(cbBuffer + sizeof(TCHAR));
        if (*pszValue)
        {
            lstrcpy(*pszValue, szHeader);
            hr = HrHttpQueryInfo(hinR, HTTP_QUERY_CUSTOM, *pszValue, &cbBuffer, 0);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        AssertSz(FAILED(hr), "First call to HttpQueryInfo must fail!");
    }
    
    TraceError("HrQueryHeader", hr);
    return hr;
}

HRESULT HrHttpQueryStatusCode(HINTERNET hinR, DWORD *pdwStatus)
{
    HRESULT hr;
    DWORD   cbBuf = sizeof(*pdwStatus);
    Assert(pdwStatus);

    *pdwStatus = 0;

    hr = HrHttpQueryInfo(hinR, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                         pdwStatus, &cbBuf, NULL);

    TraceError("HrHttpQueryStatusCode", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSendSubscriptionRequest
//
//  Purpose:    Sends a SUBSCRIBE request based on the data contained within
//              pRequest.
//
//  Arguments:
//      hin      [in]   Handle to internet session returned from InternetOpen
//      pRequest [in]   Pointer to SSDP_NOTIFY_REQUEST containing information
//                      about the subscription that needs to be sent
//      essrt    [in]   Can be one of:
//                      SSR_SUBSCRIBE - sends a subscription request
//                      SSR_RESUBSCRIBE - sends a re-subscription request
//                      SSR_UNSUBSCRIBE - sends an unsubscription request
//
//  Returns:    S_OK if success, or ERROR_INTERNET_* error if failed
//
//  Author:     danielwe   18 Oct 1999
//
//  Notes:
//
HRESULT HrSendSubscriptionRequest(HINTERNET hin,
                                  LPCTSTR szUrl,
                                  LPCTSTR szSid,
                                  DWORD *pcsecTimeout,
                                  LPTSTR *pszSidOut,
                                  ESSR_TYPE essrt)
{
    HINTERNET       hinC;
    INTERNET_PORT   ipPort;
    URL_COMPONENTS  urlComp = {0};
    TCHAR           szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR           szUrlPath[INTERNET_MAX_URL_LENGTH];
    HRESULT         hr = S_OK;

    Assert(pcsecTimeout);

    // Parse the server name out of the URL
    //
    urlComp.dwStructSize = sizeof(URL_COMPONENTS);
    urlComp.lpszHostName = (LPTSTR) &szHostName;
    urlComp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;
    urlComp.lpszUrlPath = (LPTSTR) &szUrlPath;
    urlComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

    hr = HrInternetCrackUrlA(szUrl, 0, 0, &urlComp);
    if (SUCCEEDED(hr))
    {
        hinC = HinInternetConnectA(hin, szHostName, urlComp.nPort, NULL, NULL,
                                   INTERNET_SERVICE_HTTP, 0, 0);
        if (hinC)
        {
            HINTERNET   hinR;
            LPCTSTR     szMethod = c_szSubscribe;

            if (SSR_UNSUBSCRIBE == essrt)
            {
                szMethod = c_szUnSubscribe;
            }

            hinR = HinHttpOpenRequestA(hinC, szMethod, szUrlPath,
                                       c_szHttpVersion, NULL, NULL, 0, 0);
            if (hinR)
            {
                TCHAR   szHeaders[1024];

                if (SSR_RESUBSCRIBE == essrt)
                {
                    wsprintf(szHeaders, c_szReSubsHeaderFmt, szSid,
                             *pcsecTimeout);
                }
                else if (SSR_SUBSCRIBE == essrt)
                {
                    SOCKADDR_IN     sockIn;
                    ULONG           nAddr;

                    ZeroMemory(&sockIn, sizeof(SOCKADDR_IN));
                    hr = GetIpAddress(szHostName, &sockIn);

                    if (SUCCEEDED(hr))
                    {
                        nAddr = sockIn.sin_addr.s_addr;
                        wsprintf(szHeaders, c_szSubsHeaderFmt, INET_NTOA(nAddr),
                                 c_nPort, c_szNotifyUri, c_csecTimeout);
                    }
                }
                else if (SSR_UNSUBSCRIBE == essrt)
                {
                    wsprintf(szHeaders, c_szUnSubsHeaderFmt, szSid);
                }

                TraceTag(ttidEvents, "Sending request to %s/%s:%d",
                         szHostName, szUrlPath, urlComp.nPort);
                TraceTag(ttidEvents, "Sending %s request:",
                         essrt == SSR_SUBSCRIBE ? "subscription" :
                         essrt == SSR_RESUBSCRIBE ? "re-subscription" :
                         essrt == SSR_UNSUBSCRIBE ? "unsubscribe" : "Unknown!");
                TraceTag(ttidEvents, "-----------------------------");
                TraceTag(ttidEvents, "%s", szHeaders);
                TraceTag(ttidEvents, "-----------------------------");

                if (SUCCEEDED(hr))
                {
                    hr = HrHttpSendRequestA(hinR, szHeaders, -1, NULL, 0);
                }

                if (SUCCEEDED(hr))
                {
                    LPTSTR  szTimeout = NULL;
                    LPTSTR  szServer = NULL;
                    DWORD   dwStatus;

                    hr = HrHttpQueryStatusCode(hinR, &dwStatus);
                    if (SUCCEEDED(hr) &&
                        (dwStatus == HTTP_STATUS_OK) &&
                        (SSR_UNSUBSCRIBE != essrt))
                    {
                        // First get the server header. We don't care what's
                        // in it, just that it was present
                        //
                        hr = HrQueryHeader(hinR, c_szServer, &szServer);
                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidEvents, "Server header contained: %s",
                                     szServer);

                            // Get the SID and Timeout headers from the response
                            //
                            hr = HrQueryHeader(hinR, c_szTimeout, &szTimeout);
                            if (SUCCEEDED(hr))
                            {
                                *pcsecTimeout = DwParseTime(szTimeout);

                                TraceTag(ttidEvents, "Subscribe response has %d for "
                                         "Timeout", *pcsecTimeout);

                                if (essrt == SSR_RESUBSCRIBE)
                                {
                                    LPTSTR  szSidNew = NULL;

                                    Assert(szSid);

                                    // Handle re-subscription response

                                    hr = HrQueryHeader(hinR, c_szSid, &szSidNew);
                                    if (SUCCEEDED(hr))
                                    {
                                        AssertSz(!lstrcmpi(szSidNew, szSid),
                                                 "SID from re-subscribe response isn't "
                                                 "the same!");

                                        TraceTag(ttidEvents, "Resubscribe response has %s for "
                                                 "SID", szSidNew);

                                        free(szSidNew);
                                    }
                                }
                                else
                                {
                                    // Handle subscription response

                                    Assert(pszSidOut);

                                    hr = HrQueryHeader(hinR, c_szSid, pszSidOut);
                                    if (SUCCEEDED(hr))
                                    {
                                        TraceTag(ttidEvents, "Subscribe response has %s for "
                                                 "SID", *pszSidOut);

                                    }
                                }

                                if (FAILED(hr))
                                {
                                    TraceTag(ttidEvents, "Didn't get SID header from "
                                             "subscription response!");
                                }

                                free(szTimeout);
                            }

                            free(szServer);
                        }
                    }
                    else
                    {
                        if (SUCCEEDED(hr) && dwStatus != HTTP_STATUS_OK)
                        {
                            TraceTag(ttidError, "HrSendSubscriptionRequest - Received the following error code (%d)", dwStatus);
                            hr = E_FAIL;
                        }
                    }
                }

                HrInternetCloseHandle(hinR);
            }

            HrInternetCloseHandle(hinC);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceError("HrSendSubscriptionRequest", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\receivedata.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R E C E I V E D A T A . H
//
//  Contents:   Queue of received data from network
//
//  Notes:
//
//  Author:     mbend   17 Dec 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "upsync.h"
#include "winsock2.h"

class CReceiveDataManager;

class CReceiveData
{
private:
    friend class CReceiveDataManager;

    CReceiveData(char * szData, SOCKET sock, BOOL fIsTcpSocket, BOOL fMCast, SOCKADDR_IN * psockAddrInRemote);
    ~CReceiveData();
    CReceiveData(const CReceiveData &);
    CReceiveData & operator=(const CReceiveData &);

    CReceiveData * m_pNext;
    char * m_szData;
    SOCKET m_sock;
    SOCKADDR_IN m_sockAddrInRemote;

    BOOL m_fIsTcpSocket;
    BOOL m_fMCast;
};

class CReceiveDataManager
{
public:
    ~CReceiveDataManager();

    static CReceiveDataManager & Instance();

    HRESULT HrAddData(char * szData, SOCKET sock, BOOL fMCast, SOCKADDR_IN * psockAddrInRemote);
    HRESULT HrInitialize();
    HRESULT HrShutdown();
private:
    CReceiveDataManager();
    CReceiveDataManager(const CReceiveDataManager &);
    CReceiveDataManager & operator=(const CReceiveDataManager &);

    static CReceiveDataManager s_instance;

    static DWORD WINAPI ThreadFunc(void *);
    DWORD ThreadMember();
    void ProcessReceiveBuffer(CReceiveData * pData);

    CUCriticalSection m_critSec;
    CReceiveData * m_pHead;
    CReceiveData * m_pTail;
    HANDLE m_hEventShutdown;
    HANDLE m_hEventWork;
    HANDLE m_hThread;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\rundown.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R U N D O W N . C P P
//
//  Contents:   RPC rundown support
//
//  Notes:
//
//  Author:     mbend   12 Nov 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "rundown.h"

CSsdpRundownSupport CSsdpRundownSupport::s_instance;

CSsdpRundownSupport::CSsdpRundownSupport()
{
}

CSsdpRundownSupport::~CSsdpRundownSupport()
{
    CLock lock(m_critSec);
    RundownList::Iterator iter;
    if(S_OK == m_rundownList.GetIterator(iter))
    {
        CRundownHelperBase ** ppBase = NULL;
        while(S_OK == iter.HrGetItem(&ppBase))
        {
            delete *ppBase;
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }
    m_rundownList.Clear();
}

CSsdpRundownSupport & CSsdpRundownSupport::Instance()
{
    return s_instance;
}

void CSsdpRundownSupport::RemoveRundownItem(void * pvItem)
{
    CRundownHelperBase * pBase = NULL;
    {
        CLock lock(m_critSec);
        RundownList::Iterator iter;
        if(S_OK == m_rundownList.GetIterator(iter))
        {
            CRundownHelperBase ** ppBase = NULL;
            while(S_OK == iter.HrGetItem(&ppBase))
            {
                if((*ppBase)->IsMatch(pvItem))
                {
                    pBase = *ppBase;
                    iter.HrErase();
                    break;
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }
    if(pBase)
    {
        delete pBase;
    }
}

void CSsdpRundownSupport::DoRundown(void * pvItem)
{
    CRundownHelperBase * pBase = NULL;
    {
        CLock lock(m_critSec);
        RundownList::Iterator iter;
        if(S_OK == m_rundownList.GetIterator(iter))
        {
            CRundownHelperBase ** ppBaseIter = NULL;
            while(S_OK == iter.HrGetItem(&ppBaseIter))
            {
                if((*ppBaseIter)->IsMatch(pvItem))
                {
                    pBase = *ppBaseIter;
                    iter.HrErase();
                    break;
                }
                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }
    if(pBase)
    {
        pBase->OnRundown();
        delete pBase;
        TraceTag(ttidSsdpRpcIf, "Rundown called for %p", pvItem);
    }
}

HRESULT CSsdpRundownSupport::HrAddItemInternal(CRundownHelperBase * pBase)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);
    hr = m_rundownList.HrPushFrontTransfer(pBase);

    TraceHr(ttidError, FAL, hr, FALSE, "CSsdpRundownSupport::HrAddItemInternal");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\rundown.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       R U N D O W N . H 
//
//  Contents:   RPC rundown support
//
//  Notes:      
//
//  Author:     mbend   12 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "upsync.h"
#include "ulist.h"

class CRundownHelperBase
{
public:
    virtual ~CRundownHelperBase() {}
    // Called on RPC disconnect
    virtual void OnRundown() = 0;
    // Do we match a RPC context handle
    virtual BOOL IsMatch(void * pvItem) = 0;
};

template <class Type>
class CRundownHelper : public CRundownHelperBase
{
public:
    CRundownHelper(Type * pType) : m_pType(pType) {}
    CRundownHelper(const CRundownHelper & ref) : m_pType(ref.m_pType) {}
    CRundownHelper & operator=(const CRundownHelper & ref)
    {
        if(this != &ref)
        {
            m_pType = ref.m_pType;
        }
        return *this;
    }
    void OnRundown()
    {
        // Type must have a static void Type::OnRundown(Type *) method
        Type::OnRundown(m_pType);
    }
    BOOL IsMatch(void * pvItem)
    {
        return m_pType == pvItem;
    }
private:

    Type * m_pType;
};

class CSsdpRundownSupport
{
public:
    ~CSsdpRundownSupport();

    static CSsdpRundownSupport & Instance();

    template <class Type> HRESULT HrAddRundownItem(Type * pType)
    {
        HRESULT hr = S_OK;
        CRundownHelperBase * pBase = new CRundownHelper<Type>(pType);
        if(!pBase)
        {
            return E_OUTOFMEMORY;
        }
        return HrAddItemInternal(pBase);
    }
    void RemoveRundownItem(void * pvItem);
    void DoRundown(void * pvItem);
private:
    CSsdpRundownSupport();
    CSsdpRundownSupport(const CSsdpRundownSupport &);
    CSsdpRundownSupport & operator=(const CSsdpRundownSupport &);

    HRESULT HrAddItemInternal(CRundownHelperBase * pBase);

    static CSsdpRundownSupport s_instance;

    typedef CUList<CRundownHelperBase*> RundownList;

    CUCriticalSection m_critSec;
    RundownList m_rundownList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\search.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S E A R C H . C P P
//
//  Contents:   SSDP Search Response
//
//  Notes:
//
//  Author:     mbend   10 Nov 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "search.h"
#include "ssdpfunc.h"
#include "ncbase.h"
#include "announce.h"

// response ahead 1 second
#define RESPONSE_AHEAD 0.5

CSsdpSearchResponse::CSsdpSearchResponse()
: m_timer(*this), m_szResponse(NULL)
{
}

CSsdpSearchResponse::~CSsdpSearchResponse()
{
    delete [] m_szResponse;
    m_szResponse = NULL;
}

HRESULT CSsdpSearchResponse::HrCreate(SOCKET * pSockLocal,
                                      SOCKADDR_IN * pSockRemote,
                                      char * szResponse, long nMX)
{
    HRESULT hr = S_OK;

    CSsdpSearchResponse * pResponse = new CSsdpSearchResponse();
    if(!pResponse)
    {
        delete [] szResponse;
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pResponse->HrInitialize(pSockLocal, pSockRemote, szResponse, nMX);
        if(SUCCEEDED(hr))
        {
            long nDelay = pResponse->CalculateDelay();

            TraceTag(ttidSsdpSearchResp, "CSsdpSearchResponse::HrCreate - "
                     "timer started for %d", nDelay);

            hr = pResponse->m_timer.HrSetTimer(nDelay);
        }
        else
        {
            delete [] szResponse;
        }

        if(FAILED(hr))
        {
            delete pResponse;
        }
    }

    TraceHr(ttidSsdpSearchResp, FAL, hr, FALSE, "CSsdpSearchResponse::HrCreate");
    return hr;
}

HRESULT CSsdpSearchResponse::HrInitialize(
    SOCKET * pSockLocal,
    SOCKADDR_IN * pSockRemote,
    char * szResponse,
    long nMX)
{
    HRESULT hr = S_OK;

    m_sockLocal = *pSockLocal;
    m_sockRemote = *pSockRemote;
    m_nMX = nMX;
    m_szResponse = szResponse;

    TraceHr(ttidSsdpSearchResp, FAL, hr, FALSE, "CSsdpSearchResponse::HrInitialize");
    return hr;
}

long CSsdpSearchResponse::CalculateDelay()
{
    // Range = (ResponseEntry->MX - 0);
    float nRange = (float)m_nMX;
    long nDelay;

    if (nRange > RESPONSE_AHEAD)
    {
        nRange -= RESPONSE_AHEAD;
        nDelay = (long)((rand() * nRange / RAND_MAX) * 1000.0);
    }
    else
    {
        nDelay = 0;
    }
    return nDelay;
}

void CSsdpSearchResponse::TimerFired()
{
    HRESULT hr = S_OK;

    if (FReferenceSocket(m_sockLocal))
    {
        SocketSendWithReplacement(m_szResponse, &m_sockLocal, &m_sockRemote);
        UnreferenceSocket(m_sockLocal);
    }

    TraceTag(ttidSsdpSearchResp, "Sending search response: %s", m_szResponse);

    // This will queue ourselves to autodelete
    hr = HrStart(TRUE, FALSE);

    TraceHr(ttidSsdpSearchResp, FAL, hr, FALSE, "CSsdpSearchResponse::TimerFired");
}

DWORD CSsdpSearchResponse::DwRun()
{
    // Must lock and queue work item to free ourselves or timer stuff will AV
    CLock lock(m_critSec);
    m_timer.HrDelete(INVALID_HANDLE_VALUE);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\search.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S E A R C H . H
//
//  Contents:   SSDP Search Response
//
//  Notes:
//
//  Author:     mbend   10 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "timer.h"
#include "ssdpnetwork.h"
#include "ssdptypes.h"
#include "upthread.h"
#include "upsync.h"

class CSsdpSearchResponse : public CThreadBase
{
public:
    static HRESULT HrCreate(SOCKET * pSockLocal,
                            SOCKADDR_IN * pSockRemote,
                            char * szResponse, long nMX);

    void TimerFired();
    BOOL TimerTryToLock()
    {
        return m_critSec.FTryEnter();
    }
    void TimerUnlock()
    {
        m_critSec.Leave();
    }
private:
    CSsdpSearchResponse();
    ~CSsdpSearchResponse();
    CSsdpSearchResponse(const CSsdpSearchResponse &);
    CSsdpSearchResponse & operator=(const CSsdpSearchResponse &);

    HRESULT HrInitialize(
        SOCKET * pSockLocal,
        SOCKADDR_IN * pSockRemote,
        char * szResponse,
        long nMX);

    long CalculateDelay();
    DWORD DwRun();

    CTimer<CSsdpSearchResponse> m_timer;
    long m_nMX;
    CUCriticalSection m_critSec;
    SOCKET m_sockLocal;
    SOCKADDR_IN m_sockRemote;
    char * m_szResponse;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdptimer\test\test494.cpp ===
#include    "windows.h"
#include    "ssdptimer.h"
#include    "ncdefine.h"
#include    "ncdebug.h"

#include    "stdio.h"

CTEBlockStruc	BlockStruct;

void
TimerFunc1 (CTETimer *Timer, void *Arg)
{
	DWORD	ExpectedTick = (DWORD)Arg;

	printf ("Expected Tick = %d Tick = %d, Difference=%d\r\n",
			ExpectedTick, GetTickCount(), GetTickCount() - ExpectedTick);

}

void
TimerFunc2 (CTETimer *Timer, void *Arg)
{
	DWORD	ExpectedTick = (DWORD)Arg;

	printf ("Expected Tick = %d Tick = %d, Difference=%d\r\n",
			ExpectedTick, GetTickCount(), GetTickCount() - ExpectedTick);

	// Signal the blocked thread.
	CTESignal (&BlockStruct, 0);
}

void
_cdecl main ()
{
	CTETimer	Timer1;
    CTETimer    Timer2; 

	ULONGLONG	TimeOut;
	int			i;

	if (!CTEInitialize()) {
		printf ("Unable to initialize CTE\r\n");
	}
	
	InitializeDebugging(); 

	// Initialize the timer.
	CTEInitTimer(&Timer1);
    CTEInitTimer(&Timer2); 

	// Initialize the Blocking Structure.
	CTEInitBlockStruc (&BlockStruct);

    TimeOut = 4320000000;
    CTEStartTimer (&Timer1, TimeOut, TimerFunc2,
                   (void *)(GetTickCount()+TimeOut));

    TimeOut = 60000; 
    CTEStartTimer (&Timer2, TimeOut, TimerFunc1,
                   (void *)(GetTickCount()+TimeOut));


    CTEBlock (&BlockStruct);

    CTEFinish(); 

    printf("Finish testing\n"); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\server.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

File Name:

    server.c

Abstract:

    This file contains code which implements rpc server start and stop.

Author: Ting Cai

Created: 07/10/1999

--*/


#include <pch.h>
#include "ssdp.h"
#include "status.h"
#include "ssdpfunc.h"
#include "ssdptypes.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "event.h"
#include "ncinet.h"
#include "eventsrv.h"
#include "iphlpapi.h"
#include "announce.h"
#include "notify.h"
#include "search.h"
#include "cache.h"
#include "ReceiveData.h"
#include "InterfaceList.h"
#include "ReceiveData.h"
#include "InterfaceHelper.h"

#define SSDP_MSG_MAX_THROTTLE_SIZE  16384

/*********************************************************************/
/*                 Global vars for debugging                         */
/*********************************************************************/

// To-Do: Auto-restart the ssdpsrv.exe.

// Updated through interlocked exchange
static LONG bRegisteredIf = 0;
// static long bRegisteredEp = 0;
LONG bShutdown = 0;
HANDLE ShutDownEvent = NULL;
HWND hWnd = NULL;
SOCKET g_socketTcp;
HANDLE      g_hAddrChange = NULL;
OVERLAPPED  g_ovAddrChange = {0};
HANDLE      g_hEventAddrChange = NULL;
HANDLE      g_hAddrChangeWait = NULL;

static const CHAR c_szWindowClassName[] = "SSDP Server Window";

HWND SsdpCreateWindow();
LRESULT CALLBACK SsdpWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID RunMessageLoop();

VOID NTAPI InterfaceChange(PVOID pvContext, BOOLEAN fFlag)
{
    DWORD   dwStatus;
    HWND    hwnd = (HWND)pvContext;

    TraceTag(ttidSsdpNetwork, "InterfaceChange called!!!!!!!");

    ResetNetworkList(hwnd);

    dwStatus = NotifyAddrChange(&g_hAddrChange, &g_ovAddrChange);

    if (dwStatus != ERROR_SUCCESS && dwStatus != ERROR_IO_PENDING)
    {
        TraceTag(ttidSsdpNetwork, "NotifyAddrChange returned %d",
                 dwStatus);
    }
}

BOOL FRegisterAddrChange(HWND hwnd)
{
    DWORD       dwStatus;
    BOOL        fResult = FALSE;

    TraceTag(ttidSsdpNetwork, "RegisterAddrChange() entered...");

    g_hEventAddrChange = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (g_hEventAddrChange)
    {
        if (RegisterWaitForSingleObject(&g_hAddrChangeWait, g_hEventAddrChange,
                                        InterfaceChange, (LPVOID)hwnd, INFINITE, 0))
        {

            TraceTag(ttidSsdpNetwork, "RegisterWaitForSingleObject() "
                     "succeeded...");

            g_ovAddrChange.hEvent = g_hEventAddrChange;

            dwStatus = NotifyAddrChange(&g_hAddrChange, &g_ovAddrChange);

            if (dwStatus != ERROR_SUCCESS && dwStatus != ERROR_IO_PENDING)
            {
                TraceTag(ttidSsdpNetwork, "NotifyAddrChange returned %d",
                         dwStatus);
            }
            else
            {
                fResult = TRUE;

                TraceTag(ttidSsdpNetwork, "NotifyAddrChange succeeded",
                         dwStatus);
            }
        }
    }

    return fResult;
}

VOID UnregisterAddrChange()
{
    if (g_hAddrChangeWait)
    {
        UnregisterWait(g_hAddrChangeWait);
    }

    if (g_hEventAddrChange)
    {
        CloseHandle(g_hEventAddrChange);
    }
}

INT SsdpMain(SERVICE_STATUS_HANDLE ssHandle, LPSERVICE_STATUS pStatus)
{
    TraceTag(ttidSsdpRpcIf, "SsdpMain - Enter");

    unsigned long hThread;

#ifdef DBG
    InitializeDebugging();
#endif

    // Initialize data structures

    HRESULT hr = S_OK;

    InitializeListNetwork();
    InitializeListOpenConn();

    hr = CTimerQueue::Instance().HrInitialize();
    if(FAILED(hr))
    {
        TraceHr(ttidSsdpRpcIf, FAL, hr, FALSE, "SsdpMain - CTimerQueue::Instance().HrInitialize failed");
        goto cleanup;
    }

    hr = CInterfaceHelper::Instance().HrInitialize();
    if(FAILED(hr))
    {
        goto cleanup;
    }

    hr = CUPnPInterfaceList::Instance().HrInitialize();
    if(FAILED(hr))
    {
        goto cleanup;
        TraceHr(ttidSsdpRpcIf, FAL, hr, FALSE, "SsdpMain - CUPnPInterfaceList::Instance().HrInitialize failed");
    }

    // SSDP socket initialization

    if (SocketInit() != 0)
    {
        TraceTag(ttidError, "SsdpMain - SocketInit failed");
        goto cleanup;
    }

    g_socketTcp = CreateHttpSocket();
    if (g_socketTcp == INVALID_SOCKET)
    {
        TraceTag(ttidError, "SsdpMain - CreateHttpSocket failed");
        // Should we continue without eventing?
        goto cleanup;
    }

    if (RpcServerStart() != 0)
    {
        TraceTag(ttidError, "SsdpMain - RpcServerStart failed");
        goto cleanup;
    }

    hr = CReceiveDataManager::Instance().HrInitialize();
    if(FAILED(hr))
    {
        TraceHr(ttidSsdpRpcIf, FAL, hr, FALSE, "SsdpMain - CReceiveDataManager::Instance().HrInitialize failed");
        RpcServerStop();
        goto cleanup;
    }
    // Initializes Max Cache Entries
    hr = CSsdpCacheEntryManager::Instance().HrInitialize();
    if(FAILED(hr))
    {
        TraceHr(ttidSsdpRpcIf, FAL, hr, FALSE, "SsdpMain - CSsdpCacheEntryManager::Instance().HrInitialize failed");
        RpcServerStop();
        goto cleanup;
    }

    hWnd = SsdpCreateWindow();
    if (hWnd == NULL)
    {
        TraceTag(ttidError, "SsdpMain - SsdpCreateWindow failed");
        RpcServerStop();
        goto cleanup;
    }

    if (ListenOnAllNetworks(hWnd) != 0)
    {
        TraceTag(ttidError, "SsdpMain - ListenOnAllNetworks failed");
        RpcServerStop();
        goto cleanup;
    }

    if (StartHttpServer(g_socketTcp, hWnd, SM_TCP) != 0)
    {
        TraceTag(ttidError, "SsdpMain - StartHttpServer failed");
        RpcServerStop();
        goto cleanup;
    }

    if (!FRegisterAddrChange(hWnd))
    {
        TraceTag(ttidError, "SsdpMain - FRegisterAddrChange failed");
        RpcServerStop();
        goto cleanup;
    }

    TraceTag(ttidSsdpRpcIf, "SsdpMain - Performed initialization");

    pStatus->dwCurrentState = SERVICE_RUNNING;
    if (SetServiceStatus(ssHandle, pStatus) == FALSE)
    {
        TraceTag(ttidError, "SsdpMain - SetServiceStatus failed");
        RpcServerStop();
        goto cleanup;
    }

    TraceTag(ttidSsdpRpcIf, "SSDPSRV service is now started");

    RunMessageLoop();

    TraceTag(ttidSsdpRpcIf, "SsdpMain - Doing shutdown");

    RpcServerStop();

    UnregisterAddrChange();

    TraceTag(ttidSsdpRpcIf, "Waiting for the shut down event.");

    if (ShutDownEvent)
    {
        WaitForSingleObject(ShutDownEvent,INFINITE);
    }

    TraceTag(ttidSsdpRpcIf, "Shut down event signaled.");

cleanup:
    TraceTag(ttidSsdpRpcIf, "SsdpMain - Doing cleanup");

    CReceiveDataManager::Instance().HrShutdown();
    CleanupHttpSocket();
    CleanupListOpenConn();
    CSsdpCacheEntryManager::Instance().HrShutdown();
    CTimerQueue::Instance().HrShutdown(INVALID_HANDLE_VALUE);
    CUPnPInterfaceList::Instance().HrShutdown();
    CInterfaceHelper::Instance().HrShutdown();

    CleanupListNetwork(FALSE);

    SocketFinish();

    TraceTag(ttidSsdpRpcIf, "Finished shutdown cleanup.");

#ifdef DBG
    // CloseLogFileHandle(fileLog);
    UnInitializeDebugging();
#endif // DBG

    if (ShutDownEvent)
    {
        CloseHandle(ShutDownEvent);
        ShutDownEvent = NULL;
    }

#ifdef NEVER
    if (g_hInetSess)
    {
        InternetCloseHandle(g_hInetSess);
    }
#endif

    if (hWnd)
    {
        DestroyWindow(hWnd);
        hWnd = NULL;
    }
    UnregisterClass(c_szWindowClassName, NULL);

    return 0;
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

VOID __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

VOID __RPC_USER midl_user_free(VOID __RPC_FAR * ptr)
{
    free(ptr);
}

BOOL
IsAuthenticatedUser()
{
	BOOL 	fAuthenticated = FALSE;
	DWORD	dwSidSize = SECURITY_MAX_SID_SIZE;
	SID* 	pSidAuthenticated = (SID*)midl_user_allocate(dwSidSize);

	if (NULL == pSidAuthenticated)
	{
		goto Cleanup;
	}
	
	//
	// create SID for the authenticated users
	//
	if (!CreateWellKnownSid(WinAuthenticatedUserSid,
						NULL,					// not a domain sid
						pSidAuthenticated,
						&dwSidSize))
	{
		// check the error for debug builds, normally we don't care about the error
		// because all we can do is to fail the call :)
	#ifdef DBG
		HRESULT hr = (HRESULT)GetLastError();
	#endif
		goto Cleanup;
	}
	
	//
	// check whether current client token has this sid
	//
	if (!CheckTokenMembership(NULL, 			//current token
							pSidAuthenticated,	// sid for the authenticated user					
							&fAuthenticated))
	{
		// check the error for debug builds, normally we don't care about the error
		// because all we can do is to fail the call :)
	#ifdef DBG
		HRESULT hr = (HRESULT)GetLastError();
	#endif

		// just to be on the safe side (as we don't know that CheckTokenMembership
		// does not modify fAuthenticated in case of error)
		fAuthenticated = FALSE;

		goto Cleanup;
	}

Cleanup:
	if (pSidAuthenticated)
		midl_user_free(pSidAuthenticated);

	return fAuthenticated;
	
}

BOOL
IsAnonymousUser()
{
	BOOL 	fAnonymous = FALSE;
	DWORD	dwSidSize = SECURITY_MAX_SID_SIZE;
	SID* 	pSidAnonymous= (SID*)midl_user_allocate(dwSidSize);

	if (NULL == pSidAnonymous)
	{
		goto Cleanup;
	}
	
	//
	// create SID for the authenticated users
	//
	if (!CreateWellKnownSid(WinAnonymousSid,
						NULL,					// not a domain sid
						pSidAnonymous,
						&dwSidSize))
	{
		// check the error for debug builds, normally we don't care about the error
		// because all we can do is to fail the call :)
	#ifdef DBG
		HRESULT hr = (HRESULT)GetLastError();
	#endif

		goto Cleanup;
	}
	
	//
	// check whether current client token has this sid
	//
	if (!CheckTokenMembership(NULL, 			//current token
							pSidAnonymous,	// sid for the authenticated user					
							&fAnonymous))
	{
		// check the error for debug builds, normally we don't care about the error
		// because all we can do is to fail the call :)
	#ifdef DBG
		HRESULT hr = (HRESULT)GetLastError();
	#endif

		// just to be on the safe side (as we don't know that CheckTokenMembership
		// does not modify fAnonymous in case of error)
		fAnonymous = FALSE;

		goto Cleanup;
	}

Cleanup:
	if (pSidAnonymous)
		midl_user_free(pSidAnonymous);

	return fAnonymous;
	
}


RPC_STATUS RPC_ENTRY
RpcSecurityCallback( RPC_IF_HANDLE* handle, void* pCtx)
{
	RPC_STATUS 			status = RPC_S_OK;
	UINT				uiTransportType = 0;
	ULONG				ulAuthLevel = 0;
	ULONG				ulAuthSvc = 0;
	BOOL				fImpersonated = FALSE;
	
	//
	// check to make sure incoming call comes through LRPC
	//
	status = I_RpcBindingInqTransportType(NULL, 	// current caller
										&uiTransportType);
	if (status)
		goto Cleanup;

	if (TRANSPORT_TYPE_LPC != uiTransportType)
	{
		status = RPC_S_ACCESS_DENIED;
		goto Cleanup;
	}

	//
	// retrieve client's authentication information
	//
	status = RpcBindingInqAuthClient(NULL, 		// current call
									NULL,		// don't care about authz handle
									NULL,		// don't need client' principal name, as he is local
									&ulAuthLevel, 
									&ulAuthSvc, 
									NULL);
	if (status)
		goto Cleanup;

	//
	// we require packet privacy (encryption and signing).  with lrpc
	// it is set by default, but still, the check is simple
	//
	if (!(RPC_C_AUTHN_LEVEL_PKT_PRIVACY & ulAuthLevel))
	{
		status = RPC_S_ACCESS_DENIED;
		goto Cleanup;
	}

	//
	// client used some kind of authentication service
	//
	if (RPC_C_AUTHN_NONE == ulAuthSvc)
	{
		status = RPC_S_ACCESS_DENIED;
		goto Cleanup;
	}

	//
	// impersonate, in order to check caller's token
	//
	status = RpcImpersonateClient(NULL);
	if (status)
		goto Cleanup;

	fImpersonated = TRUE;

	//
	// check whether this is an authenticated user (client)
	//
	if (!IsAuthenticatedUser())
	{
		status = RPC_S_ACCESS_DENIED;
		goto Cleanup;
	}

	//
	// do a separate check for the anonymous user
	// (even though i am not sure whether it is applicable for LRPC)
	//
	if (IsAnonymousUser())
	{
		status = RPC_S_ACCESS_DENIED;
		goto Cleanup;
	}

				
Cleanup:
	if (fImpersonated)
		RpcRevertToSelf();

	//
	// this routine is expected to return either success (RPC_S_OK) or
	// RPC_S_ACCESS_DENIED, so all other erros should be masked
	//
	
	if (status != RPC_S_OK)
		status = RPC_S_ACCESS_DENIED;
	
	return status;
}
	

INT RpcServerStart()
{
    RPC_STATUS 				status = RPC_S_OK;
    BOOL       				fRegisteredRpc = FALSE;
    RPC_BINDING_VECTOR* 	pBindingVector = NULL;

	//
	// analyze all existing networks available.
	//
    status = GetNetworks();
    if (status)
    	goto Error;
    
	//
	// create the event, to be used to synchronize shutdown
	//
    ShutDownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (ShutDownEvent == NULL)
    {
        TraceTag(ttidSsdpRpcInit, "Failed to create shut down event (%d)",
                 GetLastError());
        goto Error;
    }

	//
	// now, start the RPC interface
	//

    //
    // Use LPC protocol sequence
    //
    status = RpcServerUseProtseq((unsigned char*)"ncalrpc", 
    							RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
    							NULL);
    if (status)
    	goto Error;

	//
	// use NTLM or kerberos
	//
	status = RpcServerRegisterAuthInfo(NULL,
									RPC_C_AUTHN_GSS_NEGOTIATE, 
									NULL, 
									NULL);
	if (status)
		goto Error;

	//
	// register our interface, 
	// RPC_IF_ALLOW_SECURE_ONLY - to allow only users with authentication level higher than 
	//								RPC_C_AUTHN_LEVEL_NONE, even though it is 
	// 								unnecessary, as it is superceeded by the security callback
	// RPC_IF_AUTOLISTEN - start listening on the interface as soon as interface is registred and 
	// 						and stops listening as soon as interface is unregistered
	//
    status = RpcServerRegisterIfEx(_ssdpsrv_v1_0_s_ifspec,
                                NULL,   // MgrTypeUuid
                                NULL, 	// MgrEpv; null means use default
                                RPC_IF_ALLOW_SECURE_ONLY | RPC_IF_AUTOLISTEN, 
                                RPC_C_LISTEN_MAX_CALLS_DEFAULT, 
                                (RPC_IF_CALLBACK_FN*)RpcSecurityCallback);  
	if (status)
		goto Error;

	//
	// get the list of available bindings
	//
	status = RpcServerInqBindings(&pBindingVector);
	if (status)
		goto Error;

	//
	// register all the endpoints with the map database
	//
	status = RpcEpRegister(_ssdpsrv_v1_0_s_ifspec, 
						pBindingVector, 
						NULL, 
						NULL);			// no annotation
	if (status)
		goto Error;

	// if we reached this point, everything must have registered successfully
	// so we should mark that
    fRegisteredRpc = TRUE;

	TraceTag(ttidSsdpRpcInit, "RPC server is started");

Cleanup:
	if (pBindingVector)
		RpcBindingVectorFree(&pBindingVector);
		
    return status;

Error:
	TraceTag(ttidSsdpRpcInit, "StartRpcServer failed (%x)", status);

    //
    // don't cleanup everything, as all this globl stuff, like ShutdownEvent
    // is expected to be cleaned from the SsdpMain.
    // Rpc is the only stuff that needs to be cleaned up
    //

    if (fRegisteredRpc)
    {
        RpcServerStop();
    }

    goto Cleanup;
}

// Unregister RPC interface, endpoint and close the file if necessary.

INT RpcServerStop()
{
	RPC_STATUS status = RPC_S_OK;

	status = RpcServerUnregisterIfEx(_ssdpsrv_v1_0_s_ifspec, 
									NULL, 				// MgrTypeUuid
									1);					// call rundown now

    TraceTag(ttidSsdpRpcStop, "Leaving RpcServerStop");

    return status;
}

VOID ProcessSsdpRequest(PSSDP_REQUEST pSsdpRequest, RECEIVE_DATA *pData)
{
    // Ensure that the socket is in the network list before attempting to
    // get its name
    //

    if (pData->fIsTcpSocket || FReferenceSocket(pData->socket))
    {
        sockaddr_in     addr;
        int             nSize = sizeof(addr);

        getsockname(pData->socket, reinterpret_cast<sockaddr*>(&addr), &nSize);

        CInterfaceHelper::Instance().HrResolveAddress(addr.sin_addr.S_un.S_addr,
                                                      pSsdpRequest->guidInterface);
        if (!pData->fIsTcpSocket)
        {
            UnreferenceSocket(pData->socket);
        }
    }
    else
    {
        FreeSsdpRequest(pSsdpRequest);
        return;
    }

    if (!pData->fIsTcpSocket && !pData->fMCast && pSsdpRequest->Method != SSDP_M_SEARCH)
    {
        FreeSsdpRequest(pSsdpRequest);
        return;
    }

    if (pSsdpRequest->Method == SSDP_M_SEARCH)
    {

        if (0 == lstrcmpA(pSsdpRequest->RequestUri, "*"))
        {
            TraceTag(ttidSsdpSocket, "Searching for ST (%s)",
                     pSsdpRequest->Headers[SSDP_ST]);
            CSsdpServiceManager::Instance().HrAddSearchResponse(pSsdpRequest,
                                                                &pData->socket,
                                                                &pData->RemoteSocket);
        }
        else
        {
            TraceTag(ttidSsdpSocket, "Not searching for ST, since URI != '*' (URI='%s')",
                     pSsdpRequest->RequestUri);
        }
    }
    else if (pSsdpRequest->Method == SSDP_NOTIFY)
    {

        TraceTag(ttidSsdpSocket, "Receive notification of type (%s)",
                 pSsdpRequest->Headers[SSDP_NT]);


        if (!lstrcmpi(pSsdpRequest->Headers[SSDP_NTS], "upnp:propchange"))
        {
            if(pSsdpRequest->Headers[GENA_SID])
            {
                TraceTag(ttidEvents, "ProcessSsdpRequest - upnp:propchange - SID:%s", pSsdpRequest->Headers[GENA_SID]);
            }
            CSsdpNotifyRequestManager::Instance().HrCheckListNotifyForEvent(pSsdpRequest);

            if (pData->fIsTcpSocket || FReferenceSocket(pData->socket))
            {
                SocketSend(OKResponseHeader, pData->socket, NULL);

                if (!pData->fIsTcpSocket)
                {
                    UnreferenceSocket(pData->socket);
                }
            }
        }
        else if (!lstrcmpi(pSsdpRequest->Headers[SSDP_NTS], "ssdp:alive") ||
                 !lstrcmpi(pSsdpRequest->Headers[SSDP_NTS], "ssdp:byebye"))
        {
            BOOL IsSubscribed;

            // preserve source address if possible.
            // hack here where we use szSID to hold address
            // this should not be used for alive normally.
            if (pSsdpRequest->Headers[GENA_SID] == NULL)
            {
                char* pszIp = GetSourceAddress(pData->RemoteSocket);
                pSsdpRequest->Headers[GENA_SID] = (CHAR *) midl_user_allocate(
                                                        sizeof(CHAR) * (strlen(pszIp) + 1));
                if (pSsdpRequest->Headers[GENA_SID])
                {
                    strcpy(pSsdpRequest->Headers[GENA_SID], pszIp);
                }
            }

            // We only cache notification that clients has subscribed.
            IsSubscribed = CSsdpNotifyRequestManager::Instance().FIsAliveOrByebyeInListNotify(pSsdpRequest);

            CSsdpCacheEntryManager::Instance().HrUpdateCacheList(pSsdpRequest, IsSubscribed);
        }
        else
        {
            // unrecognized NTS type
        }

        // SsdpMessage fields are freed when clean up cache entry.
        // FreeSsdpRequest(pSsdpRequest);
    }
    else
    {
        TraceTag(ttidSsdpSocket, "Unrecognized SSDP request.");
    }
    FreeSsdpRequest(pSsdpRequest);
}

VOID RunMessageLoop()
{
    MSG msg;

    while (GetMessage(&msg, 0, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    TraceTag(ttidSsdpRpcInit, "Message loop is done");
}

HWND SsdpCreateWindow()
{
    WNDCLASS WndClass;
    HWND hwnd;

    //
    // Register the window class.
    //

    WndClass.style = 0;
    WndClass.lpfnWndProc = SsdpWindowProc;
    WndClass.cbClsExtra = 0;
    WndClass.cbWndExtra = 0;
    WndClass.hInstance = NULL;
    WndClass.hIcon = NULL;
    WndClass.hCursor = NULL;
    WndClass.hbrBackground = NULL;
    WndClass.lpszMenuName = NULL;
    WndClass.lpszClassName = c_szWindowClassName;

    if (!RegisterClass(&WndClass))
    {
        TraceTag(ttidSsdpRpcInit, "RegisterClassEx failed.");
        return NULL;
    }

    //
    // Create the window.
    //

    hwnd = CreateWindow(
                       c_szWindowClassName,
                       "",
                       WS_OVERLAPPEDWINDOW,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       CW_USEDEFAULT,
                       NULL,
                       NULL,
                       NULL,
                       NULL
                       );

    if (hwnd == NULL)
    {
        TraceTag(ttidSsdpRpcInit, "CreateWindow failed.");
        return NULL;
    }

    TraceTag(ttidSsdpRpcInit, "Created window %x", hwnd);

    ShowWindow(hwnd, SW_HIDE);
    UpdateWindow(hwnd);

    return hwnd;
}

LRESULT CALLBACK SsdpWindowProc(
                               HWND hwnd,
                               UINT msg,
                               WPARAM wParam,
                               LPARAM lParam
                               )

/*++

Routine Description:

    Window message dispatch procedure for our hidden window.

Arguments:

    hwnd - The target window handle.

    msg - The current message.

    wParam - WPARAM value.

    lParam - LPARAM value.

Return Value:

    LRESULT - The result of the message.

--*/

{
    LRESULT Result = 0;
    INT EventCode;
    INT ErrorCode;
    SOCKET Socket;
    CHAR * szData;
    CHAR * szTcpData;
    SOCKADDR_IN RemoteSocket;
    DWORD cbBuffSize = 0;
    BOOL    bMCast;

    switch (msg)
    {
    case SM_SSDP:
        Socket = (SOCKET) wParam;
        EventCode = WSAGETSELECTEVENT(lParam);
        ErrorCode = WSAGETSELECTERROR(lParam);

        switch (EventCode)
        {
            case FD_READ:
                if (FReferenceSocket(Socket))
                {
                    cbBuffSize = 0;
                    if (SocketReceive(Socket, &szData, &cbBuffSize, &RemoteSocket, TRUE, &bMCast) == TRUE)
                    {
                        if(cbBuffSize <= SSDP_MSG_MAX_THROTTLE_SIZE )
                        {
                            CReceiveDataManager::Instance().HrAddData( 
                                                                    szData,
                                                                    Socket,
                                                                    bMCast,
                                                                    reinterpret_cast<SOCKADDR_IN*>(&RemoteSocket));
                        }
                        else
                        {
                            // Typical SSDP MSG is less than 1K. If its greater than 16K we suspect a Buffer flood attack.
                            free(szData);
                            TraceTag(ttidSsdpRpcInit, "Received SSDP Msg more than 16k");
                        }
                    }

                    UnreferenceSocket(Socket);
                }
            break;
        }
        break;

    case SM_TCP:
        Socket = (SOCKET) wParam;
        EventCode = WSAGETSELECTEVENT(lParam);
        ErrorCode = WSAGETSELECTERROR(lParam);

        switch (EventCode)
        {
        case FD_READ:
            DWORD   cbBuffer;

            if (SocketReceive(Socket, &szTcpData, &cbBuffer,
                              &RemoteSocket, FALSE, &bMCast) == TRUE)
            {
                RECEIVE_DATA *  pData = NULL;
                pData = (RECEIVE_DATA *)malloc(sizeof(RECEIVE_DATA));
                if (pData)
                {
                    CopyMemory(&pData->RemoteSocket, &RemoteSocket,
                               sizeof(SOCKADDR_IN));
                    pData->socket = Socket;
                    pData->szBuffer = szTcpData;
                    pData->cbBuffer = cbBuffer;
                    pData->fIsTcpSocket = TRUE;
                    pData->fMCast = FALSE;

                    QueueUserWorkItem(LookupListOpenConn, pData, 0);
                }
                else
                {
                    TraceError("Couldn't allocate sufficient memory!",
                               E_OUTOFMEMORY);
                }
            }
            break;

        case FD_ACCEPT:

            TraceTag(ttidSsdpRpcInit, "Ready to accept connection");

            HandleAccept(Socket);

            break;

        case FD_CLOSE:

            // To-Do: Do I need to call recv to make sure all available data are read?

            TraceTag(ttidSsdpRpcInit, "Closing socket %d", Socket);
            closesocket(Socket);
            RemoveOpenConn(Socket);
        }

        break;

    case WM_QUERYENDSESSION:

        TraceTag(ttidSsdpRpcInit, "Received WM_QUERYENDSESSION message");
        if (!(lParam & ENDSESSION_LOGOFF))
        {
            TraceTag(ttidSsdpRpcInit, "System is shutting down");
        }
        Result = TRUE;

        break;

    default:
        //
        // Pass it through.
        //

        Result = DefWindowProc( hwnd, msg, wParam, lParam );
        break;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdpsrv\ssdprpc.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

File Name:

    ssdprpc.c

Abstract:

    This file contains code which implements SSDPSRV.exe rpc interfaces.

Author: Ting Cai

Created: 07/10/1999

--*/

#include <pch.h>
#pragma hdrstop

#include "ssdperror.h"
#include "ssdpsrv.h"
#include "status.h"
#include "ssdpfunc.h"
#include "ssdptypes.h"
#include "ssdpnetwork.h"
#include "ncbase.h"
#include "ncinet.h"
#include "event.h"
#include <limits.h>
#include "announce.h"
#include "search.h"
#include "cache.h"
#include "notify.h"
#include "InterfaceList.h"

extern LONG bShutdown;
extern HANDLE ShutDownEvent;
extern HWND hWnd;

// Publication

INT _RegisterServiceRpc(PCONTEXT_HANDLE_TYPE *pphContext,
                        SSDP_MESSAGE ssdpMsg, DWORD flags)
{
    if (!pphContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (ssdpMsg.szUSN == NULL || ssdpMsg.szType == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (ssdpMsg.szAltHeaders == NULL && ssdpMsg.szLocHeader == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    HRESULT hr = S_OK;
    hr = CSsdpServiceManager::Instance().HrAddService(
        &ssdpMsg, flags, pphContext);

    return hr;
}

INT _DeregisterServiceRpc(PCONTEXT_HANDLE_TYPE *pphContext, BOOL fByebye)
{
    CSsdpService * pService = *reinterpret_cast<CSsdpService**>(pphContext);

    HRESULT hr = CSsdpServiceManager::Instance().HrRemoveService(pService, fByebye);
    *pphContext = NULL;

    return hr;
}

INT _DeregisterServiceRpcByUSN(
                              /* [string][in] */ LPSTR szUSN,
                              /* [in] */ BOOL fByebye)
{
    HRESULT hr = E_INVALIDARG;

    CSsdpService * pService = CSsdpServiceManager::Instance().FindServiceByUsn(szUSN);
    if(pService)
    {
        hr = CSsdpServiceManager::Instance().HrRemoveService(pService, fByebye);
    }

    return hr;
}
// Cache

VOID _UpdateCacheRpc(PSSDP_REQUEST CandidateRequest)
{
    SSDP_REQUEST SsdpRequest;

    if (CandidateRequest)
    {
        InitializeSsdpRequest(&SsdpRequest);

        CopySsdpRequest(&SsdpRequest, CandidateRequest);

        ConvertToAliveNotify(&SsdpRequest);

        CSsdpCacheEntryManager::Instance().HrUpdateCacheList(&SsdpRequest, TRUE);

        FreeSsdpRequest(&SsdpRequest);
    }
}

/*
VOID _LookupCacheRpc(
     [size_is][length_is][out][in]  unsigned char __RPC_FAR pBuffer[  ],
     [in] LONG lAllocatedSize,
     [out][in] LONG __RPC_FAR *plUsedSize)
{

}
*/

INT _LookupCacheRpc(
                   /* [string][in] */ LPSTR szType,
                   /* [out] */ MessageList __RPC_FAR *__RPC_FAR *svcList)
{
    if (!szType || !*szType || !svcList)
    {
        TraceError("Bad parameter to _LookupCacheRpc", E_INVALIDARG);
        return -1;
    }

    return CSsdpCacheEntryManager::Instance().HrSearchListCache(szType, svcList);
}

VOID _CleanupCacheRpc()
{
    CSsdpCacheEntryManager::Instance().HrShutdown();
}


// Notification

// Initialize the synchronization handle
INT _InitializeSyncHandle(PCONTEXT_HANDLE_TYPE *pphContextSync)
{

    if (!pphContextSync)
    {
        return ERROR_INVALID_PARAMETER;
    }

    HANDLE Temp =  CreateSemaphore(NULL, 0, LONG_MAX, NULL);

    if (Temp != NULL)
    {
        TraceTag(ttidSsdpNotify, "Created semaphore. %x", Temp);
        *pphContextSync = Temp;
        return 0;
    }
    else
    {
        TraceTag(ttidSsdpNotify, "Failed to create sephamore %d", GetLastError());
        *pphContextSync = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }
}

VOID _RemoveSyncHandle( PCONTEXT_HANDLE_TYPE *pphContextSync)
{
    if (!pphContextSync)
    {
        return;
    }

    HANDLE Temp = *pphContextSync;

    CSsdpNotifyRequestManager::Instance().HrRemoveNotifyRequest(Temp);

    TraceTag(ttidSsdpNotify, "Closing semaphore %x", Temp);
    CloseHandle(Temp);

    *pphContextSync = NULL;
}

INT _RegisterNotificationRpc(
                            /* [out] */ PCONTEXT_HANDLE_TYPE __RPC_FAR *pphContext,
                            /* [in] */ PSYNC_HANDLE_TYPE phContextSync,
                            /* [in] */ NOTIFY_TYPE nt,
                            /* [string][unique][in] */ LPSTR szType,
                            /* [string][unique][in] */ LPSTR szEventUrl,
                            /* [out] */ SSDP_REGISTER_INFO __RPC_FAR *__RPC_FAR *ppinfo)
{
    HRESULT                 hr = S_OK;

    if (!pphContext || !phContextSync || !ppinfo)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pphContext = NULL;

    if (NOTIFY_ALIVE == nt)
    {
        hr = CSsdpNotifyRequestManager::Instance().HrCreateAliveNotifyRequest(pphContext, szType, reinterpret_cast<HANDLE*>(phContextSync));
    }
    else if (NOTIFY_PROP_CHANGE == nt)
    {
        hr = CSsdpNotifyRequestManager::Instance().HrCreatePropChangeNotifyRequest(pphContext, szEventUrl, reinterpret_cast<HANDLE*>(phContextSync), ppinfo);
    }
    else
    {
        hr = ERROR_INVALID_PARAMETER;
    }

    return HRESULT_CODE(hr);
}

INT _GetNotificationRpc(PCONTEXT_HANDLE_TYPE phContextSync, MessageList **svcList)
{
    if (!phContextSync || !svcList)
    {
        return ERROR_INVALID_PARAMETER;
    }

    TraceTag(ttidSsdpNotify, "Waiting on notification semaphore %x", phContextSync);

    HANDLE  rgHandles[2];
    DWORD   dwRet;
    HRESULT hr = S_OK;

    rgHandles[0] = phContextSync;
    rgHandles[1] = ShutDownEvent;

    dwRet = WaitForMultipleObjects(2, rgHandles, FALSE, INFINITE);

    TraceTag(ttidSsdpNotify, "Semaphore %x released", phContextSync);

    if (WAIT_OBJECT_0 == dwRet)
    {
        hr = CSsdpNotifyRequestManager::Instance().HrRetreivePendingNotification(reinterpret_cast<HANDLE*>(phContextSync), svcList);
    }
    else
    {
        AssertSz(dwRet == WAIT_OBJECT_0 + 1, "Wait on semaphore satisfied for "
                 "some other reason!");
        TraceTag(ttidSsdpNotify, "Semaphore released because server is "
                 "shutting down...");
    }

#if DBG

    if(svcList && *svcList)
    {
        if(0 == (*svcList)->size)
        {
            TraceTag(ttidSsdpNotify, "_GetNotificationRpc - HrRetreivePendingNotification returned nothing - must be in shutdown");
        }
        else if(1 == (*svcList)->size)
        {
            SSDP_REQUEST * pRequest = (*svcList)->list;
            if(pRequest->Headers[SSDP_NTS] && !lstrcmpiA(pRequest->Headers[SSDP_NTS], "upnp:propchange"))
            {
                TraceTag(ttidSsdpNotify, "_GetNotificationRpc - upnp:propchange - SEQ:%s - SID:%s", pRequest->Headers[GENA_SEQ], pRequest->Headers[GENA_SID]);
            }
            else if(pRequest->Headers[SSDP_NTS] && !lstrcmpiA(pRequest->Headers[SSDP_NTS], "ssdp:alive"))
            {
                TraceTag(ttidSsdpNotify, "_GetNotificationRpc - ssdp:alive - NT:%s", pRequest->Headers[SSDP_NT]);
            }
        }
    }

#endif // DBG

    return hr;
}

INT _WakeupGetNotificationRpc(PCONTEXT_HANDLE_TYPE phContextSync)
{
    LONG PreviousCount = 0;

    if (!phContextSync)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (ReleaseSemaphore(phContextSync, 1, &PreviousCount) == TRUE)
    {
        TraceTag(ttidSsdpNotify, "Released Semaphore %x by 1, Previous count "
                 "is %d", phContextSync, PreviousCount);
        return 0;
    }
    else
    {
        TraceTag(ttidSsdpNotify, "Failed to release semaphore %x, error code "
                 "%d", phContextSync, GetLastError());
        return GetLastError();
    }
}

INT _DeregisterNotificationRpc(PCONTEXT_HANDLE_TYPE *pphContext, BOOL fLast)
{
    CSsdpNotifyRequest * pRequest = *reinterpret_cast<CSsdpNotifyRequest**>(pphContext);
    INT ret = CSsdpNotifyRequestManager::Instance().HrRemoveNotifyRequestByPointer(pRequest);

    *pphContext = NULL;
    return ret;
}

void _EnableDeviceHost()
{
    CUPnPInterfaceList::Instance().HrSetGlobalEnable();
}

void _DisableDeviceHost()
{
    CUPnPInterfaceList::Instance().HrClearGlobalEnable();
}

void _SetICSInterfaces(/*[in]*/ long nCount, /*[in, size_is(nCount)]*/ GUID * arInterfaces)
{
    CUPnPInterfaceList::Instance().HrSetICSInterfaces(nCount, arInterfaces);
}

void _SetICSOff()
{
    CUPnPInterfaceList::Instance().HrSetICSOff();
}

VOID _Shutdown(VOID)
{
    // Set network and announcemnt state ?


    TraceTag(ttidSsdpRpcIf, "Shutdown is called.");

    // T-Cleanup

    // Sleep(15000); // 15 seconds

    // T-Clean expires

    // Temporary testing

    // WriteListCacheToFile();

    InterlockedIncrement(&bShutdown);

    if (PostMessage(hWnd, WM_QUIT, 0, 0) == FALSE)
    {
        TraceTag(ttidSsdpRpcInit, "PostThreadMessage failed with %d", GetLastError());
    }
    else
    {
        TraceTag(ttidSsdpRpcInit, "PostThreadMessage was successful", GetLastError());
    }

    TraceTag(ttidSsdpRpcInit, "Setting shut down event");

    if (SetEvent(ShutDownEvent) == 0)
    {

        TraceTag(ttidSsdpRpcInit, "Failed to set shut down event (%d)", GetLastError());

    }
    // Cleanup will continue in main.
}

VOID __RPC_USER PCONTEXT_HANDLE_TYPE_rundown( PCONTEXT_HANDLE_TYPE pContext)
{
	if (pContext)
	{
	    CSsdpRundownSupport::Instance().DoRundown(pContext);
	}
}

VOID __RPC_USER PSYNC_HANDLE_TYPE_rundown( PCONTEXT_HANDLE_TYPE pContext)
{
    TraceTag(ttidSsdpRpcIf, "rundown routine is called on sync context %x.",pContext);

    if (pContext)
    {
        _RemoveSyncHandle(&pContext);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdptimer\test\testcxpt.cpp ===
#include    "windows.h"
#include    "ssdptimer.h"
#include    "ncdefine.h"
#include    "ncdebug.h"

#include    "stdio.h"

CTEBlockStruc	BlockStruct;

void
TimerFunc (CTETimer *Timer, void *Arg)
{
	DWORD	ExpectedTick = (DWORD)Arg;

	printf ("Expected Tick = %d Tick = %d, Difference=%d\r\n",
			ExpectedTick, GetTickCount(), GetTickCount() - ExpectedTick);

	// Signal the blocked thread.
	CTESignal (&BlockStruct, 0);
}
void
_cdecl main ()
{
	CTETimer	Timer;
	DWORD		TimeOut;
	int			i;

	if (!CTEInitialize()) {
		printf ("Unable to initialize CTE\r\n");
	}
	
	InitializeDebugging(); 

	// Initialize the timer.
	CTEInitTimer(&Timer);

	// Initialize the Blocking Structure.
	CTEInitBlockStruc (&BlockStruct);

	for (i=1; i < 400000; i++) {
		TimeOut = i*100;
		CTEStartTimer (&Timer, TimeOut, TimerFunc,
					   (void *)(GetTickCount()+TimeOut));

		if (i % 2) {
			CTEBlock (&BlockStruct);
		} else {
			// Let's try to cancel the timer.
			if (CTEStopTimer (&Timer)) {
				printf ("Timer stopped successfully\r\n");
				Sleep (TimeOut + 1000);
				printf ("Should not have seen the Expected Tick message.\r\n");
			} else {
				printf ("Unable to stop timer\r\n");
			}
		}
	
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\list.h ===
//  copied from winnt.h and wdm.h in winnt platform sdk

#ifndef _SSDPLIST_
#define _SSDPLIST_
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

//  LIST_ENTRY and SINGLE_LIST_ENTRY are defined in winnt.h
/*
typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;
*/

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

/*
typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
*/

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // _SSDPLIST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdptimer\timer.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       T I M E R . C P P
//
//  Contents:   Timer queue helper class
//
//  Notes:
//
//  Author:     mbend   3 Nov 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "timer.h"
#include "ncdefine.h"
#include "ncbase.h"


CTimerQueue CTimerQueue::s_instance;

CTimerQueue::CTimerQueue() : m_hTimerQueue(NULL), m_nRefCount(0)
{
}

CTimerQueue::~CTimerQueue()
{
    if (!m_hTimerQueue)
    {
        TraceError("CTimerQueue::~CTimerQueue", E_FAIL);
    }
}

CTimerQueue & CTimerQueue::Instance()
{
    return s_instance;
}

HRESULT CTimerQueue::HrInitialize()
{
    CLock lock(m_critSec);

    ++m_nRefCount;

    if(m_nRefCount > 1)
    {
        return S_OK;
    }

    HRESULT hr = S_OK;
    m_hTimerQueue = CreateTimerQueue();
    if(!m_hTimerQueue)
    {
        hr = HrFromLastWin32Error();
    }
    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerQueue::HrInitialize");
    return hr;
}

HRESULT CTimerQueue::HrShutdown(HANDLE hCompletionEvent)
{
    HRESULT hr = S_OK;

    HANDLE hTimerQueue = NULL;

    {
        CLock lock(m_critSec);

        if(!m_nRefCount)
        {
            hr = E_UNEXPECTED;
            TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerQueue::HrShutdown - Can't call SsdpCleanup without calling SsdpStartup");
        }

        if(SUCCEEDED(hr))
        {
            --m_nRefCount;
            if(!m_nRefCount)
            {
                Assert(m_hTimerQueue);
                hTimerQueue = m_hTimerQueue;
                m_hTimerQueue = NULL;
            }
        }
    }

    if(SUCCEEDED(hr) && hTimerQueue)
    {
        if(!DeleteTimerQueueEx(hTimerQueue, hCompletionEvent))
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerQueue::HrShutdown");
    return hr;
}

HRESULT CTimerQueue::HrGetHandle(HANDLE * phTimerQueue)
{
    CLock lock(m_critSec);

    HRESULT hr = S_OK;

    if(phTimerQueue)
    {
        *phTimerQueue = m_hTimerQueue;
    }
    else
    {
        hr = E_POINTER;
    }

    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerQueue::HrGetHandle");
    return hr;
}

#ifdef DBG
long CTimerBase::s_nCallbackEnter = 0;
long CTimerBase::s_nCallbackExit = 0;
#endif // DBG

CTimerBase::CTimerBase() : m_bShutdown(FALSE), m_hTimerQueueTimer(NULL)
{
#ifdef DBG
    m_nSetTimer = 0;
    m_nSetTimerSuccess = 0;
    m_nDeleteTimer = 0;
    m_nDeleteTimerActual = 0;
    m_nTimerFiredEnter = 0;
    m_nTimerFiredExit = 0;
    m_nCallbackEnter = 0;
#endif // DBG
}

CTimerBase::~CTimerBase()
{
    HRESULT hr = S_OK;
    if(m_hTimerQueueTimer)
    {
        HANDLE hTimerQueue = NULL;
        hr = CTimerQueue::Instance().HrGetHandle(&hTimerQueue);
        if(SUCCEEDED(hr))
        {
            if(!DeleteTimerQueueTimer(hTimerQueue, m_hTimerQueueTimer, NULL))
            {
                hr = HrFromLastWin32Error();
            }
            else
            {
                m_hTimerQueueTimer = NULL;
            }
        }
    }
}

HRESULT CTimerBase::HrSetTimer(
    DWORD dwIntervalInMillis)
{
    HRESULT hr = E_FAIL;

    CLock lock(m_critSec);

    Assert(!m_hTimerQueueTimer);

#ifdef DBG
    InterlockedIncrement(&m_nSetTimer);
#endif // DBG


    // Check for shutdown
    if(!m_bShutdown)
    {
        HANDLE hTimerQueue = NULL;
        hr = CTimerQueue::Instance().HrGetHandle(&hTimerQueue);
        if(SUCCEEDED(hr))
        {
            if(!CreateTimerQueueTimer(&m_hTimerQueueTimer, hTimerQueue, &CTimerBase::Callback, this, dwIntervalInMillis, 0, 0))
            {
                hr = HrFromLastWin32Error();
            }
        }
    }

#ifdef DBG
    if(SUCCEEDED(hr))
    {
        InterlockedIncrement(&m_nSetTimerSuccess);
    }
#endif // DBG

    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerBase::HrSetTimer");
    return hr;
}

HRESULT CTimerBase::HrSetTimerInFired(
    DWORD dwIntervalInMillis)
{
    HRESULT hr = E_FAIL;

    CLock lock(m_critSec);
    if(!m_bShutdown)
    {
        if(m_hTimerQueueTimer)
        {
            HrDelete(NULL);
            m_bShutdown = FALSE;
        }
        hr = HrSetTimer(dwIntervalInMillis);
    }

    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerBase::HrSetTimerInFired");
    return hr;
}

HRESULT CTimerBase::HrDelete(HANDLE hCompletionEvent)
{
    HRESULT hr = S_OK;

#ifdef DBG
    InterlockedIncrement(&m_nDeleteTimer);
#endif // DBG


    HANDLE hTimerQueueTimer = NULL;
    {
        CLock lock(m_critSec);

        m_bShutdown = TRUE;

        hTimerQueueTimer = m_hTimerQueueTimer;
        m_hTimerQueueTimer = NULL;
    }

    if(hTimerQueueTimer)
    {
        HANDLE hTimerQueue = NULL;
        hr = CTimerQueue::Instance().HrGetHandle(&hTimerQueue);
        if(SUCCEEDED(hr))
        {
            if(!DeleteTimerQueueTimer(hTimerQueue, hTimerQueueTimer, hCompletionEvent))
            {
                hr = HrFromLastWin32Error();
                if (HRESULT_FROM_WIN32(ERROR_IO_PENDING) == hr)
                {
                    hr = S_OK;
                }
            }
#ifdef DBG
            if(SUCCEEDED(hr))
            {
                InterlockedIncrement(&m_nDeleteTimerActual);
            }
#endif // DBG

        }
    }
    else
    {
        if(hCompletionEvent != NULL && hCompletionEvent != INVALID_HANDLE_VALUE)
        {
            SetEvent(hCompletionEvent);
        }
    }

    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerBase::HrDelete");
    return hr;
}

HRESULT CTimerBase::HrResetTimer(
    DWORD dwIntervalInMillis)
{
    HRESULT hr = S_OK;

    // Can't hold lock during whole operation or this can deadlock waiting for timer to exit
    HrDelete(INVALID_HANDLE_VALUE);
    m_bShutdown = FALSE;
    hr = HrSetTimer(dwIntervalInMillis);

    TraceHr(ttidSsdpTimer, FAL, hr, FALSE, "CTimerBase::HrResetTimer");
    return hr;
}

void CALLBACK CTimerBase::Callback(void * pvParam, BOOLEAN)
{
    CTimerBase * pTimer = reinterpret_cast<CTimerBase*>(pvParam);

#ifdef DBG
    InterlockedIncrement(&s_nCallbackEnter);
    InterlockedIncrement(&pTimer->m_nCallbackEnter);
#endif // DBG


    while(true)
    {
        CLock lock(pTimer->m_critSec);
        if(pTimer->m_bShutdown)
        {
            break;
        }
        if(pTimer->OnTryToLock())
        {
            pTimer->OnExecute();
            pTimer->OnUnlock();
            break;
        }
        Sleep(1);
    }

#ifdef DBG
    InterlockedIncrement(&s_nCallbackExit);
#endif // DBG
}

VOID FileTimeToString(FILETIME FileTime, CHAR *szBuf, INT BufSize)
{
    SYSTEMTIME SystemTime;
    INT Size;

    FileTimeToLocalFileTime(&FileTime, &FileTime);

    FileTimeToSystemTime(&FileTime,&SystemTime);

    Size = GetDateFormatA(LOCALE_SYSTEM_DEFAULT, 0, &SystemTime, NULL,
                          szBuf, BufSize-1 );

    if (Size > 0)
    {
        szBuf[Size-1] = ' ';
    }

    GetTimeFormatA(LOCALE_SYSTEM_DEFAULT, 0, &SystemTime, NULL,
                   szBuf+Size, BufSize-Size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\ssdperror.h ===
#define SSDP_ERROR_BASE 18000
#define ERROR_NO_MORE_SERVICES SSDP_ERROR_BASE+1
#define ERROR_TIMER_START_FAILED SSDP_ERROR_BASE+2
#define ERROR_DUPLICATE_SERVICE SSDP_ERROR_BASE+3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\common.h ===
#include <winuser.h>

#define SSDP_ADDR "239.255.255.250"
#define SSDP_PORT 1900
#define SSDP_ADDR_PORT "239.255.255.250:1900"
#define NUM_RETRIES 3
#define RETRY_INTERVAL 3000
#define SM_SSDP WM_USER+1
#define SM_TCP WM_USER+2
#undef ASSERT
#define ASSERT assert
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\common\ssdptimer\test\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Timer Test EXE"
#define VER_INTERNALNAME_STR            "testtimer.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\ssdptypes.h ===
#ifndef _SSDPTYPES_
#define _SSDPTYPES_

#include <windef.h>
#include <winsock2.h>
#include <wchar.h>
#include <malloc.h>
#include <time.h>
#include <assert.h>

#include "ssdp.h"
#include "list.h"
#include "ssdpparser.h"
#include "common.h"

typedef struct _RECEIVE_DATA
{
    SOCKET socket;
    CHAR *szBuffer;
    DWORD cbBuffer;
    SOCKADDR_IN RemoteSocket;
    BOOL fIsTcpSocket;
    BOOL fMCast;
} RECEIVE_DATA;

struct SSDP_RESPONSE_TIMER_DATA
{
    LPTSTR  szUsn;
    DWORD   dwEntryKey;
};

#endif // _SSDPTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\ssdpsrv.h ===
#include <wininet.h>

extern HINTERNET g_hInetSess;

INT SsdpMain(SERVICE_STATUS_HANDLE ssHandle, LPSERVICE_STATUS pStatus);

#ifdef __cplusplus
extern "C" {
#endif

VOID _Shutdown(VOID);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\event.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V E N T . H
//
//  Contents:   Private eventing functions
//
//  Notes:
//
//  Author:     danielwe   14 Oct 1999
//
//----------------------------------------------------------------------------

#include <wininet.h>

//
// Controlled Device structures
//

struct _UPNP_EVENT_SOURCE;

typedef struct _EVENT_SOURCE_PROPERTY
{
    BOOL            fModified;
    UPNP_PROPERTY   prop;
} ES_PROPERTY;

typedef struct _UPNP_EVENT_SOURCE
{
    LIST_ENTRY          linkage;
    LPTSTR              szRequestUri;       // URI that identifies subscriptions
                                            // SUBSCRIBE and UNSUBSCRIBE to
    DWORD               cProps;             // Number of properties supported
                                            // by the event source
    ES_PROPERTY *       rgesProps;          // List of properties
    LIST_ENTRY          listSubs;           // List of subscribers
    CRITICAL_SECTION    cs;
    BOOL                fCleanup;
} UPNP_EVENT_SOURCE;

// Type of subscription request to send
typedef enum _ESSR_TYPE
{
    SSR_SUBSCRIBE,
    SSR_RESUBSCRIBE,
    SSR_UNSUBSCRIBE,
} ESSR_TYPE;

HRESULT HrSendSubscriptionRequest(HINTERNET hin,
                                  LPCTSTR szUrl,
                                  LPCTSTR szSid,
                                  DWORD *pcsecTimeout,
                                  LPTSTR *pszSidOut,
                                  ESSR_TYPE essrt);
BOOL FValidateUpnpProperty(UPNP_PROPERTY * pProp);
VOID CopyUpnpProperty(UPNP_PROPERTY * pPropDst, UPNP_PROPERTY * pPropSrc);
VOID FreeUpnpProperty(UPNP_PROPERTY * pPropSrc);
VOID FreeEventSource(UPNP_EVENT_SOURCE *pes);
VOID RemoveFromListEventSource(UPNP_EVENT_SOURCE *pes);
UPNP_EVENT_SOURCE * PesFindEventSource(LPCTSTR szRequestUri);
UPNP_EVENT_SOURCE * PesVerifyEventSource(UPNP_EVENT_SOURCE *pes);
VOID PrintListEventSource(LIST_ENTRY *pListHead);
VOID CleanupEventSourceEntry (UPNP_EVENT_SOURCE *pes);
VOID PrintEventSource(const UPNP_EVENT_SOURCE *pes);
BOOL FRemoveSubscriberFromRequest(SOCKET socket, SSDP_REQUEST * pRequest);

DWORD DwParseTime(LPCTSTR szTime);
BOOL FParseCallbackUrl(LPCTSTR szCallbackUrl, LPTSTR *pszOut);
VOID ComputeAbsoluteTime(DWORD csec, FILETIME * pft);
LPTSTR SzGetNewSid(VOID);

VOID MarkAllProperties(UPNP_EVENT_SOURCE *pes, BOOL fModified);
HRESULT HrSendInitialNotifyMessage(UPNP_EVENT_SOURCE *pes, DWORD dwFlags,
                                   LPCTSTR szSid, DWORD iSeq, LPCTSTR szDestUrl);
HRESULT HrSubmitUpnpPropertyEventToSubscriber(UPNP_EVENT_SOURCE *pes,
                                              DWORD dwFlags,
                                              LPCTSTR szSid, DWORD iSeq,
                                              LPCTSTR szDestUrl);
HRESULT HrSubmitEventToSubscriber(DWORD dwFlags,
                                  LPCTSTR szHeaders, LPCTSTR szEventBody,
                                  LPCTSTR szDestUrl);
BOOL FUpdateEventSourceWithProps(UPNP_EVENT_SOURCE *pes, DWORD cProps,
                                 UPNP_PROPERTY *rgProps);

extern LIST_ENTRY          g_listEventSource;
extern CRITICAL_SECTION    g_csListEventSource;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\ssdpparser.h ===
#ifndef _SSDPPARSER_
#define _SSDPPARSER_

#include "ssdp.h"

const CHAR OKResponseHeader[40] = "HTTP/1.1 200 OK\r\n\r\n";

BOOL InitializeSsdpRequest(SSDP_REQUEST *pRequest);

BOOL ComposeSsdpRequest(const SSDP_REQUEST *Source, CHAR **pszBytes);

BOOL FReplaceTokenInLocation(LPCSTR szIn, LPSTR szReplace, LPSTR *pszOut);

BOOL ComposeSsdpResponse(const SSDP_REQUEST *Source, CHAR **pszBytes);

BOOL ParseSsdpRequest(CHAR * szMessage, SSDP_REQUEST *Result);

BOOL ParseSsdpResponse(CHAR *szMessage, SSDP_REQUEST *Result);

char* ParseHeaders(CHAR *szMessage, SSDP_REQUEST *Result);

BOOL CompareSsdpRequest(const SSDP_REQUEST * pRequestA, const SSDP_REQUEST * pRequestB);

CHAR * ParseRequestLine(CHAR * szMessage, SSDP_REQUEST *Result);

VOID FreeSsdpRequest(SSDP_REQUEST *pSsdpRequest);

INT GetMaxAgeFromCacheControl(const CHAR *szValue);

VOID PrintSsdpRequest(const SSDP_REQUEST *pssdpRequest);

BOOL CopySsdpRequest(PSSDP_REQUEST Destination, const SSDP_REQUEST * Source);

BOOL ConvertToByebyeNotify(PSSDP_REQUEST pSsdpRequest);

BOOL ConvertToAliveNotify(PSSDP_REQUEST pSsdpRequest);

CHAR* IsHeadersComplete(const CHAR *szHeaders);

BOOL VerifySsdpHeaders(SSDP_REQUEST *Result);

BOOL HasContentBody(PSSDP_REQUEST Result);

BOOL ParseContent(const char *pContent, DWORD cbContent, SSDP_REQUEST *Result);

#endif // _SSDPPARSER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\ssdpnetwork.h ===
#include <winsock2.h>

#ifndef _SSDPNETWORK_
#define _SSDPNETWORK_

#define SSDP_NETWORK_SIGNATURE 0x1602
#define INET_NTOA(a)    inet_ntoa(*(struct in_addr*)&(a))

typedef enum _NetworkState {
    NETWORK_INIT,
    NETWORK_CLEANUP
} NetworkState, *PNetworkState;

typedef struct _SSDPNetwork {

   LIST_ENTRY linkage;

   INT Type;

   SOCKADDR_IN IpAddress;

   NetworkState state;

   SOCKET socket;

   DWORD dwIndex;

   LONG cRef;

} SSDPNetwork, *PSSDPNetwork;

typedef VOID (*RECEIVE_CALLBACK_FUNC)(CHAR *szBuffer, SOCKADDR_IN *RemoteSocket);

// network related functions.

VOID InitializeListNetwork();

INT GetNetworks();

HRESULT GetIpAddress(CHAR * szName, SOCKADDR_IN *psinLocal);

VOID ResetNetworkList(HWND hwnd);

VOID GetNetworkLock();

VOID FreeNetworkLock();

VOID CleanupListNetwork(BOOL fReset);

BOOL FIsSocketValid(SOCKET s);

BOOL FReferenceSocket(SOCKET s);

VOID UnreferenceSocket(SOCKET s);

VOID SendOnAllNetworks(CHAR *szAlive, SOCKADDR_IN *RemoteAddress);

VOID SocketSendWithReplacement(CHAR *szBytes, SOCKET * pSockLocal,
                               SOCKADDR_IN *pSockRemote);

INT ListenOnAllNetworks(HWND hWnd);

// socket related functions

INT SocketInit();

VOID SocketFinish();

// open the socket and bind
BOOL SocketOpen(SOCKET *psocketToOpen, PSOCKADDR_IN IpAddress, DWORD dwMulticastInterfaceIndex, BOOL fRecvMcast);

// close the socket
BOOL SocketClose(SOCKET socketToClose);

BOOL SocketReceive(SOCKET socket, CHAR **pszData, DWORD *pcbBuffer,
                   SOCKADDR_IN *fromSocket, BOOL fMCast, BOOL *pfGotMCast);

VOID SocketSend(const CHAR *szBytes, SOCKET socket, SOCKADDR_IN *RemoteAddress);

VOID SocketSendErrorResponse(SOCKET socket, DWORD dwErr);

LPSTR GetSourceAddress(SOCKADDR_IN fromSocket);

#ifdef NEVER
VOID SuspendListening();
#endif // NEVER

#endif // SSDPNETWORK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\ssdpfunc.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

File Name:

    ssdpfunc.h

Abstract:

    This file contains cross files function prototypes.

Author: Ting Cai

Created: 07/15/1999

--*/
#ifndef _SSDPFUNC_
#define _SSDPFUNC_

#include "ssdptypes.h"
#include "ssdpnetwork.h"

// list related functions
/*
VOID InitializeListAnnounce();

VOID CleanupListAnnounce();

BOOL FIsInListAnnounce(CHAR *szUSN);

SSDP_SERVICE *PsvcFindInListAnnounce(CHAR *szUSN);

PCONTEXT_HANDLE_TYPE *GetServiceByUSN(CHAR *szUSN);

VOID SearchListAnnounce(SSDP_REQUEST *SsdpMessage, SOCKADDR_IN *RemoveAddress);

PSSDP_SERVICE AddToListAnnounce(SSDP_MESSAGE *pssdpMsg, DWORD flags,
                                PCONTEXT_HANDLE_TYPE *pphContext);

VOID RemoveFromListAnnounce(SSDP_SERVICE *pssdpSvc);

VOID StartAnnounceTimer(SSDP_SERVICE *pssdpSvc, CTETimerRtn pCallback);

VOID StopAnnounceTimer(SSDP_SERVICE *pssdpSvc);

VOID SendAnnouncement(SSDP_SERVICE *pssdpService, SOCKET socket);

VOID SendByebye(SSDP_SERVICE *pssdpService, SOCKET socket);

VOID AnnounceTimerProc (CTETimer *Timer, VOID *Arg);

VOID ByebyeTimerProc (CTETimer *Timer, VOID *Arg);

VOID FreeSSDPService(SSDP_SERVICE *pSSDPSvc);
*/

// rpc related functions
INT RpcServerStart();

INT RpcServerStop();


// Parser
/*
BOOL ComposeSSDPNotify(SSDP_SERVICE *pssdpSvc, BOOL fAlive);
*/

/*
BOOL InitializeSearchResponseFromRequest(PSSDP_SEARCH_RESPONSE pSearchResponse,
                                         SSDP_REQUEST *SsdpRequest,
                                         SOCKADDR_IN *RemoveSocket);

VOID CALLBACK SearchResponseTimerProc (LPVOID pvParam, BOOL fTimedOut);

VOID StartSearchResponseTimer(PSSDP_SEARCH_RESPONSE ResponseEntry);

VOID RemoveFromListSearchResponse(PSSDP_SEARCH_RESPONSE ResponseEntry);

VOID CleanupAnnounceEntry (SSDP_SERVICE *pService);

VOID CleanupListSearchResponse(PLIST_ENTRY pListHead);

INT RegisterSsdpService ();
*/

// Cache

/*
VOID InitializeListCache();

VOID CleanupListCache();
VOID DestroyListCache();

BOOL UpdateListCache(SSDP_REQUEST *SsdpRequest, BOOL IsSubscribed);

INT SearchListCache(CHAR *szType, MessageList **svcList);

VOID InitializeListNotify();

VOID CleanupListNotify();

VOID AddToListNotify(PSSDP_NOTIFY_REQUEST NotifyRequest);

VOID RemoveFromListNotify(PSSDP_NOTIFY_REQUEST NotifyRequest);

PSSDP_NOTIFY_REQUEST CreateNotifyRequest(NOTIFY_TYPE nt, CHAR *szType,
                                         CHAR *szEventUrl,
                                         HANDLE NotifySemaphore);

VOID CheckListNotifyForEvent(SSDP_REQUEST *SsdpRequest);

VOID CheckListNotifyForAliveByebye(SSDP_REQUEST *SsdpRequest);

BOOL IsMatchingAliveByebye(PSSDP_NOTIFY_REQUEST pNotifyRequest,
                           SSDP_REQUEST *pSsdpRequest);

BOOL QueuePendingNotification(PSSDP_NOTIFY_REQUEST pNotifyRequest,
                              PSSDP_REQUEST pSsdpRequest);

BOOL IsAliveByebyeInListNotify(SSDP_REQUEST *SsdpRequest);

INT RetrievePendingNotification(HANDLE SyncHandle, MessageList **svcList);

VOID CleanupClientNotificationRequest(HANDLE SyncSemaphore);

VOID CheckListCacheForNotification(PSSDP_NOTIFY_REQUEST pNotifyRequest);

VOID FreeNotifyRequest(PSSDP_NOTIFY_REQUEST NotifyRequest);
*/

/*
VOID ProcessSsdpRequest(PSSDP_REQUEST pSsdpRequest, RECEIVE_DATA *pData);
*/

/*
VOID GetNotifyLock();

VOID FreeNotifyLock();
*/

#endif // _SSDPFUNC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\status.h ===
#ifndef _SSDPSTATUS_
#define _SSDPSTATUS_

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#ifdef DBG

#define ERROR_STR_SIZE 1025

#define SSDP_DEBUG_RPC_INIT    0x00000001
#define SSDP_DEBUG_RPC_STOP    0x00000002
#define SSDP_DEBUG_RPC_IF      0x00000004
#define SSDP_DEBUG_SOCKET      0x00000008
#define SSDP_DEBUG_ANNOUNCE    0x00000010
#define SSDP_DEBUG_NETWORK     0x00000020
#define SSDP_DEBUG_PARSER      0x00000040
#define SSDP_DEBUG_SEARCH_RESP 0x00000080
#define SSDP_DEBUG_SYS_SVC     0x00000100
#define SSDP_DEBUG_CACHE       0x00000200
#define SSDP_DEBUG_NOTIFY      0x00000400

// RPC Client
#define SSDP_DEBUG_C_RPC_INIT  0x00000800
#define SSDP_DEBUG_C_NOTIFY    0x00001000
#define SSDP_DEBUG_C_SEARCH    0x00002000
#define SSDP_DEBUG_C_PUBLISH   0x00004000

// 1MB
#define LOG_SIZE 1048576

#define EnterStatusToLog(flag, comment, status) { \
    if (LogLevel & (SSDP_DEBUG_ ## flag)) { \
            TCHAR szError[ERROR_STR_SIZE]; \
        int charWritten; \
        EnterCriticalSection(&CSLogFile); \
        FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, \
                          NULL, \
                          status, \
                          0, \
                          szError, \
                          ERROR_STR_SIZE, \
                          NULL); \
        charWritten = _ftprintf(fileLog, "%s %s", comment, szError); \
        LogSize += charWritten * sizeof(TCHAR); \
        if (LogSize > LOG_SIZE) { \
            CleanupLogFile(); \
        } \
                fflush(fileLog); \
        LeaveCriticalSection(&CSLogFile); \
    } \
}

#define EnterMsgToLog(flag, print) { \
    if (LogLevel & (SSDP_DEBUG_ ## flag)) { \
        int charWritten; \
        EnterCriticalSection(&CSLogFile); \
        charWritten = fwprintf print; \
        LogSize += charWritten * sizeof(wchar_t); \
        if (LogSize > LOG_SIZE) { \
            CleanupLogFile(); \
        } \
                fflush(fileLog); \
        LeaveCriticalSection(&CSLogFile); \
    } \
}

#else 

#define EnterMsgToLog(flag, print)

#define EnterStatusToLog(flag, comment, status)

#endif // DBG

#define ABORT_ON_FAILURE(status) \
        if (status != 0) {       \
            goto cleanup;   \
        }

extern unsigned long LogLevel;
extern FILE *fileLog;
extern CRITICAL_SECTION CSLogFile;
extern long LogSize;

void CleanupLogFile();
int OpenLogFileHandle(char * fileName);
void CloseLogFileHandle(FILE *fileLog);


#endif // _SSDPSTATUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\inc\timer.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       T I M E R . H
//
//  Contents:   Timer queue helper class
//
//  Notes:
//
//  Author:     mbend   2 Nov 2000
//
//----------------------------------------------------------------------------

#pragma once

#include "upsync.h"

#pragma warning(disable : 4355)

class CTimerQueue
{
public:
    ~CTimerQueue();

    static CTimerQueue & Instance();

    HRESULT HrInitialize();
    HRESULT HrShutdown(HANDLE hCompletionEvent);
    HRESULT HrGetHandle(HANDLE * phTimerQueue);
private:
    CTimerQueue();
    CTimerQueue(const CTimerQueue &);
    CTimerQueue & operator=(const CTimerQueue &);

    HANDLE m_hTimerQueue;
    CUCriticalSection m_critSec;
    volatile long m_nRefCount;

    static CTimerQueue s_instance;
};

class CTimerBase
{
public:
    CTimerBase();
    virtual ~CTimerBase();

    HRESULT HrSetTimer(
        DWORD dwIntervalInMillis);
    HRESULT HrSetTimerInFired(
        DWORD dwIntervalInMillis);
    HRESULT HrDelete(HANDLE hCompletionEvent);
    HRESULT HrResetTimer(
        DWORD dwIntervalInMillis);

protected:
    virtual void OnExecute() = 0;
    virtual BOOL OnTryToLock() = 0;
    virtual void OnUnlock() = 0;
private:
    CTimerBase(const CTimerBase &);
    CTimerBase & operator=(const CTimerBase &);

    static void CALLBACK Callback(void * pvParam, BOOLEAN);

    HANDLE m_hTimerQueueTimer;
    CUCriticalSection m_critSec;
    volatile BOOL m_bShutdown;

protected:
#ifdef DBG
    long m_nSetTimer;
    long m_nSetTimerSuccess;
    long m_nDeleteTimer;
    long m_nDeleteTimerActual;
    long m_nTimerFiredEnter;
    long m_nTimerFiredExit;
    long m_nCallbackEnter;

    static long s_nCallbackEnter;
    static long s_nCallbackExit;
#endif // DBG
};

template <class Type>
class CTimer : public CTimerBase
{
public:
    CTimer(Type & type) : m_type(type) {}
    ~CTimer() {}

    void OnExecute()
    {
#ifdef DBG
    InterlockedIncrement(&m_nTimerFiredEnter);
#endif // DBG

        m_type.TimerFired();

#ifdef DBG
    InterlockedIncrement(&m_nTimerFiredExit);
#endif // DBG
    }
    BOOL OnTryToLock()
    {
        return m_type.TimerTryToLock();
    }
    void OnUnlock()
    {
        m_type.TimerUnlock();
    }
private:
    CTimer(const CTimer &);
    CTimer & operator=(const CTimer &);

    Type & m_type;
};

inline ULONGLONG ULONGLONG_FROM_FILETIME(FILETIME ft)
{
    return (*((ULONGLONG *)&(ft)));
}

inline FILETIME FILETIME_FROM_ULONGLONG(ULONGLONG ll)
{
    return (*((FILETIME *)&(ll)));
}

VOID
FileTimeToString(FILETIME FileTime, CHAR *szBuf, INT BufSize);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\cache.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C A C H E . C P P
//
//  Contents:   Public APIs dealing with SSDP cache
//
//  Notes:
//
//  Author:     tongl   18 Jan 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "ssdpapi.h"
#include "common.h"
#include "ncdefine.h"
#include "ncdebug.h"

#include <rpcasync.h>   // I_RpcExceptionFilter

extern LONG cInitialized;

//+---------------------------------------------------------------------------
//
//  Function:   CleanupCache
//
//  Purpose:    Public API to clean up SSDP cache
//
BOOL WINAPI CleanupCache()
{
    ULONG   ulStatus = NOERROR;
    BOOL    fResult = FALSE;

    if (InterlockedExchange(&cInitialized, cInitialized) == 0)
    {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    RpcTryExcept
    {
        CleanupCacheRpc();
        fResult = TRUE;
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        ulStatus = RpcExceptionCode();
    }
    RpcEndExcept
    {
        SetLastError(ulStatus);
    }

    TraceResult("CleanupCache", fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\crt.cpp ===
// include upnp\common\upbase\ncmem.cpp to override the crt's
#include <..\..\common\upbase\ncmem.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\message.cpp ===
#include <pch.h>
#pragma hdrstop

#include "ssdpapi.h"
#include "common.h"
#include "ncdefine.h"
#include "ncdebug.h"
#include "ssdpparser.h"
#include "ncstring.h"

VOID PrintSsdpMessageList(MessageList *list)
{
    int i;

    TraceTag(ttidSsdpNotify, "Printing notification list.");

    for (i = 0; i < list->size; i++)
    {
        PrintSsdpRequest(list->list+i);
        TraceTag(ttidSsdpNotify, "--------");
    }
}

VOID WINAPI FreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage)
{
    if (pSsdpMessage)
    {
        free(pSsdpMessage->szAltHeaders);
        free(pSsdpMessage->szContent);
        free(pSsdpMessage->szLocHeader);
        free(pSsdpMessage->szSid);
        free(pSsdpMessage->szType);
        free(pSsdpMessage->szUSN);
        free(pSsdpMessage);
    }
}

BOOL InitializeSsdpMessageFromRequest(PSSDP_MESSAGE pSsdpMessage, const PSSDP_REQUEST pSsdpRequest)
{
    pSsdpMessage->guidInterface = pSsdpRequest->guidInterface;
    pSsdpMessage->szLocHeader = NULL;
    pSsdpMessage->szAltHeaders = NULL;
    pSsdpMessage->szType = NULL;
    pSsdpMessage->szUSN = NULL;
    pSsdpMessage->szContent = NULL;
    pSsdpMessage->szSid = NULL;
    pSsdpMessage->iLifeTime = 0;
    pSsdpMessage->iSeq = 0;

    if (pSsdpRequest->Headers[SSDP_NT] != NULL)
    {
        pSsdpMessage->szType = (char *) malloc(sizeof(char) * (strlen(pSsdpRequest->Headers[SSDP_NT]) + 1));
        if (pSsdpMessage->szType == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pSsdpMessage->szType, pSsdpRequest->Headers[SSDP_NT]);
        }
    }
    else if (pSsdpRequest->Headers[SSDP_ST] != NULL)
    {
        pSsdpMessage->szType = (char *) malloc(sizeof(char) * (strlen(pSsdpRequest->Headers[SSDP_ST]) + 1));
        if (pSsdpMessage->szType == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pSsdpMessage->szType, pSsdpRequest->Headers[SSDP_ST]);
        }
    }

    if (pSsdpRequest->Headers[SSDP_LOCATION] != NULL)
    {
        pSsdpMessage->szLocHeader = (char *) malloc(sizeof(char) * (strlen(pSsdpRequest->Headers[SSDP_LOCATION]) + 1));
        if (pSsdpMessage->szLocHeader == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pSsdpMessage->szLocHeader, pSsdpRequest->Headers[SSDP_LOCATION]);
        }
    }

    if (pSsdpRequest->Headers[SSDP_AL] != NULL)
    {
        pSsdpMessage->szAltHeaders = (char *) malloc(sizeof(char) * (strlen(pSsdpRequest->Headers[SSDP_AL]) + 1));
        if (pSsdpMessage->szAltHeaders == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pSsdpMessage->szAltHeaders, pSsdpRequest->Headers[SSDP_AL]);
        }
    }

    if (pSsdpRequest->Headers[SSDP_USN] != NULL)
    {
        pSsdpMessage->szUSN = (char *) malloc(sizeof(char) * (strlen(pSsdpRequest->Headers[SSDP_USN]) + 1));
        if (pSsdpMessage->szUSN == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pSsdpMessage->szUSN, pSsdpRequest->Headers[SSDP_USN]);
        }
    }

    if (pSsdpRequest->Headers[GENA_SID] != NULL)
    {
        pSsdpMessage->szSid = (char *) malloc(sizeof(char) * (strlen(pSsdpRequest->Headers[GENA_SID]) + 1));
        if (pSsdpMessage->szSid == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pSsdpMessage->szSid, pSsdpRequest->Headers[GENA_SID]);
        }
    }

    if (pSsdpRequest->Headers[GENA_SEQ] != NULL)
    {
        pSsdpMessage->iSeq = strtoul(pSsdpRequest->Headers[GENA_SEQ], NULL, 10);
    }

    if (pSsdpRequest->Content)
    {
        pSsdpMessage->szContent = SzaDupSza(pSsdpRequest->Content);
        if (pSsdpMessage->szContent == NULL)
        {
            goto cleanup;
        }
    }

    pSsdpMessage->iLifeTime = GetMaxAgeFromCacheControl(pSsdpRequest->Headers[SSDP_CACHECONTROL]);

    return TRUE;

cleanup:
    FreeSsdpMessage(pSsdpMessage);

    return FALSE;
}

BOOL CopySsdpMessage(PSSDP_MESSAGE pDestination, const PSSDP_MESSAGE pSource)
{
    pDestination->guidInterface = pSource->guidInterface;
    pDestination->szLocHeader = NULL;
    pDestination->szAltHeaders = NULL;
    pDestination->szType = NULL;
    pDestination->szUSN = NULL;
    pDestination->szSid = NULL;
    pDestination->szContent = NULL;
    pDestination->iLifeTime = 0;

    if (pSource->szType != NULL)
    {
        pDestination->szType = (char *) malloc(sizeof(char) * (strlen(pSource->szType) + 1));
        if (pDestination->szType == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szType, pSource->szType);
        }
    }

    if (pSource->szLocHeader != NULL)
    {
        pDestination->szLocHeader = (char *) malloc(sizeof(char) * (strlen(pSource->szLocHeader) + 1));
        if (pDestination->szLocHeader == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szLocHeader, pSource->szLocHeader);
        }
    }

    if (pSource->szAltHeaders != NULL)
    {
        pDestination->szAltHeaders = (char *) malloc(sizeof(char) * (strlen(pSource->szAltHeaders) + 1));
        if (pDestination->szAltHeaders == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szAltHeaders, pSource->szAltHeaders);
        }
    }

    if (pSource->szUSN != NULL)
    {
        pDestination->szUSN = (char *) malloc(sizeof(char) * (strlen(pSource->szUSN) + 1));
        if (pDestination->szUSN == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szUSN, pSource->szUSN);
        }
    }

    if (pSource->szSid != NULL)
    {
        pDestination->szSid = (char *) malloc(sizeof(char) * (strlen(pSource->szSid) + 1));
        if (pDestination->szSid == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szSid, pSource->szSid);
        }
    }

    pDestination->iLifeTime = pSource->iLifeTime;
    pDestination->iSeq = pSource->iSeq;

    return TRUE;

cleanup:
    FreeSsdpMessage(pDestination);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\publish.cpp ===
#include <pch.h>
#pragma hdrstop

#include <limits.h>
#include <rpcasync.h>   // I_RpcExceptionFilter
#include "status.h"
#include "ssdpapi.h"
#include "common.h"
#include "ncdefine.h"
#include "ncdebug.h"

extern LONG cInitialized;

HANDLE WINAPI RegisterService(PSSDP_MESSAGE pSsdpMessage, DWORD flags)
{
    PCONTEXT_HANDLE_TYPE phContext = INVALID_HANDLE_VALUE;
    unsigned long status;

    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return INVALID_HANDLE_VALUE;
    }

    if (flags > SSDP_SERVICE_PERSISTENT)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (pSsdpMessage == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (pSsdpMessage->szUSN == NULL || pSsdpMessage->szType == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (pSsdpMessage->szAltHeaders == NULL && pSsdpMessage->szLocHeader == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (pSsdpMessage->iLifeTime <= 0)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if (pSsdpMessage->iLifeTime < (2 * (2*RETRY_INTERVAL*(NUM_RETRIES - 1) +
                                        RETRY_INTERVAL)) / 1000)
    {
        pSsdpMessage->iLifeTime = (2 * (2*RETRY_INTERVAL*(NUM_RETRIES - 1) +
                                        RETRY_INTERVAL)) / 1000;
    }

    if (pSsdpMessage->iLifeTime > UINT_MAX / 1000)
    {
        pSsdpMessage->iLifeTime = UINT_MAX / 1000;
    }

    RpcTryExcept
    {
        status = RegisterServiceRpc(&phContext, *pSsdpMessage, flags);
        ABORT_ON_FAILURE(status);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        status = RpcExceptionCode();
        TraceTag(ttidSsdpCPublish, "Runtime reported exception 0x%lx = %ld", status, status);
        goto cleanup;
    }
    RpcEndExcept

    return phContext;

cleanup:
    SetLastError(status);
    TraceTag(ttidSsdpCPublish, "Non-zero status: 0x%lx = %ld", status, status);
    return INVALID_HANDLE_VALUE;
}

BOOL WINAPI DeregisterService(HANDLE hRegister, BOOL fByebye)
{
    INT iRetVal;

    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    if (!hRegister || (INVALID_HANDLE_VALUE == hRegister))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcTryExcept
    {
        iRetVal = DeregisterServiceRpc(&hRegister, fByebye);
        if (iRetVal != 0)
        {
            SetLastError(iRetVal);
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        unsigned long ExceptionCode = RpcExceptionCode();
        SetLastError(ExceptionCode);
        TraceTag(ttidSsdpCNotify, "DeregisterServiceRpc Runtime reported exception 0x%lx = %ld", ExceptionCode, ExceptionCode);
        return FALSE;
    }
    RpcEndExcept
}

BOOL WINAPI DeregisterServiceByUSN(char * szUSN, BOOL fByebye)
{
    INT iRetVal;

    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    if (szUSN == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RpcTryExcept
    {
        iRetVal = DeregisterServiceRpcByUSN(szUSN, fByebye);
        if (iRetVal != 0)
        {
            SetLastError(iRetVal);
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        unsigned long ExceptionCode = RpcExceptionCode();
        SetLastError(ExceptionCode);
        TraceTag(ttidSsdpCNotify, "DeregisterServiceRpc Runtime reported exception 0x%lx = %ld", ExceptionCode, ExceptionCode);
        return FALSE;
    }
    RpcEndExcept
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\notifyc.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objbase.h"

#include <rpcasync.h>   // I_RpcExceptionFilter
#include "ssdp.h"
#include "status.h"
#include "list.h"
#include "ssdpapi.h"
#include "common.h"
#include "ncmem.h"
#include "ncdefine.h"
#include "ncdebug.h"
#include "ssdpfuncc.h"
#include "ssdpparser.h"
#include "nccom.h"
#include "ncstring.h"

static LIST_ENTRY listNotify;
PCONTEXT_HANDLE_TYPE g_pSyncContext = NULL;
static HANDLE g_hListNotify = INVALID_HANDLE_VALUE;

static long g_fExiting = 0;  // set to 1 when get notification thread is exiting
static long g_fSyncInited = FALSE;  // TRUE if SyncHandle is initialized

static HANDLE g_hThread = INVALID_HANDLE_VALUE;
HANDLE g_hLaunchEvent = INVALID_HANDLE_VALUE;
RTL_RESOURCE g_rsrcReg;

static LONG g_lNotKey = 0;

extern LONG cInitialized;

// To-do: Rpc error server is too busy after GetNotificationRpc is in process.
// signal the semaphore in rundown.

VOID AddToListClientNotify(PSSDP_CLIENT_NOTIFY NotifyRequest);
DWORD WINAPI GetNotificationLoop(LPVOID lpvThreadParam);
VOID CallbackOnNotification(MessageList *list);

// Purpose: takes the g_hListNotify mutex and returns
// Note:    This should be used only by code that lives on the Notify thread.
//          Code that can be executed when servicing an SSDP api call must use
//          MsgEnterListNotify instead.  The purpose of having two functions
//          is to save the notify thread (which has no message loop) from
//          going through extra layers of method-call goop.
VOID EnterListNotify()
{
    DWORD dwResult;

    TraceTag(ttidSsdpCNotify, "Entering g_hListNotify...");

    dwResult = ::WaitForSingleObject(g_hListNotify, INFINITE);

    TraceTag(ttidSsdpCNotify, "...acquired g_hListNotify");

    AssertSz(WAIT_TIMEOUT != dwResult,
        "EnterListNotify: unexpected return value");
    AssertSz(WAIT_ABANDONED != dwResult,
        "EnterListNotify: invalid mutex state");
    AssertSz(WAIT_OBJECT_0 == dwResult,
        "EnterListNotify: unknown return value");
}

// Purpose: takes the g_hListNotify mutex and returns, servicing the message
//          pump while waiting
// Note:    This must be used instead of EnterListNotify by any code that
//          can be executed on the client thread.  Code that lives exclusively
//          on the Notify thread should use EnterListNotify() instead.
VOID MsgEnterListNotify()
{
    HRESULT hr;
    DWORD dwResult;

    TraceTag(ttidSsdpCNotify, "Entering HrMyWaitForMultipleHandles");

    hr = HrMyWaitForMultipleHandles(0,
                                    INFINITE,
                                    1,
                                    &g_hListNotify,
                                    &dwResult);
    // We shouldn't get RPC_S_CALLPENDING because we're waiting forever
    //
    Assert(SUCCEEDED(hr));
}

// Purpose: frees the g_hListNotify mutex and returns
VOID LeaveListNotify()
{
    BOOL fResult;

    TraceTag(ttidSsdpCNotify, "Releasing Mutex");

    fResult = ::ReleaseMutex(g_hListNotify);

    TraceTag(ttidSsdpCNotify, "Mutex is released");

    if (!fResult)
    {
        TraceLastWin32Error("LeaveListNotify");
    }
}

VOID FinishExitNotificationThread()
{
    TraceTag(ttidSsdpCNotify, "Removing Sync Handle %x", g_pSyncContext);

    RpcTryExcept
    {
        RemoveSyncHandle(&g_pSyncContext);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        unsigned long ExceptionCode = RpcExceptionCode();
        TraceTag(ttidSsdpCNotify, "FinishExit... reported exception 0x%lx = %ld",
                 ExceptionCode, ExceptionCode);
    }
    RpcEndExcept

    InterlockedExchange(&g_fSyncInited, 0);
}

VOID CleanupNotificationThread()
{
    INT nStatus;

    TraceTag(ttidSsdpCNotify, "Cleaning up notif thread: %d", g_hThread);

    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNotify;

    TraceTag(ttidSsdpCNotify, "----- Cleanup SSDP Client Notify List -----");

    MsgEnterListNotify();

    p = pListHead->Flink;

    while (p != pListHead)
    {

        PSSDP_CLIENT_NOTIFY NotifyRequest;

        NotifyRequest = CONTAINING_RECORD (p, SSDP_CLIENT_NOTIFY, linkage);

        p = p->Flink;

        DeregisterNotification(NotifyRequest);

    }
    LeaveListNotify();

    if (g_hThread && g_hThread != INVALID_HANDLE_VALUE)
    {
        TraceTag(ttidSsdpCNotify, "Incrementing g_fExiting");
        InterlockedExchange(&g_fExiting, 1);

        RpcTryExcept
        {
            TraceTag(ttidSsdpCNotify, "Wakie wakie!");

            nStatus = WakeupGetNotificationRpc(g_pSyncContext);

            TraceTag(ttidSsdpCNotify, "Wake up returned status %x\n", nStatus);

            if (nStatus != 0 )
            {
                // Big problem, damage control
                FinishExitNotificationThread();
            }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            unsigned long ExceptionCode = RpcExceptionCode();
            SetLastError(ExceptionCode);
            TraceTag(ttidSsdpCNotify, "Wakeup: Runtime reported exception 0x%lx = %ld", ExceptionCode, ExceptionCode);
            FinishExitNotificationThread();
        }
        RpcEndExcept

        // note: we have to wait for our notify thread to exit _before_ we
        //       destroy g_hListNotify, as the notify thread might be holding it

        // Wait for the thread to exit since we've just told it to wake up and die
        TraceTag(ttidSsdpCNotify, "Waiting for the notification loop thread to exit.\n");
        DWORD dwResult = 0;
        HrMyWaitForMultipleHandles(
            0,
            INFINITE,
            1,
            &g_hThread,
            &dwResult);

        CloseHandle(g_hThread);
        g_hThread = INVALID_HANDLE_VALUE;
    }

    {
        BOOL fResult;

        fResult = ::CloseHandle(g_hListNotify);

        AssertSz(fResult, "CleanupListNotify: CloseHandle(g_hListNotify) failed");

        g_hListNotify = INVALID_HANDLE_VALUE;
    }
}

HANDLE WINAPI RegisterNotification (NOTIFY_TYPE nt, CHAR * szType,
                                    CHAR *szEventUrl,
                                    SERVICE_CALLBACK_FUNC fnCallback,
                                    VOID *pContext)
{
    PSSDP_CLIENT_NOTIFY ClientNotify = NULL;
    INT Size = sizeof(SSDP_CLIENT_NOTIFY);
    PCONTEXT_HANDLE_TYPE phContext;
    INT status;
    DWORD ThreadId;
    SSDP_REGISTER_INFO  info = {0};
    SSDP_REGISTER_INFO *pinfo = &info;
    BOOL fHoldingListNotify = FALSE;
    BOOL bHoldingResource = FALSE;

    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return INVALID_HANDLE_VALUE;
    }

    switch (nt)
    {
        case NOTIFY_PROP_CHANGE:
            if (szEventUrl == NULL || szType != NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
            }
            break;
        case NOTIFY_ALIVE:
            if (szType == NULL || szEventUrl != NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return INVALID_HANDLE_VALUE;
            }
            break;
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
    }

    if (fnCallback == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    ClientNotify = (PSSDP_CLIENT_NOTIFY) malloc(Size);

    if (ClientNotify == NULL)
    {
        TraceTag(ttidSsdpCNotify, "Couldn't allocate  memory for "
                 "ClientNotifyRequest for %s", szType);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return INVALID_HANDLE_VALUE;
    }

    ZeroMemory(ClientNotify, sizeof(SSDP_CLIENT_NOTIFY));

    switch (nt)
    {
        case NOTIFY_PROP_CHANGE:
            ClientNotify->Type = SSDP_CLIENT_EVENT_SIGNATURE;
            ClientNotify->szType = NULL;
            ClientNotify->szEventUrl = (CHAR *) malloc(strlen(szEventUrl)+1);
            if (ClientNotify->szEventUrl == NULL)
            {
                TraceTag(ttidSsdpCNotify, "Couldn't allocate  memory for "
                         "szEventUrl for %s", szEventUrl);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                free(ClientNotify);
                return INVALID_HANDLE_VALUE;
            }

            strcpy(ClientNotify->szEventUrl, szEventUrl);
            break;

        case NOTIFY_ALIVE:
            ClientNotify->Type = SSDP_CLIENT_NOTIFY_SIGNATURE;
            ClientNotify->szEventUrl = NULL;
            ClientNotify->szType = (CHAR *) malloc(strlen(szType)+1);
            if (ClientNotify->szType == NULL)
            {
                TraceTag(ttidSsdpCNotify, "Couldn't allocate  memory for "
                         "szType for %s", szType);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                free(ClientNotify);
                return INVALID_HANDLE_VALUE;
            }

            strcpy(ClientNotify->szType, szType);
            break;
        default:
            ASSERT(FALSE);
            return INVALID_HANDLE_VALUE;
    }

    if (InterlockedCompareExchange(&g_fSyncInited, 1, 0) == 0)
    {
        // First time ever going into this function

        Assert(IsListEmpty(&listNotify));
        RpcTryExcept
        {
            status = InitializeSyncHandle(&g_pSyncContext);
            TraceTag(ttidSsdpCNotify, "InitializeSyncHandler returned %d.",
                     status);
            if (status)
            {
                SetLastError(status);
                InterlockedExchange(&g_fSyncInited, 0);
                SetEvent(g_hLaunchEvent);
                goto cleanup;
            }
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            unsigned long ExceptionCode = RpcExceptionCode();
            SetLastError(ExceptionCode);
            TraceTag(ttidSsdpCNotify, "Runtime reported exception 0x%lx = %ld",
                     ExceptionCode, ExceptionCode);
            InterlockedExchange(&g_fSyncInited, 0);
            SetEvent(g_hLaunchEvent);
            goto cleanup;
        }
        RpcEndExcept

        // create the thread to continuously get notifications
        g_hThread = (HANDLE) CreateThread(NULL, 0, GetNotificationLoop,
                                        (LPVOID) g_pSyncContext, 0, &ThreadId);
        if (!g_hThread || g_hThread == INVALID_HANDLE_VALUE)
        {
            FinishExitNotificationThread();
            InterlockedExchange(&g_fSyncInited, 0);

            SetLastError(ERROR_OUTOFMEMORY);
        }
        else
        {
            // reset this flag!
            InterlockedExchange(&g_fExiting, 0);
        }

        // Let other threads go
        SetEvent(g_hLaunchEvent);
    }
    else
    {
        DWORD dwResult;

        dwResult = WaitForSingleObject(g_hLaunchEvent, INFINITE);
        Assert(WAIT_OBJECT_0 == dwResult);
    }

    // Somehow the thread wasn't created
    if (!InterlockedExchange(&g_fSyncInited, g_fSyncInited))
    {
        TraceTag(ttidSsdpCNotify, "Thread wasn't created! Aborting...");
        SetLastError(ERROR_NOT_READY);
        goto cleanup;
    }

    bHoldingResource = RtlAcquireResourceShared(&g_rsrcReg, TRUE);
    if(bHoldingResource)
    {
        __try
        {
            RpcTryExcept
            {
                status = RegisterNotificationRpc(&(ClientNotify->HandleServer),
                                                 g_pSyncContext, nt, szType,
                                                 szEventUrl, &pinfo);
                if (status)
                {
                    TraceTag(ttidError, "RegisterNotification: "
                             "RegisterNotificationRpc failed! %d", status);
                    SetLastError(status);
                    goto cleanup;
                }
            }
            RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
                unsigned long ExceptionCode = RpcExceptionCode();
                SetLastError(ExceptionCode);
                TraceTag(ttidSsdpCNotify, "Runtime reported exception 0x%lx = %ld", ExceptionCode, ExceptionCode);
                goto cleanup;
            }
            RpcEndExcept

            // add to the client notify request list
            ClientNotify->Size = Size;
            ClientNotify->Callback = fnCallback;
            ClientNotify->Context = pContext;
            if (pinfo)
            {
                Assert(pinfo->szSid);

                ClientNotify->szSid = SzaDupSza(pinfo->szSid);
                ClientNotify->csecTimeout = pinfo->csecTimeout;

                // Done with this
                midl_user_free(pinfo->szSid);
            }

            MsgEnterListNotify();

            TraceTag(ttidSsdpCNotify, "Adding %p to list", ClientNotify);
            InsertHeadList(&listNotify, &(ClientNotify->linkage));

            TraceTag(ttidSsdpCNotify, "Leaving mutex @382");

            LeaveListNotify();
        }
        __finally
        {
            RtlReleaseResource(&g_rsrcReg);
        }
    }


    TraceTag(ttidSsdpCNotify, "RegisterNotification returning %p", ClientNotify);

    return ClientNotify;

cleanup:
    if (ClientNotify != NULL)
    {
        free(ClientNotify->szType);
        free(ClientNotify->szEventUrl);
        free(ClientNotify->szSid);
        free(ClientNotify);
    }

    return INVALID_HANDLE_VALUE;
}

BOOL WINAPI DeregisterNotification(HANDLE hNotification)
{
    INT     status = 0;
    BOOL    fLast = FALSE;
    BOOL    fRet = FALSE;

    PSSDP_CLIENT_NOTIFY ClientNotify = (PSSDP_CLIENT_NOTIFY) hNotification;

    if (!ClientNotify)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    TraceTag(ttidSsdpCNotify, "DeregisterNotification was passed %p:%p",
             ClientNotify, &ClientNotify->HandleServer);

    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    MsgEnterListNotify();

    _try
    {
        if ((ClientNotify->Type != SSDP_CLIENT_NOTIFY_SIGNATURE &&
            ClientNotify->Type != SSDP_CLIENT_EVENT_SIGNATURE) ||
            ClientNotify->Size != sizeof(SSDP_CLIENT_NOTIFY))
        {
            LeaveListNotify();
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    _except (1)
    {
        LeaveListNotify();
        unsigned long ExceptionCode = _exception_code();
        TraceTag(ttidSsdpCNotify, "Exception 0x%lx = %ld occurred in DeregisterNotification", ExceptionCode, ExceptionCode);
        SetLastError(ExceptionCode);
        return FALSE;
    }

    TraceTag(ttidSsdpCNotify, "Removing %p from list", ClientNotify);

    RemoveEntryList(&ClientNotify->linkage);

    LeaveListNotify();

    RpcTryExcept
    {
        status = DeregisterNotificationRpc(&ClientNotify->HandleServer, fLast);
        if (status != 0)
        {
            TraceTag(ttidSsdpCNotify, "Deregister returned %d", status);
        }
        ABORT_ON_FAILURE(status);
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        unsigned long ExceptionCode = RpcExceptionCode();
        SetLastError(ExceptionCode);
        TraceTag(ttidSsdpCNotify, "Runtime reported exception 0x%lx = %ld", ExceptionCode, ExceptionCode);
        goto cleanup;
    }
    RpcEndExcept

    TraceTag(ttidSsdpCNotify, "Checking if listNotify is empty\n");

    fRet = TRUE;

cleanup:
    free(ClientNotify->szType);
    free(ClientNotify->szSid);
    free(ClientNotify->szEventUrl);
    free(ClientNotify);

    return fRet;
}

VOID FreeMessageList(MessageList *list)
{
    INT i;

    if (list != NULL)
    {
        for (i = 0; i < list->size; i++)
        {
            SSDP_REQUEST *pSsdpRequest;

            pSsdpRequest = list->list+i;

            FreeSsdpRequest(pSsdpRequest);

        }
        free(list->list);
        free(list);
    }
}

const DWORD c_cRetryMax = 3;

DWORD WINAPI GetNotificationLoop(LPVOID lpvThreadParam)
{
    DWORD   cRetries = c_cRetryMax;
    ULONG   ulExceptionCode = 0;

    while (1)
    {
        MessageList *list = NULL;

        PCONTEXT_HANDLE_TYPE pSemaphore = (PCONTEXT_HANDLE_TYPE) lpvThreadParam;

        if (!cRetries)
        {
            break;
        }

        // reset this to make sure
        ulExceptionCode = 0;

        // To-do: Check if we are exiting?
        // To-do: Check memory leak.
        RpcTryExcept
        {
            TraceTag(ttidSsdpCNotify, "Calling GetNotificationRpc...");
            GetNotificationRpc(pSemaphore, &list);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            ulExceptionCode = RpcExceptionCode();
            TraceTag(ttidSsdpCNotify, "GetNotif: Runtime reported exception "
                     "0x%lx = %ld", ulExceptionCode, ulExceptionCode);
        }
        RpcEndExcept

        if (InterlockedExchange(&g_fExiting, g_fExiting) != 0)
        {
            TraceTag(ttidSsdpCNotify, "GetNotif is exiting.");
            FreeMessageList(list);
            break;
        }
        if (list != 0)
        {
            PrintSsdpMessageList(list);
            CallbackOnNotification(list);
        }

        // Decrement the retry count if there is an error
        //
        if (NOERROR != ulExceptionCode)
        {
            cRetries--;
        }
        else
        {
            cRetries = c_cRetryMax;
        }
    }
    FinishExitNotificationThread();

    TraceTag(ttidSsdpCNotify, "Thread is exiting");

return 0;
}

BOOL InitializeListNotify()
{
    Assert(INVALID_HANDLE_VALUE == g_hListNotify);

    g_hListNotify = ::CreateMutex(NULL, TRUE, NULL);
    if (!g_hListNotify)
    {
        return FALSE;
    }

    // note: we don't need to call EnterListNotify() since we passed
    //       bInitialOwner == TRUE above
    //

    InitializeListHead(&listNotify);

    LeaveListNotify();

    return TRUE;
}

BOOL IsInListNotify(CHAR *szType)
{
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNotify;

    MsgEnterListNotify();

    p = pListHead->Flink;

    while (p != pListHead)
    {
        PSSDP_CLIENT_NOTIFY NotifyRequest;

        NotifyRequest = CONTAINING_RECORD (p, SSDP_CLIENT_NOTIFY, linkage);

        p = p->Flink;

        if (NotifyRequest->szType && !lstrcmpi(NotifyRequest->szType, szType))
        {
            LeaveListNotify();
            return TRUE;
        }
    }

    LeaveListNotify();
    return FALSE;
}

VOID CallbackOnNotification(MessageList *list)
{
    INT i;
    PLIST_ENTRY p;
    PLIST_ENTRY pListHead = &listNotify;

    TraceTag(ttidSsdpCNotify, "Callback on notification list.");

    TraceTag(ttidSsdpCNotify, "Trying to get the exclusive lock...");

    // Yeah this is a big hack, but it should work. If this is triggered by a call
    // to RegisterNotificationRpc then we want to wait before that call has
    // finished before allowing this guy to start. We just want to wait, not to
    // synchronize access (which the list notify already does).
    RtlAcquireResourceExclusive(&g_rsrcReg, TRUE);

    TraceTag(ttidSsdpCNotify, "...got it!");

    RtlReleaseResource(&g_rsrcReg);

    TraceTag(ttidSsdpCNotify, "Released it!");

    struct CallbackInfo
    {
        SERVICE_CALLBACK_FUNC   m_pfnCallback;
        SSDP_CALLBACK_TYPE      m_ssdpCallbackType;
        PSSDP_MESSAGE           m_pssdpMessage;
        void *                  m_pvContext;
    };

    long nCallbackCount = 0;

    EnterListNotify();

    // Go through list once to get a count of items
    for (i = 0; i < list->size; i++)
    {
        SSDP_REQUEST *pSsdpRequest;

        pSsdpRequest = list->list+i;

        p = pListHead->Flink;

        TraceTag(ttidSsdpCNotify, "Searching list to callback...");

        while (p != pListHead)
        {
            TraceTag(ttidSsdpCNotify, "Found an item to check...");

            PSSDP_CLIENT_NOTIFY NotifyRequest;
            BOOL                fShouldCallback;

            NotifyRequest = CONTAINING_RECORD (p, SSDP_CLIENT_NOTIFY, linkage);

            if (NotifyRequest->Type == SSDP_CLIENT_EVENT_SIGNATURE)
            {
                // Match the SID in the NOTIFY to the SID in any local
                // subscribers
                //
                fShouldCallback = (pSsdpRequest->Headers[GENA_SID] &&
                    !lstrcmp(pSsdpRequest->Headers[GENA_SID], NotifyRequest->szSid));
            }
            else
            {
                fShouldCallback = (pSsdpRequest->Headers[SSDP_NT] &&
                    !lstrcmp(pSsdpRequest->Headers[SSDP_NT], NotifyRequest->szType)) ||
                    (pSsdpRequest->Headers[SSDP_ST] &&
                    !lstrcmp(pSsdpRequest->Headers[SSDP_ST], NotifyRequest->szType));
            }

            if (fShouldCallback)
            {
                ++nCallbackCount;
            }
            p = p->Flink;
        }
    }

    CallbackInfo * arCallbackInfo = NULL;
    if(nCallbackCount)
    {
        arCallbackInfo = reinterpret_cast<CallbackInfo*>(malloc(nCallbackCount * sizeof(CallbackInfo)));
    }
    long nCallback = 0;

    // Go through list again to store callback info
    for (i = 0; i < list->size && arCallbackInfo && nCallback < nCallbackCount; i++)
    {
        SSDP_REQUEST *pSsdpRequest;

        pSsdpRequest = list->list+i;

        p = pListHead->Flink;

        TraceTag(ttidSsdpCNotify, "Searching list to callback...");

        while (p != pListHead)
        {
            TraceTag(ttidSsdpCNotify, "Found an item to check...");

            PSSDP_CLIENT_NOTIFY NotifyRequest;
            BOOL                fShouldCallback;

            NotifyRequest = CONTAINING_RECORD (p, SSDP_CLIENT_NOTIFY, linkage);

            if (NotifyRequest->Type == SSDP_CLIENT_EVENT_SIGNATURE)
            {
                // Match the SID in the NOTIFY to the SID in any local
                // subscribers
                //
                fShouldCallback = (pSsdpRequest->Headers[GENA_SID] &&
                    !lstrcmp(pSsdpRequest->Headers[GENA_SID], NotifyRequest->szSid));
            }
            else
            {
                fShouldCallback = (pSsdpRequest->Headers[SSDP_NT] &&
                    !lstrcmp(pSsdpRequest->Headers[SSDP_NT], NotifyRequest->szType)) ||
                    (pSsdpRequest->Headers[SSDP_ST] &&
                    !lstrcmp(pSsdpRequest->Headers[SSDP_ST], NotifyRequest->szType));
            }

            if (fShouldCallback)
            {
                PSSDP_MESSAGE pSsdpMessage;

                pSsdpMessage = (PSSDP_MESSAGE) malloc(sizeof(SSDP_MESSAGE));

                if (pSsdpMessage != NULL)
                {
                    if (InitializeSsdpMessageFromRequest(pSsdpMessage,
                                                         pSsdpRequest) == TRUE)
                    {
                        SSDP_CALLBACK_TYPE CallbackType = SSDP_ALIVE;

                        if (!lstrcmpi(pSsdpRequest->Headers[SSDP_NTS],
                                      "ssdp:byebye"))
                        {
                            CallbackType = SSDP_BYEBYE;
                        }
                        else if (!lstrcmpi(pSsdpRequest->Headers[SSDP_NTS],
                                           "upnp:propchange"))
                        {
                            CallbackType = SSDP_EVENT;
                        }
                        else if (!lstrcmpi(pSsdpRequest->Headers[SSDP_NTS],
                                           "upnp:dead"))
                        {
                            CallbackType = SSDP_DEAD;
                        }

                        arCallbackInfo[nCallback].m_pfnCallback = NotifyRequest->Callback;
                        arCallbackInfo[nCallback].m_ssdpCallbackType = CallbackType;
                        arCallbackInfo[nCallback].m_pssdpMessage = pSsdpMessage;
                        arCallbackInfo[nCallback].m_pvContext = NotifyRequest->Context;
                        ++nCallback;
                    }
                }
                else
                {
                    --nCallbackCount;
                    TraceTag(ttidSsdpNotify, "Failed to allocate memory for "
                             "SsdpMessage.");
                }
            }
            p = p->Flink;
        }
    }

    LeaveListNotify();
    FreeMessageList(list);

    // Make calls without list locked
    for(long n = 0; n < nCallbackCount; ++n)
    {
        arCallbackInfo[n].m_pfnCallback(
            arCallbackInfo[n].m_ssdpCallbackType,
            arCallbackInfo[n].m_pssdpMessage,
            arCallbackInfo[n].m_pvContext);
        FreeSsdpMessage(arCallbackInfo[n].m_pssdpMessage);
    }
    free(arCallbackInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\searchc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S E A R C H C . C P P
//
//  Contents:   Client side searching
//
//  Notes:
//
//  Author:     mbend   2 Dec 2000
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <rpcasync.h>   // I_RpcExceptionFilter
#include "searchc.h"
#include "list.h"
#include "ssdpparser.h"
#include "ssdpfuncc.h"
#include "ssdpapi.h"
#include "common.h"
#include "ncbase.h"
#include "ncdefine.h"
#include "ncdebug.h"
#include "nccom.h"
#include "InterfaceTable.h"
#include "iphlpapi.h"

static CHAR *SearchHeader = "\"ssdp:discover\"";
static CHAR *MulticastUri = "*";
static CHAR *MX = "3";

extern LONG cInitialized;

#define MX_VALUE 3000
#define SELECT_TIMEOUT 60
#define NUM_OF_RETRY  2  // 3-1
#define LOOPBACK_ADDR_TIMEOUT 120000  // 2 minutes

CSsdpSearchThread::CSsdpSearchThread(CSsdpSearchRequest * pRequest) : m_pRequest(pRequest)
{
}

CSsdpSearchThread::~CSsdpSearchThread()
{
}

DWORD CSsdpSearchThread::DwRun()
{
    return m_pRequest->DwThreadFunc();
}

CSsdpSearchRequest::CSsdpSearchRequest()
: m_searchState(SEARCH_START), m_pfnCallback(NULL), m_pvContext(NULL),
    m_searchThread(this), m_nNumOfRetry(NUM_OF_RETRY), m_timer(*this),
    m_bHitWire(FALSE), m_hEventDone(NULL), m_bShutdown(FALSE),
    m_bOnlyLoopBack(TRUE), m_bDeletedTimer(FALSE)
{

}

CSsdpSearchRequest::~CSsdpSearchRequest()
{
    CloseHandle(m_hEventDone);

    long nCount = m_socketList.GetCount();
    for(long n = 0; n < nCount; ++n)
    {
        closesocket(m_socketList[n].m_socket);
    }
    m_socketList.Clear();

    ResponseMessageList::Iterator iter;
    if(S_OK == m_responseMessageList.GetIterator(iter))
    {
        SSDP_MESSAGE * pMsg = NULL;
        while(S_OK == iter.HrGetItem(&pMsg))
        {
            delete [] pMsg->szAltHeaders;
            delete [] pMsg->szContent;
            delete [] pMsg->szLocHeader;
            delete [] pMsg->szSid;
            delete [] pMsg->szType;
            delete [] pMsg->szUSN;
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }
    m_responseMessageList.Clear();
}

HRESULT CSsdpSearchRequest::HrInitialize(char * szType)
{
    HRESULT hr = S_OK;

    if(!szType)
    {
        return E_INVALIDARG;
    }

    hr = m_strType.HrAssign(szType);
    if(SUCCEEDED(hr))
    {
        m_hEventDone = CreateEvent(NULL, TRUE, FALSE, NULL);
        if(!m_hEventDone)
        {
            hr = HrFromLastWin32Error();
        }
        if(SUCCEEDED(hr))
        {
            SSDP_REQUEST request;
            ZeroMemory(&request, sizeof(request));

            hr = HrInitializeSsdpSearchRequest(&request, szType);
            if(SUCCEEDED(hr))
            {
                char * szSearch = NULL;
                if(!ComposeSsdpRequest(&request, &szSearch))
                {
                    hr = E_OUTOFMEMORY;
                }
                if(SUCCEEDED(hr))
                {
                    hr = m_strSearch.HrAssign(szSearch);
                    delete [] szSearch;
                }
                // Presumably these point to constants and should not be freed
                request.Headers[SSDP_MAN] = NULL;
                request.Headers[SSDP_MX] = NULL;
                request.RequestUri = NULL;

                FreeSsdpRequest(&request);
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = HrBuildSocketList();
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrInitialize");
    return hr;
}


HRESULT CSsdpSearchRequest::HrBuildSocketList()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    SOCKET sockInfo = INVALID_SOCKET;
    SOCKADDR_IN sockAddrInfo;
    sockAddrInfo.sin_family = AF_INET;
    sockAddrInfo.sin_addr.s_addr = INADDR_ANY;
    sockAddrInfo.sin_port = 0;

    m_bOnlyLoopBack = TRUE ;
    // Open a socket to query interface list with
    sockInfo = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(INVALID_SOCKET == sockInfo)
    {
        hr = E_FAIL;
        TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrBuildSocketList - socket() failed");
    }

    if(SUCCEEDED(hr))
    {
        if(SOCKET_ERROR == bind(sockInfo, reinterpret_cast<sockaddr*>(&sockAddrInfo), sizeof(sockAddrInfo)))
        {
            hr = E_FAIL;
            TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrBuildSocketList - bind() failed");
        }
    }

    if(SUCCEEDED(hr))
    {
        DWORD cbSocketAddressList = 0;

        // Fetch size
        WSAIoctl(sockInfo, SIO_ADDRESS_LIST_QUERY, NULL, 0, NULL, 0, &cbSocketAddressList, NULL, NULL);

        if(cbSocketAddressList)
        {
            SOCKET_ADDRESS_LIST * pSocketAddressList = reinterpret_cast<SOCKET_ADDRESS_LIST*>(new char[cbSocketAddressList]);
            if(!pSocketAddressList)
            {
                hr = E_OUTOFMEMORY;
            }
            if(SUCCEEDED(hr))
            {
                // Fetch list of interfaces
                if(SOCKET_ERROR == WSAIoctl(sockInfo, SIO_ADDRESS_LIST_QUERY, NULL, 0, pSocketAddressList, cbSocketAddressList, &cbSocketAddressList, NULL, NULL))
                {
                    hr = E_FAIL;
                    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrBuildSocketList - WSAIoctl() failed");
                }
                if(SUCCEEDED(hr))
                {
                    GUID guidInterface;
                    CInterfaceTable interfaceTable;
                    hr = interfaceTable.HrInitialize();
                    if(SUCCEEDED(hr))
                    {
                        TraceTag(ttidSsdpSearchResp, "CSsdpSearchRequest::BuildSocketList() No of Interface %d ",pSocketAddressList->iAddressCount);
                        // Insert each interface into the list
                        for(long n = 0; n < pSocketAddressList->iAddressCount && SUCCEEDED(hr); ++n)
                        {
                            SOCKET_ADDRESS * pSockAddr = &pSocketAddressList->Address[n];
                            SOCKADDR_IN * pSockAddrIn = reinterpret_cast<SOCKADDR_IN*>(pSockAddr->lpSockaddr);

                            BOOL bBad = pSockAddr->iSockaddrLength == 0 ||
                                        pSockAddr->lpSockaddr == NULL ||
                                        pSockAddr->lpSockaddr->sa_family != AF_INET ||
                                        pSockAddrIn->sin_addr.s_addr == 0;
                            if(!bBad)
                            {
                                hr = interfaceTable.HrMapIpAddressToGuid(pSockAddrIn->sin_addr.S_un.S_addr, guidInterface);
                                if(SUCCEEDED(hr))
                                {
                                    SOCKET socket = INVALID_SOCKET;
                                    pSockAddrIn->sin_port = 0;
                                    if(!SocketOpen(&socket, pSockAddrIn, pSockAddrIn->sin_addr.S_un.S_addr, FALSE))
                                    {
                                        hr = E_FAIL;
                                        TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrBuildSocketList - SocketOpen() failed");
                                    }
                                    if(SUCCEEDED(hr))
                                    {
                                        SocketInfo socketInfo;
                                        socketInfo.m_socket = socket;
                                        socketInfo.m_guidInterface = guidInterface;
                                        hr = m_socketList.HrPushBack(socketInfo);
                                        m_bOnlyLoopBack = FALSE;
                                        TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::BuildSocketList() Loopbackonly(%d)", m_bOnlyLoopBack);
                                    }
                                }
                            }
                        }
                    }
                }

                delete [] reinterpret_cast<char*>(pSocketAddressList);
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        // Bind to loopback address if nothing else
        SOCKADDR_IN sockAddrLoopback;

        sockAddrLoopback.sin_family = AF_INET;
        sockAddrLoopback.sin_addr.s_addr = inet_addr("127.0.0.1");
        sockAddrLoopback.sin_port = 0;

        SOCKET socketLoopback = INVALID_SOCKET;
        if(!SocketOpen(&socketLoopback, &sockAddrLoopback, sockAddrLoopback.sin_addr.s_addr, FALSE))
        {
            hr = E_FAIL;
            TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrBuildSocketList - SocketOpen() failed");
        }
        if(SUCCEEDED(hr))
        {
            SocketInfo socketInfo;
            socketInfo.m_socket = socketLoopback;
            ZeroMemory(&socketInfo.m_guidInterface, sizeof(socketInfo.m_guidInterface));
            hr = m_socketList.HrPushBack(socketInfo);
        }
    }

    if(FAILED(hr) && m_socketList.GetCount())
    {
        long nCount = m_socketList.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            closesocket(m_socketList[n].m_socket);
        }
        m_socketList.Clear();
    }

    if(INVALID_SOCKET != sockInfo)
    {
        closesocket(sockInfo);
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrBuildSocketList");
    return hr;
}

HRESULT CSsdpSearchRequest::HrReBuildSocketList()
{
    HRESULT hr = S_OK;

    {
        CLock lock(m_critSec);
        long nCount = m_socketList.GetCount();

        for(long n = 0; n < nCount; ++n)
        {
            closesocket(m_socketList[n].m_socket);
        }
        m_socketList.Clear();

        hr = HrBuildSocketList();
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrReBuildSocketList");
    return hr;

}

HRESULT CSsdpSearchRequest::HrSocketSend(const char * szData)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    long nCount = m_socketList.GetCount();
    for(long n = 0; n < nCount; ++n)
    {
        SocketSend(szData, m_socketList[n].m_socket, NULL);
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrSocketSend");
    return hr;
}

HRESULT CSsdpSearchRequest::HrProcessLoopbackAddrOnly()
{
    HRESULT hr = S_OK;
    HANDLE  hNotify = NULL;
    DWORD  dwStatus;
    DWORD dwWaitStatus;
    HANDLE hInterfaceChangeEvent = NULL;

    ZeroMemory(&m_ovInterfaceChange, sizeof(m_ovInterfaceChange));

    hInterfaceChangeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hInterfaceChangeEvent)
    {
        m_ovInterfaceChange.hEvent = hInterfaceChangeEvent;

        // NotifyAddrChange will be cancelled when the calling thread dies
        // CSsdpSearchRequest, and therefore m_ovInterfaceChange, has a longer lifetime than the thread
        dwStatus = NotifyAddrChange(&hNotify, &m_ovInterfaceChange);
        if (dwStatus != ERROR_SUCCESS && dwStatus != ERROR_IO_PENDING)
        {
            TraceTag(ttidSsdpCSearch, "NotifyAddrChange returned %d",dwStatus);
            hr = E_FAIL;
        }
        else
        {
            TraceTag(ttidSsdpCSearch, "NotifyAddrChange succeeded",dwStatus);
            HANDLE hHandles[2] = {hInterfaceChangeEvent, m_hEventDone};

            dwWaitStatus = WaitForMultipleObjects(2, hHandles, FALSE, LOOPBACK_ADDR_TIMEOUT);
            switch(dwWaitStatus)
            {
                case WAIT_OBJECT_0:
                    TraceTag(ttidSsdpCSearch, "Wait Object - IP Addr change notified");
                    hr = HrReBuildSocketList();
                    TraceTag(ttidSsdpCSearch, "Rebuilding Socket List - List Count - %d",m_socketList.GetCount());
                    // falling through intentionally
                case WAIT_TIMEOUT:
                    TraceTag(ttidSsdpCSearch, "AutoIP Time out");
                    if(SUCCEEDED(hr))
                    {
                        char *szSearch = NULL;
                        hr = m_strSearch.HrGetMultiByteWithAlloc(&szSearch);
                        if(SUCCEEDED(hr))
                        {
                            hr = HrSocketSend(szSearch);
                            delete [] szSearch;
                            if(SUCCEEDED(hr))
                            {
                                hr = m_timer.HrSetTimer(MX_VALUE);
                            }
                        }
                    }

                    break;
                case WAIT_OBJECT_0 + 1:
                    TraceTag(ttidSsdpCSearch, "Exiting");
                    hr = E_FAIL;
                    break;

                default:
                    hr = E_FAIL;
                    break;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if(hInterfaceChangeEvent != NULL)
        CloseHandle(hInterfaceChangeEvent);

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrProcessLoopbackAddrOnly()");
    return hr ;
}

HRESULT CSsdpSearchRequest::HrStartAsync(
    BOOL bForceSearch,
    SERVICE_CALLBACK_FUNC pfnCallback,
    VOID * pvContext)
{
    HRESULT hr = S_OK;

    SOCKADDR_IN sockAddrIn;
    int nSockAddrInSize = sizeof(sockAddrIn);

    if (!cInitialized)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }

    if(!pfnCallback)
    {
        return E_INVALIDARG;
    }

    m_pfnCallback = pfnCallback;
    m_pvContext = pvContext;
    m_searchState = SEARCH_DISCOVERING;

    if(!m_bOnlyLoopBack)
        hr = HrGetCacheResult();

    if(SUCCEEDED(hr))
    {
        if(bForceSearch || !FIsInListNotify(m_strType))
        {
            if(!m_bOnlyLoopBack)
            {

                m_bHitWire = TRUE;

                char * szSearch = NULL;
                hr = m_strSearch.HrGetMultiByteWithAlloc(&szSearch);
                if(SUCCEEDED(hr))
                {
                    // Make sure we have some IO before we returned the handle, so getsockname will succeed.
                    hr = HrSocketSend(szSearch);
                    delete [] szSearch;

                    if(SUCCEEDED(hr))
                    {
                        hr = m_timer.HrSetTimer(MX_VALUE);
                        if(SUCCEEDED(hr))
                        {
                            {
                                CLock lock(m_critSec);
                                hr = m_searchThread.HrStart(FALSE, FALSE);
                            }
                            if(FAILED(hr))
                            {
                                HrDeleteTimer();
                            }
                        }
                    }
                }
            }
            else
            {
                hr = m_searchThread.HrStart(FALSE, FALSE);
            }
        }
    }

    if(FAILED(hr))
    {
        (*pfnCallback)(SSDP_DONE, NULL, pvContext);
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrStartAsync");
    return hr;
}

HRESULT CSsdpSearchRequest::HrStartSync(BOOL bForceSearch)
{
    HRESULT hr = S_OK;

    if (!cInitialized)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }

    m_searchState = SEARCH_DISCOVERING;

    hr = HrGetCacheResult();
    if(SUCCEEDED(hr))
    {
        if(bForceSearch || !FIsInListNotify(m_strType))
        {
            m_bHitWire = TRUE;

            char * szSearch = NULL;
            hr = m_strSearch.HrGetMultiByteWithAlloc(&szSearch);
            if(SUCCEEDED(hr))
            {
                hr = HrSocketSend(szSearch);
                delete [] szSearch;

                if(SUCCEEDED(hr))
                {
                    hr = m_timer.HrSetTimer(MX_VALUE);

                    if(SUCCEEDED(hr))
                    {
                        hr = DwThreadFunc();
                        if(SUCCEEDED(hr))
                        {
                            if(m_responseMessageList.IsEmpty())
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_SERVICES);
                            }
                        }
                        HrDeleteTimer();
                    }
                }
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrStartSync");
    return hr;
}

HRESULT CSsdpSearchRequest::HrShutdown()
{
    HRESULT hr = S_OK;

    {
        CLock lock(m_critSec);
        m_searchState = SEARCH_COMPLETED;
    }

    if(m_pfnCallback)
    {
        hr = HrCancelCallback();
        if(SUCCEEDED(hr))
        {
            DWORD dwResult;

            if (m_hEventDone)
                SetEvent(m_hEventDone);

            HANDLE h = m_searchThread.GetThreadHandle();
            hr = HrMyWaitForMultipleHandles(0,
                                            INFINITE,
                                            1,
                                            &h,
                                            &dwResult);
            TraceError("CSsdpSearchRequest::HrShutdown: HrMyWaitForMultipleHandles", hr);
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrShutdown");
    return hr;
}

HRESULT CSsdpSearchRequest::HrCancelCallback()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    m_bShutdown = TRUE;

    hr = HrDeleteTimer();

    WakeupSelect();

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrCancelCallback");
    return hr;
}

void CSsdpSearchRequest::WakeupSelect()
{
    SOCKADDR_IN sockAddrIn;
    int nAddrInSize = sizeof(sockAddrIn);

    long nCount = m_socketList.GetCount();
    for(long n = 0; n < nCount; ++n)
    {
        if(SOCKET_ERROR != getsockname(m_socketList[n].m_socket, reinterpret_cast<sockaddr*>(&sockAddrIn), &nAddrInSize))
        {
            sockAddrIn.sin_addr.s_addr = inet_addr("127.0.0.1");
            TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::WakeupSelect() - sending to 127.0.0.1:%d", ntohs(sockAddrIn.sin_port));
            // Will select get this if the socket is not bound to ADDR_ANY?
            SocketSend("Q", m_socketList[n].m_socket, &sockAddrIn);
        }
        else
        {
            TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::WakeupSelect() - failed to send loopback packet. (%d)", GetLastError());
            // select will eventually timeout, just slower.
        }
    }
}

HRESULT CSsdpSearchRequest::HrGetCacheResult()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    MessageList * pMessageList = NULL;

    char * szType = NULL;
    hr = m_strType.HrGetMultiByteWithAlloc(&szType);
    if(SUCCEEDED(hr))
    {
        RpcTryExcept
        {
            LookupCacheRpc(szType, &pMessageList);
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            hr = HRESULT_FROM_WIN32(RpcExceptionCode());
            TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::HrGetCacheResult - LookupCacheRpc failed (%x)", RpcExceptionCode());
        }
        RpcEndExcept

        delete [] szType;

        if(pMessageList)
        {
            for(long n = 0; n < pMessageList->size; ++n)
            {
                hr = HrAddRequestToResponseMessageList(&pMessageList->list[n]);
                if(FAILED(hr))
                {
                    break;
                }
            }
            for(long n = 0; n < pMessageList->size; ++n)
            {
                FreeSsdpRequest(&pMessageList->list[n]);
            }
            delete [] pMessageList->list;
            delete pMessageList;

            // Make the callbacks
            ResponseMessageList::Iterator iter;
            if(S_OK == m_responseMessageList.GetIterator(iter))
            {
                SSDP_MESSAGE * pSsdpMessage = NULL;
                while(S_OK == iter.HrGetItem(&pSsdpMessage))
                {
                    if(m_pfnCallback)
                    {
                        (*m_pfnCallback)(SSDP_FOUND, pSsdpMessage, m_pvContext);
                    }
                    if(S_OK != iter.HrNext())
                    {
                        break;
                    }
                }
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrGetCacheResult");
    return hr;
}

BOOL CSsdpSearchRequest::FIsInListNotify(const CUString & strType)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    char * szType = NULL;
    hr = strType.HrGetMultiByteWithAlloc(&szType);
    if(SUCCEEDED(hr))
    {
        if(!IsInListNotify(szType))
        {
            hr = S_FALSE;
        }

        delete [] szType;
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::FIsInListNotify");
    return S_OK == hr;
}

HRESULT CSsdpSearchRequest::HrAddRequestToResponseMessageList(SSDP_REQUEST * pRequest)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    // Build a temporary item in a list and then transfer
    ResponseMessageList responseMessageList;
    hr = responseMessageList.HrPushFrontDefault();
    if(SUCCEEDED(hr))
    {
        if(InitializeSsdpMessageFromRequest(&responseMessageList.Front(), pRequest))
        {
            m_responseMessageList.Prepend(responseMessageList);
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrAddRequestToResponseMessageList");
    return hr;
}

BOOL CSsdpSearchRequest::FIsInResponseMessageList(const char * szUSN)
{
    CLock lock(m_critSec);

    BOOL bRet = FALSE;

    ResponseMessageList::Iterator iter;
    if(S_OK == m_responseMessageList.GetIterator(iter))
    {
        SSDP_MESSAGE * pSsdpMessage = NULL;
        while(S_OK == iter.HrGetItem(&pSsdpMessage))
        {
            if(!lstrcmpA(szUSN, pSsdpMessage->szUSN))
            {
                bRet = TRUE;
                break;
            }
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }
    return bRet;
}

DWORD CSsdpSearchRequest::DwThreadFunc()
{
    HRESULT hr = S_OK;

    fd_set setReadSocket;
    timeval tvSelectTimeOut;

    tvSelectTimeOut.tv_sec = SELECT_TIMEOUT;
    tvSelectTimeOut.tv_usec = 0;

    long nRet;

    if(m_bOnlyLoopBack)
    {
        hr = HrProcessLoopbackAddrOnly();
    }
    if(FAILED(hr))
    {
        m_bShutdown = TRUE;
        SetEvent(m_hEventDone);
    }
    while(!m_bShutdown)
    {
        char * szRecvBuf = NULL;
        u_long ulBytesReceived;
        SOCKADDR_IN sockAddrInRemoteSocket;
        SSDP_REQUEST ssdpRequestResponse;
        u_long ulBufferSize;
        int nSockAddrInSize = sizeof(sockAddrInRemoteSocket);
        long n;
        long nCount;


        FD_ZERO(&setReadSocket);
        nCount = m_socketList.GetCount();
        for(n = 0; n < nCount; ++n)
        {
            FD_SET(m_socketList[n].m_socket, &setReadSocket);
        }

        TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc(this=%x) - about to call select", this);
        nRet = select(-1, &setReadSocket, NULL, NULL, &tvSelectTimeOut);

        if(SOCKET_ERROR == nRet)
        {
            TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc - select failed(%d)", nRet);
            break;
        }

        if(!nRet)
        {
            TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc !!! select timed out !!!, where is loopback packet? ");
            hr = HrDeleteTimer();
            break;
        }

        BOOL bBreak = FALSE;

        for(n = 0; n < nCount; ++n)
        {

            if(FD_ISSET(m_socketList[n].m_socket, &setReadSocket))
            {
                ioctlsocket(m_socketList[n].m_socket, FIONREAD, &ulBufferSize);

                szRecvBuf = new char[ulBufferSize + 1];
                if(!szRecvBuf)
                {
                    hr = E_OUTOFMEMORY;
                }

                if(FAILED(hr))
                {
                    hr = HrDeleteTimer();
                    bBreak = TRUE;
                    break;
                }
                if(SUCCEEDED(hr))
                {
                    TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc(this=%x) - about to call recvfrom", this);
                    ulBytesReceived = recvfrom(m_socketList[n].m_socket, szRecvBuf, ulBufferSize, 0,
                                               reinterpret_cast<sockaddr*>(&sockAddrInRemoteSocket), &nSockAddrInSize);
                    if(SOCKET_ERROR == ulBytesReceived)
                    {
                        CLock lock(m_critSec);
                        delete [] szRecvBuf;
                        DWORD dwError = WSAGetLastError();
                        if(WSAECONNRESET == dwError)
                        {
                            TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc - recvfrom failed as this socket has received port unreachable");
                            continue;
                        }
                        TraceTag(ttidError, "CSsdpSearchRequest::DwThreadFunc - recvfrom failed(%d)", dwError);
                        hr = HrDeleteTimer();
                        bBreak = TRUE;
                        break;
                    }
                    else
                    {
                        szRecvBuf[ulBytesReceived] = 0;
                        TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc(this=%x) - recvfrom returned: %s", this, szRecvBuf);
                    }
                }


                if(SUCCEEDED(hr))
                {
                    if(!InitializeSsdpRequest(&ssdpRequestResponse))
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    if(SUCCEEDED(hr))
                    {
                        if(ParseSsdpResponse(szRecvBuf, &ssdpRequestResponse))
                        {
                            // Set the interface on which we received this
                            ssdpRequestResponse.guidInterface = m_socketList[n].m_guidInterface;

                            // preserve source address if possible.
                            // hack here where we use szSID to hold address
                            // this should not be used for search response normally.
                            if (ssdpRequestResponse.Headers[GENA_SID] == NULL)
                            {
                                char* pszIp = GetSourceAddress(sockAddrInRemoteSocket);
                                ssdpRequestResponse.Headers[GENA_SID] = (CHAR *) midl_user_allocate(
                                                                        sizeof(CHAR) * (strlen(pszIp) + 1));
                                if (ssdpRequestResponse.Headers[GENA_SID])
                                {
                                    strcpy(ssdpRequestResponse.Headers[GENA_SID], pszIp);
                                }
                            }

                            // Check duplicate
                            if(!FIsInResponseMessageList(ssdpRequestResponse.Headers[SSDP_USN]))
                            {
                                // Build a temporary item in a list and then transfer
                                ResponseMessageList responseMessageList;
                                hr = responseMessageList.HrPushFrontDefault();
                                if(SUCCEEDED(hr))
                                {
                                    if(InitializeSsdpMessageFromRequest(&responseMessageList.Front(), &ssdpRequestResponse))
                                    {
                                        if(m_pfnCallback)
                                        {
                                            (*m_pfnCallback)(SSDP_FOUND, &responseMessageList.Front(), m_pvContext);
                                        }
                                        CLock lock(m_critSec);
                                        m_responseMessageList.Prepend(responseMessageList);
                                    }
                                }
                                RpcTryExcept
                                {
                                    TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc(this=%x) - about to call UpdateCacheRpc", this);
                                    UpdateCacheRpc(&ssdpRequestResponse);
                                }
                                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                                {
                                    hr = HRESULT_FROM_WIN32(RpcExceptionCode());
                                    TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc - UpdateCacheRpc failed (%x)", RpcExceptionCode());
                                }
                                RpcEndExcept

                            }
                            FreeSsdpRequest(&ssdpRequestResponse);
                        }
                    }
                    if(FAILED(hr))
                    {
                        TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::DwThreadFunc(this=%x) - processing of select failed", this);
                    }
                }

                delete [] szRecvBuf;
                szRecvBuf = NULL;
            }
            if(bBreak)
            {
                break;
            }
        }
    }

    // FindServices ideally should Get Cache at the of search to the most up-to-date info.
    // FindServicesCallback ideally should Get Cache first to give faster responses.
    // Get the cache at the beginning to make the code common.

    {
        CLock lock(m_critSec);
        long nCount = m_socketList.GetCount();
        for(long n = 0; n < nCount; ++n)
        {
            closesocket(m_socketList[n].m_socket);
        }
        m_socketList.Clear();
    }

    if(m_pfnCallback)
    {
        (*m_pfnCallback)(SSDP_DONE, NULL, m_pvContext);
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::DwThreadFunc");
    return hr;
}

void CSsdpSearchRequest::TimerFired()
{
    HRESULT hr = S_OK;

    TraceTag(ttidSsdpCSearch, "CSsdpSearchRequest::TimerFired(this=%x, count=%d)", this, m_nNumOfRetry);

    if(m_bShutdown)
    {
        SetEvent(m_hEventDone);
        return;
    }

    _try
    {
        if(0 == m_nNumOfRetry)
        {
            TraceTag(ttidSsdpSearchResp, "CSsdpSearchRequest::TimerFired(this=%x) - timed out", this);
            m_bShutdown = TRUE;
            WakeupSelect();
            SetEvent(m_hEventDone);
        }
        else
        {
            char * szSearch = NULL;
            hr = m_strSearch.HrGetMultiByteWithAlloc(&szSearch);
            if(SUCCEEDED(hr))
            {
                hr = HrSocketSend(szSearch);
                delete [] szSearch;

                if(SUCCEEDED(hr))
                {
                    --m_nNumOfRetry;
                    hr = m_timer.HrSetTimerInFired(MX_VALUE);
                    TraceTag(ttidSsdpSearchResp, "CSsdpSearchRequest::TimerFired(this=%x) - Num of Retry %d", this,m_nNumOfRetry);
                }
                if(FAILED(hr))
                {
                    TraceHr(ttidSsdpSearchResp, FAL, hr, FALSE, "CSsdpSearchRequest::TimerFired - failed to restart timer");
                    m_bShutdown = TRUE;
                    WakeupSelect();
                    SetEvent(m_hEventDone);
                }
            }
        }
    }
    _finally
    {
    }
}

BOOL CSsdpSearchRequest::TimerTryToLock()
{
    return m_critSec.FTryEnter();
}

void CSsdpSearchRequest::TimerUnlock()
{
    m_critSec.Leave();
}

HRESULT CSsdpSearchRequest::HrInitializeSsdpSearchRequest(SSDP_REQUEST * pRequest,char * szType)
{
    HRESULT hr = S_OK;

    ZeroMemory(pRequest, sizeof(SSDP_REQUEST));

    pRequest->Method = SSDP_M_SEARCH;
    pRequest->RequestUri = MulticastUri;
    pRequest->Headers[SSDP_MAN] = SearchHeader;
    pRequest->Headers[SSDP_MX] = MX;

    pRequest->Headers[SSDP_HOST] = new char[sizeof(CHAR) *
                                                   (strlen(SSDP_ADDR) +
                                                    1 + // colon
                                                    6 + // port number
                                                    1)];
    if(!pRequest->Headers[SSDP_HOST])
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        wsprintfA(pRequest->Headers[SSDP_HOST], "%s:%d", SSDP_ADDR, SSDP_PORT);
        hr = HrCopyString(szType, &pRequest->Headers[SSDP_ST]);
    }

    if(FAILED(hr))
    {
        delete [] pRequest->Headers[SSDP_HOST];
        delete [] pRequest->Headers[SSDP_ST];
        ZeroMemory(pRequest, sizeof(SSDP_REQUEST));
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrInitializeSsdpSearchRequest");
    return hr;
}

HRESULT CSsdpSearchRequest::HrGetFirstService(SSDP_MESSAGE ** ppSsdpMessage)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    hr = m_responseMessageList.GetIterator(m_iterCurrentResponse);
    if(S_OK == hr)
    {
        m_iterCurrentResponse.HrGetItem(ppSsdpMessage);
        m_iterCurrentResponse.HrNext();
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrGetFirstService");
    return hr;
}

HRESULT CSsdpSearchRequest::HrGetNextService(SSDP_MESSAGE ** ppSsdpMessage)
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    if(!m_iterCurrentResponse.FIsItem())
    {
        hr = S_FALSE;
    }
    if(S_OK == hr)
    {
        m_iterCurrentResponse.HrGetItem(ppSsdpMessage);
        m_iterCurrentResponse.HrNext();
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrGetNextService");
    return hr;
}

HRESULT CSsdpSearchRequest::HrDeleteTimer()
{
    HRESULT hr = S_OK;

    if (!InterlockedExchange((LONG*)&m_bDeletedTimer, TRUE))
    {
        hr = m_timer.HrDelete(INVALID_HANDLE_VALUE);
    }

    TraceHr(ttidSsdpNotify, FAL, hr, FALSE, "CSsdpSearchRequest::HrDeleteTimer");
    return hr;
}

CSsdpSearchRequestManager CSsdpSearchRequestManager::s_instance;

CSsdpSearchRequestManager::CSsdpSearchRequestManager()
{
}

CSsdpSearchRequestManager::~CSsdpSearchRequestManager()
{
}

CSsdpSearchRequestManager & CSsdpSearchRequestManager::Instance()
{
    return s_instance;
}

HRESULT CSsdpSearchRequestManager::HrCleanup()
{
    HRESULT hr = S_OK;

    CLock lock(m_critSec);

    SearchRequestList::Iterator iter;
    if(S_OK == m_searchRequestList.GetIterator(iter))
    {
        CSsdpSearchRequest * pRequestIter = NULL;
        while(S_OK == iter.HrGetItem(&pRequestIter))
        {
            hr = pRequestIter->HrShutdown();

            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }
    m_searchRequestList.Clear();

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequestManager::HrCleanup");
    return hr;
}

HRESULT CSsdpSearchRequestManager::HrCreateAsync(
    char * szType,
    BOOL bForceSearch,
    SERVICE_CALLBACK_FUNC pfnCallback,
    VOID * pvContext,
    CSsdpSearchRequest ** ppSearchRequest)
{
    HRESULT hr = S_OK;

    if(!ppSearchRequest)
    {
        return E_POINTER;
    }

    if(!cInitialized)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }

    if(!szType || !pfnCallback)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    SearchRequestList searchRequestList;
    hr = searchRequestList.HrPushFrontDefault();
    if(SUCCEEDED(hr))
    {
        hr = searchRequestList.Front().HrInitialize(szType);
        if(SUCCEEDED(hr))
        {
            hr = searchRequestList.Front().HrStartAsync(bForceSearch, pfnCallback, pvContext);
            if(SUCCEEDED(hr))
            {
                CLock lock(m_critSec);
                m_searchRequestList.Prepend(searchRequestList);
                *ppSearchRequest = &m_searchRequestList.Front();
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequestManager::HrCreateAsync");
    return hr;
}

HRESULT CSsdpSearchRequestManager::HrCreateSync(
    char * szType,
    BOOL bForceSearch,
    CSsdpSearchRequest ** ppSearchRequest)
{
    HRESULT hr = S_OK;

    if(!ppSearchRequest)
    {
        return E_POINTER;
    }

    if(!cInitialized)
    {
        return HRESULT_FROM_WIN32(ERROR_NOT_READY);
    }

    if(!szType)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    SearchRequestList searchRequestList;
    hr = searchRequestList.HrPushFrontDefault();
    if(SUCCEEDED(hr))
    {
        hr = searchRequestList.Front().HrInitialize(szType);
        if(SUCCEEDED(hr))
        {
            hr = searchRequestList.Front().HrStartSync(bForceSearch);
            if(SUCCEEDED(hr))
            {
                CLock lock(m_critSec);
                m_searchRequestList.Prepend(searchRequestList);
                *ppSearchRequest = &m_searchRequestList.Front();
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequestManager::HrCreateSync");
    return hr;
}

HRESULT CSsdpSearchRequestManager::HrRemove(CSsdpSearchRequest * pSearchRequest)
{
    HRESULT hr = S_FALSE;

    SearchRequestList searchRequestList;

    {
        CLock lock(m_critSec);
        SearchRequestList::Iterator iter;
        if(S_OK == m_searchRequestList.GetIterator(iter))
        {
            CSsdpSearchRequest * pRequestIter = NULL;
            while(S_OK == iter.HrGetItem(&pRequestIter))
            {
                if(pSearchRequest == pRequestIter)
                {
                    iter.HrMoveToList(searchRequestList);
                    break;
                }

                if(S_OK != iter.HrNext())
                {
                    break;
                }
            }
        }
    }

    // Delete outside of lock
    SearchRequestList::Iterator iter;
    if(S_OK == searchRequestList.GetIterator(iter))
    {
        CSsdpSearchRequest * pRequestIter = NULL;
        while(S_OK == iter.HrGetItem(&pRequestIter))
        {
            hr = pRequestIter->HrShutdown();
            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequestManager::HrRemove");
    return hr;
}

HRESULT CSsdpSearchRequestManager::HrGetFirstService(CSsdpSearchRequest * pSearchRequest, SSDP_MESSAGE ** ppSsdpMessage)
{
    HRESULT hr = S_FALSE;

    SearchRequestList::Iterator iter;
    if(S_OK == m_searchRequestList.GetIterator(iter))
    {
        CSsdpSearchRequest * pRequestIter = NULL;
        while(S_OK == iter.HrGetItem(&pRequestIter))
        {
            if(pSearchRequest == pRequestIter)
            {
                hr = pRequestIter->HrGetFirstService(ppSsdpMessage);
                break;
            }

            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequestManager::HrGetFirstService");
    return hr;
}

HRESULT CSsdpSearchRequestManager::HrGetNextService(CSsdpSearchRequest * pSearchRequest, SSDP_MESSAGE ** ppSsdpMessage)
{
    HRESULT hr = S_FALSE;

    SearchRequestList::Iterator iter;
    if(S_OK == m_searchRequestList.GetIterator(iter))
    {
        CSsdpSearchRequest * pRequestIter = NULL;
        while(S_OK == iter.HrGetItem(&pRequestIter))
        {
            if(pSearchRequest == pRequestIter)
            {
                hr = pRequestIter->HrGetNextService(ppSsdpMessage);
                break;
            }

            if(S_OK != iter.HrNext())
            {
                break;
            }
        }
    }

    TraceHr(ttidSsdpCNotify, FAL, hr, FALSE, "CSsdpSearchRequestManager::HrGetNextService");
    return hr;
}

BOOL InitializeListSearch()
{
    return TRUE;
}

VOID CleanupListSearch()
{
    CSsdpSearchRequestManager::Instance().HrCleanup();
}

HANDLE WINAPI FindServicesCallback (CHAR * szType,
                                    VOID * pReserved ,
                                    BOOL fForceSearch,
                                    SERVICE_CALLBACK_FUNC fnCallback,
                                    VOID *Context)
{
    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return INVALID_HANDLE_VALUE;
    }

    if (szType == NULL || !*szType || fnCallback == NULL || pReserved != NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    CSsdpSearchRequest * pSearchRequest = NULL;
    HRESULT hr = CSsdpSearchRequestManager::Instance().HrCreateAsync(szType, fForceSearch, fnCallback, Context, &pSearchRequest);

    if(FAILED(hr))
    {
        SetLastError(DwWin32ErrorFromHr(hr));
        return INVALID_HANDLE_VALUE;
    }

    return pSearchRequest;
}

BOOL WINAPI FindServicesCancel(HANDLE SearchHandle)
{
    CSsdpSearchRequest * pRequest = reinterpret_cast<CSsdpSearchRequest*>(SearchHandle);
    HRESULT hr = pRequest->HrCancelCallback();
    if(FAILED(hr))
    {
        SetLastError(DwWin32ErrorFromHr(hr));
    }
    return S_OK == hr;
}

BOOL WINAPI FindServicesClose(HANDLE SearchHandle)
{
    CSsdpSearchRequest * pRequest = reinterpret_cast<CSsdpSearchRequest*>(SearchHandle);
    HRESULT hr = CSsdpSearchRequestManager::Instance().HrRemove(pRequest);
    if(FAILED(hr))
    {
        SetLastError(DwWin32ErrorFromHr(hr));
    }
    return S_OK == hr;
}

HANDLE WINAPI FindServices(CHAR* szType, VOID *pReserved , BOOL fForceSearch)
{
    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return INVALID_HANDLE_VALUE;
    }

    if (szType == NULL || !*szType || pReserved != NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    CSsdpSearchRequest * pSearchRequest = NULL;
    HRESULT hr = CSsdpSearchRequestManager::Instance().HrCreateSync(szType, fForceSearch, &pSearchRequest);

    if(FAILED(hr))
    {
        SetLastError(DwWin32ErrorFromHr(hr));
        return INVALID_HANDLE_VALUE;
    }

    return pSearchRequest;
}

BOOL WINAPI GetFirstService(HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService)
{
    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    if (!ppSsdpService ||
        !hFindServices ||
        hFindServices == INVALID_HANDLE_VALUE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    CSsdpSearchRequest * pRequest = reinterpret_cast<CSsdpSearchRequest*>(hFindServices);
    HRESULT hr = CSsdpSearchRequestManager::Instance().HrGetFirstService(pRequest, ppSsdpService);
    if(FAILED(hr))
    {
        SetLastError(DwWin32ErrorFromHr(hr));
    }
    return S_OK == hr;
}

BOOL WINAPI GetNextService(HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService)
{
    if (!cInitialized)
    {
        SetLastError(ERROR_NOT_READY);
        return FALSE;
    }

    if (!ppSsdpService ||
        !hFindServices ||
        hFindServices == INVALID_HANDLE_VALUE)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    CSsdpSearchRequest * pRequest = reinterpret_cast<CSsdpSearchRequest*>(hFindServices);
    HRESULT hr = CSsdpSearchRequestManager::Instance().HrGetNextService(pRequest, ppSsdpService);
    if(FAILED(hr))
    {
        SetLastError(DwWin32ErrorFromHr(hr));
    }
    return S_OK == hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\ssdpapi.h ===
#ifndef _SSDPAPI_H
#define _SSDPAPI_H

#include "client.h"
#include "../inc/ssdperror.h"

#ifdef  __cplusplus
extern "C" {
#endif

// DO NOT REORDER THIS ENUMERATION.  ADD NEW VALUES TO THE END.
//   if you do, change the necessary code in upnpdevicefinder.cpp
typedef enum _SSDP_CALLBACK_TYPE {
    SSDP_FOUND = 0,
    SSDP_ALIVE = 1,
    SSDP_BYEBYE = 2,
    SSDP_DONE = 3,
    SSDP_EVENT = 4,
    SSDP_DEAD = 5,
} SSDP_CALLBACK_TYPE, *PSSDP_CALLBACK_TYPE;

typedef void (WINAPI *SERVICE_CALLBACK_FUNC)(SSDP_CALLBACK_TYPE CallbackType,
                                      CONST SSDP_MESSAGE *pSsdpService,
                                      void *pContext);

VOID WINAPI FreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage);

HANDLE WINAPI RegisterService(PSSDP_MESSAGE pSsdpMessage, DWORD flags);

BOOL WINAPI DeregisterService(HANDLE hRegister, BOOL fByebye);

BOOL WINAPI DeregisterServiceByUSN(char * szUSN, BOOL fByebye);

HANDLE WINAPI RegisterNotification (NOTIFY_TYPE nt, char * szType, char *szEventUrl, SERVICE_CALLBACK_FUNC fnCallback,void *pContext);

BOOL WINAPI DeregisterNotification(HANDLE hNotification);

BOOL WINAPI RegisterUpnpEventSource(LPCSTR szRequestUri, DWORD cProps,
                                    UPNP_PROPERTY *rgProps);
BOOL WINAPI DeregisterUpnpEventSource(LPCSTR szRequestUri);

BOOL WINAPI SubmitUpnpPropertyEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                                    DWORD cProps, UPNP_PROPERTY *rgProps);

BOOL WINAPI SubmitEvent(LPCSTR szEventSourceUri, DWORD dwFlags,
                        LPCSTR szHeaders, LPCSTR szEventBody);

BOOL WINAPI GetEventSourceInfo(LPCSTR szEventSourceUri, EVTSRC_INFO **ppinfo);

HANDLE WINAPI FindServices (char* szType, void *pReserved , BOOL fForceSearch);

HANDLE WINAPI FindServicesCallback (char * szType,
                             void * pReserved ,
                             BOOL fForceSearch,
                             SERVICE_CALLBACK_FUNC fnCallback,
                             void *Context
                             );

BOOL WINAPI GetFirstService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI GetNextService (HANDLE hFindServices, PSSDP_MESSAGE *ppSsdpService);

BOOL WINAPI FindServicesClose(HANDLE hSearch);

BOOL WINAPI FindServicesCancel(HANDLE hSearch);

BOOL WINAPI CleanupCache();

BOOL WINAPI SsdpStartup();

void WINAPI SsdpCleanup();

void WINAPI DHEnableDeviceHost();
void WINAPI DHDisableDeviceHost();
void WINAPI DHSetICSInterfaces(long nCount, GUID * arInterfaces);
void WINAPI DHSetICSOff();

#ifdef  __cplusplus
}   /* ... extern "C" */
#endif

#endif // _SSDPAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\searchc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       S E A R C H C . H
//
//  Contents:   Client side searching
//
//  Notes:
//
//  Author:     mbend   2 Dec 2000
//
//----------------------------------------------------------------------------

#include "ustring.h"
#include "ulist.h"
#include "upthread.h"
#include "upsync.h"
#include "timer.h"
#include "array.h"
#include "winsock2.h"
#include "ssdp.h"
#include "ssdpapi.h"
#include "ssdptypesc.h"

class CSsdpSearchRequest;

class CSsdpSearchThread : public CThreadBase
{
public:
    CSsdpSearchThread(CSsdpSearchRequest * pRequest);
    ~CSsdpSearchThread();
private:
    CSsdpSearchThread(const CSsdpSearchThread &);
    CSsdpSearchThread & operator=(const CSsdpSearchThread &);

    DWORD DwRun();

    CSsdpSearchRequest * m_pRequest;
};

struct SocketInfo
{
    SOCKET m_socket;
    GUID m_guidInterface;
};

class CSsdpSearchRequest
{
public:
    CSsdpSearchRequest();
    ~CSsdpSearchRequest();

    HRESULT HrInitialize(char * szType);
    HRESULT HrBuildSocketList();
    HRESULT HrReBuildSocketList();
    HRESULT HrProcessLoopbackAddrOnly();
    HRESULT HrSocketSend(const char * szData);
    HRESULT HrStartAsync(
        BOOL bForceSearch,
        SERVICE_CALLBACK_FUNC pfnCallback,
        VOID * pvContext);
    HRESULT HrStartSync(BOOL bForceSearch);
    HRESULT HrShutdown();
    HRESULT HrCancelCallback();
    void WakeupSelect();
    HRESULT HrGetCacheResult();
    BOOL FIsInListNotify(const CUString & strType);
    BOOL FIsInResponseMessageList(const char * szUSN);
    HRESULT HrAddRequestToResponseMessageList(SSDP_REQUEST * pRequest);
    DWORD DwThreadFunc();
    HRESULT HrGetFirstService(SSDP_MESSAGE ** ppSsdpMessage);
    HRESULT HrGetNextService(SSDP_MESSAGE ** ppSsdpMessage);

    void TimerFired();
    BOOL TimerTryToLock();
    void TimerUnlock();
private:
    CSsdpSearchRequest(const CSsdpSearchRequest &);
    CSsdpSearchRequest & operator=(const CSsdpSearchRequest &);

    static HRESULT HrInitializeSsdpSearchRequest(SSDP_REQUEST * pRequest,char * szType);

    typedef CUList<SSDP_MESSAGE> ResponseMessageList;
    typedef CUArray<SocketInfo> SocketList;

    SearchState     m_searchState;
    CUString        m_strType;
    CUString        m_strSearch;
    SERVICE_CALLBACK_FUNC   m_pfnCallback;
    void *          m_pvContext;
    long            m_nNumOfRetry;
    BOOL            m_bExit;
    ResponseMessageList m_responseMessageList;
    ResponseMessageList::Iterator m_iterCurrentResponse;
    CTimer<CSsdpSearchRequest> m_timer;
    SocketList      m_socketList;
    BOOL            m_bHitWire;
    CUCriticalSection m_critSec;
    HANDLE          m_hEventDone;
    CSsdpSearchThread m_searchThread;
    OVERLAPPED      m_ovInterfaceChange;
    volatile BOOL   m_bShutdown;
    BOOL            m_bOnlyLoopBack;    // Auto IP issue
    BOOL            m_bDeletedTimer;

    HRESULT HrDeleteTimer();
};

class CSsdpSearchRequestManager
{
public:
    ~CSsdpSearchRequestManager();

    static CSsdpSearchRequestManager & Instance();

    HRESULT HrCleanup();
    HRESULT HrCreateAsync(
        char * szType,
        BOOL bForceSearch,
        SERVICE_CALLBACK_FUNC pfnCallback,
        VOID * pvContext,
        CSsdpSearchRequest ** ppSearchRequest);
    HRESULT HrCreateSync(
        char * szType,
        BOOL bForceSearch,
        CSsdpSearchRequest ** ppSearchRequest);
    HRESULT HrRemove(CSsdpSearchRequest * pSearchRequest);
    HRESULT HrGetFirstService(CSsdpSearchRequest * pSearchRequest, SSDP_MESSAGE ** ppSsdpMessage);
    HRESULT HrGetNextService(CSsdpSearchRequest * pSearchRequest, SSDP_MESSAGE ** ppSsdpMessage);

private:
    CSsdpSearchRequestManager();
    CSsdpSearchRequestManager(const CSsdpSearchRequestManager &);
    CSsdpSearchRequestManager & operator=(const CSsdpSearchRequestManager &);

    static CSsdpSearchRequestManager s_instance;

    typedef CUList<CSsdpSearchRequest> SearchRequestList;

    CUCriticalSection m_critSec;
    SearchRequestList m_searchRequestList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\ssdpfuncc.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

File Name:

    ssdpfuncc.h

Abstract:

    This file contains cross files function prototypes.

Author: Ting Cai

Created: 09/5/1999

--*/
#ifndef _SSDPFUNCC_
#define _SSDPFUNCC_

#include "ssdptypesc.h"
#include "ssdpnetwork.h"

BOOL InitializeListNotify();
void CleanupListNotify();
BOOL IsInListNotify(char *szType);
void PrintSsdpMessageList(MessageList *list);
BOOL InitializeSsdpMessageFromRequest(PSSDP_MESSAGE pSsdpMessage, const PSSDP_REQUEST pSsdpRequest);
BOOL CopySsdpMessage(PSSDP_MESSAGE pDestination, const PSSDP_MESSAGE pSource);
BOOL InitializeListSearch();
void CleanupListSearch();

void FreeMessageList(MessageList *list);
VOID CleanupNotificationThread(VOID);

#endif // _SSDPFUNCC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\ssdpapi.cpp ===
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "objbase.h"

#include "status.h"
#include "ssdpfuncc.h"
#include "ssdpapi.h"
#include "common.h"
#include "ncmem.h"
#include "ncdefine.h"
#include "ncdebug.h"
#include "client_c.c"
#include "timer.h"
#include <rpcasync.h>   // I_RpcExceptionFilter

extern HANDLE g_hLaunchEvent;
extern RTL_RESOURCE g_rsrcReg;

LONG cInitialized = 0;

static CRITICAL_SECTION g_csListOpenConn;

int RpcClientStop();

static CONST c_msecMaxServiceStart = 30 * 1000; // 30 seconds
static CONST c_msecPollInterval = 100;          // .1 seconds

BOOL FStartSsdpService()
{
    SC_HANDLE   scm;
    BOOL        fRet = FALSE;

    scm = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (scm)
    {
        SC_HANDLE   hsvc;

        hsvc = OpenService(scm, "SSDPSRV", SERVICE_QUERY_STATUS | SERVICE_START);
        if (hsvc)
        {
            SERVICE_STATUS  status = {0};
            DWORD   dwTickStart = GetTickCount();
            BOOL    fDone = FALSE;

            do
            {
                if (QueryServiceStatus(hsvc, &status))
                {
                    switch (status.dwCurrentState)
                    {
                        case SERVICE_RUNNING:

                            TraceTag(ttidSsdpCRpcInit, "SSDP Service has started");
                            // Success!

                            fDone = TRUE;
                            fRet = TRUE;

                            break;

                        case SERVICE_STOPPED:

                            if (!StartService(hsvc, 0, NULL))
                            {
                                AssertSz(GetLastError() != ERROR_SERVICE_ALREADY_RUNNING,
                                         "Service cannot be running!");

                                TraceError("StartSsdpService - could not query"
                                           "start SSDPSRV service!",
                                           HrFromLastWin32Error());
                                fDone = TRUE;
                            }
                            else
                            {
                                // reset this again to be more accurate
                                dwTickStart = GetTickCount();
                            }
                            break;

                        case SERVICE_START_PENDING:
                            if (GetTickCount() -
                                     dwTickStart >= c_msecMaxServiceStart)
                            {
                                // Time ran out
                                fDone = TRUE;
                            }
                            else
                            {
                                Sleep(c_msecPollInterval);
                            }
                            break;
                    }
                }
                else
                {
                    // Error!
                    TraceError("StartSsdpService - could not query"
                               "service status for SSDPSRV!",
                               HrFromLastWin32Error());
                    fDone = TRUE;
                }

            } while (!fDone);

            CloseServiceHandle(hsvc);
        }
        else
        {
            TraceError("StartSsdpService - could not open SSDPSRV service!",
                       HrFromLastWin32Error());
        }

        CloseServiceHandle(scm);
    }
    else
    {
        TraceError("StartSsdpService - could not open SC Manager!",
                   HrFromLastWin32Error());
    }

    return fRet;
}

int RpcClientStart()
{
    HRESULT hr = S_OK;

    RPC_STATUS status;
    unsigned char * pszUuid             = NULL;
    unsigned char * pszProtocolSequence = (unsigned char *)"ncalrpc";
    unsigned char * pszNetworkAddress   = NULL;
    unsigned char * pszOptions          = NULL;
    unsigned char * pszStringBinding    = NULL;
    unsigned long ulCode;

    status = 0;
    hSSDP = NULL;

#ifdef DBG
    InitializeDebugging();
#endif // DBG

    TraceTag(ttidSsdpCRpcInit, "RpcClientStart - Enter");

    if (!InitializeListNotify())
    {
        TraceTag(ttidError, "RpcClientStart - InitializeListNotify failed");
        goto cleanup;
    }

    RtlInitializeResource(&g_rsrcReg);

    if (!FStartSsdpService())
    {
        TraceTag(ttidError, "RpcClientStart - Failed to start SSDPSRV service");
        goto cleanup;
    }

    InitializeListSearch();

    hr = CTimerQueue::Instance().HrInitialize();
    if(FAILED(hr))
    {
        TraceHr(ttidSsdpCRpcInit, FAL, hr, FALSE, "RpcClientStart - CTimerQueue::Instance().HrInitialize failed");
        goto cleanup;
    }

    // SocketInit() returns 0 on success, and places failure codes in
    // GetLastError()
    //
    if (SocketInit() !=0)
    {
        TraceTag(ttidError, "RpcClientStart - SocketInit failed");
        goto cleanup;
    }

    Assert(INVALID_HANDLE_VALUE == g_hLaunchEvent);

    g_hLaunchEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    hr = HrFromLastWin32Error();
    TraceTag(ttidSsdpCRpcInit, FAL, hr, FALSE, "RpcClientStart - CreateEvent failed");
    if (g_hLaunchEvent == NULL)
    {
        g_hLaunchEvent = INVALID_HANDLE_VALUE;
        return FALSE;
    }
    Assert(INVALID_HANDLE_VALUE != g_hLaunchEvent);

    /* Use a convenience function to concatenate the elements of */
    /* the string binding into the proper sequence.              */
    // To-Do: Security?
    status = RpcStringBindingCompose(pszUuid,
                                     pszProtocolSequence,
                                     pszNetworkAddress,
                                     NULL,
                                     pszOptions,
                                     &pszStringBinding);

    TraceError("RpcStringBindingCompose returned.", HRESULT_FROM_WIN32(status));

    ABORT_ON_FAILURE(status);

    /* Set the binding handle that will be used to bind to the server. */
    status = RpcBindingFromStringBinding(pszStringBinding, &hSSDP);

    TraceError("RpcBindingFromStringBinding returned.",
               HRESULT_FROM_WIN32(status));

    RpcStringFree(&pszStringBinding);

    ABORT_ON_FAILURE(status);

    TraceTag(ttidSsdpCRpcInit, "RpcClientStart - Exit");

    return TRUE;

cleanup:
    TraceTag(ttidError, "RpcClientStart - Exit with failure");

    RpcClientStop();

    SocketFinish();

#ifdef DBG
    UnInitializeDebugging();
#endif // DBG

    if (status)
    {
        // we got here from rpc errors, which leave their result in 'status'
        ::SetLastError(status);
    }

    return FALSE;
}

int RpcClientStop()
{
    RPC_STATUS status;

    CleanupNotificationThread();
    CleanupListSearch();
    CTimerQueue::Instance().HrShutdown(INVALID_HANDLE_VALUE);

    if (hSSDP != NULL)
    {
        status = RpcBindingFree(&hSSDP);
        hSSDP = NULL;
        TraceError("RpcClientStop returned.", HRESULT_FROM_WIN32(status));
    }

    if (INVALID_HANDLE_VALUE != g_hLaunchEvent)
    {
        BOOL fResult;

        fResult = ::CloseHandle(g_hLaunchEvent);
        Assert(fResult);

        g_hLaunchEvent = INVALID_HANDLE_VALUE;
    }

    RtlDeleteResource(&g_rsrcReg);

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   SsdpStartup
//
//  Purpose:    Initializes global state for the SSDP api functions.
//
//  Arguments:  <none>
//
//  Returns:    If the function succeeds, the return value is nonzero.
//
//              If the function fails, the return value is zero.
//              To get extended error information, call GetLastError.
//
//  Notes:      This must be called at least once before calling any SSDP
//              API functions, or they will fail.with ERROR_NOT_READY.
//
//              To deinitialize the ssdp library for a process,
//              each successful call to SsdpStartup must be balanced by a
//              corresponding call to SsdpCleanup.
//
BOOL WINAPI SsdpStartup()
{
    int iRetVal;

    EnterCriticalSection(&g_csListOpenConn);

    iRetVal = TRUE;

    if (!cInitialized)
    {
        iRetVal = RpcClientStart();
    }

    if (iRetVal)
    {
        // if we didn't hit an error, increment the reference count
        //
        cInitialized++;
    }

    LeaveCriticalSection(&g_csListOpenConn);

    return iRetVal;
}

VOID WINAPI SsdpCleanup()
{
    EnterCriticalSection(&g_csListOpenConn);

    if (cInitialized > 0)
    {
        // decrement the reference count, and cleanup when the count
        // goes to zero.
        //
        if (--cInitialized == 0)
        {
            RpcClientStop();

            SocketFinish();

#ifdef DBG
            UnInitializeDebugging();
#endif // DBG
        }
    }

    LeaveCriticalSection(&g_csListOpenConn);
}

// Delay load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

BOOL
DllMain(IN PVOID DllHandle,
        IN ULONG Reason,
        IN PVOID Context OPTIONAL)
{
    switch (Reason)
    {
    case DLL_PROCESS_ATTACH:

        InitializeCriticalSection(&g_csListOpenConn);

        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        DisableThreadLibraryCalls((HMODULE)DllHandle);
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_PROCESS_DETACH:

        DeleteCriticalSection(&g_csListOpenConn);
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;
}

void WINAPI DHEnableDeviceHost()
{
    EnableDeviceHost();
}

void WINAPI DHDisableDeviceHost()
{
    DisableDeviceHost();
}

void WINAPI DHSetICSInterfaces(long nCount, GUID * arInterfaces)
{
    SetICSInterfaces(nCount, arInterfaces);
}

void WINAPI DHSetICSOff()
{
    SetICSOff();
}

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

VOID __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(malloc(len));
}

VOID __RPC_USER midl_user_free(VOID __RPC_FAR * ptr)
{
    free(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "SSDP Client API DLL"
#define VER_INTERNALNAME_STR            "ssdpapi.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpapi\ssdptypesc.h ===
#pragma once

#include "client.h"
#include "ssdpapi.h"
#include "common.h"
#include <winsock2.h>
#include <assert.h>

#define SSDP_CLIENT_NOTIFY_SIGNATURE 0x1607
#define SSDP_CLIENT_SEARCH_SIGNATURE 0x1608
#define SSDP_CLIENT_EVENT_SIGNATURE 0x1609

typedef struct _SSDP_CLIENT_NOTIFY {

    LIST_ENTRY linkage;

    INT Type;

    INT Size;

    CHAR *szType;

    CHAR *szEventUrl;
    CHAR *szSid;

    DWORD csecTimeout;

    PCONTEXT_HANDLE_TYPE HandleServer;

    SERVICE_CALLBACK_FUNC Callback;

    VOID *Context;

} SSDP_CLIENT_NOTIFY, *PSSDP_CLIENT_NOTIFY;

#define SEARCH_REF_CREATE 0
#define SEARCH_REF_SEARCH 1
#define SEARCH_REF_TIMER 2

#define SEARCH_REF_TOTAL 3

typedef enum _SearchState {
    SEARCH_START,
    SEARCH_WAIT,
    SEARCH_ACTIVE_W_MASTER,
    SEARCH_DISCOVERING,
    SEARCH_COMPLETED
} SearchState, *PSearchState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpsrv\nt\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "SSDP Service DLL"
#define VER_INTERNALNAME_STR            "ssdpsrv.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\ssdp\ssdpsrv\nt\system.cpp ===
#include <pch.h>
#pragma hdrstop

#include "ssdpsrv.h"
#include "status.h"
#include "ncdefine.h"
#include "ncdebug.h"
#include "server_s.c"

static SERVICE_STATUS           serviceStatus;
static SERVICE_STATUS_HANDLE    serviceStatusHandle;

DWORD WINAPI ServiceCtrlHandler(DWORD dwControl, DWORD dwEventType,
                               PVOID pEventData, PVOID pContext);

// Delay load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;

void WINAPI ServiceMain(DWORD argc, LPWSTR *argv)
{
    serviceStatus.dwServiceType = SERVICE_WIN32;
    serviceStatus.dwCurrentState = SERVICE_START_PENDING;
    serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    serviceStatus.dwWin32ExitCode = 0;
    serviceStatus.dwServiceSpecificExitCode = 0;
    serviceStatus.dwCheckPoint = 0;
    serviceStatus.dwWaitHint = 0;

    serviceStatusHandle = RegisterServiceCtrlHandlerEx("ssdpsrv",
                                                       ServiceCtrlHandler,
                                                       NULL);
    if (serviceStatusHandle == (SERVICE_STATUS_HANDLE) 0)
    {
        // To-Do: register an event log
        goto cleanup;
    }

    if (SetServiceStatus(serviceStatusHandle, &serviceStatus) == FALSE)
    {
        // should register an event log .. tbd
        goto cleanup;
    }

    SsdpMain(serviceStatusHandle, &serviceStatus);

cleanup:
    serviceStatus.dwCurrentState = SERVICE_STOPPED;
    SetServiceStatus(serviceStatusHandle, &serviceStatus);
}

DWORD WINAPI ServiceCtrlHandler(DWORD dwControl, DWORD dwEventType,
                               PVOID pEventData, PVOID pContext)

{
    TraceTag(ttidSsdpRpcIf, "ServiceCtrlHandler: %d\n", dwControl);

    switch (dwControl)
    {
    	case SERVICE_CONTROL_SHUTDOWN:
        case SERVICE_CONTROL_STOP:
            _Shutdown();

            serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            SetServiceStatus(serviceStatusHandle, &serviceStatus);

            break;
        case SERVICE_CONTROL_INTERROGATE:
            SetServiceStatus(serviceStatusHandle, &serviceStatus);
            break;
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\esmon\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Event Source monitoring tool"
#define VER_INTERNALNAME_STR            "esmon.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\esmon\mon.cpp ===
#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

ULONG CurrentBufferSize;
PUCHAR PreviousBuffer;
PUCHAR CurrentBuffer;
PUCHAR TempBuffer;

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;

BOOL
WriteConsoleLine(
                HANDLE OutputHandle,
                WORD LineNumber,
                LPSTR Text,
                BOOL Highlight
                )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter( OutputHandle,
                                     ' ',
                                     NumberOfCols,
                                     WriteCoord,
                                     &NumberWritten
                                   )
       )
    {
        return FALSE;
    }

    if (Text == NULL || (TextLength = strlen( Text )) == 0)
    {
        return TRUE;
    }
    else
    {
        return WriteConsoleOutputCharacter( OutputHandle,
                                            Text,
                                            TextLength,
                                            WriteCoord,
                                            &NumberWritten
                                          );
    }
}

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    NTSTATUS Status;
    int i;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    ULONG LastCount;
    COORD cp;
    BOOLEAN Active;
    PSYSTEM_THREAD_INFORMATION Thread;
    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_FILECACHE_INFORMATION FileCache;
    SYSTEM_FILECACHE_INFORMATION PrevFileCache;

    CHAR OutputBuffer[ 512 ];
    UCHAR LastKey;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    BOOLEAN DoQuit = FALSE;

    ULONG SkipLine;
    ULONG Hint;
    ULONG Offset1;
    SIZE_T SumCommit;
    int num;
    int lastnum;
    INPUT_RECORD InputRecord;
    DWORD NumRead;
    ULONG Cpu;
    ULONG NoScreenChanges = FALSE;

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    Interactive = TRUE;
    if (Interactive)
    {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           )
        {
            Interactive = FALSE;
        }
        else
        {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               )
            {
                if (OutputHandle != NULL)
                {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            }
            else
            {
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows - 7;
            }
        }
    }

    DelayTimeMsec = 5000;
    DelayTimeTicks = DelayTimeMsec * 10000;

    Active = TRUE;

    while (TRUE)
    {

                DisplayLine = 0;

                sprintf (OutputBuffer,
                         " Memory:%8ldK Avail:%7ldK  PageFlts:%6ld InRam Kernel:%5ldK P:%5ldK",
                         BasicInfo.NumberOfPhysicalPages*(BasicInfo.PageSize/1024),
                         PerfInfo.AvailablePages*(BasicInfo.PageSize/1024),
                         PerfInfo.PageFaultCount - LastCount,
                         (PerfInfo.ResidentSystemCodePage + PerfInfo.ResidentSystemDriverPage)*(BasicInfo.PageSize/1024),
                         (PerfInfo.ResidentPagedPoolPage)*(BasicInfo.PageSize/1024)
                        );
                LastCount = PerfInfo.PageFaultCount;
                WriteConsoleLine( OutputHandle,
                                  DisplayLine++,
                                  OutputBuffer,
                                  FALSE
                                );
        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0)
        {

            //
            // Check for input record
            //

            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               )
            {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ')
                {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1)
                    {
                        DoQuit = TRUE;
                    }
                    else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode)
                    {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;
                    }
                }
                break;
            }
        }
        if (DoQuit)
        {
            if (Interactive)
            {
                SetConsoleActiveScreenBuffer( OriginalOutputHandle );
                SetConsoleMode( InputHandle, OriginalInputMode );
                CloseHandle( OutputHandle );
            }
            return 0;
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\esmon\esmon.cpp ===
#include "pch.h"
#pragma hdrstop

#include "stdio.h"
#include "ncstring.h"
#include "ssdpapi.h"


#define _SECOND ((__int64) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)


const DWORD MAX_DATA = 1024;

#define BUFFER_SIZE 64*1024
#define MAX_BUFFER_SIZE 10*1024*1024

ULONG CurrentBufferSize;
PUCHAR PreviousBuffer;
PUCHAR CurrentBuffer;
PUCHAR TempBuffer;

BOOLEAN Interactive;
ULONG NumberOfInputRecords;
INPUT_RECORD InputRecord;
HANDLE InputHandle;
HANDLE OriginalOutputHandle;
HANDLE OutputHandle;
DWORD OriginalInputMode;
ULONG NumberOfCols;
ULONG NumberOfRows;
ULONG NumberOfDetailLines;
ULONG FirstDetailLine;
CONSOLE_SCREEN_BUFFER_INFO OriginalConsoleInfo;


struct EVTSRC_DATA
{
    CHAR            szEvtSrc[MAX_PATH];
    DWORD           dwLastDiff;
};

EVTSRC_DATA g_rgData[MAX_DATA];


DWORD CsecDiffFileTime(FILETIME * pft1, FILETIME *pft2)
{
    ULONGLONG qwResult1;
    ULONGLONG qwResult2;
    LONG lDiff;

    // Copy the time into a quadword.
    qwResult1 = (((ULONGLONG) pft1->dwHighDateTime) << 32) + pft1->dwLowDateTime;
    qwResult2 = (((ULONGLONG) pft2->dwHighDateTime) << 32) + pft2->dwLowDateTime;

    lDiff = (LONG) (((LONGLONG)(qwResult2 - qwResult1)) / _SECOND);
    lDiff = max(0, lDiff);

    return lDiff;
}

BOOL
WriteConsoleLine(
                HANDLE OutputHandle,
                WORD LineNumber,
                LPSTR Text,
                BOOL Highlight
                )
{
    COORD WriteCoord;
    DWORD NumberWritten;
    DWORD TextLength;

    WriteCoord.X = 0;
    WriteCoord.Y = LineNumber;
    if (!FillConsoleOutputCharacter(OutputHandle,' ', NumberOfCols,
                                    WriteCoord, &NumberWritten))
    {
        return FALSE;
    }

    if (Text == NULL || (TextLength = strlen( Text )) == 0)
    {
        return TRUE;
    }
    else
    {
        return WriteConsoleOutputCharacter(OutputHandle, Text, TextLength,
                                           WriteCoord, &NumberWritten);
    }
}

EXTERN_C
VOID
__cdecl
main (
    IN INT     argc,
    IN PCSTR argv[])
{
    FILE *  pInputFile = NULL;
    CHAR    szBuf[1024];
    DWORD   iData = 0;
    DWORD   cData = 0;
    EVTSRC_INFO     info = {0};
    EVTSRC_INFO *   pinfo = &info;
    BOOL    fDone = FALSE;

    int i;
    ULONG DelayTimeMsec;
    ULONG DelayTimeTicks;
    ULONG LastCount;
    COORD cp;
    BOOLEAN Active;

    CHAR OutputBuffer[1024];
    UCHAR LastKey;
    LONG ScrollDelta;
    WORD DisplayLine, LastDetailRow;
    BOOLEAN DoQuit = FALSE;

    ULONG SkipLine;
    ULONG Hint;
    ULONG Offset1;
    SIZE_T SumCommit;
    int num;
    int lastnum;
    INPUT_RECORD InputRecord;
    DWORD NumRead;
    ULONG Cpu;
    ULONG NoScreenChanges = FALSE;


    if (argc != 2)
    {
        printf("No input file specified!\n");
        exit(0);
    }

    SsdpStartup();

    pInputFile = fopen(argv[1], "r");

    while (!fDone)
    {
        if (pInputFile)
        {
            // If there was an error reading the file
            //
            if (!fgets(szBuf, sizeof(szBuf), pInputFile))
            {
                // If it wasn't eof, print an error
                //
                if (!feof(pInputFile))
                {
                    _tprintf(TEXT("\nFailure reading script file\n\n"));
                }
                else
                {
                    _tprintf(TEXT("\n[Script complete]\n\n"));
                }

                fclose(pInputFile);
                fDone = TRUE;
            }
            else
            {
                CHAR    *pch;

                // Strip trailing linefeeds
                pch = strtok(szBuf, "\r\n");

                lstrcpy(g_rgData[iData].szEvtSrc, szBuf);
                g_rgData[iData].dwLastDiff = 0xFFFFFFFF;
                iData++;
            }
        }
    }

    cData = iData;

    InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    OriginalOutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    Interactive = TRUE;
    if (Interactive)
    {
        if (InputHandle == NULL ||
            OriginalOutputHandle == NULL ||
            !GetConsoleMode( InputHandle, &OriginalInputMode )
           )
        {
            Interactive = FALSE;
        }
        else
        {
            OutputHandle = CreateConsoleScreenBuffer( GENERIC_READ | GENERIC_WRITE,
                                                      FILE_SHARE_WRITE | FILE_SHARE_READ,
                                                      NULL,
                                                      CONSOLE_TEXTMODE_BUFFER,
                                                      NULL
                                                    );
            if (OutputHandle == NULL ||
                !GetConsoleScreenBufferInfo( OriginalOutputHandle, &OriginalConsoleInfo ) ||
                !SetConsoleScreenBufferSize( OutputHandle, OriginalConsoleInfo.dwSize ) ||
                !SetConsoleActiveScreenBuffer( OutputHandle ) ||
                !SetConsoleMode( InputHandle, 0 )
               )
            {
                if (OutputHandle != NULL)
                {
                    CloseHandle( OutputHandle );
                    OutputHandle = NULL;
                }

                Interactive = FALSE;
            }
            else
            {
                NumberOfCols = OriginalConsoleInfo.dwSize.X;
                NumberOfRows = OriginalConsoleInfo.dwSize.Y;
                NumberOfDetailLines = NumberOfRows - 7;
            }
        }
    }

    DelayTimeMsec = 500;
    DelayTimeTicks = DelayTimeMsec * 10000;

    Active = TRUE;

    sprintf(OutputBuffer,
            "   "
             "%-15s "
             "%-35s "
             "%-6s "
             "%-30s "
             "%-4s "
             "%-32s",
            "EvtSrc",
            "Notif To",
            "Seq",
            "Expires",
            "TO",
            "SID");

    WriteConsoleLine(OutputHandle, 0, OutputBuffer, FALSE);

    while (TRUE)
    {
        for (DisplayLine = 1, iData = 0; iData < cData; iData++)
        {
            if (GetEventSourceInfo(g_rgData[iData].szEvtSrc, &pinfo))
            {
                DWORD   iSub;

                for (iSub = 0;
                     iSub < pinfo->cSubs ? pinfo->cSubs : 0;
                     iSub++)
                {
                    SYSTEMTIME  st;
                    FILETIME    ftCur;
                    TCHAR       szLocalDate[255];
                    TCHAR       szLocalTime[255];
                    CHAR        szExp[255];
                    DWORD       csecDiff;

                    FileTimeToSystemTime(&pinfo->rgSubs[iSub].ftTimeout, &st);
                    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL,
                                  szLocalDate, 255);
                    GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL,
                                 szLocalTime, 255);

                    GetSystemTimeAsFileTime(&ftCur);
                    FileTimeToLocalFileTime(&ftCur, &ftCur);

                    csecDiff = CsecDiffFileTime(&ftCur,
                                             &pinfo->rgSubs[iSub].ftTimeout);

                    if (csecDiff < g_rgData[iData].dwLastDiff)
                    {
                        g_rgData[iData].dwLastDiff = csecDiff;
                    }

                    if (g_rgData[iData].dwLastDiff < 10)
                    {
                        MessageBeep(MB_OK);
                    }

                    sprintf(szExp, "%s %s (%d) (%d)",
                            szLocalDate, szLocalTime,
                            csecDiff, g_rgData[iData].dwLastDiff);

                    sprintf(OutputBuffer,
                             "%ld) "
                             "%-15s "
                             "%-35s "
                             "%-6ld "
                             "%-30s "
                             "%-4ld "
                             "%-32s",
                             DisplayLine,
                             g_rgData[iData].szEvtSrc,
                             pinfo->rgSubs[iSub].szDestUrl,
                             pinfo->rgSubs[iSub].iSeq,
                             szExp,
                             pinfo->rgSubs[iSub].csecTimeout,
                             pinfo->rgSubs[iSub].szSid);

                    free(pinfo->rgSubs[iSub].szDestUrl);
                    free(pinfo->rgSubs[iSub].szSid);
                }

                // Just free the rest of them
                for (iSub = 1; iSub < pinfo->cSubs; iSub++)
                {
                    free(pinfo->rgSubs[iSub].szDestUrl);
                    free(pinfo->rgSubs[iSub].szSid);
                }

                free(pinfo->rgSubs);
                ZeroMemory(pinfo, sizeof(EVTSRC_INFO));

                WriteConsoleLine(OutputHandle, DisplayLine++, OutputBuffer, FALSE);
            }
        }

        while (WaitForSingleObject( InputHandle, DelayTimeMsec ) == STATUS_WAIT_0)
        {

            //
            // Check for input record
            //

            if (ReadConsoleInput( InputHandle, &InputRecord, 1, &NumberOfInputRecords ) &&
                InputRecord.EventType == KEY_EVENT &&
                InputRecord.Event.KeyEvent.bKeyDown
               )
            {
                LastKey = InputRecord.Event.KeyEvent.uChar.AsciiChar;
                if (LastKey < ' ')
                {
                    ScrollDelta = 0;
                    if (LastKey == 'C'-'A'+1)
                    {
                        DoQuit = TRUE;
                    }
                    else switch (InputRecord.Event.KeyEvent.wVirtualKeyCode)
                    {
                        case VK_ESCAPE:
                            DoQuit = TRUE;
                            break;
                    }
                }
                break;
            }
        }
        if (DoQuit)
        {
            if (Interactive)
            {
                SetConsoleActiveScreenBuffer( OriginalOutputHandle );
                SetConsoleMode( InputHandle, OriginalInputMode );
                CloseHandle( OutputHandle );
            }
            break;
        }
    }

    SsdpCleanup();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\inc\updiag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P D I A G . H
//
//  Contents:   Interface between ISAPI control DLL and UPDIAG
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#ifndef _UPDIAG_H
#define _UPDIAG_H

static const DWORD MAX_PROP_CHANGES     = 32;   // maximum # of properties that can change
static const TCHAR c_szSharedData[]     = TEXT("UPNP_SHARED_DATA");
static const TCHAR c_szSharedEvent[]    = TEXT("UPNP_SHARED_DATA_EVENT");
static const TCHAR c_szSharedEventRet[] = TEXT("UPNP_SHARED_DATA_EVENT_RETURN");
static const TCHAR c_szSharedMutex[]    = TEXT("UPNP_SHARED_DATA_MUTEX");

struct ARG
{
    TCHAR       szValue[256];
};

struct SHARED_DATA
{
    DWORD       dwReturn;
    CHAR        szEventSource[256];
    CHAR        szAction[256];
    DWORD       cArgs;
    ARG         rgArgs[MAX_PROP_CHANGES];

    DWORD       dwSeqNumber;
    CHAR        szSID[256];
};

#endif // _UPDIAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\isapictl\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP ISAPI Control Extension"
#define VER_INTERNALNAME_STR            "isapictl.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\isapictl\isapictl.cpp ===
#include <pch.h>
#pragma hdrstop

#include <httpext.h>
#include <httpfilt.h>
#include <wininet.h>
#include <msxml.h>
#include <oleauto.h>
#include "ssdpapi.h"
#include "ncbase.h"
#include "updiag.h"
#include "ncxml.h"

BOOL            g_fInited = FALSE;
HANDLE          g_hMapFile = NULL;
SHARED_DATA *   g_pdata = NULL;
HANDLE          g_hEvent = NULL;
HANDLE          g_hEventRet = NULL;
HANDLE          g_hMutex = NULL;
BOOL            g_fTurnOff = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpv)
{
    return TRUE;
}

BOOL FInit()
{
    SECURITY_ATTRIBUTES sa = {0};
    SECURITY_DESCRIPTOR sd = {0};

    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    InitializeDebugging();

    TraceTag(ttidIsapiCtl, "Initializing...");

    g_hEvent = CreateEvent(&sa, FALSE, FALSE, c_szSharedEvent);
    if (g_hEvent)
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
             TraceTag(ttidIsapiCtl, "Event wasn't already created!");
             goto cleanup;
        }
        else
        {
            TraceTag(ttidIsapiCtl, "Created event...");
        }
    }
    else
    {
        TraceTag(ttidIsapiCtl, "Could not create event! Error = %d.",
                 GetLastError());
        goto cleanup;
    }

    g_hEventRet = CreateEvent(&sa, FALSE, FALSE, c_szSharedEventRet);
    if (g_hEventRet)
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
             TraceTag(ttidIsapiCtl, "Return event wasn't already created!");
             goto cleanup;
        }
        else
        {
            TraceTag(ttidIsapiCtl, "Created return event...");
        }
    }
    else
    {
        TraceTag(ttidIsapiCtl, "Could not create return event! Error = %d.",
                 GetLastError());
        goto cleanup;
    }

    g_hMutex = CreateMutex(&sa, FALSE, c_szSharedMutex);
    if (g_hMutex)
    {
        if (GetLastError() != ERROR_ALREADY_EXISTS)
        {
             TraceTag(ttidIsapiCtl, "Mutex wasn't already created!");
             goto cleanup;
        }
        else
        {
            TraceTag(ttidIsapiCtl, "Created mutex...");
        }
    }
    else
    {
        TraceTag(ttidIsapiCtl, "Could not create event! Error = %d.",
                 GetLastError());
        goto cleanup;
    }

    g_hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, c_szSharedData);
    if (g_hMapFile)
    {
        TraceTag(ttidIsapiCtl, "Opened file mapping...");
        g_pdata = (SHARED_DATA *)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS,
                                              0, 0, 0);
        if (g_pdata)
        {
            TraceTag(ttidIsapiCtl, "Shared data successful at 0x%08X.", g_pdata);
            TraceTag(ttidIsapiCtl, "ISAPICTL is initialized.");
            g_fInited = TRUE;
            return TRUE;
        }
        else
        {
            TraceTag(ttidIsapiCtl, "Failed to map file. Error %d.", GetLastError());
            goto cleanup;
        }
    }
    else
    {
        TraceTag(ttidIsapiCtl, "Failed to open file mapping. Error %d.", GetLastError());
        goto cleanup;
    }

cleanup:

    if (g_pdata)
    {
        UnmapViewOfFile((LPVOID)g_pdata);
    }

    if (g_hMapFile)
    {
        CloseHandle(g_hMapFile);
    }

    if (g_hEvent)
    {
        CloseHandle(g_hEvent);
    }

    if (g_hEventRet)
    {
        CloseHandle(g_hEvent);
    }

    if (g_hMutex)
    {
        CloseHandle(g_hMutex);
    }

    return FALSE;
}

BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO * pver)
{
    if (!g_fInited && !g_fTurnOff)
    {
        if (!FInit())
        {
            TraceTag(ttidIsapiCtl, "Failed to initialize. Aborting!");
            SsdpCleanup();
            g_fTurnOff = TRUE;
            TraceTag(ttidIsapiCtl, "Turning off.");
            //return FALSE;
        }
    }

    pver->dwExtensionVersion = MAKELONG(1, 0);
    lstrcpyA(pver->lpszExtensionDesc, "UPnP ISAPI Control Extension");

    TraceTag(ttidIsapiCtl, "ISAPICTL: Extension version: %s.",
             pver->lpszExtensionDesc);

    return TRUE;
}



HRESULT
HrParseHeader(
    IXMLDOMNode * pxdnHeader)
{
    HRESULT hr = S_OK;
    IXMLDOMNode * pxdnChild = NULL;

    hr = pxdnHeader->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode * pxdnNextSibling = NULL;
        BSTR        bstrBaseName = NULL;

        hr = pxdnChild->get_baseName(&bstrBaseName);

        if (SUCCEEDED(hr) && bstrBaseName)
        {
            if (wcscmp(bstrBaseName, L"sequenceNumber") == 0)
            {
                TraceTag(ttidIsapiCtl,
                         "HrParseHeader(): "
                         "Parsing sequence number node");

                BSTR    bstrSeqNumberText = NULL;

                hr = pxdnChild->get_text(&bstrSeqNumberText);

                if (SUCCEEDED(hr) && bstrSeqNumberText)
                {
                    LONG    lSeqNumber = _wtol(bstrSeqNumberText);

                    g_pdata->dwSeqNumber = (DWORD) lSeqNumber;

                    TraceTag(ttidIsapiCtl,
                             "HrParseHeader(): "
                             "Sequence number is %d\n",
                             g_pdata->dwSeqNumber);

                    SysFreeString(bstrSeqNumberText);
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }
                    TraceTag(ttidIsapiCtl,
                             "HrParseHeader(): "
                             "Failed to get sequence number text");
                }
            }
            else if (wcscmp(bstrBaseName, L"SID") == 0)
            {
                TraceTag(ttidIsapiCtl,
                         "HrParseHeader(): "
                         "Parsing SID node");

                BSTR    bstrSIDText = NULL;

                hr = pxdnChild->get_text(&bstrSIDText);

                if (SUCCEEDED(hr) && bstrSIDText)
                {
                    DWORD   cch;

                    cch = SysStringLen(bstrSIDText)+1;
                    WideCharToMultiByte(CP_ACP, 0, bstrSIDText,
                                        cch,
                                        (LPSTR)g_pdata->szSID,
                                        cch, NULL, NULL);

                    TraceTag(ttidIsapiCtl,
                             "HrParseHeader(): "
                             "SID is %s\n",
                             g_pdata->szSID);

                    SysFreeString(bstrSIDText);
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }
                    TraceTag(ttidIsapiCtl,
                             "HrParseHeader(): "
                             "Failed to get SID text");
                }
            }
            else
            {
                // Found an unknown node. This SOAP request is not valid.

                TraceTag(ttidIsapiCtl,
                         "HrParseHeader(): "
                         "Found unknown node \"%S\"",
                         bstrBaseName);

                hr = E_FAIL;
            }

            SysFreeString(bstrBaseName);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrParseHeader(): "
                       "Failed to get node base name",
                       hr);
        }

        if (SUCCEEDED(hr))
        {
            hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
            pxdnChild->Release();
            pxdnChild = pxdnNextSibling;
        }
        else
        {
            pxdnChild->Release();
            pxdnChild = NULL;
        }

    };

    if (SUCCEEDED(hr))
    {
        // Last success return code out of the loop would have
        // been S_FALSE.

        hr = S_OK;
    }

    TraceError("HrParseHeader(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT
HrParseBody(
    IXMLDOMNode * pxdnBody)
{
    HRESULT hr = S_OK;

    // Find the action node. This is the first child of the <Body> node.

    IXMLDOMNode * pxdnAction = NULL;

    hr = pxdnBody->get_firstChild(&pxdnAction);

    if (SUCCEEDED(hr) && pxdnAction)
    {
        BSTR    bstrActionName = NULL;

        hr = pxdnAction->get_baseName(&bstrActionName);

        if (SUCCEEDED(hr) && bstrActionName)
        {
            // Copy the action name into the shared data.

            DWORD   cch;

            cch = SysStringLen(bstrActionName) + 1;
            WideCharToMultiByte(CP_ACP, 0, bstrActionName,
                                cch,
                                (LPSTR)g_pdata->szAction,
                                cch, NULL, NULL);

            // Copy each of the action arguments into the shared data.

            IXMLDOMNode * pxdnArgument = NULL;

            hr = pxdnAction->get_firstChild(&pxdnArgument);

            while (SUCCEEDED(hr) && pxdnArgument)
            {
                BSTR    bstrArgText = NULL;

                hr = pxdnArgument->get_text(&bstrArgText);

                if (SUCCEEDED(hr) && bstrArgText)
                {
                    DWORD   cch;

                    cch = SysStringLen(bstrArgText) + 1;

                    WideCharToMultiByte(CP_ACP, 0, bstrArgText,
                                        cch,
                                        (LPSTR)g_pdata->rgArgs[g_pdata->cArgs].szValue,
                                        cch, NULL, NULL);

                    g_pdata->cArgs++;

                    SysFreeString(bstrArgText);
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }
                    TraceError("HrParseBody(): "
                               "Failed to get argument text",
                               hr);
                }

                if (SUCCEEDED(hr))
                {
                    IXMLDOMNode * pxdnNextArgument = NULL;

                    hr = pxdnArgument->get_nextSibling(&pxdnNextArgument);
                    pxdnArgument->Release();
                    pxdnArgument = pxdnNextArgument;
                }
                else
                {
                    pxdnArgument->Release();
                    pxdnArgument = NULL;
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }

            SysFreeString(bstrActionName);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrParseBody(): "
                       "Failed to get action name",
                       hr);
        }

        pxdnAction->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("HrParseBody(): "
                   "Failed to get action node",
                   hr);
    }



    TraceError("HrParseBody(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT
HrParseAction(
    IXMLDOMNode * pxdnSOAPEnvelope)
{
    HRESULT     hr = S_OK;
    IXMLDOMNode * pxdnChild = NULL;

    hr = pxdnSOAPEnvelope->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode * pxdnNextSibling = NULL;
        BSTR    bstrBaseName = NULL;

        hr = pxdnChild->get_baseName(&bstrBaseName);

        if (SUCCEEDED(hr) && bstrBaseName)
        {
            if (wcscmp(bstrBaseName, L"Header") == 0)
            {
                TraceTag(ttidIsapiCtl,
                         "HrParseAction(): "
                         "Parsing Header node");

                hr = HrParseHeader(pxdnChild);

            }
            else if (wcscmp(bstrBaseName, L"Body") == 0)
            {
                TraceTag(ttidIsapiCtl,
                         "HrParseAction(): "
                         "Parsing Body node");

                hr = HrParseBody(pxdnChild);

            }
            else
            {
                // Found an unknown node. This SOAP request is not valid.
                TraceTag(ttidIsapiCtl,
                         "HrParseAction(): "
                         "Found unknown node \"%S\"",
                         bstrBaseName);

                hr = E_FAIL;
            }

            SysFreeString(bstrBaseName);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrParseAction(): "
                       "Failed to get node base name",
                       hr);
        }

        if (SUCCEEDED(hr))
        {
            hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
            pxdnChild->Release();
            pxdnChild = pxdnNextSibling;
        }
        else
        {
            pxdnChild->Release();
            pxdnChild = NULL;
        }

    };

    if (SUCCEEDED(hr))
    {
        // Last success return code out of the loop would have
        // been S_FALSE.

        hr = S_OK;
    }

    TraceError("HrParseAction(): "
               "Exiting",
               hr);

    return hr;
}


HRESULT HrLoadArgsFromXml(LPCWSTR szXml)
{
    VARIANT_BOOL        vbSuccess;
    HRESULT             hr = S_OK;
    IXMLDOMDocument *   pxmlDoc;
    IXMLDOMNodeList *   pNodeList = NULL;
    IXMLDOMNode *       pNode = NULL;
    IXMLDOMNode *       pNext = NULL;

    hr = CoCreateInstance(CLSID_DOMDocument30, NULL, CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument, (LPVOID *)&pxmlDoc);
    if (SUCCEEDED(hr))
    {
        hr = pxmlDoc->put_async(VARIANT_FALSE);
        if (SUCCEEDED(hr))
        {
            hr = pxmlDoc->loadXML((BSTR)szXml, &vbSuccess);
            if (SUCCEEDED(hr))
            {
                IXMLDOMElement *    pxde;

                hr = pxmlDoc->get_documentElement(&pxde);
                if (S_OK == hr)
                {
                    hr = HrParseAction(pxde);


                    ReleaseObj(pxde);
                }
            }
        }

        ReleaseObj(pxmlDoc);
    }

    TraceError("HrLoadArgsFromXml", hr);
    return hr;
}

DWORD DwProcessXoapRequest(LPSTR szUri, DWORD cbData, LPBYTE pbData)
{
    LPSTR           szData = (LPSTR)pbData;
    UPNP_PROPERTY * rgProps;
    DWORD           cProps;
    DWORD           dwReturn = 0;
    HRESULT         hr;

    //  Must acquire shared-memory mutex first
    //
    if (WAIT_OBJECT_0 == WaitForSingleObject(g_hMutex, INFINITE))
    {
        TraceTag(ttidIsapiCtl, "Acquired mutex...");

        ZeroMemory(g_pdata, sizeof(SHARED_DATA));

        LPSTR   szAnsi;
        LPWSTR  wszXmlBody;

        szAnsi = new CHAR[cbData + 1];
        CopyMemory(szAnsi, pbData, cbData);
        szAnsi[cbData] = 0;
        wszXmlBody = WszFromSz(szAnsi);

        TraceTag(ttidIsapiCtl, "URI = %s: Data = %s.", szUri, szAnsi);

        delete [] szAnsi;

        hr = HrLoadArgsFromXml(wszXmlBody);
        TraceError("DwProcessXoapRequest: HrLoadArgsFromXml", hr);

        // Done with changes to shared memory
        TraceTag(ttidIsapiCtl, "Releasing mutex...");
        ReleaseMutex(g_hMutex);

        if (S_OK == hr)
        {
            // Copy in event source URI
            lstrcpyA(g_pdata->szEventSource, szUri);

            TraceTag(ttidIsapiCtl, "Setting event...");

            // Now tell the device we're ready for it to process
            SetEvent(g_hEvent);

            TraceTag(ttidIsapiCtl, "Waiting for return event...");

            // Immediately wait on event again for return response
            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hEventRet, INFINITE))
            {
                dwReturn = g_pdata->dwReturn;
                TraceTag(ttidIsapiCtl, "Setting return value to %d.", dwReturn);
            }
        }
        else
        {
            // On failure, we don't even need to signal the device. This
            // XOAP request wasn't properly formed or we couldn't process
            // it anyway
            //
            TraceError("DwProcessXoapRequest - failed to load args from XML", hr);
            dwReturn = DwWin32ErrorFromHr(hr);
        }

        // And we're done!
    }

    return dwReturn;
}

HRESULT HrComposeXoapResponse(DWORD dwValue, LPSTR *pszOut)
{
    HRESULT hr = S_OK;
    LPSTR   szOut;
    CHAR    szBuffer[1024];

    Assert(pszOut);


    // $ BUGBUG SPATHER Response should be namespace-qualified.

    wsprintfA(szBuffer,
             "<SOAP:Envelope xmlns:SOAP=\"urn:schemas-xmlsoap-org:soap.v1\">\r\n"
             "    <SOAP:Body>\r\n"
             "        <%sResponse>\r\n"
             "            <return>%d</return>\r\n"
             "        </%sResponse>\r\n"
             "    </SOAP:Body>\r\n"
             "</SOAP:Envelope>",
             g_pdata->szAction,
             dwValue,
             g_pdata->szAction);

    szOut = SzaDupSza(szBuffer);
    if (szOut)
    {
        *pszOut = szOut;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("HrComposeXoapResponse", hr);
    return hr;
}

DWORD WINAPI HttpExtensionProc(LPEXTENSION_CONTROL_BLOCK pecb)
{
    DWORD   hseStatus = HSE_STATUS_SUCCESS;

    if (g_fInited)
    {
        DWORD   dwReturn;
        HRESULT hr;

        if (!lstrcmpiA(pecb->lpszMethod, "M-POST"))
        {
            LPSTR   szResponse;
            DWORD   cbResponse;

            // This was a post request so it's a XOAP control request
            TraceTag(ttidIsapiCtl, "Received 'M-POST' request");

            // The URI of the event source will be the query string
            dwReturn = DwProcessXoapRequest(pecb->lpszQueryString,
                                            pecb->cbAvailable,
                                            pecb->lpbData);

            // Send XOAP response with dwReturn
            TraceTag(ttidIsapiCtl, "Sending XOAP response for %d.", dwReturn);

            hr = HrComposeXoapResponse(dwReturn, &szResponse);
            if (S_OK == hr)
            {
                cbResponse = lstrlenA(szResponse);

                TraceTag(ttidIsapiCtl, "Writing XOAP response: %s.", szResponse);

                pecb->WriteClient(pecb->ConnID, (LPVOID)szResponse,
                                  &cbResponse, 0);

                free(szResponse);
            }
        }
        else if (!lstrcmpiA(pecb->lpszMethod, "POST"))
        {

            HSE_SEND_HEADER_EX_INFO hse;
            LPSTR                   szResponse = "";
            DWORD                   cbResponse;
            LPSTR                   szStatus = "405 Method Not Allowed";
            DWORD                   cbStatus;


            TraceTag(ttidIsapiCtl, "Received 'POST' request");
            TraceTag(ttidIsapiCtl, "Data = %s.", pecb->lpbData);

            ZeroMemory(&hse, sizeof(HSE_SEND_HEADER_EX_INFO));
            cbResponse = lstrlenA(szResponse);
            cbStatus = lstrlenA(szStatus);
            hse.pszStatus = szStatus;// here you should print "405 Method Not Allowed"
            hse.pszHeader = szResponse; // this one should be empty for http errors
            hse.cchStatus = cbStatus;
            hse.cchHeader = cbResponse;
            hse.fKeepConn = FALSE;

            pecb->dwHttpStatusCode = HTTP_STATUS_BAD_METHOD;

            pecb->ServerSupportFunction(pecb->ConnID,
                                        HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                        (LPVOID)&hse,
                                        NULL,
                                        NULL);
        }
        else
        {
            TraceTag(ttidIsapiCtl, "Data = %s.", pecb->lpbData);

            pecb->dwHttpStatusCode = HTTP_STATUS_BAD_METHOD;
            TraceTag(ttidIsapiCtl, "ISAPICTL: Received bad method '%s' request.",
                     pecb->lpszMethod);

            hseStatus = HSE_STATUS_ERROR;
        }
    }
    else
    {
        TraceTag(ttidIsapiCtl, "Not initialized!");
    }

    return hseStatus;
}


BOOL WINAPI TerminateExtension(DWORD dwFlags)
{
    TraceTag(ttidIsapiCtl, "TerminateExtension: Exiting...");

    if (g_pdata)
    {
        UnmapViewOfFile((LPVOID)g_pdata);
    }

    if (g_hMapFile)
    {
        CloseHandle(g_hMapFile);
    }

    if (g_hEvent)
    {
        CloseHandle(g_hEvent);
    }

    if (g_hEventRet)
    {
        CloseHandle(g_hEvent);
    }

    if (g_hMutex)
    {
        CloseHandle(g_hMutex);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\inc\util.h ===
// 
// util.h
//
// utility functions used by updiag
// 

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
// 
//  File:       U T I L . H
//
//  Contents:   Common data structure and function used by mulriple tools
//
//  Notes:
//
//  Author:     tongl   25 Jan 2000
//
//----------------------------------------------------------------------------

#ifndef _UTIL_H
#define _UTIL_H

#include <setupapi.h>
#include <wininet.h>
#include <updiag.h>

static const DWORD MAX_SST_ROWS         = 32;
static const MAX_ACTION_ARGUMENTS       = 8;
static const MAX_ACTIONS                = 32;
static const DWORD MAX_OPERATIONS       = 10;
static const DWORD MAX_STD_OPERATIONS   = 20;

// service state table
//
struct SST_ROW
{
    TCHAR       szPropName[256];
    VARIANT     varValue;
    TCHAR       mszAllowedValueList[256];
    TCHAR       szMin[256];
    TCHAR       szMax[256];
    TCHAR       szStep[256];
};

struct SST
{
    SST_ROW     rgRows[MAX_SST_ROWS];
    DWORD       cRows;
};

// service action set
//
struct OPERATION_DATA
{
    // Assumptions:
    // 1) one operation affects one and only one state variable
    // 2) operations in the same action do NOT share the same argument
    //    (if they do the argument has to be passed in twice)
    // 3) the order of input arguments to an action must be in the same
    //    order as the operations and arguments for each operation
    // 4) the number of arguments each operation takes is uniquely
    //    determined by the name of the operation
    TCHAR   szOpName[256];

    // The state variable this operation affects
    TCHAR   szVariableName[256];

    // The list of constants and their values this operation takes
    TCHAR   mszConstantList[256];
};

struct ACTION
{
    TCHAR               szActionName[256];
    OPERATION_DATA      rgOperations[MAX_OPERATIONS];
    DWORD               cOperations;
};

struct ACTION_SET
{
    ACTION          rgActions[MAX_ACTIONS];
    DWORD           cActions;
};

// Control structures for demo services
//
typedef DWORD (WINAPI * PFNACTION)(DWORD cArgs, ARG *rgArgs);
struct DEMO_ACTION
{
    LPCTSTR     szAction;
    PFNACTION   pfnValidate;
    PFNACTION   pfnAction;
};

struct DEMO_SERVICE_CTL
{
    LPCTSTR         szServiceId;
    DWORD           cActions;
    DEMO_ACTION     rgActions[MAX_ACTIONS];
};


struct UPNPSVC
{
    TCHAR                   szSti[256];
    TCHAR                   szId[256];
    TCHAR                   szServiceType[256];
    TCHAR                   szControlUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR                   szEvtUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR                   szScpdUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR                   szConfigFile[MAX_PATH];
    SST                     sst;
    ACTION_SET              action_set;
    TCHAR                   szControlId[256];
    HANDLE                  hSvc;
    const DEMO_SERVICE_CTL* psvcDemoCtl;
};

// Standard state table operation list
//
typedef DWORD (WINAPI * PFNOPERATION)(UPNPSVC * psvc, OPERATION_DATA * pOpData,
                                      DWORD cArgs, ARG *rgArgs);
struct STANDARD_OPERATION
{
    LPCTSTR         szOperation;
    DWORD           nArguments;
    DWORD           nConstants;
    PFNOPERATION    pfnOperation;
};

struct STANDARD_OPERATION_LIST
{
    DWORD                   cOperations;
    STANDARD_OPERATION      rgOperations[MAX_STD_OPERATIONS];
};

VOID WcharToTcharInPlace(LPTSTR szT, LPWSTR szW);

inline BOOL
IsValidHandle(HANDLE h)
{
    return (h && INVALID_HANDLE_VALUE != h);
}

HRESULT HrSetupOpenConfigFile(  PCTSTR pszFileName,
                                UINT* punErrorLine,
                                HINF* phinf);

HRESULT HrSetupFindFirstLine( HINF hinf,
                              PCTSTR pszSection,
                              PCTSTR pszKey,
                              INFCONTEXT* pctx);

HRESULT HrSetupFindNextLine( const INFCONTEXT& ctxIn,
                             INFCONTEXT* pctxOut);

HRESULT HrSetupGetStringField( const INFCONTEXT& ctx,
                               DWORD dwFieldIndex,
                               PTSTR  pszBuf, 
                               DWORD cchBuf,
                               DWORD* pcchRequired);

HRESULT HrSetupGetLineText( const  INFCONTEXT& ctx,
                            PTSTR  pszBuf,  
                            DWORD  ReturnBufferSize,
                            DWORD* pcchRequired);


VOID SetupCloseInfFileSafe(HINF hinf);

BOOL fGetNextField(TCHAR ** pszLine, TCHAR * szBuffer);

BOOL IsStandardOperation(TCHAR * szOpName, DWORD * pnArgs, DWORD * pnConsts);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\scpdgen\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "SCPD generating tool"
#define VER_INTERNALNAME_STR            "scpdgen.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\scpdgen\scpdgen.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S C P D G E N . C P P
//
//  Contents:   Functions that generates scpd for upnp service
//
//  Notes:
//
//  Author:     tongl   7 December 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "stdio.h"
#include "ncstring.h"
#include "oleauto.h"
#include "setupapi.h"
#include "util.h"

struct ARG_DATA
{
    // argument to an action
    TCHAR   szArg[256];

    // related state variable
    TCHAR   szVariable[256];
};

struct ARG_LIST
{
    DWORD         cArgs;
    ARG_DATA      rgArguments[MAX_ACTION_ARGUMENTS];
};

HRESULT HrCreateScpdNode(IN  IXMLDOMDocument * pScpdDoc,
                         OUT IXMLDOMElement ** ppScpdNode);

HRESULT HrCreateStateVariableNode(IN  LPTSTR    szVariableLine,
                                  IN  IXMLDOMDocument * pScpdDoc,
                                  OUT IXMLDOMElement ** ppVariableNode);

HRESULT HrCreateServiceStateTableNode(IN   HINF hinf,
                                      IN   IXMLDOMDocument * pScpdDoc,
                                      OUT  IXMLDOMElement ** ppSSTNode);

HRESULT HrCreateActionNode(IN   HINF hinf,
                           IN   LPTSTR    szActionLine,
                           IN   IXMLDOMDocument * pScpdDoc,
                           OUT  IXMLDOMElement ** ppActionNode);

HRESULT HrCreateActionListNode(IN  HINF hinf,
                               IN  IXMLDOMDocument * pScpdDoc,
                               OUT IXMLDOMElement ** ppActionListNode);

BOOL IsStandardOperation(TCHAR * szOpName, DWORD * pnArgs, DWORD * pnConsts);

//
// Create scpd doc for service from the config file and save to
// specified destination
//

EXTERN_C
VOID
__cdecl
wmain (
    IN INT     argc,
    IN PCWSTR argv[])
{
    HRESULT hr = S_OK;

    if (argc != 3)
    {
        _tprintf(TEXT("\nUsage: \n    %s\n\n"),
                 TEXT("<Service INF file>, <SCPD xml file name and path>"));

        return;
    };

    TCHAR    szSvcConfigFile[MAX_PATH];
    WszToTszBuf(szSvcConfigFile, argv[1], MAX_PATH);

    LPCWSTR pszScpdFileWithPath = argv[2];

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        TraceError("CoInitializeEx", hr);
        return;
    }

    IXMLDOMDocument *pScpdDoc = NULL;

    // Create a new document object
    hr = CoCreateInstance(CLSID_DOMDocument30,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument,
                          (void **) &pScpdDoc);
    if (SUCCEEDED(hr))
    {
        hr = pScpdDoc->put_preserveWhiteSpace(VARIANT_TRUE);
        if (S_OK == hr)
        {
            // Build <?xml version="1.0"?>
            IXMLDOMProcessingInstruction * piVersion = NULL;

            BSTR bstrTarget = SysAllocString(L"xml");
            if (bstrTarget)
            {
                BSTR bstrData = SysAllocString(L"version=\"1.0\"");
                if (bstrData)
                {
                    hr = pScpdDoc->createProcessingInstruction(
                                   bstrTarget, bstrData, &piVersion);

                    if (SUCCEEDED(hr))
                    {
                        // Append the <version> element to the document.
                        hr = pScpdDoc->appendChild(piVersion, NULL);
                        piVersion->Release();

                        if (FAILED(hr))
                        {
                            TraceError("Failed to append <version> to document.", hr);
                        }

                        SysFreeString(bstrTarget);
                        SysFreeString(bstrData);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            // Build <scpd> element
            VARIANT vNULL;
            vNULL.vt = VT_EMPTY;

            IXMLDOMElement  * pScpdNode = NULL;
            hr = HrCreateScpdNode(pScpdDoc, &pScpdNode);
            if (SUCCEEDED(hr))
            {
                // open the config file
                HINF hinf = NULL;
                UINT unErrorLine;

                hr = HrSetupOpenConfigFile(szSvcConfigFile, &unErrorLine, &hinf);
                if (S_OK == hr)
                {
                    Assert(IsValidHandle(hinf));

                    // Build <serviceStateTable> element
                    IXMLDOMElement  * pSSTNode = NULL;
                    hr = HrCreateServiceStateTableNode(hinf, pScpdDoc, &pSSTNode);
                    if (SUCCEEDED(hr))
                    {
                        Assert(pSSTNode);
                        hr = pScpdNode->insertBefore(pSSTNode,
                                                     vNULL,
                                                     NULL);

                        pSSTNode->Release();

                        if (FAILED(hr))
                        {
                            TraceError("Failed to insert <serviceStateTable> element", hr);
                        }
                        else
                        {
                            // Build <actionList> element
                            IXMLDOMElement  * pActionListNode = NULL;
                            hr = HrCreateActionListNode(hinf, pScpdDoc, &pActionListNode);
                            if (SUCCEEDED(hr))
                            {
                                Assert(pActionListNode);
                                hr = pScpdNode->insertBefore(pActionListNode,
                                                             vNULL,
                                                             NULL);
                                pActionListNode->Release();

                                if (FAILED(hr))
                                {
                                    TraceError("Failed to insert <actionList> element", hr);
                                }
                            }
                        }
                    }

                    SetupCloseInfFileSafe(hinf);
                }
                else
                {
                    TraceTag(ttidUpdiag, "Failed to open file %s, line = %d",
                             szSvcConfigFile, unErrorLine);
                }

                // Append the <scpd> element to the document.
                if (SUCCEEDED(hr))
                {
                    hr = pScpdDoc->appendChild(pScpdNode, NULL);
                    pScpdNode->Release();
                    if (FAILED(hr))
                    {
                        TraceError("Failed to append <scpd> element to document.", hr);
                    }
                }
            }
            else
            {
                TraceError("Failed to create <scpd> element", hr);
            }

            if (SUCCEEDED(hr))
            {
                // Persist the xml document
                VARIANT vFileName;
                vFileName.vt = VT_BSTR;

                V_BSTR(&vFileName) = SysAllocString(pszScpdFileWithPath);

                hr = pScpdDoc->save(vFileName);
                VariantClear(&vFileName);
            }

            pScpdDoc->Release();
        }
    }
    else
    {
        TraceError("Failed to create XML DOM Document object", hr);
    }

    CoUninitialize();
}

//
// Create the <scpd> note that will include a serviceStateTable and
// an actionList
//
HRESULT HrCreateScpdNode(IN  IXMLDOMDocument * pScpdDoc,
                         OUT IXMLDOMElement ** ppScpdNode)
{
    HRESULT hr = S_OK;

    Assert(ppScpdNode);
    *ppScpdNode = NULL;

    IXMLDOMElement  * pScpdNode = NULL;
    BSTR    bstrElementName = SysAllocString(L"scpd");

    if (bstrElementName)
    {
        hr = pScpdDoc->createElement(bstrElementName, &pScpdNode);
        if (SUCCEEDED(hr))
        {
            // set the xmlns attribute
            BSTR bstrAttrName = SysAllocString(L"xmlns");
            if (bstrAttrName)
            {
                VARIANT vValue;
                vValue.vt = VT_BSTR;
                V_BSTR(&vValue) = SysAllocString(L"x-schema:scpdl-schema.xml");

                hr = pScpdNode->setAttribute(bstrAttrName, vValue);

                SysFreeString(bstrAttrName);
                VariantClear(&vValue);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                *ppScpdNode = pScpdNode;
                pScpdNode->AddRef();
            }
            else
            {
                TraceError("HrCreateScpdNode: Failed to set xmlns attribute", hr);
            }
            pScpdNode->Release();
        }
        else
        {
            TraceError("HrCreateScpdNode: Failed to create <scpd> element", hr);
        }
        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCreateScpdNode: Failed to allocate BSTR for element name", hr);
    }

    TraceError("HrCreateScpdNode", hr);
    return hr;
}

HRESULT HrCreateServiceStateTableNode(IN  HINF hinf,
                                      IN  IXMLDOMDocument * pScpdDoc,
                                      OUT IXMLDOMElement ** ppSSTNode)
{
    HRESULT hr = S_OK;

    Assert(ppSSTNode);
    *ppSSTNode = NULL;

    IXMLDOMElement  * pSSTNode = NULL;
    BSTR    bstrElementName = SysAllocString(L"serviceStateTable");

    if (bstrElementName)
    {
        hr = pScpdDoc->createElement(bstrElementName, &pSSTNode);
        if (SUCCEEDED(hr))
        {
            // get the [StateTable] section
            INFCONTEXT ctx;

            hr = HrSetupFindFirstLine(hinf, TEXT("StateTable"), NULL, &ctx);
            if (S_OK == hr)
            {
                // loop through [StateTable] section and create stateVariable's

                TCHAR   szKey[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256
                TCHAR   szVariableLine[LINE_LEN];

                IXMLDOMElement  * pVariableNode = NULL;
                VARIANT vNULL;
                vNULL.vt = VT_EMPTY;

                do
                {
                    // Retrieve a line from the ActionSet section
                    hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                    if(S_OK == hr)
                    {
                        // varify this is a "Variable"
                        szKey[celems(szKey)-1] = L'\0';
                        if (lstrcmpi(szKey, TEXT("Variable")))
                        {
                            TraceTag(ttidUpdiag, "Wrong key in the StateTable section: %s", szKey);
                            continue;
                        }

                        // get the line text
                        hr = HrSetupGetLineText(ctx, szVariableLine, celems(szVariableLine),
                                                NULL);
                        if (S_OK == hr)
                        {
                            // Add variable in this line
                            hr = HrCreateStateVariableNode(szVariableLine, pScpdDoc, &pVariableNode);
                            if (SUCCEEDED(hr))
                            {
                                Assert(pVariableNode);
                                hr = pSSTNode->insertBefore(pVariableNode,
                                                            vNULL,
                                                            NULL);
                                pVariableNode->Release();
                            }
                        }
                    }
                }
                while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));


                if (hr == S_FALSE)
                {
                    // S_FALSE will terminate the loop successfully, so convert it to S_OK
                    // here.
                    hr = S_OK;
                }

                if (S_OK == hr)
                {
                    *ppSSTNode = pSSTNode;
                    pSSTNode->AddRef();
                }
            }
            else
            {
                TraceError("HrCreateScpdNode: [StateTable] section not found in inf", hr);
            }
        }
        else
        {
            TraceError("HrCreateScpdNode: Failed to create <serviceStateTable> element", hr);
        }
        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCreateServiceStateTableNode: Failed to allocate BSTR for element name", hr);
    }

    TraceError("HrCreateServiceStateTableNode", hr);
    return hr;
}

HRESULT HrAddElementWithText(IXMLDOMDocument * pDoc,
                             IXMLDOMElement  * pParentNode,
                             LPTSTR szElementName,
                             LPTSTR szElementText)
{
    HRESULT hr = S_OK;

    IXMLDOMElement  * pNewNode = NULL;
    VARIANT vNull;
    vNull.vt = VT_EMPTY;

    BSTR    bstrElementName = NULL;
    BSTR    bstrTextValue = NULL;

    WCHAR * wszElementName = WszFromTsz(szElementName);
    WCHAR * wszElementText = WszFromTsz(szElementText);

    if (!wszElementName || !wszElementText)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        bstrElementName = SysAllocString(wszElementName);
        bstrTextValue = SysAllocString(wszElementText);

        if (!bstrElementName || !bstrTextValue)
        {
            hr = E_OUTOFMEMORY;
        }

        delete wszElementName;
        delete wszElementText;
    }

    if (SUCCEEDED(hr))
    {
        hr = pDoc->createElement(bstrElementName, &pNewNode);
        if (SUCCEEDED(hr))
        {
            IXMLDOMText * pText = NULL;

            hr = pDoc->createTextNode(bstrTextValue, &pText);
            if (SUCCEEDED(hr))
            {
                hr = pNewNode->insertBefore(pText, vNull, NULL);
                if (FAILED(hr))
                {
                    TraceError("HrAddElementWithText: Failed to insert text node", hr);
                }
                pText->Release();
            }
            else
            {
                TraceError("HrAddElementWithText: Failed to create text node", hr);
            }

            if (SUCCEEDED(hr))
            {
                hr = pParentNode->insertBefore(pNewNode, vNull, NULL);
                if (FAILED(hr))
                {
                    TraceError("HrAddElementWithText: Failed to insert new node", hr);
                }
            }
            pNewNode->Release();
        }
        else
        {
            TraceError("HrAddElementWithText: Could not create new element", hr);
        }

        SysFreeString(bstrElementName);
        SysFreeString(bstrTextValue);
    }

    TraceError("HrAddElementWithText", hr);
    return hr;
}

BOOL fIsValidDataType(LPTSTR szBuf)
{
    return ((lstrcmpi(szBuf, TEXT("number")) ==0)    ||
            (lstrcmpi(szBuf, TEXT("string")) ==0)    ||
            (lstrcmpi(szBuf, TEXT("dateTime")) ==0)  ||
            (lstrcmpi(szBuf, TEXT("boolean")) ==0)   ||
            (lstrcmpi(szBuf, TEXT("ByteBlock")) ==0));
}

HRESULT HrAddAllowedValueNode( IXMLDOMDocument * pDoc,
                               IXMLDOMElement  * pVariableNode,
                               LPTSTR szBuf)
{
    HRESULT hr = S_OK;

    Assert(*szBuf == '(');
    szBuf++;

    IXMLDOMElement  * pAllowedValueNode = NULL;
    BSTR    bstrElementName;

    // we assume that ".." specifies a range, otherwise it's a comma separated
    // list of allowed values
    TCHAR * pChar = _tcsstr(szBuf, TEXT(".."));
    if (pChar)
    {
        // we have a range
        // BUGBUG: we should check if data type of the min, max & step
        // matches the variable type
        TCHAR * szMin, * szMax, * szStep;

        szMin = szBuf;
        *pChar = '\0';

        szMax = pChar+2;
        pChar = _tcschr(szMax, TEXT(','));
        if (pChar)
        {
            *pChar = '\0';
            szStep = ++pChar;

            pChar = _tcschr(szStep, TEXT(')'));
            if (pChar)
            {
                *pChar = '\0';

                bstrElementName = SysAllocString(L"allowedValueRange");
                if (bstrElementName)
                {
                    hr = pDoc->createElement(bstrElementName, &pAllowedValueNode);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrAddElementWithText(pDoc, pAllowedValueNode, TEXT("minimum"), szMin);
                        if (SUCCEEDED(hr))
                        {
                            hr = HrAddElementWithText(pDoc, pAllowedValueNode, TEXT("maximum"), szMax);
                            if (SUCCEEDED(hr))
                            {
                                hr = HrAddElementWithText(pDoc, pAllowedValueNode, TEXT("step"), szStep);
                            }
                        }
                    }
                    SysFreeString(bstrElementName);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                TraceTag(ttidUpdiag, "HrAddAllowedValueNode: missing closing )");
                hr = E_INVALIDARG;
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "HrAddAllowedValueNode: step not specified");
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // we have a list of allowed values
        pChar = _tcschr(szBuf, TEXT(')'));
        if (pChar)
        {
            *pChar = '\0';
            if (lstrlen(szBuf))
            {
                bstrElementName = SysAllocString(L"allowedValueList");
                if (bstrElementName)
                {
                    hr = pDoc->createElement(bstrElementName, &pAllowedValueNode);
                    if (SUCCEEDED(hr))
                    {
                        while ((S_OK ==hr) && (pChar = _tcschr(szBuf, TEXT(','))))
                        {
                            *pChar = '\0';
                            hr = HrAddElementWithText(pDoc, pAllowedValueNode,
                                                      TEXT("allowedValue"), szBuf);

                            szBuf = ++pChar;
                        }

                        // add the last one
                        if (*szBuf)
                        {
                            hr = HrAddElementWithText(pDoc, pAllowedValueNode,
                                                      TEXT("allowedValue"), szBuf);
                        }
                        else
                        {
                            TraceTag(ttidUpdiag, "HrAddAllowedValueNode: invalid syntax");
                            hr = E_INVALIDARG;
                        }
                    }
                    SysFreeString(bstrElementName);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "HrAddAllowedValueNode: missing closing )");
            hr = E_INVALIDARG;
        }
    }

    if (pAllowedValueNode && (S_OK == hr))
    {
        // append the allowed value node to "stateVariable"
        VARIANT vNull;
        vNull.vt = VT_EMPTY;

        hr = pVariableNode->insertBefore(pAllowedValueNode, vNull, NULL);
    }

    TraceError("HrAddAllowedValueRangeNode" , hr);
    return hr;
}

HRESULT HrCreateStateVariableNode(IN  LPTSTR    szVariableLine,
                                  IN  IXMLDOMDocument * pScpdDoc,
                                  OUT IXMLDOMElement ** ppVariableNode)
{
    HRESULT hr = S_OK;

    Assert(ppVariableNode);
    *ppVariableNode = NULL;

    IXMLDOMElement  * pVariableNode = NULL;
    BSTR    bstrElementName = SysAllocString(L"stateVariable");

    if (bstrElementName)
    {
        hr = pScpdDoc->createElement(bstrElementName, &pVariableNode);
        if (SUCCEEDED(hr))
        {
            TCHAR szBuf[MAX_PATH];
            if (fGetNextField(&szVariableLine, szBuf))
            {
                hr = HrAddElementWithText(pScpdDoc, pVariableNode, TEXT("name"), szBuf);
                if (SUCCEEDED(hr))
                {
                    if (fGetNextField(&szVariableLine, szBuf))
                    {
                        if (fIsValidDataType(szBuf))
                        {
                            hr = HrAddElementWithText(pScpdDoc, pVariableNode,
                                                      TEXT("dataType"), szBuf);

                            // AllowedValueRange is optional
                            if (SUCCEEDED(hr) && fGetNextField(&szVariableLine, szBuf))
                            {
                                hr = HrAddAllowedValueNode(pScpdDoc, pVariableNode, szBuf);
                            }

                            if (SUCCEEDED(hr) && fGetNextField(&szVariableLine, szBuf))
                            {
                                 hr = HrAddElementWithText(pScpdDoc, pVariableNode,
                                                           TEXT("defaultValue"), szBuf);
                            }
                        }
                        else
                        {
                            hr = E_INVALIDARG;
                            TraceError("HrCreateStateVariableNode: invalid data type specified", hr);
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    }
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }

            if (S_OK == hr)
            {
                *ppVariableNode = pVariableNode;
                pVariableNode->AddRef();
            }
        }
        else
        {
            TraceError("HrCreateStateVariableNode: Failed to create <stateVariable> element", hr);
        }
        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCreateStateVariableNode: Failed to allocate BSTR for element name", hr);
    }

    TraceError("HrCreateStateVariableNode", hr);
    return hr;
}

HRESULT HrCreateActionListNode(IN  HINF hinf,
                               IN  IXMLDOMDocument * pScpdDoc,
                               OUT IXMLDOMElement ** ppActionListNode)
{
    HRESULT hr = S_OK;

    Assert(ppActionListNode);
    *ppActionListNode = NULL;

    IXMLDOMElement  * pActionListNode = NULL;
    BSTR    bstrElementName = SysAllocString(L"actionList");

    if (bstrElementName)
    {
        hr = pScpdDoc->createElement(bstrElementName, &pActionListNode);
        if (SUCCEEDED(hr))
        {
            // get the [ActionSet] section
            INFCONTEXT ctx;

            hr = HrSetupFindFirstLine(hinf, TEXT("ActionSet"), NULL, &ctx);
            if (S_OK == hr)
            {
                // loop through [ActionSet] section and create actions

                TCHAR   szKey[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256
                TCHAR   szActionLine[LINE_LEN];

                IXMLDOMElement  * pActionNode = NULL;
                VARIANT vNULL;
                vNULL.vt = VT_EMPTY;

                do
                {
                    // Retrieve a line from the ActionSet section
                    hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                    if(S_OK == hr)
                    {
                        // varify this is a "Action"
                        szKey[celems(szKey)-1] = L'\0';
                        if (lstrcmpi(szKey, TEXT("Action")))
                        {
                            TraceTag(ttidUpdiag, "Wrong key in the ActionSet section: %s", szKey);
                            continue;
                        }

                        // get the line text
                        hr = HrSetupGetLineText(ctx, szActionLine, celems(szActionLine),
                                                NULL);
                        if (S_OK == hr)
                        {
                            // Add action in this line
                            hr = HrCreateActionNode(hinf, szActionLine, pScpdDoc, &pActionNode);
                            if (SUCCEEDED(hr))
                            {
                                Assert(pActionNode);
                                hr = pActionListNode->insertBefore( pActionNode,
                                                                    vNULL,
                                                                    NULL);
                                pActionNode->Release();
                            }
                        }
                    }
                }
                while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));


                if (hr == S_FALSE)
                {
                    // S_FALSE will terminate the loop successfully, so convert it to S_OK
                    // here.
                    hr = S_OK;
                }

                if (S_OK == hr)
                {
                    *ppActionListNode = pActionListNode;
                    pActionListNode->AddRef();
                }
            }
            else
            {
                TraceError("HrCreateScpdNode: [ActionSet] not found in service inf", hr);
            }
        }
        else
        {
            TraceError("HrCreateScpdNode: Failed to create <actionList> element", hr);
        }
        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrCreateScpdNode: Failed to allocate BSTR for element name", hr);
    }

    TraceError("HrCreateActionListNode", hr);
    return hr;
}

//
// Construct the list of arguments and related state variable
// for each argument
//
HRESULT HrGetArgumentList(IN    HINF        hinf,
                          IN    LPTSTR      szActionName,
                          IN    LPTSTR      szActionArgList,
                          OUT   ARG_LIST *  pargList)
{

    HRESULT hr = S_OK;

    BOOL fNamedArgs = FALSE;
    if (szActionArgList)
    {
        fNamedArgs = !!lstrlen(szActionArgList);
    }

    DWORD dwNum = 1;

    // Loop over the list of operations for this action
    INFCONTEXT  ctx;
    hr = HrSetupFindFirstLine(hinf, szActionName, NULL, &ctx);
    if (S_OK == hr)
    {
        do
        {
            TCHAR   szKey[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256
            TCHAR   szOpLine[LINE_LEN];

            // Retrieve a line from the Action
            hr = HrSetupGetStringField(ctx, 0, szKey, celems(szKey), NULL);
            if(S_OK == hr)
            {
                // varify this is an "Operation"
                szKey[celems(szKey)-1] = L'\0';
                if (lstrcmpi(szKey, TEXT("Operation")))
                {
                    TraceTag(ttidUpdiag, "ERROR! HrGetRelatedVariableList: Wrong key in the Operation section: %s", szKey);
                    continue;
                }

                hr = HrSetupGetLineText(ctx, szOpLine, celems(szOpLine), NULL);
                if (S_OK == hr)
                {
                    // Get the affected variables in this operation
                    TCHAR * szRelatedVariable;

                    TCHAR * pChar = _tcschr(szOpLine, TEXT('('));
                    if (pChar)
                    {
                        *pChar ='\0';
                        TCHAR * szOpName = szOpLine;

                        pChar ++;
                        szRelatedVariable = pChar;

                        DWORD nArgs;
                        DWORD nConsts;
                        if (IsStandardOperation(szOpName, &nArgs, &nConsts))
                        {
                            // get the Variable name
                            if (nArgs+nConsts ==0)
                            {
                                pChar = _tcschr(szRelatedVariable, TEXT(')'));
                            }
                            else
                            {
                                pChar = _tcschr(szRelatedVariable, TEXT(','));
                            }

                            if (pChar)
                            {
                                *pChar = TEXT('\0');

                                // BUGBUG: Can we check if the variable is valid ??
                                for (DWORD iArg =0; iArg < nArgs; iArg++)
                                {
                                    TCHAR szArgName[256];
                                    *szArgName = '\0';

                                    if (!fNamedArgs)
                                    {
                                        // generate argument name, add to the list
                                        lstrcpy(szArgName, TEXT("Argument_"));

                                        TCHAR szNum[2];
                                        _itot(dwNum, szNum, 10);

                                        lstrcat(szArgName, szNum);
                                        dwNum++;
                                    }
                                    else
                                    {
                                        // use the argument name specified in the inf
                                        pChar = _tcschr(szActionArgList, TEXT(','));
                                        if (pChar)
                                        {
                                            *pChar = '\0';
                                            lstrcpy(szArgName, szActionArgList);

                                            pChar ++;
                                            szActionArgList = pChar;
                                        }
                                        else
                                        {
                                            lstrcpy(szArgName, szActionArgList);
                                        }
                                    }

                                    if (!(*szArgName))
                                    {
                                        TraceTag(ttidUpdiag, "Argument list incomplete!");
                                        hr = E_INVALIDARG;
                                        break;
                                    }
                                    else
                                    {
                                        if (pargList->cArgs < MAX_ACTION_ARGUMENTS)
                                        {
                                            TraceTag(ttidUpdiag, "HrGetArgumentList: action: %s, argument: %s, relatedStateVariable: %s",
                                                     szActionName, szArgName, szRelatedVariable);

                                            lstrcpy(pargList->rgArguments[pargList->cArgs].szArg, szArgName);
                                            lstrcpy(pargList->rgArguments[pargList->cArgs].szVariable, szRelatedVariable);
                                            pargList->cArgs++;
                                        }
                                        else
                                        {
                                            TraceTag(ttidUpdiag, "Too many arguments!");
                                            hr = E_INVALIDARG;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            TraceTag(ttidUpdiag, "ERROR! HrGetArgumentList: unknown operation: %s",
                                     szOpName);
                        }
                    }
                }
            }
        }
        while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));
    }

    if (hr == S_FALSE)
    {
        // S_FALSE will terminate the loop successfully, so convert it to S_OK
        // here.
        hr = S_OK;
    }

    TraceError("HrGetArgumentList",hr);
    return hr;
}

HRESULT HrAddArgumentNode( IXMLDOMDocument * pDoc,
                           IXMLDOMElement  * pArgumentListNode,
                           LPTSTR szArgumentName,
                           LPTSTR szVariableName)
{
    HRESULT hr = S_OK;

    IXMLDOMElement  * pArgumentNode = NULL;
    BSTR    bstrElementName = SysAllocString(L"argument");
    if (bstrElementName)
    {
        hr = pDoc->createElement(bstrElementName, &pArgumentNode);
        if (SUCCEEDED(hr))
        {
            // name
            hr = HrAddElementWithText(pDoc, pArgumentNode,
                                      TEXT("name"), szArgumentName);

            if (SUCCEEDED(hr))
            {
                // relatedStateVariable
                hr = HrAddElementWithText(pDoc, pArgumentNode,
                                          TEXT("relatedStateVariable"), szVariableName);
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "HrAddArgumentNode: failed creating <argument> node");
        }

        SysFreeString(bstrElementName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (pArgumentNode && (S_OK == hr))
    {
        // append the argument node to "argumentList"
        VARIANT vNull;
        vNull.vt = VT_EMPTY;

        hr = pArgumentListNode->insertBefore(pArgumentNode, vNull, NULL);
        pArgumentNode->Release();
    }

    TraceError("HrAddArgumentNode", hr);
    return hr;
}

HRESULT HrCreateActionNode(IN   HINF hinf,
                           IN   LPTSTR    szActionLine,
                           IN   IXMLDOMDocument * pDoc,
                           OUT  IXMLDOMElement ** ppActionNode)
{
    HRESULT hr = S_OK;

    Assert(ppActionNode);
    *ppActionNode = NULL;

    IXMLDOMElement  * pActionNode = NULL;
    BSTR    bstrAction = SysAllocString(L"action");

    if (bstrAction)
    {
        hr = pDoc->createElement(bstrAction, &pActionNode);
        if (SUCCEEDED(hr))
        {
            TCHAR * szActionName = szActionLine;
            TCHAR * szActionArgList = NULL;

            TCHAR * pChar = _tcschr(szActionLine, TEXT('('));
            if (pChar)
            {
                *pChar = '\0';

                pChar ++;
                szActionArgList = pChar;

                pChar = _tcschr(szActionArgList, TEXT(')'));
                if (pChar)
                {
                    *pChar = '\0';
                }
                else
                {
                    TraceTag(ttidUpdiag, "HrCreateActionNode: argument list missing closing )");
                    hr = E_INVALIDARG;
                }
            }

            if (SUCCEEDED(hr))
            {
                // <name>
                hr = HrAddElementWithText(pDoc, pActionNode, TEXT("name"), szActionName);

                if (SUCCEEDED(hr))
                {
                    // <argumentList>
                    ARG_LIST argList;
                    argList.cArgs = 0;

                    hr = HrGetArgumentList(hinf, szActionName, szActionArgList, &argList);

                    if (SUCCEEDED(hr) && (argList.cArgs > 0))
                    {
                        IXMLDOMElement  * pArgumentListNode = NULL;
                        BSTR bstrArgumentList = SysAllocString(L"argumentList");
                        if (bstrArgumentList)
                        {
                            hr = pDoc->createElement(bstrArgumentList, &pArgumentListNode);
                            if (SUCCEEDED(hr))
                            {
                                for (DWORD iArg = 0; iArg < argList.cArgs; iArg++)
                                {
                                    hr = HrAddArgumentNode(pDoc, pArgumentListNode,
                                                           argList.rgArguments[iArg].szArg,
                                                           argList.rgArguments[iArg].szVariable);
                                    if (FAILED(hr))
                                        break;
                                }

                                if (SUCCEEDED(hr))
                                {
                                    // append the argumentList node to "action"
                                    VARIANT vNull;
                                    vNull.vt = VT_EMPTY;

                                    hr = pActionNode->insertBefore(pArgumentListNode, vNull, NULL);
                                    pArgumentListNode->Release();
                                }
                            }
                            else
                            {
                                TraceTag(ttidUpdiag, "HrCreateActionNode: failed creating argument list node");
                            }

                            SysFreeString(bstrArgumentList);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "HrCreateActionNode: Failed to create <action> node.");
        }
        SysFreeString(bstrAction);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        *ppActionNode = pActionNode;
        pActionNode->AddRef();
    }

    TraceError("HrCreateActionNode", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\media.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M E D I A . C P P
//
//  Contents:   Control handlers and implementation for the media
//              player device
//
//  Notes:
//
//  Author:     danielwe   6 Nov 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "media.h"
#include "ncbase.h"
#include "updiagp.h"
#include "ncinet.h"

static const LPSTR c_rgszStates[] =
{
    "Turned Off",
    "Uninitialized",
    "Stopped",
    "Paused",
    "Playing",
};

// Current multimedia variables
Media media = {TurnedOff, NULL, 0, FALSE};

DWORD Val_VolumeUp(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_VolumeUp(DWORD cArgs, ARG *rgArgs)
{
    OnVolumeUpDown(TRUE);
    return 1;
}

DWORD Val_VolumeDown(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_VolumeDown(DWORD cArgs, ARG *rgArgs)
{
    OnVolumeUpDown(FALSE);
    return 1;
}

DWORD Val_SetVolume(DWORD cArgs, ARG *rgArgs)
{
    if (cArgs == 1)
    {
        return 1;
    }

    return 0;
}

DWORD Do_SetVolume(DWORD cArgs, ARG *rgArgs)
{
    OnSetVolume(_tcstoul(rgArgs[0].szValue, NULL, 10));
    return 1;
}

DWORD Val_Mute(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_Mute(DWORD cArgs, ARG *rgArgs)
{
    OnMediaMute();
    return 1;
}

DWORD Val_Power(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_Power(DWORD cArgs, ARG *rgArgs)
{
    if (media.state == TurnedOff)
    {
        InitMedia();
    }
    else
    {
        DeleteContents();
    }

    return 1;
}

DWORD Val_LoadFile(DWORD cArgs, ARG *rgArgs)
{
    if (cArgs != 1)
    {
        return 0;
    }
    else
    {
        // Check if the file exists
        if (GetFileAttributes(rgArgs[0].szValue) == -1)
        {
            return 0;
        }
    }

    return 1;
}

DWORD Do_LoadFile(DWORD cArgs, ARG *rgArgs)
{
    OpenMediaFile(rgArgs[0].szValue);
    return 1;
}

DWORD Val_Play(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_Play(DWORD cArgs, ARG *rgArgs)
{
    OnMediaPlay();
    return 1;
}

DWORD Val_Stop(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_Stop(DWORD cArgs, ARG *rgArgs)
{
    OnMediaStop();
    return 1;
}

DWORD Val_Pause(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_Pause(DWORD cArgs, ARG *rgArgs)
{
    OnMediaPause();
    return 1;
}

DWORD Val_SetPos(DWORD cArgs, ARG *rgArgs)
{
    return 0;
}

DWORD Do_SetPos(DWORD cArgs, ARG *rgArgs)
{
    return 0;
}

DWORD Val_SetTime(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Do_SetTime(DWORD cArgs, ARG *rgArgs)
{
    return 1;
}

DWORD Val_Test(DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Testing 1 2 3...");
    return 1;
}

DWORD Do_Test(DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Doing a test!");
    return 1;
}

//
// CanPlay
//
// Return true if we can go to a playing state from our current state
//
BOOL CanPlay()
{
    return(media.state == Stopped || media.state == Paused);
}

BOOL CanSetVolume()
{
    return(media.state == Stopped ||
           media.state == Paused ||
           media.state == Playing);
}

//
// CanStop
//
// Return true if we can go to a stopped state from our current state
//
BOOL CanStop()
{
    return(media.state == Playing || media.state == Paused);
}


//
// CanPause
//
// Return true if we can go to a paused state from our current state
//
BOOL CanPause()
{
    return(media.state == Playing || media.state == Stopped);
}


//
// IsInitialized
//
// Return true if we have loaded and initialized a multimedia file
//
BOOL IsInitialized()
{
    return(media.state != Uninitialized);
}

VOID SubmitMediaEvent(LPCSTR szEventSource, LPCSTR szProp, LPCSTR szValue)
{
    UPNPSVC *   psvc;
    CHAR        szState[256];
    CHAR        szUri[INTERNET_MAX_URL_LENGTH];
    LPCSTR      szEvtSource = szEventSource ? szEventSource : g_pdata->szEventSource;
    LPTSTR      pszEvtSource;

    UPNP_PROPERTY rgProps[] =
    {
        {(LPSTR)szProp, 0, (LPSTR)szValue}
    };

    pszEvtSource = TszFromSz(szEvtSource);
    if (pszEvtSource)
    {
        psvc = PSvcFromId(pszEvtSource);
        if (psvc)
        {
            LPSTR pszEvtUrl;

            pszEvtUrl = SzFromTsz(psvc->szEvtUrl);
            if (pszEvtUrl)
            {
                HRESULT hr;

                hr = HrGetRequestUriA(pszEvtUrl, INTERNET_MAX_URL_LENGTH, szUri);
                if (SUCCEEDED(hr))
                {
                    if (SubmitUpnpPropertyEvent(szUri, 0, 1, rgProps))
                    {
                        TraceTag(ttidUpdiag, "Successfully submitted event for %s.",
                                 szUri);
                    }
                    else
                    {
                        TraceTag(ttidUpdiag, "Did not submit event for %s! Error %d.",
                                 g_pdata->szEventSource, GetLastError());
                    }
                }

                delete [] pszEvtUrl;
            }
            else
            {
                TraceTag(ttidUpdiag, "SubmitMediaEvent: SzFromTsz");
            }
        }
        delete [] pszEvtSource;
    }
    else
    {
        TraceTag(ttidUpdiag, "SubmitMediaEvent: TszFromSz");
    }
}


//
// ChangeStateTo
//
VOID ChangeStateTo(State newState)
{
    media.state = newState;

    SubmitMediaEvent("xport", "State", c_rgszStates[newState]);

    TraceTag(ttidMedia, "Changed state to %d.", newState);
}

DWORD WINAPI TimeThreadProc(LPVOID lpvThreadParam)
{
    while (TRUE)
    {
        if (WaitForSingleObject(g_hEventCleanup, 1000) == WAIT_OBJECT_0)
        {
            break;
        }
        else
        {
            SYSTEMTIME      st;
            FILETIME        ft;
            CHAR            szLocalTime[255];
            CHAR            szLocalDate[255];
            CHAR            szBoth[513];

            // Stamp the current time into the subscription struct
            //
            GetSystemTimeAsFileTime(&ft);

            // Convert time to local time zone
            FileTimeToLocalFileTime(&ft, &ft);
            FileTimeToSystemTime(&ft, &st);

            GetTimeFormatA(LOCALE_USER_DEFAULT, LOCALE_USE_CP_ACP, &st, NULL,
                           szLocalTime, 255);
            GetDateFormatA(LOCALE_USER_DEFAULT,
                           LOCALE_USE_CP_ACP | DATE_SHORTDATE, &st, NULL,
                           szLocalDate, 255);

            wsprintfA(szBoth, "%s %s", szLocalDate, szLocalTime);

            SubmitMediaEvent("clock", "DateTime", szBoth);
        }
    }

    return 0;
}

//
// InitMedia
//
// Initialization
//
BOOL InitMedia()
{
    DWORD               dwTid;

    g_hThreadTime = CreateThread(NULL, 0, TimeThreadProc, NULL, 0, &dwTid);

    ChangeStateTo( Uninitialized );

    media.pGraph = NULL;

    TraceTag(ttidMedia, "Initialized...");

    return TRUE;
}


//
// CreateFilterGraph
//
BOOL CreateFilterGraph()
{
    IMediaEvent *pME;
    HRESULT hr;

    ASSERT(media.pGraph == NULL);

    hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
                          IID_IGraphBuilder, (LPVOID *) &media.pGraph);
    TraceError("CreateFilterGraph: CoCreateInstance()", hr);
    if (FAILED(hr))
    {
        media.pGraph = NULL;
        return FALSE;
    }

    TraceTag(ttidMedia, "Created filter graph");

    return TRUE;

} // CreateFilterGraph


// Destruction
//
// DeleteContents
//
VOID DeleteContents()
{
    ReleaseObj(media.pGraph);
    media.pGraph = NULL;

    ChangeStateTo(Uninitialized);

    TraceTag(ttidMedia, "Deleted contents.");
}

//
// RenderFile
//
BOOL RenderFile(LPCTSTR szFileName)
{
    HRESULT hr;
    WCHAR wPath[MAX_PATH];
    CHAR aPath[MAX_PATH];

    DeleteContents();

    TszToWszBuf(wPath, szFileName, MAX_PATH);

    if (!CreateFilterGraph())
    {
        TraceTag(ttidMedia, "Couldn't render");
        return FALSE;
    }

    TszToWszBuf(wPath, szFileName, MAX_PATH);

    hr = media.pGraph->RenderFile(wPath, NULL);
    TraceError("RenderFile: RenderFile()", hr);

    if (FAILED(hr))
    {
        return FALSE;
    }

    TszToSzBuf(aPath, szFileName, MAX_PATH);

    SubmitMediaEvent("app", "File", aPath);

    TraceTag(ttidMedia, "Rendered file %s.", szFileName);
    return TRUE;

} // RenderFile


//
// OpenMediaFile
//
// File..Open has been selected
//
VOID OpenMediaFile(LPCTSTR szFile)
{
    if ( szFile != NULL && RenderFile(szFile))
    {
        TraceTag(ttidMedia, "Opened file %s." , szFile);
        ChangeStateTo(Stopped);
    }

} // OpenMediaFile

VOID OnSetVolume(DWORD dwVol)
{
    if (CanSetVolume())
    {
        HRESULT         hr;
        IBasicAudio *   pAudio;

        hr = media.pGraph->QueryInterface(IID_IBasicAudio, (LPVOID *) &pAudio);
        TraceError("OnSetVolume: QueryInterface()", hr);
        if (SUCCEEDED(hr))
        {
            LONG    lVol;
            CHAR    szVol[32];

            dwVol = max(0, dwVol);
            dwVol = min(7, dwVol);
            lVol = (7 - dwVol) * -300;

            TraceTag(ttidMedia, "Putting new volume of %d.", lVol);
            pAudio->put_Volume(lVol);

            wsprintfA(szVol, "%ld", lVol);
            SubmitMediaEvent("app", "Volume", szVol);

            ReleaseObj(pAudio);
        }
    }
}

VOID OnVolumeUpDown(BOOL fUp)
{
    if (CanSetVolume())
    {
        HRESULT         hr;
        IBasicAudio *   pAudio;

        hr = media.pGraph->QueryInterface(IID_IBasicAudio, (LPVOID *) &pAudio);
        TraceError("OnVolumeUp: QueryInterface()", hr);
        if (SUCCEEDED(hr))
        {
            LONG    lVol;
            const LONG lStep = 300;

            pAudio->get_Volume(&lVol);
            TraceTag(ttidMedia, "Current volume is %d.", lVol);

            if (fUp)
            {
                lVol += lStep;
                lVol = min(lVol, 0);
            }
            else
            {
                lVol -= lStep;
                lVol = max(lVol, -10000);
            }

            if (media.fIsMuted)
            {
                media.lOldVol = lVol;
                TraceTag(ttidMedia, "MUTED: Saving new volume of %d.", lVol);
            }
            else
            {
                CHAR    szVol[32];

                TraceTag(ttidMedia, "Putting new volume of %d.", lVol);
                pAudio->put_Volume(lVol);

                wsprintfA(szVol, "%ld", lVol);
                SubmitMediaEvent("app", "Volume", szVol);
            }

            ReleaseObj(pAudio);
        }
    }
}

VOID OnMediaMute()
{
    HRESULT         hr;
    IBasicAudio *   pAudio;

    hr = media.pGraph->QueryInterface(IID_IBasicAudio, (LPVOID *) &pAudio);
    TraceError("OnVolumeUp: QueryInterface()", hr);
    if (SUCCEEDED(hr))
    {
        if (media.fIsMuted)
        {
            TraceTag(ttidMedia, "Unmuting... Restoring volume of %d.",
                     media.lOldVol);
            pAudio->put_Volume(media.lOldVol);
            media.fIsMuted = FALSE;
        }
        else
        {
            pAudio->get_Volume(&media.lOldVol);
            TraceTag(ttidMedia, "Muting volume. Was %d.", media.lOldVol);
            pAudio->put_Volume(-10000);
            media.fIsMuted = TRUE;
        }

        ReleaseObj(pAudio);
    }
}

//
// OnMediaPlay
//
// There are two possible UI strategies for an application: you either play
// from the start each time you stop, or you play from the current position,
// in which case you have to explicitly rewind at the end. If you want the
// play from current and rewind at end, enable this code, if you want the
// other option, then enable FROM_START in both OnMediaStop and OnAbortStop.

#undef REWIND
#define FROM_START

VOID OnMediaPlay()
{
    if (CanPlay())
    {
        HRESULT hr;
        IMediaControl *pMC;

        // Obtain the interface to our filter graph
        hr = media.pGraph->QueryInterface(IID_IMediaControl, (LPVOID *) &pMC);
        TraceError("OnMediaPlay: QueryInterface()", hr);

        if (SUCCEEDED(hr))
        {
#ifdef REWIND
            IMediaPosition * pMP;
            hr = media.pGraph->lpVtbl->QueryInterface(media.pGraph,
                                                      &IID_IMediaPosition,
                                                      (VOID**) &pMP);
            if (SUCCEEDED(hr))
            {
                // start from last position, but rewind if near the end
                REFTIME tCurrent, tLength;
                hr = pMP->lpVtbl->get_Duration(pMP, &tLength);
                if (SUCCEEDED(hr))
                {
                    hr = pMP->lpVtbl->get_CurrentPosition(pMP, &tCurrent);
                    if (SUCCEEDED(hr))
                    {
                        // within 1sec of end? (or past end?)
                        if ((tLength - tCurrent) < 1)
                        {
                            pMP->lpVtbl->put_CurrentPosition(pMP, 0);
                        }
                    }
                }
                pMP->lpVtbl->Release(pMP);
            }
#endif
            // Ask the filter graph to play and release the interface
            hr = pMC->Run();
            TraceError("OnMediaPlay: Run()", hr);

            ReleaseObj(pMC);

            if (SUCCEEDED(hr))
            {
                ChangeStateTo(Playing);
                TraceTag(ttidMedia, "Playing...");
                return;
            }
        }

        TraceTag(ttidMedia, "Can't play!");
    }
    else
    {
        TraceTag(ttidMedia, "Not valid state for playing right now: %d.",
                 media.state);
    }

} // OnMediaPlay


//
// OnMediaPause
//
VOID OnMediaPause()
{
    if (CanPause())
    {
        HRESULT hr;
        IMediaControl *pMC;

        // Obtain the interface to our filter graph
        hr = media.pGraph->QueryInterface(IID_IMediaControl, (LPVOID *) &pMC);
        TraceError("OnMediaPause: QueryInterface()", hr);

        if (SUCCEEDED(hr))
        {
            // Ask the filter graph to pause and release the interface
            hr = pMC->Pause();
            TraceError("OnMediaPause: Pause()", hr);
            ReleaseObj(pMC);

            if (SUCCEEDED(hr))
            {
                ChangeStateTo(Paused);
                return;
            }
        }
    }
    else
    {
        TraceTag(ttidMedia, "Not valid state for pausing right now: %d.",
                 media.state);
    }

} // OnMediaPause

//
// OnMediaStop
//
// There are two different ways to stop a graph. We can stop and then when we
// are later paused or run continue from the same position. Alternatively the
// graph can be set back to the start of the media when it is stopped to have
// a more CDPLAYER style interface. These are both offered here conditionally
// compiled using the FROM_START definition. The main difference is that in
// the latter case we put the current position to zero while we change states
//
VOID OnMediaStop()
{
    if (CanStop())
    {
        HRESULT hr;
        IMediaControl *pMC;

        // Obtain the interface to our filter graph
        hr = media.pGraph->QueryInterface(IID_IMediaControl, (LPVOID *) &pMC);
        TraceError("OnMediaStop: QueryInterface(IID_IMediaControl)", hr);
        if (SUCCEEDED(hr))
        {

#ifdef FROM_START
            IMediaPosition * pMP;
            OAFilterState state;

            // Ask the filter graph to pause
            hr = pMC->Pause();
            TraceError("OnMediaStop: Pause()", hr);

            // if we want always to play from the beginning
            // then we should seek back to the start here
            // (on app or user stop request, and also after EC_COMPLETE).
            hr = media.pGraph->QueryInterface(IID_IMediaPosition, (LPVOID *) &pMP);
            TraceError("OnMediaStop: QueryInterface(IID_IMediaPosition)", hr);
            if (SUCCEEDED(hr))
            {
                pMP->put_CurrentPosition(0);
                ReleaseObj(pMP);
            }

            // wait for pause to complete
            pMC->GetState(INFINITE, &state);
#endif

            // now really do the stop
            pMC->Stop();
            ReleaseObj(pMC);
            ChangeStateTo(Stopped);
            return;
        }
    }
    else
    {
        TraceTag(ttidMedia, "Not valid state for pausing right now: %d.",
                 media.state);
    }

} // OnMediaStop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\eventsrc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E V E N T S R C . C P P
//
//  Contents:   Functions dealing with UPnP event sources.
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <oleauto.h>
#include "ncbase.h"
#include "updiagp.h"
#include "ncinet.h"

BOOL DoListEventSources(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    DWORD   ies;

    Assert(g_ctx.ectx == CTX_CD);

    _tprintf(TEXT("Listing all Event Sources\n"));
    _tprintf(TEXT("------------------------------\n"));
    for (ies = 0; ies < PDevCur()->cSvcs; ies++)
    {
        _tprintf(TEXT("%d) %s\n"), ies + 1,
                 PDevCur()->rgSvcs[ies]->szEvtUrl);
    }

    _tprintf(TEXT("------------------------------\n\n"));

    return FALSE;
}

BOOL DoSwitchEs(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_CD);

    if (cArgs == 2)
    {
        DWORD   idev;

        idev = _tcstoul(rgArgs[1], NULL, 10);
        if (idev <= PDevCur()->cSvcs && PDevCur()->rgSvcs[idev - 1])
        {
            g_ctx.psvcCur = PDevCur()->rgSvcs[idev - 1];
            g_ctx.ectx = CTX_EVTSRC;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid event source index!\n"), idev);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoSubmitEvent(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    DWORD           iArg;
    DWORD           iProp;
    UPNPSVC *       psvc = g_ctx.psvcCur;
    UPNP_PROPERTY * rgProps;
    DWORD           cProps = cArgs - 1;

    Assert(g_ctx.ectx == CTX_EVTSRC);

    if (cArgs < 2)
    {
        Usage(iCmd);
        return FALSE;
    }

    rgProps = new UPNP_PROPERTY[cProps];
    Assert(rgProps);

    ::ZeroMemory(rgProps, sizeof(UPNP_PROPERTY) * cProps);

    for (iArg = 1; iArg < cArgs; iArg++)
    {
        LPTSTR      szProp;
        LPTSTR      szValue;

        szProp = _tcstok(rgArgs[iArg], TEXT(":"));
        if (szProp)
        {
            iProp = _tcstoul(szProp, NULL, 10);
            if (iProp > 0)
            {
                iProp--;    // make it 0-based

                szValue = _tcstok(NULL, TEXT(":"));
                if (szValue)
                {
                    rgProps[iArg - 1].szName = SzFromTsz(psvc->sst.rgRows[iProp].szPropName);
                    rgProps[iArg - 1].szValue = SzFromTsz(szValue);
                }
                else
                {
                    _tprintf(TEXT("'%s' is not a valid property!\n\n"), szProp);
                    goto cleanup;
                }
            }
            else
            {
                _tprintf(TEXT("'%s' is not a valid property!\n\n"), szProp);
                goto cleanup;
            }
        }
        else
        {
            _tprintf(TEXT("'%s' is not a valid property!\n\n"), rgArgs[iArg]);
            goto cleanup;
        }
    }

    CHAR    szUri[INTERNET_MAX_URL_LENGTH];
    LPSTR   pszEvtUrl;
    HRESULT hr;

    pszEvtUrl = SzFromTsz(psvc->szEvtUrl);
    if (pszEvtUrl)
    {
        hr = HrGetRequestUriA(pszEvtUrl, INTERNET_MAX_URL_LENGTH, szUri);
        if (SUCCEEDED(hr))
        {
            if (SubmitUpnpPropertyEvent(szUri, 0, cProps, rgProps))
            {
                TraceTag(ttidUpdiag, "Successfully submitted event to %s.", psvc->szEvtUrl);
            }
            else
            {
                TraceTag(ttidUpdiag, "Failed to submit event to %s! Error %d.",
                         psvc->szEvtUrl, GetLastError());
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "Failed to crack URL %s! Error %d.",
                     psvc->szEvtUrl, GetLastError());
        }

        delete [] pszEvtUrl;
    }
    else
    {
        TraceTag(ttidUpdiag, "DoSubmitEvent: SzFromTsz failed");
    }

cleanup:
    iProp = 0;
    for ( ; iProp < cProps; ++iProp)
    {
        if (rgProps[iProp].szName)
        {
            delete [] rgProps[iProp].szName;
        }
        if (rgProps[iProp].szValue)
        {
            delete [] rgProps[iProp].szValue;
        }
    }

    delete [] rgProps;

    return FALSE;
}

BOOL DoListProps(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    DWORD       iProp;
    UPNPSVC *   psvc = g_ctx.psvcCur;

    Assert(g_ctx.ectx == CTX_EVTSRC);

    _tprintf(TEXT("Listing properties for event source %s...\n"),
             g_ctx.psvcCur->szEvtUrl);
    _tprintf(TEXT("----------------------------------------------------\n"));

    for (iProp = 0; iProp < psvc->sst.cRows; iProp++)
    {
        VARIANT     varDest;

        VariantClear(&varDest);
        VariantChangeType(&varDest, &psvc->sst.rgRows[iProp].varValue, 0, VT_BSTR);
        _tprintf(TEXT("%d) %s = %S\n"), iProp + 1,
                 psvc->sst.rgRows[iProp].szPropName, varDest.bstrVal);
    }

    _tprintf(TEXT("----------------------------------------------------\n\n"));

    return FALSE;
}

DWORD CsecDiffFileTime(FILETIME * pft1, FILETIME *pft2)
{
    ULONGLONG qwResult1;
    ULONGLONG qwResult2;
    LONG lDiff;

    // Copy the time into a quadword.
    qwResult1 = (((ULONGLONG) pft1->dwHighDateTime) << 32) + pft1->dwLowDateTime;
    qwResult2 = (((ULONGLONG) pft2->dwHighDateTime) << 32) + pft2->dwLowDateTime;

    lDiff = (LONG) (((LONGLONG)(qwResult2 - qwResult1)) / _SECOND);
    lDiff = max(0, lDiff);

    return lDiff;
}

VOID DoEvtSrcInfo()
{
    UPNPSVC *       psvc = g_ctx.psvcCur;
    CHAR            szUri[INTERNET_MAX_URL_LENGTH];
    HRESULT         hr;
    EVTSRC_INFO     info = {0};
    EVTSRC_INFO *   pinfo = &info;
    LPSTR           pszEvtUrl;

    pszEvtUrl = SzFromTsz(psvc->szEvtUrl);
    if (pszEvtUrl)
    {
        hr = HrGetRequestUriA(pszEvtUrl, INTERNET_MAX_URL_LENGTH, szUri);
        if (SUCCEEDED(hr))
        {
            if (GetEventSourceInfo(szUri, &pinfo))
            {
                DWORD   iSub;

                _tprintf(TEXT("Listing information for event source %s:\n"),
                         psvc->szEvtUrl);
                _tprintf(TEXT("------------------------------------------------------\n"));

                for (iSub = 0; iSub < pinfo->cSubs; iSub++)
                {
                    SYSTEMTIME  st;
                    FILETIME    ftCur;
                    TCHAR       szLocalDate[255];
                    TCHAR       szLocalTime[255];

                    _tprintf(TEXT("Notify to : %s\n"), pinfo->rgSubs[iSub].szDestUrl);
                    _tprintf(TEXT("Seq #     : %d\n"), pinfo->rgSubs[iSub].iSeq);

                    FileTimeToSystemTime(&pinfo->rgSubs[iSub].ftTimeout, &st);
                    GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL,
                                  szLocalDate, 255);
                    GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL,
                                 szLocalTime, 255);

                    GetSystemTimeAsFileTime(&ftCur);
                    FileTimeToLocalFileTime(&ftCur, &ftCur);

                    _tprintf(TEXT("Expires   : %s %s (in %d seconds)\n"),
                             szLocalDate, szLocalTime,
                             CsecDiffFileTime(&ftCur,
                                              &pinfo->rgSubs[iSub].ftTimeout));

                    _tprintf(TEXT("Timeout   : %d\n"), pinfo->rgSubs[iSub].csecTimeout);
                    _tprintf(TEXT("SID       : %s\n\n"), pinfo->rgSubs[iSub].szSid);

                    free(pinfo->rgSubs[iSub].szDestUrl);
                    free(pinfo->rgSubs[iSub].szSid);
                }

                free(pinfo->rgSubs);

                _tprintf(TEXT("------------------------------------------------------\n\n"));

            }
            else
            {
                TraceTag(ttidUpdiag, "Failed to get event source info for %s! Error %d.",
                         psvc->szEvtUrl, GetLastError());
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "Failed to crack URL %s! Error %d.",
                     psvc->szEvtUrl, GetLastError());
        }
        delete [] pszEvtUrl;
    }
    else
    {
        TraceTag(ttidUpdiag, "DoEvtSrcInfo: SzFromTsz failed");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\search.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S E A R C H . C P P
//
//  Contents:   Functions dealing with UPnP searches.
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncbase.h"
#include "updiagp.h"


BOOL DoFindServices(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_UCP);

    if (g_ctx.pucpCur->cResults >= MAX_RESULT)
    {
        _tprintf(TEXT("Exceeded maximum number of results!\n"));
        return FALSE;
    }

    if (cArgs == 2)
    {
        UPNPRESULT *  pres;
        LPSTR pszType;

        pres = new UPNPRESULT;
        ZeroMemory(pres, sizeof(UPNPRESULT));
        lstrcpy(pres->szType, rgArgs[1]);
        pres->resType = RES_FIND;

        pszType = SzFromTsz(rgArgs[1]);
        if (pszType)
        {
            pres->hResult = FindServicesCallback(pszType, NULL, FALSE,
                                                NotifyCallback, (LPVOID)pres);
            if (pres->hResult && pres->hResult != INVALID_HANDLE_VALUE)
            {
                g_ctx.pucpCur->rgResults[g_ctx.pucpCur->cResults++] = pres;
                _tprintf(TEXT("Started looking for devices of type: %s\n"), rgArgs[1]);
            }
            else
            {
                _tprintf(TEXT("FindServicesCallback failed with error %d.\n"),
                         GetLastError());
                delete pres;
            }

            delete [] pszType;
        }
        else
        {
            _tprintf(TEXT("DoFindServices: SzFromTsz failed\n"));
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoSwitchResult(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_UCP);

    if (cArgs == 2)
    {
        DWORD   ires;

        ires = _tcstoul(rgArgs[1], NULL, 10);
        if (ires <= g_ctx.pucpCur->cResults &&
            g_ctx.pucpCur->rgResults[ires - 1])
        {
            g_ctx.presCur = g_ctx.pucpCur->rgResults[ires - 1];
            g_ctx.ectx = CTX_RESULT;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid result index!\n"), ires);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

LPCTSTR SzFromResType(RESULT_TYPE rt)
{
    switch (rt)
    {
        case RES_NOTIFY:
            return TEXT("Notify");
        case RES_FIND:
            return TEXT("Search");
        case RES_SUBS:
            return TEXT("Subscription");
    }

    return TEXT("Unknown");
}

BOOL DoListUpnpResults(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (g_ctx.ectx == CTX_UCP)
    {
        DWORD   isvc;

        _tprintf(TEXT("Listing all Results within %s\n"), g_ctx.pucpCur->szName);
        _tprintf(TEXT("------------------------------\n"));
        for (isvc = 0; isvc < g_ctx.pucpCur->cResults; isvc++)
        {
            UPNPRESULT *    pres = g_ctx.pucpCur->rgResults[isvc];

            _tprintf(TEXT("%d) %s:(%s) - %d result(s)\n"), isvc + 1,
                     SzFromResType(pres->resType),
                     pres->szType,
                     pres->cResult);
        }

        _tprintf(TEXT("------------------------------\n\n"));
    }

    return FALSE;
}

VOID ListUpnpResultMsgs(DWORD ires, UPNPRESULT *pResult)
{
    switch (pResult->resType)
    {
        case RES_NOTIFY:
        case RES_FIND:
            _tprintf(TEXT("%d) Type      : %s\n"),
                     ires + 1, pResult->rgmsgResult[ires]->iSeq == 2 ? "Alive" :
                  pResult->rgmsgResult[ires]->iSeq == 1 ? "Byebye" : "Search");
            _tprintf(TEXT("   USN       : %s\n"),
                     pResult->rgmsgResult[ires]->szUSN);
            _tprintf(TEXT("   SID       : %s\n"),
                     pResult->rgmsgResult[ires]->szSid);
            _tprintf(TEXT("   AL        : %s\n"),
                     pResult->rgmsgResult[ires]->szAltHeaders);
            _tprintf(TEXT("   Location  : %s\n"),
                     pResult->rgmsgResult[ires]->szLocHeader);
            _tprintf(TEXT("   NT/ST     : %s\n"),
                     pResult->rgmsgResult[ires]->szType);
            _tprintf(TEXT("   LifeTime  : %d\n"),
                     pResult->rgmsgResult[ires]->iLifeTime);
            break;
        case RES_SUBS:
            _tprintf(TEXT("%d) Seq #:%d Sid: %s - Content\n%s\n"), ires + 1,
                     pResult->rgmsgResult[ires]->iSeq,
                     pResult->rgmsgResult[ires]->szSid,
                     pResult->rgmsgResult[ires]->szContent);
            break;
    }
}

BOOL DoListUpnpResultMsgs(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_RESULT);

    DWORD           ires;
    UPNPRESULT *    pres = g_ctx.presCur;

    _tprintf(TEXT("Listing all Results within %s\n"), pres->szType);
    _tprintf(TEXT("------------------------------\n"));
    for (ires = 0; ires < pres->cResult; ires++)
    {
        ListUpnpResultMsgs(ires, pres);
    }

    _tprintf(TEXT("------------------------------\n\n"));

    return FALSE;
}

BOOL DoAlive(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    HANDLE  hSubs;

    Assert(g_ctx.ectx & CTX_UCP);

    if (g_ctx.pucpCur->cResults >= MAX_RESULT)
    {
        _tprintf(TEXT("Exceeded maximum number of subscriptions!\n"));
        return FALSE;
    }

    if (cArgs == 2)
    {
        UPNPRESULT *  pAlive;

        pAlive = new UPNPRESULT;
        ZeroMemory(pAlive, sizeof(UPNPRESULT));
        lstrcpy(pAlive->szType, rgArgs[1]);
        pAlive->resType = RES_NOTIFY;

        if (g_ctx.ectx == CTX_UCP)
        {
            LPSTR pszType;

            pszType = SzFromTsz(rgArgs[1]);
            if (pszType)
            {
                pAlive->hResult = RegisterNotification(NOTIFY_ALIVE, pszType,
                                                      NULL, NotifyCallback,
                                                      (LPVOID) pAlive);
                if (pAlive->hResult && pAlive->hResult != INVALID_HANDLE_VALUE)
                {
                    g_ctx.pucpCur->rgResults[g_ctx.pucpCur->cResults++] = pAlive;
                    _tprintf(TEXT("Listening for alive from: %s\n"), rgArgs[1]);
                }
                else
                {
                    _tprintf(TEXT("RegisterNotification failed with error %d.\n"),
                             GetLastError());
                    delete pAlive;
                }

                delete [] pszType;
            }
            else
            {
                _tprintf(TEXT("DoAlive: SzFromTsz failed"));
            }
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoDelResult(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_UCP);

    if (cArgs == 2)
    {
        DWORD   ires;

        ires = _tcstoul(rgArgs[1], NULL, 10);
        if (ires <= g_ctx.pucpCur->cResults &&
            g_ctx.pucpCur->rgResults[ires - 1])
        {
            UPNPRESULT *  pres = g_ctx.pucpCur->rgResults[ires - 1];

            _tprintf(TEXT("Deleted result %s.\n"), pres->szType);
            // Move last item into gap and decrement the count
            g_ctx.pucpCur->rgResults[ires - 1] = g_ctx.pucpCur->rgResults[g_ctx.pucpCur->cResults - 1];
            CleanupResult(pres);
            g_ctx.pucpCur->cResults--;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid search index!\n"), ires);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

VOID CleanupResult(UPNPRESULT *pres)
{
    DWORD   i;

    for (i = 0; i < pres->cResult; i++)
    {
        LocalFreeSsdpMessage(pres->rgmsgResult[i]);
    }

    switch (pres->resType)
    {
        case RES_FIND:
            TraceTag(ttidUpdiag, "Closing search handle %d.", pres->hResult);
            FindServicesClose(pres->hResult);
            break;

        case RES_SUBS:
        case RES_NOTIFY:
            TraceTag(ttidUpdiag, "Deregistering notification %d.", pres->hResult);
            DeregisterNotification(pres->hResult);
            break;

    }
    delete pres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\device.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D E V I C E . C P P
//
//  Contents:   Functions dealing with UPnP controlled devices
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncbase.h"
#include <oleauto.h>
#include <wininet.h>
#include "updiagp.h"
#include "ncinet.h"
#include "setupapi.h"
#include "util.h"

extern const STANDARD_OPERATION_LIST c_Ops;

UPNPDEV *PDevCur()
{
    return g_ctx.pdevCur[g_ctx.idevStackIndex - 1];
}

VOID PushDev(UPNPDEV *pdev)
{
    g_ctx.pdevCur[g_ctx.idevStackIndex++] = pdev;
    g_ctx.ectx = CTX_CD;
}

UPNPDEV *PopDev()
{
    UPNPDEV *   pdev;

    pdev = PDevCur();
    g_ctx.idevStackIndex--;

    return pdev;
}

VOID RgPropsFromSst(SST *psst, UPNP_PROPERTY **prgProps)
{
    DWORD           iProp;
    UPNP_PROPERTY * rgProps;

    rgProps = new UPNP_PROPERTY[psst->cRows];

    for (iProp = 0; iProp < psst->cRows; iProp++)
    {
        rgProps[iProp].szName = SzFromTsz(psst->rgRows[iProp].szPropName);

        VARIANT     varDest;
        VariantInit(&varDest);
        VariantChangeType(&varDest, &psst->rgRows[iProp].varValue, 0, VT_BSTR);

        //$ BUGBUG (danielwe) 25 Oct 1999: Remove this when SSDP is built
        // Unicode.
        //
        LPWSTR  wszVal = varDest.bstrVal;
        rgProps[iProp].szValue = SzFromWsz(wszVal);
        rgProps[iProp].dwFlags = 0;
    }

    *prgProps = rgProps;
}

BOOL FRegisterDeviceAsUpnpService(LPSTR szDescDocUrl, UPNPDEV *pdev)
{
    SSDP_MESSAGE    msg = {0};
    CHAR            szBuffer[256];
    CHAR            szUdn[256];
    CHAR            szType[256];

    msg.iLifeTime = 15000;
    msg.szLocHeader = szDescDocUrl;

    Assert(pdev->szUdn);
    Assert(pdev->szDeviceType);

    TszToSzBuf(szUdn, pdev->szUdn, celems(szUdn));
    TszToSzBuf(szType, pdev->szDeviceType, celems(szType));

    // Only register this type if this is a root device
    //
    if (pdev->fRoot)
    {
        wsprintfA(szBuffer, "%s::upnp:rootdevice", szUdn);
        msg.szType = "upnp:rootdevice";
        msg.szUSN = szBuffer;

        pdev->hSvc[0] = RegisterService(&msg, 0);
        if (pdev->hSvc[0] != INVALID_HANDLE_VALUE)
        {
            TraceTag(ttidUpdiag, "Registered %s as an SSDP Service.",
                     msg.szType);
        }
        else
        {
            TraceTag(ttidUpdiag, "Failed to register %s as an SSDP Service! Error = %d.",
                     msg.szType, GetLastError());
            return FALSE;
        }
    }

    msg.szUSN = szUdn;
    msg.szType = szUdn;

    pdev->hSvc[1] = RegisterService(&msg, 0);
    if (pdev->hSvc[1] != INVALID_HANDLE_VALUE)
    {
        TraceTag(ttidUpdiag, "Registered %s as an SSDP Service.",
                 msg.szType);
    }
    else
    {
        TraceTag(ttidUpdiag, "Failed to register %s as an SSDP Service! Error = %d.",
                 msg.szType, GetLastError());
        return FALSE;
    }

    wsprintfA(szBuffer, "%s::%s", szUdn, szType);
    msg.szUSN = szBuffer;
    msg.szType = szType;

    pdev->hSvc[2] = RegisterService(&msg, 0);
    if (pdev->hSvc[2] != INVALID_HANDLE_VALUE)
    {
        TraceTag(ttidUpdiag, "Registered %s as an SSDP Service.",
                 msg.szType);
    }
    else
    {
        TraceTag(ttidUpdiag, "Failed to register %s as an SSDP Service! Error = %d.",
                 msg.szType, GetLastError());
        return FALSE;
    }

    return TRUE;
}

VOID GetServiceConfigFile(UPNPDEV * pdev, UPNPSVC * psvc, LPCTSTR szDevConfigFile)
{
    HRESULT     hr;
    HINF        hinf;
    INFCONTEXT  ctx;
    UINT        unErrorLine;

    TCHAR   szKey[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256
    TCHAR   szDeviceType[LINE_LEN];
    TCHAR   szServiceType[LINE_LEN];

    // full path to the inf file is %windir%\inf\szConfigFile
    TCHAR   szDevConfigFileWithPath[MAX_PATH];
    GetWindowsDirectory (szDevConfigFileWithPath, MAX_PATH);

    lstrcat (szDevConfigFileWithPath, TEXT("\\inf\\"));
    lstrcat(szDevConfigFileWithPath, szDevConfigFile);

    hr = HrSetupOpenConfigFile(szDevConfigFileWithPath, &unErrorLine, &hinf);
    if (S_OK == hr)
    {
        Assert(IsValidHandle(hinf));

        // Loop over the Devices section
        hr = HrSetupFindFirstLine(hinf, TEXT("Devices"), NULL, &ctx);
        if (S_OK == hr)
        {
            do
            {
                // Retrieve a line from the Devices section
                hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                if(S_OK == hr)
                {
                    // varify this is an "Device"
                    szKey[celems(szKey)-1] = L'\0';
                    if (lstrcmpi(szKey, TEXT("Device")))
                    {
                        TraceTag(ttidUpdiag, "Wrong key in the Devices section: %s", szKey);
                        continue;
                    }

                    // Query the DeviceType
                    hr = HrSetupGetStringField(ctx, 1, szDeviceType, celems(szDeviceType),
                                               NULL);
                    if (S_OK == hr)
                    {
                        if (!lstrcmpi(szDeviceType, pdev->szDeviceType))
                        {
                            break;
                        }
                        else
                        {
                            continue;
                        }
                    }
                }
            }
            while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));
        }

        if (hr == S_FALSE)
        {
            // we didn't find the device !
            TraceTag(ttidUpdiag, "Error!! Config section for device %s is not found.",
                     pdev->szDeviceType);
        }
        else
        {
            // Loop over section for this device
            hr = HrSetupFindFirstLine(hinf, szDeviceType, NULL, &ctx);
            if (S_OK == hr)
            {
                do
                {
                    // Retrieve a line from the Devices section
                    hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                    if(S_OK == hr)
                    {
                        // varify this is an "Device"
                        szKey[celems(szKey)-1] = L'\0';
                        if (lstrcmpi(szKey, TEXT("Service")))
                        {
                            TraceTag(ttidUpdiag, "Wrong key in the Device's section: %s", szKey);
                            continue;
                        }

                        // Query the Service Type
                        hr = HrSetupGetStringField(ctx, 1, szServiceType, celems(szServiceType),
                                                   NULL);
                        if (S_OK == hr)
                        {
                            if (!lstrcmpi(szServiceType, psvc->szServiceType))
                            {
                                break;
                            }
                            else
                            {
                                continue;
                            }
                        }
                    }
                }
                while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));

                if (hr == S_FALSE)
                {
                    // we didn't find the service !
                    TraceTag(ttidUpdiag, "Error!! Config section for service %s is not found.",
                             psvc->szServiceType);
                }
                else
                {
                    hr = HrSetupFindFirstLine(hinf, szServiceType, NULL, &ctx);
                    if (S_OK == hr)
                    {
                        // Retrieve a line from the Devices section
                        hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                        if(S_OK == hr)
                        {
                            // varify this is an "Device"
                            szKey[celems(szKey)-1] = L'\0';
                            if (lstrcmpi(szKey, TEXT("ServiceInf")))
                            {
                                TraceTag(ttidUpdiag, "Wrong key in the Service's section: %s", szKey);
                            }
                            else
                            {
                                // Query the Service config file
                                TCHAR szConfigFile[MAX_PATH];
                                hr = HrSetupGetStringField(ctx, 1, szConfigFile,
                                                           celems(szConfigFile), NULL);
                                if (S_OK ==hr)
                                {
                                    // full path to the inf file is %windir%\inf\szConfigFile
                                    TCHAR   szDevConfigFileWithPath[MAX_PATH];
                                    GetWindowsDirectory (psvc->szConfigFile, MAX_PATH);

                                    lstrcat (psvc->szConfigFile, TEXT("\\inf\\"));
                                    lstrcat(psvc->szConfigFile, szConfigFile);
                                }
                            }
                        }
                    }
                }
            }
        }

        SetupCloseInfFileSafe(hinf);
    }
}

HRESULT HrAddAllowedValue(SST_ROW * pRow, TCHAR * szValueRange)
{
    HRESULT hr = S_OK;

    if(*szValueRange == '(')
    {
        szValueRange++;

        IXMLDOMElement  * pAllowedValueNode = NULL;
        BSTR    bstrElementName;

        // we assume that ".." specifies a range, otherwise it's a comma
        // separated list of allowed values
        TCHAR * pChar = _tcsstr(szValueRange, TEXT(".."));
        if (pChar)
        {
            // we have a range
            TCHAR * pNextItem = szValueRange;

            // BUGBUG: we should check if data type of the min, max & step
            // matches the variable type
            *pChar = '\0';
            lstrcpy(pRow->szMin, pNextItem);
            pNextItem = pChar+2;

            pChar = _tcschr(pNextItem, TEXT(','));
            if (pChar)
            {
                *pChar = '\0';
                lstrcpy(pRow->szMax, pNextItem);
                pNextItem = ++pChar;

                pChar = _tcschr(pNextItem, TEXT(')'));
                if (pChar)
                {
                    *pChar = '\0';
                    lstrcpy(pRow->szStep, pNextItem);
                }
                else
                {
                    TraceTag(ttidUpdiag, "HrAddAllowedValue: missing closing )");
                    hr = E_INVALIDARG;
                }
            }
            else
            {
                TraceTag(ttidUpdiag, "HrAddAllowedValue: step not specified");
                hr = E_INVALIDARG;
            }
        }
        else
        {
            // we have a list of allowed values
            pChar = _tcschr(szValueRange, TEXT(')'));
            if (pChar)
            {
                *pChar = '\0';
                if (lstrlen(szValueRange))
                {
                    lstrcpy(pRow->mszAllowedValueList, szValueRange);
                    TCHAR * pNextItem = pRow->mszAllowedValueList;

                    while ((S_OK ==hr) && (pChar = _tcschr(pNextItem, TEXT(','))))
                    {
                        *pChar = '\0';
                        pNextItem = ++pChar;
                    }

                    // add the last one
                    if (*pNextItem)
                    {
                        pNextItem += lstrlen(pNextItem);
                        pNextItem ++;

                        *pNextItem = '\0';
                    }
                    else
                    {
                        TraceTag(ttidUpdiag, "HrAddAllowedValue: invalid syntax");
                        hr = E_INVALIDARG;
                    }
                }
            }
            else
            {
                TraceTag(ttidUpdiag, "HrAddAllowedValue: missing closing )");
                hr = E_INVALIDARG;
            }
        }
    }
    else
    {
        TraceTag(ttidUpdiag, "HrAddAllowedValue: missing begining (");
                 hr = E_INVALIDARG;
    }

    TraceError("HrAddAllowedValue", hr);
    return hr;
}

HRESULT HrAddVariable(UPNPSVC * psvc, LPTSTR szVariableLine)
{
    HRESULT hr = S_OK;

    DWORD iRow = psvc->sst.cRows;
    if (iRow < MAX_SST_ROWS)
    {
        SST_ROW * pRow = &psvc->sst.rgRows[iRow];

        // fill in variable name
        TCHAR szName[MAX_PATH];
        if (fGetNextField(&szVariableLine, szName))
        {
            lstrcpy(pRow->szPropName, szName);

            TCHAR szType[MAX_PATH];
            fGetNextField(&szVariableLine, szType);

            TCHAR szValueRange[MAX_PATH];
            fGetNextField(&szVariableLine, szValueRange);

            TCHAR szDefaultValue[MAX_PATH];
            fGetNextField(&szVariableLine, szDefaultValue);

            // fill in variable type and default value
            if (*szType && *szDefaultValue)
            {
                VariantInit(&pRow->varValue);
                pRow->varValue.vt = VT_BSTR;

                WCHAR * wszDefaultValue = WszFromTsz(szDefaultValue);
                V_BSTR(&pRow->varValue) = SysAllocString(wszDefaultValue);
                delete wszDefaultValue;

                VARTYPE vt = VT_EMPTY;

                if (lstrcmpi(szType, TEXT("number")) == 0)
                {
                    vt = VT_I4;
                }
                else if (lstrcmpi(szType, TEXT("string")) == 0)
                {
                    vt = VT_BSTR;
                }
                else if (lstrcmpi(szType, TEXT("dateTime")) == 0)
                {
                    vt = VT_DATE;
                }
                else if (lstrcmpi(szType, TEXT("boolean")) == 0)
                {
                    vt = VT_BOOL;
                }
                else if (lstrcmpi(szType, TEXT("ByteBlock")) == 0)
                {
                    vt = VT_UI1 | VT_ARRAY;
                }

                if (vt != VT_EMPTY)
                {
                    hr = VariantChangeType(&pRow->varValue, &pRow->varValue, 0, vt);
                }
                else
                {
                    hr = E_INVALIDARG;
                    TraceTag(ttidUpdiag, "HrAddVariable: invalid data type %s.", szType);
                }

                if (S_OK == hr)
                {
                    // fill in value range or list of allowed values if specified
                    *pRow->mszAllowedValueList  = '\0';
                    *pRow->szMin  = '\0';
                    *pRow->szMax  = '\0';
                    *pRow->szStep = '\0';

                    if (*szValueRange)
                    {
                        hr = HrAddAllowedValue(pRow, szValueRange);
                    }

                    // successfully added a new row
                    if (S_OK == hr)
                    {
                        psvc->sst.cRows++;
                    }
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                TraceTag(ttidUpdiag, "HrAddVariable: data type or default value missing for variable %s.",
                         szName);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            TraceTag(ttidUpdiag, "HrAddVariable: variable name not found");
        }
    }
    else
    {
        hr = E_FAIL;
        TraceTag(ttidUpdiag, "HrAddVariable: max number of rows in state table exceeded");
    }

    TraceError("HrAddVariable", hr);
    return hr;
}

// input:  the state table and variable name
// output: if the variable exists in the state table
// NYI
BOOL IsValidVariable(SST * pSST, TCHAR * szVarName)
{
    return TRUE;
}

// parses a line and fill in a new operation of an action
HRESULT HrAddOperation(UPNPSVC * psvc, ACTION * pAction, TCHAR * szLine)
{
    HRESULT hr = S_OK;

    DWORD iOperation = pAction->cOperations;
    if (iOperation < MAX_OPERATIONS)
    {
        OPERATION_DATA * pOperation = &pAction->rgOperations[iOperation];

        // get the operations's name
        TCHAR * pChar = _tcschr(szLine, TEXT('('));
        if (pChar)
        {
            *pChar ='\0';
            lstrcpy(pOperation->szOpName, szLine);
            szLine = ++pChar;

            DWORD nArgs;
            DWORD nConsts;
            if (IsStandardOperation(pOperation->szOpName, &nArgs, &nConsts))
            {
                TraceTag(ttidUpdiag, "=== Operation %s ===", pOperation->szOpName);
                // get the Variable name
                if (nArgs+nConsts ==0)
                {
                    pChar = _tcschr(szLine, TEXT(')'));
                }
                else
                {
                    pChar = _tcschr(szLine, TEXT(','));
                }

                if (pChar)
                {
                    *pChar = TEXT('\0');
                    lstrcpy(pOperation->szVariableName, szLine);
                    szLine = ++pChar;

                    if(IsValidVariable(&psvc->sst, pOperation->szVariableName))
                    {
                        TraceTag(ttidUpdiag, "Variable: %s", pOperation->szVariableName);

                        BOOL fError = FALSE;

                        // skip the arguments
                        while (nArgs > 0)
                        {
                            if (nArgs + nConsts == 1)
                            {
                                pChar = _tcschr(szLine, TEXT(')'));
                            }
                            else
                            {
                                pChar = _tcschr(szLine, TEXT(','));
                            }

                            if (pChar)
                            {
                                *pChar = TEXT('\0');
                                TraceTag(ttidUpdiag, "Argument: %s", szLine);
                                szLine = ++pChar;
                            }
                            else
                            {
                                fError = TRUE;
                                TraceTag(ttidUpdiag, "ERROR! HrAddOperation: Syntax error: missing arguments");
                                break;
                            }
                            nArgs--;
                        }

                        if (!fError)
                        {
                            TCHAR * pNextConst = pOperation->mszConstantList;

                            // now get the constants, all in string form
                            while (nConsts >0)
                            {
                                if (nConsts == 1)
                                {
                                    pChar = _tcschr(szLine, TEXT(')'));
                                }
                                else
                                {
                                    pChar = _tcschr(szLine, TEXT(','));
                                }

                                if (pChar)
                                {
                                    *pChar = TEXT('\0');
                                    TraceTag(ttidUpdiag, "Constant: %s", szLine);
                                    lstrcpy(pNextConst, szLine);

                                    pNextConst+=lstrlen(pNextConst);
                                    pNextConst++;

                                    szLine = ++pChar;
                                }
                                else
                                {
                                    fError = TRUE;
                                    TraceTag(ttidUpdiag, "ERROR! HrAddOperation: Syntax error: missing constants");
                                    break;
                                }

                                nConsts--;
                            }
                            *pNextConst = TEXT('\0');
                        }

                        if (!fError)
                        {
                            // all is well, increment the count of operations
                            pAction->cOperations++;
                        }
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        TraceTag(ttidUpdiag, "ERROR! HrAddOperation: variable %s not in state table",
                                 pOperation->szVariableName);
                    }
                }
                else
                {
                    hr = E_INVALIDARG;
                    TraceTag(ttidUpdiag, "ERROR! HrAddOperation: Invalid syntax for operation: %s, affected state variable not found",
                             pOperation->szOpName);
                }
            }
            else
            {
                hr = E_INVALIDARG;
                TraceTag(ttidUpdiag, "ERROR! HrAddOperation: Invalid operation: %s", pOperation->szOpName);
            }
        }
    }

    TraceError("HrAddOperation", hr);
    return hr;
}

HRESULT HrAddAction(UPNPSVC * psvc, HINF hinf, TCHAR * szActionName)
{
    HRESULT hr = S_OK;
    INFCONTEXT  ctx;

    DWORD iAction = psvc->action_set.cActions;
    ACTION * pAction = &(psvc->action_set.rgActions[iAction]);

    // initialize the new action
    lstrcpy(pAction->szActionName, szActionName);
    pAction->cOperations = 0;

    // Loop over the list of operations for this action
    hr = HrSetupFindFirstLine(hinf, szActionName, NULL, &ctx);
    if (S_OK == hr)
    {
        do
        {
            TCHAR   szKey[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256
            TCHAR   szOpLine[LINE_LEN];

            // Retrieve a line from the Action
            hr = HrSetupGetStringField(ctx, 0, szKey, celems(szKey),
                                       NULL);
            if(S_OK == hr)
            {
                // varify this is an "Operation"
                szKey[celems(szKey)-1] = L'\0';
                if (lstrcmpi(szKey, TEXT("Operation")))
                {
                    TraceTag(ttidUpdiag, "ERROR! HrAddAction: Wrong key in the Operation section: %s", szKey);
                    continue;
                }

                // Query the OperationLine
                // get the line text
                hr = HrSetupGetLineText(ctx, szOpLine, celems(szOpLine), NULL);
                if (S_OK == hr)
                {
                    // Add operations in this action
                    hr = HrAddOperation(psvc, pAction, szOpLine);
                }
            }
        }
        while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));
    }

    if (hr == S_FALSE)
    {
        // S_FALSE will terminate the loop successfully, so convert it to S_OK
        // here.
        hr = S_OK;
    }

    // we just successfully added a new action
    if (S_OK == hr)
        psvc->action_set.cActions++;

    return hr;
}

HRESULT HrLoadSSTAndActionSet(UPNPSVC * psvc)
{
    HRESULT hr = S_OK;
    HINF hinf = NULL;
    INFCONTEXT ctx;
    TCHAR   szKey[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256

    UINT unErrorLine;
    hr = HrSetupOpenConfigFile(psvc->szConfigFile, &unErrorLine, &hinf);
    if (S_OK == hr)
    {
        Assert(IsValidHandle(hinf));

        // Process [StateTable] section
        TraceTag(ttidUpdiag, "Reading StateTable for service %s", psvc->szId);

        TCHAR   szVariableLine[LINE_LEN];
        hr = HrSetupFindFirstLine(hinf, TEXT("StateTable"), NULL, &ctx);
        if (S_OK == hr)
        {
            do
            {
                // Retrieve a line from the StateTable section
                hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                if(S_OK == hr)
                {
                    // varify this is a "Variable"
                    szKey[celems(szKey)-1] = L'\0';
                    if (lstrcmpi(szKey, TEXT("Variable")))
                    {
                        TraceTag(ttidUpdiag, "Wrong key in the StateTable section: %s", szKey);
                        continue;
                    }

                    // get the line text
                    hr = HrSetupGetLineText(ctx, szVariableLine, celems(szVariableLine),
                                            NULL);
                    if (S_OK == hr)
                    {
                        // Add variable in this line
                        hr = HrAddVariable(psvc, szVariableLine);
                    }
                }
            }
            while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));


            if (hr == S_FALSE)
            {
                // S_FALSE will terminate the loop successfully, so convert it to S_OK
                // here.
                hr = S_OK;
            }
        }

        // Process [ActionSet] section
        TraceTag(ttidUpdiag, "Reading ActionSet for service %s", psvc->szId);

        TCHAR   szActionName[LINE_LEN];
        hr = HrSetupFindFirstLine(hinf, TEXT("ActionSet"), NULL, &ctx);
        if (S_OK == hr)
        {
            do
            {
                // Retrieve a line from the ActionSet section
                hr = HrSetupGetStringField(ctx,0,szKey,celems(szKey),NULL);
                if(S_OK == hr)
                {
                    // varify this is an "Action"
                    szKey[celems(szKey)-1] = L'\0';
                    if (lstrcmpi(szKey, TEXT("Action")))
                    {
                        TraceTag(ttidUpdiag, "Wrong key in the ActionList section: %s", szKey);
                        continue;
                    }

                    // Query the ActionName
                    hr = HrSetupGetLineText(ctx, szActionName, celems(szActionName),
                                            NULL);
                    if (S_OK == hr)
                    {
                                                // Remove argument list if specified
                                                TCHAR * pChar = _tcschr(szActionName, TEXT('('));
                                                if (pChar)
                                                        *pChar = '\0';

                        // Add operations in this action
                        hr = HrAddAction(psvc, hinf, szActionName);
                    }
                }
            }
            while (S_OK == (hr = HrSetupFindNextLine(ctx, &ctx)));
        }

        if (hr == S_FALSE)
        {
            // S_FALSE will terminate the loop successfully, so convert it to S_OK
            // here.
            hr = S_OK;
        }

        SetupCloseInfFileSafe(hinf);
    }
    else
    {
        TraceTag(ttidUpdiag, "Failed to open file %s, line = %d",
                 psvc->szConfigFile, unErrorLine);
    }

    TraceError("HrLoadSSTAndActionSet", hr);
    return hr;
}

VOID AttachServiceControl(UPNPSVC *psvc)
{
    // set the control ID for this service from the control url
    TCHAR * pChar = _tcschr(psvc->szControlUrl, TEXT('?'));
    if (pChar)
    {
        pChar++;
        lstrcpy(psvc->szControlId, pChar);

        // If it's a demo service then hook up the Demo control
        for (DWORD isvc = 0; isvc < c_cDemoSvc; isvc++)
        {
            if (!_tcsicmp(c_rgSvc[isvc].szServiceId, psvc->szControlId))
            {
                psvc->psvcDemoCtl = &c_rgSvc[isvc];
                TraceTag(ttidUpdiag, "Attached service demo control '%s' to '%s'.",
                         psvc->psvcDemoCtl->szServiceId, psvc->szServiceType);
                break;
            }
        }

        if (isvc == c_cDemoSvc)
        {
            TraceTag(ttidUpdiag, "No demo service control handler found for id '%s'.",
                     psvc->szControlId);
        }
    }
    else
    {
        TraceTag(ttidUpdiag, "Control URL for '%s' doesn't have proper "
                 "format: %s.", psvc->szServiceType, psvc->szControlUrl);
    }
}

void
FreeServiceInfo(UPNP_SERVICE_PRIVATE * pusp)
{
    Assert(pusp);

    CoTaskMemFree(pusp->wszServiceType);
    CoTaskMemFree(pusp->wszServiceId);
    CoTaskMemFree(pusp->wszControlUrl);
    CoTaskMemFree(pusp->wszEventSubUrl);
    CoTaskMemFree(pusp->wszScpd);
}

HRESULT HrReadServices(LPSTR szDescDocUrl, LPCTSTR szDevConfigFile,
                       IUPnPDevice * pud, UPNPDEV *pdev)
{
    HRESULT             hr = S_OK;
    IUPnPDevicePrivate *pudp = NULL;

    hr = pud->QueryInterface(IID_IUPnPDevicePrivate, (LPVOID *)&pudp);
    if (SUCCEEDED(hr))
    {
        ULONG                   cServices;
        UPNP_SERVICE_PRIVATE *  rgusp;
        hr = pudp->GetNumServices(&cServices);
        if (SUCCEEDED(hr))
        {
            Assert(cServices > 0);
        }

        rgusp = (UPNP_SERVICE_PRIVATE *) CoTaskMemAlloc(cServices *
                                                        sizeof(UPNP_SERVICE_PRIVATE));
        if (rgusp)
        {
            ULONG   ulSvcs;

            hr = pudp->GetServiceInfo(0, cServices, rgusp, &ulSvcs);
            if (SUCCEEDED(hr))
            {
                DWORD   isvc;

                pdev->cSvcs = ulSvcs;

                for (isvc = 0; isvc < ulSvcs; isvc++)
                {
                    UPNPSVC *   psvc = new UPNPSVC;

                    ZeroMemory(psvc, sizeof(UPNPSVC));

                    pdev->rgSvcs[isvc] = psvc;

                    WcharToTcharInPlace(psvc->szControlUrl, rgusp[isvc].wszControlUrl);
                    WcharToTcharInPlace(psvc->szEvtUrl, rgusp[isvc].wszEventSubUrl);
                    WcharToTcharInPlace(psvc->szScpdUrl, rgusp[isvc].wszScpd);
                    WcharToTcharInPlace(psvc->szServiceType, rgusp[isvc].wszServiceType);
                    WcharToTcharInPlace(psvc->szId, rgusp[isvc].wszServiceId);

                    // get the service's config file path and name
                    GetServiceConfigFile(pdev, psvc, szDevConfigFile);

                    // initialize the service state table and action list
                    // BUGBUG: allow services with no config file to be created
                    // (e.g. midi player)
                    HRESULT hr2;
                    hr2 = HrLoadSSTAndActionSet(psvc);

                    SSDP_MESSAGE    msg = {0};
                    CHAR            szBuffer[256];
                    CHAR            szUdn[256];
                    CHAR            szType[256];

                    Assert(pdev->szUdn);
                    Assert(psvc->szServiceType);

                    TszToSzBuf(szUdn, pdev->szUdn, celems(szUdn));
                    TszToSzBuf(szType, psvc->szServiceType, celems(szType));

                    msg.iLifeTime = 15000;
                    msg.szLocHeader = szDescDocUrl;

                    wsprintfA(szBuffer, "%s::%s", szUdn, szType);
                    msg.szType = szType;
                    msg.szUSN = szBuffer;

                    psvc->hSvc = RegisterService(&msg, 0);
                    if (psvc->hSvc && psvc->hSvc != INVALID_HANDLE_VALUE)
                    {
                        TraceTag(ttidUpdiag, "Successfully registered "
                                 "service %s.", psvc->szServiceType);
                    }
                    else
                    {
                        TraceTag(ttidUpdiag, "Failed to register %s as "
                                 "a service! Error = %d.",
                                 psvc->szServiceType, GetLastError());
                    }

                    AttachServiceControl(psvc);

                    {
                        CHAR    szEvtUrl[INTERNET_MAX_URL_LENGTH];
                        LPSTR   pszEvtUrl;

                        Assert(psvc->szEvtUrl);
                        pszEvtUrl = SzFromTsz(psvc->szEvtUrl);
                        if (pszEvtUrl)
                        {
                            hr = HrGetRequestUriA(pszEvtUrl,
                                                  INTERNET_MAX_URL_LENGTH,
                                                  szEvtUrl);
                            if (SUCCEEDED(hr))
                            {
                                // convert SST to UPNP_PROPERTY
                                UPNP_PROPERTY * rgProps;
                                RgPropsFromSst(&psvc->sst, &rgProps);

                                if(RegisterUpnpEventSource(szEvtUrl,
                                                           psvc->sst.cRows,
                                                           rgProps))
                                {
                                    TraceTag(ttidUpdiag, "Successfully registered "
                                             "event source %s.", szEvtUrl);
                                }
                                else
                                {
                                    TraceTag(ttidUpdiag, "Failed to register %s as "
                                             "an event source! Error = %d.",
                                             psvc->szEvtUrl, GetLastError());
                                }

                                for (DWORD iRow = 0; iRow < psvc->sst.cRows; iRow++)
                                {
                                    #ifdef _UNICODE
                                        delete(rgProps[iRow].szName);
                                    #else
                                        free(rgProps[iRow].szName);
                                    #endif

                                    delete(rgProps[iRow].szValue);
                                }
                                delete [] rgProps;
                            }
                            delete [] pszEvtUrl;
                        }
                        else
                        {
                            TraceTag(ttidUpdiag, "HrReadServices: SzFromTsz failed");
                        }
                    }

                    // free the strings allocated by GetServiceInfo() above
                    FreeServiceInfo(&(rgusp[isvc]));
                }
            }

            CoTaskMemFree((LPVOID)rgusp);
        }

        ReleaseObj(pudp);
    }

    TraceError("HrReadServices", hr);
    return hr;
}

HRESULT HrReadDevice(BOOL fRoot, LPSTR szDescDocUrl, LPCTSTR szConfigFile,
                     IUPnPDevice * pud)
{
    HRESULT hr;
    BSTR bstr;
    BOOL fPop = FALSE;

    hr = pud->get_FriendlyName(&bstr);
    if (SUCCEEDED(hr))
    {
        UPNPDEV *   pdev;

        TraceTag(ttidUpdiag, "Loading device %S.", bstr);

        pdev = new UPNPDEV;
        ZeroMemory(pdev, sizeof(UPNPDEV));

        WcharToTcharInPlace(pdev->szFriendlyName, bstr);
        SysFreeString(bstr);

        pdev->fRoot = fRoot;

        pud->get_Type(&bstr);
        WcharToTcharInPlace(pdev->szDeviceType, bstr);
        SysFreeString(bstr);

        pud->get_UniqueDeviceName(&bstr);
        WcharToTcharInPlace(pdev->szUdn, bstr);
        SysFreeString(bstr);

        if (FRegisterDeviceAsUpnpService(szDescDocUrl, pdev))
        {
            if (fRoot)
            {
                g_params.rgCd[g_params.cCd++] = pdev;
            }
            else
            {
                PDevCur()->rgDevs[PDevCur()->cDevs++] = pdev;
            }

            PushDev(pdev);
            fPop = TRUE;

            hr = HrReadServices(szDescDocUrl, szConfigFile, pud, pdev);
        }
        else
        {
            CleanupCd(pdev);
        }
    }

    // read in the child devices

    IUPnPDevices * puds;

    puds = NULL;
    hr = pud->get_Children(&puds);
    if (SUCCEEDED(hr))
    {
        Assert(puds);

        IUnknown * punkEnum;

        punkEnum = NULL;
        hr = puds->get__NewEnum(&punkEnum);
        if(SUCCEEDED(hr))
        {
            IEnumUnknown * peu;

            peu = NULL;
            hr = punkEnum->QueryInterface(IID_IEnumUnknown, (void**) &peu);
            if (SUCCEEDED(hr))
            {
                while (S_OK == hr)
                {
                    IUnknown * punkDevice;

                    punkDevice = NULL;
                    hr = peu->Next(1, &punkDevice, NULL);
                    if (S_FALSE == hr)
                    {
                        Assert(!punkDevice);

                        // we're done
                    }
                    else if (SUCCEEDED(hr))
                    {
                        Assert(punkDevice);

                        IUPnPDevice * pudChild;

                        pudChild = NULL;
                        hr = punkDevice->QueryInterface(IID_IUPnPDevice, (void**) &pudChild);
                        if (SUCCEEDED(hr))
                        {
                            Assert(pudChild);

                            hr = HrReadDevice(FALSE, szDescDocUrl, szConfigFile, pudChild);

                            ReleaseObj(pudChild);
                        }

                        ReleaseObj(punkDevice);
                    }
                }

                if (S_FALSE == hr)
                {
                    hr = S_OK;
                }

                ReleaseObj(peu);
            }

            ReleaseObj(punkEnum);
        }

        ReleaseObj(puds);
    }

    if ((!fRoot) && (fPop))
    {
        PopDev();
    }

    TraceError("HrReadDevice", hr);
    return hr;
}

BOOL DoNewCd(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    UPNPDEV *   pdev;
    UPNPSVC *   psvc;
    HRESULT     hr = S_OK;

    if ((cArgs == 3) || (cArgs ==2))
    {
        IUPnPDevice * pud = NULL;
        IUPnPDescriptionDocument * pudd = NULL;

        // This is the file name
        // Load device from description doc
        _tprintf(TEXT("Loading device from doc: %s...\n"), rgArgs[1]);

        hr = CoCreateInstance(CLSID_UPnPDescriptionDocument,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUPnPDescriptionDocument,
                              (LPVOID *)&pudd);
        if (SUCCEEDED(hr))
        {
            Assert(pudd);

            LPWSTR pszUrl;

            pszUrl = WszFromTsz(rgArgs[1]);
            if (pszUrl)
            {
                BSTR bstrUrl;

                bstrUrl = ::SysAllocString(pszUrl);
                if (bstrUrl)
                {
                    hr = pudd->Load(bstrUrl);
                    if (SUCCEEDED(hr))
                    {
                        _tprintf(TEXT("Loaded %s.\n"), rgArgs[1]);

                        hr = pudd->RootDevice(&pud);
                        if (FAILED(hr))
                        {
                            TraceTag(ttidUpdiag, "IUPnPDescriptionDocument::RootDevice (URL=%S) failed, hr=%x", pszUrl, hr);
                            pud = NULL;
                        }
                    }
                    else
                    {
                        TraceTag(ttidUpdiag, "Failed to load %S.  hr=%x", pszUrl, hr);
                        _tprintf(TEXT("Failed to load %s.  hr=%d\n"), rgArgs[1], hr);
                    }

                    ::SysFreeString(bstrUrl);
                }
                else
                {
                    // SysAllocString failed
                    hr = E_OUTOFMEMORY;
                }
                delete [] pszUrl;
            }
            else
            {
                // WszFromTsz failed
                hr = E_OUTOFMEMORY;
            }

            ReleaseObj(pudd);
        }
        else
        {
            _tprintf(TEXT("Could not create description doc.  is upnp.dll registered?\n"));
        }

        if (FAILED(hr))
        {
            Assert(!pud);
            return FALSE;
        }

        Assert(pud);

        // read root device properties into structs

        Assert(rgArgs[1]);
        LPSTR pszDescDocUrl = SzFromTsz(rgArgs[1]);
        if (pszDescDocUrl)
        {
            if (cArgs==2)
            {
                hr = HrReadDevice(TRUE, pszDescDocUrl, TEXT(""), pud);
            }
            else
            {
                hr = HrReadDevice(TRUE, pszDescDocUrl, rgArgs[2], pud);
            }

            delete [] pszDescDocUrl;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        TraceError("DoNewCd", hr);

        ReleaseObj(pud);

        // Can the ISAPI DLL get more than one request at the same time? If
        // so we need to queue control changes to SSTs.


#ifdef NEVER
        UPNP_PROPERTY * rgProps;

        RgPropsFromSst(&psvc->sst, &rgProps);

        if (RegisterUpnpEventSource(psvc->szEvtUrl, psvc->sst.cRows, rgProps))
        {
        }
        else
        {
            TraceTag(ttidUpdiag, "Failed to register %s as an event source! Error = %d.",
                     psvc->szEvtUrl, GetLastError());
        }
#endif

    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoSwitchCd(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_ROOT || g_ctx.ectx == CTX_CD);

    if (cArgs == 2)
    {
        DWORD       idev;
        UPNPDEV *   pdev;

        idev = _tcstoul(rgArgs[1], NULL, 10);

        if (g_ctx.ectx == CTX_CD)
        {
            if (idev &&
                idev <= PDevCur()->cDevs &&
                PDevCur()->rgDevs[idev - 1])
            {
                pdev = PDevCur()->rgDevs[idev - 1];
            }
        }
        else
        {
            if (idev &&
                idev <= g_params.cCd &&
                g_params.rgCd[idev - 1])
            {
                pdev = g_params.rgCd[idev - 1];
            }
        }

        if (pdev)
        {
            PushDev(pdev);
        }
        else
        {
            _tprintf(TEXT("%d is not a valid CD index!\n"), idev);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoDelCd(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_ROOT);

    if (cArgs == 2)
    {
        DWORD       idev;
        UPNPDEV *   pdev;

        idev = _tcstoul(rgArgs[1], NULL, 10);

        pdev = g_params.rgCd[idev - 1];

        if (idev &&
            idev <= g_params.cCd &&
            pdev)
        {
            _tprintf(TEXT("Deleted device %s.\n"), pdev->szFriendlyName);
            // Move last item into gap and decrement the count
            g_params.rgCd[idev - 1] = g_params.rgCd[g_params.cCd - 1];
            CleanupCd(pdev);
            g_params.cCd--;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid CD index!\n"), idev);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoListDevices(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    DWORD   idev;

    if (g_ctx.ectx == CTX_ROOT)
    {
        _tprintf(TEXT("Listing all Controlled Devices\n"));
        _tprintf(TEXT("------------------------------\n"));
        for (idev = 0; idev < g_params.cCd; idev++)
        {
            _tprintf(TEXT("%d) %s\n"), idev + 1, g_params.rgCd[idev]->szFriendlyName);
        }

        _tprintf(TEXT("------------------------------\n\n"));
    }
    else if (g_ctx.ectx == CTX_CD)
    {
        _tprintf(TEXT("Listing all sub-devices of %s\n"), PDevCur()->szFriendlyName);
        _tprintf(TEXT("------------------------------\n"));
        for (idev = 0; idev < PDevCur()->cDevs; idev++)
        {
            _tprintf(TEXT("%d) %s\n"), idev + 1, PDevCur()->rgDevs[idev]->szFriendlyName);
        }

        _tprintf(TEXT("------------------------------\n\n"));
    }

    return FALSE;
}

VOID CleanupCd(UPNPDEV *pcd)
{
    DWORD   i;

    for (i = 0; i < pcd->cDevs; i++)
    {
        CleanupCd(pcd->rgDevs[i]);
    }

    for (i = 0; i < pcd->cSvcs; i++)
    {
        CleanupService(pcd->rgSvcs[i]);
    }

    for (i = 0; i < 3; i++)
    {
        if (pcd->hSvc[i] && (pcd->hSvc[i] != INVALID_HANDLE_VALUE))
        {
            DeregisterService(pcd->hSvc[i], TRUE);
        }
    }

    delete pcd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\service.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S E R V I C E . C P P
//
//  Contents:   Functions dealing with UPnP services.
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "oleauto.h"
#include "ncbase.h"
#include "updiagp.h"
#include "ncinet.h"

BOOL DoListServices(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (g_ctx.ectx == CTX_CD)
    {
        DWORD   isvc;

        _tprintf(TEXT("Listing all Services within %s\n"), PDevCur()->szFriendlyName);
        _tprintf(TEXT("------------------------------\n"));
        for (isvc = 0; isvc < PDevCur()->cSvcs; isvc++)
        {
            _tprintf(TEXT("%d) %s\n"), isvc + 1,
                     PDevCur()->rgSvcs[isvc]->szServiceType);
        }

        _tprintf(TEXT("------------------------------\n\n"));
    }

    return FALSE;
}

BOOL DoSwitchSvc(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (g_ctx.ectx == CTX_CD)
    {
        if (cArgs == 2)
        {
            DWORD   isvc;

            isvc = _tcstoul(rgArgs[1], NULL, 10);
            if (isvc &&
                isvc <= PDevCur()->cSvcs &&
                PDevCur()->rgSvcs[isvc - 1])
            {
                g_ctx.psvcCur = PDevCur()->rgSvcs[isvc - 1];
                g_ctx.ectx = CTX_CD_SVC;
            }
            else
            {
                _tprintf(TEXT("%d is not a valid Service index!\n"), isvc);
            }
        }
        else
        {
            Usage(iCmd);
        }
    }

    return FALSE;
}

VOID CleanupService(UPNPSVC *psvc)
{
    if (psvc->hSvc)
    {
        if (DeregisterService(psvc->hSvc, TRUE))
        {
            TraceTag(ttidUpdiag, "Successfully deregistered %s as a service.",
                     psvc->szServiceType);
        }
        else
        {
            TraceTag(ttidUpdiag, "Error %d deregistering %s as a service.",
                     GetLastError(), psvc->szServiceType);
        }

        CHAR    szEvtUrl[INTERNET_MAX_URL_LENGTH];
        HRESULT hr;
        LPSTR pszEvtUrl = SzFromTsz(psvc->szEvtUrl);
        if (pszEvtUrl)
        {
            hr = HrGetRequestUriA(pszEvtUrl,
                                  INTERNET_MAX_URL_LENGTH,
                                  szEvtUrl);
            if (SUCCEEDED(hr))
            {
                if (DeregisterUpnpEventSource(szEvtUrl))
                {
                    TraceTag(ttidUpdiag, "Successfully deregistered %s as an event source.",
                             psvc->szEvtUrl);
                }
                else
                {
                    TraceTag(ttidUpdiag, "Error %d deregistering %s as an event source.\n",
                             GetLastError(), psvc->szEvtUrl);
                }
            }
            TraceError("CleanupService: HrGetRequestUri", hr);

            delete [] pszEvtUrl;
        }
        else
        {
            TraceTag(ttidUpdiag, "CleanupService: TszToSz failed");
        }
    }

    delete psvc;
}

// print current service state table values
BOOL DoPrintSST(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    HRESULT hr;

    Assert(g_ctx.ectx == CTX_CD_SVC);

    UPNPSVC *   psvc = g_ctx.psvcCur;

    _tprintf(TEXT("Service State Table: \n"));
    _tprintf(TEXT("----------------------------------------------------\n"));

    for (DWORD iRow = 0; iRow < psvc->sst.cRows; iRow++)
    {
        SST_ROW * pRow = &psvc->sst.rgRows[iRow];

        VARIANT     varDest;

        VariantInit(&varDest);
        hr = VariantChangeType(&varDest, &(pRow->varValue), 0, VT_BSTR);
        if (SUCCEEDED(hr))
        {
            _tprintf(TEXT("%d) %s = %S "), iRow + 1,
                     psvc->sst.rgRows[iRow].szPropName, varDest.bstrVal);

            VariantClear(&varDest);

            if (*pRow->mszAllowedValueList)
            {
                _tprintf(TEXT(", Allowed Value List: "));
                TCHAR * pNextString = pRow->mszAllowedValueList; 
                while (*pNextString)
                {
                    _tprintf(TEXT("%s"), pNextString);

                    pNextString += lstrlen(pNextString);
                    pNextString ++;

                    if (*pNextString)
                        _tprintf(TEXT(","));
                } 
            }
            else if (*pRow->szMin)
            {
                _tprintf(TEXT(", Min: %s, Max: %s, Step: %s"),
                         pRow->szMin, pRow->szMax, pRow->szStep);
            }
        }

        _tprintf(TEXT("\n"));
    }

    _tprintf(TEXT("----------------------------------------------------\n\n"));

    return FALSE;
}

// print current service state table values
BOOL DoPrintActionSet(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_CD_SVC);
    UPNPSVC *   psvc = g_ctx.psvcCur;

    _tprintf(TEXT("Service Action Set: \n"));
    _tprintf(TEXT("----------------------------------------------------\n"));

    for (DWORD iAct = 0; iAct < psvc->action_set.cActions; iAct++)
    {
        _tprintf(TEXT("%d) %s:\n"), iAct+1,
                 psvc->action_set.rgActions[iAct].szActionName);

        for (DWORD iOpt =0; iOpt<psvc->action_set.rgActions[iAct].cOperations; iOpt++)
        {
            OPERATION_DATA * pOptData = &psvc->action_set.rgActions[iAct].rgOperations[iOpt];

            _tprintf(TEXT("Name = %s, Variable = %s"), pOptData->szOpName, pOptData->szVariableName);

            TCHAR * szConst = pOptData->mszConstantList;
            if (*szConst)
            {
                _tprintf(TEXT(", Constants = "));
                while (*szConst)
                {
                    _tprintf(TEXT("%s"), szConst); 
                    szConst += lstrlen(szConst);
                    szConst++;

                    if (*szConst)
                        _tprintf(TEXT(", "));     
                }
            }
            _tprintf(TEXT("\n"));
        }
        _tprintf(TEXT("\n"));
    }

    _tprintf(TEXT("----------------------------------------------------\n\n"));

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\ucp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U C P . C P P
//
//  Contents:   Functions dealing with UPnP User Control Points
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncbase.h"
#include "updiagp.h"

BOOL DoNewUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_ROOT);

    if (cArgs == 2)
    {
        if (g_params.cUcp < MAX_UCP)
        {
            UPNPUCP *   pucp = new UPNPUCP;

            ZeroMemory(pucp, sizeof(UPNPUCP));
            lstrcpy(pucp->szName, rgArgs[1]);

            g_params.rgUcp[g_params.cUcp++] = pucp;
            g_ctx.pucpCur = pucp;
            g_ctx.ectx = CTX_UCP;
        }
        else
        {
            _tprintf(TEXT("Exceeded number of UCPs allowed!\n\n"));
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoDelUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_ROOT);

    if (cArgs == 2)
    {
        DWORD       iucp;
        UPNPUCP *   pucp;

        iucp = _tcstoul(rgArgs[1], NULL, 10);

        pucp = g_params.rgUcp[iucp - 1];

        if (iucp &&
            iucp <= g_params.cUcp &&
            pucp)
        {
            _tprintf(TEXT("Deleted control point %s.\n"), pucp->szName);

            // Move last item into gap and decrement the count
            g_params.rgUcp[iucp - 1] = g_params.rgUcp[g_params.cUcp - 1];
            CleanupUcp(pucp);
            g_params.cUcp--;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid UCP index!\n"), iucp);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoSwitchUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_ROOT);

    if (cArgs == 2)
    {
        DWORD   iucp;

        iucp = _tcstoul(rgArgs[1], NULL, 10);
        if (iucp &&
            iucp <= g_params.cUcp &&
            g_params.rgUcp[iucp - 1])
        {
            g_ctx.pucpCur = g_params.rgUcp[iucp - 1];
            g_ctx.ectx = CTX_UCP;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid UCP index!\n"), iucp);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

VOID CleanupUcp(UPNPUCP *pucp)
{
    DWORD   i;

    for (i = 0; i < pucp->cResults; i++)
    {
        CleanupResult(pucp->rgResults[i]);
    }

    delete pucp;
}

BOOL DoListUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (g_ctx.ectx == CTX_ROOT)
    {
        DWORD   iucp;

        _tprintf(TEXT("Listing all Control Points\n"));
        _tprintf(TEXT("------------------------------\n"));
        for (iucp = 0; iucp < g_params.cUcp; iucp++)
        {
            _tprintf(TEXT("%d) %s\n"), iucp + 1, g_params.rgUcp[iucp]->szName);
        }

        _tprintf(TEXT("------------------------------\n\n"));
    }

    return FALSE;
}

BOOL DoSubscribe(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    HANDLE  hSubs;

    Assert(g_ctx.ectx & (CTX_UCP | CTX_DEVICE));

    if (g_ctx.pucpCur->cResults >= MAX_RESULT)
    {
        _tprintf(TEXT("Exceeded maximum number of subscriptions!\n"));
        return FALSE;
    }

    if (cArgs == 2)
    {
        UPNPRESULT *  psubs;

        psubs = new UPNPRESULT;
        ZeroMemory(psubs, sizeof(UPNPRESULT));
        lstrcpy(psubs->szType, rgArgs[1]);
        psubs->resType = RES_SUBS;

        if (g_ctx.ectx == CTX_UCP)
        {
            Assert(rgArgs[1]);
            LPSTR pszType = SzFromTsz(rgArgs[1]);
            if (pszType)
            {
                psubs->hResult = RegisterNotification(NOTIFY_PROP_CHANGE, NULL,
                                                      pszType, NotifyCallback,
                                                      (LPVOID) psubs);
                if (psubs->hResult && psubs->hResult != INVALID_HANDLE_VALUE)
                {
                    g_ctx.pucpCur->rgResults[g_ctx.pucpCur->cResults++] = psubs;
                    _tprintf(TEXT("Subscribed to event URL : %s\n"), rgArgs[1]);
                }
                else
                {
                    _tprintf(TEXT("RegisterNotification failed with error %d.\n"),
                             GetLastError());
                    delete psubs;
                }

                delete [] pszType;
            }
            else
            {
                _tprintf(TEXT("DoSubscribe: SzFromTsz failed\n"));
            }
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoUnsubscribe(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    Assert(g_ctx.ectx == CTX_UCP);

    if (cArgs == 2)
    {
        DWORD   isrch;

        isrch = _tcstoul(rgArgs[1], NULL, 10);
        if (isrch <= g_ctx.pucpCur->cResults &&
            g_ctx.pucpCur->rgResults[isrch - 1])
        {
            UPNPRESULT *  psubs = g_ctx.pucpCur->rgResults[isrch - 1];

            _tprintf(TEXT("Deleted subscription %s.\n"),
                     psubs->szType);
            // Move last item into gap and decrement the count
            g_ctx.pucpCur->rgResults[isrch - 1] = g_ctx.pucpCur->rgResults[g_ctx.pucpCur->cResults - 1];
            CleanupResult(psubs);
            g_ctx.pucpCur->cResults--;
        }
        else
        {
            _tprintf(TEXT("%d is not a valid subscription index!\n"), isrch);
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\control.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N T R O L . C P P
//
//  Contents:   Functions dealing with UPnP service control
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncbase.h"
#include "oleauto.h"
#include "updiagp.h"
#include "media.h"
#include "ncinet.h"
#include "util.h"

extern const STANDARD_OPERATION_LIST c_Ops;

//
// Global service control structure for demo services
//
extern const DEMO_SERVICE_CTL c_rgSvc[] =
{
    {
        TEXT("app"),
        6,
        {
            {   TEXT("VolumeUp"),       Val_VolumeUp,       Do_VolumeUp     },
            {   TEXT("VolumeDown"),     Val_VolumeDown,     Do_VolumeDown   },
            {   TEXT("SetVolume"),      Val_SetVolume,      Do_SetVolume    },
            {   TEXT("Mute"),           Val_Mute,           Do_Mute         },
            {   TEXT("Power"),          Val_Power,          Do_Power        },
            {   TEXT("LoadFile"),       Val_LoadFile,       Do_LoadFile     },
        },
    },
    {
        TEXT("xport"),
        4,
        {
            {   TEXT("Play"),           Val_Play,           Do_Play         },
            {   TEXT("Stop"),           Val_Stop,           Do_Stop         },
            {   TEXT("Pause"),          Val_Pause,          Do_Pause        },
            {   TEXT("SetPos"),         Val_SetPos,         Do_SetPos       },
        }
    },
    {
        TEXT("clock"),
        1,
        {
            {   TEXT("SetDateTime"),        Val_SetTime,        Do_SetTime      },
        }
    },
};

extern const DWORD c_cDemoSvc = celems(c_rgSvc);

ACTION *PActFromSz(ACTION_SET * pActionSet, LPCTSTR szAction)
{
    for (DWORD iAction = 0; iAction < pActionSet->cActions; iAction++)
    {
        if (!_tcsicmp(pActionSet->rgActions[iAction].szActionName, szAction))
            return &pActionSet->rgActions[iAction];
    }

    return NULL;
}


const DEMO_ACTION *PDemoActFromSz(const DEMO_SERVICE_CTL *psvc, LPCTSTR szAction)
{
    DWORD   iAction;

    Assert(psvc);

    for (iAction = 0; iAction < psvc->cActions; iAction++)
    {
        if (!_tcsicmp(psvc->rgActions[iAction].szAction, szAction))
            return &psvc->rgActions[iAction];
    }

    return NULL;
}

UPNPSVC *PSvcFromIdDev(UPNPDEV *pdev, LPCTSTR szId)
{
    DWORD       isvc;
    DWORD       idev;
    UPNPSVC *   psvc;

    // First look thru all local services
    //
    for (isvc = 0; isvc < pdev->cSvcs; isvc++)
    {
        psvc = pdev->rgSvcs[isvc];

        if (!_tcsicmp(psvc->szControlId, szId))
        {
            return psvc;
        }
    }

    // If not found there, recurse for each sub-device
    //
    for (idev = 0; idev < pdev->cDevs; idev++)
    {
        psvc = PSvcFromIdDev(pdev->rgDevs[idev], szId);
        if (psvc)
        {
            return psvc;
        }
    }

    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   PSvcFromId
//
//  Purpose:    Given a service identifier, return the service for which a
//              valid control handler exists
//
//  Arguments:
//      szId [in]   Service identifier
//
//  Returns:    Matching service
//
//  Author:     danielwe   6 Nov 1999
//
//  Notes:
//
UPNPSVC *PSvcFromId(LPCTSTR szId)
{
    DWORD   idev;

    // Loop thru all devices and all services within those devices looking
    // for a service that implements the control handler identified by szId
    //
    for (idev = 0; idev < g_params.cCd; idev++)
    {
        UPNPSVC *   psvc;

        psvc = PSvcFromIdDev(g_params.rgCd[idev], szId);
        if (psvc)
        {
            return psvc;
        }
    }

    TraceTag(ttidUpdiag, "Can't find a service matching id: '%s'.", szId);

    return NULL;
}

// BUGBUG
/*
DWORD ValidateActionArguments(ACTION * pAction,
                              g_pdata->cArgs,
                              (ARG *) &g_pdata->rgArgs)
{
    return 1;
}
*/

const STANDARD_OPERATION  * PStdOpFromSz(LPTSTR szOpName)
{
    const STANDARD_OPERATION * pStdOperation = NULL;
    for (DWORD iOps = 0; iOps < c_Ops.cOperations; iOps++)
    {
        if (!_tcsicmp(c_Ops.rgOperations[iOps].szOperation, szOpName))
        {
            pStdOperation = &c_Ops.rgOperations[iOps];
            break;
        }
    }

    return pStdOperation;
}

DWORD dwArgsFromOpName(LPTSTR szOpName)
{
    DWORD dwArgs=0;
    const STANDARD_OPERATION * pStdOperation = PStdOpFromSz(szOpName);
    if (pStdOperation)
    {
        dwArgs = pStdOperation->nArguments;
    }

    return dwArgs;
}

DWORD DwPerformOperation(UPNPSVC * psvc, OPERATION_DATA * pOpData,
                           DWORD cArgs, ARG *rgArgs)
{
    const STANDARD_OPERATION  * pStdOperation = PStdOpFromSz(pOpData->szOpName);
    if(pStdOperation)
    {
        return pStdOperation->pfnOperation(psvc, pOpData, cArgs, rgArgs);
    }
    else
    {
        TraceTag(ttidUpdiag, "Operation %s is not supported by the emulated device.",
                 pOpData->szOpName);

        return 1;
    }
}

// BUGBUG: separate the demo stuff from the generic stuff
VOID PerformActionForDemoService(UPNPSVC *  psvc);

//+---------------------------------------------------------------------------
//
//  Function:   ProcessControlRequest
//
//  Purpose:    Main control request handler
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   6 Nov 1999
//
//              tongl       11/20/99
//              added the state table change and moved the functionality
//              to play midi files to PerformActionForDemoService
//
//  Notes:      This ISAPICTL extension will signal an event telling us
//              to process a request that it has received. This function
//              determines which UPnP service the request was meant for,
//              and if a control handler for that service exists,
//              it calls the appropriate code to process the request
//              to make service state table changes and notify user
//              control points
//
//
VOID ProcessControlRequest()
{
    if (WAIT_OBJECT_0 == WaitForSingleObject(g_hMutex, INFINITE))
    {
        DWORD       dwReturn = 0;
        UPNPSVC *   psvc;
        ACTION  *   pAction;
        LPTSTR      pszEventSource;

        pszEventSource = TszFromSz(g_pdata->szEventSource);
        if (pszEventSource)
        {
            TraceTag(ttidUpdiag, "Processing a control request for %s!",
                     g_pdata->szEventSource);

            psvc = PSvcFromId(pszEventSource);
            if (psvc)
            {
                LPTSTR pszAction;

                // Validate arguments and set action return value
                pszAction = TszFromSz(g_pdata->szAction);
                if (pszAction)
                {
                    pAction = PActFromSz(&(psvc->action_set), pszAction);
                    if (pAction)
                    {
                        /*
                        // NYI
                        dwReturn = ValidateActionArguments(pAction,
                                                           g_pdata->cArgs,
                                                           (ARG *) &g_pdata->rgArgs);
                        */
                        dwReturn = 1;
                        if (!dwReturn)
                        {
                            TraceTag(ttidUpdiag, "Failed to validate action '%s'.",
                                     pAction->szActionName);
                        }
                    }

                    delete [] pszAction;
                }
                else
                {
                    TraceTag(ttidUpdiag, "ProcessControlRequest: TszFromSz failed");
                }
            }

            g_pdata->dwReturn = dwReturn;

            TraceTag(ttidUpdiag, "Signalling event for ISAPICTL to continue...");
            // Release the ISAPI DLL so it can return to the UCP
            SetEvent(g_hEventRet);

            if (dwReturn)
            {
                HRESULT hr;
                DWORD   dwActionResult;

                AssertSz(pAction, "Good return but no action?");

                // Now perform the action
                TraceTag(ttidUpdiag, "Performing action %s.", pAction->szActionName);

                OPERATION_DATA * pOperation;
                DWORD       iArgs =0;
                DWORD       cArgs;
                ARG         rgArgs[MAX_PROP_CHANGES];

                for (DWORD iOp=0; iOp<pAction->cOperations; iOp++)
                {
                    pOperation = &pAction->rgOperations[iOp];

                    // get the arguments for this operation
                    cArgs = dwArgsFromOpName(pOperation->szOpName);

                    Assert(iArgs+cArgs <= g_pdata->cArgs);
                    for(DWORD i=0; i<cArgs; i++)
                    {
                        lstrcpy(rgArgs[i].szValue, g_pdata->rgArgs[iArgs].szValue);
                        iArgs++;
                    }

                    // perform the operation
                    dwActionResult = DwPerformOperation(psvc, pOperation, cArgs, rgArgs);
                    if (dwActionResult)
                        break;
                }

                if (!dwActionResult)
                {
                    TraceTag(ttidUpdiag, "Successfully completed action %s.",
                             pAction->szActionName);
                }
                else
                {
                    TraceTag(ttidUpdiag, "Failed to complete action %s.",
                             pAction->szActionName);
                }
            }
            else
            {
                TraceTag(ttidUpdiag, "Did not perform action for %s.",
                         g_pdata->szEventSource);
            }

            if (psvc && psvc->psvcDemoCtl)
            {
                PerformActionForDemoService(psvc);
            }

            ReleaseMutex(g_hMutex);
        }

        delete [] pszEventSource;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   PerformActionForDemoService
//
//  Purpose:    Perform the action on the demo services (midi-player)
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   6 Nov 1999
//
//  Notes:      For the two demo services, this function calls the
//              appropriate code to process the request.
//
VOID PerformActionForDemoService(UPNPSVC *  psvc)
{
    const DEMO_ACTION *     pAct;
    DWORD                   dwReturn = 0;

     // Validate arguments and set action return value
    LPTSTR pszAction = TszFromSz(g_pdata->szAction);
    if (pszAction)
    {
        pAct = PDemoActFromSz(psvc->psvcDemoCtl, pszAction);
        if (pAct)
        {
            dwReturn = pAct->pfnValidate(g_pdata->cArgs,
                                         (ARG *) &g_pdata->rgArgs);
            if (!dwReturn)
            {
                TraceTag(ttidUpdiag, "Failed to validate demo action '%s'.",
                         pAct->szAction);
            }
        }

        delete [] pszAction;
    }
    else
    {
        TraceTag(ttidUpdiag, "PerformActionForDemoService: TszFromSz");
    }

    g_pdata->dwReturn = dwReturn;

    TraceTag(ttidUpdiag, "Signalling event for ISAPICTL to continue...");
    // Release the ISAPI DLL so it can return to the UCP
    SetEvent(g_hEventRet);

    if (dwReturn)
    {
        DWORD   dwActionResult;

        AssertSz(pAct, "Good return but no action?");

        // Now perform the action

        TraceTag(ttidUpdiag, "Performing action %s.", pAct->szAction);

        dwActionResult = pAct->pfnAction(g_pdata->cArgs,
                                         (ARG *) &g_pdata->rgArgs);
        if (dwActionResult)
        {
            TraceTag(ttidUpdiag, "Successfully completed action %s.",
                     pAct->szAction);
        }
        else
        {
            TraceTag(ttidUpdiag, "Failed to complete action %s. Result = %d.",
                     pAct->szAction, dwActionResult);
        }
    }
    else
    {
        TraceTag(ttidUpdiag, "Did not perform action for %s.",
                 g_pdata->szEventSource);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   RequestHandlerThreadStart
//
//  Purpose:    Start routine for the request handler thread
//
//  Arguments:
//      pvParam []
//
//  Returns:    Always 0
//
//  Author:     danielwe   6 Nov 1999
//
//  Notes:
//
DWORD WINAPI RequestHandlerThreadStart(LPVOID pvParam)
{
    HRESULT hr;

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        TraceTag(ttidUpdiag, "COM initialized.");
        while (TRUE)
        {
            TraceTag(ttidUpdiag, "Awaiting control request...");
            if (WAIT_OBJECT_0 == WaitForSingleObject(g_hEvent, INFINITE))
            {
                TraceTag(ttidUpdiag, "Event was signalled...");
                // When the event is signalled, a control request is ready
                ProcessControlRequest();
            }
        }

        // Right now this will never be called because this thread never
        // exits, but eventually we may want it to.
        //
        CoUninitialize();
    }
    else
    {
        TraceError("RequestHandlerThreadStart - CoInitializeEx", hr);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\media.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M E D I A . H
//
//  Contents:   Definitions of media player device functions and structs
//
//  Notes:
//
//  Author:     danielwe   6 Nov 1999
//
//----------------------------------------------------------------------------

#ifndef _MEDIA_H
#define _MEDIA_H

#include <streams.h>
#include "updiag.h"

enum State
{
    TurnedOff,
    Uninitialized,
    Stopped,
    Paused,
    Playing
};

struct Media
{
    State           state;
    IGraphBuilder * pGraph;
    LONG            lOldVol;
    BOOL            fIsMuted;
};

BOOL InitMedia(VOID);
VOID OpenMediaFile(LPCTSTR szFile);

BOOL CanPlay(VOID);
BOOL CanSetVolume(VOID);
BOOL CanStop(VOID);
BOOL CanPause(VOID);
BOOL IsInitialized(VOID);
VOID DeleteContents(VOID);

// Event handlers

VOID OnMediaPlay(VOID);
VOID OnMediaPause(VOID);
VOID OnMediaStop(VOID);
VOID OnVolumeUpDown(BOOL fUp);
VOID OnSetVolume(DWORD dwVol);
VOID OnMediaMute(VOID);

// Control handlers
DWORD Val_VolumeUp(DWORD cArgs, ARG *rgArgs);
DWORD Do_VolumeUp(DWORD cArgs, ARG *rgArgs);

DWORD Val_VolumeDown(DWORD cArgs, ARG *rgArgs);
DWORD Do_VolumeDown(DWORD cArgs, ARG *rgArgs);

DWORD Val_SetVolume(DWORD cArgs, ARG *rgArgs);
DWORD Do_SetVolume(DWORD cArgs, ARG *rgArgs);

DWORD Val_Mute(DWORD cArgs, ARG *rgArgs);
DWORD Do_Mute(DWORD cArgs, ARG *rgArgs);

DWORD Val_Power(DWORD cArgs, ARG *rgArgs);
DWORD Do_Power(DWORD cArgs, ARG *rgArgs);

DWORD Val_LoadFile(DWORD cArgs, ARG *rgArgs);
DWORD Do_LoadFile(DWORD cArgs, ARG *rgArgs);

DWORD Val_Play(DWORD cArgs, ARG *rgArgs);
DWORD Do_Play(DWORD cArgs, ARG *rgArgs);

DWORD Val_Stop(DWORD cArgs, ARG *rgArgs);
DWORD Do_Stop(DWORD cArgs, ARG *rgArgs);

DWORD Val_Pause(DWORD cArgs, ARG *rgArgs);
DWORD Do_Pause(DWORD cArgs, ARG *rgArgs);

DWORD Val_SetPos(DWORD cArgs, ARG *rgArgs);
DWORD Do_SetPos(DWORD cArgs, ARG *rgArgs);

DWORD Val_Test(DWORD cArgs, ARG *rgArgs);
DWORD Do_Test(DWORD cArgs, ARG *rgArgs);

DWORD Val_SetTime(DWORD cArgs, ARG *rgArgs);
DWORD Do_SetTime(DWORD cArgs, ARG *rgArgs);

extern Media media;

#endif //!_MEDIA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\updiag.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P D I A G . C P P
//
//  Contents:   UPnP Diagnostic App and CD and UCP emulator
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncbase.h"
#include "updiagp.h"
#include "ncinet.h"

UPDIAG_PARAMS   g_params = {0};
UPDIAG_CONTEXT  g_ctx;
SHARED_DATA *   g_pdata = NULL;
HANDLE          g_hMapFile = NULL;
HANDLE          g_hEvent = NULL;
HANDLE          g_hEventRet = NULL;
HANDLE          g_hEventCleanup = NULL;
HANDLE          g_hMutex = NULL;
HANDLE          g_hThreadTime = NULL;
FILE *          g_pInputFile = NULL;

static const COMMAND c_rgCommands[] =
{
    // Generic commands (some depend on context)
    //
    {TEXT("?"),      TEXT("Help!"),                                 CTX_ANY,                TRUE,       DoHelp,             TEXT("[command]")},
    {TEXT("\\"),     TEXT("Go to Root context"),                    CTX_ANY,                TRUE,       DoRoot,             TEXT("")},
    {TEXT(".."),     TEXT("Go To Previous Context"),                CTX_ANY & ~CTX_ROOT,    TRUE,       DoBack,             TEXT("")},
    {TEXT("exit"),   TEXT("Exit UPDIAG"),                           CTX_ANY,                TRUE,       DoExit,             TEXT("")},
    {TEXT("info"),   TEXT("List Information"),                      CTX_ANY,                TRUE,       DoInfo,             TEXT("")},
    {TEXT("script"), TEXT("Run Script"),                            CTX_ANY,                TRUE,       DoScript,           TEXT("<file name>")},

    // Automation specific commands (wont appear in menus)
    //
    {TEXT("sleep"),  TEXT("Sleep for time period"),                 CTX_AUTO,               TRUE,       DoSleep,            TEXT("<seconds>")},
    {TEXT("prompt"), TEXT("Prompt (for user input)"),               CTX_AUTO,               TRUE,       DoPrompt,           TEXT("")},

    // Listing commands
    //
    {TEXT("ls"),     TEXT("List Services"),                         CTX_CD | CTX_DEVICE,    TRUE,       DoListServices,     TEXT("")},
    {TEXT("ld"),     TEXT("List Devices"),                          CTX_ROOT | CTX_DEVICE | CTX_CD,  TRUE,       DoListDevices,      TEXT("")},
    {TEXT("lucp"),   TEXT("List Control Points"),                   CTX_ROOT,               TRUE,       DoListUcp,          TEXT("")},
    {TEXT("les"),    TEXT("List Event Sources"),                    CTX_CD,                 FALSE,      DoListEventSources, TEXT("")},
    {TEXT("lsubs"),  TEXT("List Subscriptions"),                    CTX_UCP,                TRUE,       DoListUpnpResults,      TEXT("")},
    {TEXT("lsres"),  TEXT("List Results"),                          CTX_RESULT,             TRUE,       DoListUpnpResultMsgs,   TEXT("")},
    {TEXT("lsrch"),  TEXT("List Searches"),                         CTX_UCP,                TRUE,       DoListUpnpResults,  TEXT("")},

    // Context switching commands
    //
    {TEXT("ucp"),    TEXT("Switch To UCP Context"),                 CTX_ROOT,               TRUE,       DoSwitchUcp,        TEXT("<ucp #>")},
    {TEXT("srch"),   TEXT("Switch To Search Context"),              CTX_UCP,                TRUE,       DoSwitchResult,     TEXT("<search #>")},
    {TEXT("dev"),    TEXT("Switch To Device Context"),              CTX_DEVICE,             TRUE,       DoNothing,          TEXT("")},
    {TEXT("svc"),    TEXT("Switch To Service Context"),             CTX_DEVICE | CTX_CD,    TRUE,       DoSwitchSvc,        TEXT("<service #>")},
    {TEXT("es"),     TEXT("Switch To Event Source Context"),        CTX_CD,                 FALSE,      DoSwitchEs,         TEXT("<event source #>")},
    {TEXT("gsubs"),  TEXT("Switch To Subscription Context"),        CTX_UCP,                TRUE,       DoSwitchResult,     TEXT("<subscription #>")},

    // UCP commands
    //
    {TEXT("newucp"), TEXT("Create New Control Point"),              CTX_ROOT,               TRUE,       DoNewUcp,           TEXT("<ucp name>")},
    {TEXT("delucp"), TEXT("Delete Control Point"),                  CTX_ROOT,               TRUE,       DoDelUcp,           TEXT("<ucp #>")},

    // These test RegisterNotification()
    {TEXT("alive"),  TEXT("Register For Alive Notification"),       CTX_UCP,                TRUE,       DoAlive,            TEXT("<notif type>")},
    {TEXT("subs"),   TEXT("Subscribe To Service"),                  CTX_UCP,                TRUE,       DoSubscribe,        TEXT("<event source URL>")},

    // These test DeregisterNotification()
    {TEXT("unsubs"), TEXT("Unsubscribe To Service"),                CTX_UCP,                TRUE,       DoDelResult,        TEXT("<subscription #>")},
    {TEXT("unalive"),TEXT("Stop Listening For Alive"),              CTX_UCP,                TRUE,       DoNothing,          TEXT("")},

    // These test FindServicesCallback()
    {TEXT("newf"),   TEXT("Create New Search"),                     CTX_UCP,                TRUE,       DoFindServices,     TEXT("<search type>")},
    {TEXT("delf"),   TEXT("Delete Search"),                         CTX_UCP,                TRUE,       DoDelResult,        TEXT("<search #>")},

    // These test FindServices()
    // --- nothing yet ---
    //

    // These test UPnP COM interfaces
    {TEXT("doc"),    TEXT("List Description Document"),             CTX_DEVICE,             TRUE,       DoNothing,          TEXT("")},
    {TEXT("cmd"),    TEXT("Send Command To Service"),               CTX_UCP_SVC,            TRUE,       DoNothing,          TEXT("")},

    // CD commands
    //

    // These test RegisterService() and RegisterEventSource()
    {TEXT("newcd"),  TEXT("Create New CD"),                         CTX_ROOT,               FALSE,      DoNewCd,            TEXT("<URL to description doc>, <Device INF file>")},
    {TEXT("cd"),     TEXT("Switch To CD Context"),                  CTX_ROOT | CTX_CD,      FALSE,      DoSwitchCd,         TEXT("<cd #>")},
    {TEXT("delcd"),  TEXT("Delete CD"),                             CTX_ROOT,               FALSE,      DoDelCd,            TEXT("<cd #>")},

    // This tests SubmitUpnpPropertyEvent()
    {TEXT("evt"),    TEXT("Submit An Event"),                       CTX_EVTSRC,             FALSE,      DoSubmitEvent,      TEXT("{property#:newValue} [...]")},
    {TEXT("props"),  TEXT("List Event Source Properties"),          CTX_EVTSRC,             FALSE,      DoListProps,        TEXT("")},

    // Dump StateTable and action set of a service
    {TEXT("sst"),       TEXT("Print the service state table"),      CTX_CD_SVC,             FALSE,      DoPrintSST,         TEXT("")},
    {TEXT("actions"),   TEXT("Print the service action set"),       CTX_CD_SVC,             FALSE,      DoPrintActionSet,   TEXT("")},
};

static const DWORD c_cCmd = celems(c_rgCommands);

BOOL FIsMillenium()
{
    OSVERSIONINFO   osvi = {0};

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&osvi);

    return (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}

VOID Usage(DWORD iCmd)
{
    _tprintf(TEXT("%s - %s\nUsage: \n    %s %s\n\n"), c_rgCommands[iCmd].szCommand,
            c_rgCommands[iCmd].szCmdDesc, c_rgCommands[iCmd].szCommand,
            c_rgCommands[iCmd].szUsage);
}

BOOL FCmdFromName(LPCTSTR szName, DWORD *piCmd)
{
    DWORD   iCmd;

    *piCmd = 0xFFFFFFFF;

    for (iCmd = 0; iCmd < c_cCmd; iCmd++)
    {
        if (!_tcsicmp(szName, c_rgCommands[iCmd].szCommand))
        {
            *piCmd = iCmd;
            return TRUE;
        }
    }

    return FALSE;
}

BOOL DoHelp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    LPTSTR  szName;

    if (cArgs == 2)
    {
        if (FCmdFromName(rgArgs[1], &iCmd))
        {
            Usage(iCmd);
            return FALSE;
        }
    }

    _tprintf(TEXT("Available commands:\n"));
    _tprintf(TEXT("-------------------\n"));
    for (iCmd = 0; iCmd < c_cCmd; iCmd++)
    {
        if ((c_rgCommands[iCmd].dwCtx & g_ctx.ectx) &&
            (((FIsMillenium() && c_rgCommands[iCmd].fValidOnMillen)) ||
               (!FIsMillenium())))

        {
            _tprintf(TEXT("%-7s - %s\n"), c_rgCommands[iCmd].szCommand,
                    c_rgCommands[iCmd].szCmdDesc);
        }
    }

    _tprintf(TEXT("-------------------\n\n"));

    return FALSE;
}

BOOL DoInfo(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (cArgs == 1)
    {
        switch (g_ctx.ectx)
        {
            case CTX_EVTSRC:
                DoEvtSrcInfo();
                break;
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}


BOOL DoSleep(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (cArgs == 2)
    {
        DWORD   iSeconds = _tcstoul(rgArgs[1], NULL, 10);

        _tprintf(TEXT("Sleeping for %d second(s).\n\n"), iSeconds);
        Sleep(iSeconds * 1000);
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}

BOOL DoPrompt(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    TCHAR szBuf[10];    // Size doesn't matter (uh, not here anyway)

    _tprintf(TEXT("Press [Enter] to continue\n"));

    _fgetts(szBuf, sizeof(szBuf), stdin);

    return FALSE;
}

BOOL DoScript(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (cArgs == 2)
    {
        if (g_pInputFile)
        {
            _tprintf(TEXT("Error. Already in script. Go away.\n\n"));
        }
        else
        {
            g_pInputFile = _tfopen(rgArgs[1], TEXT("r"));
            if (!g_pInputFile)
            {
                _tprintf(TEXT("Failed to open input file. Reverting to user-input.\n\n"));
            }
            else
            {
                _tprintf(TEXT("Running in scripted mode with file: %S\n\n"), rgArgs[1]);
            }
        }
    }
    else
    {
        Usage(iCmd);
    }

    return FALSE;
}


BOOL DoNothing(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    _tprintf(TEXT("Not yet implemented.\n\n"));
    return FALSE;
}

BOOL DoRoot(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    g_ctx.ectx = CTX_ROOT;
    g_ctx.idevStackIndex = 0;

    return FALSE;
}

BOOL DoBack(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    switch (g_ctx.ectx)
    {
        case CTX_UCP:
            g_ctx.ectx = CTX_ROOT;
            break;

        case CTX_CD:
            PopDev();
            if (!g_ctx.idevStackIndex)
            {
                // Go back to root context if no more devs on stack
                g_ctx.ectx = CTX_ROOT;
            }
            break;

        case CTX_RESULT:
            g_ctx.ectx = CTX_UCP;
            break;

        case CTX_CD_SVC:
        case CTX_EVTSRC:
            g_ctx.ectx = CTX_CD;
            break;
    }
    return FALSE;
}

VOID Cleanup()
{
    DWORD   i;

    SetEvent(g_hEventCleanup);
    TraceTag(ttidUpdiag, "Waiting for time thread to exit");
    WaitForSingleObject(g_hThreadTime, INFINITE);

    for (i = 0; i < g_params.cCd; i++)
    {
        CleanupCd(g_params.rgCd[i]);
    }

    for (i = 0; i < g_params.cUcp; i++)
    {
        CleanupUcp(g_params.rgUcp[i]);
    }

    UnmapViewOfFile((LPVOID)g_pdata);
    CloseHandle(g_hMapFile);
    CloseHandle(g_hEvent);
    CloseHandle(g_hEventRet);
    CloseHandle(g_hEventCleanup);
    CloseHandle(g_hMutex);

    CoUninitialize();
    UnInitializeNcInet();
    SsdpCleanup();
}

BOOL DoExit(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs)
{
    if (cArgs == 1)
    {
        Cleanup();
        return TRUE;
    }

    return FALSE;
}

BOOL ParseCommand(LPTSTR szCommand)
{
    DWORD   iCmd;
    LPTSTR  szTemp;

    // eat leading spaces
    while (*szCommand == ' ')
    {
        szCommand++;
    }

    szTemp = _tcstok(szCommand, c_szSeps);
    if (szTemp && *szTemp && (*szTemp != ';'))
    {
        for (iCmd = 0; iCmd < c_cCmd; iCmd++)
        {
            if (!lstrcmpi(szCommand, c_rgCommands[iCmd].szCommand) &&
                (((FIsMillenium() && c_rgCommands[iCmd].fValidOnMillen)) ||
                   (!FIsMillenium())))
            {
                if (c_rgCommands[iCmd].dwCtx & (g_ctx.ectx | CTX_AUTO))
                {
                    DWORD   iArg = 0;
                    LPTSTR  argv[MAX_ARGS];

                    ZeroMemory(&argv, sizeof(argv));
                    while (szTemp && iArg < MAX_ARGS)
                    {
                        argv[iArg++] = szTemp;
                        szTemp = _tcstok(NULL, c_szSeps);
                    }

                    return c_rgCommands[iCmd].pfnCommand(iCmd, iArg, argv);
                }
                else
                {
                    _tprintf(TEXT("'%s' is not valid in this context.\n\n"),
                           _tcstok(szCommand, TEXT(" \r\n\t")));
                    return FALSE;
                }
            }
        }

        _tprintf(TEXT("Unknown command: '%s'.\n\n"), _tcstok(szCommand, TEXT(" \r\n\t")));
    }

    return FALSE;
}

BOOL FInit()
{
    HANDLE              hThread;
    SECURITY_ATTRIBUTES sa = {0};
    SECURITY_DESCRIPTOR sd = {0};
    HRESULT             hr = S_OK;

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        TraceError("FInit", hr);
        return FALSE;
    }

    InitializeDebugging();
    if (!SsdpStartup())
    {
        TraceTag(ttidUpdiag, "SsdpStartup failed! Error %d.",
                 GetLastError());
        return FALSE;
    }

    InitializeNcInet();

    if (FIsMillenium())
    {
        // Don't need to do any more
        return TRUE;
    }

    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, TRUE, NULL, FALSE);
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    g_hMapFile = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE,
                                   0, sizeof(SHARED_DATA), c_szSharedData);

    if (!g_hMapFile)
    {
        TraceTag(ttidUpdiag, "Could not create shared memory! Error %d.",
                 GetLastError());
        return FALSE;
    }

    TraceTag(ttidUpdiag, "Created file mapping '%s'.", c_szSharedData);

    g_pdata = (SHARED_DATA *)MapViewOfFile(g_hMapFile, FILE_MAP_ALL_ACCESS,
                                          0, 0, 0);
    if (!g_pdata)
    {
        TraceTag(ttidUpdiag, "Could not map shared memory! Error %d.", GetLastError());
        return FALSE;
    }

    ZeroMemory(g_pdata, sizeof(SHARED_DATA));

    g_hEvent = CreateEvent(&sa, FALSE, FALSE, c_szSharedEvent);
    if (!g_hEvent)
    {
        TraceTag(ttidUpdiag, "Could not create %s! Error %d.",
                 c_szSharedEvent, GetLastError());
        return FALSE;
    }

    TraceTag(ttidUpdiag, "Created %s event.", c_szSharedEvent);

    g_hEventRet = CreateEvent(&sa, FALSE, FALSE, c_szSharedEventRet);
    if (!g_hEventRet)
    {
        TraceTag(ttidUpdiag, "Could not create %s! Error %d.",
                 c_szSharedEventRet, GetLastError());
        return FALSE;
    }

    TraceTag(ttidUpdiag, "Created %s event.", c_szSharedEventRet);

    g_hEventCleanup = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!g_hEventCleanup)
    {
        TraceTag(ttidUpdiag, "Could not create cleanup event! Error %d.",
                 GetLastError());
        return FALSE;
    }

    TraceTag(ttidUpdiag, "Created %s event.", c_szSharedEventRet);

    DWORD   dwThreadId;
    hThread = CreateThread(NULL, 0, RequestHandlerThreadStart, NULL, 0,
                           &dwThreadId);
    if (!hThread)
    {
        TraceTag(ttidUpdiag, "Could not create request handler thread! Error %d.",
                 GetLastError());
        return FALSE;
    }

    TraceTag(ttidUpdiag, "Created shared thread.");

    g_hMutex = CreateMutex(&sa, FALSE, c_szSharedMutex);
    if (!g_hMutex)
    {
        TraceTag(ttidUpdiag, "Could not create shared mutex! Error %d.",
                 GetLastError());
        return FALSE;
    }

    TraceTag(ttidUpdiag, "Created mutex.");

    return TRUE;
}

VOID Prompt(LPTSTR szRoot, LPTSTR szParam)
{
    const DWORD c_cchMax = 60;
    TCHAR       szPrompt[81];

    if (szParam && *szParam)
    {
        if (_tcslen(szParam) >= c_cchMax)
        {
            TCHAR       szTemp[c_cchMax + 1] = {0};

            lstrcpyn(szTemp, szParam, c_cchMax);

            wsprintf(szPrompt, TEXT("%s: %s...>"), szRoot, szTemp);
        }
        else
        {
            wsprintf(szPrompt, TEXT("%s: %s>"), szRoot, szParam);
        }
    }
    else
    {
        wsprintf(szPrompt, TEXT("%s>"), szRoot);
    }

    _fputts(szPrompt, stdout);
}

BOOL FIsLineAllWhitespace(LPTSTR szBuf)
{
    INT iLen = _tcslen(szBuf);

    for (INT iLoop = 0; iLoop < iLen; iLoop++)
    {
        if (!_istspace(szBuf[iLoop]))
        {
            return FALSE;

        }
    }

    return TRUE;
}

VOID PrintCommandPrompt()
{
    switch (g_ctx.ectx)
    {
        case CTX_ROOT:
            Prompt(TEXT("UPDIAG"), NULL);
            break;
        case CTX_CD:
            Prompt(TEXT("CD"), PDevCur()->szFriendlyName);
            break;
        case CTX_RESULT:
            switch (g_ctx.presCur->resType)
            {
                case RES_FIND:
                    Prompt(TEXT("SRCH"), g_ctx.presCur->szType);
                    break;
                case RES_NOTIFY:
                    Prompt(TEXT("NOTIFY"), g_ctx.presCur->szType);
                    break;
                case RES_SUBS:
                    Prompt(TEXT("SUBS"), g_ctx.presCur->szType);
                    break;
                default:
                    Prompt(TEXT("BUG!"), g_ctx.presCur->szType);
                    break;
            }
            break;
        case CTX_CD_SVC:
            Prompt(TEXT("CDSVC"), g_ctx.psvcCur->szSti);
            break;
        case CTX_EVTSRC:
            Prompt(TEXT("ES"), g_ctx.psvcCur->szEvtUrl);
            break;
        case CTX_UCP:
            Prompt(TEXT("UCP"), g_ctx.pucpCur->szName);
            break;
        default:
            Prompt(TEXT("UNKNOWN"), NULL);
            break;
    }
}

EXTERN_C
VOID
__cdecl
wmain (
    IN INT     argc,
    IN PCWSTR argv[])
{
    TCHAR   szBuf[MAX_PATH];
    BOOL    fDone       = FALSE;

    if (!FInit())
    {
        return;
    }

    // Check for presence of input file arg. If there, init file input.
    //
    if (argc > 1)
    {
        CHAR    szFileName[MAX_PATH];

        WszToSzBuf(szFileName, argv[1], MAX_PATH);
        g_pInputFile = fopen(szFileName, "r");
        if (!g_pInputFile)
        {
            _tprintf(TEXT("Failed to open input file. Reverting to user-input.\n\n"));
        }
        else
        {
            _tprintf(TEXT("Running in scripted mode with file: %S\n\n"), argv[1]);
        }
    }

    g_ctx.ectx = CTX_ROOT;

    while (!fDone)
    {
        // If we're running from an input file, continue.
        //
        if (g_pInputFile)
        {
            // If there was an error reading the file
            //
            if (!_fgetts(szBuf, sizeof(szBuf), g_pInputFile))
            {
                // If it wasn't eof, print an error
                //
                if (!feof(g_pInputFile))
                {
                    _tprintf(TEXT("\nFailure reading script file\n\n"));
                }
                else
                {
                    _tprintf(TEXT("\n[Script complete]\n\n"));
                }

                // regardless, close the file and NULL the handle
                //
                fclose(g_pInputFile);
                g_pInputFile = NULL;
            }
            else
            {
                if (!FIsLineAllWhitespace(szBuf))
                {
                    PrintCommandPrompt();
                    _tprintf(TEXT("%s\n"), szBuf);
                    fDone = ParseCommand(szBuf);
                }
            }
        }
        else
        {
            PrintCommandPrompt();
            _fgetts(szBuf, sizeof(szBuf), stdin);

            // Print nice separator so we can distinguish between commands and output
            //
            _tprintf(TEXT("\n"));

            fDone = ParseCommand(szBuf);
        }
    }

    // Print nice terminating separator
    //
    _tprintf(TEXT("\n"));

    if (g_pInputFile)
    {
        fclose(g_pInputFile);
    }

    SsdpCleanup();
}


// Copy this from the SSDP implemenation so that BoundsChecker doesn't get
// upset about mismatching new with free.
//
VOID LocalFreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage)
{
    delete pSsdpMessage->szAltHeaders;
    delete pSsdpMessage->szContent;
    delete pSsdpMessage->szLocHeader;
    delete pSsdpMessage->szType;
    delete pSsdpMessage->szUSN;
    delete pSsdpMessage->szSid;
    delete pSsdpMessage;
}

// stolen from ssdp\client\message.cpp
BOOL CopySsdpMessage(PSSDP_MESSAGE pDestination, CONST SSDP_MESSAGE * pSource)
{
    pDestination->szLocHeader = NULL;
    pDestination->szAltHeaders = NULL;
    pDestination->szType = NULL;
    pDestination->szUSN = NULL;
    pDestination->szSid = NULL;
    pDestination->szContent = NULL;
    pDestination->iLifeTime = 0;

    if (pSource->szType != NULL)
    {
        pDestination->szType = new CHAR [strlen(pSource->szType) + 1];
        if (pDestination->szType == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szType, pSource->szType);
        }
    }

    if (pSource->szLocHeader != NULL)
    {
        pDestination->szLocHeader = new CHAR [strlen(pSource->szLocHeader) + 1];
        if (pDestination->szLocHeader == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szLocHeader, pSource->szLocHeader);
        }
    }

    if (pSource->szAltHeaders != NULL)
    {
        pDestination->szAltHeaders = new CHAR [strlen(pSource->szAltHeaders) + 1];
        if (pDestination->szAltHeaders == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szAltHeaders, pSource->szAltHeaders);
        }
    }

    if (pSource->szUSN != NULL)
    {
        pDestination->szUSN = new CHAR [strlen(pSource->szUSN) + 1];
        if (pDestination->szUSN == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szUSN, pSource->szUSN);
        }
    }

    if (pSource->szSid != NULL)
    {
        pDestination->szSid = new CHAR [strlen(pSource->szSid) + 1];
        if (pDestination->szSid == NULL)
        {
            goto cleanup;
        }
        else
        {
            strcpy(pDestination->szSid, pSource->szSid);
        }
    }

    pDestination->iLifeTime = pSource->iLifeTime;
    pDestination->iSeq = pSource->iSeq;

    return TRUE;

cleanup:
    LocalFreeSsdpMessage(pDestination);

    return FALSE;
}


VOID NotifyCallback(SSDP_CALLBACK_TYPE ct,
                    CONST SSDP_MESSAGE *pSsdpService,
                    LPVOID pContext)
{
    UPNPRESULT *  pres = (UPNPRESULT *)pContext;

    Assert(pres);

    switch (ct)
    {
        case SSDP_DONE:
            break;

        case SSDP_BYEBYE:
        case SSDP_ALIVE:
        case SSDP_FOUND:
        case SSDP_EVENT:
            if (pres->cResult < MAX_RESULT_MSGS)
            {
                SSDP_MESSAGE * pSsdpMsgCopy;

                pSsdpMsgCopy = new SSDP_MESSAGE;
                if (pSsdpMsgCopy)
                {
                    BOOL fResult;

                    fResult = CopySsdpMessage(pSsdpMsgCopy, pSsdpService);
                    if (fResult)
                    {
                        // Overload iSeq in the case of alive or byebye so we know
                        // which is which
                        if (ct == SSDP_BYEBYE)
                        {
                            pSsdpMsgCopy->iSeq = 1;
                        }
                        else if (ct == SSDP_ALIVE)
                        {
                            pSsdpMsgCopy->iSeq = 2;
                        }
                        else if (ct == SSDP_FOUND)
                        {
                            pSsdpMsgCopy->iSeq = 0;
                        }

                        pres->rgmsgResult[pres->cResult++] = pSsdpMsgCopy;
                    }
                    // else, CopySsdpMessage frees pSsdpMsgCopy
                }
            }
            break;
        default:
            TraceTag(ttidUpdiag, "Unknown callback type %d!", ct);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPnP Diagnostic"
#define VER_INTERNALNAME_STR            "updiag.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\validatesd\validatesd.cpp ===
#include <pch.h>
#pragma hdrstop

#include <msxml2.h>
#include <objbase.h>
#include <stdio.h>
#include <oleauto.h>

#include "validate.h"
#include "ncbase.h"

// ISSUE-2000/10/29-spather: Add support for XML Parse Errors

HRESULT
HrLoadXMLFromFile(LPCWSTR              pszFileName,
                  IXMLDOMDocument      ** ppxdd,
                  IXMLDOMParseError    ** ppxdpe)
{
    HRESULT            hr = S_OK;
    IXMLDOMDocument    * pxdd = NULL;
    IXMLDOMParseError  * pxdpe = NULL;

    hr = CoCreateInstance(CLSID_DOMDocument30,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument,
                          (void **) &pxdd);

    if (SUCCEEDED(hr))
    {
        VARIANT        varFileName;
        VARIANT_BOOL   vbSuccess = VARIANT_FALSE;

        VariantInit(&varFileName);

        V_BSTR(&varFileName) = SysAllocString(pszFileName);

        if (V_BSTR(&varFileName))
        {
            varFileName.vt = VT_BSTR;

            hr = pxdd->load(varFileName, &vbSuccess);

            if (SUCCEEDED(hr))
            {
                if (VARIANT_FALSE == vbSuccess)
                {
                    // There was an XML parse error.

                    hr = pxdd->get_parseError(&pxdpe);

                    if (SUCCEEDED(hr))
                    {
                        hr = S_FALSE; // Indicates parse error.
                    }
                    else
                    {
                        TraceError("HrLoadXMLFromFile(): "
                                   "Failed to get XML DOM parse error",
                                   hr);
                    }
                }

            }
            else
            {
                TraceError("HrLoadXMLFromFile(): "
                           "Failed to load XML",
                           hr);
            }

            VariantClear(&varFileName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrLoadXMLFromFile(): "
                       "Failed to allocate BSTR for filename",
                       hr);
        }
    }
    else
    {
        TraceError("HrLoadXMLFromFile(): "
                   "Could not create DOM document",
                   hr);
    }

    // If everything succeeded, copy the out parameters, otherwise clean up
    // what would have been put in the out parameters.

    if (SUCCEEDED(hr))
    {
        *ppxdd = pxdd;
        *ppxdpe = pxdpe;
    }
    else
    {
        if (pxdd)
        {
            pxdd->Release();
            pxdd = NULL;
        }

        if (pxdpe)
        {
            pxdpe->Release();
            pxdpe = NULL;
        }
    }

    TraceError("HrLoadXMLFromFile(): "
               "Exiting",
               hr);
    return hr;
}


HRESULT
HrReportParseError(
    IN  IXMLDOMParseError  * pxdpe)
{
    HRESULT hr = S_OK;
    LONG    lErrorCode = 0;
    LONG    lLineNum = 0;
    LONG    lLinePos = 0;
    BSTR    bstrReason = NULL;
    BSTR    bstrSrcText = NULL;
    DWORD   cchError = 0;
    LPWSTR  szError = NULL;

    hr = pxdpe->get_errorCode(&lErrorCode);
    if (SUCCEEDED(hr))
    {
        hr = pxdpe->get_line(&lLineNum);

        if (SUCCEEDED(hr))
        {
            hr = pxdpe->get_linepos(&lLinePos);

            if (SUCCEEDED(hr))
            {
                hr = pxdpe->get_reason(&bstrReason);

                if (SUCCEEDED(hr))
                {
                    hr = pxdpe->get_srcText(&bstrSrcText);

                    if (FAILED(hr))
                    {
                        TraceError("HrReportParseError(): "
                                   "Failed to get source text",
                                   hr);
                    }
                }
                else
                {
                    TraceError("HrReportParseError(): "
                               "Failed to get reason",
                               hr);
                }
            }
            else
            {
                TraceError("HrReportParseError(): "
                           "Failed to get line position",
                           hr);
            }
        }
        else
        {
            TraceError("HrReportParseError(): "
                       "Failed to get line number",
                       hr);
        }
    }
    else
    {
        TraceError("HrReportParseError(): "
                   "Failed to get error code",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        // Final error string will look like this:
        // XML Error <errorCode>: line <lineNum>, col <linePos>: "<srcText>": <reason>
        // Allow 10 digits each for error code, line number and line position.

        cchError = lstrlenW(L"XML Error : line , col : \"\": ")+
                   10 + 10 + 10 +
                   SysStringLen(bstrSrcText) +
                   SysStringLen(bstrReason);

        szError = new WCHAR[cchError+1];

        if (szError)
        {
            wsprintfW(szError,
                      L"XML Error %ld: line %ld, col %ld: \"%s\": %s",
                      lErrorCode,
                      lLineNum,
                      lLinePos,
                      bstrSrcText,
                      bstrReason);
            fprintf(stderr,
                    "%S",
                    szError);

        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrReportParseError(): "
                       "Failed to allocate error string",
                       hr);
        }
    }

    // Cleanup.

    if (bstrReason)
    {
        SysFreeString(bstrReason);
        bstrReason = NULL;
    }

    if (bstrSrcText)
    {
        SysFreeString(bstrSrcText);
        bstrSrcText = NULL;
    }

    if (szError)
    {
        delete [] szError;
        szError = NULL;
        cchError = 0;
    }
    TraceError("HrReportParseError(): "
               "Exiting",
               hr);
    return hr;
}


EXTERN_C
INT
__cdecl
wmain(
    int    argc,
        PCWSTR argv[])
{
        HRESULT hr = S_OK;
        int             iRet = 0;

    if (argc != 2)
    {
        fprintf(stderr, "Usage: %S <filename>\n"
                "where <filename> specifies a file containing a service "
                "description",
                argv[0]);
        return -1;
    }

        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

        if (SUCCEEDED(hr))
        {
        IXMLDOMDocument    * pxdd = NULL;
        IXMLDOMParseError  * pxdpe = NULL;

        hr = HrLoadXMLFromFile(argv[1], &pxdd, &pxdpe);

        if (SUCCEEDED(hr))
        {
            if (S_FALSE == hr)
            {
                Assert(pxdpe);

                hr = HrReportParseError(pxdpe);
                pxdpe->Release();
            }
            else
            {
                IXMLDOMElement * pxdeRoot = NULL;

                hr = pxdd->get_documentElement(&pxdeRoot);

                if (SUCCEEDED(hr))
                {
                    LPWSTR szError = NULL;

                    hr = HrValidateServiceDescription(pxdeRoot, &szError);

                    if (SUCCEEDED(hr))
                    {
                        printf("%S: Document is valid!\n",
                               argv[0]);
                    }
                    else if (UPNP_E_INVALID_DOCUMENT == hr)
                    {
                        printf("%S: %S\n",
                               argv[0], szError);
                        delete [] szError;
                    }
                    else
                    {
                        fprintf(stderr,
                                "%S: Service description validation FAILED\n",
                                argv[0]);
                        TraceError("wmain(): "
                                   "Failed to validate document",
                                   hr);
                    }

                    pxdeRoot->Release();
                }
                else
                {
                    fprintf(stderr,
                            "%S: An error occured while processing the XML\n",
                            argv[0]);
                }
            }

            pxdd->Release();
        }
        else
        {
            fprintf(stderr,
                    "%S: Unable to load file %S\n",
                    argv[0], argv[1]);
        }

        CoUninitialize();
        }
        else
        {
        TraceError("wmain(): CoInitialized failed",
                   hr);

                fprintf(stderr,
                "%S: Initialization failed\n",
                argv[0]);
        }

        if (FAILED(hr))
                iRet = -1;

        fprintf(stdout, "%S: Exiting, returning %d\n",
            argv[0], iRet);

        return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\node.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       node.cpp
//
//  Contents:   Implementation of CNode, the basis for the device tree
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "node.h"

CNode::CNode()
{
    _pnParent = NULL;
    _pnFirstChild = NULL;
    _pnLastChild = NULL;
    _pnNextSibling = NULL;
}

CNode::~CNode()
{
    // preorder deletion

    if (_pnFirstChild)
    {
        delete _pnFirstChild;
    }

    if (_pnNextSibling)
    {
        delete _pnNextSibling;
    }
}

CNode *
CNode::GetFirstChild()
{
    return _pnFirstChild;
}

CNode *
CNode::GetParent()
{
    return _pnParent;
}

CNode *
CNode::GetNextSibling()
{
    return _pnNextSibling;
}

BOOL
CNode::HasParent()
{
    return _pnParent ? TRUE : FALSE;
}

BOOL
CNode::HasChildren()
{
    return _pnFirstChild ? TRUE : FALSE;
}

CNode *
CNode::GetRoot()
{
    CNode * pnTemp;

    pnTemp = this;

    while (pnTemp && pnTemp->HasParent())
    {
        pnTemp = pnTemp->GetParent();
    }

    return pnTemp;
}

#ifdef NEVER
// returns the nth child of the node, or NULL if no "nth" child exists
// note: children are ZERO-based.  GetNthChild(0) would return the
// FIRST child.
CNode *
CNode::GetNthChild(ULONG ulNeeded, ULONG * pulSkipped)
{
    CNode * pnTemp;
    ULONG ulCount;

    ulCount = 0;
    pnTemp = _pnFirstChild;
    for ( ; (ulCount < ulNeeded) && pnTemp ; ++ulCount)
    {
        pnTemp = pnTemp->GetNextSibling();
    }

    if (pulSkipped)
    {
        *pulSkipped = ulCount;
    }

    Assert(ulCount <= ulNeeded);
    Assert(FImplies((ulCount < ulNeeded), !pnTemp));
    Assert(FImplies((ulCount == ulNeeded), pnTemp));

    return pnTemp;
}

// returns the "first" child of the node's parent:
//  e.g. the first node in the node's sibling list
// note: doesn't work if a root node has siblings,
//       but this shouldn't be the case anyway
CNode *
CNode::GetFirstSibling()
{
    CNode * pnResult;

    pnResult = NULL;
    if (_pnParent)
    {
        pnResult = _pnParent->GetFirstChild();
    }
    else
    {
        // NOTE: root nodes must have no siblings
        Assert(!_pnNextSibling);

        pnResult = this;
    }
    Assert(pnResult);

    return pnResult;
}
#endif // NEVER

void
CNode::SetParent(CNode * pnParent)
{
    // you can only add a child once
    Assert(!_pnParent);
    _pnParent = pnParent;
}

void
CNode::SetNextSibling(CNode * pnNextSibling)
{
    Assert(!_pnNextSibling);
    _pnNextSibling = pnNextSibling;
}

void
CNode::AddChild(CNode * pnNewChild)
{
    Assert(pnNewChild);

    pnNewChild->SetParent(this);

    if (_pnLastChild)
    {
        _pnLastChild->SetNextSibling(pnNewChild);
    }

    _pnLastChild = pnNewChild;

    if (!_pnFirstChild)
    {
        _pnFirstChild = pnNewChild;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\testtarget.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       TESTTARGET.CPP
//
//  Contents:   Implementation of test for target computer
//
//  Notes:
//
//  Author:     henryr   18 Nov 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <rpcdce.h>
#include <wininet.h>

#include "list.h"
#include "upnpdefs.h"
#include "UPnPDeviceFinder.h"
#include "upnpcommon.h"
#include "testtarget.h"

static int  nTestTargetInit = 0;

static const TCHAR c_tszUpnpRegKey[] = TEXT("SOFTWARE\\Microsoft\\UPnP Control Point");
static const TCHAR c_tszUpnpRegAllowRemote[] = TEXT("DownloadScope");


#define TARGET_PRIVATE_ADDRS    5
static char*   szaddrPrivate[TARGET_PRIVATE_ADDRS] = {
    {"10.0.0.0"},
    {"169.254.0.0"},
    {"192.168.0.0"},
    {"172.16.0.0"},
    {"127.0.0.1"},
};

static char*   szmaskPrivate[TARGET_PRIVATE_ADDRS] = {
    {"255.0.0.0"},
    {"255.255.0.0"},
    {"255.255.0.0"},
    {"255.240.0.0"},
    {"255.255.255.255"},
};

// above strings will be converted to addresses and stored in these tables
// the array sizes TARGET_PRIVATE_ADDRS must be the same in all tables
static sockaddr_in addrPrivate[TARGET_PRIVATE_ADDRS];
static sockaddr_in maskPrivate[TARGET_PRIVATE_ADDRS];

// tables used to calculate delays, based on failure count
// separate tables for local and remote addresses, and for
// announcements versus search replies
#define     MAX_FAILS       5

static const int TableLocalAnnounceDelay[MAX_FAILS+1] =   { 3000,  5000, 15000, 30000,  60000, 120000};
static const int TableRemoteAnnounceDelay[MAX_FAILS+1] =  { 6000, 10000, 30000, 60000, 120000, 240000};
static const int TableLocalSearchDelay[MAX_FAILS+1] =     {    0,  3000,  5000, 15000,  30000,  60000};
static const int TableRemoteSearchDelay[MAX_FAILS+1] =    {    0,  6000, 10000, 30000,  60000, 120000};

// additional delay based on active downloads
#define     MAX_PENDING     35
static const int TablePendingAnnounceDelay[MAX_PENDING+1] = {       0,     0,     0,     0,     0, 
                                                                 5000,  5000,  5000,  5000,  5000,
                                                                10000, 10000, 10000, 10000, 10000,
                                                                20000, 20000, 20000, 20000, 20000,
                                                                30000, 30000, 30000, 30000, 30000,
                                                                40000, 40000, 40000, 40000, 40000,
                                                                50000, 50000, 50000, 50000, 50000, 
                                                                60000  };
static const int TablePendingSearchDelay[MAX_PENDING+1] =   {       0,     0,     0,     0,     0, 
                                                                    0,     0,     0,     0,     0,
                                                                10000, 10000, 10000, 10000, 10000,
                                                                20000, 20000, 20000, 20000, 20000,
                                                                30000, 30000, 30000, 30000, 30000,
                                                                40000, 40000, 40000, 40000, 40000,
                                                                50000, 50000, 50000, 50000, 50000, 
                                                                60000  };


static LIST_ENTRY g_listTarget;
static CRITICAL_SECTION g_csListTarget;
static int      g_nListTarget = 0;
static const int g_cMaxListTarget = 200;

// the following  SCOPE_ values are arrnged in priority order
#define SCOPE_SUBNETONLY    0               // subnet only
#define SCOPE_PRIVATE       1               // subnet or a private address
#define SCOPE_PRIVATE_TTL   2               // subnet or private or within ttl hops
#define SCOPE_REMOTE        3               // anywhere

static DWORD     g_dwAllowRemotes = SCOPE_PRIVATE;

// Default TTL value for UPNP
static const DWORD c_dwTtlDefault = 4;
static const DWORD c_dwTtlMin = 1;
static const DWORD c_dwTtlMax = 255;
static       DWORD dwThisTtl = c_dwTtlDefault;


typedef struct _TARGET_HISTORY
{
    LIST_ENTRY linkage;

    LPSTR   szTargetName;
    int     nInUse;
    int     nFailMetric;
    DWORD   dwLocal;
    DWORD   dwLastUsedTick;
    int     nPending;
} TARGET_HISTORY, *PTARGET_HISTORY;

// value for ageing entries
#define     TARGET_OLD_ENOUGH       60 * 60 * 1000          // 1 hour

// value for ageing pending counts
#define     TARGET_PENDING_LIFE     10 * 60 * 1000          // 10 minutes
#define     TARGET_PENDING_HALF_LIFE 5 * 60 * 1000          // 5 minutes

// private methods
PTARGET_HISTORY CreateTargetHistory(LPSTR szTargetName, DWORD dwLocal);
VOID ReleaseTarget(PTARGET_HISTORY pTarget);
VOID FreeTargetHistory(PTARGET_HISTORY pTarget);
VOID AddToListTarget(PTARGET_HISTORY pTarget);
VOID AddOrReplaceListTarget(PTARGET_HISTORY pTarget);
VOID RemoveFromListTarget(PTARGET_HISTORY pTarget);
VOID CleanupListTarget();
PTARGET_HISTORY LookupTarget(LPSTR szTargetName);
DWORD UpdateLastUsed(PTARGET_HISTORY pTarget);
VOID    CalculateDelay(SSDP_CALLBACK_TYPE sctType,
                        BOOL bIsLocal,
                        int nFailMetric,
                        int nPending,
                        DWORD dwAge,
                        DWORD* cmsecMaxDelay,
                        DWORD* cmsecMinDelay);

DWORD IsTestTargetLocal(sockaddr_in addrTarget, struct hostent* lpHostEnt);
DWORD DoesTargetMatchLocal(sockaddr_in addrTarget, sockaddr_in addrLocal, sockaddr_in maskLocal);



//+---------------------------------------------------------------------------
//
//  Member:     TestTargetUrlOk
//
//  Purpose:    Determine if a download attempt should be made, and if so
//              return maximum and minimum delays to use before doing download
//
//  Arguments:  SSDP_MESSAGE * struct that includes URL, source address, 
//              DWORD* cmsecMaxDelay - pointer to max delay output value
//              DWORD* cmsecMinDelay - pointer to min delay output value
//
//  Returns:    TRUE if OK to download, FALSE if not
//
//
//  Notes:
//
BOOL TestTargetUrlOk(CONST SSDP_MESSAGE * pSsdpMessage,
                        SSDP_CALLBACK_TYPE sctType,
                        DWORD* cmsecMaxDelay,
                        DWORD* cmsecMinDelay)
{
    int     iRet;
    BOOL    bResult = TRUE;
    DWORD   dwLocal = SCOPE_REMOTE;
    
    sockaddr_in addrTarget;
    sockaddr_in addrSource;
    sockaddr_in addrLocal;
    sockaddr_in maskLocal;

    URL_COMPONENTSA  urlComp = {0};
    char        szHostName[INTERNET_MAX_URL_LENGTH + 1];
    struct hostent*     lpHostEnt = NULL;
    PTARGET_HISTORY     pTarget = NULL;

    *cmsecMaxDelay = 3000;
    *cmsecMinDelay = 0;

    if (InitTestTarget() == FALSE)
    {
        return TRUE;
    }

    urlComp.dwStructSize = sizeof(URL_COMPONENTS);
    urlComp.lpszHostName = szHostName;
    urlComp.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

    if (InternetCrackUrlA(pSsdpMessage->szLocHeader, 0, 0, &urlComp))
    {
        if (isdigit(*szHostName))
        {
            // IP literal address
            addrTarget.sin_addr.s_addr = inet_addr(szHostName);

        }
        else
        {
            // host name
            lpHostEnt = gethostbyname(szHostName);
            if (lpHostEnt == NULL)
            {
                iRet = GetLastError();
                TraceTag(ttidUPnPDeviceFinder, "gethostbyname failed with error code %d", iRet);
                bResult = FALSE;
                goto Cleanup;
            }
        }
    }
    else
    {
        TraceTag(ttidUPnPDeviceFinder, "Failed crack URL. Error code (%d).", GetLastError());
        bResult = FALSE;
        goto Cleanup;
    }

    // check if port number reasonable
    if (urlComp.nPort != 0 &&
        urlComp.nPort != 80 &&
        urlComp.nPort < 1024)
    {
        TraceTag(ttidUPnPDeviceFinder, "Rejecting due to port number. Port (%d).", urlComp.nPort);
        bResult = FALSE;
        goto Cleanup;
    }

    // check if host in list.
    pTarget = LookupTarget(szHostName);
    if (pTarget)
    {
        // if in list, use scope to determine if allowed
        if (pTarget->dwLocal > g_dwAllowRemotes)
        {
            TraceTag(ttidUPnPDeviceFinder, "Rejecting due to address not local.");
            ReleaseTarget(pTarget);
            bResult = FALSE;
            goto Cleanup;
        }

        // if in list, use fail count, isLocal, and nPending to set delay & return
        DWORD dwAge = UpdateLastUsed(pTarget);
        CalculateDelay(sctType,
                        pTarget->dwLocal == SCOPE_SUBNETONLY,
                        pTarget->nFailMetric,
                        pTarget->nPending,
                        dwAge,
                        cmsecMaxDelay,
                        cmsecMinDelay);

        pTarget->nPending++;

        ReleaseTarget(pTarget);
        bResult = TRUE;

        goto Cleanup;
    }

    // if we have a source address, check if matches target
    if (pSsdpMessage->szSid)
    {
        addrSource.sin_addr.s_addr = inet_addr(pSsdpMessage->szSid);
        if (INADDR_NONE != addrSource.sin_addr.s_addr)
        {
            // got a source address. Test if same as target address
            if (lpHostEnt == NULL)
            {
                if (addrSource.sin_addr.s_addr != addrTarget.sin_addr.s_addr)
                {
                    TraceTag(ttidUPnPDeviceFinder, "Rejecting due to address mismatch.");
                    bResult = FALSE;
                    goto Cleanup;
                }
            }
            else
            {
                // host name
                // check each returned address
                char** ppaddr_list = lpHostEnt->h_addr_list;
                sockaddr_in addrTmp;
                bResult = FALSE;

                while (*ppaddr_list)
                {
                    CopyMemory (&addrTmp.sin_addr, *ppaddr_list, lpHostEnt->h_length);
                    if (addrSource.sin_addr.s_addr == addrTmp.sin_addr.s_addr)
                    {
                        // exit loop now, so addrTarget has source address
                        bResult = TRUE;
                        break;
                    }
                    ppaddr_list++;
                }
                if (bResult == FALSE)
                {
                    TraceTag(ttidUPnPDeviceFinder, "Rejecting due to address mismatch.");
                    goto Cleanup;
                }
            }
        }
    }

    bResult = TRUE;

    // now check if we think that the target address is local
    dwLocal = IsTestTargetLocal(addrTarget, lpHostEnt);

    // create a target entry
    pTarget = CreateTargetHistory(szHostName, dwLocal);
    if (pTarget)
    {
        AddOrReplaceListTarget(pTarget);
        ReleaseTarget(pTarget);
    }

    if (dwLocal > g_dwAllowRemotes)
    {
        TraceTag(ttidUPnPDeviceFinder, "Rejecting due to address not local.");
        bResult = FALSE;
        goto Cleanup;
    }

    CalculateDelay(sctType,
                    dwLocal == SCOPE_SUBNETONLY,
                    1,                  // no history, assume failure
                    0,
                    0,
                    cmsecMaxDelay,
                    cmsecMinDelay);

Cleanup:

    TraceTag(ttidUPnPDeviceFinder, "Test Target for %s returns %d with delay %d - %d", 
                            pSsdpMessage->szLocHeader, bResult, *cmsecMinDelay, *cmsecMaxDelay);

    return bResult;

}


//+---------------------------------------------------------------------------
//
//  Member:     TargetAttemptCompletedW
//
//  Purpose:    Indicate that a download attempt has completed
//
//  Arguments:  Url in UNICODE form
//              code to indicate fail, success, or aborted
//
//  Returns:    none
//
//
//  Notes:
//
VOID TargetAttemptCompletedW(LPWSTR wszUrl, int code)
{
    if (0 != nTestTargetInit)
    {
        LPSTR szUrl = SzFromWsz(wszUrl);

        if (szUrl)
        {
            TargetAttemptCompletedA(szUrl, code);

            MemFree(szUrl);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     TargetAttemptCompletedA
//
//  Purpose:    Indicate that a download attempt has completed
//
//  Arguments:  Url in ANSI form
//              code to indicate fail, success, or aborted
//
//  Returns:    none
//
//
//  Notes:
//
VOID TargetAttemptCompletedA(LPSTR szUrl, int code)
{
    PTARGET_HISTORY pTarget;
    URL_COMPONENTSA  urlComp = {0};
    char        szHostName[INTERNET_MAX_URL_LENGTH + 1];

    if (0 != nTestTargetInit)
    {
        urlComp.dwStructSize = sizeof(URL_COMPONENTS);
        urlComp.lpszHostName = szHostName;
        urlComp.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

        if (InternetCrackUrlA(szUrl, 0, 0, &urlComp))
        {
            pTarget = LookupTarget(szHostName);
            if (pTarget)
            {
                switch (code)
                {
                case TARGET_COMPLETE_FAIL:
                    if (pTarget->nFailMetric < MAX_FAILS)
                    {
                        pTarget->nFailMetric++;
                    }
                    break;
                case TARGET_COMPLETE_OK:
                    if (pTarget->nFailMetric > 0)
                    {
                        pTarget->nFailMetric--;
                    }
                    break;
                default:
                    break;
                }

                if (pTarget->nPending > 0)
                    pTarget->nPending--;

                TraceTag(ttidUPnPDeviceFinder, "Test Target completed for %s. "
                            "code %d pending %d fail count %d", 
                            szUrl, code, pTarget->nPending, pTarget->nFailMetric);

                ReleaseTarget(pTarget);
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     InitTestTarget
//
//  Purpose:    Initialize resources used for TestTarget
//
//  Arguments:  none
//
//  Returns:    TRUE if succeeded, FALSE if not
//
//
//  Notes:
//
BOOL InitTestTarget()
{
    WSADATA WsaData;
    int i;

    if (nTestTargetInit == 0)
    {
        HKEY    hkey;

        if (WSAStartup(MAKEWORD( 2, 2 ), &WsaData) != 0)
        {
            TraceTag(ttidUPnPDeviceFinder, "Failed to init winsock. Error code (%d).", GetLastError());
            return FALSE;
        }

        InitializeCriticalSection(&g_csListTarget);
        EnterCriticalSection(&g_csListTarget);
        InitializeListHead(&g_listTarget);
        g_nListTarget = 0;
        LeaveCriticalSection(&g_csListTarget);

        for (i=0; i < TARGET_PRIVATE_ADDRS; i++)
        {
            addrPrivate[i].sin_addr.s_addr = inet_addr(szaddrPrivate[i]);
            maskPrivate[i].sin_addr.s_addr = inet_addr(szmaskPrivate[i]);

        }

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          c_tszUpnpRegKey,
                                          0,
                                          KEY_READ, &hkey))
        {
            DWORD   cbSize = sizeof(g_dwAllowRemotes);

            // ignore failure. In that case, we'll use default
            (VOID) RegQueryValueEx(hkey, c_tszUpnpRegAllowRemote, NULL, NULL, (BYTE *)&g_dwAllowRemotes, &cbSize);

            if (g_dwAllowRemotes > SCOPE_REMOTE)
            {
                g_dwAllowRemotes = SCOPE_REMOTE;
            }

            RegCloseKey(hkey);
        }

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("SYSTEM\\CurrentControlSet\\Services\\SSDPSRV\\Parameters"),
                                          0,
                                          KEY_READ, &hkey))
        {
            DWORD   cbSize = sizeof(DWORD);
            DWORD   dwTtl = c_dwTtlDefault;

            // ignore failure. In that case, we'll use default
            (VOID) RegQueryValueEx(hkey, TEXT("TTL"), NULL, NULL, (BYTE *)&dwTtl, &cbSize);

            dwThisTtl = max(dwTtl, c_dwTtlMin);
            dwThisTtl = min(dwTtl, c_dwTtlMax);

            RegCloseKey(hkey);
        }

        nTestTargetInit++;

        TraceTag(ttidUPnPDeviceFinder, "Test Target initialized.");
    }


    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     TermTestTarget
//
//  Purpose:    Free resources used for TestTarget
//
//  Arguments:  none
//
//  Returns:    none
//
//
//  Notes:
//
VOID TermTestTarget()
{
    if (nTestTargetInit > 0)
    {
        nTestTargetInit--;

        if (0 == nTestTargetInit)
        {
            CleanupListTarget();
            DeleteCriticalSection(&g_csListTarget);

            WSACleanup();
        }
        TraceTag(ttidUPnPDeviceFinder, "Test Target terminated.");

    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CreateTargetHistory
//
//  Purpose:    Save target data to keep in history list
//
//  Arguments:  Target name or address string
//              Scope value
//
//  Returns:    pointer to TARGET_HISTORY struct
//
//
//  Notes:
//
PTARGET_HISTORY CreateTargetHistory(LPSTR szTargetName, DWORD dwLocal)
{
    PTARGET_HISTORY pTarget = (PTARGET_HISTORY) malloc(sizeof(TARGET_HISTORY) +
                                                        strlen(szTargetName) + 1);

    if (pTarget == NULL)
    {
        TraceTag(ttidUPnPDeviceFinder, "Couldn't allocate memory for %d", socket);
        return NULL;
    }

    pTarget->szTargetName = (char*)pTarget + sizeof(TARGET_HISTORY);
    strcpy(pTarget->szTargetName, szTargetName);

    pTarget->nFailMetric = 1;
    pTarget->dwLastUsedTick = GetTickCount();
    pTarget->dwLocal = dwLocal;
    pTarget->nInUse = 1;
    pTarget->nPending = 0;

    return pTarget;
}


//+---------------------------------------------------------------------------
//
//  Member:     FreeTargetHistory
//
//  Purpose:    Save target data to keep in history list
//
//  Arguments:  Target name or address string
//
//  Returns:    pointer to TARGET_HISTORY struct
//
//
//  Notes:
//
VOID FreeTargetHistory(PTARGET_HISTORY pTarget)
{
    free(pTarget);
}


//+---------------------------------------------------------------------------
//
//  Member:     AddToListTarget
//
//  Purpose:    Add target data to history list
//
//  Arguments:  pointer to TARGET_HISTORY struct
//
//  Returns:    
//
//  Notes:
//
VOID AddToListTarget(PTARGET_HISTORY pTarget)
{
    EnterCriticalSection(&g_csListTarget);
    InsertHeadList(&g_listTarget, &(pTarget->linkage));
    g_nListTarget++;
    LeaveCriticalSection(&g_csListTarget);
}

//+---------------------------------------------------------------------------
//
//  Member:     AddOrReplaceListTarget
//
//  Purpose:    Add target data to history list. If list is full
//              then release an existing entry first
//
//  Arguments:  pointer to TARGET_HISTORY struct
//
//  Returns:    
//
//  Notes:
//
VOID AddOrReplaceListTarget(PTARGET_HISTORY pTarget)
{
    DWORD   dwAge;
    DWORD   dwOldest;
    PTARGET_HISTORY pFound = NULL;

    EnterCriticalSection(&g_csListTarget);

    if (g_nListTarget > g_cMaxListTarget)
    {
        PLIST_ENTRY     p;
        PLIST_ENTRY     pListHead = &g_listTarget;
        PTARGET_HISTORY pTmpTarget;

        DWORD dwNowTick = GetTickCount();
        dwOldest = 0;
        for (p = pListHead->Flink; p != pListHead;)
        {
            PTARGET_HISTORY pTmpTarget;

            pTmpTarget = CONTAINING_RECORD (p, TARGET_HISTORY, linkage);

            p = p->Flink;

            dwAge = dwNowTick - pTmpTarget->dwLastUsedTick;
            if ((pTmpTarget->nInUse == 0) && 
                (dwAge > TARGET_OLD_ENOUGH))
            {
                pFound = pTmpTarget;
                break;
            }
            if ((pTmpTarget->nInUse == 0) &&
                (dwAge > dwOldest))
            {
                dwOldest = dwAge;
                pFound = pTmpTarget;
            }
        }

        if (pFound)
        {
            RemoveFromListTarget(pFound);
            FreeTargetHistory(pFound);
        }
    }

    AddToListTarget(pTarget);
    
    LeaveCriticalSection(&g_csListTarget);
}

//+---------------------------------------------------------------------------
//
//  Member:     RemoveFromListTarget
//
//  Purpose:    Remove target data from history list. 
//
//  Arguments:  pointer to TARGET_HISTORY struct
//
//  Returns:    
//
//  Notes:
//
VOID RemoveFromListTarget(PTARGET_HISTORY pTarget)
{
    EnterCriticalSection(&g_csListTarget);
    RemoveEntryList(&(pTarget->linkage));
    g_nListTarget--;
    LeaveCriticalSection(&g_csListTarget);
}


//+---------------------------------------------------------------------------
//
//  Member:     CleanupListTarget
//
//  Purpose:    Remove and free all target history structs 
//
//  Arguments:  
//
//  Returns:    
//
//  Notes:
//
VOID CleanupListTarget()
{
    PLIST_ENTRY     p;

    EnterCriticalSection(&g_csListTarget);

    PLIST_ENTRY     pListHead = &g_listTarget;

    for (p = pListHead->Flink; p != pListHead;)
    {
        PTARGET_HISTORY pTarget;

        pTarget = CONTAINING_RECORD (p, TARGET_HISTORY, linkage);

        p = p->Flink;

        RemoveFromListTarget(pTarget);
        FreeTargetHistory(pTarget);
    }

    LeaveCriticalSection(&g_csListTarget);

}



//+---------------------------------------------------------------------------
//
//  Member:     LookupTarget
//
//  Purpose:    Find a target in the list that matches the name or address string 
//
//  Arguments:  name or address string
//
//  Returns:    pointer to target history or NULL
//
//  Notes:
//
PTARGET_HISTORY LookupTarget(LPSTR szTargetName)
{
    PLIST_ENTRY     p;
    PLIST_ENTRY     pListHead = &g_listTarget;
    PTARGET_HISTORY  pFound = NULL;

    EnterCriticalSection(&g_csListTarget);
    for (p = pListHead->Flink; p != pListHead;)
    {
        PTARGET_HISTORY pTarget;

        pTarget = CONTAINING_RECORD (p, TARGET_HISTORY, linkage);

        p = p->Flink;

        if (strcmp(pTarget->szTargetName, szTargetName) == 0)
        {
            pFound = pTarget;
            pFound->nInUse++;
            break;
        }
    }

    LeaveCriticalSection(&g_csListTarget);

    return pFound;
}

VOID ReleaseTarget(PTARGET_HISTORY pTarget)
{
    pTarget->nInUse--;
}


//+---------------------------------------------------------------------------
//
//  Member:     UpdateLastUsed
//
//  Purpose:    Mark a target history as being used.
//              This updates its last used time
//              It also may reduce the pending count if it has been idle for a while 
//
//  Arguments:  pointer to target history
//
//  Returns:    last used age before this update
//
//  Notes:
//
DWORD UpdateLastUsed(PTARGET_HISTORY pTarget)
{
    DWORD dwNow = GetTickCount();
    DWORD dwAge = dwNow - pTarget->dwLastUsedTick;
    pTarget->dwLastUsedTick = dwNow;

    if (dwAge > TARGET_PENDING_LIFE)
    {
        pTarget->nPending = 0;
    }
    else if (dwAge > TARGET_PENDING_HALF_LIFE)
    {
        pTarget->nPending = pTarget->nPending / 2;
    }

    return dwAge;
}




//+---------------------------------------------------------------------------
//
//  Member:     CalculateDelay
//
//  Purpose:    Based on all the metrics available, calculate what the delay
//              should be. 
//
//  Arguments:  failure count
//              local or remote address flag
//              type indicating announcement or search result
//              last used age
//              number of in progress or pending downloads
//              pointer to output for Max delay
//              pointer to output for Min delay
//
//  Returns:    
//
//  Notes:
//
VOID    CalculateDelay(SSDP_CALLBACK_TYPE sctType,
                        BOOL bIsLocal,
                        int nFailMetric,
                        int nPending,
                        DWORD dwAge,
                        DWORD* cmsecMaxDelay,
                        DWORD* cmsecMinDelay)
{
    int nDelay = 0;
    // limit nPending for table lookup
    if (nPending > MAX_PENDING)
        nPending = MAX_PENDING;

    if (SSDP_ALIVE == sctType)
    {
        // calculation for announcements

        // delay per pending download
        nDelay = TablePendingAnnounceDelay[nPending];

        // plus delay for local/remote address using tables
        if (bIsLocal)
        {
            nDelay += TableLocalAnnounceDelay[nFailMetric];
        }
        else
        {
            nDelay += TableRemoteAnnounceDelay[nFailMetric];
        }
    }
    else if (SSDP_FOUND == sctType)
    {

        // delay per pending download
        nDelay = TablePendingSearchDelay[nPending];

        if (bIsLocal)
        {
            nDelay += TableLocalSearchDelay[nFailMetric];
        }
        else
        {
            nDelay += TableRemoteSearchDelay[nFailMetric];
        }
    }

    *cmsecMaxDelay = nDelay;
    // min is always 0 for now
    *cmsecMinDelay = 0;

    TraceTag(ttidUPnPDeviceFinder, "Calculate delay %d", nDelay);
}



//+---------------------------------------------------------------------------
//
//  Member:     IsTestTargetLocal
//
//  Purpose:    test if target address is local 
//
//  Arguments:  target address or pointer to hostent
//
//  Returns:    Scope of target
//
//  Notes:
//
DWORD IsTestTargetLocal(sockaddr_in addrTarget, struct hostent*  lpHostEnt)
{
    PIP_ADAPTER_INFO pip = NULL;
    RPC_STATUS rpcRet;
    ULONG ulSize = 0;
    DWORD dwFound = SCOPE_REMOTE;
    DWORD dwScope;

    GetAdaptersInfo(NULL, &ulSize);
    if(ulSize)
    {
        pip = reinterpret_cast<PIP_ADAPTER_INFO>(malloc(ulSize));

        DWORD dwRet = GetAdaptersInfo(pip, &ulSize);

        if(ERROR_SUCCESS == dwRet)
        {
            PIP_ADAPTER_INFO pipIter = pip;
            while(pipIter && dwFound != SCOPE_SUBNETONLY)
            {
                PIP_ADDR_STRING pIpAddr = &pipIter->IpAddressList;
                while (pIpAddr && dwFound != SCOPE_SUBNETONLY)
                {
                    sockaddr_in addrLocal;
                    sockaddr_in maskLocal;
                    sockaddr_in addrTmp;

                    addrLocal.sin_addr.s_addr = inet_addr(pIpAddr->IpAddress.String);
                    maskLocal.sin_addr.s_addr = inet_addr(pIpAddr->IpMask.String);
                    if (addrLocal.sin_addr.s_addr != 0)
                    {
                        if (lpHostEnt == NULL)
                        {
                            dwScope = DoesTargetMatchLocal(addrTarget, addrLocal, maskLocal);
                            if (dwScope < dwFound)
                            {
                                dwFound = dwScope;
                            }
                        }
                        else
                        {
                            // check all lpHostEnt
                            char** ppaddr_list = lpHostEnt->h_addr_list;
                            sockaddr_in addrTmp;

                            while (*ppaddr_list && dwFound != SCOPE_SUBNETONLY)
                            {
                                CopyMemory (&addrTmp.sin_addr, *ppaddr_list, lpHostEnt->h_length);
                                dwScope = DoesTargetMatchLocal(addrTmp, addrLocal, maskLocal);
                                if (dwScope < dwFound)
                                {
                                    dwFound = dwScope;
                                }
                                ppaddr_list++;
                            }

                        }
                    }

                    pIpAddr = pIpAddr->Next;
                }
                pipIter = pipIter->Next;
            }
        }

        free(pip);
    }

    return dwFound;
}


//+---------------------------------------------------------------------------
//
//  Member:     DoesTargetMatchLocal
//
//  Purpose:    based on target address, and this computer's address
//              determine if target is local
//
//  Arguments:  target address
//              local address
//              local mask
//
//  Returns:    SCOPE_* value
//
//
//  Notes:
//
DWORD DoesTargetMatchLocal(sockaddr_in addrTarget, sockaddr_in addrLocal, sockaddr_in maskLocal)
{
    DWORD dwScope = SCOPE_REMOTE;

    // is this on my subnet?
    if ((addrLocal.sin_addr.s_addr & maskLocal.sin_addr.s_addr) ==
        (addrTarget.sin_addr.s_addr & maskLocal.sin_addr.s_addr))
    {
        dwScope = SCOPE_SUBNETONLY;
    }
    else
    {
        // is this a known private address from table?
        int i;

        for (i = 0; i < TARGET_PRIVATE_ADDRS; i++)
        {
            if ((addrPrivate[i].sin_addr.s_addr & maskPrivate[i].sin_addr.s_addr) ==
                (addrTarget.sin_addr.s_addr & maskPrivate[i].sin_addr.s_addr))
            {
                dwScope = SCOPE_PRIVATE;
                break;
            }
        }
    }

    if ((dwScope == SCOPE_REMOTE) && (g_dwAllowRemotes == SCOPE_PRIVATE_TTL))
    {
        // check if actually within 4 hops
        // only if previous tests failed, and allowing value is TTL
        DWORD dwHops;
        DWORD dwRtt;
        if (GetRTTAndHopCount(addrTarget.sin_addr.s_addr, &dwHops, dwThisTtl, &dwRtt))
        {
            dwScope = SCOPE_PRIVATE_TTL;
        }
        TraceTag(ttidUPnPDeviceFinder, "GetRTTAndHopCount returns %d", dwHops);
    }

    return dwScope;
}

BOOL WINAPI ValidateTargetUrlWithHostUrlA(LPCSTR szHostUrl, LPCSTR szTargetUrl)
{
    BOOL bResult = TRUE;
    URL_COMPONENTSA  urlCompHost  = {0};
    URL_COMPONENTSA  urlCompTarget = {0};
    char szHostName[INTERNET_MAX_URL_LENGTH + 1];
    char szTargetName[INTERNET_MAX_URL_LENGTH + 1];
       
        urlCompHost.dwStructSize = sizeof(URL_COMPONENTS);
        urlCompHost.lpszHostName = szHostName;
        urlCompHost.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

        urlCompTarget.dwStructSize = sizeof(URL_COMPONENTS);
        urlCompTarget.lpszHostName = szTargetName;
        urlCompTarget.dwHostNameLength = INTERNET_MAX_URL_LENGTH;

        if (!InternetCrackUrlA(szHostUrl, 0, 0, &urlCompHost))
        {
            TraceTag(ttidUPnPDeviceFinder, "Failed crack URL. Error code (%d).", GetLastError());
            bResult = FALSE;
            goto Cleanup;           
        }

        if (!InternetCrackUrlA(szTargetUrl, 0, 0, &urlCompTarget))
        {
            TraceTag(ttidUPnPDeviceFinder, "Failed crack URL. Error code (%d).", GetLastError());
            bResult = FALSE;
            goto Cleanup;  
        }

        if(_stricmp(szHostName,szTargetName) != 0 )
        {
            TraceTag(ttidUPnPDeviceFinder, "Rejecting due to Host and Target URL hostname mismatch");
            bResult = FALSE;
            goto Cleanup;           
        }
 
        if (urlCompTarget.nPort != 0 &&
            urlCompTarget.nPort != 80 &&
            urlCompTarget.nPort < 1024)
        {
            TraceTag(ttidUPnPDeviceFinder, "Rejecting due to port number. Port (%d).", urlCompTarget.nPort);
            bResult = FALSE;
            goto Cleanup;
        }    

        Cleanup:
            TraceTag(ttidUPnPDeviceFinder,"Host Url %s ",szHostUrl);
            TraceTag(ttidUPnPDeviceFinder,"Target Url %s ",szTargetUrl); 
    
        return bResult;

}

BOOL ValidateTargetUrlWithHostUrlW(LPCWSTR wszHostUrl, LPCWSTR wszTargetUrl)
{
    BOOL bResult = FALSE;
    LPSTR szHostUrl = NULL;
    LPSTR szTargetUrl = NULL;
    
    szHostUrl = SzFromWsz(wszHostUrl);
    szTargetUrl = SzFromWsz(wszTargetUrl);
    
    if((szHostUrl) && ( szTargetUrl))
        bResult = ValidateTargetUrlWithHostUrlA(szHostUrl,szTargetUrl);    

    MemFree(szHostUrl);
    MemFree(szTargetUrl);
  
    return bResult;
}

BOOL fValidateUrl (const ULONG cElems,
                const DevicePropertiesParsingStruct dppsInfo [],
                const LPCWSTR arypszReadValues [],
                const LPCWSTR wszUrl )
{
    ULONG i;
    BOOL fResult = TRUE;
     
    for (i = 0; i < cElems; ++i )
    {
        if (dppsInfo[i].m_fValidateUrl && arypszReadValues[i]) 
        {
            
            fResult = ValidateTargetUrlWithHostUrlW(wszUrl, arypszReadValues[i]);
            if(!fResult)
                break;
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\util\util.cpp ===
// 
// util.cpp
// 
// utility functions used by updiag.exe
//

#include "pch.h"
#pragma hdrstop

#include "oleauto.h"
#include "ncbase.h"
#include "ncinet.h"
#include "ssdpapi.h"
#include "util.h"

//
// Functions for Standard State Table Operations
//
DWORD Do_Set(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_Assign(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_Toggle(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_Increment(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_Decrement(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_IncrementWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_DecrementWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_IncrementBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_DecrementBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_NextStringWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_PrevStringWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_NextStringBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);
DWORD Do_PrevStringBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs);

// 
// List of Standard State Table Operations
//
extern const STANDARD_OPERATION_LIST c_Ops =
{
    // total number of standard operations
    13,
    {
        //  Operation name,                 # of arguments,     # of constants,    actual function
        {   TEXT("SET"),                    0,                  1,                 Do_Set},
        {   TEXT("ASSIGN"),                 1,                  0,                 Do_Assign},
        {   TEXT("TOGGLE"),                 0,                  0,                 Do_Toggle},
        {   TEXT("INCREMENT"),              0,                  0,                 Do_Increment},
        {   TEXT("DECREMENT"),              0,                  0,                 Do_Decrement},
        {   TEXT("INCREMENT_WRAP"),         0,                  2,                 Do_IncrementWrap},
        {   TEXT("DECREMENT_WRAP"),         0,                  2,                 Do_DecrementWrap},
        {   TEXT("INCREMENT_BOUNDED"),      0,                  1,                 Do_IncrementBounded},
        {   TEXT("DECREMENT_BOUNDED"),      0,                  1,                 Do_DecrementBounded},
        {   TEXT("NEXT_STRING_WRAP"),       0,                  0,                 Do_NextStringWrap},
        {   TEXT("PREV_STRING_WRAP"),       0,                  0,                 Do_PrevStringWrap},
        {   TEXT("NEXT_STRING_BOUNDED"),    0,                  0,                 Do_NextStringBounded},
        {   TEXT("PREV_STRING_BOUNDED"),    0,                  0,                 Do_PrevStringBounded},
    },
};


VOID WcharToTcharInPlace(LPTSTR szT, LPWSTR szW)
{
    DWORD   cch = wcslen(szW) + 1;

#ifndef UNICODE
    WideCharToMultiByte(CP_ACP, 0, szW, cch, szT, cch, NULL, NULL);
#else
    lstrcpyW(szT, szW);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupOpenConfigFile
//
//  Purpose:    Open a service's configuration file (INF format)
//
HRESULT HrSetupOpenConfigFile(  PCTSTR pszFileName,
                                UINT* punErrorLine,
                                HINF* phinf)
{
    HRESULT hr;
    HINF hinf;

    Assert (pszFileName);
    Assert (phinf);

    // Try to open the file.
    //
    hinf = SetupOpenInfFile (pszFileName, NULL, INF_STYLE_WIN4, punErrorLine);
    if (INVALID_HANDLE_VALUE != hinf)
    {
        hr = S_OK;
        *phinf = hinf;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        *phinf = NULL;
        if (punErrorLine)
        {
            *punErrorLine = 0;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
             "HrSetupOpenConfigFile (%S)", pszFileName);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindFirstLine
//
//  Purpose:    Find the first line in an INF file with a matching section
//              and key.
//
HRESULT HrSetupFindFirstLine( HINF hinf,
                              PCTSTR pszSection,
                              PCTSTR pszKey,
                              INFCONTEXT* pctx)
{
    Assert (hinf);
    Assert (pszSection);
    Assert (pctx);

    HRESULT hr;
    if (SetupFindFirstLine (hinf, pszSection, pszKey, pctx))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
    }
    TraceErrorOptional ("HrSetupFindFirstLine", hr,
                        (SPAPI_E_LINE_NOT_FOUND == hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupFindNextLine
//
//  Purpose:    Find the next line in an INF file relative to ctxIn.
//
HRESULT HrSetupFindNextLine( const INFCONTEXT& ctxIn,
                             INFCONTEXT* pctxOut)
{
    Assert (pctxOut);

    HRESULT hr;
    if (SetupFindNextLine (const_cast<PINFCONTEXT>(&ctxIn), pctxOut))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // Translate ERROR_LINE_NOT_FOUND into S_FALSE
            hr = S_FALSE;
        }
    }
    TraceError ("HrSetupFindNextLine", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetStringField
//
//  Purpose:    Gets a string from an INF field.
//
HRESULT HrSetupGetStringField( const INFCONTEXT& ctx,
                               DWORD dwFieldIndex,
                               PTSTR pszBuf, 
                               DWORD cchBuf,
                               DWORD* pcchRequired)
{
    HRESULT hr;
    if (SetupGetStringField ((PINFCONTEXT)&ctx, dwFieldIndex, pszBuf,
            cchBuf, pcchRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();

        if (pszBuf)
        {
            *pszBuf = 0;
        }
        if (pcchRequired)
        {
            *pcchRequired = 0;
        }
    }
    TraceError ("HrSetupGetStringField", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetupGetLineText
//
//  Purpose:    Gets a line from an INF field.
//
HRESULT HrSetupGetLineText( const  INFCONTEXT& ctx,
                            PTSTR  pszBuf,  
                            DWORD  cchBuf,
                            DWORD* pcchRequired)
{
    HRESULT hr;
    if (SetupGetLineText((PINFCONTEXT)&ctx, NULL, NULL, NULL, pszBuf,
                         cchBuf, pcchRequired))
    {
        hr = S_OK;
    }
    else
    {
        hr = HrFromLastWin32Error ();
        if (pszBuf)
        {
            *pszBuf = 0;
        }
        if (pcchRequired)
        {
            *pcchRequired = 0;
        }
    }
    TraceError ("HrSetupGetStringField", hr);
    return hr;
}

VOID SetupCloseInfFileSafe(HINF hinf)
{
    if (IsValidHandle(hinf))
    {
        SetupCloseInfFile(hinf);
    }
}

// get the next field
// returns FALSE if field not found or is empty
BOOL fGetNextField(TCHAR ** pszLine, TCHAR * szBuffer)
{
    Assert(*pszLine);
    Assert(szBuffer);

    *szBuffer = '\0';

    if (lstrlen(*pszLine))
    {
        TCHAR * pChar;
        
        if (**pszLine == '(')
        {
            pChar = _tcschr(*pszLine, TEXT(')'));
            pChar++;
        }
        else
        {
            pChar = _tcschr(*pszLine, TEXT(','));
        }

        if (pChar)
        {
            *pChar ='\0';
            lstrcpy(szBuffer, *pszLine);
            *pszLine = ++pChar;
        }
        else
        {
            lstrcpy(szBuffer, *pszLine);
            **pszLine = '\0';
        }
    }

    return (!!lstrlen(szBuffer));
}

// Input:  name of the operation
// Output: number of arguments and constants
BOOL IsStandardOperation(TCHAR * szOpName, DWORD * pnArgs, DWORD * pnConsts)
{
    *pnArgs =0;
    *pnConsts=0;

    for (DWORD iOps = 0; iOps < c_Ops.cOperations; iOps++)
    {
        if (!_tcsicmp(c_Ops.rgOperations[iOps].szOperation, szOpName))
        {
            *pnArgs = c_Ops.rgOperations[iOps].nArguments;
            *pnConsts = c_Ops.rgOperations[iOps].nConstants;

            return TRUE;
        }
    }

    return FALSE;
}

// Find the row in the state table that needs to be changed
//
SST_ROW * FindSSTRowByVarName(SST * psst, TCHAR * szVariableName)
{
    SST_ROW * pRow = NULL;
    for (DWORD iRow =0; iRow<psst->cRows; iRow++)
    {
        if (!lstrcmpi(psst->rgRows[iRow].szPropName, szVariableName))
        {
            pRow = &psst->rgRows[iRow];
            break;
        }
    }
    return pRow;
}

//
// Functions for Standard State Table Operations
//
HRESULT HrSetVariantValue(VARIANT * pVar, TCHAR * szNewValue)
{
    HRESULT hr;
    VARIANT varNew;

    VariantInit(&varNew);
    varNew.vt = VT_BSTR;

    WCHAR * wszNewValue = WszFromTsz(szNewValue);
    V_BSTR(&varNew) = SysAllocString(wszNewValue);

    hr = VariantChangeType(&varNew, &varNew, 0, pVar->vt);
    if (S_OK == hr)
    {
        hr = VariantCopy(pVar, &varNew);
    }

    TraceError("HrSetVariantValue", hr);
    return hr;
}

DWORD dwSubmitEvent(UPNPSVC * psvc, SST_ROW * pRow) 
{
    HRESULT hr;
    DWORD dwErr =0;
    CHAR   szUri[INTERNET_MAX_URL_LENGTH];

    UPNP_PROPERTY Property = {0};

    // convert current value to string
    VARIANT varValue;
    VariantInit(&varValue);
    hr = VariantChangeType(&varValue, &pRow->varValue, 0, VT_BSTR);
    if (S_OK ==hr)
    {
        LPSTR pszUrl = SzFromTsz(psvc->szEvtUrl);
        if (pszUrl)
        {
            LPWSTR  wszVal = varValue.bstrVal;
            Property.szValue = SzFromWsz(wszVal);

            if (Property.szValue)
            {
                hr = HrGetRequestUriA(pszUrl, INTERNET_MAX_URL_LENGTH, szUri);
                if (SUCCEEDED(hr))
                {
                    if (SubmitUpnpPropertyEvent(szUri, 0, 1, &Property))
                    {
                        TraceTag(ttidUpdiag, "Successfully submitted event to %s.", psvc->szEvtUrl);
                    }
                    else
                    {
                        dwErr =1;
                        TraceTag(ttidUpdiag, "Failed to submit event to %s! Error %d.",
                                 psvc->szEvtUrl, GetLastError());
                    }
                }
                else
                {
                    dwErr =1;
                    TraceTag(ttidUpdiag, "Failed to crack URL %s! Error %d.",
                             psvc->szEvtUrl, GetLastError());
                }

                delete [] Property.szValue;
            }
            else
            {
                dwErr =1;
                TraceTag(ttidUpdiag, "SzFromWsz (#2) failed");
            }
        }
        else
        {
            dwErr =1;
            TraceTag(ttidUpdiag, "SzFromWsz (#1) failed");
        }
    }
    else
    {
        dwErr =1;
        TraceTag(ttidUpdiag, "Failed to convert variable value to string. Error: %x.", hr);
    }

    return dwErr;
}

DWORD Do_Set(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_Set: set variable %s to constant %s", 
             pOpData->szVariableName, pOpData->mszConstantList);
    
    DWORD dwError = 0;
    Assert(cArgs == 0);

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        HRESULT hr = HrSetVariantValue(&pRow->varValue, pOpData->mszConstantList);
        if (S_OK != hr)
        {
            dwError =1;
        }
        else
        {
            dwError = dwSubmitEvent(psvc, pRow); 
        }
    }
    return dwError;
};

DWORD Do_Assign(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_Assign: assign variable %s to argument %s",
             pOpData->szVariableName, rgArgs[0].szValue);

    DWORD dwError = 0;
    Assert(cArgs == 1);

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // check if the new value is within the range or is in the allowed value list
        if (*pRow->mszAllowedValueList)
        {
            TCHAR * pNextString = pRow->mszAllowedValueList; 
            while (*pNextString && (lstrcmpi(rgArgs[0].szValue, pNextString) !=0))
            {
                pNextString += lstrlen(pNextString);
                pNextString ++;
            } 
            
            if (!*pNextString)
            {
                TraceTag(ttidUpdiag, "Do_Assign: new variable value is not in the allowed value list !");
                dwError =1;
            }
        }
        else if (*pRow->szMin)
        {
            Assert(*pRow->szMax);

            // This should only work if the variable is a number ??
            Assert(pRow->varValue.vt == VT_I4);
            if (pRow->varValue.vt == VT_I4)
            {
                long lMin = _ttol(pRow->szMin);
                long lMax = _ttol(pRow->szMax);
                long lVal = _ttol(rgArgs[0].szValue);

                if ((lVal<lMin) || (lVal>lMax))
                {
                    TraceTag(ttidUpdiag, "Do_Assign: new variable value is not in the allowed range !");
                    dwError =1;
                }
            }
        }

        if (!dwError)
        {
            HRESULT  hr = HrSetVariantValue(&pRow->varValue, rgArgs[0].szValue);
            if (S_OK != hr)
            {
                dwError =1;
            }
            else
            {
                dwError = dwSubmitEvent(psvc, pRow);
            }
        }
    }
    return dwError;
};

DWORD Do_Toggle(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_Toggle");
    
    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        Assert(pRow->varValue.vt == VT_BOOL);
        if (pRow->varValue.vt == VT_BOOL)
        {
            pRow->varValue.boolVal = ~pRow->varValue.boolVal;
            dwError = dwSubmitEvent(psvc, pRow);
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a boolean.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }

    return dwError;
};

DWORD Do_Increment(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_Increment");
    
    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if teh variable is a number ??
        Assert(pRow->varValue.vt == VT_I4);
        if (pRow->varValue.vt == VT_I4)
        {
            pRow->varValue.lVal++;
            dwError = dwSubmitEvent(psvc, pRow);
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a number.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }

    return dwError;
};

DWORD Do_Decrement(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_Decrement");

    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if teh variable is a number ??
        Assert(pRow->varValue.vt == VT_I4);
        if (pRow->varValue.vt == VT_I4)
        {
            pRow->varValue.lVal--;
            dwError = dwSubmitEvent(psvc, pRow);
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a number.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
};

DWORD Do_IncrementWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_IncrementWrap");

    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if the variable is a number ??
        Assert(pRow->varValue.vt == VT_I4);
        if (pRow->varValue.vt == VT_I4)
        {
            // get the max and min values from the constant list
            TCHAR * szMax = pOpData->mszConstantList;
            szMax += lstrlen(szMax)+1;
            
            long lMin = _ttol(pOpData->mszConstantList);
            long lMax = _ttol(szMax);

            Assert(lMax >= lMin);
            TraceTag(ttidUpdiag, "Do_IncrementWrap: variable= %d, min= %d, max= %d", 
                     pRow->varValue.lVal, lMin, lMax);

            pRow->varValue.lVal = lMin + ((pRow->varValue.lVal-lMin+1) % (lMax-lMin+1));
            Assert((lMin<=pRow->varValue.lVal) && (lMax>=pRow->varValue.lVal));

            dwError = dwSubmitEvent(psvc, pRow);
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a number.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
};

DWORD Do_DecrementWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_DecrementWrap");

    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if the variable is a number ??
        Assert(pRow->varValue.vt == VT_I4);
        if (pRow->varValue.vt == VT_I4)
        {
            // get the max and min values from the constant list
            TCHAR * szMax = pOpData->mszConstantList;
            szMax += lstrlen(szMax)+1;
            
            long lMin = _ttol(pOpData->mszConstantList);
            long lMax = _ttol(szMax);

            Assert(lMax >= lMin);
            TraceTag(ttidUpdiag, "Do_DecrementWrap: variable= %d, min= %d, max= %d", 
                     pRow->varValue.lVal, lMin, lMax);

            pRow->varValue.lVal = lMax - ((lMax-pRow->varValue.lVal+1) % (lMax-lMin+1));
            Assert((lMin<=pRow->varValue.lVal) && (lMax>=pRow->varValue.lVal));

            dwError = dwSubmitEvent(psvc, pRow);
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a number.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
};

DWORD Do_IncrementBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_IncrementBounded");

    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if the variable is a number ??
        Assert(pRow->varValue.vt == VT_I4);
        if (pRow->varValue.vt == VT_I4)
        {
            // max value is the only constant
            long lMax = _ttol(pOpData->mszConstantList);
            if (pRow->varValue.lVal < lMax)
            {
                pRow->varValue.lVal++;
                dwError = dwSubmitEvent(psvc, pRow);
            }
            else
            {
                TraceTag(ttidUpdiag, "IncrementBounded: variable %s already has the maximum value.", 
                         pOpData->szVariableName);
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a number.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
};

DWORD Do_DecrementBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_DecrementBounded");

    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if the variable is a number ??
        Assert(pRow->varValue.vt == VT_I4);
        if (pRow->varValue.vt == VT_I4)
        {
            // max value is the only constant
            long lMin = _ttol(pOpData->mszConstantList);

            if (pRow->varValue.lVal > lMin)
            {
                pRow->varValue.lVal--;
                dwError = dwSubmitEvent(psvc, pRow);
            }
            else
            {
                TraceTag(ttidUpdiag, "DecrementBounded: variable %s already has the minimal value.", 
                         pOpData->szVariableName);
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "Error: variable %s is not a number.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
};

DWORD dwMoveToNextString(UPNPSVC * psvc, OPERATION_DATA * pOpData, BOOL fWrap)
{
    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if the variable is a string
        // and we have a list of allowed values

        Assert(pRow->varValue.vt == VT_BSTR);
        if (pRow->varValue.vt == VT_BSTR)
        {
            if (lstrlen(pRow->mszAllowedValueList)>0)
            {
                TCHAR * pNextString = pRow->mszAllowedValueList; 
                while (*pNextString && (lstrcmpi(TszFromWsz(pRow->varValue.bstrVal), 
                                                pNextString) !=0))
                {
                    pNextString += lstrlen(pNextString);
                    pNextString ++;
                } 
                
                if (!*pNextString)
                {
                    TraceTag(ttidUpdiag, "dwSetToNextString: variable value is not in the allowed value list ??");
                    dwError =1;
                }
                else
                {
                    // is pNextString the last string in the list ?
                    TCHAR * pChar = pNextString + lstrlen(pNextString);
                    pChar++;
                    if (*pChar)
                    {
                        // not the last string
                        V_BSTR(&pRow->varValue) = SysAllocString(WszFromTsz(pChar));
                        dwError = dwSubmitEvent(psvc, pRow);
                    }
                    else if (fWrap)
                    {
                        V_BSTR(&pRow->varValue) = 
                                SysAllocString(WszFromTsz(pRow->mszAllowedValueList));
                        dwError = dwSubmitEvent(psvc, pRow);
                    }
                }
            }
            else
            {
                TraceTag(ttidUpdiag, "dwSetToNextString: variable %s has no list of allowed values.",
                         pOpData->szVariableName);

                dwError =1;
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "dwSetToNextString: variable %s is not a string.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
}

DWORD dwMoveToPrevString(UPNPSVC * psvc, OPERATION_DATA * pOpData, BOOL fWrap)
{
    DWORD dwError = 0;

    // find the SST row to update
    SST_ROW * pRow = FindSSTRowByVarName(&psvc->sst, pOpData->szVariableName);
    Assert(pRow);
    if (pRow)
    {
        // This should only work if the variable is a string
        // and we have a list of allowed values

        Assert(pRow->varValue.vt == VT_BSTR);
        if (pRow->varValue.vt == VT_BSTR)
        {
            if (lstrlen(pRow->mszAllowedValueList)>0)
            {
                TCHAR * pNextString = pRow->mszAllowedValueList;
                TCHAR * pPrevString = pNextString;

                while (*pNextString && (lstrcmpi(TszFromWsz(pRow->varValue.bstrVal), 
                                                pNextString) !=0))
                {
                    if (pPrevString != pNextString)
                    {
                        pPrevString = pNextString;
                    }

                    pNextString += lstrlen(pNextString);
                    pNextString++;
                } 
                
                if (!pNextString)
                {
                    TraceTag(ttidUpdiag, "dwSetToNextString: variable value is not in the allowed value list ??");
                    dwError =1;
                }
                else
                {
                    // is pNextString the first string in the list ?
                    if (pNextString != pPrevString)
                    {
                        // not the first string
                        V_BSTR(&pRow->varValue) = SysAllocString(WszFromTsz(pPrevString));
                        dwError = dwSubmitEvent(psvc, pRow);
                    }
                    else if (fWrap)
                    {
                        // go to the last string
                        pNextString += lstrlen(pNextString);
                        pNextString++;

                        while (*pNextString)
                        {
                            pPrevString = pNextString;

                            pNextString += lstrlen(pNextString);
                            pNextString++;
                        }

                        V_BSTR(&pRow->varValue) = SysAllocString(WszFromTsz(pPrevString));
                        dwError = dwSubmitEvent(psvc, pRow);
                    }
                }
            }
            else
            {
                TraceTag(ttidUpdiag, "dwMoveToPrevString: variable %s has no list of allowed values.",
                         pOpData->szVariableName);

                dwError =1;
            }
        }
        else
        {
            TraceTag(ttidUpdiag, "dwMoveToPrevString: variable %s is not a string.", 
                     pOpData->szVariableName);

            dwError =1;
        }
    }
    return dwError;
}

DWORD Do_NextStringWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_NextStringWrap");
    return dwMoveToNextString(psvc, pOpData, TRUE);
}

DWORD Do_PrevStringWrap(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_PrevStringWrap");
    return dwMoveToPrevString(psvc, pOpData, TRUE);
}

DWORD Do_NextStringBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_NextStringBounded");
    return dwMoveToNextString(psvc, pOpData, FALSE);
}

DWORD Do_PrevStringBounded(UPNPSVC * psvc, OPERATION_DATA * pOpData, DWORD cArgs, ARG *rgArgs)
{
    TraceTag(ttidUpdiag, "Do_PrevStringBounded");
    return dwMoveToPrevString(psvc, pOpData, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\iconutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdevicenode.cpp
//
//  Contents:   IUPnPDevice implementation for CUPnPDeviceNode, CUPnPIconNode
//
//  Notes:      The icon choosing algorithm was stolen from the implementation
//              of LookupIconIdFromDirectoryEx in
//                  ntos\w32\ntuser\client\clres.c
//              This code is only a slightly modified version of the
//              original code, tailored for our internal data types.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "upnpdevice.h"
#include "node.h"
#include "enumhelper.h"
#include "upnpservicenodelist.h"
#include "upnpdevicenode.h"         // CIconPropertiesNode definition
#include "iconutil.h"


/***************************************************************************\
* ulMyAbs (stolen from "MyAbs")
*
* Calcules my weighted absolute value of the difference between 2 nums.
* This of course normalizes values to >= zero.  But it also doubles them
* if valueHave < valueWant.  This is because you get worse results trying
* to extrapolate from uless info up then interpolating from more info down.
* I paid $150 to take the SAT.  I'm damned well going to get my vocab's
* money worth.
*
\***************************************************************************/

ULONG
ulMyAbs(LONG lValueHave,
        LONG lValueWant)
{
    LONG lDiff;

    lDiff = lValueHave - lValueWant;

    if (lDiff < 0)
    {
       lDiff = -2 * lDiff;
    }

    return lDiff;
}


/***************************************************************************\
* ulMatchImage (stolen from "MatchImage")
*
* This function takes ulPINTs for width & height in case of "real size".
* For this option, we use dimensions of 1st icon in resdir as size to
* uload, instead of system metrics.
*
* Returns a number that measures how "far away" the given image is
* from a desired one.  The value is 0 for an exact match.  Note that our
* formula has the following properties:
*     (1) Differences in width/height count much more than differences in
*         color format.
*     (2) Fewer colors give a smaller difference than more
*     (3) Bigger images are better than smaller, since shrinking produces
*             better results than stretching.
*
* The formula is the sum of the following terms:
*     ulog2(colors wanted) - ulog2(colors really), times -2 if the image
*         has more colors than we'd ulike.  This is because we will ulose
*         information when converting to fewer colors, ulike 16 color to
*         monochrome.
*     ulog2(width really) - ulog2(width wanted), times -2 if the image is
*         narrower than what we'd ulike.  This is because we will get a
*         better result when consolidating more information into a smaller
*         space, than when extrapolating from uless information to more.
*     ulog2(height really) - ulog2(height wanted), times -2 if the image is
*         shorter than what we'd ulike.  This is for the same reason as
*         the width.
*
* ulet's step through an example.  Suppose we want a 16 (4-bit) color, 32x32 image,
* and are choosing from the following ulist:
*     16 color, 64x64 image
*     16 color, 16x16 image
*      8 color, 32x32 image
*      2 color, 32x32 image
*
* We'd prefer the images in the following order:
*      8 color, 32x32         : Match value is 0 + 0 + 1     == 1
*     16 color, 64x64         : Match value is 1 + 1 + 0     == 2
*      2 color, 32x32         : Match value is 0 + 0 + 3     == 3
*     16 color, 16x16         : Match value is 2*1 + 2*1 + 0 == 4
*
\***************************************************************************/

ULONG
ulMatchImage(ULONG ulCurrentX,
             ULONG ulCurrentY,
             ULONG ulCurrentBpp,
             ULONG ulDesiredX,
             ULONG ulDesiredY,
             ULONG ulDesiredBpp)
{
    ULONG ulResult;

    ULONG ulBppScore;
    ULONG ulXScore;
    ULONG ulYScore;

    /*
     * Here are the rules for our "match" formula:
     *      (1) A close size match is much preferable to a color match
     *      (2) Fewer colors are better than more
     *      (3) Bigger icons are better than smaller
     */

    ulBppScore = ulMyAbs(ulCurrentBpp, ulDesiredBpp);
    ulXScore = ulMyAbs(ulCurrentX, ulDesiredX);
    ulYScore = ulMyAbs(ulCurrentY, ulDesiredY);

    ulResult = 2 * ulBppScore + ulXScore + ulYScore;

    return ulResult;
}


/***************************************************************************\
* pipnGetBestIcon (stolen from "GetBestImage")
*
* Among the different forms of images, choose the one that best matches the
* color format & dimensions of the request.  We try to match the size, then
* the color info.  So we find the item that
*
* (1) Has closest dimensions (smaller or bigger equally good) to minimize
*     the width, height difference
* (2) Has best colors.  We favor uless over more colors.
*
* If we find an identical match, we return immediately.
*
\***************************************************************************/

CIconPropertiesNode *
pipnGetBestIcon(LPCWSTR pszFormat,
                ULONG ulX,
                ULONG ulY,
                ULONG ulBpp,
                CIconPropertiesNode * pipnFirst)
{
    Assert(pszFormat);
    Assert(pipnFirst);

    CIconPropertiesNode * pipnTemp;
    CIconPropertiesNode * pipnBest;
    ULONG ulBestScore;

    pipnBest = NULL;
    // note: MAXULONG is defined in ntdef.h, which we don't have
    ulBestScore = (ULONG)-1;

    /*
     * uloop through resource entries, saving the "closest" item so far.  Most
     * of the real work is in MatchImage(), which uses a fabricated formula
     * to give us the results that we desire.  Namely, an image as close in
     * size to what we want preferring bigger over smaller, then an image
     * with the right color format
     */

    for (pipnTemp = pipnFirst; pipnTemp; pipnTemp = pipnTemp->m_pipnNext)
    {
        ULONG ulCurrentScore;
        BOOL fIsAcceptable;

        fIsAcceptable = FALSE;
        {
            // is this icon acceptable?
            int result;
            LPCWSTR pszTempFormat;

            pszTempFormat = pipnTemp->m_pszFormat;

            result = wcscmp(pszFormat, pszTempFormat);
            if (0 == result)
            {
                fIsAcceptable = TRUE;
            }
        }

        if (!fIsAcceptable)
        {
            continue;
        }

        {
            // is this icon preferable?

            ULONG ulCurrentX;
            ULONG ulCurrentY;
            ULONG ulCurrentBpp;

            ulCurrentX = pipnTemp->m_ulSizeX;
            ulCurrentY = pipnTemp->m_ulSizeY;
            ulCurrentBpp = pipnTemp->m_ulBitDepth;

            ulCurrentScore = ulMatchImage(ulCurrentX,
                                          ulCurrentY,
                                          ulCurrentBpp,
                                          ulX,
                                          ulY,
                                          ulBpp);
        }

        if (ulCurrentScore < ulBestScore)
        {
            // we've found a better match
            pipnBest = pipnTemp;
            ulBestScore = ulCurrentScore;
        }

        if (!ulBestScore)
        {
            // we've found an exact match
            break;
        }
    }

    // note: there may be no match at all, if no icons are of hte
    //       desired format
    return pipnBest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\tools\updiag\updiagp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P D I A G P . H
//
//  Contents:   Private definitions for UPDIAG
//
//  Notes:
//
//  Author:     danielwe   28 Oct 1999
//
//----------------------------------------------------------------------------
#ifndef _UPDIAGP_H
#define _UPDIAGP_H

#include <wininet.h>
#include <stdio.h>
#include "ssdpapi.h"
#include "updiag.h"
#include "util.h"

typedef BOOL (* PFNCMD)(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);

static const DWORD MAX_DEV              = 32;
static const DWORD MAX_SVC              = 32;
static const DWORD MAX_EVTSRC           = MAX_SVC;
static const DWORD MAX_CD               = 100;
static const DWORD MAX_UCP              = 5;
static const DWORD MAX_ARGS             = 8;
static const DWORD MAX_RESULT           = 32;
static const DWORD MAX_RESULT_MSGS      = 256;
static const DWORD MAX_DEV_STACK        = 8;

static const TCHAR c_szSeps[]   = TEXT(" \n\r\t");

struct COMMAND
{
    LPCTSTR     szCommand;
    LPCTSTR     szCmdDesc;
    DWORD       dwCtx;
    BOOL        fValidOnMillen;
    PFNCMD      pfnCommand;
    LPCTSTR     szUsage;
};

struct UPNPDEV
{
    BOOL        fRoot;

    UPNPSVC *   rgSvcs[MAX_SVC];
    DWORD       cSvcs;

    UPNPDEV *   rgDevs[MAX_DEV];
    DWORD       cDevs;

    TCHAR       szFriendlyName[256];
    TCHAR       szUdn[256];
    TCHAR       szDeviceType[256];
    TCHAR       szPresentationUrl[256];
    TCHAR       szManufaturer[256];
    TCHAR       szManufaturerUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR       szModelName[256];
    TCHAR       szModelNumber[256];
    TCHAR       szModelDesc[256];
    TCHAR       szModelUrl[INTERNET_MAX_URL_LENGTH];
    TCHAR       szUpc[256];
    TCHAR       szSerialNumber[256];

    HANDLE      hSvc[3];
};

enum RESULT_TYPE
{
    RES_SUBS,
    RES_FIND,
    RES_NOTIFY,
};

struct UPNPRESULT
{
    SSDP_MESSAGE *  rgmsgResult[MAX_RESULT_MSGS];
    DWORD           cResult;
    TCHAR           szType[256];
    HANDLE          hResult;
    RESULT_TYPE     resType;
};

struct UPNPUCP
{
    TCHAR           szName[256];
    UPNPRESULT *    rgResults[MAX_RESULT];
    DWORD           cResults;
};

enum ECMD_CONTEXT
{
    CTX_ROOT    = 0x00000001,       // Root context (start of app)
    CTX_DEVICE  = 0x00000002,       // Looking at specific device
    CTX_CD_SVC  = 0x00000004,       // Looking at specific service on CD
    CTX_EVTSRC  = 0x00000008,       // Looking at specific event source
    CTX_RESULT  = 0x00000010,       // Looking at specific search/subscription result
    CTX_UCP     = 0x00000020,       // Root of UCP context
    CTX_CD      = 0x00000040,       // Root of CD context
    CTX_UCP_SVC = 0x00000200,       // Looking at specific service on UCP

    CTX_AUTO    = 0x80000000,       // Automation only (won't appear in menus)
    CTX_ANY     = 0xFFFFFFFF,       // Any context
};

struct UPDIAG_CONTEXT
{
    ECMD_CONTEXT    ectx;
    UPNPDEV *       pdevCur[MAX_DEV_STACK];
    DWORD           idevStackIndex;
    UPNPSVC *       psvcCur;
    UPNPUCP *       pucpCur;
    UPNPRESULT *    presCur;
};

struct UPDIAG_PARAMS
{
    UPNPDEV *   rgCd[MAX_CD];
    DWORD       cCd;

    UPNPUCP *   rgUcp[MAX_UCP];
    DWORD       cUcp;
};

extern const DEMO_SERVICE_CTL c_rgSvc[];
extern const DWORD c_cDemoSvc;

extern UPDIAG_PARAMS    g_params;
extern UPDIAG_CONTEXT   g_ctx;
extern SHARED_DATA *    g_pdata;
extern HANDLE           g_hEvent;
extern HANDLE           g_hEventRet;
extern HANDLE           g_hEventCleanup;
extern HANDLE           g_hMutex;
extern HANDLE           g_hThreadTime;

VOID Usage(DWORD iCmd);
BOOL DoHelp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoBack(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoRoot(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoFindServices(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoListEventSources(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoExit(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoAlive(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoNothing(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSleep(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoInfo(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoPrompt(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoScript(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoNewCd(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoDelCd(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoNewUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoDelUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSwitchUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSwitchCd(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSwitchEs(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSwitchSvc(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSwitchSearch(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoUnsubscribe(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoNewService(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoListDevices(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoListUcp(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoListServices(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSubmitEvent(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoListProps(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
VOID DoEvtSrcInfo(VOID);
BOOL DoSubscribe(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);

BOOL DoListUpnpResultMsgs(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoListUpnpResults(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoSwitchResult(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoDelResult(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);

BOOL DoPrintSST(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);
BOOL DoPrintActionSet(DWORD iCmd, DWORD cArgs, LPTSTR *rgArgs);

VOID NotifyCallback(SSDP_CALLBACK_TYPE ct,
                    CONST SSDP_MESSAGE *pSsdpService,
                    LPVOID pContext);

DWORD WINAPI RequestHandlerThreadStart(LPVOID pvParam);

VOID CleanupUcp(UPNPUCP *pucp);
VOID CleanupCd(UPNPDEV *pcd);
VOID CleanupResult(UPNPRESULT *psrch);
VOID CleanupService(UPNPSVC *psvc);

UPNPSVC *PSvcFromId(LPCTSTR szId);

VOID LocalFreeSsdpMessage(PSSDP_MESSAGE pSsdpMessage);

DWORD WINAPI TimeThreadProc(LPVOID lpvThreadParam);

// Device stack functions
//
UPNPDEV *PDevCur(VOID);
VOID PushDev(UPNPDEV *pdev);
UPNPDEV *PopDev(VOID);

// For filetime coversions
//
#define _SECOND ((__int64) 10000000)
#define _MINUTE (60 * _SECOND)
#define _HOUR   (60 * _MINUTE)
#define _DAY    (24 * _HOUR)

#endif // _UPDIAGP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpcommon.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P C O M M O N . C P P
//
//  Contents:   Common functions for upnp.dll
//
//  Notes:
//
//  Author:     jeffspr   11 Nov 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ssdpapi.h"
#include "upnpcommon.h"
#include "ncbase.h"         // HrFromLastWin32Error



// we need to remember whether or not SsdpStartup succeeded.
// If it didn't, we must not call SsdpCleanup later
//

HRESULT
HrSsdpStartup(BOOL * pfSsdpInitialized)
{
    Assert(pfSsdpInitialized);

    HRESULT hr;
    BOOL fResult;

    hr = S_OK;

    fResult = SsdpStartup();
    if (!fResult)
    {
        hr = HrFromLastWin32Error();
        goto Cleanup;
    }

Cleanup:
    *pfSsdpInitialized = fResult;

    TraceError("HrSsdpStartup", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdescriptiondoc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdescriptiondoc.cpp
//
//  Contents:   IUPnPDevice implementation for CUPnPDescriptionDoc
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "node.h"
#include "enumhelper.h"
#include "upnpservicenodelist.h"
#include "upnpdevicenode.h"
#include "upnpdocument.h"
#include "upnpdescriptiondoc.h"
#include "ssdpapi.h"
#include <nccom.h>
#include "upnpxmltags.h"
#include "testtarget.h"

VOID
InvokeCallback(IDispatch * pdisp, HRESULT hrLoadResult)
{
    Assert(pdisp);

    HRESULT hr;
    DISPPARAMS dispparams;
    VARIANT vtArg1;

    ::ZeroMemory(&dispparams, sizeof(DISPPARAMS));
    ::VariantInit(&vtArg1);

    V_VT(&vtArg1) = VT_I4;
    V_I4(&vtArg1) = hrLoadResult;

    dispparams.rgvarg = &vtArg1;
    dispparams.cArgs = 1;

    hr = pdisp->Invoke(DISPID_VALUE,
                       IID_NULL,
                       LOCALE_USER_DEFAULT,
                       DISPATCH_METHOD,
                       &dispparams,
                       NULL,
                       NULL,
                       NULL);

    if (FAILED(hr))
    {
        TraceTag(ttidUPnPDescriptionDoc, "OBJ: InvokeCallback: IDispatch::Invoke returned, hr=%x", hr);
    }

    ::VariantClear(&vtArg1);
}


CUPnPDescriptionDoc::CUPnPDescriptionDoc()
{
    _pudn = NULL;
    _punkCallback = NULL;
}

CUPnPDescriptionDoc::~CUPnPDescriptionDoc()
{
    Assert(!_pudn);
    Assert(!_punkCallback);
}


HRESULT
CUPnPDescriptionDoc::FinalConstruct()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::FinalConstruct");

    HRESULT hr;

    hr = CUPnPDocument::FinalConstruct();

    TraceError("CUPnPDescriptionDoc::FinalConstruct", hr);
    return hr;
}

HRESULT
CUPnPDescriptionDoc::FinalRelease()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::FinalRelease");

    HRESULT hr;

    // note: this will recursively delete the whole device tree
    //       and disconnect any bogus old wrappers
    if (_pudn)
    {
        delete _pudn;
        _pudn = NULL;
    }

    // we do this here so that we don't fire the callback while we're shutting
    // down.  Resultantly, if the client does the following:
    //   start an async load
    //   release us before the load completest without calling Abort()
    // we won't call their _punkCallback.

    SAFE_RELEASE(_punkCallback);

    hr = CUPnPDocument::FinalRelease();

    TraceError("CUPnPDescriptionDoc::FinalRelease", hr);
    return hr;
}


HRESULT
CUPnPDescriptionDoc::Initialize(LPVOID pvCookie)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::Initialize");

    IUnknown * punkCallback;

    punkCallback = (IUnknown *)pvCookie;

    SAFE_RELEASE(_punkCallback);

    if (punkCallback)
    {
        punkCallback->AddRef();
        _punkCallback = punkCallback;
    }

    // note: this will recursively delete the whole device tree
    //       and disconnect any bogus old wrappers
    if (_pudn)
    {
        delete _pudn;
        _pudn = NULL;
    }

    return S_OK;
}


HRESULT
CUPnPDescriptionDoc::OnLoadComplete()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::OnLoadComplete");

    Assert(GetXMLDocument());

    HRESULT hr;
    IXMLDOMElement * pxde;
    IXMLDOMNode * pxdnDevice;
    BSTR bstrUrlBase;
    CUPnPDeviceNode * pudnRoot;

    hr = S_OK;
    pxde = NULL;
    pxdnDevice = NULL;
    bstrUrlBase = NULL;
    pudnRoot = NULL;

    hr = GetXMLDocument()->get_documentElement(&pxde);
    if (S_OK != hr)
    {
        TraceError("OBJ: CUPnPDescriptionDoc::OnLoadComplete - get_documentElement", hr);
        pxde = NULL;

        hr = E_FAIL;
        goto Error;
    }
    Assert(pxde);

    // we _should_ have a reference to the "<root>" element.
    // make sure that we do, or barf.
    {
        // note: IXMLDOMElement inherits from IXMLDOMNode
        //
        if (!FIsThisTheNodeName(pxde, XMLTags::pszElementRoot))
        {
            hr = UPNP_E_ROOT_ELEMENT_EXPECTED;
            goto Error;
        }
    }

    // Validation for duplicate URLBase element - Updated by Guru
    hr = HrCheckForDuplicateElement(pxde, XMLTags::pszBaseUrl);
    if(SUCCEEDED(hr))
    {
        hr = HrGetTextValueFromChildElement(pxde, &XMLTags::pszBaseUrl, 1, &bstrUrlBase);
    }
    if (FAILED(hr))
    {
        bstrUrlBase = NULL;

        hr = E_FAIL;
        goto Error;
    }
    else if (S_OK == hr)
    {
        // we found an URLBase tag.  set our base url appropriately.
        // we realease the bstr in Cleanup.

        if ( bstrUrlBase && *bstrUrlBase )
        {
            if(ValidateTargetUrlWithHostUrlW(m_bstrFullUrl,bstrUrlBase))
            {
                SetBaseUrl(bstrUrlBase);
            }
            else
            {
                hr = E_FAIL;
                goto Error;      
            }
        }		   

    }
    // the URLBase tag is optional.

    // now let's create the "root device".  its initialization will create
    // the nested device tree.  yeah, recursion.... I guess...


    hr = HrGetNestedChildElement(pxde, &XMLTags::pszDevice, 1, &pxdnDevice);
    if (FAILED(hr))
    {
        pxdnDevice = NULL;

        hr = E_FAIL;
        goto Error;
    }
    else if (S_FALSE == hr)
    {
        Assert(!pxdnDevice);

        hr = UPNP_E_DEVICE_ELEMENT_EXPECTED;
        goto Error;
    }
    Assert(S_OK == hr);

    pudnRoot = new CUPnPDeviceNode();
    if (!pudnRoot)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // this will addref pxdnDevice
    hr = pudnRoot->HrInit(pxdnDevice, this, m_bstrFullUrl);
    if (FAILED(hr))
    {
        goto Error;
    }

    // yeah, everything looks reasonable.  we're like set up and stuff.
    hr = S_OK;
    delete _pudn;
    _pudn = pudnRoot;

Cleanup:
    SAFE_RELEASE(pxde);
    SAFE_RELEASE(pxdnDevice);
    ::SysFreeString(bstrUrlBase);

    TraceError("CUPnPDescriptionDoc::OnLoadComplete", hr);
    return hr;

Error:
    if (pudnRoot)
    {
        delete pudnRoot;
    }

    goto Cleanup;
}


HRESULT
CUPnPDescriptionDoc::OnLoadReallyDone()
{
    // our load (successful or not) has completed.
    HRESULT hr;
    HRESULT hrLoadResult;

    hrLoadResult = GetLoadResult();

    hr = HrFireCallback(hrLoadResult);

    SAFE_RELEASE(_punkCallback);

    TraceError("CUPnPDescriptionDoc::OnLoadReallyDone", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::get_ReadyState(long * plReadyState)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::get_GetReadyState");

    HRESULT hr;
    READYSTATE rs;

    hr = S_OK;

    if (!plReadyState)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    rs = GetReadyState();
    *plReadyState = rs;

Cleanup:
    TraceError("CUPnPDescriptionDoc::get_GetReadyState", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::Load(/* [in] */ BSTR bstrUrl)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::Load");

    HRESULT hr;

    if (!bstrUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = SyncLoadFromUrl(bstrUrl);

Cleanup:
    TraceError("CUPnPDescriptionDoc::Load", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::LoadAsync(/* [in] */ BSTR bstrUrl,
                               /* [in] */ IUnknown * punkCallback)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::LoadAsync");

    HRESULT hr;

    if (!bstrUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!punkCallback)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // make sure punkCallback implements one of our two interfaces
    {
        // try for IUPnPDescriptionDocumentCallback
        BOOL fIsSupported;

        fIsSupported = FSupportsInterface(punkCallback, IID_IUPnPDescriptionDocumentCallback);

        if (!fIsSupported)
        {
            // or at least IDispatch
            fIsSupported = FSupportsInterface(punkCallback, IID_IDispatch);
        }

        if (!fIsSupported)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    hr = AsyncLoadFromUrl(bstrUrl, punkCallback);

Cleanup:
    TraceError("CUPnPDescriptionDoc::LoadAsync", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::get_LoadResult(/* [out] */ long * plError)
{
    TraceTag(ttidUPnPDescriptionDoc, "CUPnPDescriptionDoc::get_LoadResult");

    HRESULT hr;

    hr = E_POINTER;

    if (plError)
    {
        hr = S_OK;

        // delegate to the internal method
        *plError = GetLoadResult();
    }

    TraceError("CUPnPDescriptionDoc::get_LoadResult", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::Abort()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::Abort");

    HRESULT hr;

    // we don't call/free _punkCallback here because this isn't the only way
    // for the load to be aborted - it can also be aborted in
    // CUPnPDocumentBSC::OnProgress.  Instead, we just rely OnLoadReallyDone
    // being called, as we do for everything else.

    // delegate to the internal method
    hr = AbortLoading();

    TraceError("CUPnPDescriptionDoc::Abort", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::RootDevice(IUPnPDevice **ppudRootDevice)
{
     TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::RootDevice");

    HRESULT hr;
    IUPnPDevice * pud;

    hr = E_FAIL;
    pud = NULL;

    if (!ppudRootDevice)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (_pudn)
    {
        hr = _pudn->HrGetWrapper(&pud);
    }

    *ppudRootDevice = pud;

Cleanup:
    TraceError("CUPnPDescriptionDoc::RootDevice", hr);
    return hr;
}


STDMETHODIMP
CUPnPDescriptionDoc::DeviceByUDN(BSTR bstrUDN, IUPnPDevice ** ppudDevice)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::DeviceByUDN");

    HRESULT hr;
    CUPnPDeviceNode * pudnMatch;
    IUPnPDevice * pudResult;

    pudResult = NULL;

    if (!bstrUDN)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!ppudDevice)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!_pudn)
    {
        hr = E_PENDING;
        goto Cleanup;
    }

    pudnMatch = _pudn->UdnGetDeviceByUdn(bstrUDN);
    if (pudnMatch)
    {
        // we have a match
        hr = pudnMatch->HrGetWrapper(&pudResult);
        Assert(FImplies(SUCCEEDED(hr), pudResult));
        Assert(FImplies(FAILED(hr), !pudResult));
    }
    else
    {
        // the UDN wasn't found
        hr = E_FAIL;
    }

    *ppudDevice = pudResult;

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), pudResult));
    Assert(FImplies(FAILED(hr), !pudResult));

    TraceError("CUPnPDescriptionDoc::DeviceByUDN", hr);
    return hr;
}


HRESULT
CUPnPDescriptionDoc::HrFireCallback(HRESULT hrLoadResult)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::HrFireCallback");

    IUPnPDescriptionDocumentCallback * puddc;
    HRESULT hr;

    hr = S_OK;
    puddc = NULL;

    if (!_punkCallback)
    {
        // no callback to call, no big deal
        goto Cleanup;
    }

    // Figure out what type of callback pointer we have from the
    // IUnknown. It can be one of 2 possibilities. Either it is
    // a C/C++ callback in which case the interface would be
    // IUPnPDescriptionDocumentCallback, or it can be from script,
    // in which case it would be IDispatch. If it's neither, then
    // we can't do anything.
    //

    hr = _punkCallback->QueryInterface(IID_IUPnPDescriptionDocumentCallback,
                                       (LPVOID *)&puddc);
    if (SUCCEEDED(hr))
    {
        // we have a IUPnPDescriptionDocumentCallback client
        Assert(puddc);

        hr = puddc->LoadComplete(hrLoadResult);
        if (FAILED(hr))
        {
            TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDescriptionDoc::HrFireCallback:"
                     "IUPnPDescriptionDocumentCallback::LoadComplete returned, hr=%x", hr);
        }
        hr = S_OK;

        puddc->Release();
    }
    else
    {
        Assert(FAILED(hr));

        IDispatch * pdisp;

        pdisp = NULL;

        if (E_NOINTERFACE != hr)
        {
            // we have a genuine error from the QI
            TraceError("CUPnPDescriptionDoc::HrFireCallback, QI #1", hr);
            goto Cleanup;
        }

        // we don't have a IUPnPDescriptionDocumentCallback client, so
        // see if it can use IDispatch
        //

        hr = _punkCallback->QueryInterface(IID_IDispatch,
                                           (LPVOID *)&pdisp);
        if (SUCCEEDED(hr))
        {
            Assert(pdisp);

            InvokeCallback(pdisp, hrLoadResult);

            hr = S_OK;

            pdisp->Release();
        }
        else
        {
            Assert(FAILED(hr));

            if (E_NOINTERFACE != hr)
            {
                // we have a genuine error
                TraceError("CUPnPDescriptionDoc::HrFireCallback, QI #2", hr);
                goto Cleanup;
            }

            // this really doesn't bother us too much, but shouldn't ever
            // happen; we've already made sure that _punkCallback supports
            // one of these two interfaces before we initialized it.
            //
            AssertSz(FALSE, "OBJ: CUPnPDescriptionDoc::HrFireCallback:"
                     "supplied punkCallback doesn't support nothin'!");
        }
    }

Cleanup:
    TraceError("CUPnPDescriptionDoc::HrFireCallback", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdevices.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdevices.cpp
//
//  Contents:   Implementation of CUPnPDevices, our IUPnPDevices object
//
//  Notes:      Also implements CEnumHelper so that the generic enumerator
//              classes can use it.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "enumhelper.h"
#include "UPnPDevices.h"
#include "UPnPDevice.h"
#include "upnpenumerator.h"


/////////////////////////////////////////////////////////////////////////////
// CUPnPDevices


CUPnPDevices::CUPnPDevices()
{
    m_pdlnFirst = NULL;
    m_pdlnLast = NULL;
}

CUPnPDevices::~CUPnPDevices()
{
    Assert(!m_pdlnFirst);
    Assert(!m_pdlnLast);
}

HRESULT
CUPnPDevices::FinalConstruct()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDevices::FinalConstruct");

    return S_OK;
}

HRESULT
CUPnPDevices::FinalRelease()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDevices::FinalRelease");

    DEVICE_LIST_NODE * pdlnCurrent;

    pdlnCurrent = m_pdlnFirst;
    while (pdlnCurrent)
    {
        DEVICE_LIST_NODE * pdlnNext;

        pdlnNext = pdlnCurrent->m_pdlnNext;

        Assert(pdlnCurrent->m_pud);
        pdlnCurrent->m_pud->Release();

        delete pdlnCurrent;

        pdlnCurrent = pdlnNext;
    }

    m_pdlnFirst = NULL;
    m_pdlnLast = NULL;

    return S_OK;
}

STDMETHODIMP
CUPnPDevices::get_Count(LONG * plCount)
{
    TraceTag(ttidUPnPDescriptionDoc, "CUPnPDevices::get_Count");

    HRESULT hr;
    LONG lCount;
    DEVICE_LIST_NODE * pdlnCurrent;

    if (!plCount)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = S_OK;
    lCount = 0;

    pdlnCurrent = m_pdlnFirst;

    while (pdlnCurrent)
    {
        ++lCount;
        pdlnCurrent = pdlnCurrent->m_pdlnNext;

        if (lCount < 0)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }

    *plCount = lCount;

Cleanup:
    TraceError("CUPnPDevices::get_Count", hr);
    return hr;
}

STDMETHODIMP
CUPnPDevices::get__NewEnum(LPUNKNOWN * ppunk)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDevices::get__NewEnum");

    HRESULT hr;

    if (ppunk)
    {
        // init the enumerator.  we maintain the list of devices for this
        // enumerator, (via CEnumHelper) so it refcounts *US* to make sure
        // that we stay around as long as it does, even if our client frees
        // all explicit references to us.

        IUnknown * punk;
        CEnumHelper * peh;
        LPVOID pvCookie;

        punk = GetUnknown();
        peh = this;
        pvCookie = GetFirstItem();

        hr = CUPnPEnumerator::HrCreateEnumerator(punk,
                                                 peh,
                                                 pvCookie,
                                                 ppunk);
    }
    else
    {
        hr = E_POINTER;
    }

    TraceError("CUPnPDevices::get__NewEnum", hr);
    return hr;
}

DEVICE_LIST_NODE *
CUPnPDevices::pdlnFindDeviceByUdn(LPCWSTR pszUdn)
{
    Assert(pszUdn);

    DEVICE_LIST_NODE * pdln;

    pdln = m_pdlnFirst;

    while (pdln)
    {
        HRESULT hr;
        IUPnPDevice * pudCurrent;
        BSTR bstrCurrentUdn;

        pudCurrent = pdln->m_pud;
        Assert(pudCurrent);

        bstrCurrentUdn = NULL;
        hr = pudCurrent->get_UniqueDeviceName(&bstrCurrentUdn);
        if (SUCCEEDED(hr))
        {
            Assert(S_OK == hr);
            Assert(bstrCurrentUdn);

            int result;

            result = wcscmp(pszUdn, bstrCurrentUdn);

            ::SysFreeString(bstrCurrentUdn);

            if (0 == result)
            {
                // we found a match
                break;
            }
        }
        else
        {
            // we ignore errors here.  since a device collection
            // can be made up of a bunch of independant documents,
            // it's possible for one of these documents to be
            // in a gimped state, while the others work just fine.
            // one broken document shouldn't keep the collection
            // from working.
        }

        pdln = pdln->m_pdlnNext;
    }

    return pdln;
}

STDMETHODIMP
CUPnPDevices::get_Item(BSTR bstrUDN,
                       IUPnPDevice ** ppDevice)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDevices::get_Item");

    HRESULT hr;
    DEVICE_LIST_NODE * pdlnMatchingNode;
    IUPnPDevice * pudResult;

    hr = E_INVALIDARG;
    pudResult = NULL;

    if (!bstrUDN)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!ppDevice)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pdlnMatchingNode = pdlnFindDeviceByUdn(bstrUDN);

    if (pdlnMatchingNode)
    {
        // we found a matching node.  woo hoo.

        pudResult = pdlnMatchingNode->m_pud;
        pudResult->AddRef();

        hr = S_OK;
    }

    *ppDevice = pudResult;

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), pudResult));
    Assert(FImplies(FAILED(hr), !pudResult));

    TraceError("CUPnPDevices::get_Item", hr);
    return hr;
}

LPVOID
CUPnPDevices::GetFirstItem()
{
    return (LPVOID)m_pdlnFirst;
}

DEVICE_LIST_NODE *
GetNthChild(DEVICE_LIST_NODE * pdlnStart, ULONG ulNeeded, ULONG * pulSkipped)
{
    // note(cmr): If you change this, you probably want to change GetNthChild in
    //            upnpservicenodelist.cpp as well

    Assert(pdlnStart);

    DEVICE_LIST_NODE * pdlnTemp;
    ULONG ulCount;

    ulCount = 0;
    pdlnTemp = pdlnStart;
    for ( ; (ulCount < ulNeeded) && pdlnTemp; ++ulCount)
    {
        pdlnTemp = pdlnTemp->m_pdlnNext;
    }

    if (pulSkipped)
    {
        *pulSkipped = ulCount;
    }

    Assert(ulCount <= ulNeeded);
    Assert(FImplies((ulCount < ulNeeded), !pdlnTemp));

    return pdlnTemp;
}

LPVOID
CUPnPDevices::GetNextNthItem(ULONG ulSkip,
                             LPVOID pvCookie,
                             ULONG * pulSkipped)
{
    Assert(pvCookie);

    DEVICE_LIST_NODE * pdlnCurrent;
    DEVICE_LIST_NODE * pdlnResult;

    pdlnCurrent = (DEVICE_LIST_NODE *)pvCookie;

    pdlnResult = GetNthChild(pdlnCurrent, ulSkip, pulSkipped);

    return pdlnResult;
}

HRESULT
CUPnPDevices::GetPunk(LPVOID pvCookie, IUnknown ** ppunk)
{
    Assert(pvCookie);
    Assert(ppunk);

    DEVICE_LIST_NODE * pdlnCurrent;
    IUPnPDevice * pud;
    IUnknown * punkResult;

    pdlnCurrent = (DEVICE_LIST_NODE *)pvCookie;

    pud = pdlnCurrent->m_pud;
    Assert(pud);

    punkResult = pud;
    punkResult->AddRef();

    *ppunk = punkResult;

    return S_OK;
}

// AddRef() pud and stick it at the end of the list.
// pud must not be NULL;
HRESULT
CUPnPDevices::HrAddDevice(IUPnPDevice * pud)
{
    Assert(pud);

    HRESULT hr;
    DEVICE_LIST_NODE * pdlnNew;

    pdlnNew = new DEVICE_LIST_NODE;
    if (!pdlnNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // initialize new node
    pud->AddRef();
    pdlnNew->m_pud = pud;

    pdlnNew->m_pdlnNext = NULL;

    // add it to the list
    AddToEnd(pdlnNew);

    hr = S_OK;

Cleanup:
    return hr;
}


void
CUPnPDevices::AddToEnd(DEVICE_LIST_NODE * pdlnNew)
{
    Assert(pdlnNew);

    if (!m_pdlnLast)
    {
        // we have our first element

        Assert(!m_pdlnFirst);

        m_pdlnFirst = pdlnNew;
    }
    else
    {
        // add it to the end of our current list of elements

        Assert(!(m_pdlnLast->m_pdlnNext));
        m_pdlnLast->m_pdlnNext = pdlnNew;
    }

    m_pdlnLast = pdlnNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdevicefinder.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       U P N P D E V I C E F I N D E R . C P P
//
//  Contents:   Implementation of CUPnPDeviceFinder
//
//  Notes:
//
//  Author:     jeffspr   18 Nov 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "upnpdefs.h"
#include "UPnPDocument.h"
#include "UPnPDescriptionDoc.h"
#include "UPnPDeviceFinder.h"
#include "upnpcommon.h"
#include "ssdpapi.h"
#include "ncstring.h"
#include "ncbase.h"
#include "nccom.h"
#include "ncutil.h"
#include "ncinet2.h"
#include "testtarget.h"


//---[ Globals ]--------------------------------------------------------------

// Default to 20 second timeout
static const DWORD c_cmsecFindByUdnTimeout = 20000;

// same timeout for FindByType
static const DWORD c_cmsecFindByTypeTimeout = 20000;

CFinderCollector g_finderCollector;


static LIST_ENTRY g_listDelayedDownload;
static CRITICAL_SECTION g_csDelayedDownload;
static int      g_initDelayedDownload = 0;

struct CALLBACK_PARAMS
{
    LIST_ENTRY linkage;

    SSDP_CALLBACK_TYPE      sctType;
    SSDP_MESSAGE *          pSsdpMessage;
    LPVOID                  pContext;
    HANDLE                  hTimer;
};

VOID InitDelayedDownloadList();
VOID TermDelayedDownloadList();
VOID AddToDelayedDownloadList(CALLBACK_PARAMS* pcp);
BOOL RemoveMatchFromDelayedDownloadList(SSDP_MESSAGE* pSsdpMessage, LPVOID pContext);
BOOL RemoveFromDelayedDownloadList(CALLBACK_PARAMS* pcp);
VOID PurgeContextFromDelayedDownloadList(LPVOID pContext);
VOID TestDelayedDownloadsDone(LPVOID pContext);


/////////////////////////////////////////////////////////////////////////////
// CUPnPDeviceFinder

#ifdef ENABLETRACE
#define TraceSsdpMessage    __TraceSsdpMessage
#else
#define TraceSsdpMessage    NOP_FUNCTION
#endif // ENABLETRACE

VOID __TraceSsdpMessage(SSDP_CALLBACK_TYPE sctType,
                      CONST SSDP_MESSAGE * pSsdpMessage)
{
    CHAR szMsgType[30];

    switch(sctType)
    {
        case SSDP_ALIVE:
            strcpy(szMsgType, "SSDP_ALIVE");
            break;
        case SSDP_BYEBYE:
            strcpy(szMsgType, "SSDP_BYEBYE");
            break;
        case SSDP_DONE:
            strcpy(szMsgType, "SSDP_DONE");
            break;
        case SSDP_FOUND:
            strcpy(szMsgType, "SSDP_FOUND");
            break;
        case SSDP_DEAD:
            return;
        default:
            AssertSz(FALSE, "What the? Who invented a new SSDP message type?");
            strcpy(szMsgType, "<Unknown message type>");
            break;
    }

    TraceTag(ttidUPnPDeviceFinder, "Callback Info:");
    TraceTag(ttidUPnPDeviceFinder, "--------------");
    TraceTag(ttidUPnPDeviceFinder, "Msg Type   : %s", szMsgType);

    if (pSsdpMessage)
    {
        TraceTag(ttidUPnPDeviceFinder, "Dev Type   : %s",
            pSsdpMessage->szType ? pSsdpMessage->szType : "<not present>");
        TraceTag(ttidUPnPDeviceFinder, "USN        : %s",
            pSsdpMessage->szUSN ? pSsdpMessage->szUSN : "<not present>");
        TraceTag(ttidUPnPDeviceFinder, "SID        : %s",
            pSsdpMessage->szUSN ? pSsdpMessage->szSid : "<not present>");
        TraceTag(ttidUPnPDeviceFinder, "AltHeaders : %s",
            pSsdpMessage->szAltHeaders ? pSsdpMessage->szAltHeaders : "<not present>");
        TraceTag(ttidUPnPDeviceFinder, "LocHeaders : %s",
            pSsdpMessage->szLocHeader ? pSsdpMessage->szLocHeader : "<not present>");
        TraceTag(ttidUPnPDeviceFinder, "Content    : %s",
            pSsdpMessage->szContent ? pSsdpMessage->szContent : "<not present>");
        TraceTag(ttidUPnPDeviceFinder, "LifeTime   : %d", pSsdpMessage->iLifeTime);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   BstrUdnFromUsn
//
//  Purpose:    Helper function to get the UDN of a device from the szUsn
//              field of the SSDP_MESSAGE struct.
//
//  Arguments:
//      szUsn [in]  USN field of SSDP_MESSAGE struct
//
//  Returns:    BSTR of UDN
//
//  Author:     danielwe   17 Jan 2000
//
//  Notes:      this looks for the first occurance of "::" in the
//              specified string, and, if found, copies all the characters
//              preceeding it into a newly-allocated BSTR.  If "::" isn't
//              found, it copies the entire string.
//
BSTR BstrUdnFromUsn(LPCSTR szUsn)
{
    Assert(szUsn);

    CONST WCHAR rgszSearch [] = L"::";

    BSTR    bstrReturn;
    UINT    cch;
    LPWSTR  szw;

    bstrReturn = NULL;
    cch = 0;

    // Note(cmr): please DO NOT write to szUsn.  We might not own it.
    //
    szw = WszFromSz(szUsn);
    if (szw)
    {
        LPWSTR pch;

        pch = wcsstr(szw, rgszSearch);
        if (pch)
        {
            *pch = '\0';
        }

        bstrReturn = ::SysAllocString(szw);

        delete [] szw;
    }

    return bstrReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInvokeCallback
//
//  Purpose:    Invokes the callback function for an asynchronous find
//              operation.
//
//  Arguments:
//      pdisp   [in]  IDispatch pointer to callback function
//      dfcType [in]  Type of callbck (DFC_NEW_DEVICE, DFC_REMOVE_DEVICE, DFC_DONE)
//      bstrUdn [in]  UDN of device
//      pdispObj[in]  IDispatch of device (can be NULL for remove or done)
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:
//
HRESULT HrInvokeCallback(IDispatch *pdisp, DFC_TYPE dfcType, BSTR bstrUdn,
                         IDispatch *pdispObj)
{
    VARIANT     ary_vaArgs[3];
    VARIANT     vaResult;
    HRESULT     hr = S_OK;

    VariantInit(&ary_vaArgs[2]);
    VariantInit(&ary_vaArgs[1]);

    switch (dfcType)
    {
        case DFC_NEW_DEVICE:
            ary_vaArgs[2].vt = VT_DISPATCH;
            V_DISPATCH(&ary_vaArgs[2]) = pdispObj;

            ary_vaArgs[1].vt = VT_BSTR;
            V_BSTR(&ary_vaArgs[1]) = bstrUdn;
            break;

        case DFC_REMOVE_DEVICE:
            ary_vaArgs[1].vt = VT_BSTR;
            V_BSTR(&ary_vaArgs[1]) = bstrUdn;

            Assert(!pdispObj);
            break;

        case DFC_DONE:
            Assert(!bstrUdn);
            Assert(!pdispObj);
            break;

        default:
            AssertSz(FALSE, "Invalid find callback type!");
            break;
    }

    VariantInit(&ary_vaArgs[0]);
    ary_vaArgs[0].vt = VT_I4;
    V_I4(&ary_vaArgs[0]) = dfcType;

    DISPPARAMS  dispParams = {ary_vaArgs, NULL, 3, 0};

    VariantInit(&vaResult);

    EXCEPINFO   exInfo;

    hr = pdisp->Invoke(0, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD,
                       &dispParams, &vaResult, &exInfo,  NULL);

    TraceError("HrInvokeCallback", hr);
    return hr;
}


VOID
FreeFinder(CComObject<CUPnPDeviceFinderCallback> * pdfc)
{
    Assert(pdfc)

    // deinit the search object. This will stop the search a-la ssdp
    pdfc->DeInitSsdp();

    if (!pdfc->IsBusy())
    {
        pdfc->DeInit();
        // free the search object
        pdfc->Release();
        TraceTag(ttidUPnPDeviceFinder, "Freed finder 0x%08X.", pdfc);
    }
    else
    {
        g_finderCollector.Add(pdfc);
        TraceTag(ttidUPnPDeviceFinder, "Unable to free finder 0x%08X - adding to global list.", pdfc);
    }
}

VOID
FreeLoader(DFC_DOCUMENT_LOADING_INFO * pdfdli)
{
    Assert(pdfdli);
    Assert(pdfdli->m_pdoc);
    Assert(pdfdli->m_bstrUDN);
    Assert(pdfdli->m_cbfCallbackFired != DFC_CBF_CURRENTLY_FIRING);

    pdfdli->m_pdoc->Release();
    pdfdli->m_pdoc = NULL;

    ::SysFreeString(pdfdli->m_bstrUDN);
    if (pdfdli->m_bstrUrl)
        ::SysFreeString(pdfdli->m_bstrUrl);

    delete pdfdli;

    TraceTag(ttidUPnPDeviceFinder, "Freed loader 0x%08X.", pdfdli);
}

CUPnPDeviceFinder::CUPnPDeviceFinder()
{
    InitializeListHead(&m_FinderList);
    m_fSsdpInitialized = FALSE;

    // we do this so that the first few cookies allocated by
    // different finders are likely to be different.  If a user
    // then tries to pass a cookie returned by one finder to
    // a second finder, it's a little bit more likely that the
    // call will fail.  Hopefully, this will allow users to
    // find bugs in their code, and not lead them to mistakenly
    // assume that these cookies are globally unique or anything.
    //
    m_lNextFinderCookie = PtrToLong(this);
}

HRESULT
CUPnPDeviceFinder::FinalConstruct()
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::FinalConstruct");

    HRESULT hr;

    InitDelayedDownloadList();

    hr = HrSsdpStartup(&m_fSsdpInitialized);
    Assert(FImplies(SUCCEEDED(hr), m_fSsdpInitialized));
    Assert(FImplies(FAILED(hr), !m_fSsdpInitialized));

    TraceError("CUPnPDeviceFinder::FinalConstruct", hr);
    return hr;
}

HRESULT
CUPnPDeviceFinder::FinalRelease()
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::FinalRelease");

    PLIST_ENTRY ple;
    DFC_DEVICE_FINDER_INFO * pdfi;

    // loop through the entire list
    while (!IsListEmpty(&m_FinderList))
    {
        // remove the first item from list
        ple = RemoveHeadList(&m_FinderList);

        // retrieve the device finder info block
        pdfi = CONTAINING_RECORD(ple, DFC_DEVICE_FINDER_INFO, m_link);

        // release finder object
        FreeFinder(pdfi->m_pdfc);

        // nuke info
        delete pdfi;
    }

    if (m_fSsdpInitialized)
    {
        SsdpCleanup();
    }


    g_finderCollector.CleanUp(FALSE);

    TermDelayedDownloadList();

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::HrAllocFinder
//
//  Purpose:    Creates a new device finder callback data object, AddRef()s
//              it, and stores it in the local list of all finder objects.
//
//  Arguments:
//      ppcfdcd [out]   Returns new object
//
//  Returns:    S_OK if success, E_OUTOFMEMORY if couldn't alloc memory
//
//  Author:     danielwe   17 Jan 2000
//
//  Notes:
//
HRESULT CUPnPDeviceFinder::HrAllocFinder(CComObject<CUPnPDeviceFinderCallback> ** ppdfc)
{
    Assert(ppdfc);

    HRESULT     hr = E_OUTOFMEMORY;
    PLIST_ENTRY ple = NULL;
    DFC_DEVICE_FINDER_INFO * pdfi = NULL;
    CComObject<CUPnPDeviceFinderCallback> * pdfc = NULL;

    // allocate device info
    pdfi = new DFC_DEVICE_FINDER_INFO;

    if (pdfi == NULL)
    {
        TraceError("CUPnPDeviceFinder::HrAllocFinder: allocate info", hr);
        goto Cleanup;
    }

    // attempt to instantiate instance of device finder object
    hr = CComObject<CUPnPDeviceFinderCallback>::CreateInstance(&pdfc);

    if (FAILED(hr))
    {
        TraceError("CUPnPDeviceFinder::HrAllocFinder: CreateInstance", hr);

        delete pdfi;

        pdfc = NULL;
        goto Cleanup;
    }

    pdfc->AddRef();

    // save device object
    pdfi->m_pdfc = pdfc;

    // append to device finder list
    InsertTailList(&m_FinderList, &pdfi->m_link);

    // success
    hr = S_OK;

Cleanup:

    // transfer
    *ppdfc = pdfc;

    TraceError("CUPnPDeviceFinder::HrAllocFinder", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::DeleteFinder
//
//  Purpose:    This will stop a search in progress, free its memory,
//              and remove it from the list of searches.
//
//  Arguments:
//      pdfc [in]     search callback object to delete
//
//  Returns:    Nothing
//
//  Author:     danielwe   17 Jan 2000
//
//  Notes:
//
VOID CUPnPDeviceFinder::DeleteFinder(CComObject<CUPnPDeviceFinderCallback> * pdfc)
{
    Assert(pdfc);

    PLIST_ENTRY ple = NULL;
    DFC_DEVICE_FINDER_INFO * pdfi = NULL;

    // retrieve first item
    ple = m_FinderList.Flink;

    // search through entire list
    while (ple != &m_FinderList)
    {
        // retrieve the device finder info block
        pdfi = CONTAINING_RECORD(ple, DFC_DEVICE_FINDER_INFO, m_link);

        // compare device objects
        if (pdfi->m_pdfc == pdfc)
        {
            // remove from list
            RemoveEntryList(ple);

            // release object
            FreeFinder(pdfc);

            // release info
            delete pdfi;

            break;
        }

        // next item...
        ple = ple->Flink;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     UPnPDeviceFinder::PdfcFindFinder
//
//  Purpose:    This will stop a search in progress, free its memory,
//              and remove it from the list of searches.
//
//  Arguments:
//      lFind [in]    Cookie of matching CUPnPDeviceFinderCallback
//
//  Returns:    Pointer to matching CUPnPDeviceFinderCallback object if
//              found, NULL if not found.
//
//  Notes:
//
CComObject<CUPnPDeviceFinderCallback> *
CUPnPDeviceFinder::PdfcFindFinder(LONG lFind)
{
    CComObject<CUPnPDeviceFinderCallback> * pdfcResult;
    PLIST_ENTRY ple;

    pdfcResult = NULL;

    // retrieve first item
    ple = m_FinderList.Flink;

    // search through entire list
    while (ple != &m_FinderList)
    {
        DFC_DEVICE_FINDER_INFO * pdfi;
        LONG lCookieCurrent;

        // retrieve the device finder info block
        pdfi = CONTAINING_RECORD(ple, DFC_DEVICE_FINDER_INFO, m_link);
        Assert(pdfi);
        Assert(pdfi->m_pdfc);

        // compare cookies
        lCookieCurrent = pdfi->m_pdfc->GetClientCookie();

        if (lCookieCurrent == lFind)
        {
            pdfcResult = pdfi->m_pdfc;
            break;
        }

        // next item...
        ple = ple->Flink;
    }

    return pdfcResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrHandleDeviceAddOrRemove
//
//  Purpose:    Calls the appropriate callback helper method, marshalling
//              the call to the "main" apartment thread.
//
//  Arguments:
//      ppch [in]           search callback object to notify
//      pSsdpMessage [in]   message containing an add or remove notification
//      dfType [in]         type of message from the DF_ADD_TYPE enumeration.
//                          Tells the callback helper
//
//  Returns:    Nothing
//
//  Author:     danielwe   17 Jan 2000
//
//  Notes:
//
HRESULT HrHandleDeviceAddOrRemove(IUPnPPrivateCallbackHelper * ppch,
                                  CONST SSDP_MESSAGE * pSsdpMessage,
                                  DF_ADD_TYPE dfType)
{
    Assert(ppch);
    Assert(pSsdpMessage);

    HRESULT hr;
    LPWSTR  szwLocation = NULL;
    GUID guidInterface;

    guidInterface = pSsdpMessage->guidInterface;

    if (!(pSsdpMessage->szLocHeader) && (dfType != DF_REMOVE))
    {
        TraceTag(ttidUPnPDeviceFinder, "HrHandleDeviceAddOrRemove:"
            "szLocHeader is NULL, invalid SSDP message");

        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!(pSsdpMessage->szUSN))
    {
        TraceTag(ttidUPnPDeviceFinder, "HrHandleDeviceAddOrRemove:"
            "szUSN is NULL, invalid SSDP message");

        hr = E_INVALIDARG;
        goto Cleanup;
    }


    hr = E_OUTOFMEMORY;

    if (dfType != DF_REMOVE)
    {
        szwLocation = WszFromSz(pSsdpMessage->szLocHeader);
    }

    if (szwLocation || (dfType == DF_REMOVE))
    {
        BSTR    bstrUdn;

        bstrUdn = BstrUdnFromUsn(pSsdpMessage->szUSN);
        if (bstrUdn)
        {
            switch (dfType)
            {
            case DF_ADD_SEARCH_RESULT:
                AssertSz(szwLocation, "Location header is NULL for device add!");
                hr = ppch->HandleDeviceAdd(szwLocation, bstrUdn, TRUE, &guidInterface);
                break;

            case DF_ADD_NOTIFY:
                AssertSz(szwLocation, "Location header is NULL for device add!");
                hr = ppch->HandleDeviceAdd(szwLocation, bstrUdn, FALSE, &guidInterface);
                break;

            case DF_REMOVE:
                hr = ppch->HandleDeviceRemove(bstrUdn);
                break;

            default:
                AssertSz(FALSE, "HrHandleDeviceAddOrRemove: unhandled dfType");
                break;
            }

            SysFreeString(bstrUdn);
        }
        // else, hr = E_OUTOFMEMORY by default

        delete szwLocation;
    }

Cleanup:
    TraceError("HrHandleDeviceAddOrRemove", hr);
    return hr;
}

HRESULT HrCopySsdpMessage(SSDP_MESSAGE **ppmsg, CONST SSDP_MESSAGE *pSsdpMessage)
{
    HRESULT     hr = S_OK;

    SSDP_MESSAGE *  pmsg;

    pmsg = new SSDP_MESSAGE;
    if (pmsg)
    {
        pmsg->guidInterface = pSsdpMessage->guidInterface;
        pmsg->iLifeTime = pSsdpMessage->iLifeTime;
        pmsg->iSeq = pSsdpMessage->iSeq;

        if (pSsdpMessage->szAltHeaders && SUCCEEDED(hr))
        {
            pmsg->szAltHeaders = SzaDupSza(pSsdpMessage->szAltHeaders);
            if (!pmsg->szAltHeaders)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pmsg->szAltHeaders = NULL;
        }

        if (pSsdpMessage->szContent && SUCCEEDED(hr))
        {
            pmsg->szContent = SzaDupSza(pSsdpMessage->szContent);
            if (!pmsg->szContent)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pmsg->szContent = NULL;
        }

        if (pSsdpMessage->szLocHeader && SUCCEEDED(hr))
        {
            pmsg->szLocHeader = SzaDupSza(pSsdpMessage->szLocHeader);
            if (!pmsg->szLocHeader)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pmsg->szLocHeader = NULL;
        }

        if (pSsdpMessage->szSid && SUCCEEDED(hr))
        {
            pmsg->szSid = SzaDupSza(pSsdpMessage->szSid);
            if (!pmsg->szSid)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pmsg->szSid = NULL;
        }

        if (pSsdpMessage->szType && SUCCEEDED(hr))
        {
            pmsg->szType = SzaDupSza(pSsdpMessage->szType);
            if (!pmsg->szType)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pmsg->szType = NULL;
        }

        if (pSsdpMessage->szUSN && SUCCEEDED(hr))
        {
            pmsg->szUSN = SzaDupSza(pSsdpMessage->szUSN);
            if (!pmsg->szUSN)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            pmsg->szUSN = NULL;
        }

        if (SUCCEEDED(hr))
        {
            *ppmsg = pmsg;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        FreeSsdpMessage(pmsg);
    }

    TraceError("HrCopySsdpMessage", hr);
    return hr;
}




VOID CUPnPDeviceFinder::NotificationCallback(SSDP_CALLBACK_TYPE sctType,
                                             CONST SSDP_MESSAGE * pSsdpMessage,
                                             LPVOID pContext)
{
    CALLBACK_PARAMS *   pcp;
    HRESULT             hr = S_OK;

    TraceTag(ttidUPnPDeviceFinder, "Device Finder Notification callback - started");

    pcp = new CALLBACK_PARAMS;
    if (!pcp)
    {
        TraceError("CUPnPDeviceFinder::NotificationCallback", E_OUTOFMEMORY);
        return;
    }

    pcp->pSsdpMessage = NULL;

    if (pSsdpMessage)
    {
        hr = HrCopySsdpMessage(&pcp->pSsdpMessage, pSsdpMessage);
    }

    if (SUCCEEDED(hr))
    {
        DWORD   cmsecDelay;
        DWORD   cmsecMaxDelay = 3000;
        DWORD   cmsecMinDelay = 0;

        pcp->pContext = pContext;
        pcp->sctType = sctType;
        pcp->hTimer = NULL;

        switch(sctType)
        {
            case SSDP_ALIVE:
            case SSDP_FOUND:
                if (TestTargetUrlOk(pSsdpMessage, sctType, &cmsecMaxDelay, &cmsecMinDelay) == FALSE)
                {
                    if (pcp->pSsdpMessage)
                        FreeSsdpMessage(pcp->pSsdpMessage);
                    delete pcp;
                    break;
                }

                if (cmsecMaxDelay > 0 || cmsecMinDelay > 0)
                {
                    CComObject<CUPnPDeviceFinderCallback> * pFinder;

                    pFinder = (CComObject<CUPnPDeviceFinderCallback> *)pContext;

                    if (cmsecMaxDelay > 0)
                        cmsecDelay = (rand() % cmsecMaxDelay);
                    cmsecDelay += cmsecMinDelay;

                    Assert(pFinder->m_hTimerQ);

                    AddToDelayedDownloadList(pcp);

                    if (!CreateTimerQueueTimer(&pcp->hTimer, pFinder->m_hTimerQ,
                                               CUPnPDeviceFinder::NotificationCallbackHelper,
                                               pcp, cmsecDelay, 0, WT_EXECUTEDEFAULT))
                    {
                        RemoveFromDelayedDownloadList(pcp);
                        if (pcp->pSsdpMessage)
                            FreeSsdpMessage(pcp->pSsdpMessage);
                        delete pcp;
                        hr = HrFromLastWin32Error();
                    }
                    else
                    {
                        TraceTag(ttidUPnPDeviceFinder, "Successfully created timer "
                                 "for %d msecs", cmsecDelay);
                    }
                }
                else
                {
                    NotificationCallbackHelper(pcp, FALSE);
                }
                break;

            case SSDP_BYEBYE:
                // see if this matches a delayed download still pending
                if (pcp->pSsdpMessage)
                    RemoveMatchFromDelayedDownloadList(pcp->pSsdpMessage, pContext);
                NotificationCallbackHelper(pcp, FALSE);
                break;

            case SSDP_DONE:
                // need to delay DONE until all delays complete
                AddToDelayedDownloadList(pcp);
                TestDelayedDownloadsDone(pContext);
                break;

            default:
                // any other types should have been caught above
                AssertSz(FALSE, "bogus SSDP_CALLBACK_TYPE value");
        }
    }

    TraceTag(ttidUPnPDeviceFinder, "Device Finder Notification callback - finished");
    TraceError("CUPnPDeviceFinder::NotificationCallback", hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::NotificationCallbackHelper
//
//  Purpose:    SSDP notification callback function for asynchronous find
//              operations.
//
//  Arguments:
//      sctType      [in]   Callback type
//      pSsdpMessage [in]   SSDP message
//      pContext     [in]   Context information (the cookie of our callback's
//                                               GIT entry)
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:      This method is either executed on:
//                  - the main apartment
//                  - the ssdp callback thread
//              The thread on which it is executed can change during
//              the duration of a single search.
//
VOID WINAPI CUPnPDeviceFinder::NotificationCallbackHelper(LPVOID pvContext, BOOLEAN fTimeOut)
{
    Assert(pvContext);

    CALLBACK_PARAMS *   pcp;

    pcp = (CALLBACK_PARAMS *)pvContext;

    TraceTag(ttidUPnPDeviceFinder, "Device Finder callback helper - starting");
    TraceSsdpMessage(pcp->sctType, pcp->pSsdpMessage);

    HRESULT hr;
    BOOL fCoInited;
    DWORD dwGITCookie;
    IUPnPPrivateCallbackHelper * ppch;
    LPVOID  pContext = pcp->pContext;

    hr = S_OK;
    fCoInited = FALSE;
    CComObject<CUPnPDeviceFinderCallback> * pFinder;

    // see if this delayed download exists, and remove from list
    BOOL bDelayed = RemoveFromDelayedDownloadList(pcp);

    pFinder = (CComObject<CUPnPDeviceFinderCallback> *)pcp->pContext;
    dwGITCookie = pFinder->m_dwGITCookie;
    ppch = NULL;

    if (pcp->sctType > SSDP_DONE)
    {
        // we'll be ignoring this message, so don't bother with initialization
        //
        goto Cleanup;
    }

    while (TRUE)
    {
        hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if (SUCCEEDED(hr))
        {
            fCoInited = TRUE;
            break;
        }
        else
        {
            if (hr == RPC_E_CHANGED_MODE)
            {
                CoUninitialize();
            }
            else
            {
                // CoInitializeEx failed, so we can't call the callback,
                // so we can't really do anything here
                //
                TraceError("NotificationCallbackHelper:CoInitializeEx", hr);
                goto Cleanup;
            }
        }
    }


    {
        // Obtain a marshalled pointer to our private callback helper object.
        // This makes all of the operations execute in the context of the
        // caller's thread.
        //

        IGlobalInterfaceTable * pgit;

        hr = HrGetGITPointer(&pgit);
        if (FAILED(hr))
        {

            goto Cleanup;
        }
        Assert(pgit);

        hr = pgit->GetInterfaceFromGlobal(dwGITCookie,
                                          IID_IUPnPPrivateCallbackHelper,
                                          (LPVOID *)&ppch);

        ReleaseObj(pgit);

        if (FAILED(hr))
        {
            TraceError("NotificationCallbackHelper: GetInterfaceFromGlobal", hr);

            // note: it's possible that our pointer is no longer in the GIT;
            //       e.g., the search might have been cancelled but SSDP
            //       decided to call us here anyway.  Regardless, we can't
            //       do much now
            //
            ppch = NULL;
            goto Cleanup;
        }
        Assert(ppch);
    }

    switch(pcp->sctType)
    {
        case SSDP_FOUND:
            if (pcp->hTimer && (bDelayed == FALSE))
            {
                // timer was used, if no longer in list, then we had a byebye, so abort.
                TargetAttemptCompletedA(pcp->pSsdpMessage->szLocHeader, TARGET_COMPLETE_ABORT);
                goto Cleanup;
            }

            hr = HrHandleDeviceAddOrRemove(ppch, pcp->pSsdpMessage, DF_ADD_SEARCH_RESULT);

            if (FAILED(hr))
            {
                TargetAttemptCompletedA(pcp->pSsdpMessage->szLocHeader, TARGET_COMPLETE_ABORT);
            }
            break;

        case SSDP_ALIVE:
            if (pcp->hTimer && (bDelayed == FALSE))
            {
                // timer was used, if no longer in list, then we had a byebye, so abort.
                TargetAttemptCompletedA(pcp->pSsdpMessage->szLocHeader, TARGET_COMPLETE_ABORT);
                goto Cleanup;
            }

            hr = HrHandleDeviceAddOrRemove(ppch, pcp->pSsdpMessage, DF_ADD_NOTIFY);

            if (FAILED(hr))
            {
                TargetAttemptCompletedA(pcp->pSsdpMessage->szLocHeader, TARGET_COMPLETE_ABORT);
            }
            break;

        case SSDP_BYEBYE:
            hr = HrHandleDeviceAddOrRemove(ppch, pcp->pSsdpMessage, DF_REMOVE);
            break;

        case SSDP_DONE:
            hr = ppch->HandleDone();
            TraceError("CUPnPDeviceFinder::NotificationCallbackHelper: HandleDone",
                       hr);
            break;

        default:
            // any other types should have been caught above
            AssertSz(FALSE, "bogus SSDP_CALLBACK_TYPE value");
    }

Cleanup:
    ReleaseObj(ppch);

    if (pcp->hTimer)
    {
        TraceTag(ttidUPnPDeviceFinder, "Device Finder callback helper - getting lock");

        EnterCriticalSection(&pFinder->m_cs);

        if (!pFinder->m_fCleanup)
        {
            TraceTag(ttidUPnPDeviceFinder, "Device Finder callback helper - "
                     "not in cleanup. Deleting timer queue timer...");

            DeleteTimerQueueTimer(pFinder->m_hTimerQ, pcp->hTimer, NULL);
        }
        else
        {
            TraceTag(ttidUPnPDeviceFinder, "Device Finder callback helper - "
                     "In cleanup.. Not deleting timer queue timer.");
        }

        LeaveCriticalSection(&pFinder->m_cs);

        TraceTag(ttidUPnPDeviceFinder, "Device Finder callback helper - released lock");
    }

    if (pcp->pSsdpMessage)
        FreeSsdpMessage(pcp->pSsdpMessage);
    delete pcp;

    if (fCoInited)
    {
        ::CoUninitialize();
    }

    // see if this was last download and Done is pending
    TestDelayedDownloadsDone(pContext);

    TraceTag(ttidUPnPDeviceFinder, "Device Finder callback helper - finished");
    TraceError("CUPnPDeviceFinder::NotificationCallbackHelper", hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::CancelAsyncFind
//
//  Purpose:    Cancels an asynchronous find opeeration.
//
//  Arguments:
//      lFind [in]  Context information
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFinder::CancelAsyncFind(LONG lFind)
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::CancelAsyncFind");

    HRESULT hr;
    CComObject<CUPnPDeviceFinderCallback> * pdfc;

    hr = S_OK;
    pdfc = NULL;

    pdfc = PdfcFindFinder(lFind);
    if (!pdfc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    {
        DFC_SEARCHSTATE ss = pdfc->GetSearchState();
        if (ss < DFC_SS_STARTED)
        {
            // REVIEW: is this right?
            hr = S_FALSE;
        }
    }

    DeleteFinder(pdfc);

Cleanup:
    TraceHr(ttidUPnPDeviceFinder, FAL, hr, FALSE, "CUPnPDeviceFinder::CancelAsyncFind");

    TraceError("CUPnPDeviceFinder::CancelAsyncFind", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::StartAsyncFind
//
//  Purpose:    Starts an asynchronous find opeeration.
//
//  Arguments:
//      lFind [in]  Context information
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFinder::StartAsyncFind(LONG lFind)
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::StartAsyncFind");

    HRESULT hr;
    CComObject<CUPnPDeviceFinderCallback> * pdfc;

    hr = S_OK;
    pdfc = NULL;

    pdfc = PdfcFindFinder(lFind);
    if (!pdfc)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = pdfc->HrStartSearch();
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    TraceHr(ttidUPnPDeviceFinder, FAL, hr, FALSE, "CUPnPDeviceFinder::StartAsyncFind");

    TraceError("CUPnPDeviceFinder::StartAsyncFind", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::CreateAsyncFind
//
//  Purpose:    Creates an asynchronous find context
//
//  Arguments:
//      bstrTypeURI              [in]   Search type string
//      dwFlags                  [in]   Reserved for future use.  Currently
//                                      unused and ignored.
//      punkDeviceFinderCallback [in]   IUnknown of callback interface
//      plFindData               [out]  Find context information for use later
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFinder::CreateAsyncFind(
    BSTR                        bstrTypeURI,
    DWORD                       dwFlags,
    IUnknown *                  punkDeviceFinderCallback,
    LONG *                      plFindData)
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::CreateAsyncFind");

    UNREFERENCED_PARAMETER(dwFlags);

    HRESULT hr;
    CComObject<CUPnPDeviceFinderCallback> * pdfc;
    LPSTR pszSearch;

    hr = S_OK;
    pdfc = NULL;
    pszSearch = NULL;

    if (!plFindData || IsBadWritePtr(plFindData, sizeof(LONG)))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *plFindData = 0;

    if (!bstrTypeURI || !punkDeviceFinderCallback)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!(*bstrTypeURI))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    g_finderCollector.CleanUp(FALSE);

    // We do a bunch of things here:
    //  1. create a CUPnPDeviceFinderCallback object, storing a
    //     pointer in our list of CUPnPDeviceFinderCallback objects,
    //     AddRef()ing the pointer that we store
    //  2. initialize the CUPnPDeviceFinderCallback object
    //  3. store a pointer to the CUPnPDeviceFinderCallback object in
    //     *plFindData and return

    hr = HrAllocFinder(&pdfc);
    if (FAILED(hr))
    {
        pdfc = NULL;
        goto Cleanup;
    }
    Assert(pdfc);

    pszSearch = SzFromWsz(bstrTypeURI);
    if (!pszSearch)
    {
        TraceError("CUPnPDeviceFinder::CreateAsyncFind failed to allocate "
                   "pcfdcd->m_pszSearch", hr);

        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        LONG lCookie;

        lCookie = m_lNextFinderCookie++;

        hr = pdfc->HrInit(punkDeviceFinderCallback, pszSearch, lCookie);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

Cleanup:
    // If we succeeded, fill in search data return val
    //
    if (SUCCEEDED(hr))
    {
        LONG lCookie;

        lCookie = pdfc->GetClientCookie();

        *plFindData = lCookie;
    }
    else
    {
        if (pdfc)
        {
            DeleteFinder(pdfc);
        }
    }

    delete [] pszSearch;

    TraceHr(ttidUPnPDeviceFinder, FAL, hr, FALSE, "CUPnPDeviceFinder::CreateAsyncFind");

    TraceError("CUPnPDeviceFinder::CreateAsyncFind", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::HrAddDeviceToCollection
//
//  Purpose:    Helper function to add a device to the given collection
//              of devices
//
//  Arguments:
//      pCollection  [in]   Collection to add to
//      pSsdpMessage [in]   SSDP message containing device data
//
//  Returns:    S_OK if successful
//              S_FALSE if the device was not added due to a non-terminal
//                  error (e.g. the SSDP_MESSAGE wasn't valid and can't
//                  be added, but the collection is fine and other valid
//                  messages can be added)
//              OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:
//
HRESULT CUPnPDeviceFinder::HrAddDeviceToCollection(
    CComObject<CUPnPDevices> *  pCollection,
    CONST SSDP_MESSAGE *        pSsdpMessage)
{
    Assert(pCollection);
    Assert(pSsdpMessage);

    HRESULT                           hr = S_OK;
    CComObject<CUPnPDescriptionDoc> * pDoc = NULL;

    LPWSTR pszUrl = NULL;
    BSTR   bstrUdn = NULL;

    // check to make sure pSsdpMessage is valid, and extract the needed data
    // from it
    if (!(pSsdpMessage->szLocHeader))
    {
        TraceTag(ttidUPnPDeviceFinder,
                 "CUPnPDeviceFinder::HrAddDeviceToCollection:"
                 "ssdp message with bogus szLocHeader");

        // bug 125961: this isn't a terminal error
        hr = S_FALSE;
        goto Cleanup;
    }

    pszUrl = WszFromSz(pSsdpMessage->szLocHeader);
    if (!pszUrl)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if (!(pSsdpMessage->szUSN))
    {
        TraceTag(ttidUPnPDeviceFinder,
                 "CUPnPDeviceFinder::HrAddDeviceToCollection:"
                 "ssdp message with bogus szUSN");

        hr = S_FALSE;
        goto Cleanup;
    }

    bstrUdn = BstrUdnFromUsn(pSsdpMessage->szUSN);
    if (!bstrUdn)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = CComObject<CUPnPDescriptionDoc>::CreateInstance(&pDoc);
    if (SUCCEEDED(hr))
    {
        Assert(pDoc);
        pDoc->AddRef();

        hr = pDoc->SyncLoadFromUrl(pszUrl);
        if (SUCCEEDED(hr))
        {
            IUPnPDevice * pud = NULL;

            hr = pDoc->DeviceByUDN(bstrUdn, &pud);
            if (SUCCEEDED(hr))
            {
                Assert(pud);

                hr = pCollection->HrAddDevice(pud);
                if (FAILED(hr))
                {
                    TraceTag(ttidUPnPDeviceFinder,
                             "Couldn't pCollection->AddDevice(pud), hr=%x",
                             hr);
                }

                // the collection has a ref on the device
                pud->Release();
            }
            else
            {
                TraceTag(ttidUPnPDeviceFinder, "Couldn't get"
                         "pDoc->DeviceByUDN(), hr=%x", hr);

                if (E_FAIL == hr)
                {
                    // the loaded description doc didn't contain a device
                    // with the UDN.  This is a non-terminal error.
                    hr = S_FALSE;
                }
            }
        }
        else
        {
            TraceTag(ttidUPnPDeviceFinder, "Couldn't load description "
                     "doc at %S, hr=%x, ignoring", pszUrl, hr);
            hr = S_FALSE;
        }

        pDoc->Release();
    }
    else
    {
        TraceError("Couldn't create description document", hr);
    }

Cleanup:
    if (pszUrl)
    {
        delete [] pszUrl;
    }

    ::SysFreeString(bstrUdn);

    TraceError("CUPnPDeviceFinder::HrAddDeviceToCollection", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::FindByType
//
//  Purpose:    Finds services synchronously.
//
//  Arguments:
//      bstrTypeURI [in]    Search type
//      dwFlags     [in]    Reserved for future use.  Currently
//                          unused and ignored.
//      ppDevices   [out]   Returns collection of devices that were found
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:      Rewritten to use an async search.  This allows us to load
//              and parse the descriptions of the search results in
//              parallel.
//
STDMETHODIMP CUPnPDeviceFinder::FindByType(
    BSTR            bstrType,
    DWORD           dwFlags,
    IUPnPDevices ** ppDevices)
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::FindByType");

    UNREFERENCED_PARAMETER(dwFlags);

    HRESULT     hr                  = S_OK;
    CComObject<CFindSyncDeviceFinderCallback> * pfsdfc = NULL;
    CComObject<CUPnPDevices> * pDevices = NULL;
    HANDLE hDoneEvent = NULL;
    LONG lFindData = 0;

    if (!ppDevices || IsBadWritePtr(ppDevices, sizeof(IUPnPDevices **)))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDevices = NULL;

    if (!bstrType)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!*bstrType)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    hDoneEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hDoneEvent)
    {
        hr = HrFromLastWin32Error();
        TraceError("CUPnPDeviceFinder::FindByType: CreateEvent", hr);

        goto Cleanup;
    }

    hr = CComObject<CUPnPDevices>::CreateInstance(&pDevices);
    if (FAILED(hr))
    {
        TraceError("CUPnPDeviceFinder::FindByType: CreateInstance #1", hr);

        pDevices = NULL;
        goto Cleanup;
    }
    Assert(pDevices);

    pDevices->AddRef();

    hr = CComObject<CFindSyncDeviceFinderCallback>::CreateInstance(&pfsdfc);
    if (FAILED(hr))
    {
        TraceError("CUPnPDeviceFinder::FindByType: CreateInstance #2", hr);

        pfsdfc = NULL;
        goto Cleanup;
    }
    Assert(pfsdfc);

    pfsdfc->AddRef();


    hr = pfsdfc->HrInit(hDoneEvent, pDevices);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = CreateAsyncFind(bstrType, 0, pfsdfc, &lFindData);
    if (SUCCEEDED(hr))
    {
        hr = StartAsyncFind(lFindData);
        if (SUCCEEDED(hr))
        {
            DWORD dwEventSignalled;

            // wait for the load to complete

            hr = HrMyWaitForMultipleHandles(0,
                                            c_cmsecFindByTypeTimeout,
                                            1,
                                            &hDoneEvent,
                                            &dwEventSignalled);
            Assert(FImplies(SUCCEEDED(hr), 0 == dwEventSignalled));

            if (RPC_S_CALLPENDING == hr)
            {
                // we timed out.
                //
                TraceTag(ttidUPnPDeviceFinder,
                         "CUPnPDeviceFinder::FindByType: Search timed out");

                hr = S_OK;
            }

            if (FAILED(hr))
            {
                TraceError("CUPnPDeviceFinder::FindByType:"
                           "CoWaitForMultipleHandles", hr);
            }
            else
            {
                pDevices->AddRef();
                *ppDevices = pDevices;
            }

            CancelAsyncFind(lFindData);
        }
    }


Cleanup:
    Assert(FIff(SUCCEEDED(hr), ppDevices && *ppDevices));

    if (pfsdfc)
    {
        pfsdfc->Release();
    }

    if (pDevices)
    {
        pDevices->Release();
    }

    if (hDoneEvent)
    {
        ::CloseHandle(hDoneEvent);
    }

    TraceError("CUPnPDeviceFinder::FindByType", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::FindByUDN
//
//  Purpose:    Implements a synchronous find operation looking for a device
//              with a specific UDN. This returns one and only one device.
//
//  Arguments:
//      bstrUdn  [in]   Device UDN to look for
//      ppDevice [out]  Returns device, if found, NULL if not
//
//  Returns:    S_OK if a device was found successfully, S_FALSE if the search
//              was successful but no device was found, or OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:      This is basically a helper function that uses the async
//              search methods on this interface, along with the standard
//              callback interface, to perform a simple and common search.
//
STDMETHODIMP CUPnPDeviceFinder::FindByUDN(BSTR bstrUdn, IUPnPDevice ** ppDevice)
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinder::FindByUDN");

    HRESULT                     hr  = S_OK;
    CComObject<CFindByUdnDeviceFinderCallback> * pfbudfc = NULL;
    HANDLE                      hDoneEvent = NULL;
    LONG                        lFindData = 0;
    IUPnPDevice *               pudResult = NULL;

    if ((!ppDevice) || IsBadWritePtr(ppDevice, sizeof(IUPnPDevice *)))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDevice = NULL;

    if (!bstrUdn)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!(*bstrUdn))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hDoneEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!hDoneEvent)
    {
        hr = HrFromLastWin32Error();
        TraceError("CUPnPDeviceFinder::FindByUDN: CreateEvent", hr);

        goto Cleanup;
    }

    hr = CComObject<CFindByUdnDeviceFinderCallback>::CreateInstance(&pfbudfc);
    if (FAILED(hr))
    {
        TraceError("CUPnPDeviceFinder::FindByUDN: CreateInstance", hr);

        pfbudfc = NULL;
        goto Cleanup;
    }
    Assert(pfbudfc);

    pfbudfc->AddRef();

    hr = pfbudfc->HrInit(bstrUdn, hDoneEvent);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = CreateAsyncFind(bstrUdn, 0, pfbudfc, &lFindData);
    if (SUCCEEDED(hr))
    {
        hr = StartAsyncFind(lFindData);
        if (SUCCEEDED(hr))
        {
            DWORD dwEventSignalled;

            // wait for the load to complete

            hr = HrMyWaitForMultipleHandles(0,
                                            c_cmsecFindByUdnTimeout,
                                            1,
                                            &hDoneEvent,
                                            &dwEventSignalled);

            if (SUCCEEDED(hr))
            {
                Assert(0 == dwEventSignalled);

                // the event was signalled.  do we have a device?
                //
                pudResult = pfbudfc->GetFoundDevice();

                hr = pudResult ? S_OK : S_FALSE;
            }
            else if (RPC_S_CALLPENDING == hr)
            {
                // we timed out
                //
                TraceTag(ttidUPnPDeviceFinder,
                         "CUPnPDeviceFinder::FindByUDN: Search timed out");

                hr = S_FALSE;
            }
            else
            {
                TraceError("CUPnPDeviceFinder::FindByUDN:"
                           "CoWaitForMultipleHandles", hr);
            }

            CancelAsyncFind(lFindData);
        }
    }

    *ppDevice = pudResult;

Cleanup:
    Assert(FIff(S_OK == hr, pudResult));
    Assert(FImplies(pudResult, ppDevice));

    if (pfbudfc)
    {
        pfbudfc->Release();
    }

    if (hDoneEvent)
    {
        ::CloseHandle(hDoneEvent);
    }

    TraceError("CUPnPDeviceFinder::FindByUDN", hr == S_FALSE ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::RemoveOldLoaders
//
//  Purpose:    Searchs loader list for stale loaders and deletes them.
//
//  Arguments:  <none>
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     donryan 2-23-2000
//
//  Notes:
//
VOID CUPnPDeviceFinderCallback::RemoveOldLoaders()
{
    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // retrieve first item
    ple = m_LoaderList.Flink;

    // search through list
    while (ple != &m_LoaderList)
    {
        // retrieve document loader info from entry
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        // is this loader stale?
        if (DFC_CBF_FIRED == (pdli->m_cbfCallbackFired))
        {
            // remove from list
            RemoveEntryList(ple);

            // NOTE: calling FreeLoader here will delete the LIST_ENTRY
            // we are currently pointed at so we need to move to the next
            // item in the list before calling FreeLoader.
            ple = ple->Flink;

            // delete loader
            FreeLoader(pdli);
        }
        else
        {
            // next item...
            ple = ple->Flink;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::GetClientCookie
//
//  Purpose:    Returns the unique cookie for this callback instance.
//              This cookie was set when the callback object was created.
//
//  Arguments:  <none>
//
//  Returns:    m_lClientCookie
//
//  Notes:
//
LONG CUPnPDeviceFinderCallback::GetClientCookie() const
{
    return m_lClientCookie;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::HandleDone
//
//  Purpose:    Out-of-thread handler for search completion using the async
//              SSDP find API
//
//  Arguments:  <none>
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:      This method will always execute on the MAIN thread
//
STDMETHODIMP CUPnPDeviceFinderCallback::HandleDone()
{
    Assert(!m_fSsdpSearchDone);

    m_lBusyCount++;

    HRESULT     hr = S_OK;

    // cleanup list
    RemoveOldLoaders();

    if (DFC_SS_CLEANUP == m_ss || m_fCanceled)
    {
        // we're in the process of stopping this search.  Just return.
        //
        goto Cleanup;
    }
    Assert(m_punkCallback);

    if (!m_fSsdpSearchDone)
    {
        m_fSsdpSearchDone = TRUE;

        // note(cmr): Register for future results.  We do this before
        // in addition to FindServicesCallback so that we grab NOTIFY
        // messages (sent by devices that are just coming online).
        // The callback notifications via RegisterNotification only
        // return NOTIFY messages, where FindServicesCallback only
        // returns search responses
        //

        m_hNotify = RegisterNotification(NOTIFY_ALIVE,
                                         m_pszSearch,
                                         NULL,
                                         CUPnPDeviceFinder::NotificationCallback,
                                         this);
        if (INVALID_HANDLE_VALUE == m_hNotify)
        {
            hr = HrFromLastWin32Error();
            TraceError("CUPnPDeviceFinderCallback::HandleDone: RegisterNotification", hr);

            goto Cleanup;
        }
        TraceTag(ttidUPnPDeviceFinder, "RegisterNotification started");

        hr = HrEnsureSearchDoneFired();
    }

Cleanup:
    m_lBusyCount--;
    TraceError("CUPnPDeviceFinderCallback::HandleDone", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::HandleDeviceAdd
//
//  Purpose:    Out-of-thread handler for found devices using the async
//              SSDP find API
//
//  Arguments:
//      szwLocation [in]    Location header of SSDP message
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:      This method is will always execute on the MAIN thread
//
STDMETHODIMP CUPnPDeviceFinderCallback::HandleDeviceAdd(LPWSTR szwLocation,
                                                        BSTR bstrUdn,
                                                        BOOL fSearchResult,
                                                        GUID *pguidInterface)
{
    Assert(szwLocation);

    HRESULT                             hr;
    DFC_DOCUMENT_LOADING_INFO *         pddli;
    CComObject<CUPnPDescriptionDoc> *   pDoc;
    IUnknown *                          punkCallback;
    BSTR                                bstrUrl;

    hr = S_OK;
    pddli = NULL;
    pDoc = NULL;
    punkCallback = NULL;
    bstrUrl = NULL;

    m_lBusyCount++;

    if (DFC_SS_CLEANUP == m_ss)
    {
        // we're in the process of stopping this search.  Just return.
        //
        goto Cleanup;
    }

    if (!m_punkCallback)
    {
        hr = E_FAIL;
        TraceError("CUPnPDeviceFinderCallback::HandleDeviceAdd - no callback!",
                   hr);
        goto Cleanup;
    }

    // cleanup list
    RemoveOldLoaders();

    {
        BOOL fIsHttpUrl;

        fIsHttpUrl = FIsHttpUrl(szwLocation);
        if (!fIsHttpUrl)
        {
            // We'll only load description documents from the device finder
            // are either http or https urls.
            //
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    bstrUrl = ::SysAllocString(szwLocation);
    if (!bstrUrl)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = HrAllocLoader(bstrUdn, fSearchResult, pguidInterface, &pddli);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    Assert(pddli);

    // note: AFTER this point we have to goto Error to clean up

    pDoc = pddli->m_pdoc;
    Assert(pDoc);

    punkCallback = GetUnknown();
    Assert(punkCallback);

    pddli->m_bstrUrl = SysAllocString(bstrUrl);

    hr = pDoc->LoadAsync(bstrUrl, punkCallback);
    if (FAILED(hr))
    {
        TraceError("CUPnPDeviceFinderCallback::HandleDeviceAdd: AsyncLoadFromUrl", hr);

        goto Error;
    }

Cleanup:
    ::SysFreeString(bstrUrl);
    m_lBusyCount--;

    TraceError("CUPnPDeviceFinderCallback::HandleDeviceAdd", hr);
    return hr;

Error:
    TraceError("CUPnPDeviceFinderCallback::HandleDeviceAdd -"
               " removing loader that failed prematurely!", hr);

    DeleteLoader(pddli);
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::HandleDeviceRemove
//
//  Purpose:    Out-of-thread handler for removed devices using the async
//              SSDP find API
//
//  Arguments:
//      bstrUdn [in]    UDN of the removed device
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   2 Dec 1999
//
//  Notes:      This method will always execute on the MAIN thread
//
STDMETHODIMP CUPnPDeviceFinderCallback::HandleDeviceRemove(BSTR bstrUdn)
{
    IUPnPDevice *               pud = NULL;
    HRESULT                     hr = S_OK;
    IUPnPDeviceFinderCallback * pdfc;

    m_lBusyCount++;

    if (DFC_SS_CLEANUP == m_ss)
    {
        // we're in the process of stopping this search.  Just return.
        //
        goto Cleanup;
    }

    if (!m_punkCallback)
    {
        hr = E_FAIL;
        TraceError("CUPnPDeviceFinderCallback::HandleDeviceRemove- no callback!",
                   hr);
        goto Cleanup;
    }

    // see if we're trying to load the device that went away.
    // if so, abort the load
    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // retrieve first item
    ple = m_LoaderList.Flink;

    // search through list
    while (ple != &m_LoaderList)
    {
        int result;
        LPCWSTR pszUdnTemp;

        // retrieve the document loader info
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        // retrieve udn information
        pszUdnTemp = pdli->m_bstrUDN;

        // compare with udn of interest
        result = wcscmp(bstrUdn, pszUdnTemp);

        // delete item if udn matches.  Clean out stale entries at the end.
        // if a callback is currently firing, don't delete the loader -- rely on
        // a later call to RemoveOldLoaders() to do the cleanup
        if (0 == result && pdli->m_cbfCallbackFired != DFC_CBF_CURRENTLY_FIRING)
        {
            // remove from list
            RemoveEntryList(ple);

            // NOTE: calling FreeLoader here will delete the LIST_ENTRY
            // we are currently pointed at so we need to move to the next
            // item in the list before calling FreeLoader.
            ple = ple->Flink;

            // delete loader
            FreeLoader(pdli);
        }
        else
        {
            // next item
            ple = ple->Flink;
        }
    }

    // Figure out what type of callback pointer we have from the
    // IUnknown. It can be one of 2 possibilities. Either it is
    // a C/C++ callback in which case the interface would be
    // IUPnPDeviceFinderCallback, or it can be from script, in
    // which case it would be IDispatch. If it's neither, then
    // we can't do anything.
    //
    hr = m_punkCallback->QueryInterface(IID_IUPnPDeviceFinderCallback,
                                        (LPVOID *)&pdfc);
    if (E_NOINTERFACE == hr)
    {
        IDispatch * pdisp;

        hr = m_punkCallback->QueryInterface(IID_IDispatch,
                                            (LPVOID *)&pdisp);
        if (SUCCEEDED(hr))
        {
            hr = HrInvokeCallback(pdisp, DFC_REMOVE_DEVICE, bstrUdn, NULL);
            ReleaseObj(pdisp);
        }
        else
        {
            TraceError("CUPnPDeviceFinder::HandleDeviceRemove-"
                       " couln't find a callback interface!", hr);
        }
    }
    else if (SUCCEEDED(hr))
    {
        pdfc->DeviceRemoved(m_lClientCookie, bstrUdn);
        ReleaseObj(pdfc);
    }

    RemoveOldLoaders();

Cleanup:
    m_lBusyCount--;
    TraceError("CUPnPDeviceFinderCallback::HandleDeviceRemove", hr);
    return hr;
}

CUPnPDeviceFinderCallback::CUPnPDeviceFinderCallback()
{
    m_hSearch = INVALID_HANDLE_VALUE;
    m_hNotify = INVALID_HANDLE_VALUE;
    m_pszSearch = NULL;
    m_punkCallback = NULL;
    m_dwGITCookie = 0;
    m_ss = DFC_SS_UNINITIALIZED;
    m_fSsdpSearchDone = FALSE;
    m_lClientCookie = 0;
    m_hTimerQ = NULL;
    m_lBusyCount = 0;
    m_fCanceled = FALSE;

#ifdef DBG
    m_nThreadId = GetCurrentThreadId();
#endif // DBG

    InitializeListHead(&m_LoaderList);
}

CUPnPDeviceFinderCallback::~CUPnPDeviceFinderCallback()
{
    // DeInit MUST have been called!
    //
    Assert(INVALID_HANDLE_VALUE == m_hSearch);
    Assert(INVALID_HANDLE_VALUE == m_hNotify);

    Assert(!m_pszSearch);
    Assert(!m_punkCallback);
    Assert(!m_lClientCookie);
    Assert(m_lBusyCount == 0);

    DeleteCriticalSection(&m_cs);
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::HrInit
//
//  Purpose:    Initializes the private callback helper object, storing the
//              search type and registering itself in the GIT.
//
//  Arguments:
//      punkCallback [in]   Callback function to invoke
//      pszSearch    [in]   URI for which to search for
//      lClientCookie [in]  Cookie to provide later when firing callback
//                          functions
//
//  Returns:    S_OK if successful, OLE error otherwise
//
//  Author:     danielwe   7 Dec 1999
//
//  Notes:      The m_hSearch and m_hNotify members won't be valid until
//              StartSearch() is called.
//
HRESULT
CUPnPDeviceFinderCallback::HrInit(IUnknown * punkCallback,
                                  LPCSTR pszSearch,
                                  LONG lClientCookie)
{
    Assert(pszSearch);
    Assert(*pszSearch);
    Assert(punkCallback);
    Assert(DFC_SS_UNINITIALIZED == m_ss);
    Assert(lClientCookie);

    // we can only be called here once
    Assert(INVALID_HANDLE_VALUE == m_hSearch);
    Assert(INVALID_HANDLE_VALUE == m_hNotify);
    Assert(!m_fCanceled);
    Assert(!m_pszSearch);
    Assert(!m_punkCallback);
    Assert(!m_lClientCookie);

    HRESULT hr;
    IGlobalInterfaceTable * pgit;

    hr = S_OK;
    pgit = NULL;

    m_pszSearch = SzaDupSza(pszSearch);
    if (!m_pszSearch)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    InitializeCriticalSection(&m_cs);
    m_fCleanup = FALSE;

    m_hTimerQ = CreateTimerQueue();
    if (!m_hTimerQ)
    {
        hr = HrFromLastWin32Error();
        goto Cleanup;
    }

    punkCallback->AddRef();
    m_punkCallback = punkCallback;

    // register ourselves in the GIT
    hr = HrGetGITPointer(&pgit);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    Assert(pgit);
    {
        IUnknown * punk;

        punk = GetUnknown();
        Assert(punk);

        hr = pgit->RegisterInterfaceInGlobal(punk,
                                             IID_IUPnPPrivateCallbackHelper,
                                             &m_dwGITCookie);
        if (FAILED(hr))
        {
            TraceError("CUPnPDeviceFinderCallback::HrInit: RegisterInterfaceInGlobal", hr);
            goto Cleanup;
        }
    }

    // note: if you add code here, you must call RevokeInterfaceFromGlobal
    //       in Cleanup if FAILED.  Try adding stuff before this call (with
    //       appropriate cleanup calls below) instead.
    //

    SetSearchState(DFC_SS_INITIALIZED);

    m_lClientCookie = lClientCookie;

Cleanup:
    ReleaseObj(pgit);

    if (FAILED(hr))
    {
        // cleanup stuff
        if (m_pszSearch)
        {
            m_pszSearch = NULL;
        }

        if (m_punkCallback)
        {
            m_punkCallback->Release();
            m_punkCallback = NULL;
        }

        if (m_hTimerQ)
        {
            DeleteTimerQueue(m_hTimerQ);
            m_hTimerQ = NULL;
        }
    }

    TraceError("CUPnPDeviceFinderCallback::HrInit", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::DeInitSsdp
//
//  Purpose:    Stops the ssdp search associated with this particualr find
//              operation, and frees any memory
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   7 Dec 1999
//
//  Notes:      This method MUST be called by someone holding a reference
//              count on us!
//
VOID CUPnPDeviceFinderCallback::DeInitSsdp()
{
    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinderCallback::DeInit");

    BOOL fRegisteredInGit;

    fRegisteredInGit = m_ss >= DFC_SS_INITIALIZED;

    SetSearchState(DFC_SS_CLEANUP);
    Assert(!m_fCanceled);
    m_fCanceled = TRUE;

    if (INVALID_HANDLE_VALUE != m_hSearch)
    {
        // cancel the ssdp search without closing, since that could cause a deadlock if we are busy
        // this function returns without waiting for the notification thread to exit, so we could
        // still receive notifications until FindServicesClose is called (in DeInit), we will receive
        // an SSDP_DONE for sure

        BOOL fResult;

        fResult = FindServicesCancel(m_hSearch);
        if (!fResult)
        {
            TraceLastWin32Error("CUPnPDeviceFinderCallback::DeInit: FindServicesCancel");
        }
    }

    if (INVALID_HANDLE_VALUE != m_hNotify)
    {
        // stop the notifications

        BOOL fResult;

        fResult = DeregisterNotification(m_hNotify);
        if (!fResult)
        {
            TraceLastWin32Error("CUPnPDeviceFinderCallback::DeInit: DeregisterNotification");
        }
        m_hNotify = INVALID_HANDLE_VALUE;
    }

    // note: we're guarenteed by ssdp not to be called back now

    m_lClientCookie = 0;

    // note(cmr): after this point, we're guarenteed by SSDP to not be called back
    //  on our notification callback
    //
    if (fRegisteredInGit)
    {
        // We've been registered in the GIT

        // remove ourselves from the GIT.  This will keep the ssdp callback
        // function's handle from working.
        //

        IGlobalInterfaceTable * pgit;
        HRESULT hr;

        pgit = NULL;

        hr = HrGetGITPointer(&pgit);
        if (SUCCEEDED(hr))
        {
            Assert(pgit);

            hr = pgit->RevokeInterfaceFromGlobal(m_dwGITCookie);
            TraceError("CUPnPDeviceFinderCallback::DeInit: RevokeInterfaceFromGlobal", hr);

            pgit->Release();
        }
        else
        {
            // hmm.  we're in trouble.
        }
    }

    if (m_pszSearch)
    {
        delete [] m_pszSearch;
        m_pszSearch = NULL;
    }

    // get rid of all the loaders, unless they are currently firing
    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    // retrieve first item
    ple = m_LoaderList.Flink;

    // search through list
    while (ple != &m_LoaderList)
    {
        // retrieve document loader info from entry
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        // is this loader stale?
        if (DFC_CBF_CURRENTLY_FIRING != pdli->m_cbfCallbackFired)
        {
            // remove from list
            RemoveEntryList(ple);

            // NOTE: calling FreeLoader here will delete the LIST_ENTRY
            // we are currently pointed at so we need to move to the next
            // item in the list before calling FreeLoader.
            ple = ple->Flink;

            // delete loader
            FreeLoader(pdli);
        }
        else
        {
            // next item...
            ple = ple->Flink;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::DeInit
//
//  Purpose:    Stops the ssdp search associated with this particualr find
//              operation, and frees any memory
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   7 Dec 1999
//
//  Notes:      This method MUST be called by someone holding a reference
//              count on us!
//
VOID CUPnPDeviceFinderCallback::DeInit()
{
    if (INVALID_HANDLE_VALUE != m_hSearch)
    {
        // close the ssdp search

        BOOL fResult;

        fResult = FindServicesClose(m_hSearch);
        if (!fResult)
        {
            TraceLastWin32Error("CUPnPDeviceFinderCallback::DeInit: FindServicesClose");
        }
        m_hSearch = INVALID_HANDLE_VALUE;
    }

    if (m_punkCallback)
    {
        m_punkCallback->Release();
        m_punkCallback = NULL;
    }

    // stop any async loadings going on
    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // loop through list
    while (!IsListEmpty(&m_LoaderList))
    {
        // remove the first item from list
        ple = RemoveHeadList(&m_LoaderList);

        // retrieve the document loader info block
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        // release
        FreeLoader(pdli);
    }

    TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinderCallback::DeInit - "
             "deleting timer queue");

    HANDLE  hEvent;

    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent)
    {
        TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinderCallback::DeInit - "
             "Getting lock...");

        EnterCriticalSection(&m_cs);

        m_fCleanup = TRUE;

        TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinderCallback::DeInit - "
                 "Deleting timer queue...");

        DeleteTimerQueueEx(m_hTimerQ, hEvent);
        m_hTimerQ = NULL;

        LeaveCriticalSection(&m_cs);

        TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinderCallback::DeInit - "
                     "Waiting on event to be signalled...");

        DWORD dwEventSignalled;

        (VOID) HrMyWaitForMultipleHandles(0, INFINITE, 1, &hEvent,
                                          &dwEventSignalled);
        Assert(!dwEventSignalled);

        TraceTag(ttidUPnPDeviceFinder, "CUPnPDeviceFinderCallback::DeInit - "
                 "..done!");
        PurgeContextFromDelayedDownloadList(this);

        CloseHandle(hEvent);
    }

    m_ss = DFC_SS_UNINITIALIZED;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::IsBusy
//
//  Purpose:    Are any loaders currently executing callbacks?
//
//  Arguments:  <none>
//
//  Returns:    TRUE/FALSE
//
BOOL
CUPnPDeviceFinderCallback::IsBusy()
{
    BOOL bIsBusy = FALSE;
    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    if (m_lBusyCount > 0) {
        // The device finder is in a callback
        bIsBusy = TRUE;
    }
    else
    {
        // retrieve first item
        ple = m_LoaderList.Flink;

        // search through list
        while (ple != &m_LoaderList)
        {
            // retrieve document loader info from entry
            pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

            if (DFC_CBF_CURRENTLY_FIRING == (pdli->m_cbfCallbackFired))
            {
                bIsBusy = TRUE;
                break;
            }
            else
            {
                // next item...
                ple = ple->Flink;
            }
        }
    }

    return bIsBusy;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::HrStartSearch
//
//  Purpose:    Starts the search a-la SSDP
//
//  Arguments:  <none>
//
//  Returns:    S_OK if successful, OLE error otherwise
//              S_FALSE if search has already been started
//
HRESULT
CUPnPDeviceFinderCallback::HrStartSearch()
{
    Assert(m_pszSearch);
    Assert(m_punkCallback);
    Assert(m_lClientCookie);
    // somehow HrStartSearch was called before HrInit
    Assert(m_ss > DFC_SS_UNINITIALIZED);

    HRESULT hr;

    hr = S_OK;

    if (m_ss >= DFC_SS_STARTED)
    {
        // we've already been started
        //
        hr = S_FALSE;
        goto Cleanup;
    }
    Assert(INVALID_HANDLE_VALUE == m_hSearch);
    Assert(INVALID_HANDLE_VALUE == m_hNotify);

    // note: AFTER this point we must go to Error to cleanup

    // note: set this first, since FindServicesCallback might bounce
    //       right back with 'new' (cached) results, and the loads from those
    //       urls might also be cached, and thus would bounce back immediately
    //       as well.
    SetSearchState(DFC_SS_STARTED);

    m_hSearch = FindServicesCallback(m_pszSearch,
                                     NULL,
                                     TRUE,
                                     CUPnPDeviceFinder::NotificationCallback,
                                     this);
    if (INVALID_HANDLE_VALUE == m_hSearch)
    {
        hr = HrFromLastWin32Error();
        TraceError("CUPnPDeviceFinder::FindServicesCallback", hr);

        SetSearchState(DFC_SS_INITIALIZED);

        goto Cleanup;
    }
    TraceTag(ttidUPnPDeviceFinder, "FindServicesCallback started");

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), INVALID_HANDLE_VALUE != m_hSearch));
    Assert(FImplies(FAILED(hr), INVALID_HANDLE_VALUE == m_hSearch));

    TraceError("CUPnPDeviceFinderCallback::HrStartSearch", hr);
    return hr;
}

HRESULT
HrFireDeviceAddedCallback(IUnknown * punkCallback,
                          LONG lContext,
                          BSTR bstrUdn,
                          IUPnPDevice * pud,
                          GUID * pguidInterface)
{
    Assert(punkCallback);
    Assert(bstrUdn);
    Assert(pud);

    HRESULT hr;

    // Try special interface for ICS
    IUPnPDeviceFinderAddCallbackWithInterface * pdfcwi = NULL;
    hr = punkCallback->QueryInterface(&pdfcwi);
    if(SUCCEEDED(hr))
    {
        hr = pdfcwi->DeviceAddedWithInterface(lContext, pud, pguidInterface);
        ReleaseObj(pdfcwi);
    }
    else if(E_NOINTERFACE == hr)
    {
        IUPnPDeviceFinderCallback * pdfc;

        // Figure out what type of callback pointer we have from the
        // IUnknown. It can be one of 2 possibilities. Either it is
        // a C/C++ callback in which case the interface would be
        // IUPnPDeviceFinderCallback, or it can be from script, in
        // which case it would be IDispatch. If it's neither, then
        // we can't do anything.
        //

        pdfc = NULL;

        hr = punkCallback->QueryInterface(IID_IUPnPDeviceFinderCallback,
                                         (LPVOID *)&pdfc);
        if (E_NOINTERFACE == hr)
        {
            IDispatch * pdisp;

            pdisp = NULL;

            hr = punkCallback->QueryInterface(IID_IDispatch,
                                              (LPVOID *)&pdisp);
            if (SUCCEEDED(hr))
            {
                hr = HrInvokeCallback(pdisp,
                                      DFC_NEW_DEVICE,
                                      bstrUdn,
                                      pud);
                ReleaseObj(pdisp);
            }
            else
            {
                TraceError("HrFireDeviceAddedCallback -"
                           " couln't find a callback interface!", hr);
            }
        }
        else if (SUCCEEDED(hr))
        {
            pdfc->DeviceAdded(lContext, pud);
            ReleaseObj(pdfc);
        }
    }
    else
    {
        // original QI failed unexpectedly
        TraceError("HrFireDeviceAddedCallback - QI failed", hr);
    }

    TraceError("HrFireDeviceAddedCallback", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::LoadComplete
//
//  Purpose:    Implementation of
//              IUPnPDescriptionDocumentCallback::LoadComplete.
//              Called when a description document finishes loading.
//
//  Arguments:  hrLoadResult    The result of the load operation.
//
//  Returns:    return value is ignored
//
//  Notes:      We only have one instance of IUPnPDescriptionDocumentCallback,
//              even though we may be loading many description documents
//              simultaneously.  Since the callback doesn't differentiate
//              which document finished loading, we look through ALL of the
//              currently loading documents each time this is called to see
//              if they've loaded.
//              Note: this might also be called after DeInit has been called.
//              Note: we can't call DeleteLoader() here because we're in
//              a callback from the description doc object, which DeleteLoader
//              might free.
//
STDMETHODIMP
CUPnPDeviceFinderCallback::LoadComplete(HRESULT hrLoadResult)
{
    Assert(m_ss >= DFC_SS_STARTED);

    HRESULT hr;
    ULONG iLoader;

    hr = S_OK;

    m_lBusyCount++;

    if (DFC_SS_CLEANUP == m_ss)
    {
        // we're stopping the search.  Just ignore things here.
        //
        goto Cleanup;
    }

    // find loaded documents in list

    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // retrieve first item
    ple = m_LoaderList.Flink;

    // note: don't make any calls which might allow the device
    //       finder to be re-entered (e.g. callbacks) when
    //       the local ple/pdli points to a DFC_CBF_FIRED object.
    //       If this happens, the entry at ple/pdli might be
    //       freed, and using it will crash.
    //


    // loop through list
    while (ple != &m_LoaderList)
    {
        // retrive document loader info from entry
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        // is the load done?

        if (DFC_CBF_NOT_FIRED == (pdli->m_cbfCallbackFired))
        {
            CComObject<CUPnPDescriptionDoc> * pDoc;
            READYSTATE rs;

            pDoc = pdli->m_pdoc;

            Assert(pDoc);

            hr = pDoc->get_ReadyState((LONG *)&rs);
            if (FAILED(hr))
            {
                TraceError("CUPnPDeviceFinderCallback::LoadComplete -"
                           " get_ReadyState", hr);
                continue;
            }

            if (READYSTATE_COMPLETE == rs)
            {
                IUPnPDevice * pud;
                BSTR bstrUdn;

                pud = NULL;
                bstrUdn = pdli->m_bstrUDN;

                hr = pDoc->DeviceByUDN(bstrUdn, &pud);
                if (SUCCEEDED(hr))
                {
                    Assert(pud);

                    TargetAttemptCompletedW(pdli->m_bstrUrl, TARGET_COMPLETE_OK);

                    // Set this whether we successfully fire the callback or not.
                    // We'll only try once.
                    //
                    // note: we must set this before firing the callback to
                    //       ensure that we don't fire the callback twice.
                    //       This could happen if the client pumps messages
                    //       from the callback.

                    pdli->m_cbfCallbackFired = DFC_CBF_CURRENTLY_FIRING;

                    HrFireDeviceAddedCallback(m_punkCallback,
                                              m_lClientCookie,
                                              bstrUdn,
                                              pud,
                                              &pdli->m_guidInterface);

                    pud->Release();
                }
                else
                {
                    TargetAttemptCompletedW(pdli->m_bstrUrl, TARGET_COMPLETE_FAIL);

                    TraceError("CUPnPDeviceFinderCallback::LoadComplete -"
                               " could not get deviceByUDN!", hr);
                }

                // note: we might have just failed to call the callback, but
                //       we set this anyway.  We'll only try once.
                pdli->m_cbfCallbackFired = DFC_CBF_FIRED;
            }
        }

        // next item...
        ple = ple->Flink;
    }

    hr = HrEnsureSearchDoneFired();

Cleanup:
    m_lBusyCount--;
    TraceError("CUPnPDeviceFinderCallback::LoadComplete", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinderCallback::HrAllocLoader
//
//  Purpose:    Creates a new description document object, AddRef()s
//              it, and stores it in the local list of all doc objects.
//
//  Arguments:
//      pszUdn [in]         UDN of desired device from the given document
//      fSearchResult [in]  TRUE if the result is being loaded as a result
//                          of an ssdp search (as opposed to the device
//                          announcing itself by a NOTIFY).  If this is TRUE,
//                          then the SearchDone() notification will not be
//                          sent until this document finishes loading
//                          (and is removed from the list of loading documents)
//      ppdoc [out]         Returns the new document object
//
//  Returns:    S_OK if success, E_OUTOFMEMORY if couldn't alloc memory
//
//  Notes:
//
HRESULT
CUPnPDeviceFinderCallback::HrAllocLoader(LPCWSTR pszUdn,
                                         BOOL fSearchResult,
                                         GUID *pguidInterface,
                                         DFC_DOCUMENT_LOADING_INFO ** ppddli)
{
    Assert(pszUdn);
    Assert(ppddli);
    Assert(FImplies(fSearchResult, m_ss < DFC_SS_DONE));

    HRESULT hr;
    CComObject<CUPnPDescriptionDoc> * pdoc;
    BSTR bstrTemp;
    DFC_DOCUMENT_LOADING_INFO * pddliResult;

    hr = E_OUTOFMEMORY;
    pdoc = NULL;
    bstrTemp = NULL;
    pddliResult = NULL;

    // allocate new document loading info
    pddliResult = new DFC_DOCUMENT_LOADING_INFO;
    if (pddliResult == NULL)
    {
        goto Cleanup;
    }

    // note: after this point we have to go to Error to clean up

    bstrTemp = ::SysAllocString(pszUdn);
    if (!bstrTemp)
    {
        goto Error;
    }

    hr = CComObject<CUPnPDescriptionDoc>::CreateInstance(&pdoc);
    if (FAILED(hr))
    {
        TraceError("CUPnPDeviceFinderCallback::HrAllocLoader: CreateInstance", hr);

        pdoc = NULL;
        goto Error;
    }
    Assert(pdoc);

    pdoc->AddRef();

    pddliResult->m_pdoc = pdoc;
    pddliResult->m_bstrUDN = bstrTemp;
    pddliResult->m_bstrUrl = NULL;
    pddliResult->m_fSearchResult = fSearchResult;
    pddliResult->m_cbfCallbackFired = DFC_CBF_NOT_FIRED;
    pddliResult->m_guidInterface = *pguidInterface ;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // insert into loader list
    InsertTailList(&m_LoaderList, &pddliResult->m_link);

    TraceTag(ttidUPnPDeviceFinder, "Alloc()ed loader 0x%08X.", pddliResult);

Cleanup:
    *ppddli = pddliResult;

    TraceError("CUPnPDeviceFinderCallback::HrAllocLoader", hr);
    return hr;

Error:
    if (pddliResult != NULL)
    {
        delete pddliResult;
        pddliResult = NULL;
    }

    if (bstrTemp != NULL)
    {
        ::SysFreeString(bstrTemp);
    }
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::DeleteLoader
//
//  Purpose:    This will stop a load in progress, free its memory,
//              and remove it from the list of docs.
//
//  Arguments:
//      pdoc [in]     search callback object to delete
//
//  Returns:    Nothing
//
//  Notes:
//
VOID
CUPnPDeviceFinderCallback::DeleteLoader(DFC_DOCUMENT_LOADING_INFO * pdliToDelete)
{
    Assert(pdliToDelete);

    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // retrieve first item
    ple = m_LoaderList.Flink;

    // search through list
    while (ple != &m_LoaderList)
    {
        Assert(ple);

        // retrieve document loader info from entry
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        // compare with given
        if (pdli == pdliToDelete)
        {
            // remove from list
            RemoveEntryList(ple);

            // release loader
            FreeLoader(pdli);

            break;
        }

        // next item
        ple = ple->Flink;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFinder::HrEnsureSearchDoneFired
//
//  Purpose:    This will fire the notification callback if the search
//              is completed.  The search is completed if both:
//                  - we have received the SSDP_DONE callback from SSDP
//                  - we have finished loading all description documents
//                    that have been returned as search results
//                    (excluding results that we received through NOTIFYs)
//
//  Arguments:  <none>
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Notes:
//
HRESULT
CUPnPDeviceFinderCallback::HrEnsureSearchDoneFired()
{
    HRESULT hr;
    IUPnPDeviceFinderCallback * pdfc;

    hr = S_OK;
    pdfc = NULL;

    if (m_ss >= DFC_SS_DONE || m_ss == DFC_SS_UNINITIALIZED)
    {
        // we're already fired the callback, or we're cleaning up
        goto Cleanup;
    }

    Assert(m_ss >= DFC_SS_STARTED);

    if (!m_fSsdpSearchDone)
    {
        // we're not firing the callback, SSDP isn't done yet
        goto Cleanup;
    }

    // SSDP is done and we haven't fired the callback, but check to make sure
    // that all description document loads that have been started from ssdp
    // search results have completed/failed
    PLIST_ENTRY ple;
    DFC_DOCUMENT_LOADING_INFO * pdli;

    Assert(GetCurrentThreadId() == m_nThreadId);

    // retrieve first item
    ple = m_LoaderList.Flink;

    // loop through list
    while (ple != &m_LoaderList)
    {
        // retrieve document loader info from entry
        pdli = CONTAINING_RECORD(ple, DFC_DOCUMENT_LOADING_INFO, m_link);

        if (pdli->m_fSearchResult &&
            (DFC_CBF_FIRED != (pdli->m_cbfCallbackFired)))
        {
#if DBG
            TraceTag(ttidUPnPDeviceFinder, "Still waiting on %S to finish "
                     "loading...", pdli->m_bstrUrl);
#endif
            // we still have a search result document that hasn't
            // been loaded yet
            //
            goto Cleanup;
        }

        // next item
        ple = ple->Flink;
    }

    // actually fire the search done callback.  We'll only try to do
    // this once.
    SetSearchState(DFC_SS_DONE);

    hr = m_punkCallback->QueryInterface(IID_IUPnPDeviceFinderCallback,
                                        (LPVOID *)&pdfc);
    if (E_NOINTERFACE == hr)
    {
        IDispatch * pdisp;

        pdisp = NULL;

        hr = m_punkCallback->QueryInterface(IID_IDispatch,
                                            (LPVOID *)&pdisp);
        if (SUCCEEDED(hr))
        {
            Assert(pdisp);

            hr = HrInvokeCallback(pdisp, DFC_DONE, NULL, NULL);
            ReleaseObj(pdisp);
        }
        else
        {
            TraceError("CUPnPDeviceFinderCallback::HrEnsureSearchDoneFired-"
                       " couln't find a callback interface!", hr);
        }
    }
    else if (SUCCEEDED(hr))
    {
        Assert(pdfc);

        pdfc->SearchComplete(m_lClientCookie);

        pdfc->Release();;
    }
    else
    {
        TraceError("CUPnPDeviceFinderCallback::HrEnsureSearchDoneFired-"
            "QI #1 failed", hr);
        goto Cleanup;
    }

Cleanup:
    TraceError("CUPnPDeviceFinderCallback::HrEnsureSearchDoneFired", hr);
    return hr;
}

VOID
CUPnPDeviceFinderCallback::SetSearchState(DFC_SEARCHSTATE ss)
{
    m_ss = ss;
}

DFC_SEARCHSTATE
CUPnPDeviceFinderCallback::GetSearchState() const
{
    return m_ss;
}



CFindByUdnDeviceFinderCallback::CFindByUdnDeviceFinderCallback()
{
    m_hEventLoaded = INVALID_HANDLE_VALUE;
    m_pszDesiredUdn = NULL;
    m_pud = NULL;
}

STDMETHODIMP
CFindByUdnDeviceFinderCallback::DeviceAdded(/* [in] */ LONG lFindData,
                                            /* [in] */ IUPnPDevice * pDevice)
{
    TraceTag(ttidUPnPDeviceFinder,
             "CFindByUdnDeviceFinderCallback::DeviceAdded");

    // this is really internal to us
    Assert(pDevice);
    Assert(m_pszDesiredUdn);

    HRESULT hr;

    hr = S_OK;

    if (!m_pud)
    {
        BSTR bstrUdn;

        bstrUdn = NULL;

        hr = pDevice->get_UniqueDeviceName(&bstrUdn);
        if (SUCCEEDED(hr))
        {
            if (bstrUdn)
            {
                int result;

                result = wcscmp(bstrUdn, m_pszDesiredUdn);
                if (0 == result)
                {
                    // we've found a matching device.  save it and signal our event
                    Assert(!m_pud);

                    pDevice->AddRef();
                    m_pud = pDevice;

                    SignalEvent();
                }
                else
                {
                    // our search resulted in a device with an unmatching udn.
                    // this isn't a bug, as we could just have some bogus device
                    // responding to our (supposed) udn search

                    TraceTag(ttidUPnPDeviceFinder,
                             "CFindByUdnDeviceFinderCallback::DeviceAdded: "
                             "device with bogus UDN found.  Found=%S, Desired=%S",
                             bstrUdn, m_pszDesiredUdn);
                }
            }

            ::SysFreeString(bstrUdn);
        }
    }
    // else, we've already found a matching device, and we only want one.
    // just return

    TraceError("CFindByUdnDeviceFinderCallback::DeviceAdded", hr);
    return hr;
}

STDMETHODIMP
CFindByUdnDeviceFinderCallback::DeviceRemoved(/* [in] */ LONG lFindData,
                                              /* [in] */ BSTR bstrUDN)
{
    // ignore
    return S_OK;
}

STDMETHODIMP
CFindByUdnDeviceFinderCallback::SearchComplete(/* [in] */ LONG lFindData)
{
    TraceTag(ttidUPnPDeviceFinder,
             "CFindByUdnDeviceFinderCallback::SearchComplete");

    SignalEvent();

    return S_OK;
}


// local methods
HRESULT
CFindByUdnDeviceFinderCallback::HrInit(LPCWSTR pszDesiredUdn,
                                       HANDLE hEventLoaded)
{
    Assert(hEventLoaded);
    Assert(pszDesiredUdn);
    // this can only be called once
    Assert(INVALID_HANDLE_VALUE == m_hEventLoaded);
    Assert(!m_pszDesiredUdn);

    HRESULT hr;

    hr = S_OK;

    m_pszDesiredUdn = WszAllocateAndCopyWsz(pszDesiredUdn);
    if (!m_pszDesiredUdn)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        HANDLE hProcess;
        BOOL fResult;

        hProcess = ::GetCurrentProcess();

        // note: we can only signal the event with this handle, not wait
        //       on it.  This is fine, since we only want to signal it
        //       anyway.
        //
        fResult = ::DuplicateHandle(hProcess,
                                    hEventLoaded,
                                    hProcess,
                                    &m_hEventLoaded,
                                    EVENT_MODIFY_STATE,
                                    FALSE,
                                    0);
        if (!fResult)
        {
            hr = HrFromLastWin32Error();
            TraceError("CFindByUdnDeviceFinderCallback::HrInit:"
                       "DuplicateHandle", hr);

            m_hEventLoaded = INVALID_HANDLE_VALUE;

            goto Cleanup;
        }

        // note: no need to close hndProcess
    }

    // note: if one adds code here, one must add code at Cleanup to
    //       cleanup the handle duplicated above

Cleanup:
    if (FAILED(hr))
    {
        if (m_pszDesiredUdn)
        {
            delete [] m_pszDesiredUdn;
            m_pszDesiredUdn = NULL;
        }
    }

    TraceError("CFindByUdnDeviceFinderCallback::HrInit", hr);
    return hr;
}

IUPnPDevice *
CFindByUdnDeviceFinderCallback::GetFoundDevice() const
{
    IUPnPDevice * pudResult;

    pudResult = m_pud;
    if (pudResult)
    {
        pudResult->AddRef();
    }

    return pudResult;
}

// ATL Methods
HRESULT
CFindByUdnDeviceFinderCallback::FinalRelease()
{
    if (INVALID_HANDLE_VALUE != m_hEventLoaded)
    {
        ::CloseHandle(m_hEventLoaded);
    }

    if (m_pszDesiredUdn)
    {
        delete [] m_pszDesiredUdn;
    }

    ReleaseObj(m_pud);

    return S_OK;
}

VOID
CFindByUdnDeviceFinderCallback::SignalEvent()
{
    Assert(INVALID_HANDLE_VALUE != m_hEventLoaded);

    BOOL fResult;

    fResult = ::SetEvent(m_hEventLoaded);
    if (!fResult)
    {
        // the call to SetEvent failed.  Uh oh.

        TraceLastWin32Error("CFindByUdnDeviceFinderCallback::SignalEvent");
    }
}


CFindSyncDeviceFinderCallback::CFindSyncDeviceFinderCallback()
{
    m_hEventComplete = INVALID_HANDLE_VALUE;
    m_pSearchResults = NULL;
}

STDMETHODIMP
CFindSyncDeviceFinderCallback::DeviceAdded(/* [in] */ LONG lFindData,
                                           /* [in] */ IUPnPDevice * pDevice)
{
    TraceTag(ttidUPnPDeviceFinder,
             "CFindSyncDeviceFinderCallback::DeviceAdded");

    Assert(pDevice);
    Assert(m_pSearchResults);

    HRESULT hr;

    // TODO(cmr): we should replace the device in the list if its UDN already exists

    // add the device to the search results
    hr = m_pSearchResults->HrAddDevice(pDevice);

    TraceError("CFindSyncDeviceFinderCallback::DeviceAdded", hr);
    return hr;
}

STDMETHODIMP
CFindSyncDeviceFinderCallback::DeviceRemoved(/* [in] */ LONG lFindData,
                                              /* [in] */ BSTR bstrUDN)
{
    TraceTag(ttidUPnPDeviceFinder,
             "CFindSyncDeviceFinderCallback::DeviceRemoved");

    // TODO(cmr): we should remove the device from the list

    return S_OK;
}

STDMETHODIMP
CFindSyncDeviceFinderCallback::SearchComplete(/* [in] */ LONG lFindData)
{
    TraceTag(ttidUPnPDeviceFinder,
             "CFindSyncDeviceFinderCallback::SearchComplete");

    SignalEvent();

    return S_OK;
}


// local methods
HRESULT
CFindSyncDeviceFinderCallback::HrInit(HANDLE hEventSearchComplete,
                                      CComObject<CUPnPDevices> * pSearchResults)
{
    Assert(hEventSearchComplete);
    Assert(pSearchResults);

    // this can only be called once
    Assert(INVALID_HANDLE_VALUE == m_hEventComplete);
    Assert(!m_pSearchResults);

    HRESULT hr;

    hr = S_OK;


    pSearchResults->AddRef();
    m_pSearchResults = pSearchResults;

    {
        HANDLE hProcess;
        BOOL fResult;

        hProcess = ::GetCurrentProcess();

        // note: we can only signal the event with this handle, not wait
        //       on it.  This is fine, since we only want to signal it
        //       anyway.
        //
        fResult = ::DuplicateHandle(hProcess,
                                    hEventSearchComplete,
                                    hProcess,
                                    &m_hEventComplete,
                                    EVENT_MODIFY_STATE,
                                    FALSE,
                                    0);
        if (!fResult)
        {
            hr = HrFromLastWin32Error();
            TraceError("CFindByUdnDeviceFinderCallback::HrInit:"
                       "DuplicateHandle", hr);

            m_hEventComplete = INVALID_HANDLE_VALUE;

            goto Cleanup;
        }

        // note: no need to close hndProcess
    }

    // note: if one adds code here, one must add code at Cleanup to
    //       cleanup the handle duplicated above

Cleanup:
    if (FAILED(hr))
    {
        Assert(m_pSearchResults);
        m_pSearchResults->Release();
        m_pSearchResults = NULL;
    }

    TraceError("CFindSyncDeviceFinderCallback::HrInit", hr);
    return hr;
}

// ATL Methods
HRESULT
CFindSyncDeviceFinderCallback::FinalRelease()
{
    if (INVALID_HANDLE_VALUE != m_hEventComplete)
    {
        ::CloseHandle(m_hEventComplete);
    }

    ReleaseObj(m_pSearchResults);

    return S_OK;
}

VOID
CFindSyncDeviceFinderCallback::SignalEvent()
{
    Assert(INVALID_HANDLE_VALUE != m_hEventComplete);

    BOOL fResult;

    fResult = ::SetEvent(m_hEventComplete);
    if (!fResult)
    {
        // the call to SetEvent failed.  Uh oh.

        TraceLastWin32Error("CFindSyncDeviceFinderCallback::SignalEvent");
    }
}

VOID
CFinderCollector::Add(CComObject<CUPnPDeviceFinderCallback> * pdfc)
{
    if (pdfc)
    {
        DFC_DEVICE_FINDER_INFO * pdfi = new DFC_DEVICE_FINDER_INFO;
        if (pdfi)
        {
            pdfi->m_pdfc = pdfc;
            InsertTailList(&m_FinderList, &pdfi->m_link);
        }
        else
        {
            // there's nothing we can do about this now :(
        }
    }
}

VOID CFinderCollector::CleanUp(BOOL bForceRemoval)
{
    PLIST_ENTRY ple;

    // retrieve first item
    ple = m_FinderList.Flink;

    // search through entire list
    while (ple != &m_FinderList)
    {
        DFC_DEVICE_FINDER_INFO * pdfi;

        // retrieve the device finder info block
        pdfi = CONTAINING_RECORD(ple, DFC_DEVICE_FINDER_INFO, m_link);

        Assert(pdfi->m_pdfc);

        if (bForceRemoval || !pdfi->m_pdfc->IsBusy())
        {
            RemoveEntryList(ple);

            // next item...
            ple = ple->Flink;

            pdfi->m_pdfc->DeInit();
            // free the search object
            pdfi->m_pdfc->Release();

            TraceTag(ttidUPnPDeviceFinder, "Freed finder 0x%08X.", pdfi->m_pdfc);

            pdfi->m_pdfc = NULL;
            delete pdfi;
        }
        else
        {
            // next item...
            ple = ple->Flink;
        }
    }
}



// THe download list is used to keep track of download
// documents which are delayed.
// If a byebye is received while the downloads are pending,
// the record is removed. When the timer is fired, if the
// record is not found, the download is aborted.
VOID InitDelayedDownloadList()
{
    if (0 == g_initDelayedDownload)
    {
        InitializeCriticalSection(&g_csDelayedDownload);
        EnterCriticalSection(&g_csDelayedDownload);
        InitializeListHead(&g_listDelayedDownload);
        LeaveCriticalSection(&g_csDelayedDownload);
    }
    g_initDelayedDownload++;
}

VOID TermDelayedDownloadList()
{
    PLIST_ENTRY     p;

    if (g_initDelayedDownload)
    {
        g_initDelayedDownload--;

        if (0 == g_initDelayedDownload)
        {
            EnterCriticalSection(&g_csDelayedDownload);

            PLIST_ENTRY     pListHead = &g_listDelayedDownload;

            for (p = pListHead->Flink; p != pListHead;)
            {
                PLIST_ENTRY pFound;

                pFound = p;

                p = p->Flink;

                RemoveEntryList(pFound);
            }

            LeaveCriticalSection(&g_csDelayedDownload);

            DeleteCriticalSection(&g_csDelayedDownload);
        }
    }
}

VOID AddToDelayedDownloadList(CALLBACK_PARAMS* pcp)
{
    EnterCriticalSection(&g_csDelayedDownload);
    InsertHeadList(&g_listDelayedDownload, &(pcp->linkage));
    LeaveCriticalSection(&g_csDelayedDownload);
}

BOOL RemoveMatchFromDelayedDownloadList(SSDP_MESSAGE* pSsdpMessage, LPVOID pContext)
{
    CALLBACK_PARAMS* pFound = NULL;

    if (g_initDelayedDownload)
    {
        EnterCriticalSection(&g_csDelayedDownload);

        PLIST_ENTRY     p;
        PLIST_ENTRY     pListHead = &g_listDelayedDownload;

        for (p = pListHead->Flink; p != pListHead;)
        {
            CALLBACK_PARAMS* pTmp;

            pTmp = CONTAINING_RECORD (p, CALLBACK_PARAMS, linkage);

            p = p->Flink;

            if (pContext == pTmp->pContext &&
                strcmp(pTmp->pSsdpMessage->szUSN, pSsdpMessage->szUSN) == 0)
            {
                pFound = pTmp;
                break;
            }
        }

        if (pFound)
        {
            RemoveEntryList(&(pFound->linkage));
        }

        LeaveCriticalSection(&g_csDelayedDownload);
    }

    return (pFound != NULL);
}

BOOL RemoveFromDelayedDownloadList(CALLBACK_PARAMS* pcp)
{
    CALLBACK_PARAMS* pFound = NULL;

    if (g_initDelayedDownload)
    {
        EnterCriticalSection(&g_csDelayedDownload);

        PLIST_ENTRY     p;
        PLIST_ENTRY     pListHead = &g_listDelayedDownload;

        for (p = pListHead->Flink; p != pListHead;)
        {
            CALLBACK_PARAMS* pTmp;

            pTmp = CONTAINING_RECORD (p, CALLBACK_PARAMS, linkage);

            p = p->Flink;

            if (pTmp == pcp)
            {
                pFound = pTmp;
                break;
            }
        }

        if (pFound)
        {
            RemoveEntryList(&(pFound->linkage));
        }

        LeaveCriticalSection(&g_csDelayedDownload);
    }

    return (pFound != NULL);
}

// Remove all the entries associated with a given context
VOID PurgeContextFromDelayedDownloadList(LPVOID pContext)
{
    if (g_initDelayedDownload)
    {
        EnterCriticalSection(&g_csDelayedDownload);

        PLIST_ENTRY     p;
        PLIST_ENTRY     pListHead = &g_listDelayedDownload;

        for (p = pListHead->Flink; p != pListHead;)
        {
            CALLBACK_PARAMS* pTmp;

            pTmp = CONTAINING_RECORD (p, CALLBACK_PARAMS, linkage);

            p = p->Flink;

            if (pContext == pTmp->pContext)
            {
                RemoveEntryList(&(pTmp->linkage));
            }
        }

        LeaveCriticalSection(&g_csDelayedDownload);
    }
}

// test if Done is the only element in the list.
// if it is then process done
VOID TestDelayedDownloadsDone(LPVOID pContext)
{
    CALLBACK_PARAMS* pFound = NULL;

    if (g_initDelayedDownload)
    {
        EnterCriticalSection(&g_csDelayedDownload);

        PLIST_ENTRY     p;
        PLIST_ENTRY     pListHead = &g_listDelayedDownload;

        for (p = pListHead->Flink; p != pListHead;)
        {
            CALLBACK_PARAMS* pTmp;

            pTmp = CONTAINING_RECORD (p, CALLBACK_PARAMS, linkage);

            p = p->Flink;

            if (pContext == pTmp->pContext)
            {
                if (pTmp->sctType == SSDP_DONE)
                {
                    // found a done
                    pFound = pTmp;
                }
                else
                {
                    // found something else.  Not done.
                    pFound = NULL;
                    break;
                }
            }
        }

        if (pFound)
        {
            RemoveEntryList(&(pFound->linkage));
        }

        LeaveCriticalSection(&g_csDelayedDownload);

        if (pFound)
        {
            CUPnPDeviceFinder::NotificationCallbackHelper(pFound, TRUE);
            // data referenced by pFound may be deleted, so
            // do not dereference it anymore.
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdevice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdevice.cpp
//
//  Contents:   IUPnPDevice implementation for CUPnPDevice.
//
//  Notes:      This is simply a COM wrapper for a CUPnPDeviceNode.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "UPnPDevice.h"
#include "node.h"
#include "enumhelper.h"
#include "upnpservicenodelist.h"
#include "upnpdevicenode.h"


#define SAFE_WRAP(pointer, methodcall) return (pointer) ? pointer->methodcall : E_UNEXPECTED


CUPnPDevice::CUPnPDevice()
{
    _pdevnode = NULL;
    _punk = NULL;
}

CUPnPDevice::~CUPnPDevice()
{
    Assert(!_pdevnode);
    Assert(!_punk);
}

HRESULT
CUPnPDevice::FinalConstruct()
{
    return S_OK;
}


HRESULT
CUPnPDevice::FinalRelease()
{
    if (_pdevnode)
    {
        // we must unwrap() the node, so that they don't
        // think we're still around.
        _pdevnode->Unwrap();
        _pdevnode = NULL;
    }
    SAFE_RELEASE(_punk);

    return S_OK;
}

void
CUPnPDevice::Init(CUPnPDeviceNode * pdevnode, IUnknown * punk)
{
    Assert(pdevnode);
    Assert(punk);

    _pdevnode = pdevnode;

    punk->AddRef();
    _punk = punk;
}

void
CUPnPDevice::Deinit()
{
    // note: we still keep the ref on the doc around
    // until we're released.  this shouldn't be necessary....
    _pdevnode = NULL;
}

// IUPnPDevice methods

STDMETHODIMP
CUPnPDevice::get_IsRootDevice(VARIANT_BOOL *pvarb)
{
    SAFE_WRAP(_pdevnode, get_IsRootDevice(pvarb));
}

STDMETHODIMP
CUPnPDevice::get_RootDevice(IUPnPDevice **ppudDeviceRoot)
{
    SAFE_WRAP(_pdevnode, get_RootDevice(ppudDeviceRoot));
}

STDMETHODIMP
CUPnPDevice::get_ParentDevice(IUPnPDevice **ppudDeviceParent)
{
    SAFE_WRAP(_pdevnode, get_ParentDevice(ppudDeviceParent));
}

STDMETHODIMP
CUPnPDevice::get_HasChildren(VARIANT_BOOL * pvarb)
{
    SAFE_WRAP(_pdevnode, get_HasChildren(pvarb));
}

STDMETHODIMP
CUPnPDevice::get_Children(IUPnPDevices **ppudChildren)
{
    SAFE_WRAP(_pdevnode, get_Children(ppudChildren));
}

STDMETHODIMP
CUPnPDevice::get_UniqueDeviceName(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_UniqueDeviceName(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_FriendlyName(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_FriendlyName(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_Type(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_Type(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_PresentationURL(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_PresentationURL(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_ManufacturerName(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_ManufacturerName(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_ManufacturerURL(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_ManufacturerURL(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_ModelName(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_ModelName(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_ModelNumber(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_ModelNumber(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_Description(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_Description(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_ModelURL(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_ModelURL(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_UPC(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_UPC(pbstr));
}

STDMETHODIMP
CUPnPDevice::get_SerialNumber(BSTR *pbstr)
{
    SAFE_WRAP(_pdevnode, get_SerialNumber(pbstr));
}

STDMETHODIMP
CUPnPDevice::IconURL(BSTR bstrEncodingFormat,
                     LONG lSizeX,
                     LONG lSizeY,
                     LONG lBitDepth,
                     BSTR * pbstrIconUrl)
{
    SAFE_WRAP(_pdevnode, IconURL(bstrEncodingFormat, lSizeX, lSizeY, lBitDepth, pbstrIconUrl));
}

STDMETHODIMP
CUPnPDevice::get_Services(IUPnPServices **ppusServices)
{
    SAFE_WRAP(_pdevnode, get_Services(ppusServices));
}

// IUPnPDeviceDocumentAccess method

STDMETHODIMP
CUPnPDevice::GetDocumentURL(BSTR* pDocumentUrl)
{
    SAFE_WRAP(_pdevnode, GetDocumentURL(pDocumentUrl));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdocumentbsc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocumentbsc.cpp
//
//  Contents:   implementation of CUPnPDocumentBSC
//
//  Notes:      a helper class that implements IBindStatusCallback
//              and sends notifiations to a CUPnPDocument
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "upnpdocument.h"
#include "upnpdocumentbsc.h"


CUPnPDocumentBSC::CUPnPDocumentBSC()
{
    _pdoc = NULL;
    _pbscOld = NULL;
    _pBinding = NULL;

    _fIsBinding = FALSE;
    _fAsync = FALSE;
}

CUPnPDocumentBSC::~CUPnPDocumentBSC()
{
    Assert(!_pdoc);
    Assert(!_pbscOld);
    Assert(!_pBinding);
}


// registers a BSC object with a particular bind context
// it will also addref itself.
//
HRESULT
CUPnPDocumentBSC::Init(CUPnPDocument * pdoc,
                       IBindCtx * pbc,
                       ULONG ulNumFormats,
                       const LPCTSTR * arylpszContentTypes,
                       BOOL fAsync)
{
    Assert(pdoc);
    Assert(FImplies(ulNumFormats, arylpszContentTypes));

    HRESULT hr;
    IBindStatusCallback * pbsc = NULL;
    IEnumFORMATETC * pefe = NULL;

    _fAsync = fAsync;

    _pdoc = pdoc;

    // <dark magic>
    //   we need an un-addref()'d pbsc to hand to RBSC().  We also want to
    //   addref() _puddbsc for our doc.
    //   the magic?  _puddsc was created with a refcount of 0 (ala ATL),
    //   but since we _have_ to QI for pbsc we're driving it to 1.
    //   now just pretend that we had really addref()d ourselves and
    //   release()d pbsc, and we're done.
    // </dark magic>
    // note: we do this first since we're expected to AddRef() ourselves
    //       even if we fail.
    hr = GetUnknown()->QueryInterface(IID_IBindStatusCallback, (void**)&pbsc);
    Assert(SUCCEEDED(hr));
    Assert(pbsc);

    if (!pbc)
    {
        // we're all done

        hr = S_OK;
        goto Cleanup;
    }

    // only put stuff that needs a pbc after here...

    // Make our format enumerator
    if (ulNumFormats)
    {
        hr = EnumFormatEtcFromLPCTSTRArray(ulNumFormats, arylpszContentTypes, &pefe);
        if (S_OK != hr)
        {
            TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::Init - EnumFormatEtcFromLPCTSTRArray failed, hr=%xd", hr);

            goto Cleanup;
        }
        Assert(pefe);

        hr = ::RegisterFormatEnumerator(pbc, pefe, 0);
        if (S_OK != hr)
        {
            TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::Init - RegisterFormatEnumerator failed, hr=%xd", hr);
            pefe->Release();
            pefe = NULL;
            goto Cleanup;
        }
    }

    hr = ::RegisterBindStatusCallback(pbc, pbsc, &_pbscOld, 0);
    if (S_OK != hr)
    {
        TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::Init - RegisterBindStatusCallback failed, hr=%xd", hr);

        _pbscOld = NULL;

        // clean up the Enumerator
        if (ulNumFormats)
        {
            goto Error;
        }

        goto Cleanup;
    }

    // note: if anyone adds code at this point that can fail, be sure to call
    //       RevokeBindStatusCallback

Cleanup:
    // note (cmr): we're not releasing pefe here.  the sdk documentation
    //      isn't very good, so I don't really know what to do.  existing code in
    //      the NT tree doesn't release it.  tracing through the current
    //      urlmon code shows that RegisterFormatEnumerator AddRef()s pefe,
    //      but that CreateFormatEnumerator returns an un-AddRef()d
    //      IEnumFormatEtc pointer.  This seems to be against common COM
    //      practice, if not against a specific rule.
    //      Oh well.  Hope we don't leak.

    // note (jdewey): cmr was wrong. CreateFormatEnumerator returns an AddRef()d
    //      IEnumFormatEtc pointer, and RegisterFormatEnumerator() AddRefs it.

    if (pefe)
    {
        pefe->Release();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDocumentBSC::Init");
    return hr;

Error:
    // only go here if we have to unregister an enumerator
    Assert(pbc);
    Assert(pefe);
    ::RevokeFormatEnumerator(pbc, pefe);

    goto Cleanup;
}

// pbc is the bind context (if it's still around) to unregister from
void
CUPnPDocumentBSC::Deinit(IBindCtx * pbc)
{
    IBindStatusCallback * pbsc;
    HRESULT hr;
    if (_fIsBinding)
    {
        // Oops.  In theory, this is might be bad: if _pbscOld isn't NULL,
        // that means that unregistered it from the bind context when
        // registering ourselves, but now we're going away and never ended
        // up actually starting the binding.  There's really not anything
        // we can do about this, but it shouldn't really matter - the only
        // way this would affect a client is if they were to re-use the
        // same bind context for some other subsequent bind operation
        // without re-registering it.  But this is broken anyway with the
        // current implemention of url monikers.
        SAFE_RELEASE(_pbscOld);
    }

    if (pbc)
    {
        // assume that (at least someone, presumably our doc) has a ref
        // on ourselves
        hr = GetUnknown()->QueryInterface(IID_IBindStatusCallback, (void**)&pbsc);
        Assert(SUCCEEDED(hr));
        Assert(pbsc);

        hr = ::RevokeBindStatusCallback(pbc, pbsc);
        if (S_OK != hr)
        {
            TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::Deinit - RevokeBindStatusCallback failed, hr=%xd", hr);
        }

        pbsc->Release();
    }

    _pdoc = NULL;
}

HRESULT
CUPnPDocumentBSC::FinalConstruct()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::FinalConstruct");

    return S_OK;
}

HRESULT
CUPnPDocumentBSC::FinalRelease()
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::FinalRelease");

    // the doc that creates us MUST call Deinit() before releasing us.
    Assert(!_pdoc);

    // we free this in OnStopBinding.  We can only have this pointer if
    // a binding operation has started, at which point we ALWAYS expect
    // OnStopBinding to be called.
    Assert(!_pBinding);

    // if we went through a bind operation, we cleaned this up in
    // OnStopBinding().  Otherwise, we cleaned it up in Deinit().
    Assert(!_pbscOld);

    return S_OK;
}

// this function takes a LPCTSTR array of length ulNumFormats that
// represents the acceptable mime/types (e.g. ones that would appear
// in a http "Accept:" tag).  This returns an
// IEnumFORMATETC pointer (that can be passed to CreateAsyncBindCtx[Ex]
// or RegisterFormatEnumerator).
HRESULT
CUPnPDocumentBSC::EnumFormatEtcFromLPCTSTRArray(ULONG ulNumFormats,
                                          const LPCTSTR * arylpszContentTypes,
                                          IEnumFORMATETC ** ppefe)
{
    Assert(ulNumFormats);
    Assert(FImplies(ulNumFormats, arylpszContentTypes));
    Assert(ppefe);

    HRESULT hr;
    FORMATETC * pfe;

    DWORD dwFormatTemp;
    ULONG i;

    pfe = new FORMATETC [ulNumFormats];
    if (!pfe)
    {
        hr = E_OUTOFMEMORY;

        goto Cleanup;
    }

    for (i = 0; i < ulNumFormats; ++i)
    {
        dwFormatTemp = ::RegisterClipboardFormat(arylpszContentTypes[i]);
        if (0 == dwFormatTemp)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());

            TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::EnumFormatEtcFromLPCTSTRArray - RegisterClipboardFormat failed, hr=%xd", hr);

            goto Cleanup;
        }

        pfe[i].cfFormat = dwFormatTemp;
        pfe[i].ptd = NULL;
        pfe[i].dwAspect = DVASPECT_CONTENT;
        pfe[i].lindex = -1;
        pfe[i].tymed = TYMED_NULL;
    }

    hr = ::CreateFormatEnumerator(ulNumFormats, pfe, ppefe);
    if (S_OK != hr)
    {
        TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentBSC::EnumFormatEtcFromLPCTSTRArray - CreateFormatEnumerator failed, hr=%xd", hr);
    }

Cleanup:
    if (pfe)
    {
        delete [] pfe;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDocumentBSC::EnumFormatEtcFromLPCTSTRArray");
    return hr;
}


STDMETHODIMP
CUPnPDocumentBSC::GetBindInfo(DWORD *grfBINDF, BINDINFO *pbindinfo)
{
    HRESULT hr;

    // only called when loading synchronously

    hr = S_OK;

    if (!grfBINDF)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pbindinfo)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *grfBINDF = BINDF_RESYNCHRONIZE | BINDF_PULLDATA;
    // note(cmr): the flags here should be the same flags the XML parser
    //            passes to its implementation of GetBindInfo(), for
    //            consistency between sync and async loads.

    if (_fAsync)
    {
        *grfBINDF  |= BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE;
    }

    // see the "URL Monikers Overview" in MSDN for what to do here.
    // the cbSize value of the structure is valid, but nothing
    // else.
    // we have to clear out all the bytes of the structure first,
    // even if we don't know what they mean...

    {
        DWORD cbSize;

        cbSize = pbindinfo->cbSize;
        ::ZeroMemory(pbindinfo, cbSize);

        // note: this also implicitly sets dwCodePage to 0 (e.g. CP_ACP == ANSI).
        //       everyone else seems to do this, and it seems like the right
        //       thing to do here.

        pbindinfo->cbSize = cbSize;
    }

    // note(cmr): supposedly this structure was smaller before IE 4.
    //            the docs don't say how small.  it seems that the
    //            dwVerb field was always around, though, and that's
    //            all we care about here.  If we care about more later,
    //            we need to test cbSize.

    pbindinfo->dwBindVerb = BINDVERB_GET;

Cleanup:
    return hr;
}

// IBindStatusCallback Methods
STDMETHODIMP
CUPnPDocumentBSC::OnStartBinding(DWORD dwReserved, IBinding *pib)
{
    HRESULT hr;

    Assert(!_pBinding);

    hr = S_OK;

    if (pib)
    {
        pib->AddRef();
        _pBinding = pib;
    }
    else
    {
        TraceTag(ttidUPnPDescriptionDoc, "CUPnPDocumentBSC::OnStartBinding - IBinding is NULL");
        hr = E_INVALIDARG;
    }

    _fIsBinding = TRUE;

    if (_pbscOld)
    {
        hr = _pbscOld->OnStartBinding(dwReserved, pib);
        TraceError("CUPnPDocumentBSC::OnStartBinding - pbscOld->OnStartBinding", hr);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDocumentBSC::OnStartBinding");
    return hr;
}

STDMETHODIMP
CUPnPDocumentBSC::GetPriority(LONG *pnPriority)
{
    HRESULT hr;

    // note(cmr): it seems that URLMON doesn't call
    //            this for URL streams, so don't implement
    //            this as it would be dead code.  If we ever
    //            get called here though, we need to implement
    //            this.
    Assert(FALSE);

    hr = E_NOTIMPL;

    if (_pbscOld)
    {
        // since we don't really care about this, always
        // defer to anyone else...

        hr = _pbscOld->GetPriority(pnPriority);
    }

    return hr;
}

STDMETHODIMP
CUPnPDocumentBSC::OnProgress(ULONG ulProgress,
                             ULONG ulProgressMax,
                             ULONG ulStatusCode,
                             LPCWSTR szStatusText)
{
    HRESULT hr = S_OK;

    if (_pdoc)
    {
        switch (ulStatusCode)
        {
        case BINDSTATUS_REDIRECTING:
        case BINDSTATUS_BEGINDOWNLOADDATA:

        if (szStatusText)
            {
                // make sure that someone isn't doing something sneaky, like
                // redirecting us to an url that we're not allowed to visit

                BOOL fIsAllowed;

                fIsAllowed = _pdoc->fIsUrlLoadAllowed(szStatusText);
                if (!fIsAllowed)
                {
                    TraceTag(ttidUPnPDescriptionDoc,
                             "OBJ: CUPnPDocumentBSC::OnProgress: we were redirected to an insecure URL.  Aborting load.");

                    hr = _pdoc->AbortLoading();
                    if (FAILED(hr))
                    {
                        goto Cleanup;
                    }
                }
                else
                {
                    // the url is in szStatusText
                    hr = _pdoc->SetBaseUrl(szStatusText);
                    if (FAILED(hr))
                    {
                        goto Cleanup;
                    }
                }
            }
            break;

        default:
            // nothing to see here
            break;
        }
    }

    if (_pbscOld)
    {
        hr = _pbscOld->OnProgress(ulProgress, ulProgressMax, ulStatusCode, szStatusText);
    }

Cleanup:
    return hr;
}

// shouldn't be called
STDMETHODIMP
CUPnPDocumentBSC::OnDataAvailable (/* [in] */ DWORD grfBSCF,
                             /* [in] */ DWORD dwSize,
                             /* [in] */ FORMATETC *pformatetc,
                             /* [in] */ STGMEDIUM *pstgmed)
{
    // note(cmr): the urlmon docs imply that we shouldn't
    //            get this callback but we do anyway.  hmm.

    return S_OK;
}

// shouldn't be called
STDMETHODIMP
CUPnPDocumentBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    return E_UNEXPECTED;
}

STDMETHODIMP
CUPnPDocumentBSC::OnLowResource(DWORD dwReserved)
{
    HRESULT hr = E_NOTIMPL;

    if (_pbscOld)
    {
        hr = _pbscOld->OnLowResource(dwReserved);
    }

    return hr;
}

STDMETHODIMP
CUPnPDocumentBSC::OnStopBinding (/* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError)
{
    HRESULT hr = S_OK;

    if (!_fIsBinding)
    {
        // note(cmr): the XML parser calls OnStopBinding manually in
        //            URLCallback::Abort().  This seems entirely random,
        //            as we get a OnStopBinding call anyway when the binding
        //            operation is aborted.  The result is that we get called
        //            here twice.  Until we realize that this is happening for
        //            a good reason, just ignore "extra" OnStopBinding
        //            calls.

        Assert(!_pbscOld);
        Assert(!_pBinding);

        goto Cleanup;
    }

    //TODO(cmr): snag Content-Base header from _pBinding...

    if (_pbscOld)
    {
        hr = _pbscOld->OnStopBinding(hr, szError);
    }

    SAFE_RELEASE(_pbscOld);
    // note(cmr): looking at the urlmon code, it seems wrong to do this here.
    //            lots of other code does it though....
    SAFE_RELEASE(_pBinding);

    _fIsBinding = FALSE;

Cleanup:
    return hr;
}

HRESULT
CUPnPDocumentBSC::Abort()
{
    HRESULT hr;

    if (!_pBinding)
    {
        // either we're not in a bind operation or we were somehow
        // not supplied a binding pointer  IBinding::Abort might
        // return E_FAIL, and we want  to be different.
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    hr = _pBinding->Abort();

Cleanup:
    return hr;
}

// note that IsBinding will even be true after Abort has been called if
// OnStopBinding hasn't yet been invoked.
BOOL
CUPnPDocumentBSC::IsBinding()
{
    return _fIsBinding;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdocument.cpp ===
//depot/private/upnp/net/upnp/upnp/api/upnpdocument.cpp#2 - edit change 2746 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocument.cpp
//
//  Contents:   implementation of CUPnPDocument
//
//  Notes:      an abstract base class to help load xml documents via
//              IPersistMoniker/IBindStatusCallback
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop


#include "upnpdocument.h"
#include "upnpdocumentctx.h"

#include <exdisp.h>             // IID_IWebBrowser2
#include <shlguid.h>            // SID_SWebBrowserApp

#include <xmldomdid.h>          // for DISPID_XMLDOMEVENT_*

#include <ncstring.h>
#include <ncinet2.h>
#include <ncutil.h>

#define UPNP_MAX_DOCSIZE    (100 * 1024)

const TCHAR pszContentTypeTextXml [] = TEXT("text/xml");
const TCHAR pszContentTypeApplicationXml [] = TEXT("application/xml");

const LPCTSTR CUPnPDocument::s_aryAcceptFormats [] = { pszContentTypeTextXml, pszContentTypeApplicationXml };
const DWORD CUPnPDocument::s_cAcceptFormats = celems(s_aryAcceptFormats);

const TCHAR pszAcceptHeader [] = TEXT("Accept: ");
const TCHAR pszAcceptSep [] = TEXT(", ");

const DWORD c_dwOpenTimeout = 60000;

const char  szXmlHeader[] = "<?xml ";

static HINTERNET   g_hAsyncInetDocSess = NULL;
static int g_nAsyncInetDocSessCnt = 0;
static HINTERNET   g_hSyncInetDocSess = NULL;
static int g_nSyncInetDocSessCnt = 0;


HRESULT
HrReallocAndCopyString(LPWSTR * ppszDest, LPCWSTR pszSrc)
{
    Assert(ppszDest);

    HRESULT hr;
    LPWSTR pszTemp;

    hr = S_OK;

    pszTemp = NULL;

    if (pszSrc)
    {
        // copy the string into pszTemp
        pszTemp = WszAllocateAndCopyWsz(pszSrc);
        if (!pszTemp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    if (*ppszDest)
    {
        delete [] *ppszDest;
    }
    *ppszDest = pszTemp;

Cleanup:
    TraceError("HrReallocAndCopyString", hr);
    return hr;
}


// queries punk for IServiceProvider, and then asks
// that service provider for the interface riid, storing
// it in ppv if available
// returns S_FALSE if not available
HRESULT
HrQueryServiceForInterface(IUnknown * punk,
                           REFGUID guidService,
                           REFIID riid,
                           LPVOID * ppv)
{
    HRESULT hr;
    IServiceProvider * psp;
    LPVOID pvResult;

    psp = NULL;
    pvResult = NULL;

    hr = punk->QueryInterface(IID_IServiceProvider, (LPVOID *)&psp);
    if (FAILED(hr))
    {
        psp = NULL;

        if (E_NOINTERFACE == hr)
        {
            hr = S_FALSE;
        }
        else
        {
            TraceError("HrQueryServiceForInterface: QI failed!", hr);
        }

        goto Cleanup;
    }
    Assert(psp);

    hr = psp->QueryService(guidService,
                           riid,
                           &pvResult);
    if (FAILED(hr))
    {
        pvResult = NULL;

        if (E_NOINTERFACE == hr)
        {
            // note(cmr): MSDN says this should return SVC_E_UNKNOWNSERVICE,
            // but this error code doesn't seem to exist anywhere.
            //

            hr = S_FALSE;
        }
        else
        {
            TraceError("HrQueryServiceForInterface: IServiceProvider::QueryService failed!", hr);
        }

        goto Cleanup;
    }
    Assert(pvResult);

Cleanup:
    Assert(FImplies(S_OK == hr, pvResult));
    Assert(FImplies(S_OK != hr, !pvResult));

    SAFE_RELEASE(psp);

    *ppv = pvResult;

    TraceError("HrQueryServiceForInterface", hr);
    return hr;
}

VOID
InitInternetForDocs()
{
    if (NULL == g_hAsyncInetDocSess)
    {
        g_hAsyncInetDocSess = InternetOpen(TEXT("Mozilla/4.0 (compatible; UPnP/1.0; Windows NT/5.1)"),
                               INTERNET_OPEN_TYPE_DIRECT,
                               NULL, NULL, INTERNET_FLAG_ASYNC);


        TraceTag(ttidUPnPDocument, "InitInternetForDocs: create Async Internet session");
        if (g_hAsyncInetDocSess)
        {
            InternetSetOption( g_hAsyncInetDocSess,
                                   INTERNET_OPTION_CONNECT_TIMEOUT,
                                   (LPVOID)&c_dwOpenTimeout,
                                   sizeof(c_dwOpenTimeout));

            if (InternetSetStatusCallback(g_hAsyncInetDocSess,
                                        &CUPnPDocumentCtx::DocLoadCallback) ==
                                    INTERNET_INVALID_STATUS_CALLBACK)
            {
                InternetCloseHandle(g_hAsyncInetDocSess);
                g_hAsyncInetDocSess = NULL;
            }
        }

    }
    if (g_hAsyncInetDocSess)
        g_nAsyncInetDocSessCnt++;

    if (NULL == g_hSyncInetDocSess)
    {
        g_hSyncInetDocSess = InternetOpen(TEXT("Mozilla/4.0 (compatible; UPnP/1.0; Windows NT/5.1)"),
                               INTERNET_OPEN_TYPE_DIRECT,
                               NULL, NULL, 0);

        InternetSetOption( g_hSyncInetDocSess,
                               INTERNET_OPTION_CONNECT_TIMEOUT,
                               (LPVOID)&c_dwOpenTimeout,
                               sizeof(c_dwOpenTimeout));

        TraceTag(ttidUPnPDocument, "InitInternetForDocs: create Sync Internet session");
    }
    if (g_hSyncInetDocSess)
        g_nSyncInetDocSessCnt++;
}

VOID
CleanupInternetForDocs()
{
    if (g_nAsyncInetDocSessCnt > 0)
        g_nAsyncInetDocSessCnt--;

    if (0 == g_nAsyncInetDocSessCnt)
    {
        InternetCloseHandle(g_hAsyncInetDocSess);
        g_hAsyncInetDocSess = NULL;
        TraceTag(ttidUPnPDocument, "CleanupInternetForDocs: close Async Internet session");
    }

    if (g_nSyncInetDocSessCnt > 0)
        g_nSyncInetDocSessCnt--;

    if (0 == g_nSyncInetDocSessCnt)
    {
        InternetCloseHandle(g_hSyncInetDocSess);
        g_hSyncInetDocSess = NULL;
        TraceTag(ttidUPnPDocument, "CleanupInternetForDocs: close Sync Internet session");
    }
}


CUPnPDocument::CUPnPDocument()
{
    _pxdd = NULL;
    _puddctx = NULL;

    _rs = READYSTATE_UNINITIALIZED;
    _hrLoadResult = E_UNEXPECTED;
    _pszBaseUrl = NULL;
    _pszHostUrl = NULL;
    _pszSecurityUrl = NULL;
    m_bstrFullUrl = NULL;
    m_dwPendingSize = 0;
    m_szPendingBuf = NULL;
}

CUPnPDocument::~CUPnPDocument()
{
    Assert(!_pxdd);
    Assert(!_puddctx);

    Assert(!_pszBaseUrl);
    Assert(!_pszHostUrl);
    Assert(!_pszSecurityUrl);
    Assert(!m_bstrFullUrl);
}

HRESULT
CUPnPDocument::FinalConstruct()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::FinalConstruct");

    HRESULT hr;

    InitInternetForDocs();

    hr = CoCreateInstance ( CLSID_DOMDocument30,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IXMLDOMDocument,
                            (LPVOID *)&_pxdd );
    if (S_OK != hr)
    {
        TraceError("OBJ: CUPnPDocument::FinalConstruct - CoCreateInstance(CLSID_DOMDocument)", hr);

        _pxdd = NULL;
        goto Error;
    }
    Assert(_pxdd);

    hr = _pxdd->put_resolveExternals(VARIANT_FALSE);
    if (FAILED(hr))
    {
        TraceError("OBJ: CUPnPDocument::FinalConstruct - put_resolveExternals", hr);

        goto Error;
    }

    hr = _pxdd->put_validateOnParse(VARIANT_FALSE);
    if (FAILED(hr))
    {
        TraceError("OBJ: CUPnPDocument::FinalConstruct - put_validateOnParse", hr);

        goto Error;
    }

Cleanup:
    TraceError("CUPnPDocument::FinalConstruct", hr);
    return hr;

Error:
    // weirdness: we possibly have a partially constructed object.
    //            and it would make sense to clean things up here.
    //            Since we're returning a failure code, though, ATL
    //            is going to immediately call FinalRelease.
    //            Since the cleanup code here would duplicate that in
    //            FinalRelease, we just do nothing here, and rely
    //            on FinalRelease to fix us up.

    hr = E_FAIL;

    goto Cleanup;
}


HRESULT
CUPnPDocument::FinalRelease()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::FinalRelease");

    // we don't assert that all of our data is initialized here
    // since we might have barfed out of FinalConstruct

     // clean up our Context object, if we have one
    if (_puddctx)
    {
        _puddctx->Deinit();
        _puddctx->GetUnknown()->Release();
        _puddctx = NULL;
    }

    // stop any download we have
    if (_pxdd)
    {
        // ignore the hr here, since we're going away whether or not
        // we can abort
        AbortLoading();
    }

    // do we have a base url?
    if (_pszBaseUrl)
    {
        delete [] _pszBaseUrl;
        _pszBaseUrl = NULL;
    }

    if (_pszHostUrl)
    {
        delete [] _pszHostUrl;
        _pszHostUrl = NULL;
    }

    if (_pszSecurityUrl)
    {
        delete [] _pszSecurityUrl;
        _pszSecurityUrl = NULL;
    }

    // free up our xml doc references
    SAFE_RELEASE(_pxdd);

    SysFreeString(m_bstrFullUrl);
    m_bstrFullUrl = NULL;

    CleanupInternetForDocs();

    return S_OK;
}





HRESULT
CUPnPDocument::SyncLoadFromUrl(/* [in] */ LPCWSTR pszUrl)
{
    HRESULT hr;

    hr = HrLoad(pszUrl, NULL, FALSE);

    TraceError("CUPnPDocument::SyncLoadFromUrl", hr);
    return hr;
}


HRESULT
CUPnPDocument::AsyncLoadFromUrl(/* [in] */ LPCWSTR pszUrl, LPVOID pvCookie)
{
    HRESULT hr;

    hr = HrLoad(pszUrl, pvCookie, TRUE);

    TraceError("CUPnPDocument::SyncLoadFromUrl", hr);
    return hr;
}


HRESULT
CUPnPDocument::HrLoad(LPCWSTR pszUrl,
                      LPVOID pvCookie,
                      BOOL fAsync)
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::HrLoad");

    Assert(_pxdd);

    DWORD dwResult;
    HRESULT hr;
    HINTERNET hInetDocSess;
    DWORD dwContext = 0;
    LPTSTR pszAccept = NULL;
    LPWSTR pszFullUrl = NULL;       // the URL to load the document from.
                                    // if pszUrl is a relative URL (e.g. not
                                    // fully-qualified, this will be the
                                    // fully-qualified version of the URL.
                                    // Otherwise, it will be just set to pszUrl

    // select Internet session to use
    if (fAsync)
    {
        hInetDocSess = g_hAsyncInetDocSess;
    }
    else
    {
        hInetDocSess = g_hSyncInetDocSess;
    }

    if (!hInetDocSess)
    {
        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::HrLoad, Inet handle not open");
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    pszFullUrl = NULL;

    if (!pszUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    // initialize the document
    hr = Reset(pvCookie);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // make our fully-qualified url from the host url and the supplied url
    if (_pszHostUrl)
    {
        hr = HrCombineUrl(_pszHostUrl, pszUrl, &pszFullUrl);
        if (FAILED(hr))
        {
            pszFullUrl = NULL;
            goto Cleanup;
        }
    }
    else
    {
        pszFullUrl = WszAllocateAndCopyWsz(pszUrl);
        if (!pszFullUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    // ensure that we are allowed to load pszFullUrl
    {
        BOOL fIsAllowed;

        fIsAllowed = fIsUrlLoadAllowed(pszFullUrl);
        if (!fIsAllowed)
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        hr = SetBaseUrl(pszFullUrl);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    if (fAsync)
    {
        // make our callback object for CUPnPDocumentCtx
        hr = CComObject<CUPnPDocumentCtx>::CreateInstance(&_puddctx);
        if (FAILED(hr))
        {
            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::HrLoad - CreateInstance(CUPnPDocumentCtx) failed, hr=%x", hr);

            _puddctx = NULL;
            goto Cleanup;
        }
        Assert(_puddctx);

        _puddctx->GetUnknown()->AddRef();

        hr = _puddctx->Init(this, &dwContext);
        if (FAILED(hr))
        {
            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::HrLoad - CUPnPDocumentCtx::Init failed, hr=%x", hr);

            _puddctx->GetUnknown()->Release();
            _puddctx = NULL;
            goto Cleanup;
        }
    }
    else
    {
        // do not create context if synchronous
        _puddctx = NULL;
    }

    SetLoadResult(E_PENDING);

    // note: after this point we have to goto Error to clean up!
    {
        const LPCTSTR * aryAcceptFormats;
        ULONG cAcceptFormats;

        GetAcceptFormats(&aryAcceptFormats, &cAcceptFormats);

        // convert the formats to HTTP Accept: header
        if (cAcceptFormats > 0)
        {
            int i;
            int size = _tcslen(pszAcceptHeader) + 3;        // leave room for \r\nNULL

            for (i = 0; i < cAcceptFormats; i++)
            {
                size += _tcslen(aryAcceptFormats[i]) + 2;   // leave room for ", "
            }

            pszAccept = (LPTSTR)MemAlloc(size * sizeof(TCHAR));
            if (NULL == pszAccept)
            {
                hr = E_OUTOFMEMORY;
                goto Error;
            }

            _tcscpy(pszAccept, pszAcceptHeader);
            for (i = 0; i < cAcceptFormats; i++)
            {
                if (i > 0)
                {
                    // insert separator if not first
                    _tcscat(pszAccept, pszAcceptSep);
                }
                _tcscat(pszAccept, aryAcceptFormats[i]);
            }
            _tcscat(pszAccept, TEXT("\r\n"));
        }
    }

    SysFreeString(m_bstrFullUrl);
    m_bstrFullUrl = SysAllocString(pszFullUrl);

    if (!m_bstrFullUrl)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if (fAsync)
    {
        hr = _puddctx->StartInternetOpenUrl(hInetDocSess, pszFullUrl,
                                    pszAccept,
                                    _tcslen(pszAccept),
                                    INTERNET_FLAG_KEEP_CONNECTION |
                                    INTERNET_FLAG_NO_AUTO_REDIRECT |
                                    INTERNET_FLAG_NO_AUTH |
                                    INTERNET_FLAG_NO_COOKIES);
        if (FAILED(hr))
        {
            // some real error
            AbortLoading();
            goto Error;
        }
    }
    else
    {
        HINTERNET hOpenUrl;

        hOpenUrl = InternetOpenUrl(hInetDocSess, pszFullUrl,
                                    pszAccept,
                                    _tcslen(pszAccept),
                                    INTERNET_FLAG_KEEP_CONNECTION |
                                    INTERNET_FLAG_NO_AUTO_REDIRECT |
                                    INTERNET_FLAG_NO_AUTH |
                                    INTERNET_FLAG_NO_COOKIES ,
                                    (DWORD_PTR)0);

        if (hOpenUrl == NULL)
        {
            DWORD dw = GetLastError();
            hr = HrFromLastWin32Error();
            AbortLoading();
            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::HrLoad, InternetOpenUrl error dw=%d hr=0x%x", dw, hr);
            goto Error;
        }

        // handle the download doc
        hr = DocumentDownloadReady(hOpenUrl, 0);
        InternetCloseHandle(hOpenUrl);
        hOpenUrl = NULL;

        if (FAILED(hr))
        {
            goto Error;
        }
    }


Cleanup:
    if (pszFullUrl)
    {
        delete [] pszFullUrl;
    }

    if (pszAccept)
    {
        MemFree(pszAccept);
        pszAccept = NULL;
    }

    TraceError("CUPnPDocument::HrLoad", hr);
    return hr;

Error:

    SetLoadResult(hr);

    // clean up Context helper object
    if (_puddctx)
    {
        _puddctx->Deinit();
        _puddctx->GetUnknown()->Release();
        _puddctx = NULL;
    }


    goto Cleanup;
}


HRESULT
CUPnPDocument::DocumentDownloadReady(HINTERNET hOpenUrl, DWORD dwError)
{
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwReadSize = 0;
    LPSTR pDoc = m_szPendingBuf;
    DWORD dwTotalSize = m_dwPendingSize;
    HRESULT hr = S_OK;

    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::DocumentDownloadReady dwError = %d",
                dwError);

    if (hOpenUrl && (0 == dwError))
    {
        // get the HTTP status
        dwSize = sizeof(dwStatus);
        if (!HttpQueryInfo(hOpenUrl,
                            HTTP_QUERY_STATUS_CODE + HTTP_QUERY_FLAG_NUMBER,
                            &dwStatus, &dwSize, NULL) )
        {
            hr = HrFromLastWin32Error();
            TraceError("CUPnPDocument::DocumentDownloadReady HttpQueryInfo", hr);
        }
        else if (dwStatus >= 400)
        {
            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::DocumentDownloadReady status code %d",
                    dwStatus);
            hr = E_FAIL; 
        }

        // loop to read the data
        while (SUCCEEDED(hr))
        {
            if (InternetQueryDataAvailable(hOpenUrl, &dwSize, 0, 0))
            {
                if (dwSize == 0)
                {
                    // end of doc
                    break;
                }
                if (dwTotalSize + dwSize > UPNP_MAX_DOCSIZE)
                {
                    // download too long. Reject
                    MemFree(pDoc);
                    pDoc = NULL;
                    hr = E_OUTOFMEMORY;
                    break;
                }
                // realloc
                void* ReadBuf = MemAlloc(dwTotalSize + dwSize + 1);
                if (ReadBuf)
                {
                    if (pDoc)
                    {
                        CopyMemory(ReadBuf, pDoc, dwTotalSize);
                        MemFree(pDoc);
                    }
                    pDoc = (LPSTR)ReadBuf;
                    ReadBuf = (BYTE*)ReadBuf + dwTotalSize;

                    if (!InternetReadFile(hOpenUrl, ReadBuf,
                                            dwSize, &dwReadSize))
                    {
                        DWORD dw = GetLastError();
                        if (ERROR_IO_PENDING == dw)
                        {
                          // not last REQUEST_COMPLETE
                            // save state, return E_PENDING
                            m_szPendingBuf = pDoc;
                            m_dwPendingSize = dwTotalSize;
                            hr = E_PENDING;
                            goto Incomplete;
                        }
                        MemFree(pDoc);
                        pDoc = NULL;
                        hr = HrFromLastWin32Error();
                        break;
                    }
                    dwTotalSize += dwReadSize;
                    pDoc[dwTotalSize] = 0;

                    if (dwReadSize == 0)
                        break;

                    if (dwTotalSize > strlen(szXmlHeader))
                    {
                        // quick check if data starts with "<xml "
                        // we assume the strncmp works with utf8 in this case
                        if (strncmp(szXmlHeader, pDoc, strlen(szXmlHeader)) != 0)
                        {
                            MemFree(pDoc);
                            pDoc = NULL;
                            hr = E_FAIL;
                            TraceError("CUPnPDocument::DocumentDownloadReady doc does not start with <?xml ", hr);
                            break;
                        }
                    }
                }
                else
                {
                    MemFree(pDoc);
                    pDoc = NULL;
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                DWORD dw = GetLastError();
                if (ERROR_IO_PENDING == dw)
                {
                    // not last REQUEST_COMPLETE
                    // save state, return E_PENDING
                    m_szPendingBuf = pDoc;
                    m_dwPendingSize = dwTotalSize;
                    hr = E_PENDING;
                    goto Incomplete;
                }
                MemFree(pDoc);
                pDoc = NULL;
                hr = HrFromLastWin32Error();
                break;
            }
        }

        // should have entire doc loaded now
        if (pDoc)
        {
            // Convert the XML contained in the doc into a BSTR,
            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::DocumentDownloadReady, data read complete");
            WCHAR* pwszXMLBody;

            pwszXMLBody = WszFromUtf8(pDoc);

            if (pwszXMLBody)
            {
                BSTR bstrXMLBody = NULL;

                bstrXMLBody = SysAllocString(pwszXMLBody);

                // got the doc in a BSTR. start parsing
                if (bstrXMLBody)
                {
                    if (SUCCEEDED(hr))
                    {
                        VARIANT_BOOL vbSuccess;

                        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::DocumentDownloadReady, load XML");
                        _pxdd->put_resolveExternals(VARIANT_FALSE);
                        hr = _pxdd->loadXML(bstrXMLBody, &vbSuccess);

                        CompleteLoading();
                        SysFreeString(bstrXMLBody);
                    }
                }
                MemFree(pwszXMLBody);
            }

            MemFree(pDoc);

        }
    }

    if (FAILED(hr))
    {
        if (NULL == hOpenUrl)
        {
            hr = E_UNEXPECTED;
            TraceError("CUPnPDocument::DocumentDownloadReady no handle", hr);
        }
        if (dwError)
        {
            hr = HrFromLastWin32Error();
            TraceError("CUPnPDocument::DocumentDownloadReady error", hr);
        }
        SetLoadResult(hr);
    }


    SetReadyState(READYSTATE_COMPLETE);

    OnLoadReallyDone();

    // Get the load result from the URL load attempt. If failed, we'll
    // return fail to the caller instead of making them call like we
    // rudely did in the past.
    //
    hr = GetLoadResult();

Incomplete:
    TraceError("CUPnPDocument::DocumentDownloadReady", hr);
    return hr;
}


// Virtual methods

VOID
CUPnPDocument::OnReadyStateChange()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::OnReadyStateChange - default implementation called");
}

HRESULT
CUPnPDocument::Initialize(LPVOID pvCookie)
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::Initialize - default implementation called");

    return S_OK;
}

HRESULT
CUPnPDocument::OnLoadComplete()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::OnLoadComplete - default implementation called");

    return S_OK;
}

HRESULT
CUPnPDocument::OnLoadReallyDone()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::OnLoadReallyDone - default implementation called");

    return S_OK;
}

VOID
CUPnPDocument::GetAcceptFormats(CONST LPCTSTR ** ppszFormats, DWORD * pcFormats) const
{
    Assert(ppszFormats);
    Assert(pcFormats);

    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::GetAcceptFormats - default implementation called");

    *ppszFormats = s_aryAcceptFormats;
    *pcFormats = s_cAcceptFormats;
}

// note: this only stops the loading operation.  it doesn't clean anything up.
HRESULT
CUPnPDocument::AbortLoading()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::Abort");

    HRESULT hr;

    if (!_pxdd)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // note: this will abort the binding operation if one is in progress
    hr = _pxdd->abort();

Cleanup:
    TraceError("CUPnPDocument::AbortBinding", hr);
    return hr;
}

VOID
CUPnPDocument::CompleteLoading()
{
    HRESULT hr;
    HRESULT hrErrorCode;
    IXMLDOMParseError * pxdpe;

    // we've finished loading.  Make sure the load completed successfully,
    // call the OnLoadComplete callback so the client can do any other
    // processing, and then change the readystate.


    hrErrorCode = E_UNEXPECTED;
    pxdpe = NULL;

    hr = _pxdd->get_parseError(&pxdpe);
    if (SUCCEEDED(hr))
    {
        Assert(pxdpe);

        // gee, wally.  I hope a HRESULT is always the same size as a LONG...
        hr = pxdpe->get_errorCode(&hrErrorCode);
        if (FAILED(hr))
        {
            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::CompleteLoading - get_errorCode failed, hr=%x", hr);

            hrErrorCode = E_UNEXPECTED;
        }
        pxdpe->Release();
        pxdpe = NULL;

        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::CompleteLoading - xml parser returned hrErrorCode=%x", hrErrorCode);
    }
    else
    {
        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocument::CompleteLoading - get_parseError failed, hr=%x", hr);

        hrErrorCode = hr;
    }

    if (SUCCEEDED(hrErrorCode))
    {
        // the load completed successfully.  Have our decendant try to parse
        // the document document
        hrErrorCode = OnLoadComplete();
    }

    SetLoadResult(hrErrorCode);
}




READYSTATE
CUPnPDocument::GetReadyState() const
{
    return _rs;
}


VOID
CUPnPDocument::SetReadyState(READYSTATE rs)
{
    if (_rs != rs)
    {
        _rs = rs;
        OnReadyStateChange();
    }
}

LPCWSTR
CUPnPDocument::GetBaseUrl() const
{
    return _pszBaseUrl;
}

HRESULT
CUPnPDocument::SetBaseUrl(LPCWSTR pszUrlNew)
{
    return HrReallocAndCopyString(pszUrlNew, &_pszBaseUrl);
}

IXMLDOMDocument *
CUPnPDocument::GetXMLDocument() const
{
    return _pxdd;
}


HRESULT
CUPnPDocument::GetLoadResult() const
{
    return _hrLoadResult;
}


VOID
CUPnPDocument::SetLoadResult(HRESULT hrLoadResult)
{
    _hrLoadResult = hrLoadResult;
}


HRESULT
CUPnPDocument::Reset(LPVOID pvCookie)
{
    HRESULT hr;

    // clean up our own state
     // stop any download we have
    hr = AbortLoading();
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // have our document clear itself
    hr = Initialize(pvCookie);
    if (FAILED(hr))
    {
        // if we have an error, don't reset the document.
        TraceError("OBJ: CUPnPDocument::Reset: Initialize()", hr);
        goto Cleanup;
    }

     // clean up our Context object, if we have one
    if (_puddctx)
    {
        _puddctx->Deinit();
        _puddctx->GetUnknown()->Release();
        _puddctx = NULL;
    }

    hr = SetBaseUrl(NULL);
    Assert(SUCCEEDED(hr));

    hr = HrInitHostUrl();
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = HrInitSecurityUrl();
    if (FAILED(hr))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // clear our bind result.
    SetLoadResult(E_UNEXPECTED);

    SetReadyState(READYSTATE_LOADING);

Cleanup:
    TraceError("CUPnPDocument::Reset", hr);
    return hr;
}


HRESULT
CUPnPDocument::HrInitHostUrl()
{
    HRESULT hr;
    IWebBrowser2 * pwb;
    BSTR bstrUrl;

    hr = S_OK;
    pwb = NULL;
    bstrUrl = NULL;

    if (!m_spUnkSite)
    {
        // we're all done

        goto Cleanup;
    }

            // we ignore this since it's perfectly legal for a container
            // not to support IServiceProvider.  The resulting security domain
            // is NULL, which prohibits everything to an untrusted caller
            //
    hr = HrQueryServiceForInterface(m_spUnkSite,
                                    SID_SWebBrowserApp,
                                    IID_IWebBrowser2,
                                    (LPVOID *)&pwb);
    if (S_OK != hr)
    {
        Assert(!pwb);

        goto Cleanup;
    }
    Assert(pwb);

    // now we can get our host url
    //
    hr = pwb->get_LocationURL(&bstrUrl);
    if (FAILED(hr))
    {
        TraceError("OBJ: CUPnPDocument::HrInitHostUrl: get_LocationURL!", hr);

        bstrUrl = NULL;
        goto Cleanup;
    }

Cleanup:
    Assert(FImplies(bstrUrl, SUCCEEDED(hr)));
    Assert(FImplies(FAILED(hr), !bstrUrl));

    {
        HRESULT hr2;

        // we assume here that SetBaseUrl cannot fail when bstrUrl is NULL.
        //
        hr2 = SetHostUrl(bstrUrl);

        Assert(FImplies(FAILED(hr), SUCCEEDED(hr2)));

        if (SUCCEEDED(hr))
        {
            hr = hr2;
        }
    }

    ::SysFreeString(bstrUrl);
    SAFE_RELEASE(pwb);

    TraceError("CUPnPDocument::HrInitHostUrl", hr);
    return hr;
}

HRESULT
CUPnPDocument::HrInitSecurityUrl()
{
    HRESULT hr;
    LPCWSTR pszHostUrl;
    LPWSTR pszSecurityUrl;

    pszHostUrl = GetHostUrl();
    pszSecurityUrl = NULL;

    if (pszHostUrl)
    {
        hr = HrGetSecurityDomainOfUrl(pszHostUrl, &pszSecurityUrl);
        if (FAILED(hr))
        {
            pszSecurityUrl = NULL;
            goto Cleanup;
        }
    }

    hr = SetSecurityUrl(pszSecurityUrl);

Cleanup:
    TraceError("CUPnPDocument::HrInitSecurityUrl", hr);
    return hr;
}

BOOL
CUPnPDocument::fIsUrlLoadAllowed(LPCWSTR pszUrl) const
{
    Assert(pszUrl);

    HRESULT hr;
    BOOL fAllowed;

    fAllowed = FALSE;

    if (m_dwCurrentSafety & INTERFACESAFE_FOR_UNTRUSTED_CALLER)
    {
        // we're running in an *untrusted* caller.
        //

        LPWSTR pszDomain;

        pszDomain = NULL;

        hr = HrGetSecurityDomainOfUrl(pszUrl, &pszDomain);
        if (SUCCEEDED(hr))
        {
            // we can only compare the strings if they both are defined.
            // If they aren't, this could very well mean that we're in
            // an untrusted caller and couldn't get our host's url
            //

            if (pszDomain)
            {
                if (_pszSecurityUrl)
                {
                    // the load will be allowed if pszDomain and
                    // _pszSecurityUrl are identical
                    int result;

                    result = wcscmp(_pszSecurityUrl, pszDomain);

                    if (0 == result)
                    {
                        fAllowed = TRUE;
                    }
                }

                delete [] pszDomain;
            }
        }
    }
    else
    {
        Assert(!m_dwCurrentSafety);

        // we're running in trusted code.  all loads are allowed.
        fAllowed = TRUE;
    }

    return fAllowed;
}

LPCWSTR
CUPnPDocument::GetSecurityUrl() const
{
    return _pszSecurityUrl;
}

HRESULT
CUPnPDocument::SetSecurityUrl(LPCWSTR pszSecurityUrlNew)
{
    return HrReallocAndCopyString(pszSecurityUrlNew, &_pszSecurityUrl);
}

LPCWSTR
CUPnPDocument::GetHostUrl() const
{
    return _pszHostUrl;
}

HRESULT
CUPnPDocument::SetHostUrl(LPCWSTR pszHostUrlNew)
{
    return HrReallocAndCopyString(pszHostUrlNew, &_pszHostUrl);
}

VOID
CUPnPDocument::CopySafety(CUPnPDocument * pdocParent)
{
    Assert(pdocParent);

    // note: no need for AddRef/Release worries, m_spUnkSite is a CComPtr
    //
    m_spUnkSite = pdocParent->m_spUnkSite;
    m_dwCurrentSafety = pdocParent->m_dwCurrentSafety;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdevicenode.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdevicenode.cpp
//
//  Contents:   IUPnPDevice implementation for CUPnPDeviceNode, CUPnPIconNode
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "node.h"
#include "upnpdevice.h"
#include "enumhelper.h"
#include "upnpdevices.h"
#include "upnpservicenodelist.h"
#include "UPnPDeviceNode.h"
#include "upnpdocument.h"
#include "upnpdescriptiondoc.h"
#include "upnpxmltags.h"
#include "upnpservices.h"
#include "rehy.h"
#include "ncinet2.h"        // HrCombineUrl
#include "ncstring.h"       // PszAllocateAndCopyPsz
#include "iconutil.h"       // pipnGetBestIcon
#include "testtarget.h"


// NOTE: REORDER THIS ON PAIN OF DEATH - ADD NEW VALUES AT THE END
const DevicePropertiesParsingStruct
CUPnPDeviceNode::s_dppsParsingInfo [/* dpLast */] =
{
//m_fOptional  m_fIsUrl  m_fValidateUrl    m_pszTagName
    { FALSE,   FALSE,    FALSE,     XMLTags::pszUDN            }, // dpUDN
    { FALSE,   FALSE,    FALSE,     XMLTags::pszFriendlyName     }, // dpFriendlyName
    { FALSE,   FALSE,    FALSE,     XMLTags::pszDeviceType      }, // dpType
    { TRUE,    TRUE,     FALSE,     XMLTags::pszPresentationURL  }, // dpPresentationUrl
    { FALSE,   FALSE,    FALSE,     XMLTags::pszManufacturer     }, // dpManufacturerName
    { TRUE,    TRUE,     FALSE,     XMLTags::pszManufacturerURL  }, // dpManufacturerUrl
    { FALSE,   FALSE,    FALSE,     XMLTags::pszModelName       }, // dpModelName
    { TRUE,    FALSE,    FALSE,     XMLTags::pszModelNumber     }, // dpModelNumber
    { TRUE,    FALSE,    FALSE,     XMLTags::pszModelDescription  }, // dpDescription
    { TRUE,    TRUE,     FALSE,     XMLTags::pszModelURL        }, // dpModelUrl
    { TRUE,    FALSE,    FALSE,     XMLTags::pszUPC             }, // dpUpc
    { TRUE,    FALSE,    FALSE,     XMLTags::pszSerialNumber      }, // dpSerialNumber
};
// NOTE: REORDER THIS ON PAIN OF DEATH - ADD NEW VALUES AT THE END


// NOTE: REORDER THIS ON PAIN OF DEATH - ADD NEW VALUES AT THE END
const DevicePropertiesParsingStruct
CIconPropertiesNode::s_dppsIconParsingInfo [/* ipLast */] =
{
//m_fOptional  m_fIsUrl  m_fValidateUrl    m_pszTagName
    { FALSE,   FALSE,    FALSE,     XMLTags::pszMimetype   }, // ipMimetype
    { FALSE,   FALSE,    FALSE,     XMLTags::pszWidth      }, // ipWidth
    { FALSE,   FALSE,    FALSE,     XMLTags::pszHeight     }, // ipHeight
    { FALSE,   FALSE,    FALSE,     XMLTags::pszDepth      }, // ipDepth
    { FALSE,   TRUE,     TRUE,      XMLTags::pszUrl        }, // ipUrl
};
// NOTE: REORDER THIS ON PAIN OF DEATH - ADD NEW VALUES AT THE END


CUPnPDeviceNode::CUPnPDeviceNode()
{
    AssertSz(dpLast == celems(s_dppsParsingInfo),
             "CUPnPDeviceNode: Properties added but s_dppsParsingInfo not updated!");

    m_pdoc = NULL;
    m_pud = NULL;
    m_pipnIcons = NULL;
    m_bstrUrl = NULL;

    ::ZeroMemory(m_arypszStringProperties, sizeof(LPWSTR *) * dpLast);
}

CUPnPDeviceNode::~CUPnPDeviceNode()
{
    ULONG i;

    if (m_pud)
    {
        // tell our wrapper that we're going away.
        m_pud->Deinit();
    }

    for (i = 0; i < dpLast; ++i)
    {
        if (m_arypszStringProperties[i])
        {
            delete [] m_arypszStringProperties[i];
        }
    }

    {
        // release icon lists
        CIconPropertiesNode * pipnTemp;

        pipnTemp = m_pipnIcons;
        while (pipnTemp)
        {
            CIconPropertiesNode * pipnNext;

            pipnNext = pipnTemp->m_pipnNext;

            delete pipnTemp;

            pipnTemp = pipnNext;
        }
    }

    if (m_bstrUrl)
    {
        SysFreeString(m_bstrUrl);
    }

    // note: our base class will clean up our children
}

HRESULT
CUPnPDeviceNode::HrReadStringValues(IXMLDOMNode * pxdn)
{
    Assert(pxdn);
    Assert(m_pdoc);

    HRESULT hr;
    LPCWSTR pszBaseUrl;
    BOOL fComplete;

    pszBaseUrl = m_pdoc->GetBaseUrl();
    fComplete = FALSE;
    // Duplicate Tag Validation
    hr = HrAreElementTagsValid(pxdn, dpLast,s_dppsParsingInfo);
    if(SUCCEEDED(hr))
    {
        hr = HrReadElementWithParseData(pxdn,
                                    dpLast,
                                    s_dppsParsingInfo,
                                    pszBaseUrl,
                                    m_arypszStringProperties);
    }
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    fComplete = fAreReadValuesComplete(dpLast,
                                       s_dppsParsingInfo,
                                       m_arypszStringProperties);
    if (!fComplete)
    {
        hr = UPNP_E_DEVICE_NODE_INCOMPLETE;
    }
	
	//  ISSUE-2002/03/12-guruk -Except Presentation Url in s_dppsParsingInfo, we don't directly deal with other URL's App should validate those URLs like manufature URL etc
	//  Presentation Url is currently not validated as these can point to third party web sites and hosted in a different place
	//  If any URL need to be validated, invoke fValidateUrl()

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), fComplete));

    TraceError("CUPnPDeviceNode::HrReadStringValues", hr);
    return hr;
}

HRESULT
CUPnPDeviceNode::HrReadIconList(IXMLDOMNode * pxdn)
{
    Assert(pxdn);
    Assert(m_pdoc);

    // Creates the list of UPnPServiceNode nodes
    HRESULT hr;
    IXMLDOMNode * pxdnIconList;
    IXMLDOMNode * pxdnIcon;

      // this is a pointer to the address of the "Next" pointer
      // of the end of our icon properties linked list.
      // it is the address which needs to receive the address
      // of the new nodes to add them to the list
    CIconPropertiesNode ** ppipnNext;
    LPCWSTR pszBaseUrl;

    pxdnIcon = NULL;
    pxdnIconList = NULL;
    ppipnNext = &m_pipnIcons;
    pszBaseUrl = m_pdoc->GetBaseUrl();

    // Duplicate Tag Validation
    hr = HrCheckForDuplicateElement(pxdn,XMLTags::pszIconList);
    if(SUCCEEDED(hr))
    {
        hr = HrGetNestedChildElement(pxdn,
                                 &(XMLTags::pszIconList),
                                 1,
                                 &pxdnIconList);
    }
    if (FAILED(hr))
    {
        pxdnIconList = NULL;

        goto Cleanup;
    }
    else if (S_FALSE == hr)
    {
        Assert(!pxdnIconList);

        // we didn't have an <iconList> node.  This is ok.
        //
        hr = S_OK;
        goto Cleanup;
    }

    hr = HrGetNestedChildElement(pxdnIconList,
                                 &(XMLTags::pszIcon),
                                 1,
                                 &pxdnIcon);
    if (FAILED(hr))
    {
        pxdnIcon = NULL;

        goto Cleanup;
    }
    else if (S_FALSE == hr)
    {
        // there wasn't an <icon> node.
        hr = UPNP_E_ICON_ELEMENT_EXPECTED;

        goto Cleanup;
    }

    while (pxdnIcon)
    {
        IXMLDOMNode * pxdnIconTemp;
        CIconPropertiesNode * pipnNew;

        // for each icon in the list...

        // 1. create the icon node
        pipnNew = new CIconPropertiesNode();
        if (!pipnNew)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // 2. add it to the list
        //    note: this step MUST happen before the HrInit(), so we're
        //          sure not to leak the node if an error occurs...
        Assert(!(*ppipnNext));

        *ppipnNext = pipnNew;
        ppipnNext = &(pipnNew->m_pipnNext);

        // 3. Initialize it
        hr = pipnNew->HrInit(pxdnIcon, pszBaseUrl);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

#ifdef DBG
        {
            // dump icon in DBG builds
            TraceTag(ttidUPnPDescriptionDoc,
                     "loaded icon: m_pszFormat=%S, "
                                   "m_ulSizeX=%d, "
                                   "m_ulSizeY=%d, "
                                   "m_ulBitDepth=%d, "
                                   "m_pszUrl=%S",
                     pipnNew->m_pszFormat,
                     pipnNew->m_ulSizeX,
                     pipnNew->m_ulSizeY,
                     pipnNew->m_ulBitDepth,
                     pipnNew->m_pszUrl);
        }
#endif // DBG

        // 4. Get more icons
        pxdnIconTemp = NULL;

        hr = HrGetNextChildElement(pxdnIcon, XMLTags::pszIcon, &pxdnIconTemp);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        pxdnIcon->Release();
        pxdnIcon = pxdnIconTemp;
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

Cleanup:
    Assert(!(*ppipnNext));
    TraceError("OBJ: CUPnPDeviceNode::HrReadIconList", hr);

    SAFE_RELEASE(pxdnIconList);
    SAFE_RELEASE(pxdnIcon);
    return hr;
}


HRESULT
CUPnPDeviceNode::HrInitServices(IXMLDOMNode * pxdn)
{
    Assert(pxdn);
    Assert(m_pdoc);

    // Creates the list of UPnPServiceNode nodes
    HRESULT hr;
    IXMLDOMNode * pxdnService;
    const LPCWSTR arypszServiceTags [] = { XMLTags::pszServiceList,
                                           XMLTags::pszService };
    LPCWSTR pszBaseUrl;

    pxdnService = NULL;
    pszBaseUrl = m_pdoc->GetBaseUrl();

    // first, initialize the service list
    m_usnlServiceList.Init(m_pdoc);

    hr = HrIsElementPresentOnce(pxdn,arypszServiceTags[0]);
    if(SUCCEEDED(hr))
    {
        hr = HrGetNestedChildElement(pxdn,
                                 arypszServiceTags,
                                 celems(arypszServiceTags),
                                 &pxdnService);
    }
    if (FAILED(hr))
    {
        pxdnService = NULL;

        goto Cleanup;
    }
    else if (S_FALSE == hr)
    {
        // there wasn't a <serviceList>\<service> node.
        hr = UPNP_E_SERVICE_ELEMENT_EXPECTED;

        goto Cleanup;
    }
    Assert(S_OK == hr);

    while (pxdnService)
    {
        // we found a service, let's add it to our service list

        IXMLDOMNode * pxdnTemp;

        hr = m_usnlServiceList.HrAddService(pxdnService, pszBaseUrl);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        pxdnTemp = NULL;
        hr = HrGetNextChildElement(pxdnService, XMLTags::pszService, &pxdnTemp);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        pxdnService->Release();
        pxdnService = pxdnTemp;
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::HrInitServices", hr);

    SAFE_RELEASE(pxdnService);
    return hr;
}

HRESULT
CUPnPDeviceNode::HrCreateChildren(IXMLDOMNode * pxdn)
{
    Assert(pxdn);
    Assert(m_pdoc);

    HRESULT hr;
    IXMLDOMNode * pxdnDeviceList;
    IXMLDOMNode * pxdnDevice;

    pxdnDeviceList = NULL;
    pxdnDevice = NULL;

    // do we have any child devices at all?

    // note: we do this in two calls to HrGetNestedChildElement to handle
    //       the case where ad <deviceList> element exists but a <device>
    //       element doesn't.

    hr = HrCheckForDuplicateElement(pxdn,XMLTags::pszDeviceList);
    if(SUCCEEDED(hr))
    {
        hr = HrGetNestedChildElement(pxdn,
                                 &(XMLTags::pszDeviceList),
                                 1,
                                 &pxdnDeviceList);
    }
    if (FAILED(hr))
    {
        TraceError("OBJ: CUPnPDeviceNode::CreateChildren - HrGetNestedChildElement", hr);

        pxdnDeviceList = NULL;
        hr = E_FAIL;
        goto Cleanup;
    }
    else if (S_FALSE == hr)
    {
        // it's ok not to find anything here
        Assert(!pxdnDeviceList);

        hr = S_OK;
        goto Cleanup;
    }
    Assert(S_OK == hr);

    hr = HrGetNestedChildElement(pxdnDeviceList,
                                 &(XMLTags::pszDevice),
                                 1,
                                 &pxdnDevice);
    if (FAILED(hr))
    {
        TraceError("OBJ: CUPnPDeviceNode::CreateChildren - HrGetNestedChildElement", hr);

        pxdnDevice = NULL;
        hr = E_FAIL;
        goto Cleanup;
    }
    else if (S_FALSE == hr)
    {
        // we need a <device> element here
        Assert(!pxdnDevice);

        hr = UPNP_E_DEVICE_ELEMENT_EXPECTED;
        goto Cleanup;
    }
    Assert(S_OK == hr);

    while (pxdnDevice)
    {
        IXMLDOMNode * pxdnDeviceTemp;
        CUPnPDeviceNode * pudnChild;

        pxdnDeviceTemp = NULL;
        pudnChild = NULL;

        // for all of our child devices...
        Assert(pxdnDevice);

        // 1. create the device
        pudnChild = new CUPnPDeviceNode();
        if (!pudnChild)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        // 2. add it to the tree
        //    note: this step MUST happen before the Init(), so we're
        //          sure not to leak the child node if an error occurs...
        AddChild(pudnChild);

        // 3. let it create more children
        hr = pudnChild->HrInit(pxdnDevice, m_pdoc, m_bstrUrl);
        if (FAILED(hr))
        {
            // unwind everything.  eventually our doc will delete
            // our root object, which will cause us all to be destroyed

            goto Cleanup;
        }

        // 4. create more children ourselves
        hr = HrGetNextChildElement(pxdnDevice, XMLTags::pszDevice, &pxdnDeviceTemp);
        if (FAILED(hr))
        {
            goto Cleanup;
        }

        pxdnDevice->Release();
        pxdnDevice = pxdnDeviceTemp;
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), !pxdnDevice));
    SAFE_RELEASE(pxdnDeviceList);
    SAFE_RELEASE(pxdnDevice);

    TraceError("OBJ: CUPnPDeviceNode::HrCreateChildren", hr);
    return hr;
}

HRESULT
CUPnPDeviceNode::HrInit(IXMLDOMNode * pxdn, CUPnPDescriptionDoc * pdoc, BSTR bstrUrl)
{
    Assert(pxdn);
    Assert(pdoc);

    HRESULT hr;

    hr = S_OK;

    m_pdoc = pdoc;

    m_bstrUrl = SysAllocString(bstrUrl);
    if (!m_bstrUrl)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // NOTE: we must init the above before calling HrReadStringValues(),
    //  HrCreateChildren(), or HrInitServices()

    hr = HrReadStringValues(pxdn);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = HrReadIconList(pxdn);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = HrInitServices(pxdn);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = HrCreateChildren(pxdn);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::HrInit", hr);
    return hr;
}


//  how this wrapper stuff works.
//
//    in the beginning, there is the doc
//      the doc is a com object, the doc has refcount
//
//    the doc creates nodes when the doc is loaded.
//    nodes are vanilla C++ objects.  nodes are not refcounted.
//
//    wrappers are COM objects that provide refcounting _around_
//    nodes.  they provide two
//     1. keep the doc from going away even if all the exlicit
//        references to it do
//     2. allows clients to unrefrence some elements of the
//        tree and get them back later.
//
//    the only _unfortunate_ part of this is that
//     1. nodes can go away without the doc being released.
//        this can happen if the doc is reLoad()ed
//          in this case, we want the doc to be reloaded,
//          but any calls to "old" nodes would have to
//          fail.  internally, the nodes would go way.
//        this means the wrapper can outlast the node
//     2. wrappers can live and die on their own
//        this means that nodes can outlive the wrapper.
//
//    because of this, there's a "two-way" deinit process.
//    this process isn't very good, and is worth thinking about and
//    implementing correctly someday.
//
//    it works as follows:
//      way 1: the wrapper has a soft ref (pointer) to
//             the node
//               - this is given to the wrapper when it
//                 is created
//               - when a node goes away, and it has a
//                 wrapper, it calls deinit() on the
//                 wrapper to remove this ref
//      way 2: the node has a soft ref to the wrapper
//               - the node has this because it created
//                 the wrapper
//               - when a wrapper goes away, and it
//                 still has a ref to the node, it calls
//                 unwrap() on the node to remove this
//                 ref
//
//      safe assumptions are:
//       - a wrapper may or may not have a node
//       - a node may or may not have a wrapper
//       - a node will always be created before a wrapper
//       - when a node or a wrapper goes away, it must tell
//         its dual that it's doing so, if it can.
//
//      note that this scheme is horribly un-thread-safe....

HRESULT
CUPnPDeviceNode::HrGetWrapper(IUPnPDevice ** ppud)
{
    Assert(ppud);
    Assert(m_pdoc);

    HRESULT hr;
    IUPnPDevice * pudResult;

    pudResult = NULL;

    if (!m_pud)
    {
        CComObject<CUPnPDevice> * pudWrapper;
        IUnknown * punk;

        // create ourselves a wrapper, now.

        pudWrapper = NULL;
        hr = CComObject<CUPnPDevice>::CreateInstance(&pudWrapper);
        if (FAILED(hr))
        {
            TraceError("OBJ: CUPnPDeviceNode::HrGetWrapper - CreateInstance(CUPnPDevice)", hr);

            goto Cleanup;
        }
        Assert(pudWrapper);

        m_pud = pudWrapper;

        punk = m_pdoc->GetUnknown();
        Assert(punk);

        // note: this should addref() the doc.  also, after this point,
        //       it should Unwrap() us if it goes away on its own
        //
        pudWrapper->Init(this, punk);
    }
    Assert(m_pud);

    hr = m_pud->GetUnknown()->QueryInterface(IID_IUPnPDevice, (void**)&pudResult);
    Assert(SUCCEEDED(hr));
    Assert(pudResult);

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::HrGetWrapper", hr);
    Assert(FImplies(SUCCEEDED(hr), pudResult));
    Assert(FImplies(FAILED(hr), !pudResult));

    *ppud = pudResult;
    return hr;
}


BOOL
CUPnPDeviceNode::fIsThisOurUdn(LPCWSTR pszUdn)
{
    Assert(m_arypszStringProperties[dpUdn]);

    int result;
    BOOL fResult;

    result = wcscmp(m_arypszStringProperties[dpUdn], pszUdn);

    fResult = (0 == result) ? TRUE : FALSE;

    return fResult;
}

// searches the device tree at the current node for a node matching the
// given UDN.  If one is found, it that node is returned.  Otherwise,
// the chidren of a node are searched first, then its siblings.
// TODO(cmr): we somehow need to make sure only one device exists
//            per UDN
CUPnPDeviceNode *
CUPnPDeviceNode::UdnGetDeviceByUdn(LPCWSTR pszUdn)
{
    Assert(pszUdn);

    CUPnPDeviceNode * pdnResult;
    CUPnPDeviceNode * pdnTemp;

    pdnResult = NULL;

    {
        // search ourselves first
        BOOL fResult;

        fResult = fIsThisOurUdn(pszUdn);

        if (fResult)
        {
            pdnResult = this;
            goto Cleanup;
        }
    }

    // search our children next
    pdnTemp = (CUPnPDeviceNode *)GetFirstChild();
    if (pdnTemp)
    {
        pdnResult = pdnTemp->UdnGetDeviceByUdn(pszUdn);
        if (pdnResult)
        {
            goto Cleanup;
        }
    }

    // then search our siblings
    pdnTemp = (CUPnPDeviceNode *)GetNextSibling();
    if (pdnTemp)
    {
        pdnResult = pdnTemp->UdnGetDeviceByUdn(pszUdn);
    }

Cleanup:
    return pdnResult;
}

void
CUPnPDeviceNode::Unwrap()
{
    // only our wrapper may call this
    Assert(m_pud);
    m_pud = NULL;
}

STDMETHODIMP
CUPnPDeviceNode::get_IsRootDevice(VARIANT_BOOL *pvarb)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_IsRootDevice");

    HRESULT hr;
    BOOL fNotARootDevice;

    hr = S_OK;

    if (!pvarb)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    fNotARootDevice = HasParent();

    if (fNotARootDevice)
    {
        *pvarb = VARIANT_FALSE;
    }
    else
    {
        *pvarb = VARIANT_TRUE;
    }

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::get_IsRootDevice", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_RootDevice(IUPnPDevice **ppudDeviceRoot)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_RootDevice");

    HRESULT hr;
    IUPnPDevice * pud;
    CUPnPDeviceNode * pudn;

    if (!ppudDeviceRoot)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pudn = (CUPnPDeviceNode *)GetRoot();
    Assert(pudn);

    pud = NULL;
    hr = pudn->HrGetWrapper(&pud);

    *ppudDeviceRoot = pud;

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::get_RootDevice", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_ParentDevice(IUPnPDevice ** ppudDeviceParent)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_ParentDevice");

    HRESULT hr;
    IUPnPDevice * pud;
    CUPnPDeviceNode * pudn;

    hr = S_FALSE;
    pud = NULL;

    if (!ppudDeviceParent)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pudn = (CUPnPDeviceNode *)GetParent();
    if (pudn)
    {
        hr = pudn->HrGetWrapper(&pud);
        Assert(FImplies(SUCCEEDED(hr), S_OK == hr));
    }

    *ppudDeviceParent = pud;

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::get_ParentDevice", hr);
    return hr;

}

STDMETHODIMP
CUPnPDeviceNode::get_HasChildren(VARIANT_BOOL * pvarb)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_HasChildren");

    HRESULT hr;
    BOOL fHasChildren;

    if (!pvarb)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = S_OK;

    fHasChildren = HasChildren();
    if (fHasChildren)
    {
        *pvarb = VARIANT_TRUE;
    }
    else
    {
        *pvarb = VARIANT_FALSE;
    }

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::get_HasChildren", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_Children(IUPnPDevices **ppudChildren)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_Children");

    HRESULT hr;
    CComObject<CUPnPDevices> * pudsCollection;
    CUPnPDeviceNode * pudnChild;

    if (!ppudChildren)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    pudsCollection = NULL;

    hr = CComObject<CUPnPDevices>::CreateInstance(&pudsCollection);
    if (FAILED(hr))
    {
        pudsCollection = NULL;
        goto Cleanup;
    }
    Assert(pudsCollection);

    pudnChild = (CUPnPDeviceNode *)GetFirstChild();

    while (pudnChild)
    {
        IUPnPDevice * pud;

        // get the wrapper for the node.  HrGetWrapper() returns
        // an AddRef()'d pointer

        pud = NULL;

        hr = pudnChild->HrGetWrapper(&pud);
        if (FAILED(hr))
        {
            // HrGetWrapper must not have allocated/addref()'d us an object
            // clean up the collection, though.
            goto Error;
        }
        Assert(pud);

        // put it in the collection
        hr = pudsCollection->HrAddDevice(pud);

        // If HrAddDevice() succeeded, it AddRef()d our device, so we don't
        // need this ref anymore.  If it failed, we're going to bail,
        // releasing all of the devices we already put into the collection,
        // but since pud _isn't_ in the collection, we need to delete it
        // explicitly.
        pud->Release();

        if (FAILED(hr))
        {
            // this isn't good, we should fail.
            goto Error;
        }

        // get the next child
        pudnChild = (CUPnPDeviceNode *)pudnChild->GetNextSibling();
    }

    // we're all done, and we have a collection full of our children
    //  (which may mean that it's empty, but that's ok).

    hr = S_OK;
    pudsCollection->QueryInterface(ppudChildren);

Cleanup:
    TraceError("OBJ: CUPnPDeviceNode::get_Children", hr);
    return hr;

Error:
    Assert(ppudChildren);
    Assert(pudsCollection);

    // note: this should free anything we have in the collection too
    pudsCollection->GetUnknown()->AddRef();
    pudsCollection->GetUnknown()->Release();

    *ppudChildren = NULL;

    goto Cleanup;
}


HRESULT
CUPnPDeviceNode::HrReturnStringValue(LPCWSTR pszValue, BSTR * pbstr)
{
    HRESULT hr;
    BSTR bstrResult;

    hr = S_FALSE;
    bstrResult = NULL;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (pszValue)
    {
        bstrResult = ::SysAllocString(pszValue);
        if (!bstrResult)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
    }

Cleanup:
    Assert(FImplies((S_OK == hr), bstrResult));
    Assert(FImplies((S_OK != hr), !bstrResult));

    if (pbstr)
    {
        *pbstr = bstrResult;
    }

    TraceError("CUPnPDeviceNode:::HrReturnStringValue", hr);
    return hr;
}


STDMETHODIMP
CUPnPDeviceNode::get_UniqueDeviceName(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_UniqueDeviceName");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpUdn], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_UniqueDeviceName", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_FriendlyName(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_FriendlyName");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpFriendlyName], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_FriendlyName", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_Type(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_Type");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpType], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_Type", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_PresentationURL(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_PresentationURL");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpPresentationUrl], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_PresentationURL", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_ManufacturerName(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_ManufacturerName");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpManufacturerName], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_ManufacturerName", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_ManufacturerURL(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_ManufacturerURL");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpManufacturerUrl], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_ManufacturerURL", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_ModelName(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_ModelName");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpModelName], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_ModelName", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_ModelNumber(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_ModelNumber");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpModelNumber], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_ModelNumber", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_Description(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_Description");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpDescription], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_Description", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_ModelURL(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_ModelURL");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpModelUrl], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_ModelURL", hr);
    return hr;
}

STDMETHODIMP
CUPnPDeviceNode::get_UPC(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_UPC");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpUpc], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_get_UPC", hr);
    return hr;
}


STDMETHODIMP
CUPnPDeviceNode::get_SerialNumber(BSTR * pbstr)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_SerialNumber");

    HRESULT hr;

    hr = HrReturnStringValue(m_arypszStringProperties[dpSerialNumber], pbstr);

    TraceError("OBJ: CUPnPDeviceNode::get_SerialNumber", hr);
    return hr;
}


STDMETHODIMP
CUPnPDeviceNode::IconURL(BSTR bstrEncodingFormat,
                         LONG lSizeX,
                         LONG lSizeY,
                         LONG lBitDepth,
                         BSTR * pbstrIconUrl)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::IconURL");

    HRESULT hr;
    CIconPropertiesNode * pipnBestMatch;
    BSTR bstrResult;

    bstrResult = NULL;

    if (!pbstrIconUrl)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!bstrEncodingFormat)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (lSizeX < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (lSizeY < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (lBitDepth < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!m_pipnIcons)
    {
        // we have no icons
        hr = S_FALSE;
        goto Cleanup;
    }

    pipnBestMatch = pipnGetBestIcon(bstrEncodingFormat,
                                    lSizeX,
                                    lSizeY,
                                    lBitDepth,
                                    m_pipnIcons);
    if (!pipnBestMatch)
    {
        // no match was found.  This means that there are no icons
        // in our icon list of the format 'bstrEncodingFormat'.
        // leave bstrResult == NULL and return S_FALSE

        hr = S_FALSE;
        goto Cleanup;
    }

    {
        // return the result
        LPCWSTR pszUrl;

        pszUrl = pipnBestMatch->m_pszUrl;

        hr = HrReturnStringValue(pszUrl,
                                 &bstrResult);
    }

Cleanup:
    Assert(FImplies(S_OK == hr, bstrResult));
    Assert(FImplies(S_OK != hr, !bstrResult));

    if (pbstrIconUrl)
    {
        *pbstrIconUrl = bstrResult;
    }

    TraceError("OBJ: CUPnPDeviceNode::IconURL", hr);
    return hr;
}


STDMETHODIMP
CUPnPDeviceNode::get_Services(IUPnPServices ** ppusServices)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDeviceNode::get_Services");

    HRESULT hr;

    if (!ppusServices)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = m_usnlServiceList.HrGetWrapper(ppusServices);

Cleanup:
    TraceError("CUPnPDeviceNode::get_Services", hr);
    return hr;
}

// IUPnPDeviceDocumentAccess method

STDMETHODIMP
CUPnPDeviceNode::GetDocumentURL(BSTR* pbstrDocumentUrl)
{
    HRESULT hr = S_OK;

    if (!pbstrDocumentUrl)
    {
        hr = E_POINTER;
    }
    else
    {
        if (m_bstrUrl)
        {
            *pbstrDocumentUrl = SysAllocString(m_bstrUrl);
            if (!*pbstrDocumentUrl)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

CIconPropertiesNode::CIconPropertiesNode()
{
    AssertSz(ipLast == celems(s_dppsIconParsingInfo),
             "CIconPropertiesNode: Properties added but s_dppsIconParsingInfo not updated!");

    m_pszFormat = NULL;
    m_ulSizeX = 0;
    m_ulSizeY = 0;
    m_ulBitDepth = 0;
    m_pszUrl = NULL;

    m_pipnNext = NULL;
}

CIconPropertiesNode::~CIconPropertiesNode()
{
    if (m_pszFormat)
    {
        delete [] m_pszFormat;
    }

    if (m_pszUrl)
    {
        delete [] m_pszUrl;
    }

    // note: don't free m_pipnNext, the device node will do that
}

HRESULT
HrDwordFromString(LPCWSTR pszNumber, DWORD * pdwResult)
{
    Assert(pszNumber);
    Assert(pdwResult);

    HRESULT hr;
    DWORD dwResult;
    LONG lTemp;

    hr = E_INVALIDARG;
    dwResult = 0;

    lTemp = _wtol(pszNumber);
    if (lTemp >= 0)
    {
        hr = S_OK;
        dwResult = lTemp;
    }

    *pdwResult = dwResult;

    TraceError("HrDwordFromString", hr);
    return hr;
}

HRESULT
CIconPropertiesNode::HrInit(IXMLDOMNode * pxdn, LPCWSTR pszBaseUrl)
{
    HRESULT hr;
    LPWSTR arypszIconProperties [ipLast];
    BOOL fComplete;

    // Duplicate Tag Validation
    hr = HrAreElementTagsValid(pxdn, ipLast,s_dppsIconParsingInfo);
    if(SUCCEEDED(hr))
    {
        // note: this will initialize arypszIconProperties
        hr = HrReadElementWithParseData(pxdn,
                                    ipLast,
                                    s_dppsIconParsingInfo,
                                    pszBaseUrl,
                                    arypszIconProperties);
    }
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // note: after this point goto Error to free arypszIconProperties

    fComplete = fAreReadValuesComplete(ipLast,
                                       s_dppsIconParsingInfo,
                                       arypszIconProperties);
    if (!fComplete)
    {
        goto Error;
    }

    // ISSUE-2002/03/12-guruk -  In Our current implementation, we do not down load icons 
    //           dynamically. If this is implemented, we need to ensure the
    //           icon urls are valid and comes from the same host.
    //           Call fValidateUrl() to do this.

    
	// massage the data into ints, and free the strings

    // note(cmr): We do this (get strings from the xml doc and then convert
    //            them to integer values manually) to simplify our parsing
    //            code.  If we didn't, we'd have to handle mixed data types
    //            in HrReadElementWithParseData, rather than only read
    //            strings.  Since this is the only place where we have
    //            non-string data in the description doc, and since XML
    //            doesn't do any special encoding of "number"s, we just
    //            convert this here.

    hr = HrDwordFromString(arypszIconProperties[ipWidth], &m_ulSizeX);
    if (FAILED(hr))
    {
        goto Error;
    }

    hr = HrDwordFromString(arypszIconProperties[ipHeight], &m_ulSizeY);
    if (FAILED(hr))
    {
        goto Error;
    }

    hr = HrDwordFromString(arypszIconProperties[ipDepth], &m_ulBitDepth);
    if (FAILED(hr))
    {
        goto Error;
    }

    // we can't fail now.  reassign the strings, and free the ones we
    /// didn't take
    Assert(arypszIconProperties[ipMimetype]);
    m_pszFormat = arypszIconProperties[ipMimetype];

    Assert(arypszIconProperties[ipUrl]);
    m_pszUrl = arypszIconProperties[ipUrl];

    Assert(arypszIconProperties[ipWidth]);
    delete [] arypszIconProperties[ipWidth];

    Assert(arypszIconProperties[ipHeight]);
    delete [] arypszIconProperties[ipHeight];

    Assert(arypszIconProperties[ipDepth]);
    delete [] arypszIconProperties[ipDepth];

Cleanup:
    TraceError("OBJ: CIconPropertiesNode::HrInit", hr);
    return hr;

Error:
    hr = UPNP_E_ICON_NODE_INCOMPLETE;

    {
        ULONG i;

        i = 0;
        for ( ; i < ipLast; ++i)
        {
            if (arypszIconProperties[i])
            {
                delete [] arypszIconProperties[i];
            }
        }
    }

    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdocumentnotifysink.cpp ===
//depot/private/upnp/net/upnp/upnp/api/upnpdocumentnotifysink.cpp#4 - integrate change 7273 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocumentnotifysink.cpp
//
//  Contents:   implementation of CUPnPDocumentNotifySink
//
//  Notes:      Implementation of IPropertyNotifySink that forwards
//              OnChanged events to the generic document object.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "upnpdocument.h"
#include "upnpdocumentnotifysink.h"


CUPnPDocumentNotifySink::CUPnPDocumentNotifySink()
{
    _pdoc = NULL;
    _punk = NULL;
    _fAdvised = FALSE;
}

CUPnPDocumentNotifySink::~CUPnPDocumentNotifySink()
{
    // our doc MUST call our Deinit() before releasing us...
    Assert(!_pdoc);
    Assert(!_punk);

    Assert(!_fAdvised);
}

HRESULT
CUPnPDocumentNotifySink::Init(CUPnPDocument * pdoc, IUnknown * punk)
{
    Assert(pdoc);
    Assert(punk);

    HRESULT hr;

    _pdoc = pdoc;

    punk->AddRef();
    _punk = punk;

    // Addref() ourselves for our doc.
    // we keep this ref even if we fail.
    GetUnknown()->AddRef();

    hr = AtlAdvise(punk, GetUnknown(), IID_IPropertyNotifySink, &_dwNookieCookie);
    TraceError("OBJ: CUPnPDocument::CUPnPDocumentNotifySink::Init - AtlAdvise", hr);

    _fAdvised = SUCCEEDED(hr);

    return hr;
}

HRESULT
CUPnPDocumentNotifySink::Deinit()
{
    Assert(_punk);

    HRESULT hr;

    hr = S_OK;

    if (_fAdvised)
    {
        hr = AtlUnadvise(_punk, IID_IPropertyNotifySink, _dwNookieCookie);

        TraceError("OBJ: CUPnPDocument::CUPnPDocumentNotifySink::Deinit - AtlUnadvise", hr);

        _fAdvised = FAILED(hr);

        // we're somewhat in trouble here if the Unadvise failed, but the best we can
        // do is to free everything anyway.
    }

    _punk->Release();
    _punk = NULL;

    _pdoc = NULL;

    return hr;
}


// IPropertyNotifySink Methods
STDMETHODIMP
CUPnPDocumentNotifySink::OnChanged (DISPID dispid)
{
    HRESULT hr = E_UNEXPECTED;

    if (_pdoc)
    {
        hr = _pdoc->OnChanged(dispid);
    }

    return hr;
}

STDMETHODIMP
CUPnPDocumentNotifySink::OnRequestEdit (DISPID dispid)
{
    // Let the edit continue.  We don't care.
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpdocumentctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocumentctx.cpp
//
//  Contents:   implementation of wininet callbacks
//
//  Notes:      
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "upnpdocument.h"
#include "upnpdocumentctx.h"

#include <ncutil.h>



static BOOL                 g_bInitDownloads = FALSE;
static CRITICAL_SECTION     g_csDownloads;
static HANDLE               g_hDownloads = NULL;
static DWORD                g_nDownloads = 0;


void
InitDownloads()
{
    if (!g_bInitDownloads)
    {
        InitializeCriticalSection(&g_csDownloads);
        // start off signalled since no downloads active
        g_hDownloads = CreateEvent(NULL, TRUE, TRUE, NULL);

        g_nDownloads = 0;

        g_bInitDownloads = TRUE;
    }
}


void
WaitForAllDownloadsComplete(DWORD ms)
{
    if (g_bInitDownloads)
    {
        if (g_hDownloads)
        {
            WaitForSingleObject(g_hDownloads, ms);
            CloseHandle(g_hDownloads);
            g_hDownloads = NULL;
        }
        DeleteCriticalSection(&g_csDownloads);
    }
}

void
IncrementDownloadBusy()
{
    if (g_bInitDownloads)
    {
        EnterCriticalSection(&g_csDownloads);

        g_nDownloads++;
        if (g_hDownloads)
            ResetEvent(g_hDownloads);

        LeaveCriticalSection(&g_csDownloads);
    }
}

void
DecrementDownloadBusy()
{
    if (g_bInitDownloads)
    {
        EnterCriticalSection(&g_csDownloads);

        g_nDownloads--;
        if (0 == g_nDownloads && g_hDownloads)
            SetEvent(g_hDownloads);

        LeaveCriticalSection(&g_csDownloads);
    }
}





CUPnPDocumentCtx::CUPnPDocumentCtx()
{
    m_pDoc = NULL;
    m_dwGITCookie = 0;
    m_dwError = 0;

    InitDownloads();
}

CUPnPDocumentCtx::~CUPnPDocumentCtx()
{
}


HRESULT
CUPnPDocumentCtx::FinalConstruct()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::FinalConstruct");

    return S_OK;

}


HRESULT
CUPnPDocumentCtx::FinalRelease()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::FinalRelease");


    return S_OK;

}


// The CDocument object passes in pointer to itself.
// The CDocumentCtx object is registered in the Global Interface Table
HRESULT 
CUPnPDocumentCtx::Init(CUPnPDocument* pDoc, DWORD* pdwContext)
{
    IUnknown * punk;
    IUnknown* pIntf;

    IGlobalInterfaceTable * pgit;
    HRESULT hr;

    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::Init");
    m_pDoc = NULL;
    m_dwGITCookie = 0;
    *pdwContext = 0;

    // register ourselves in the GIT
    hr = HrGetGITPointer(&pgit);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    Assert(pgit);
    punk = GetUnknown();
    Assert(punk);
    hr = punk->QueryInterface(IID_IUPnPPrivateDocumentCallbackHelper, (void**)&pIntf);

    if (SUCCEEDED(hr))
    {
        hr = pgit->RegisterInterfaceInGlobal(pIntf,
                                             IID_IUPnPPrivateDocumentCallbackHelper,
                                             &m_dwGITCookie);
        pIntf->Release();
    }

    pgit->Release();

    if (FAILED(hr))
    {
        TraceError("CUPnPDocumentCtx::Init: RegisterInterfaceInGlobal", hr);
        goto Cleanup;
    }

    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::Init, registered interface cookie=%x", m_dwGITCookie);
    m_pDoc = pDoc;
    *pdwContext = m_dwGITCookie;

Cleanup:
    TraceError("CUPnPDocumentCtx::Init",hr);
    return hr;
}


// start the async download.
// Indicate that it is busy
HRESULT
CUPnPDocumentCtx::StartInternetOpenUrl(HINTERNET hInetSess,
                                       LPTSTR pszFullUrl,
                                       LPTSTR pszHdr,
                                       DWORD dwHdrLen,
                                       DWORD dwFlags)
{
    HRESULT hr = S_OK;

    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::StartInternetOpenUrl");

    IncrementDownloadBusy();

    // bump ref cnt until async transfer completes
    GetUnknown()->AddRef();

    HINTERNET hOpenUrl = InternetOpenUrl(hInetSess,
                                       pszFullUrl,
                                       pszHdr,
                                       dwHdrLen,
                                       dwFlags,
                                       m_dwGITCookie);

    // if async, then should get error of ERROR_IO_PENDING
    DWORD dw = GetLastError();
    if (ERROR_IO_PENDING != dw)
    {
        // no transfer, release now
        GetUnknown()->Release();
        
        DecrementDownloadBusy();

        hr = HrFromLastWin32Error();
        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::StartInternetOpenUrl, error dw=%d", dw);
    }

    TraceError("CUPnPDocumentCtx::StartInternetOpenUrl",hr);
    return hr;
}


// download has completed
// The document no longer needs the context.
// remove self from Global Interface Table
// mark as not busy
HRESULT
CUPnPDocumentCtx::EndInternetOpenUrl()
{
    HRESULT hr = S_OK;

    if (m_dwGITCookie)
    {
        // remove ourselves from the GIT.  

        IGlobalInterfaceTable * pgit;
        HRESULT hr;

        pgit = NULL;

        hr = HrGetGITPointer(&pgit);
        if (SUCCEEDED(hr))
        {
            Assert(pgit);

            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::EndInternetOpenUrl, revoking interface using %x", m_dwGITCookie);
            hr = pgit->RevokeInterfaceFromGlobal(m_dwGITCookie);
            if (FAILED(hr))
                TraceTag(ttidUPnPDocument, "CUPnPDocumentCtx::EndInternetOpenUrl: RevokeInterfaceFromGlobal fails");

            pgit->Release();
            m_dwGITCookie = 0;
        }
    }

    GetUnknown()->Release();

    TraceError("CUPnPDocumentCtx::EndInternetOpenUrl",hr);
    return hr;
}


// The document is no longer interesting. Do not release anything as we
//  may be in middle of callback
VOID
CUPnPDocumentCtx::Deinit()
{
    TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::Deinit");

    m_pDoc = NULL;
}


// this runs on main thread, after being invoked from wininet callback
// called when request is completed successfully
STDMETHODIMP
CUPnPDocumentCtx::DocumentDownloadReady(DWORD_PTR hOpenUrl)
{
    HRESULT hr = S_OK;

    if (m_pDoc)
    {
        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::DocumentDownloadReady");
        hr = m_pDoc->DocumentDownloadReady((HINTERNET)hOpenUrl, 0);
    }
    if (hr != E_PENDING)
    {
        InternetCloseHandle((HINTERNET)hOpenUrl);
        EndInternetOpenUrl();
    }

    TraceError("CUPnPDocumentCtx::DocumentDownloadReady",hr);
    return hr;
}


// this runs on main thread, after being invoked from wininet callback
// called when request is completed unsuccessfully
STDMETHODIMP
CUPnPDocumentCtx::DocumentDownloadAbort(DWORD_PTR hOpenUrl, DWORD dwError)
{
    HRESULT hr = S_OK;

    if (m_pDoc)
    {
        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::DocumentDownloadAbort error %d", dwError);
        hr = m_pDoc->DocumentDownloadReady((HINTERNET)hOpenUrl, dwError);
    }
    if (hr != E_PENDING)
    {
        InternetCloseHandle((HINTERNET)hOpenUrl);
        EndInternetOpenUrl();
    }

    TraceError("CUPnPDocumentCtx::DocumentDownloadAbort",hr);
    return hr;
}


// this runs on main thread, after being invoked from wininet callback
// called when request is being redirected
STDMETHODIMP
CUPnPDocumentCtx::DocumentDownloadRedirect(DWORD_PTR hOpenUrl, LPCWSTR lpstrUrl)
{
    HRESULT hr = S_OK;

    if (m_pDoc)
    {
        TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::DocumentDownloadRedirect");
        if (!m_pDoc->fIsUrlLoadAllowed(lpstrUrl))
        {
            hr = m_pDoc->AbortLoading();
            InternetCloseHandle((HINTERNET)hOpenUrl);
            EndInternetOpenUrl();
        }
        else
        {
            // we can do this from other thread
            hr = m_pDoc->SetBaseUrl(lpstrUrl);
        }
    }

    TraceError("CUPnPDocumentCtx::DocumentDownloadRedirect",hr);
    return hr;
}


// this is the WinInet callback function for Async operations
// We are interested only in REQUEST_COMPLETE and REDIRECT
// Uses context to get pointer to CDocumentCtx object.
// then gets interface pointer from Global Interface Table
// and calls through the interface to force thread switch
void __stdcall CUPnPDocumentCtx::DocLoadCallback(HINTERNET hInternet,
                        DWORD_PTR dwContext,
                        DWORD dwInternetStatus,
                        LPVOID lpvStatusInformation,
                        DWORD dwStatusInformationLength)
{
#define NOP         0
#define COMPLETE    1
#define ABORT       2
#define REDIRECT    3

    DWORD action = NOP;
    DWORD dwError;
    HINTERNET hHandle;
    HRESULT hr = S_OK;

    switch (dwInternetStatus)
    {
    case INTERNET_STATUS_REDIRECT:
        TraceTag(ttidUPnPDocument," REDIRECT to %s", lpvStatusInformation);
        action = REDIRECT;
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        TraceTag(ttidUPnPDocument," REQUEST_COMPLETE hInternet %x, dwResult %x, dwError %x",
                        hInternet, 
                        ((INTERNET_ASYNC_RESULT *)lpvStatusInformation)->dwResult,
                        ((INTERNET_ASYNC_RESULT *)lpvStatusInformation)->dwError);

        if (((INTERNET_ASYNC_RESULT *)lpvStatusInformation)->dwResult > 1)
        {
            hHandle = (HINTERNET)((INTERNET_ASYNC_RESULT *)lpvStatusInformation)->dwResult;
            dwError = ((INTERNET_ASYNC_RESULT *)lpvStatusInformation)->dwError;
        }
        else
        {
            hHandle = hInternet;
            dwError = ((INTERNET_ASYNC_RESULT *)lpvStatusInformation)->dwResult == 1 ? 0 : 1;
        }
        // Check for errors.
        if (dwError == 0)
            action = COMPLETE;
        else
            action = ABORT;
        break;

    default:
        break;
    }

    if (NOP != action)
    {
        // need to make call to CUPnPDocument on its thread
        HRESULT hr;
        BOOL fCoInited = FALSE;
        IUPnPPrivateDocumentCallbackHelper * ppch;
        IGlobalInterfaceTable * pgit;
        DWORD dwGITCookie = 0;

        if (0 == dwContext)
        {
            TraceTag(ttidUPnPDocument,"DocLoadCallback:  NULL context");
            return;
        }
        dwGITCookie = (DWORD)dwContext;

        while (TRUE)
        {
            hr = ::CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
            if (SUCCEEDED(hr))
            {
                fCoInited = TRUE;
                break;
            }
            else
            {
                if (hr == RPC_E_CHANGED_MODE)
                {
                    TraceError("DocLoadCallback RPC_E_CHANGED_MODE", hr);
                    CoUninitialize();
                }
                else
                {
                    // CoInitializeEx failed, so we can't call the callback,
                    // so we can't really do anything here
                    //
                    TraceError("DocLoadCallback CoInitialize", hr);
                    goto Cleanup;
                }
            }
        }

        // Obtain a marshalled pointer to our private callback helper object.
        // This makes all of the operations execute in the context of the
        // caller's thread.
        //

        hr = HrGetGITPointer(&pgit);
        if (SUCCEEDED(hr))
        {
            Assert(pgit);

            TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::DocLoadCallback, get interface using %x", dwGITCookie);
            hr = pgit->GetInterfaceFromGlobal(dwGITCookie,
                                              IID_IUPnPPrivateDocumentCallbackHelper,
                                              (LPVOID *)&ppch);

            pgit->Release();
        }


        if (FAILED(hr))
        {
            TraceError("CUPnPDocumentCtx::DocLoadCallback: GetInterfaceFromGlobal fails", hr);

            ppch = NULL;

            InternetCloseHandle(hHandle);
        }

        if (ppch)
        {
            switch (action)
            {
            case COMPLETE:
                TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::DocLoadCallback, COMPLETE ctx %x", dwGITCookie);

                // this could take some time!
                // Is there a better way to do this?
                hr = ppch->DocumentDownloadReady((DWORD_PTR)hHandle);
                break;

            case ABORT:
                TraceTag(ttidUPnPDocument, "OBJ: CUPnPDocumentCtx::DocLoadCallback, ABORT ctx %x", dwGITCookie);

                ppch->DocumentDownloadAbort((DWORD_PTR)hHandle,
                                            dwError);
                break;

            case REDIRECT:
                {
                    LPCWSTR lpstrUrl = WszFromTsz((LPCTSTR)lpvStatusInformation);

                    if (lpstrUrl)
                    {
                        ppch->DocumentDownloadRedirect((DWORD_PTR)hInternet, lpstrUrl);
                        MemFree((VOID*)lpstrUrl);
                    }
                }
                break;

            }

            ppch->Release();
            TraceError("CUPnPDocumentCtx::DocLoadCallback", hr);
        }


Cleanup:
        if (fCoInited)
        {
            CoUninitialize();
        }
    }

    if (INTERNET_STATUS_REQUEST_COMPLETE == dwInternetStatus && 
        hr != E_PENDING)
    {
        DecrementDownloadBusy();
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpservice.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservice.cpp
//
//  Contents:   IUPnPService implementation for CUPnPService
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------



#include "pch.h"
#pragma hdrstop

#include "UPnPService.h"
#include "ncstring.h"
#include "ncutil.h"
#include "upnpcommon.h"
#include "nccom.h"
#include "ncbase.h"

#include "rehy.h"
#include "rehyutil.h"

const WCHAR WSZ_UPNP_NAMESPACE_URI[] =
    L"urn:schemas-upnp-org:control-1-0";

/*
 * Function:    CUPnPService::CUPnPService
 *
 * Purpose:     Default class constructor - HrInitializes private data members.
 */


CUPnPService::CUPnPService()
{
    m_pwszSTI = NULL;
    m_pwszControlURL = NULL;
    m_pControlConnect = NULL;
    m_pwszEventSubURL = NULL;
    m_pwszId = NULL;
    m_lNumStateVariables = 0;
    m_StateTable = NULL;
    m_lNumActions = 0;
    m_ActionTable = NULL;
    m_hEventSub = INVALID_HANDLE_VALUE;
    m_pwszSubsID = NULL;
    m_dwSeqNumber = -1;
    m_fCallbackCookieValid = FALSE;
    m_dwCallbackCookie = -1;
    m_psc = NULL;
    m_lLastTransportStatus = 0;

    m_arydwCallbackCookies = NULL;
    m_dwNumCallbacks = 0;
    m_dwMaxCallbacks = 0;
    m_bShutdown = FALSE;
}

/*
 * Function:    CUPnPService::~CUPnPService
 *
 * Purpose:     Default class destructor - frees resources used.
 */

CUPnPService::~CUPnPService()
{
    TraceTag(ttidUPnPService, "CUPnPService::~CUPnPService(this=%x): Enter\n", this);

    Assert(!m_psc);
    Assert(!m_fCallbackCookieValid);
    Assert(m_bShutdown);

    // note: the first stage of destruction happens in FinalRelease()

    Lock();

    if (m_pwszSTI)
    {
        MemFree(m_pwszSTI);
        m_pwszSTI = NULL;
    }

    if (m_pwszControlURL)
    {
        MemFree(m_pwszControlURL);
        m_pwszControlURL = NULL;
    }

    if (m_pControlConnect)
    {
        HrReleaseControlConnect(m_pControlConnect);
        m_pControlConnect = NULL;
    }

    if (m_pwszEventSubURL)
    {
        MemFree(m_pwszEventSubURL);
        m_pwszEventSubURL = NULL;
    }

    if (m_pwszId)
    {
        MemFree(m_pwszId);
        m_pwszId = NULL;
    }

    if (m_pwszSubsID)
    {
        MemFree(m_pwszSubsID);
        m_pwszSubsID = NULL;
    }

    freeActionTable();

    Unlock();

    m_StateTableCS.Lock();

    freeStateTable();

    m_StateTableCS.Unlock();

    TraceTag(ttidUPnPService, "CUPnPService::~CUPnPService(this=%x): Exit\n", this);
}


HRESULT
CUPnPService::FinalConstruct()
{
    HRESULT hr = S_OK;

    // initialize callback list
    LPDWORD arydwTemp = NULL;

    arydwTemp = new DWORD [ CALLBACK_LIST_INIT_SIZE ];
    if (!arydwTemp)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        SIZE_T size;

        size = sizeof(DWORD) * CALLBACK_LIST_INIT_SIZE;

        ::ZeroMemory(arydwTemp, size);

        m_arydwCallbackCookies = arydwTemp;

        m_dwMaxCallbacks = CALLBACK_LIST_INIT_SIZE;
    }

    if(FAILED(hr))
    {
        m_bShutdown = TRUE;
    }

    TraceError("CUPnPService::FinalConstruct: HrSsdpStartup", hr);

    return hr;
}


HRESULT
CUPnPService::FinalRelease()
{
    Assert(m_bShutdown);

    HRESULT hr;

    hr = S_OK;

    if (m_arydwCallbackCookies)
    {
        FreeCallbackList();

        delete [] m_arydwCallbackCookies;

        m_arydwCallbackCookies = NULL;
    }

    // note: more destruction happens in ~CUPnPService()

    TraceError("CUPnPService::FinalRelease", hr);
    return hr;
}


/*
 * Function:    CUPnPService::AddCallback()
 *
 * Purpose:     Add a function to the list of callbacks that will be fired
 *              when a state variable update occurs.
 *
 * Arguments:
 *  pUnkCallback   [in]    Callback object - either supports
 *                         IUPnPServiceCallback or IDispatch
 *                         (where the method with dispID 0 is
 *                          the callback function).
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Note:
 *  This function must _NOT_ be called from an event callback (DOC ISSUE).
 */

STDMETHODIMP CUPnPService::AddCallback(IN    IUnknown * pUnkCallback)
{
    TraceTag(ttidUPnPService, "CUPnPService::AddCallback(this=%x)", this);
    HRESULT hr = S_OK;

    if (IsBadReadPtr((void *) pUnkCallback, sizeof(IUnknown)))
        return E_POINTER;

    Lock();

    hr = HrAddCallback(pUnkCallback, NULL);

    Unlock();

    TraceError("CUPnPService::AddCallback(): "
               "Exiting",
               hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPService::AddTransientCallback
//
//  Purpose:    Adds a callback that can later be removed
//
//  Arguments:
//      pUnkCallback [in]   Callback to be added
//      pdwCookie    [out]  Returns the cookie from the GIT that can be used
//                          to remove the callback
//
//  Returns:    S_OK if success, E_INVALIDARG if callback cookie was invalid,
//              or pUnkCallback does not support one of the valid callback
//              interfaces
//
//  Author:     danielwe   2001/05/14
//
//  Notes:      DO NOT CALL THIS FUNCTION FROM WITHIN A CALLBACK (Doc Issue)
//
STDMETHODIMP CUPnPService::AddTransientCallback(IN    IUnknown * pUnkCallback,
                                                OUT   DWORD *pdwCookie)
{
    TraceTag(ttidUPnPService, "CUPnPService::AddTransientCallback(this=%x)", this);
    HRESULT hr = S_OK;

    if (IsBadReadPtr((void *) pUnkCallback, sizeof(IUnknown)))
        return E_POINTER;

    if (IsBadReadPtr((void *) pdwCookie, sizeof(DWORD)))
        return E_POINTER;

    Lock();

    hr = HrAddCallback(pUnkCallback, pdwCookie);

    Unlock();

    TraceError("CUPnPService::AddTransientCallback(): "
               "Exiting",
               hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPService::RemoveTransientCallback
//
//  Purpose:    Removes a callback from the list of callbacks and revokes it
//              from the GIT
//
//  Arguments:
//      dwCookie [in]   Cookie returned from AddTransientCallback()
//
//  Returns:    S_OK if success, E_INVALIDARG if callback cookie was invalid
//
//  Author:     danielwe   2001/05/14
//
//  Notes:      DO NOT CALL THIS FUNCTION FROM WITHIN A CALLBACK (Doc Issue)
//
STDMETHODIMP CUPnPService::RemoveTransientCallback(IN DWORD dwCookie)
{
    TraceTag(ttidUPnPService, "CUPnPService::RemoveTransientCallback(this=%x)", this);
    HRESULT hr = S_OK;

    Lock();

    hr = HrRemoveCallback(dwCookie);

    Unlock();

    TraceError("CUPnPService::RemoveTransientCallback(): "
               "Exiting",
               hr);

    return hr;
}

STDMETHODIMP CUPnPService::QueryStateVariable(BSTR bstrVariableName,
                                              VARIANT *pValue)
{
    TraceTag(ttidUPnPService, "CUPnPService::QueryStateVariable(this=%x) - Enter", this);
    HRESULT hr = UPNP_E_INVALID_VARIABLE;

    if ((NULL == pValue) || (NULL == bstrVariableName))
        return E_POINTER;

    if (IsBadWritePtr((void *) pValue, sizeof(VARIANT)) ||
        IsBadStringPtrW(bstrVariableName, MAX_STRING_LENGTH))
        return E_POINTER;

    VariantInit(pValue);

    m_StateTableCS.Lock();

    for (LONG i = 0; i < m_lNumStateVariables; i++)
    {
        if (_wcsicmp(bstrVariableName, m_StateTable[i].pwszVarName) == 0)
        {
            hr = S_OK;

            if ((m_StateTable[i].value.vt == VT_EMPTY) &&
                (FALSE == m_StateTable[i].bDoRemoteQuery))
            {
                // This row has not been initialized by an event.

                hr = UPNP_E_VARIABLE_VALUE_UNKNOWN;
                TraceError("CUPnPService::QueryStateVariable(): "
                           "Evented variable has not been initialized",
                           hr);
            }
            else
            {
                if (m_StateTable[i].bDoRemoteQuery)
                {
                    // This is a non-evented variable. Have to go out to the
                    // device to get its value.

                    TraceTag(ttidUPnPService,
                             "CUPnPService::QueryStateVariable(): "
                             "Doing remote query for variable %S\n",
                             m_StateTable[i].pwszVarName);

                    m_lLastTransportStatus = 0;

                    ClearSSTRowValue(&(m_StateTable[i].value));

                    hr = HrRehydratorQueryStateVariableEx(&(m_StateTable[i]),
                                                        WSZ_UPNP_NAMESPACE_URI,
                                                        m_pwszControlURL,
                                                        m_pControlConnect,
                                                        &m_lLastTransportStatus);

                }

                if (SUCCEEDED(hr))
                {
                    hr = VariantCopy(pValue, &(m_StateTable[i].value));
                }
                else
                {
                    TraceError("CUPnPService::QueryStateVariable(): "
                               "Remote QueryStateVariable failed",
                               hr);
                }
            }
            break;
        }
    }

    m_StateTableCS.Unlock();

    TraceTag(ttidUPnPService, "CUPnPService::QueryStateVariable(this=%x) - Exit", this);
    return hr;
}


STDMETHODIMP CUPnPService::InvokeAction(
    IN  BSTR           bstrActionName,
    IN  VARIANT        vInActionArgs,
    IN  OUT VARIANT    * pvOutActionArgs,
    OUT VARIANT        * pvRetVal)
{
    TraceTag(ttidUPnPService, "CUPnPService::InvokeAction(this=%x)", this);
    HRESULT     hr = S_OK;

    if (m_lNumActions > 0)
    {
        if (IsBadStringPtrW(bstrActionName,
                            MAX_STRING_LENGTH) ||
            (pvOutActionArgs && IsBadReadPtr((void *) pvOutActionArgs,
                         sizeof(VARIANT))) ||
            (pvOutActionArgs && IsBadWritePtr((void *) pvOutActionArgs,
                          sizeof(VARIANT))) ||
            (pvRetVal && IsBadWritePtr((void *) pvRetVal,
                          sizeof(VARIANT))))
        {
            hr = E_POINTER;
            TraceError("CUPnPService::InvokeAction(): "
                       "Bad pointer argument", hr);
        }
        else
        {
            VARIANT     * pvar;

            for (pvar = &vInActionArgs;
                 pvar->vt == (VT_VARIANT | VT_BYREF);
                 pvar = pvar->pvarVal)
            {}

            SAFEARRAY   * psa = NULL;
            IDispatch   * pdisp = NULL;

            switch(pvar->vt)
            {
            case VT_VARIANT | VT_ARRAY:
                psa = pvar->parray;
                break;

            case VT_VARIANT | VT_ARRAY | VT_BYREF:
                psa = *pvar->pparray;
                break;

            case VT_DISPATCH:
                pdisp = pvar->pdispVal;
                hr = HrJScriptArrayToSafeArray(pdisp, pvar);

                if (SUCCEEDED(hr))
                {
                    Assert(pvar->vt == (VT_VARIANT | VT_ARRAY));
                    psa = pvar->parray;
                }
                break;

            default:
                hr = DISP_E_TYPEMISMATCH;
            };

            if (SUCCEEDED(hr))
            {
                SERVICE_ACTION  * pAction = NULL;

                Assert(psa);

                hr = HrValidateAction(bstrActionName, psa, &pAction);

                if (SUCCEEDED(hr))
                {
                    Assert(pAction);

                    if (NULL == pvOutActionArgs)
                    {
                        if ((pAction->lNumOutArguments > 1) ||
                            ((pAction->lNumOutArguments == 1) &&
                             (NULL == pAction->pReturnValue)))
                        {
                            hr = E_POINTER;
                            TraceError("CUPnPService::InvokeAction(): "
                                       "Action has out parameters, but NULL"
                                       "out argument array passed in",
                                       hr);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        if ((NULL == pvRetVal) &&
                            (NULL != pAction->pReturnValue))
                        {
                            hr = E_POINTER;
                            TraceError("CUPnPService::InvokeAction(): "
                                       "Action has return value, but NULL"
                                       "return value pointer passed in",
                                       hr);
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        SAFEARRAY * psaOutArgs = NULL;
                        SAFEARRAY ** ppsaOutArgs = NULL;

                        m_lLastTransportStatus = 0;

                        if (pvOutActionArgs)
                        {
                            ppsaOutArgs = &psaOutArgs;
                        }
                        else
                        {
                            ppsaOutArgs = NULL;
                        }

                        hr = HrRehydratorInvokeServiceActionEx(pAction,
                                                             psa,
                                                             m_pwszSTI,
                                                             m_pwszControlURL,
                                                             m_pControlConnect,
                                                             ppsaOutArgs,
                                                             pvRetVal,
                                                             &m_lLastTransportStatus);

                        if (SUCCEEDED(hr))
                        {
                            if (pvOutActionArgs)
                            {
                                VariantClear(pvOutActionArgs);
                                V_VT(pvOutActionArgs) = VT_VARIANT | VT_ARRAY;
                                pvOutActionArgs->parray = psaOutArgs;
                            }
                        }
                    }
                }
                else
                {
                    TraceError("CUPnPService::InvokeAction(): "
                               "Invocation request failed validation", hr);
                }
            }
            else
            {
                TraceError( "CUPnPService::InvokeAction(): "
                            "Failed in parsing action arguments", hr);
            }
        }

    }
    else
    {
        hr = E_FAIL;
        TraceError("CUPnPService::InvokeAction(): "
                   "InvokeAction called for a service that has no actions",
                   hr);

    }

    TraceError("CUPnPService::InvokeAction()", hr);
    return hr;
}


STDMETHODIMP CUPnPService::get_ServiceTypeIdentifier(BSTR *pVal)
{
    Assert(m_pwszSTI);

    HRESULT hr = S_OK;

    TraceTag(ttidUPnPService, "CUPnPService::get_ServiceTypeIdentifier(): "
             "Enter\n");

    if (NULL == pVal)
        return E_POINTER;

    if (IsBadWritePtr((void *) pVal, sizeof(BSTR)))
        return E_POINTER;

    *pVal = SysAllocString(m_pwszSTI);

    if (NULL == *pVal)
    {
        hr = E_OUTOFMEMORY;
        TraceError("CUPnPService::get_ServiceTypeIdentifier(): "
                   "Could not allocate STI string", hr);
    }

    TraceTag(ttidUPnPService, "CUPnPService::get_ServiceTypeIdentifier(): "
             "Exit - Returning hr == 0x%x\n", hr);

    TraceError("CUPnPService::get_ServiceTypeIdentifier", hr);
    return hr;
}


/*
 * Function:    CUPnPService::get_Id()
 *
 * Purpose:     Returns the Service Instance Identifier of the service
 *              object.
 *
 * Parameters:
 *  pbstrId         On return, contains a newly-alloced string containing
 *                  the service id.
 *
 * Returns:
 *  S_OK            *pbstrId is a newly-allocated string containing
 *                  the service ID.
 *  E_OUTOFMEMORY   there was not sufficient memory to copy the
 *                  string.
 */

STDMETHODIMP
CUPnPService::get_Id(BSTR * pbstrId)
{
    Assert(m_pwszId);

    HRESULT hr = S_OK;

    TraceTag(ttidUPnPService, "CUPnPService::get_Id(): "
             "Enter\n");

    if (NULL == pbstrId)
        return E_POINTER;

    if (IsBadWritePtr((void *) pbstrId, sizeof(BSTR)))
        return E_POINTER;

    *pbstrId = SysAllocString(m_pwszId);

    if (NULL == *pbstrId)
    {
        hr = E_OUTOFMEMORY;
        TraceError("CUPnPService::get_Id(): "
                   "Could not allocate Id string", hr);
    }

    TraceTag(ttidUPnPService, "CUPnPService::get_Id(): "
             "Exit - Returning hr == 0x%x\n", hr);

    Assert(FImplies(SUCCEEDED(hr) && pbstrId, *pbstrId));
    Assert(FImplies(FAILED(hr) && pbstrId, !(*pbstrId)));

    TraceError("CUPnPService::get_Id", hr);
    return hr;
}


/*
 * Function:    CUPnPService::get_LastTransportStatus()
 *
 * Purpose:     Returns the transport status value from the last
 *              remote operation (invoking an action or doing a
 *              remote query state variable).
 *
 * Arguments:
 *  plStatus    [out]   Returns the status value.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  The value returned is only meaningful after a transport operation.
 */

STDMETHODIMP
CUPnPService::get_LastTransportStatus(
    OUT long    * plStatus)
{
    HRESULT hr = S_OK;

    if (!IsBadWritePtr((void *) plStatus, sizeof(long)))
    {
        *plStatus = m_lLastTransportStatus;
    }
    else
    {
        hr = E_POINTER;
    }

    TraceError("CUPnPService::get_LastTransportStatus(): "
               "Exiting",
               hr);
    return hr;
}


/*
 * Function:    CUPnPService::HrInitialize()
 *
 * Purpose:     HrInitializes a new service object.
 *
 * Arguments:
 *  pcwszSTI            [in]    Service Type Identifier for the service
 *                               this object represents.
 *  pcwszControlURL     [in]    The HTTP URL to which control requests will
 *                               be sent
 *  pcwszEventSubURL    [in]    The HTTP URL to which event subscription
 *                               requests will be sent
 *  lNumStateVariables  [in]    Number of state variables exported
 *  pSST                [in]    Array of SERVICE_STATE_VARIABLE structures
 *                              representing a service state table (array
 *                              length must equal lNumStateVariables)
 *  lNumActions         [in]    Number of actions exported
 *  pActionTable        [in]    Array of SERVICE_ACTION structures representing
 *                              the actions supported by the service (array
 *                              length must equal lNumActions)
 *
 * Returns:     S_OK if successful, other HRESULT if error
 */

HRESULT
CUPnPService::HrInitialize(IN LPCWSTR                  pcwszSTI,
                           IN LPCWSTR                  pcwszControlURL,
                           IN LPCWSTR                  pcwszEventSubURL,
                           IN LPCWSTR                  pcwszId,
                           IN LONG                     lNumStateVariables,
                           IN SERVICE_STATE_TABLE_ROW  * pSST,
                           IN LONG                     lNumActions,
                           IN SERVICE_ACTION           * pActionTable)
{
    HRESULT hr = S_OK;

    TraceTag(ttidUPnPService, "CUPnPService::HrInitialize(this=%x): Enter\n", this);

    // Initialize the state and action table pointers first. The rehydrator
    // assumes that we now own this memory and will free it in our destructor.
    // Therefore, we have to copy these pointers before doing anything that can
    // fail and cause us to bail out (even checking for null on these pointers).

    m_StateTableCS.Lock();

    freeStateTable();   // In case there was one before

    m_lNumStateVariables = lNumStateVariables;
    m_StateTable = pSST;

    m_StateTableCS.Unlock();

    // Need to lock the object to finish the rest
    // of the initialization.

    Lock();

    freeActionTable();  // In case there was one before

    m_lNumActions = lNumActions;
    m_ActionTable = pActionTable;

    if (pcwszSTI                    &&
        pcwszControlURL             &&
        pcwszEventSubURL            &&
        pcwszId                     &&
        (lNumStateVariables > 0)    &&
        pSST                        &&
        (((lNumActions > 0) && pActionTable) ||
         ((0 == lNumActions) && (NULL == pActionTable))))
    {

        // Get rid of any previous initialization.

        if (m_pwszSTI)
        {
            MemFree(m_pwszSTI);
            m_pwszSTI = NULL;
        }

        if (m_pwszControlURL)
        {
            MemFree(m_pwszControlURL);
            m_pwszControlURL = NULL;
        }

        if (m_pControlConnect)
        {
            HrReleaseControlConnect(m_pControlConnect);
            m_pControlConnect = NULL;
        }

        if (m_pwszEventSubURL)
        {
            MemFree(m_pwszEventSubURL);
            m_pwszEventSubURL = NULL;
        }

        if (m_pwszId)
        {
            MemFree(m_pwszId);
            m_pwszId = NULL;
        }

        // Copy strings.

        m_pwszSTI = WszAllocateAndCopyWsz(pcwszSTI);

        if (m_pwszSTI)
        {
            m_pwszControlURL = WszAllocateAndCopyWsz(pcwszControlURL);

            if (m_pwszControlURL)
            {
                // we can ignore return value, since it is not essential
                HrCreateControlConnect(m_pwszControlURL, &m_pControlConnect);

                m_pwszEventSubURL = WszAllocateAndCopyWsz(pcwszEventSubURL);

                if (m_pwszEventSubURL)
                {
                    m_pwszId = WszAllocateAndCopyWsz(pcwszId);

                    if (m_pwszId)
                    {
                        hr = HrInitializeEventing();

                        if (SUCCEEDED(hr))
                        {
#ifdef DBG  // checked build only
                            DumpInitialization();
#endif // DBG
                        }
                        else
                        {
                            TraceError("CUPnPService::HrInitialize(): "
                                       "Failed to initialize eventing", hr);
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("CUPnPService::HrInitialize(): "
                                   "Error allocating / copying service Id", hr);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPService::HrInitialize(): "
                               "Error allocating / copying event sub URL", hr);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPService::HrInitialize(): "
                           "Error allocating / copying Control URL", hr);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPService::HrInitialize(): "
                       "Error allocating/copying STI string", hr);
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceError("CUPnPService::HrInitialize(): "
                   "Invalid argument passed in", hr);
    }

    Unlock();

    TraceTag(ttidUPnPService, "CUPnPService::HrInitialize(this=%x): "
             "Exit - hr == 0x%x\n", this, hr);

    TraceError("CUPnPService::HrInitialize", hr);
    return hr;
}

HRESULT CUPnPService::HrStartShutdown()
{
    TraceTag(ttidUPnPService, "CUPnPService::HrStartShutdown - Enter(this=%x)", this);
    HRESULT hr = S_OK;

    m_critSecCallback.Lock();

    // Set the shutdown flag
    m_bShutdown = TRUE;

    // Unsubscribe from the event source.  We must do this from FinalRelease()
    // instead of the destructor since the callback thread might be using
    // this, and DeregisterNotification stops it.

    if (m_hEventSub != INVALID_HANDLE_VALUE)
    {
        DeregisterNotification(m_hEventSub);
        m_dwSeqNumber = -1;
    }

    // deinit our callback object.  Note that this must happen _before_ we
    // call DeregisterNotification, to ensure that we don't fire state
    // change callbacks into the client now.
    if (m_psc)
    {
        m_psc->DeInit();

        m_psc->Release();

        m_psc = NULL;
    }

    // note: we must remove the callback from the GIT after we call
    //       DeregisterNotification

    if (m_fCallbackCookieValid)
    {
        IGlobalInterfaceTable * pGIT;

        pGIT = NULL;

        hr = HrGetGITPointer(&pGIT);
        if (SUCCEEDED(hr))
        {
            Assert(pGIT);

            while(true)
            {
                hr = pGIT->RevokeInterfaceFromGlobal(m_dwCallbackCookie);
                TraceError("CUPnPService::FinalRelease: RevokeInterfaceFromGlobal",
                           hr);
                if(HRESULT_FROM_WIN32(ERROR_BUSY) != hr)
                {
                    break;
                }
                // Pump messages because someone is trying to get an entry from the GIT
                MSG msg;
                while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }

            if (SUCCEEDED(hr))
            {
                m_fCallbackCookieValid = FALSE;
            }
            else
            {
                TraceTag(ttidUPnPService, "CUPnPService::HrStartShutdown(this=%x) - Could not remove cookie!", this);

            }

            pGIT->Release();
        }
    }

    m_critSecCallback.Unlock();

    TraceTag(ttidUPnPService, "CUPnPService::HrStartShutdown - Exit(this=%x)", this);
    TraceHr(ttidUPnPService, FAL, hr, FALSE, "CUPnPService::HrStartShutdown");
    return hr;
}


/*
 * Function:    CUPnPService::HrFireCallbacks()
 *
 * Purpose:     Invokes the callback functions that were passed to
 *              the service object via the AddCallback()
 *              method.
 *
 * Arguments:
 *  bstrStateVarName    [in]    State variable name to pass as 2nd
 *                              argument to callbacks
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
CUPnPService::HrFireCallbacks(
    IN SERVICE_CALLBACK_TYPE sct,
    IN BSTR    bstrStateVarName)
{
    HRESULT hr = S_OK;

    TraceTag(ttidUPnPService,
             "CUPnPService::HrFireCallbacks(this=%x): "
             "Firing state change callback for variable %S\n",
             this,
             bstrStateVarName);

    if (m_fCallbackCookieValid)
    {
        IGlobalInterfaceTable * pGIT;

        pGIT = NULL;

        hr = HrGetGITPointer(&pGIT);
        if (SUCCEEDED(hr))
        {
            Assert(pGIT);

            IUPnPPrivateServiceHelper2 * pupsh;

            pupsh = NULL;

            hr = pGIT->GetInterfaceFromGlobal(m_dwCallbackCookie,
                                              IID_IUPnPPrivateServiceHelper2,
                                              (void **) &pupsh);
            if (SUCCEEDED(hr))
            {
                Assert(pupsh);

                IUnknown * punkService;

                hr = pupsh->GetServiceObject(&punkService);
                if (SUCCEEDED(hr))
                {
                    Assert(punkService);

                    switch (sct)
                    {
                    case SCT_STATE_CHANGE:
                        {
                            Assert(bstrStateVarName);

                            VARIANT vaValue;

                            VariantInit(&vaValue);

                            // Get the value of the variable from the state table.

                            hr = QueryStateVariable(bstrStateVarName,
                                                    &vaValue);
                            if (SUCCEEDED(hr))
                            {
                                hr = HrInvokeStateChangeCallbacks(punkService,
                                                                  pGIT,
                                                                  bstrStateVarName,
                                                                  &vaValue);

                                TraceError("CUPnPService::HrFireCallbacks: "
                                           "HrInvokeStateChangeCallbacks", hr);

                                ClearSSTRowValue(&vaValue);
                            }
                            else
                            {
                                TraceError("CUPnPService::HrFireCallbacks: "
                                           "QueryStateVariable", hr);
                            }
                        }
                        break;

                    case SCT_DEAD:
                        {
                            hr = HrInvokeServiceDiedCallbacks(punkService,
                                                              pGIT);

                            TraceError("CUPnPService::HrFireCallbacks: "
                                       "HrInvokeServiceDiedCallbacks", hr);
                        }
                        break;

                    default:
                        AssertSz(FALSE, "Unknown callback type in HrFireCallbacks");
                        break;
                    }

                    // note: this might be the last Release() of the service
                    //       object.  Here we rely on the proxy not making
                    //       a blocking call, or we'll deadlock.
                    //
                    punkService->Release();
                }
                else
                {
                    // we're shutting down, don't fire any callbacks
                    TraceError("CUPnPService::HrFireCallbacks(): "
                               "GetServiceObject, not firing callbacks", hr);
                }

                pupsh->Release();
            }
            else
            {
                TraceError("CUPnPService::HrFireCallbacks: "
                           "GetInterfaceFromGlobal", hr);
            }

            pGIT->Release();
        }
    }
    else
    {
        TraceTag(ttidUPnPService,
                 "CUPnPService::HrFireCallbacks(): "
                 "!m_fCallbackCookieValid, not firing callbacks");
    }

    TraceTag(ttidUPnPService, "CUPnPService::HrFireCallbacks(this=%x) - Exit", this);
    TraceError("CUPnPService::HrFireCallbacks()", hr);
    return hr;
}


/*
 * Function:    CUPnPService::HrInitializeEventing()
 *
 * Purpose:     Initialize eventing for this service object. This involves
 *              setting up the list of event callback functions and
 *              subscribing to the service event source.
 *
 * Note:        This must be called by someone holding a COM reference
 *              on the object (e.g. call AddRef() before calling this).
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
CUPnPService::HrInitializeEventing()
{
    TraceTag(ttidUPnPService, "CUPnPService::HrInitializeEventing(this=%x) - Enter", this);
    HRESULT hr = S_OK;

    m_critSecCallback.Lock();

    // Create our callback object - do this even if we don't have any evented
    // variables because someone might call AddCallback() on us and we want
    // the behavior to be the same.

    if (!m_fCallbackCookieValid && !m_bShutdown)
    {
        Assert(!m_psc);

        // We haven't successfully called HrInitializeEventing before
        //

        hr = CComObject<CUPnPServiceCallback>::CreateInstance(&m_psc);
        if (SUCCEEDED(hr))
        {
            Assert(m_psc);

            IGlobalInterfaceTable * pGIT;

            pGIT = NULL;

            m_psc->AddRef();
            m_psc->Init(this);

            hr = HrGetGITPointer(&pGIT);
            if (SUCCEEDED(hr))
            {
                Assert(pGIT);

                IUPnPPrivateServiceHelper2 * pshCallback;

                pshCallback = dynamic_cast<IUPnPPrivateServiceHelper2 *>(m_psc);
                Assert(pshCallback);

                hr = pGIT->RegisterInterfaceInGlobal(pshCallback,
                                                     IID_IUPnPPrivateServiceHelper2,
                                                     &m_dwCallbackCookie);
                if (SUCCEEDED(hr))
                {
                    TraceTag(ttidUPnPService, "CUPnPService::HrInitializeEventing(this=%x) "
                             "Registered callback in GIT.", this);
                    m_fCallbackCookieValid = TRUE;
                }
                else
                {
                    TraceError("CUPnPService::HrInitializeEventing(): "
                               "Could not register callback in the GIT", hr);
                }

                // note: we never AddRef()'d pshCallback, so don't release
                // it here

                pGIT->Release();
            }
            else
            {
                TraceError("CUPnPService::HrInitializeEventing(): "
                           "Could not create Global Interface Table", hr);
            }
        }
        else
        {
            TraceError("CUPnPService::HrInitializeEventing(): "
                       "Could not create callback object", hr);
        }
    }

    Assert(FImplies(SUCCEEDED(hr) && !m_bShutdown, m_fCallbackCookieValid));
    Assert(FImplies(FAILED(hr), !m_fCallbackCookieValid));

    // Subscribe to the event source only if we have evented variables.

    if (FHaveEventedVariables() && !m_bShutdown)
    {
        TraceTag(ttidUPnPService,
                 "HrInitializeEventing(this=%x): "
                 "Have some evented variables - will initialize eventing\n", this);

        if (SUCCEEDED(hr))
        {
            LPSTR   pszEventSubURL = NULL;

            pszEventSubURL = SzFromWsz(m_pwszEventSubURL);
            if (pszEventSubURL)
            {
                // Initialize our subscriber ID member.
                if (m_pwszSubsID)
                {
                    MemFree(m_pwszSubsID);
                    m_pwszSubsID = NULL;
                }
                // Unsubscribe, if we are already subscribed.
                if (m_hEventSub != INVALID_HANDLE_VALUE)
                {
                    DeregisterNotification(m_hEventSub);
                    m_dwSeqNumber = -1;
                }
                // Subscribe to the event source.

                Assert(m_psc);
                m_hEventSub = RegisterNotification(NOTIFY_PROP_CHANGE,
                                                   NULL,
                                                   pszEventSubURL,
                                                   CUPnPService::EventNotifyCallback,
                                                   (void *) this);

                if (INVALID_HANDLE_VALUE == m_hEventSub)
                {
                    TraceTag(ttidUPnPService, "CUPnPService::HrInitializeEventing(this=%x) - RegisterNotification failed", this);
                    Unlock();

                    // call this since we might be on the callback thread
                    hr = HrFireCallbacks(SCT_DEAD, NULL);

                    Lock();

                    if (FAILED(hr))
                    {
                        TraceError("CUPnPService::HrInitializeEventing(): "
                                   "Failed to fire service died callbacks",
                                   hr);
                    }
                    hr = UPNP_E_EVENT_SUBSCRIPTION_FAILED;
                    TraceError("CUPnPService::HrInitializeEventing(): "
                               "Failed to subscribe to event source", hr);
                }

                delete [] pszEventSubURL;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPService::HrInitializeEventing(): "
                           "Failed to convert event sub url to ansi", hr);
            }
        }
    }
    else
    {
        TraceTag(ttidUPnPService,
                 "HrInitializeEventing(): "
                 "Have no evented variables - won't initialize eventing\n");
    }

    TraceError("CUPnPService::HrInitializeEventing", hr);

    m_critSecCallback.Unlock();

    TraceTag(ttidUPnPService, "CUPnPService::HrInitializeEventing(this=%x) - Exit", this);
    return hr;
}


/*
 * Function:    CUPnPService::freeStateTable()
 *
 * Purpose:     Frees any memory used by the service state table.
 *
 */

VOID
CUPnPService::freeStateTable()
{
    if (m_StateTable)
    {
        for (LONG i = 0; i < m_lNumStateVariables; i++)
        {
            if (m_StateTable[i].pwszVarName)
            {
                MemFree(m_StateTable[i].pwszVarName);
                m_StateTable[i].pwszVarName = NULL;
            }

            ClearSSTRowValue(&(m_StateTable[i].value));
        }

        MemFree(m_StateTable);
        m_StateTable = NULL;
    }

    m_lNumStateVariables = 0;
}


/*
 * Function:    CUPnPService::freeActionTable()
 *
 * Purpose:     Frees any memory used by the service action table.
 *
 */

VOID
CUPnPService::freeActionTable()
{
    if (m_ActionTable)
    {
        for (LONG i = 0; i < m_lNumActions; i++)
        {
            SERVICE_ACTION  * pAct = &m_ActionTable[i];

            if (pAct->pwszName)
            {
                MemFree(pAct->pwszName);
                pAct->pwszName = NULL;
            }

            if (pAct->pInArguments)
            {
                for (LONG j = 0; j < pAct->lNumInArguments; j++)
                {
                    SERVICE_ACTION_ARGUMENT * pArg =
                        &((pAct->pInArguments)[j]);

                    if (pArg->pwszName) {
                        MemFree(pArg->pwszName);
                        pArg->pwszName = NULL;
                    }
                }
                MemFree(pAct->pInArguments);
                pAct->pInArguments = NULL;
            }

            pAct->lNumInArguments = 0;

            if (pAct->pOutArguments)
            {
                for (LONG j = 0; j < pAct->lNumOutArguments; j++)
                {
                    SERVICE_ACTION_ARGUMENT * pArg =
                        &((pAct->pOutArguments)[j]);

                    if (pArg->pwszName) {
                        MemFree(pArg->pwszName);
                        pArg->pwszName = NULL;
                    }
                }
                MemFree(pAct->pOutArguments);
                pAct->pOutArguments = NULL;
            }

            pAct->lNumOutArguments = 0;

            pAct->pReturnValue = NULL;
        }

        MemFree(m_ActionTable);
        m_ActionTable = NULL;
    }

    m_lNumActions = 0;
}


/*
 * Function:    CUPnPService::DumpInitialization()
 *
 * Purpose:     Dumps the internal configuration of the service object,
 *              including the STI, the names of the state variables, the
 *              HTTP verb, and the control URL.
 *
 * Notes:       This function only exists in the checked build.
 */

#ifdef DBG  // checked build only
VOID
CUPnPService::DumpInitialization()
{
    TraceTag(ttidUPnPService, "Service object at 0x%x:\n", this);
    //$ NYI SPather
    // Dump the rest of the internal configuration.
}
#endif // DBG


/*
 * Function:    CUPnPService::HrValidateAction()
 *
 * Purpose:     Validates an action invocation request by checking that the
 *              action name and arguments match what the service supports.
 *
 * Arguments:
 *  pcwszActionName    [in]    Name of the action
 *  psaActionArgs      [in]    Pointer to SAFEARRAY containing action arguments
 *  ppAction           [out]   Returns a pointer to the action table structure
 *                             describing the action.
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  $ NYI SPather - Not done yet.
 *  All this really does now is ensure that the method name is
 *  known and that the number of arguments are correct.
 */

HRESULT
CUPnPService::HrValidateAction(
    IN  LPCWSTR         pcwszActionName,
    IN  SAFEARRAY       * psaActionArgs,
    OUT SERVICE_ACTION  ** ppAction)
{
    HRESULT         hr = S_OK;
    SERVICE_ACTION  * pAction = NULL;

    if (ppAction)
    {
        *ppAction = NULL;
    }

    // First, find the action.

    TraceTag(ttidUPnPService, "HrValidateAction: ACTION\t%S\n",
             pcwszActionName);

    for (LONG i = 0; i < m_lNumActions; i++)
    {
        if (_wcsicmp(pcwszActionName,
                     m_ActionTable[i].pwszName) == 0)
        {
            pAction = &m_ActionTable[i];

            if (ppAction)
            {
                *ppAction = pAction;    // Return the action structure
            }

            break;
        }
    }

    if (pAction)
    {
        LONG    lUBound, lLBound, cArgs;

        // We found the action in our action table. Now validate the args.

        do
        {
            hr = SafeArrayGetUBound(psaActionArgs,
                                    1,
                                    &lUBound);

            if (FAILED(hr)) {
                TraceError("CUPnPService::HrValidateAction(): "
                           "Failed to get upper bound on args array",
                           hr);
                break;
            }

            hr = SafeArrayGetLBound(psaActionArgs,
                                    1,
                                    &lLBound);

            if (FAILED(hr)) {
                TraceError("CUPnPService::HrValidateAction(): "
                           "Failed to get lower bound on args array",
                           hr);
                break;
            }
        } while (FALSE);

        if (SUCCEEDED(hr))
        {
            VARIANT HUGEP   * aryVarArgs = NULL;
            long            rgIndices[1];
            VARIANT         varLastElement;

            cArgs = (lUBound - lLBound)+1;

            if (cArgs > 0)
            {
                // Have to work around a SafeArray problem here. There is no
                // way to create an empty SafeArray. VBScript and other apps
                // simply pass in a SafeArray with one VT_EMPTY variant element.
                // Here we need to check for this and decrement cArgs if necessary.

                rgIndices[0] = lUBound;

                hr = SafeArrayGetElement(psaActionArgs,
                                         rgIndices,
                                         &varLastElement);

                if (SUCCEEDED(hr))
                {
                    if (varLastElement.vt == VT_EMPTY)
                    {
                        cArgs--;
                    }
                    VariantClear(&varLastElement);
                }
                else
                {
                    TraceError("CUPnPService::HrValidateAction(): "
                               "Could not get last element from argument safe array",
                               hr);
                }
            }

            if ((SUCCEEDED(hr)) && (cArgs == pAction->lNumInArguments))
            {
                // We don't check the data type of each argument any more
                // since we don't really know how.  Instead, we'll fail in
                // HrBuildAndSetArguments when we try and add the data to
                // the request.
                //
            }
            else
            {
                hr = UPNP_E_INVALID_ARGUMENTS;
                TraceError("CUPnPService::HrValidateAction(): "
                           "Invalid number of arguments",
                           hr);
            }
        }
    }
    else
    {
        // Could not find the action in our action table. Must be invalid.

        hr = UPNP_E_INVALID_ACTION;
        TraceError("CUPnPService::HrValidateAction(): "
                   "Could not find action name in action table",
                   hr);
    }

    return hr;
}


/*
 * Function:    CUPnPService::FHaveEventedVariables())
 *
 * Purpose:     Determines whether or not this service contains
 *              any state variables that are evented.
 *
 * Arguments:
 *  (none)
 *
 * Return Value:
 *  TRUE if there are 1 or more evented variables, FALSE otherwise.
 *
 * Notes:
 *  (none)
 */

BOOL
CUPnPService::FHaveEventedVariables()
{
    BOOL fRet = FALSE;

    // Walk through the state table, looking for an evented variable.

    for (LONG i = 0; i < m_lNumStateVariables; i++)
    {
        if (FALSE == m_StateTable[i].bDoRemoteQuery)
        {
            // We do not do remote query for this variable, therefore
            // it must be evented.

            fRet = TRUE;
            break;
        }
    }

    return fRet;
}


BSTR
CUPnPService::BSTRStripNameSpaceFromFQName(
                                           IN   BSTR bstrFullyQualifiedName
                                           )
{
    BSTR    bstrRetVal = NULL;
    UINT    uiLength;
    BOOL    bFoundColon = FALSE;

    uiLength = SysStringLen(bstrFullyQualifiedName);

    // Go through the input string, find the first colon, and return the
    // string from that character on.

    for (UINT i = 0; i < uiLength; i++)
    {
        if (L':' == bstrFullyQualifiedName[i])
        {
            bFoundColon = TRUE;

            if ((uiLength - 1) == i)    // BSTR may not be NULL terminated
            {
                bstrRetVal = SysAllocString(L"");
            }
            else
            {
                bstrRetVal = SysAllocString(&bstrFullyQualifiedName[i+1]);
            }
            break;
        }
    }

    // If we didn't find a ":", then return a copy of the string we were
    // passed in.
    if (FALSE == bFoundColon)
    {
        bstrRetVal = SysAllocString(bstrFullyQualifiedName);
    }

    return bstrRetVal;
}


HRESULT
CUPnPService::ParsePropertyNode(
    IN IXMLDOMNode * pxdnPropNode)
{
    TraceTag(ttidUPnPService, "CUPnPService::ParsePropertyNode(this=%x) - Enter", this);
    HRESULT hr;
    BSTR    bstrNodeName = NULL;

    hr = pxdnPropNode->get_nodeName(&bstrNodeName);

    if (SUCCEEDED(hr))
    {
        BSTR    bstrVarName = NULL;

        bstrVarName = BSTRStripNameSpaceFromFQName(bstrNodeName);

        if (bstrVarName)
        {
            TraceTag(ttidUPnPService,
                     "Event contained value for %S\n",
                     bstrVarName);

            SERVICE_STATE_TABLE_ROW * pSSTRow;

            pSSTRow = NULL;

            m_StateTableCS.Lock();

            for (LONG i = 0; i < m_lNumStateVariables; i++)
            {
                if (_wcsicmp(bstrVarName, m_StateTable[i].pwszVarName) == 0)
                {
                    pSSTRow = &m_StateTable[i];
                    break;
                }
            }

            if (NULL != pSSTRow)
            {
                hr = HrUpdateStateVariable(pSSTRow, pxdnPropNode);
                TraceHr(ttidError, FAL, hr, FALSE, "CUPnPService::ParsePropertyNode(): HrUpdateStateVariable failed");
            }
            else
            {
                hr = E_INVALIDARG;
                TraceError("CUPnPService::ParsePropertyNode(): "
                           "Could not find state variable in table", hr);
            }

            m_StateTableCS.Unlock();

            if (FAILED(hr))
            {
                TraceError("CUPnPService::ParsePropertyNode(): "
                           "Failed to update state variable", hr);
            }

            SysFreeString(bstrVarName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPService::ParsePropertyNode(): "
                       "Failed to strip namespace from node name", hr);
        }

        SysFreeString(bstrNodeName);
        bstrNodeName = NULL;

    }
    else
    {
        TraceError("CUPnPService::ParsePropertyNode(): "
                   "Failed to get node name", hr);
    }

    TraceTag(ttidUPnPService, "CUPnPService::ParsePropertyNode(this=%x) - Exit", this);
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPService::ParsePropertyNode");
    return hr;
}


HRESULT
CUPnPService::HrParseEventAndUpdateStateTable(
    IN  IXMLDOMDocument * pEventBody)
{
    TraceTag(ttidUPnPService, "CUPnPService::HrParseEventAndUpdateStateTable(this=%x) - Enter", this);
    HRESULT hr = S_OK;
    IXMLDOMElement * pxdeRoot = NULL;

    // Get the document's root element (the <propertyset> element.

    hr = pEventBody->get_documentElement(&pxdeRoot);

    if (S_OK == hr)
    {
        IXMLDOMNode * pChild = NULL;
        IXMLDOMNode * pNext = NULL;

        Assert(pxdeRoot);

        // Get the first <property> element.

        hr = pxdeRoot->get_firstChild(&pChild);

        while (pChild)
        {
            IXMLDOMNode * pPropNode = NULL;

            // Get the child element of the <property> element. The
            // name of this element will be the name of the variable
            // being updated.

            hr = pChild->get_firstChild(&pPropNode);

            if (SUCCEEDED(hr))
            {
                if (pPropNode)
                {
                    hr = ParsePropertyNode(pPropNode);

                    if (FAILED(hr))
                    {
                        TraceError("CUPnPService::"
                                   "HrParseEventAndUpdateStateTable(): "
                                   "Failed to parse property node",
                                   hr);
                    }

                    pPropNode->Release();
                }
                else
                {
                    TraceError("CUPnPService::"
                               "HrParseEventAndUpdateStateTable(): "
                               "<property> element was empty, "
                               "moving on...", hr);
                }
            }
            else
            {
                TraceError("CUPnPService::HrParseEventAndUpdateStateTable(): "
                           "Failed to get property node", hr);
            }

            if (FAILED(hr))
            {
                pChild->Release();
                break;
            }

            hr = pChild->get_nextSibling(&pNext);
            pChild->Release();
            pChild = pNext;
        }

        // Last time through this loop would have return S_FALSE. Set
        // return value to S_OK.

        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }

        pxdeRoot->Release();
    }
    else
    {
        TraceError("CUPnPService::HrParseEventAndUpdateStateTable(): "
                   "Failed to get document element", hr);
    }

    TraceError("CUPnPService::HrParseEventAndUpdateStateTable(): "
               "Exiting",
               hr);

    TraceTag(ttidUPnPService, "CUPnPService::HrParseEventAndUpdateStateTable(this=%x) - Exit", this);
    return hr;
}


HRESULT
CUPnPService::HrParseEventAndInvokeCallbacks(
    IN IXMLDOMDocument * pEventBody)
{
    TraceTag(ttidUPnPService, "CUPnPService::HrParseEventAndInvokeCallbacks(this=%x) - Enter", this);
    HRESULT hr = S_OK;
    IXMLDOMElement * pxdeRoot = NULL;

    // Get the document's root node (<propertyset>).

    hr = pEventBody->get_documentElement(&pxdeRoot);

    if (S_OK == hr)
    {
        IXMLDOMNode * pChild = NULL;
        IXMLDOMNode * pNext = NULL;

        Assert(pxdeRoot);

        // Get the first <property> element.

        hr = pxdeRoot->get_firstChild(&pChild);

        while (pChild)
        {
            IXMLDOMNode * pPropNode = NULL;

            // Get the child element of the <property> element. The
            // name of this element will be the name of the variable
            // being updated.

            hr = pChild->get_firstChild(&pPropNode);

            if (SUCCEEDED(hr))
            {
                if (pPropNode)
                {
                    BSTR    bstrNodeName = NULL;

                    hr = pPropNode->get_nodeName(&bstrNodeName);

                    if (SUCCEEDED(hr))
                    {
                        BSTR    bstrVarName = NULL;

                        bstrVarName = BSTRStripNameSpaceFromFQName(bstrNodeName);

                        if (bstrVarName)
                        {
                            hr = HrFireCallbacks(SCT_STATE_CHANGE, bstrVarName);
                            if (FAILED(hr))
                            {
                                TraceError("CUPnPService::HrParseEventAndInvokeCallbacks(): "
                                           "Failed to fire state change callbacks",
                                           hr);
                            }

                            SysFreeString(bstrVarName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("CUPnPService::HrParseEventAndInvokeCallbacks(): "
                                       "Failed to strip namespace from node name", hr);
                        }

                        SysFreeString(bstrNodeName);
                        bstrNodeName = NULL;

                    }
                    else
                    {
                        TraceError("CUPnPService::HrParseEventAndInvokeCallbacks(): "
                                   "Failed to get node name", hr);

                    }

                    pPropNode->Release();
                }
                else
                {
                    TraceError("CUPnPService::"
                               "HrParseEventAndInvokeCallbacks(): "
                               "<property> element was empty, "
                               "moving on...", hr);
                }
            }
            else
            {
                TraceError("CUPnPService::HrParseEventAndInvokeCallbacks(): "
                           "Failed to get property node", hr);
            }


            if (FAILED(hr))
            {
                pChild->Release();
                break;
            }

            hr = pChild->get_nextSibling(&pNext);
            pChild->Release();
            pChild = pNext;
        }

        // Last time through this loop would have return S_FALSE. Set
        // return value to S_OK.

        if (SUCCEEDED(hr))
        {
            hr = S_OK;
        }

        pxdeRoot->Release();
    }
    else
    {
        TraceError("CUPnPService::HrParseEventAndInvokeCallbacks(): "
                   "Failed to get root element", hr);
    }

    TraceError("CUPnPService::HrParseEventAndInvokeCallbacks(): "
               "Exiting",
               hr);

    TraceTag(ttidUPnPService, "CUPnPService::HrParseEventAndInvokeCallbacks(this=%x) - Exit", this);
    return hr;
}


// Called from callback routine
HRESULT
CUPnPService::HrHandleEvent(CONST SSDP_MESSAGE * pssdpMsg)
{
    TraceTag(ttidUPnPService, "CUPnPService::HrHandleEvent(this=%x) - Enter", this);
    HRESULT hr;
    LPWSTR  pwszXMLBody = NULL;

    TraceTag(ttidUPnPService, "Received event notification\n");

    // Store the subscriber ID if we don't already have it.
    if (NULL == m_pwszSubsID)
    {
        m_pwszSubsID = WszFromSz(pssdpMsg->szSid);

        // Deliberately not checking for NULL here. If this is NULL (mem
        // allocation failure), then we'll just continue on as if we never
        // got a subscriber ID and try again the next time we get an event
        // notification.
    }

    // Convert the XML contained in the SSDP message into a BSTR,
    // then create an XML DOM Document object from it.

    pwszXMLBody = WszFromUtf8(pssdpMsg->szContent);

    if (pwszXMLBody)
    {
        BSTR bstrXMLBody = NULL;

        bstrXMLBody = SysAllocString(pwszXMLBody);

        if (bstrXMLBody)
        {
            IXMLDOMDocument * pXMLDoc = NULL;

            hr = CoCreateInstance(CLSID_DOMDocument30,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IXMLDOMDocument,
                                  (void **) &pXMLDoc);

            if (SUCCEEDED(hr))
            {
                hr = pXMLDoc->put_async(VARIANT_FALSE);

                if (SUCCEEDED(hr))
                {
                    VARIANT_BOOL vbSuccess;

                    pXMLDoc->put_resolveExternals(VARIANT_FALSE);
                    hr = pXMLDoc->loadXML(bstrXMLBody, &vbSuccess);

                    if (SUCCEEDED(hr) && vbSuccess)
                    {
                        hr = HrParseEventAndUpdateStateTable(pXMLDoc);

                        if (SUCCEEDED(hr))
                        {
                            // We successfully updated the state table after
                            // parsing the event, so now we can update the
                            // sequence number.

                            m_dwSeqNumber = pssdpMsg->iSeq;

                            // Invoke callbacks.

                            hr = HrParseEventAndInvokeCallbacks(pXMLDoc);

                            if (FAILED(hr))
                            {
                                TraceError("CUPnPService::HrHandleEvent(): "
                                           "Failed to parse event and invoke "
                                           "callbacks",
                                           hr);
                            }


                        }
                        else
                        {
                            TraceError("CUPnPService::HrHandleEvent(): "
                                       "Failed to parse event and update "
                                       "state table",
                                       hr);
                        }
                    }
                    else
                    {
                        Assert((S_FALSE == hr) || FAILED(hr));

                        if (S_FALSE == hr)
                        {
                            hr = E_FAIL;
                        }

                        TraceError("CUPnPService::HrHandleEvent(): "
                                   "Failed to load XML into document "
                                   "object",
                                   hr);
                    }
                }
                else
                {
                    TraceError("CUPnPService::HrHandleEvent(): "
                               "Failed to set async property to false",
                               hr);
                }

                pXMLDoc->Release();
            }
            else
            {
                TraceError("CUPnPService::HrHandleEvent(): "
                           "Failed to create XML DOM Document object",
                           hr);
            }

            SysFreeString(bstrXMLBody);
            bstrXMLBody = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CUPnPService::HrHandleEvent(): "
                       "Failed to convert event message body to "
                       "BSTR", hr);

        }

        delete [] pwszXMLBody;
        pwszXMLBody = NULL;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("CUPnPService::HrHandleEvent(): "
                   "Failed to convert event message body to unicode",
                   hr);
    }

    TraceTag(ttidUPnPService, "CUPnPService::HrHandleEvent(this=%x) - Exit", this);
    TraceError("CUPnPService::HrHandleEvent", hr);
    return hr;
}


void
CUPnPService::EventNotifyCallback(SSDP_CALLBACK_TYPE  ssdpType,
                                  CONST SSDP_MESSAGE  *pssdpMsg,
                                  LPVOID              pContext)
{
    TraceTag(ttidUPnPService, "CUPnPService::EventNotifyCallback(pSvcObject=%x): enter", pContext);

    HRESULT         hr = S_OK;

    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        CUPnPService    *pSvcObject = (CUPnPService *)pContext;
        hr = CServiceLifetimeManager::Instance().AddRefService(pSvcObject);
        if(SUCCEEDED(hr))
        {
            Assert(pSvcObject);

            if ((SSDP_EVENT == ssdpType) && pssdpMsg->szContent)
            {
                TraceTag(ttidUPnPService, "CUPnPService::EventNotifyCallback(pSvcObject=%x, SeqNumber=%d): "
                         "Received event notification", pContext, pssdpMsg->iSeq);

                // Check the sequence number. If it's about to overflow (the
                // next number is -1) or the sequence number on the event notification
                // is not 1 greater than our current sequence number (i.e. the event is
                // out of sequence) then we need to unsubscribe
                // from and then resubscribe to the event source in order to get back
                // in sync.

                if ((-1 == (pSvcObject->m_dwSeqNumber + 1)) ||  // overflow
                    (pssdpMsg->iSeq != (pSvcObject->m_dwSeqNumber + 1)))    // out of seq
                {
                    // Can't unsubscribe / resubscribe from the callback function,
                    // so schedule a worker thread to do it for us.

                    HANDLE  hWorkerThread = NULL;
                    DWORD   dwId;

                    // Bump ref count up and hand to thread
                    hr = CServiceLifetimeManager::Instance().AddRefService(pSvcObject);
                    if(SUCCEEDED(hr))
                    {
                        TraceTag(ttidUPnPService, "CUPnPService::EventNotifyCallback - Spawning event worker thread.");
                        hWorkerThread = CreateThread(NULL,
                                                     0,
                                                     EventingWorkerThreadProc,
                                                     (LPVOID) pSvcObject,
                                                     0,
                                                     &dwId);
                        if(!hWorkerThread)
                        {
                            // Drop added ref count if we didn't really create a thread
                            CServiceLifetimeManager::Instance().DerefService(pSvcObject);
                        }
                    }

                    if (NULL == hWorkerThread)
                    {
                        hr = HrFromLastWin32Error();
                        TraceError("CUPnPService::EventNotifyCallback(): "
                                   "Failed to create worker thread",
                                   hr);
                    }
                    else
                    {
                        CloseHandle(hWorkerThread);
                    }
                }
                else
                {
                    TraceTag(ttidUPnPService, "CUPnPService::EventNotifyCallback - Calling HrHandleEvent(pSvcObject=%x).", pSvcObject);
                    hr = pSvcObject->HrHandleEvent(pssdpMsg);
                }
            }
            else if ((SSDP_DEAD == ssdpType))
            {
                TraceTag(ttidUPnPService, "CUPnPService::EventNotifyCallback(pSvcObject=%x): ",
                         "Received SSDP_DEAD notification", pSvcObject);

                hr = pSvcObject->HrFireCallbacks(SCT_DEAD, NULL);
            }
            else
            {
                TraceTag(ttidUPnPService,
                         "CUPnPService::EventNotifyCallback(): "
                         "Received unknown SSDP Type -- %d\n",
                         ssdpType);
            }

            hr = CServiceLifetimeManager::Instance().DerefService(pSvcObject);
        }

        CoUninitialize();
    }
    else
    {
        TraceError("CUPnPService::EventNotifyCallback(): "
                   "Failed to CoInitialize on callback thread", hr);
    }

    TraceTag(ttidUPnPService, "CUPnPService::EventNotifyCallback(pSvcObject=%x): exit", pContext);
}


/*
 * Function:    CUPnPService::EventingWorkerThreadProc()
 *
 * Purpose:     This function is executed by a worker thread to re-initiailize
 *              eventing on the service object.
 *
 * Arguments:
 *  lpParameter     [in]    A pointer to the service object.
 *
 * Return Value:
 *  0 if successful, -1 otherwise.
 *
 * Notes:
 *  (none)
 */

DWORD
CUPnPService::EventingWorkerThreadProc(
    LPVOID    lpParameter)
{
    TraceTag(ttidUPnPService, "CUPnPService::EventingWorkerThreadProc(%x) - Enter", lpParameter);
    HRESULT hr = S_OK;
    DWORD   dwRet = 0;

    CUPnPService    * pSvcObject = (CUPnPService *) lpParameter;

    TraceTag(ttidUPnPService,
             "CUPnPService::EventingWorkerThreadProc(): "
             "Entering worker thread routine");

    Assert(pSvcObject);

    pSvcObject->Lock(); // HrInitializeEventing assumes that the object is locked

    hr = pSvcObject->HrInitializeEventing();

    pSvcObject->Unlock();

    if (FAILED(hr))
    {
        TraceError("CUPnPService::EventingWorkerThreadProc(): "
                   "Failed to reinitialize eventing",
                   hr);
        dwRet = -1;
    }

    // Drop reference count passed to this function
    CServiceLifetimeManager::Instance().DerefService(pSvcObject);

    TraceTag(ttidUPnPService,
             "CUPnPService::EventingWorkerThreadProc(): "
             "Exiting worker thread routine -- returning %d", dwRet);

    TraceTag(ttidUPnPService, "CUPnPService::EventingWorkerThreadProc(%x) - Exit", lpParameter);
    return dwRet;
}


// must not be called with service object lock held
//

HRESULT
HrInvokeDispatchCallback(IDispatch * pdispCallback,
                         LPCWSTR pszCallbackType,
                         IDispatch * pdispThis,
                         LPCWSTR pszStateVarName,
                         VARIANT * lpvarValue)
{
    Assert(pdispCallback);
    Assert(pszCallbackType);
    Assert(pdispThis);
    // pszStateVarName and lpvarValue are optional, but must be
    // supplied together
    Assert(FIff(pszStateVarName, lpvarValue));

    HRESULT hr;
    VARIANT     ary_vaArgs[4];

    hr = S_OK;

    ::VariantInit(&ary_vaArgs[0]);
    ::VariantInit(&ary_vaArgs[1]);
    ::VariantInit(&ary_vaArgs[2]);
    ::VariantInit(&ary_vaArgs[3]);

    // Fourth argument is the value.
    if (lpvarValue)
    {
        hr = VariantCopy(&ary_vaArgs[0], lpvarValue);
        if (FAILED(hr))
        {
            ::VariantInit(&ary_vaArgs[0]);

            TraceError("HrInvokeDispatchCallback(): VariantCopy", hr);
            goto Cleanup;
        }
    }

    // Third argument is the state variable name.
    // Copy this in case our caller parties on it.

    if (pszStateVarName)
    {
        BSTR bstrVarName;

        bstrVarName = ::SysAllocString(pszStateVarName);
        if (!bstrVarName)
        {
            hr = E_OUTOFMEMORY;

            TraceError("HrInvokeDispatchCallback(): SysAllocString - "
                       "pszStateVarName", hr);
            goto Cleanup;
        }

        V_VT(&ary_vaArgs[1]) = VT_BSTR;
        V_BSTR(&ary_vaArgs[1]) = bstrVarName;
    }

    // Second argument is the pointer to the service object.
    pdispThis->AddRef();

    V_VT(&ary_vaArgs[2]) = VT_DISPATCH;
    V_DISPATCH(&ary_vaArgs[2]) = pdispThis;

    // First argument is the string defining the type
    // of callback.
    {
        BSTR bstrCallbackType;

        bstrCallbackType = ::SysAllocString(pszCallbackType);
        if (!bstrCallbackType)
        {
            hr = E_OUTOFMEMORY;

            TraceError("HrInvokeDispatchCallback(): SysAllocString - "
                       "pszCallbackType", hr);
            goto Cleanup;
        }

        V_VT(&ary_vaArgs[3]) = VT_BSTR;
        V_BSTR(&ary_vaArgs[3]) = bstrCallbackType;
    }

    {
        VARIANT     vaResult;
        DISPPARAMS  dispParams = {ary_vaArgs, NULL, 4, 0};

        VariantInit(&vaResult);

        TraceTag(ttidUPnPService,
                 "HrInvokeDispatchCallback(): firing user callback");

        hr = pdispCallback->Invoke(0,
                                   IID_NULL,
                                   LOCALE_USER_DEFAULT,
                                   DISPATCH_METHOD,
                                   &dispParams,
                                   &vaResult,
                                   NULL,
                                   NULL);

        TraceTag(ttidUPnPService,
                 "HrInvokeDispatchCallback(): user callback returned");

        if (VT_ERROR == vaResult.vt)
        {
            TraceError("HrInvokeDispatchCallback(): "
                       "Callback returned this SCODE: ",
                       vaResult.scode);
        }

        if (FAILED(hr))
        {
            TraceError("HrInvokeDispatchCallback(): "
                       "Failed to invoke callback function",
                       hr);
        }
    }

    if ((VT_ARRAY | VT_UI1) == V_VT(&ary_vaArgs[0]))
    {
        SafeArrayDestroy(V_ARRAY(&ary_vaArgs[0]));
    }
    else
    {
        ::VariantClear(&ary_vaArgs[0]);
    }
    ::VariantClear(&ary_vaArgs[1]);
    ::VariantClear(&ary_vaArgs[2]);
    ::VariantClear(&ary_vaArgs[3]);

Cleanup:
    TraceError("HrInvokeDispatchCallback()", hr);
    return hr;
}


/*
 * Function:    CUPnPService::HrInvokeServiceDiedCallbacks()
 *
 * Purpose:     Fires all of the registered callbacks to notifify them
 *              that a service instance is dead (we either received an
 *              SSDP_DEAD message or RegisterNotification() failed).
 *
 * Arguments:
 *  punkService     [in]    A marshalled pointer to the service object
 *                          in its main apartment.
 *
 * Notes:
 *  This will be called from and execute on the SSDP Notify callback thread.
 *
 * Returns:
 *  S_OK if successful
 *  E_OUTOFMEMORY / OLE error otherwise
 */

HRESULT
CUPnPService::HrInvokeServiceDiedCallbacks(IUnknown * punkService,
                                           IGlobalInterfaceTable * pGIT)
{
    TraceTag(ttidUPnPService, "CUPnPService::HrInvokeServiceDiedCallbacks(this=%x) - Enter", this);
    Assert(punkService);
    Assert(pGIT);

    HRESULT hr;
    DWORD i;

    Lock();

    i = 0;
    for ( ; i < m_dwNumCallbacks; ++i)
    {
        Assert(m_arydwCallbackCookies);

        IUnknown * punkCallback;
        DWORD dwCookie;

        punkCallback = NULL;
        dwCookie = m_arydwCallbackCookies[i];

        hr = pGIT->GetInterfaceFromGlobal(dwCookie,
                                          IID_IUnknown,
                                          (LPVOID*)&punkCallback);
        if (SUCCEEDED(hr))
        {
            Assert(punkCallback);

            // See if the callback supports IDispatch or our custom interface
            //
            // NOTE: if we ever support additional callback interfaces,
            //       remember to update the code in HrAddCallback as well
            //

            IUPnPServiceCallback    * pusc = NULL;

            hr = punkCallback->QueryInterface(IID_IUPnPServiceCallback,
                                              (void **) &pusc);

            if (SUCCEEDED(hr) && pusc)
            {
                TraceTag(ttidUPnPService,
                         "CUPnPService::HrInvokeServiceDiedCallbacks(): "
                         "Firing callback off IUPnPServiceCallback "
                         "interface\n");

                // Get an IUPnPService interface on the service object.
                IUPnPService    * pus = NULL;

                hr = punkService->QueryInterface(IID_IUPnPService,
                                                 (void **) &pus);

                if (SUCCEEDED(hr) && pus)
                {
                    Unlock();

                    hr = pusc->ServiceInstanceDied(pus);

                    Lock();

                    TraceError("CUPnPService::"
                               "HrInvokeServiceDiedCallbacks(): "
                               "ServiceInstanceDied() on callback"
                               "interface returned failure",
                               hr);

                    pus->Release();
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }

                    TraceError("CUPnPService::"
                               "HrInvokeServiceDiedCallbacks(): "
                               "Failed to get IUPnPService interface "
                               "on service object",
                               hr);
                }

                pusc->Release();
            }
            else if (E_NOINTERFACE == hr)
            {
                IDispatch * pdispCallback = NULL;

                hr = punkCallback->QueryInterface(IID_IDispatch,
                                                  (LPVOID*)&pdispCallback);

                if (SUCCEEDED(hr) && pdispCallback)
                {
                    // Only IDispatch is supported.

                    // Get an IDispatch interface on the service object.
                    IDispatch    * pdispService = NULL;

                    hr = punkService->QueryInterface(IID_IDispatch,
                                                     (void **) &pdispService);
                    if (SUCCEEDED(hr))
                    {
                        Assert(pdispService);

                        TraceTag(ttidUPnPService,
                                 "CUPnPService::HrInvokeServiceDiedCallbacks(): "
                                 "Firing callback off IDispatch "
                                 "interface\n");

                        hr = HrInvokeDispatchCallback(pdispCallback,
                                                      L"SERVICE_INSTANCE_DIED",
                                                      pdispService,
                                                      NULL,
                                                      NULL);

                        pdispService->Release();
                    }
                    else
                    {
                        TraceError("CUPnPService::"
                                "HrInvokeServiceDiedCallbacks: "
                                "couldn't get service object's IDispatch",
                                hr)
                    }

                    pdispCallback->Release();
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }
                    TraceError("CUPnPService::HrInvokeServiceDiedCallbacks: "
                               "callback doesn't support any supported interfaces!", hr)
                }
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                TraceError("CUPnPService::HrInvokeServiceDiedCallbacks(): "
                           "Failed to get an interface on callback object",
                           hr);
            }

            punkCallback->Release();
        }
        else
        {
            TraceError("CUPnPService::HrInvokeServiceDiedCallbacks(): "
                       "GetInterfaceFromGlobal", hr);
        }
    }

    Unlock();

    TraceTag(ttidUPnPService, "CUPnPService::HrInvokeServiceDiedCallbacks(this=%x) - Exit", this);
    TraceError("CUPnPService::HrInvokeServiceDiedCallbacks", hr);
    return hr;
}


/*
 * Function:    CUPnPService::HrInvokeStateChangeCallbacks()
 *
 * Purpose:     Fires all of the registered callbacks to notifify them
 *              of a particular state update event.
 *
 * Arguments:
 *  punkService     [in]    A marshalled pointer to the service object
 *                          in its main apartment.
 *  pszStateVarName [in]    Name of updated variable
 *  lpvarValue      [in]    New value of pszStateVarName
 *
 * Notes:
 *  This will be called from the callback thread and marshalled to
 *  the main STA.
 *
 * Returns:
 *  S_OK if successful
 *  E_OUTOFMEMORY / OLE error otherwise
 */

HRESULT
CUPnPService::HrInvokeStateChangeCallbacks (
    IN IUnknown * punkService,
    IN IGlobalInterfaceTable * pGIT,
    IN LPCWSTR pszStateVarName,
    IN LPVARIANT lpvarValue)
{
    TraceTag(ttidUPnPService, "CUPnPService::HrInvokeStateChangeCallbacks(this=%x) - Enter", this);
    Assert(punkService);
    Assert(pGIT);
    Assert(lpvarValue);
    Assert(pszStateVarName);

    HRESULT hr = S_OK;
    DWORD   i;
    DWORD * rgdwCookies = NULL;
    DWORD   cCallbacks;

    // Copy callback info into locals before making cross-thread COM calls
    //
    Lock();

    cCallbacks = m_dwNumCallbacks;
    if (cCallbacks)
    {
        Assert(m_arydwCallbackCookies);

        rgdwCookies = new DWORD[cCallbacks];
        if (rgdwCookies)
        {
            CopyMemory(rgdwCookies, m_arydwCallbackCookies,
                       sizeof(DWORD) * cCallbacks);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    Unlock();

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < cCallbacks; ++i)
        {
            // See if the callback supports IDispatch or our custom interface
            //
            // NOTE: if we ever support additional callback interfaces, remember
            //       to update the code in HrAddCallback as well
            //

            IUnknown *  punkCallback;
            DWORD       dwCookie;

            punkCallback = NULL;
            dwCookie = rgdwCookies[i];

            hr = pGIT->GetInterfaceFromGlobal(dwCookie,
                                              IID_IUnknown,
                                              (LPVOID*)&punkCallback);
            if (SUCCEEDED(hr))
            {
                Assert(punkCallback);

                IUPnPServiceCallback    * pusc = NULL;

                hr = punkCallback->QueryInterface(IID_IUPnPServiceCallback,
                                                           (void **) &pusc);

                if (SUCCEEDED(hr) && pusc)
                {
                    TraceTag(ttidUPnPService,
                             "CUPnPService::HrInvokeStateChangeCallbacks(): "
                             "Firing callback off IUPnPServiceCallback "
                             "interface");

                    // Get an IUPnPService interface on the service object.
                    IUPnPService    * pus = NULL;

                    hr = punkService->QueryInterface(IID_IUPnPService,
                                                     (void **) &pus);

                    if (SUCCEEDED(hr) && pus)
                    {
                        BSTR              bstrVarName = NULL;

                        bstrVarName = SysAllocString(pszStateVarName);
                        if (bstrVarName)
                        {
                            hr = pusc->StateVariableChanged(pus,
                                                            bstrVarName,
                                                            *lpvarValue);
                            if (FAILED(hr))
                            {
                                TraceError("CUPnPService::"
                                           "InvokeChangeCallbacks(): "
                                           "StateVariableChanged() on callback"
                                           "interface returned failure",
                                           hr);
                            }

                            SysFreeString(bstrVarName);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("CUPnPService::HrInvokeStateChangeCallbacks(): "
                                       "Failed to allocate BSTR for varName",
                                       hr);
                        }

                        pus->Release();
                    }
                    else
                    {
                        if (SUCCEEDED(hr))
                        {
                            hr = E_FAIL;
                        }

                        TraceError("CUPnPService::"
                                   "HrFireStateChangeCallbacks(): "
                                   "Failed to get IUPnPService interface "
                                   "on service object",
                                   hr);
                    }

                    pusc->Release();
                }
                else if (E_NOINTERFACE == hr)
                {
                    IDispatch * pdispCallback = NULL;

                    hr = punkCallback->QueryInterface(IID_IDispatch,
                                                      (LPVOID*)&pdispCallback);

                    if (SUCCEEDED(hr) && pdispCallback)
                    {
                        IDispatch * pdispService;

                        pdispService = NULL;

                        hr = punkService->QueryInterface(IID_IDispatch,
                                                    (LPVOID*) &pdispService);
                        if (SUCCEEDED(hr))
                        {
                            Assert(punkService);

                            // Only IDispatch is supported.

                            TraceTag(ttidUPnPService, "CUPnPService::"
                                                      "HrInvokeStateChangeCallbacks(): "
                                                      "Firing callback off IDispatch interface\n");

                            hr = HrInvokeDispatchCallback(pdispCallback,
                                                          L"VARIABLE_UPDATE",
                                                          pdispService,
                                                          pszStateVarName,
                                                          lpvarValue);

                            punkService->Release();
                        }
                        else
                        {
                            TraceError("CUPnPService::"
                                    "HrInvokeStateChangeCallbacks: "
                                    "couldn't get service object's IDispatch",
                                    hr);
                        }

                        pdispCallback->Release();
                    }
                    else
                    {
                        if (SUCCEEDED(hr))
                        {
                            hr = E_FAIL;
                        }
                        TraceError("CUPnPService::HrInvokeStateChangeCallbacks: "
                                   "callback doesn't support any supported interfaces!", hr)
                    }
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }
                    TraceError("CUPnPService::HrInvokeStateChangeCallbacks(): "
                               "Failed to get an interface on callback object",
                               hr);
                }

                punkCallback->Release();
            }
            else
            {
                TraceError("CUPnPService::HrInvokeStateChangeCallbacks(): "
                           "GetInterfaceFromGlobal", hr);
            }
        }
    }

    delete [] rgdwCookies;

    TraceTag(ttidUPnPService, "CUPnPService::HrInvokeStateChangeCallbacks(this=%x) - Exit", this);
    TraceError("CUPnPService::HrInvokeStateChangeCallbacks", hr);
    return hr;
}


/*
 * Function:    CUPnPService::HrGrowCallbackList()
 *
 * Purpose:     Grows the capacity of the list used to store the
 *              event callback functions. This function is called
 *              when the current list is full and we need to add
 *              another callback.
 *
 * Returns:
 *  S_OK if successful, E_OUTOFMEMORY otherwise.
 */

HRESULT
CUPnPService::HrGrowCallbackList()
{
    HRESULT hr;
    DWORD   dwNewMaxCallbacks;
    LPDWORD arydwCallbacks;

    hr = S_OK;

    dwNewMaxCallbacks = m_dwMaxCallbacks + CALLBACK_LIST_DELTA;

    arydwCallbacks = new DWORD [ dwNewMaxCallbacks ];
    if (arydwCallbacks)
    {
        SIZE_T sizeNewBlock;
        SIZE_T sizeOldBlock;

        sizeNewBlock = sizeof(DWORD) * m_dwNumCallbacks;
        sizeOldBlock = sizeof(DWORD) * m_dwNumCallbacks;

        ::ZeroMemory(arydwCallbacks, sizeNewBlock);

        if (m_arydwCallbackCookies)
        {
            ::CopyMemory(arydwCallbacks, m_arydwCallbackCookies, sizeOldBlock);

            delete [] m_arydwCallbackCookies;
        }

        m_arydwCallbackCookies = arydwCallbacks;
        m_dwMaxCallbacks = dwNewMaxCallbacks;
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("CUPnPService::HrGrowCallbackList(): "
                   "Failed to allocate new array", hr);
    }

    TraceError("CUPnPService::HrGrowCallbackList", hr);
    return hr;
}


/*
 * Function:    CUPnPService::HrFreeCallbackList()
 *
 * Purpose:     Removes all of the callback pointers from the GIT.
 *
 * Returns:
 *  S_OK if successful, E_OUTOFMEMORY otherwise.
 */

VOID
CUPnPService::FreeCallbackList()
{
    Assert(m_arydwCallbackCookies);
    Assert(m_dwNumCallbacks <= m_dwMaxCallbacks);
    Assert(m_dwMaxCallbacks);

    HRESULT hr;

    IGlobalInterfaceTable * pGIT;

    pGIT = NULL;

    hr = HrGetGITPointer(&pGIT);
    if (SUCCEEDED(hr))
    {
        Assert(pGIT);

        DWORD i;

        i = 0;
        for ( ; i < m_dwNumCallbacks; ++i)
        {
            DWORD dwCookie;

            dwCookie = m_arydwCallbackCookies[i];

            hr = pGIT->RevokeInterfaceFromGlobal(dwCookie);
            TraceError("CUPnPService::HrFreeCallbackList: "
                       "RevokeInterfaceInGlobal", hr);

            // note: ignore errors here, as there's not much we can do
        }

        pGIT->Release();
    }

    m_dwNumCallbacks = 0;
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPService::FreeCallbackList");
}


/*
 * Function:    CUPnPService::HrAddCallback()
 *
 * Purpose:     Adds a callback to the list of callbacks to call back.
 *              (seriously: it adds an interface pointer to the GIT
 *              and stores its GIT cookie into a list of cookies to
 *              call back when an state update event is received.
 *              It will only add it to the list if it supports one
 *              of the supported callback interfaces).
 *
 * Notes:
 *  The service object must call this with its object lock held.
 *  This will always be called on the main STA.
 *
 * Returns:
 *  S_OK if successful
 *  E_NOINTERFACE if the punkCallback doesn't implement a supported callback
 *              interface
 *  E_OUTOFMEMORY otherwise
 */

HRESULT
CUPnPService::HrAddCallback(IUnknown * punkCallback, DWORD *pdwCookie)
{
    TraceTag(ttidUPnPService, "CUPnPService::HrAddCallback(this=%x) - Enter", this);
    Assert(punkCallback);

    HRESULT hr;
    BOOL fHasSupportedInterface;

    hr = S_OK;

    if (pdwCookie)
    {
        *pdwCookie = 0;
    }

    fHasSupportedInterface = FSupportsInterface(punkCallback,
                                                IID_IUPnPServiceCallback);
    if (!fHasSupportedInterface)
    {
        fHasSupportedInterface = FSupportsInterface(punkCallback,
                                                    IID_IDispatch);
    }

    if (fHasSupportedInterface)
    {
        // add it to the list of callbacks
        Assert(SUCCEEDED(hr));

        if (m_dwNumCallbacks == m_dwMaxCallbacks)
        {
            hr = HrGrowCallbackList();
            TraceError("CUPnPService::HrAddCallback(): "
                       "Failed to grow callback list", hr);
        }

        if (SUCCEEDED(hr))
        {
            Assert(m_arydwCallbackCookies);
            Assert(m_dwNumCallbacks <= m_dwMaxCallbacks);

            IGlobalInterfaceTable * pGIT;

            pGIT = NULL;

            hr = HrGetGITPointer(&pGIT);
            if (SUCCEEDED(hr))
            {
                Assert(pGIT);

                DWORD dwCookie;

                dwCookie = 0;

                hr = pGIT->RegisterInterfaceInGlobal(punkCallback,
                                                     IID_IUnknown,
                                                     &dwCookie);
                if (SUCCEEDED(hr))
                {
                    m_arydwCallbackCookies[m_dwNumCallbacks] = dwCookie;
                    m_dwNumCallbacks++;

                    if (pdwCookie)
                    {
                        *pdwCookie = dwCookie;
                    }
                }
                else
                {
                    TraceError("CUPnPService::HrAddCallback: "
                               "RegisterInterfaceInGlobal", hr);
                }

                pGIT->Release();
            }
        }
    }
    else
    {
        TraceTag(ttidUPnPService,
                 "CUPnPService::HrAddCallback: "
                 "callback-to-register doesn't support any callback interface");

        hr = E_INVALIDARG;
    }

    TraceTag(ttidUPnPService, "CUPnPService::HrAddCallback(this=%x) - Exit", this);
    TraceError("CUPnPService::HrAddCallback", hr);
    return hr;
}

DWORD WINAPI RemoveCallbackWorker(LPVOID pvContext)
{
    HRESULT     hr = S_OK;

    TraceTag(ttidUPnPService, "RemoveCallbackWorker - enter");

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr))
    {
        IGlobalInterfaceTable * pGIT = NULL;
        DWORD                   dwCookie = (DWORD)(ULONG_PTR)pvContext;

        AssertSz(dwCookie, "Cookie to revoke is 0!");

        hr = HrGetGITPointer(&pGIT);
        if (SUCCEEDED(hr))
        {
            Assert(pGIT);

            hr = pGIT->RevokeInterfaceFromGlobal(dwCookie);

            TraceError("RemoveCallbackWorker: "
                       "RevokeInterfaceInGlobal", hr);

            if (SUCCEEDED(hr))
            {
                TraceTag(ttidUPnPService, "RemoveCallbackWorker - %d"
                         " successfully revoked", dwCookie);
            }

            pGIT->Release();
        }

        CoUninitialize();
    }

    TraceTag(ttidUPnPService, "RemoveCallbackWorker - exit");

    TraceError("RemoveCallbackWorker", hr);

    return 0;
}

HRESULT
CUPnPService::HrRemoveCallback(DWORD dwCookie)
{
    HRESULT hr = S_OK;

    TraceTag(ttidUPnPService, "CUPnPService::HrRemoveCallback(this=%x) - Enter", this);

    if (!dwCookie)
    {
        hr = E_INVALIDARG;
        TraceError("HrRemoveCallback - invalid cookie!", hr);
    }
    else if (!m_dwNumCallbacks)
    {
        hr = E_INVALIDARG;
        TraceError("HrRemoveCallback - No callbacks in list!", hr);
    }
    else
    {
        Assert(m_arydwCallbackCookies);
        Assert(m_dwMaxCallbacks);
        Assert(m_dwNumCallbacks <= m_dwMaxCallbacks);

        DWORD   i;
        BOOL    fFound = FALSE;

        for (i = 0; i < m_dwNumCallbacks; ++i)
        {
            if (dwCookie == m_arydwCallbackCookies[i])
            {
                // Remove the callback cookie from the list first
                //
                m_dwNumCallbacks--;

                if (m_dwNumCallbacks)
                {
                    // We successfully revoked the callback from the GIT
                    // now remove the item from the array by moving the
                    // last item to this spot. We can do this since
                    // order does not matter
                    //
                    m_arydwCallbackCookies[i] = m_arydwCallbackCookies[m_dwNumCallbacks];
                    m_arydwCallbackCookies[m_dwNumCallbacks] = 0;
                }

                // Now revoke the interface from the table. If this fails
                // with ERROR_BUSY, then we need to do this on another thread
                // in order to get us out of this COM call
                //
                IGlobalInterfaceTable * pGIT = NULL;

                hr = HrGetGITPointer(&pGIT);
                if (SUCCEEDED(hr))
                {
                    Assert(pGIT);

                    hr = pGIT->RevokeInterfaceFromGlobal(dwCookie);
                    TraceError("CUPnPService::HrRemoveCallback: "
                               "RevokeInterfaceInGlobal", hr);
                    if (HRESULT_FROM_WIN32(ERROR_BUSY) == hr)
                    {
                        TraceTag(ttidUPnPService, "RevokeInterfaceFromGlobal "
                                 " failed. Queueing work item to do the "
                                 "revoke...");

                        QueueUserWorkItem(RemoveCallbackWorker,
                                          (PVOID)(ULONG_PTR)dwCookie, 0);
                        hr = S_OK;
                    }

                    pGIT->Release();
                }

                fFound = TRUE;

                break;
            }
        }

        if (!fFound)
        {
            hr = E_INVALIDARG;
            TraceTag(ttidError, "HrRemoveCallback - did not find cookie %d "
                     " in callback list!", dwCookie);
        }
    }

    TraceError("HrRemoveCallback", hr);
    return hr;
}

//////////////////////////////////////
// class CServiceLifetimeManager

CServiceLifetimeManager CServiceLifetimeManager::s_instance;

CServiceLifetimeManager::CServiceLifetimeManager() : m_pServiceNodeList(NULL)
{
    InitializeCriticalSection(&m_critSec);
}

CServiceLifetimeManager::~CServiceLifetimeManager()
{
    // Don't need to free list since everything should be dead by now
    if(m_pServiceNodeList)
    {
        TraceTag(ttidError, "CServiceLifetimeManager::~CServiceLifetimeManager - exiting with outstanding requests!!");
    }
    //Assert(!m_pServiceNodeList);
    DeleteCriticalSection(&m_critSec);
}

HRESULT CServiceLifetimeManager::AddService(CUPnPService * pService)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_critSec);

    // Add to list and add ref
    ServiceNode * pNode = new ServiceNode;
    if(!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        pNode->m_pNext = m_pServiceNodeList;
        pNode->m_pService = pService;
        pNode->m_nRefs = 1;
        pService->GetUnknown()->AddRef();
        m_pServiceNodeList = pNode;
        TraceTag(ttidUPnPService, "CServiceLifetimeManager::AddService(%x)", pService);
    }

    LeaveCriticalSection(&m_critSec);
    TraceHr(ttidUPnPService, FAL, hr, FALSE, "CServiceLifetimeManager::AddService");
    return hr;
}

HRESULT CServiceLifetimeManager::DerefService(CUPnPService * pService)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_critSec);

    // Find in list and remove
    hr = E_INVALIDARG;
    // Use pointer to pointer so that root node doesn't need to be handled differently
    ServiceNode ** ppNode = &m_pServiceNodeList;
    while((*ppNode))
    {
        // See if we match
        if((*ppNode)->m_pService == pService)
        {
            // Set found success code
            hr = S_OK;
            // Decrment the reference count
            Assert((*ppNode)->m_nRefs);
            --(*ppNode)->m_nRefs;
            TraceTag(ttidUPnPService, "CServiceLifetimeManager::DerefService(%x, count=%d)", pService, (*ppNode)->m_nRefs);
            // If this is the last one then cleanup and remove
            if(!(*ppNode)->m_nRefs)
            {
                // Remove added reference
                pService->GetUnknown()->Release();
                // Save pointer to current node to detete
                ServiceNode * pNode = *ppNode;
                // Remove node to list
                *ppNode = (*ppNode)->m_pNext;
                delete pNode;
            }
            break;
        }
        // Move to next node
        ppNode = &(*ppNode)->m_pNext;
    }

    LeaveCriticalSection(&m_critSec);
    TraceHr(ttidUPnPService, FAL, hr, FALSE, "CServiceLifetimeManager::DerefService");
    return hr;
}

HRESULT CServiceLifetimeManager::AddRefService(CUPnPService * pService)
{
    HRESULT hr = S_OK;
    EnterCriticalSection(&m_critSec);

    // Find in list and add reference
    hr = E_INVALIDARG;
    ServiceNode * pNode = m_pServiceNodeList;
    while(pNode)
    {
        // See if we match
        if(pNode->m_pService == pService)
        {
            // Set found success code
            hr = S_OK;
            // Add a reference
            Assert(pNode->m_nRefs);
            ++pNode->m_nRefs;
            TraceTag(ttidUPnPService, "CServiceLifetimeManager::AddRefService(%x, count=%d)", pService, pNode->m_nRefs);
            break;
        }
        // Move to next node
        pNode = pNode->m_pNext;
    }

    LeaveCriticalSection(&m_critSec);
    TraceHr(ttidUPnPService, FAL, hr, FALSE, "CServiceLifetimeManager::AddRefService");
    return hr;
}

/*
 * Function:    CUPnPServiceCallback::CUPnPServiceCallback()
 *
 */

CUPnPServiceCallback::CUPnPServiceCallback()
{
    m_pService = NULL;
}


/*
 * Function:    CUPnPServiceCallback::~CUPnPServiceCallback()
 *
 */

CUPnPServiceCallback::~CUPnPServiceCallback()
{
    // DeInit MUST have been called
    Assert(!m_pService);
}


/*
 * Function:    CUPnPServiceCallback::Init()
 *
 * Purpose:     Sets the object for which the callbackobject will hand out
 *              ref'd pointers.  It must not refcount the pointer that it
 *              stores (only the pointers that it hands out).
 *
 * Notes:
 *  This will always be called on the main STA.
 */

VOID
CUPnPServiceCallback::Init(CUPnPService * pService)
{
    TraceTag(ttidUPnPService, "CUPnPServiceCallback::Init - m_pService(%x)", pService);
    Assert(!m_pService);
    Assert(pService);

    m_pService = pService;
    HRESULT hr = CServiceLifetimeManager::Instance().AddRefService(m_pService);
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPServiceCallback::Init");
}


/*
 * Function:    CUPnPServiceCallback::DeInit()
 *
 * Purpose:     Called by the service object when it is freed.  Tells
 *              the callback object to stop giving out ref'd service
 *              object pointers.
 *
 * Notes:
 *  This will always be called on the main STA.
 */

VOID
CUPnPServiceCallback::DeInit(VOID)
{
    TraceTag(ttidUPnPService, "CUPnPServiceCallback::DeInit - Enter(m_pService=%x)", m_pService);
    Assert(m_pService);
    CUPnPService * pService = m_pService;
    m_pService = NULL;
    HRESULT hr = CServiceLifetimeManager::Instance().DerefService(pService);
    TraceTag(ttidUPnPService, "CUPnPServiceCallback::DeInit - Exit");
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPServiceCallback::DeInit");
}


STDMETHODIMP
CUPnPServiceCallback::GetServiceObject(IUnknown ** ppunkService)
{
    TraceTag(ttidUPnPService, "CUPnPServiceCallback::GetServiceObject(m_pService=%x)", m_pService);
    Assert(ppunkService);

    HRESULT hr;

    hr = E_FAIL;

    if (m_pService)
    {
        m_pService->GetUnknown()->AddRef();
        *ppunkService = m_pService->GetUnknown();

        hr = S_OK;
    }
    else
    {
        ppunkService = NULL;
    }

    TraceError("CUPnPServiceCallback::GetServiceObject", hr);
    return hr;
}


///////////////////////////////////////////////////
// class CUPnPServicePublic

CUPnPServicePublic::CUPnPServicePublic() : m_pService(NULL), m_fSsdpInitialized(FALSE)
{
}

CUPnPServicePublic::~CUPnPServicePublic()
{
    // we're done with ssdp
    if (m_fSsdpInitialized)
    {
        // Do SSDP cleanup asynchronously as it waits for the notification loop to exit
        // and this call may be happening on the notification loop.
        SsdpCleanup();
    }
}

HRESULT CUPnPServicePublic::FinalConstruct()
{
    TraceTag(ttidUPnPService, "CUPnPServicePublic::FinalConstruct - Enter");

    HRESULT hr = HrSsdpStartup(&m_fSsdpInitialized);
    TraceError("CUPnPServicePublic:FinalConstruct: HrSsdpStartup", hr);
    if(SUCCEEDED(hr))
    {
        hr = m_pService->CreateInstance(&m_pService);
        if(m_pService)
        {
            hr = CServiceLifetimeManager::Instance().AddService(m_pService);
        }
    }
    TraceTag(ttidUPnPService, "CUPnPServicePublic::FinalConstruct - Exit(m_pService=%x)", m_pService);
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPServicePublic::FinalConstruct(m_pService=%x)", m_pService);
    return hr;
}

HRESULT CUPnPServicePublic::FinalRelease()
{
    TraceTag(ttidUPnPService, "CUPnPServicePublic::FinalRelease - Enter(m_pService=%x)", m_pService);
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->HrStartShutdown();
        CServiceLifetimeManager::Instance().DerefService(m_pService);
        m_pService = NULL;
    }
    TraceTag(ttidUPnPService, "CUPnPServicePublic::FinalRelease - Exit");
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPServicePublic::FinalRelease");
    return hr;
}

STDMETHODIMP CUPnPServicePublic::GetTypeInfoCount(
    /* [out] */ UINT *pctinfo)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->GetTypeInfoCount(pctinfo);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::GetTypeInfo(
    /* [in] */ UINT iTInfo,
    /* [in] */ LCID lcid,
    /* [out] */ ITypeInfo **ppTInfo)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->GetTypeInfo(iTInfo, lcid, ppTInfo);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::GetIDsOfNames(
    /* [in] */ REFIID riid,
    /* [size_is][in] */ LPOLESTR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID *rgDispId)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::Invoke(
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [out][in] */ DISPPARAMS *pDispParams,
    /* [out] */ VARIANT *pVarResult,
    /* [out] */ EXCEPINFO *pExcepInfo,
    /* [out] */ UINT *puArgErr)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams,
                          pVarResult, pExcepInfo, puArgErr);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::get_ServiceTypeIdentifier(/*[out, retval]*/ BSTR *pVal)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->get_ServiceTypeIdentifier(pVal);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::InvokeAction(
    /*[in]*/            BSTR    bstrActionName,
    /*[in]*/            VARIANT vInActionArgs,
    /*[in, out]*/       VARIANT * pvOutActionArgs,
    /*[out, retval]*/   VARIANT * pvRetVal)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->InvokeAction(bstrActionName, vInActionArgs, pvOutActionArgs, pvRetVal);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::QueryStateVariable(
    /*[in]*/          BSTR bstrVariableName,
    /*[out, retval]*/ VARIANT *pValue)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->QueryStateVariable(bstrVariableName, pValue);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::AddCallback(/*[in]*/  IUnknown   * pUnkCallback)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->AddCallback(pUnkCallback);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::AddTransientCallback(/*[in]*/  IUnknown   * pUnkCallback,
                                                      /* [out] */ DWORD *pdwCookie)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->AddTransientCallback(pUnkCallback, pdwCookie);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::RemoveTransientCallback(/*[in]*/  DWORD dwCookie)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->RemoveTransientCallback(dwCookie);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::get_Id(/*[out, retval]*/ BSTR * pbstrId)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->get_Id(pbstrId);
    }
    return hr;
}

STDMETHODIMP CUPnPServicePublic::get_LastTransportStatus(/*[out, retval]*/ long * plValue)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->get_LastTransportStatus(plValue);
    }
    return hr;
}

HRESULT CUPnPServicePublic::HrInitialize(
    IN LPCWSTR                    pcwszSTI,
    IN LPCWSTR                    pcwszControlURL,
    IN LPCWSTR                    pcwszEventSubURL,
    IN LPCWSTR                    pcwszId,
    IN LONG                       lNumStateVariables,
    IN SERVICE_STATE_TABLE_ROW    * pSST,
    IN LONG                       lNumActions,
    IN SERVICE_ACTION             * pActionTable)
{
    HRESULT hr = E_OUTOFMEMORY;
    if(m_pService)
    {
        hr = m_pService->HrInitialize(pcwszSTI, pcwszControlURL, pcwszEventSubURL, pcwszId,
                                      lNumStateVariables, pSST, lNumActions, pActionTable);
    }
    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPServicePublic::HrInitialize");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpservicenode.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservicenode.cpp
//
//  Contents:   Implementation of CUPnPServiceNode, which contains
//              description-doc-level information about a service
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "node.h"
#include "upnpservicenode.h"
#include "upnpxmltags.h"
#include "ncstring.h"
#include "rehy.h"
#include "upnpdocument.h"
#include "upnpdescriptiondoc.h"

#include <ncinet2.h>            // HrCombineUrl
#include "testtarget.h"


// NOTE: REORDER THIS ON PAIN OF DEATH - ADD NEW VALUES AT THE END
const DevicePropertiesParsingStruct
CUPnPServiceNode::s_dppsParsingInfo [spLast] =
{
//m_fOptional  m_fIsUrl  m_fValidateUrl      m_pszTagName
    { FALSE,   FALSE,    FALSE,     XMLTags::pszServiceType  }, // spServiceType,
    { FALSE,   FALSE,    FALSE,     XMLTags::pszServiceId     }, // spServiceId
    { FALSE,   TRUE,     TRUE,      XMLTags::pszControlUrl     }, // spControlUrl
    { FALSE,   TRUE,     TRUE,      XMLTags::pszEventSubUrl   }, // spEventSubUrl
    { FALSE,   TRUE,     TRUE,      XMLTags::pszSCPDURL      }, // spSCPDUrl
};
// NOTE: REORDER THIS ON PAIN OF DEATH - ADD NEW VALUES AT THE END

CUPnPServiceNode::CUPnPServiceNode()
{
    AssertSz(spLast == celems(s_dppsParsingInfo),
             "CUPnPServiceNode: Properties added but s_dppsParsingInfo not updated!");

    ::ZeroMemory(m_arypszStringProperties, sizeof(LPWSTR *) * spLast);

    m_psnNext = NULL;
}


CUPnPServiceNode::~CUPnPServiceNode()
{
    ULONG i;

    for (i = 0; i < spLast; ++i)
    {
        if (m_arypszStringProperties[i])
        {
            delete [] m_arypszStringProperties[i];
        }
    }

    // don't free m_psnNext: the service list should take care of that.
}


HRESULT
CUPnPServiceNode::HrInit(IXMLDOMNode * pxdn, LPCWSTR pszBaseUrl)
{
    Assert(pxdn);

    HRESULT hr;
    BOOL fComplete;

    // TODO(cmr): right now we just take the value of the first xml tag that
    //            we're interested in.  we don't make sure that there aren't
    //            any (duplicate) tags there.  This should be made stronger.

        // Duplicate Tag Validation done here - Guru
    hr = HrAreElementTagsValid(pxdn,spLast,s_dppsParsingInfo);
    if(SUCCEEDED(hr))
    {
        hr = HrReadElementWithParseData(pxdn,
                                    spLast,
                                    s_dppsParsingInfo,
                                    pszBaseUrl,
                                    m_arypszStringProperties);
    }
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    fComplete = fAreReadValuesComplete (spLast,
                                        s_dppsParsingInfo,
                                        m_arypszStringProperties);
    if (!fComplete)
    {
        hr = UPNP_E_SERVICE_NODE_INCOMPLETE;
        goto Cleanup;
    }

    if(!fValidateUrl(spLast,
                  s_dppsParsingInfo,
                  m_arypszStringProperties,
                  (LPWSTR)pszBaseUrl) )
    {
        hr = E_FAIL ;
        TraceError("CUPnPServiceNode::HrInit() Url Validation failed", hr);
    }

Cleanup:
    TraceError("CUPnPServiceNode::HrInit", hr);
    return hr;
}


// loads an xml document from the given URL and
// returns an AddRef()'d IXMLDOMDocument * to it on success.
HRESULT
HrLoadXMLDocument(LPCWSTR pszUrl,
                  CUPnPDescriptionDoc * pdocParent,
                  IXMLDOMDocument ** ppdoc)
{
    Assert(ppdoc);
    Assert(pdocParent);
    Assert(pszUrl);

    HRESULT hr;
    HRESULT hrLoadResult;
    CComObject<CUPnPDocument> * pdoc;
    IXMLDOMDocument * pxddResult;

    pdoc = NULL;
    pxddResult = NULL;

    hr = CComObject<CUPnPDocument>::CreateInstance(&pdoc);
    if (FAILED(hr))
    {
        Assert(!pdoc);

        TraceError("OBJ: HrLoadXMLDocument: CreateInstance(CUPnPDocument) failed!", hr);
        goto Cleanup;
    }
    Assert(pdoc);

    // we need this to keep the doc from going away in the load()
    pdoc->GetUnknown()->AddRef();

    // we need to set the same security options on the new doc as we have
    // on ourselves.  This will prevent it from being redirected to a bad
    // url, even if the url that we loaded from is ok.
    pdoc->CopySafety(pdocParent);

    hr = pdoc->SyncLoadFromUrl(pszUrl);
    if (FAILED(hr))
    {
        // the load itself broke
        goto Cleanup;
    }

    // normally, we would expect to be able to receive S_FALSE here,
    // which we get if the load completes fine, but the CUPnPDocument-
    // derived class doesn't like what it sees.  Since we're just using
    // a raw CUPnPDocument, though, we should never get this result.
    // If we later change to using a CUPnPDocument-extended object, we
    // need to change this too,
    Assert(S_OK == hr);

    // this gets us an un-addref()'d xml document
    pxddResult = pdoc->GetXMLDocument();
    Assert(pxddResult);

    // addref it, since the CUPnPDocument is going away.
    pxddResult->AddRef();

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), pxddResult));
    Assert(FImplies(FAILED(hr), !pxddResult));

    if (pdoc)
    {
        pdoc->GetUnknown()->Release();
    }

    *ppdoc = pxddResult;

    TraceError("HrLoadXMLDocument", hr);
    return hr;
}


HRESULT
CUPnPServiceNode::HrGetServiceObject(IUPnPService ** ppud,
                                     CUPnPDescriptionDoc * pDoc)
{
    Assert(ppud);
    Assert(pDoc);

    HRESULT hr;
    IXMLDOMDocument * pxdd;

    pxdd = NULL;

    // make sure that all of these URLs are honkey-dorey
    {
        BOOL fIsAllowed;

        fIsAllowed = pDoc->fIsUrlLoadAllowed(m_arypszStringProperties[spSCPDUrl]);
        if (!fIsAllowed)
        {
            TraceTag(ttidUPnPDescriptionDoc,
                     "OBJ: CUPnPServiceNode::HrGetServiceObject: not creating service object, SCPDUrl=%S disallowed",
                     m_arypszStringProperties[spSCPDUrl]);

            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    {
        BOOL fIsAllowed;

        fIsAllowed = pDoc->fIsUrlLoadAllowed(m_arypszStringProperties[spControlUrl]);
        if (!fIsAllowed)
        {
            TraceTag(ttidUPnPDescriptionDoc,
                     "OBJ: CUPnPServiceNode::HrGetServiceObject: not creating service object, ControlURL=%S disallowed",
                     m_arypszStringProperties[spControlUrl]);

            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    {
        BOOL fIsAllowed;

        fIsAllowed = pDoc->fIsUrlLoadAllowed(m_arypszStringProperties[spEventSubUrl]);
        if (!fIsAllowed)
        {
            TraceTag(ttidUPnPDescriptionDoc,
                     "OBJ: CUPnPServiceNode::HrGetServiceObject: not creating service object, EventSubUrl=%S disallowed",
                     m_arypszStringProperties[spEventSubUrl]);

            hr = E_ACCESSDENIED;
            goto Cleanup;
        }
    }

    TraceTag(ttidUPnPDescriptionDoc,
             "OBJ: CUPnPServiceNode::HrGetServiceObject, loading scpd from %S for service id=%S",
             m_arypszStringProperties[spSCPDUrl],
             m_arypszStringProperties[spServiceId]);

    hr = HrLoadXMLDocument(m_arypszStringProperties[spSCPDUrl],
                           pDoc,
                           &pxdd);
    if (FAILED(hr))
    {
        Assert(!pxdd);
        goto Cleanup;
    }
    Assert(pxdd);

    TraceTag(ttidUPnPDescriptionDoc,
             "OBJ: CUPnPServiceNode::HrGetServiceObject, creating service object:\n"
             "\tService Type=%S\n\tControlUrl=%S\n\tEventSubUrl=%S\n\tServiceId=%S",
             m_arypszStringProperties[spServiceType],
             m_arypszStringProperties[spControlUrl],
             m_arypszStringProperties[spEventSubUrl],
             m_arypszStringProperties[spServiceId]);

    hr = HrRehydratorCreateServiceObject(m_arypszStringProperties[spServiceType],
                                         m_arypszStringProperties[spControlUrl],
                                         m_arypszStringProperties[spEventSubUrl],
                                         m_arypszStringProperties[spServiceId],
                                         pxdd,
                                         ppud);

Cleanup:
    SAFE_RELEASE(pxdd);

    TraceError("CUPnPServiceNode::HrGetServiceObject", hr);
    return hr;
}

LPCWSTR
CUPnPServiceNode::GetServiceId() const
{
    Assert(m_arypszStringProperties[spServiceId]);
    return m_arypszStringProperties[spServiceId];
}

void
CUPnPServiceNode::SetNext(CUPnPServiceNode * pusnNext)
{
    Assert(!m_psnNext);
    m_psnNext = pusnNext;
}


CUPnPServiceNode *
CUPnPServiceNode::GetNext() const
{
    return m_psnNext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpservicenodelist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservicenodelist.cpp
//
//  Contents:   Implementation of CUPnPServiceList, which stores
//              a list of CUPnPServiceNode objects, and implements
//              IUPnPServices
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "enumhelper.h"
#include "upnpenumerator.h"
#include "upnpservicenodelist.h"
#include "upnpservicenode.h"
#include "upnpservices.h"
#include "node.h"
#include "upnpdocument.h"
#include "upnpdescriptiondoc.h"

/////////////////////////////////////////////////////////////////////////////
// CUPnPServiceNodeList implementation

CUPnPServiceNodeList::CUPnPServiceNodeList()
{
    m_pDoc = NULL;

    m_psnFirst = NULL;
    m_psnLast = NULL;

    m_pusWrapper = NULL;
}

CUPnPServiceNodeList::~CUPnPServiceNodeList()
{
    CUPnPServiceNode * pnTemp;

    if (m_pusWrapper)
    {
        m_pusWrapper->Deinit();
    }

    pnTemp = m_psnFirst;
    while (pnTemp)
    {
        CUPnPServiceNode * pnNext;

        pnNext = pnTemp->GetNext();

        delete pnTemp;

        pnTemp = pnNext;
    }
}

void
CUPnPServiceNodeList::Init(CUPnPDescriptionDoc * pDoc)
{
    Assert(pDoc);
    // this can only be called once
    Assert(!m_pDoc);

    m_pDoc = pDoc;
}

HRESULT
CUPnPServiceNodeList::HrGetWrapper(IUPnPServices ** ppus)
{
    Assert(m_pDoc);
    Assert(ppus);

    HRESULT hr;
    IUPnPServices * pusResult;

    pusResult = NULL;

    if (!m_pusWrapper)
    {
        CComObject<CUPnPServices> * pusWrapper;
        IUnknown * punk;

        pusWrapper = NULL;
        punk = m_pDoc->GetUnknown();

        // create ourselves a wrapper, now.

        hr = CComObject<CUPnPServices>::CreateInstance(&pusWrapper);
        if (FAILED(hr))
        {
            TraceError("OBJ: CUPnPServiceNodeList::HrGetWrapper - CreateInstance(CUPnPServices)", hr);

            goto Cleanup;
        }
        Assert(pusWrapper);

        // note: this should addref() the doc.  also, after this point,
        //       it should Unwrap() us if it goes away on its own
        pusWrapper->Init(this, punk);
        m_pusWrapper = pusWrapper;
    }
    Assert(m_pusWrapper);

    // we MUST addref the pointer that we're returning!
    hr = m_pusWrapper->GetUnknown()->QueryInterface(IID_IUPnPServices, (void**)&pusResult);
    // this really should happen.  really.
    Assert(SUCCEEDED(hr));
    Assert(pusResult);

Cleanup:
    *ppus = pusResult;

    TraceError("CUPnPServiceNodeList::HrGetWrapper", hr);
    return hr;
}

void
CUPnPServiceNodeList::Unwrap()
{
    // only our wrapper can call us
    Assert(m_pusWrapper);

    m_pusWrapper = NULL;
}

HRESULT
CUPnPServiceNodeList::get_Count( /* [out, retval] */ LONG * pVal )
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPServiceNodeList::get_Count");

    HRESULT hr;
    LONG lResult;
    CUPnPServiceNode * psn;

    hr = S_OK;

    if (!pVal)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    lResult = 0;
    psn = m_psnFirst;

    while (psn)
    {
        ++lResult;
        psn = psn->GetNext();

        if (lResult < 0)
        {
            hr = E_UNEXPECTED;
            goto Cleanup;
        }
    }
    Assert(0 < lResult);

    *pVal = lResult;

Cleanup:
    TraceError("CUPnPServiceNodeList::Count", hr);
    return hr;
}

HRESULT
CUPnPServiceNodeList::get__NewEnum(LPUNKNOWN * pVal)
{
    // only our wrapper can call us
    Assert(m_pusWrapper);

    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPServiceNodeList::get__NewEnum");

    HRESULT hr;

    if (pVal)
    {
        IUnknown * punk;
        CEnumHelper * peh;
        LPVOID pvCookie;

        punk = m_pusWrapper->GetUnknown();
        peh = m_pusWrapper;
        pvCookie = GetFirstItem();

        hr = CUPnPEnumerator::HrCreateEnumerator(punk,
                                                 peh,
                                                 pvCookie,
                                                 pVal);
    }
    else
    {
        hr = E_POINTER;
    }

    TraceError("CUPnPServiceNodeList::get__NewEnum", hr);
    return hr;
}

CUPnPServiceNode *
CUPnPServiceNodeList::psnFindServiceById(LPCWSTR pszServiceId)
{
    Assert(pszServiceId);

    HRESULT hr;
    CUPnPServiceNode * psn;

    psn = m_psnFirst;

    while (psn)
    {
        LPCWSTR pszCurrentServiceId;
        int result;

        pszCurrentServiceId = psn->GetServiceId();

        if (pszCurrentServiceId)
        {
            result = wcscmp(pszServiceId, pszCurrentServiceId);
            if (0 == result)
            {
                // we found a match
                break;
            }
        }

        psn = psn->GetNext();
    }

    return psn;
}

HRESULT
CUPnPServiceNodeList::get_Item ( /* [in] */ BSTR bstrServiceId,
                        /* [out, retval] */ IUPnPService ** ppService)
{
    TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPServiceNodeList::get_Item");

    HRESULT hr;
    CUPnPServiceNode * psnMatchingNode;
    IUPnPService * psResult;

    hr = E_INVALIDARG;
    psResult = NULL;

    if (!bstrServiceId)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!ppService)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    psnMatchingNode = psnFindServiceById(bstrServiceId);

    if (psnMatchingNode)
    {
        // we found a matching node.  woo hoo.

        psResult = NULL;
        hr = psnMatchingNode->HrGetServiceObject(&psResult, m_pDoc);
        if (FAILED(hr))
        {
            // we couldn't get a service object for the service.
            // this could be because the data in the description
            // doc is invalid, the device might not be connectable,
            // etc...
            *ppService = NULL;

            goto Cleanup;
        }
        Assert(S_OK == hr);
    }

    *ppService = psResult;

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), psResult));
    Assert(FImplies(FAILED(hr), !psResult));

    TraceError("CUPnPServiceNodeList::get_Item", hr);
    return hr;
}

HRESULT
CUPnPServiceNodeList::HrAddService(IXMLDOMNode * pxdn, LPCWSTR pszBaseUrl)
{
    Assert(pxdn);

    HRESULT hr;
    CUPnPServiceNode * psnNew;

    psnNew = new CUPnPServiceNode();
    if (!psnNew)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = psnNew->HrInit(pxdn, pszBaseUrl);
    if (FAILED(hr))
    {
        // we need to free the new service element
        goto Error;
    }

    addServiceToList(psnNew);

Cleanup:
    TraceError("OBJ: CUPnPServiceNodeList::HrAddService", hr);
    return hr;

Error:
    Assert(psnNew);
    delete psnNew;

    goto Cleanup;
}

    // returns a reference to the next service node in the list,
    // after the specified node.  If there is no next service,
    // this returns NULL in *ppsnNext.
    // This method does not perform parameter validation.
    //
void
CUPnPServiceNodeList::GetNextServiceNode ( CUPnPServiceNode * psnCurrent,
                                           CUPnPServiceNode ** ppsnNext )
{
    Assert(psnCurrent);
    Assert(ppsnNext);

#ifdef DBG
    {
        // make sure psnCurrent is in our list of services

        CUPnPServiceNode * psnTemp;

        psnTemp = m_psnFirst;
        while (psnTemp)
        {
            if (psnTemp == psnCurrent)
            {
                break;
            }
            psnTemp = psnTemp->GetNext();
        }

        AssertSz(psnTemp, "OBJ: CUPnPServiceNodeList::GetNextServiceNode(): psnCurrent is not a valid node!");
    }
#endif // DBG

    *ppsnNext = psnCurrent->GetNext();
}

void
CUPnPServiceNodeList::addServiceToList(CUPnPServiceNode * psnNew)
{
    Assert(psnNew);

    if (!m_psnLast)
    {
        // we have our first element

        Assert(!m_psnFirst);

        m_psnFirst = psnNew;
    }
    else
    {
        // add it to the end of our current list of elements

        m_psnLast->SetNext(psnNew);
    }

    m_psnLast = psnNew;
}

LPVOID
CUPnPServiceNodeList::GetFirstItem()
{
    return m_psnFirst;
}

CUPnPServiceNode *
GetNthChild(CUPnPServiceNode * psnStart, ULONG ulNeeded, ULONG * pulSkipped)
{
    // note(cmr): If you change this, you probably want to change GetNthChild in
    //            upnpdevices.cpp as well

    Assert(psnStart);

    CUPnPServiceNode * psnTemp;
    ULONG ulCount;

    ulCount = 0;
    psnTemp = psnStart;
    for ( ; (ulCount < ulNeeded) && psnTemp; ++ulCount)
    {
        psnTemp = psnTemp->GetNext();
    }

    if (pulSkipped)
    {
        *pulSkipped = ulCount;
    }

    Assert(ulCount <= ulNeeded);
    Assert(FImplies((ulCount < ulNeeded), !psnTemp));

    return psnTemp;
}

LPVOID
CUPnPServiceNodeList::GetNextNthItem(ULONG ulSkip,
                                     LPVOID pCookie,
                                     ULONG * pulSkipped)
{
    Assert(pCookie);

    CUPnPServiceNode * psnCurrent;
    CUPnPServiceNode * pnResult;

    psnCurrent = (CUPnPServiceNode *) pCookie;

    pnResult = GetNthChild(psnCurrent, ulSkip, pulSkipped);

    return pnResult;
}

HRESULT
CUPnPServiceNodeList::GetPunk(LPVOID pCookie, IUnknown ** ppunk)
{
    Assert(pCookie);
    Assert(ppunk);

    CUPnPServiceNode * psn;
    IUPnPService * pus;
    HRESULT hr;

    psn = (CUPnPServiceNode *) pCookie;
    pus = NULL;
    hr = psn->HrGetServiceObject(&pus, m_pDoc);
    if (FAILED(hr))
    {
        pus = NULL;
    }

    Assert(FImplies(SUCCEEDED(hr), pus));
    Assert(FImplies(FAILED(hr), !pus));

    *ppunk = pus;

    TraceError("CUPnPServiceNodeList::GetPunk", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpenumerator.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpenumerator.cpp
//
//  Contents:   implementation of CUPnPEnumerator
//
//  Notes:      an abstract base class to help load xml documents via
//              IPersistMoniker/IBindStatusCallback
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop


#include "enumhelper.h"
#include "upnpenumerator.h"


/*
    How our wacky Enumerators work

    The enumerator object is connected to the collection object.
    The collection object provides three methods that the enumerator
    uses:
      - LPVOID GetFirstItem();
      - LPVOID GetNextNthItem(ULONG ulSkip, LPVOID pCookie, ULONG * pulSkipped);
      - HRESULT GetPunk(LPVOID pCookie, IUnknown ** ppUnk);
    All our enumerator does is store a cookie and call these
    two functions.

    GetNextItem() returns the 'next' cookie, given a particular
    cookie.

    GetNextNthItem() returns the cookie corresponding to the
    "ulSkip"-th next item in the list.
      GetNextNthItem(1, pvCookieCurrent, NULL)
    would return the cookie for the NEXT item in the list
    (after pvCookieCurrent).
    also note that pulSkipped may be NULL.

    MAGIC!!!: The cookie value NULL means that the enumerator
    is at the END of the current list.  It must be returned by
    GetNextNthItem() when the end of the list is reached, or
    by GetFirstItem() if the list is empty.

    GetPunk() returns an addref()'d IUnknown * corresponding to
    the given cookie.  This is generally just passed to the
    caller; the enumerator doesn't care what this refers to.

    Additionally, these methods are called on the Collection
    wrapper object (which creates this enumerator), not directly
    on the internal collection list object itself.  This is
    because of the wackiness between wrapper objects and the
    objects they wrap.  When the wrapped object goes away,
    it needs to deinit() any wrapper objects around it.

    For no other reason than laziness, we don't want the wrapped
    object to have to keep a list of all of the n enumerators
    that are listing its elements and then Deinit() each of them.

    Instead, we make the enumerator call the wrapped element
    through the collection wrapper.  When the wrapper is
    Deinit()ed, our calls will be Deinit()ed as well.  A side
    affect of this is that the collection wrapper stays around as
    long as any of the enumerators which it created does, but this
    doesn't seem like a big deal.
*/


CUPnPEnumerator::CUPnPEnumerator()
{
    m_punk = NULL;
    m_peh = NULL;
    m_pvCookie = NULL;
}

CUPnPEnumerator::~CUPnPEnumerator()
{
    Assert(!m_punk);
    Assert(!m_peh);
}

void
CUPnPEnumerator::Init(IUnknown * punk, CEnumHelper * peh, LPVOID pvCookie)
{
    Assert(punk);
    Assert(peh);
    // only call this once, please.
    Assert(!m_punk);

    punk->AddRef();
    m_punk = punk;

    m_peh = peh;
    m_pvCookie = pvCookie;
}


// ATL Methods
HRESULT
CUPnPEnumerator::FinalConstruct()
{
    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::FinalConstruct");

    return S_OK;
}

HRESULT
CUPnPEnumerator::FinalRelease()
{
    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::FinalRelease");

    Assert(FImplies(m_punk, m_peh));
    Assert(FImplies(m_peh, m_punk));
    if (m_punk)
    {
        m_punk->Release();
        m_punk = NULL;
    }
    m_peh = NULL;

    return S_OK;
}

HRESULT
CUPnPEnumerator::HrGetWrappers(IUnknown * arypunk [],
                               ULONG cunk,
                               ULONG * pulWrapped)
{
    Assert(arypunk);
    Assert(pulWrapped);
    Assert(m_peh);

    HRESULT hr;
    ULONG ulWrapped;
    LPVOID pvCookie;
    IUnknown ** ppunkCurrent;

    hr = S_OK;
    ulWrapped = 0;
    pvCookie = m_pvCookie;
    ppunkCurrent = arypunk;

    while ((ulWrapped < cunk) && pvCookie)
    {
        LPVOID pvCookieNew;

        *ppunkCurrent = NULL;
        hr = m_peh->GetPunk(pvCookie, ppunkCurrent);
        if (FAILED(hr))
        {
            *ppunkCurrent = NULL;
            goto Error;
        }
        Assert(*ppunkCurrent);

        pvCookieNew = m_peh->GetNextNthItem(1, pvCookie, NULL);
        Assert(pvCookieNew != pvCookie);

        pvCookie = pvCookieNew;
        ++ppunkCurrent;
        ++ulWrapped;
    }

    m_pvCookie = pvCookie;

Cleanup:
    Assert(FImplies(SUCCEEDED(hr) && (ulWrapped < cunk), !m_pvCookie));
    Assert(FImplies(FAILED(hr), !ulWrapped));

    *pulWrapped = ulWrapped;

    TraceError("CUPnPEnumerator::HrGetWrappers", hr);
    return hr;

Error:
    // free everything in arypunk so far
    {
        int i;

        i = 0;
        for ( ; i < ulWrapped; ++i)
        {
            Assert(arypunk[i]);
            arypunk[i]->Release();
            arypunk[i] = NULL;
        }
    }
    ulWrapped = 0;

    goto Cleanup;
}


// IEnumVARIANT Methods
STDMETHODIMP
CUPnPEnumerator::Next(ULONG celt, VARIANT * rgVar, ULONG * pceltFetched)
{
    // REVIEW(cmr): could we make this share more code with
    //              IEnumUnknown::Next()?  I can't figure out
    //              any reasonable way to do it.

    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::Next - IEnumVARIANT");

    HRESULT hr;
    ULONG celtFetched;
    IUnknown ** arypunk;
    IDispatch ** arydisp;
    LPVOID pvBackup;            // we need this in case we fail in QI'ing
                                // the IUnknown * list.  m_pvCookie will
                                // have already been advanced by
                                // HrGetWrappers, but we'll have failed,
                                // so we should put the list back to
                                // where it was...

    celtFetched = 0;
    arypunk = NULL;
    arydisp = NULL;
    pvBackup = m_pvCookie;

    if (!rgVar)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pceltFetched && (celt > 1))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    arypunk = new IUnknown * [celt];
    if (!arypunk)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = HrGetWrappers(arypunk, celt, &celtFetched);
    if (FAILED(hr))
    {
        Assert(!celtFetched);;
        goto Cleanup;
    }

    // note: celtFetched MAY be 0, but this doesn't seem to matter.
    arydisp = new IDispatch * [celtFetched];
    if (!arydisp)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    {
        // note: arydisp was declared as a IDispatch **, so
        //       sizeof(arydisp) won't work...
        // REVIEW(cmr): should I be using different hungarian for it?
        SIZE_T size;
        size = sizeof(IDispatch *) * celtFetched;
        ::ZeroMemory(arydisp, size);
    }

    // note: AFTER this point we must goto Error to clean up.

    // get IDispatch * references to the returned punks.
    // All of them must support IDispatch.  If any of them don't,
    // we return complete failure.
    {
        ULONG i;

        i = 0;
        for ( ; i < celtFetched; ++i)
        {
            Assert(arypunk[i]);

            IDispatch * pdispTemp;

            pdispTemp = NULL;
            hr = arypunk[i]->QueryInterface(IID_IDispatch, (void**)&pdispTemp);
            Assert(SUCCEEDED(hr));
            Assert(pdispTemp);

            arydisp[i] = pdispTemp;
        }
    }

    // stick the results into the VARIANT array
    {
        VARIANT * pvarCurrent;
        ULONG i;

        pvarCurrent = rgVar;
        i = 0;
        for ( ; i < celtFetched; ++i)
        {
            VariantInit(pvarCurrent);

            V_VT(pvarCurrent) = VT_DISPATCH;
            V_DISPATCH(pvarCurrent) = arydisp[i];

            ++pvarCurrent;
        }
    }

    if (celtFetched == celt)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    Assert(FImplies((S_OK == hr) && celt, celtFetched));
    Assert(FImplies(S_FALSE == hr, !m_pvCookie));
    Assert(FImplies(FAILED(hr), 0 == celtFetched));

    {
        // free the IUnknown * references to our return results
        ULONG i;

        for (i = 0; i < celtFetched; ++i)
        {
            Assert(arypunk[i]);
            arypunk[i]->Release();
        }
    }

    if (arypunk)
    {
        delete [] arypunk;
    }

    if (arydisp)
    {
        delete [] arydisp;
    }

    if (pceltFetched)
    {
        *pceltFetched = celtFetched;
    }

    TraceErrorOptional("CUPnPEnumerator::Next - VARIANT", hr, (S_FALSE == hr));
    return hr;
}


STDMETHODIMP
CUPnPEnumerator::Skip(ULONG celt)
{
    Assert(m_peh);

    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::Skip");

    HRESULT hr;

    // please don't change this
    hr = S_FALSE;

    if (celt > 0)
    {
        if (m_pvCookie)
        {
            // we're not at the end

            LPVOID pvNewCookie;
            ULONG celtSkipped;

            celtSkipped = 0;

            pvNewCookie = m_peh->GetNextNthItem(celt,
                                                m_pvCookie,
                                                &celtSkipped);

            if (celtSkipped == celt)
            {
                // we skipped everything
                hr = S_OK;
            }

            Assert(FImplies(celtSkipped < celt, !pvNewCookie));

            m_pvCookie = pvNewCookie;
        }
    }
    else
    {
        // we skipped 0 items, alright
        hr = S_OK;
    }

    TraceErrorOptional("CUPnPEnumerator::Skip", hr, (S_FALSE == hr));
    return hr;
}


STDMETHODIMP
CUPnPEnumerator::Reset()
{
    Assert(m_peh);

    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::Reset");

    HRESULT hr;
    LPVOID pvNewCookie;

    hr = S_OK;

    pvNewCookie = m_peh->GetFirstItem();

    m_pvCookie = pvNewCookie;

    TraceError("CUPnPEnumerator::Reset", hr);
    return hr;
}

HRESULT
CUPnPEnumerator::HrCreateClonedEnumerator(CComObject<CUPnPEnumerator> ** ppueNew)
{
    Assert(m_peh);
    Assert(m_punk);
    Assert(ppueNew);

    HRESULT hr;

    *ppueNew = NULL;
    hr = CComObject<CUPnPEnumerator>::CreateInstance(ppueNew);
    if (SUCCEEDED(hr))
    {
        Assert(*ppueNew);

        // give it our properties
        //
        (*ppueNew)->Init(m_punk, m_peh, m_pvCookie);
    }

    Assert(FImplies(SUCCEEDED(hr), *ppueNew));
    Assert(FImplies(FAILED(hr), !(*ppueNew)));

    TraceError("HrCreateClonedEnumerator", hr);
    return hr;
}


STDMETHODIMP
CUPnPEnumerator::Clone(IEnumVARIANT ** ppEnum)
{
    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::Clone - IEnumVARIANT");

    HRESULT hr;
    IEnumVARIANT * pevResult;
    CComObject<CUPnPEnumerator> * pueNew;

    // create our new enumerator
    pevResult = NULL;

    pueNew = NULL;
    hr = HrCreateClonedEnumerator(&pueNew);
    if (SUCCEEDED(hr))
    {
        hr = pueNew->GetUnknown()->QueryInterface(IID_IEnumVARIANT,
                                                  (void**)&pevResult);
        Assert(SUCCEEDED(hr));
        Assert(pevResult);
    }

    Assert(FImplies(SUCCEEDED(hr), pevResult));
    Assert(FImplies(FAILED(hr), !pevResult));

    *ppEnum = pevResult;

    TraceError("CUPnPEnumerator::Clone - IEnumVARIANT", hr);
    return hr;
}


// IEnumUnknown Methods

STDMETHODIMP
CUPnPEnumerator::Next(ULONG celt,
                      IUnknown ** rgelt,
                      ULONG * pceltFetched)
{
    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::Next - IEnumUnknown");

    // REVIEW(cmr): could we make this share more code with
    //              IEnumVARIANT::Next()?  I can't figure out
    //              any reasonable way to do it.

    HRESULT hr;
    ULONG celtFetched;
    IUnknown ** arypunk;

    // note(cmr): this doesn't make much sense, but the ATL
    //            enumerator implementation has this.  I'm guessing
    //            that some loser code relies on this.  It's not
    //            easy to do this, though, so we don't.
#ifdef NEVER
    if ((celt == 0) && (rgelt == NULL) && (NULL != pceltFetched))
    {
        // Return the number of remaining elements
        *pceltFetched = (ULONG)(m_end - m_iter);
        return S_OK;
    }
#endif // NEVER
    // note(cmr): ATL does a lot of things that seem really wacky, that
    //              we're not following.
    //           1. when (0 == celt), the current ATL implemenation returns
    //              S_OK if the list isn't at its end, and S_FALSE if
    //              it is.  Instead, we return S_FALSE when celt == 0.
    //           2. ATL doesn't allow pceltFetched to be NULL when celt==0,
    //              even though it does (by spec) when celt == 1.  We make
    //              sure that pceltFetched is non-NULL only if celt is
    //              greater than 1.

    celtFetched = 0;
    arypunk = NULL;

    if (!rgelt)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (!pceltFetched && (celt > 1))
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    arypunk = new IUnknown * [celt];
    if (!arypunk)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = HrGetWrappers(arypunk, celt, &celtFetched);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    {
        SIZE_T szLength = celtFetched * sizeof(IUnknown *);
        ::CopyMemory(rgelt, arypunk, szLength);
    }

    if (celtFetched == celt)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

Cleanup:
    Assert(FImplies((S_OK == hr) && celt, celtFetched));
    Assert(FImplies((S_FALSE == hr), !m_pvCookie));

    if (arypunk)
    {
        delete [] arypunk;
    }

    if (pceltFetched)
    {
        *pceltFetched = celtFetched;
    }

    TraceErrorOptional("CUPnPEnumerator::Next - IEnumUnknown", hr, (S_FALSE == hr));
    return hr;
}

// rem: the same as IEnumVARIANT's version
//    STDMETHODIMP(Skip)( /* [in] */ ULONG celt);
//    STDMETHOD(Reset)();

STDMETHODIMP
CUPnPEnumerator::Clone(IEnumUnknown ** ppEnum)
{
    TraceTag(ttidUPnPEnum, "CUPnPEnumerator::Clone - IEnumUnknown");

    HRESULT hr;
    IEnumUnknown * punkResult;
    CComObject<CUPnPEnumerator> * pueNew;

    // create our new enumerator
    punkResult = NULL;

    pueNew = NULL;
    hr = HrCreateClonedEnumerator(&pueNew);
    if (SUCCEEDED(hr))
    {
        hr = pueNew->GetUnknown()->QueryInterface(IID_IEnumUnknown,
                                                  (void**)&punkResult);
        Assert(SUCCEEDED(hr));
        Assert(punkResult);
    }

    Assert(FImplies(SUCCEEDED(hr), punkResult));
    Assert(FImplies(FAILED(hr), !punkResult));

    *ppEnum = punkResult;

    TraceError("CUPnPEnumerator::Clone - IEnumUnknown", hr);
    return hr;
}

HRESULT
CUPnPEnumerator::HrCreateEnumerator(IUnknown * punk,
                                    CEnumHelper * peh,
                                    LPVOID pvCookie,
                                    IUnknown ** ppunkNewEnum)
{
    Assert(punk);
    Assert(peh);
    Assert(ppunkNewEnum);

    HRESULT hr;
    CComObject<CUPnPEnumerator> * penum;
    IUnknown * punkResult;

    punkResult = NULL;

    penum = NULL;
    hr = CComObject<CUPnPEnumerator>::CreateInstance(&penum);
    if (FAILED(hr))
    {
        TraceError("OBJ: CUPnPEnumerator::HrCreateEnumerator - CreateInstance(CUPnPEnumerator)", hr);

        goto Cleanup;
    }
    Assert(penum);

    penum->Init(punk, peh, pvCookie);

    punkResult = penum->GetUnknown();
    punkResult->AddRef();

Cleanup:
    Assert(FImplies(SUCCEEDED(hr), punkResult));
    Assert(FImplies(FAILED(hr), !punkResult));

    *ppunkNewEnum = punkResult;

    TraceError("CUPnPEnumerator::HrCreateEnumerator", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include <pch.h>
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpxmltags.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpxmltags.cpp
//
//  Contents:   Definition of string constants that appear as element
//              names in our xml documents.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "upnpxmltags.h"

#define DECLARE_XML_TAG(tagname, string) CONST LPCWSTR XMLTags::tagname = string

DECLARE_XML_TAG(pszElementRoot,     L"root");
DECLARE_XML_TAG(pszBaseUrl,         L"URLBase");
DECLARE_XML_TAG(pszDevice,          L"device");
DECLARE_XML_TAG(pszUDN,             L"UDN");
DECLARE_XML_TAG(pszFriendlyName,    L"friendlyName");
DECLARE_XML_TAG(pszDeviceType,      L"deviceType");
DECLARE_XML_TAG(pszPresentationURL, L"presentationURL");
DECLARE_XML_TAG(pszManufacturer,    L"manufacturer");
DECLARE_XML_TAG(pszManufacturerURL, L"manufacturerURL");
DECLARE_XML_TAG(pszModelName,       L"modelName");
DECLARE_XML_TAG(pszModelNumber,     L"modelNumber");
DECLARE_XML_TAG(pszModelDescription,L"modelDescription");
DECLARE_XML_TAG(pszModelURL,        L"modelURL");
DECLARE_XML_TAG(pszUPC,             L"UPC");
DECLARE_XML_TAG(pszSerialNumber,    L"serialNumber");
DECLARE_XML_TAG(pszService,         L"service");
DECLARE_XML_TAG(pszServiceType,     L"serviceType");
DECLARE_XML_TAG(pszControlUrl,      L"controlURL");
DECLARE_XML_TAG(pszEventSubUrl,     L"eventSubURL");
DECLARE_XML_TAG(pszSCPDURL,         L"SCPDURL");
DECLARE_XML_TAG(pszDeviceList,      L"deviceList");
DECLARE_XML_TAG(pszServiceList,     L"serviceList");
DECLARE_XML_TAG(pszServiceId,       L"serviceId");
DECLARE_XML_TAG(pszIconList,        L"iconList");
DECLARE_XML_TAG(pszIcon,            L"icon");
DECLARE_XML_TAG(pszMimetype,        L"mimetype");
DECLARE_XML_TAG(pszWidth,           L"width");
DECLARE_XML_TAG(pszHeight,          L"height");
DECLARE_XML_TAG(pszDepth,           L"depth");
DECLARE_XML_TAG(pszUrl,             L"url");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\dll\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

//define _WIN32_WINNT 0x0400 //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "stub_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //_NOPROXY

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B6C2EC65_A7EF_4A9E_A95F_C94091F5F146__INCLUDED_)
#define AFX_DLLDATAX_H__B6C2EC65_A7EF_4A9E_A95F_C94091F5F146__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B6C2EC65_A7EF_4A9E_A95F_C94091F5F146__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\api\upnpservices.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservices.cpp
//
//  Contents:   Implementation of CUPnPServices, the wrapper class
//              for providing an IUPnPServices implementation
//              on top of a CUPnPServiceList.
//
//  Notes:      see "how this wrapper stuff works" in cupnpdevicenode.cpp
//              for an explanation of the wrapping strategy
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "enumhelper.h"
#include "upnpenumerator.h"
#include "upnpservicenodelist.h"
#include "UPnPServices.h"


#define SAFE_WRAP(pointer, methodcall) \
        return (pointer) ? pointer->methodcall : E_UNEXPECTED

/////////////////////////////////////////////////////////////////////////////
// CUPnPServices

CUPnPServices::CUPnPServices()
{
    m_pusnl = NULL;
    m_punk = NULL;
}


CUPnPServices::~CUPnPServices()
{
    Assert(!m_pusnl);
    Assert(!m_punk);
}


HRESULT
CUPnPServices::FinalConstruct()
{
    TraceTag(ttidUPnPDescriptionDoc, "CUPnPServices::FinalConstruct");

    return S_OK;
}

HRESULT
CUPnPServices::FinalRelease()
{
    TraceTag(ttidUPnPDescriptionDoc, "CUPnPServices::FinalRelease");

    if (m_pusnl)
    {
        m_pusnl->Unwrap();
        m_pusnl = NULL;

        Assert(m_punk);
    }

    SAFE_RELEASE(m_punk);

    return S_OK;
}

void
CUPnPServices::Init(CUPnPServiceNodeList * pusnl, IUnknown * punk)
{
    Assert(punk);
    Assert(pusnl);
    Assert(!m_punk);
    Assert(!m_pusnl);

    punk->AddRef();
    m_punk = punk;

    m_pusnl = pusnl;
}

void
CUPnPServices::Deinit()
{
    Assert(m_pusnl);

    m_pusnl = NULL;
}

// IUPnPServices methods
STDMETHODIMP
CUPnPServices::get_Count ( /* [out, retval] */ LONG * pVal )
{
    SAFE_WRAP(m_pusnl, get_Count(pVal));
}

STDMETHODIMP
CUPnPServices::get__NewEnum ( /* [out, retval] */ LPUNKNOWN * pVal )
{
    SAFE_WRAP(m_pusnl, get__NewEnum(pVal));
}

STDMETHODIMP
CUPnPServices::get_Item ( /* [in] */  BSTR bstrDCPI,
                  /* [out, retval] */ IUPnPService ** ppService)
{
    SAFE_WRAP(m_pusnl, get_Item(bstrDCPI, ppService));
}

LPVOID
CUPnPServices::GetFirstItem()
{
    LPVOID pvResult;

    if (m_pusnl)
    {
        pvResult = m_pusnl->GetFirstItem();
    }
    else
    {
        pvResult = NULL;
    }

    return pvResult;
}

LPVOID
CUPnPServices::GetNextNthItem(ULONG ulSkip,
                              LPVOID pCookie,
                              ULONG * pulSkipped)
{
    LPVOID pvResult;

    if (m_pusnl)
    {
        pvResult = m_pusnl->GetNextNthItem(ulSkip, pCookie, pulSkipped);
    }
    else
    {
        pvResult = NULL;

        if (pulSkipped)
        {
            *pulSkipped = 0;
        }
    }

    return pvResult;
}

HRESULT
CUPnPServices::GetPunk(LPVOID pCookie, IUnknown ** ppunk)
{
    SAFE_WRAP(m_pusnl, GetPunk(pCookie, ppunk));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\host\devicehostsetup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E H O S T S E T U P . C P P 
//
//  Contents:   Implementation of device host setup helper object
//
//  Notes:      
//
//  Author:     mbend   20 Dec 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "DeviceHostSetup.h"
#include "ssdpapi.h"

CUPnPDeviceHostSetup::CUPnPDeviceHostSetup()
{
}

CUPnPDeviceHostSetup::~CUPnPDeviceHostSetup()
{
}

STDMETHODIMP CUPnPDeviceHostSetup::AskIfNotAlreadyEnabled(/*[out, retval]*/ VARIANT_BOOL * pbEnabled)
{
    // TODO: Implement this!!!!!!!!!!!!!!!!!
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\host\devicehosticssupport.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E H O S T I C S S U P P O R T . H
//
//  Contents:   Implementation of ICS support COM wrapper object
//
//  Notes:
//
//  Author:     mbend   20 Dec 2000
//
//----------------------------------------------------------------------------

#include "upnpatl.h"
#include "upnp.h"
#include "upnpp.h"
#include "resource.h"

class ATL_NO_VTABLE CUPnPDeviceHostICSSupport :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass<CUPnPDeviceHostICSSupport, &CLSID_UPnPDeviceHostICSSupport>,
    public IUPnPDeviceHostICSSupport
{
public:
    CUPnPDeviceHostICSSupport();
    ~CUPnPDeviceHostICSSupport();

    DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEHOSTICSSUPPORT)

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceHostICSSupport)

    BEGIN_COM_MAP(CUPnPDeviceHostICSSupport)
        COM_INTERFACE_ENTRY(IUPnPDeviceHostICSSupport)
    END_COM_MAP()

    // IUPnPDeviceHostICSSupport methods
    STDMETHOD(SetICSInterfaces)(/*[in]*/ long nCount, /*[in, size_is(nCount)]*/ GUID * arPrivateInterfaceGuids);
    STDMETHOD(SetICSOff)();
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\host\devicehosticssupport.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E H O S T I C S S U P P O R T . C P P 
//
//  Contents:   Implementation of ICS support COM wrapper object
//
//  Notes:      
//
//  Author:     mbend   20 Dec 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "DeviceHostICSSupport.h"
#include "ssdpapi.h"
#include "upnphost.h"
#include "hostp.h"
#include "ComUtility.h"

#include "hostp_i.c"

typedef SmartComPtr<IUPnPRegistrarICSSupport> IUPnPRegistrarICSSupportPtr;

CUPnPDeviceHostICSSupport::CUPnPDeviceHostICSSupport()
{
}

CUPnPDeviceHostICSSupport::~CUPnPDeviceHostICSSupport()
{
}

STDMETHODIMP CUPnPDeviceHostICSSupport::SetICSInterfaces(/*[in]*/ long nCount, /*[in, size_is(nCount)]*/ GUID * arPrivateInterfaceGuids)
{
    // TODO: Add calls to upnphost
    BOOL bRet = SsdpStartup();
    if(bRet)
    {
        TraceTag(ttidSsdpCRpcInit, "CUPnPDeviceHostICSSupport::SetICSInterfaces");
        DHSetICSInterfaces(nCount, arPrivateInterfaceGuids);
        SsdpCleanup();

        IUPnPRegistrarICSSupportPtr pIcs;
        HRESULT hr = pIcs.HrCreateInstanceLocal(CLSID_UPnPRegistrar);
        if(SUCCEEDED(hr))
        {
            hr = pIcs->SetICSInterfaces(nCount, arPrivateInterfaceGuids);
        }
    }
    else
    {
        TraceTag(ttidError, "CUPnPDeviceHostICSSupport::SetICSInterfaces - SsdpStartup failed");
    }
    return S_OK;
}

STDMETHODIMP CUPnPDeviceHostICSSupport::SetICSOff()
{
    // TODO: Add calls to upnphost
    BOOL bRet = SsdpStartup();
    if(bRet)
    {
        TraceTag(ttidSsdpCRpcInit, "CUPnPDeviceHostICSSupport::SetICSOff");
        DHSetICSOff();
        SsdpCleanup();
    
        IUPnPRegistrarICSSupportPtr pIcs;
        HRESULT hr = pIcs.HrCreateInstanceLocal(CLSID_UPnPRegistrar);
        if(SUCCEEDED(hr))
        {
            hr = pIcs->SetICSOff();
        }
    }
    else
    {
        TraceTag(ttidError, "CUPnPDeviceHostICSSupport::SetICSInterfaces - SsdpStartup failed");
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\host\devicehostsetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       D E V I C E H O S T S E T U P . H
//
//  Contents:   Implementation of device host setup helper object
//
//  Notes:
//
//  Author:     mbend   20 Dec 2000
//
//----------------------------------------------------------------------------

#include "upnpatl.h"
#include "upnp.h"
#include "resource.h"

class ATL_NO_VTABLE CUPnPDeviceHostSetup :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass<CUPnPDeviceHostSetup, &CLSID_UPnPDeviceHostSetup>,
    public IUPnPDeviceHostSetup
{
public:
    CUPnPDeviceHostSetup();
    ~CUPnPDeviceHostSetup();

    DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEHOSTSETUP)

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceHostSetup)

    BEGIN_COM_MAP(CUPnPDeviceHostSetup)
        COM_INTERFACE_ENTRY(IUPnPDeviceHostSetup)
    END_COM_MAP()

    // IUPnPDeviceHostSetup methods
    STDMETHOD(AskIfNotAlreadyEnabled)(/*[out, retval]*/ VARIANT_BOOL * pbEnabled);
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\dll\upnp.cpp ===
// UPnP.cpp : Implementation of DLL Exports.



#include "pch.h"
#pragma hdrstop

#include "resource.h"

#include "UPnPDeviceFinder.h"
#include "enumhelper.h"
#include "UPnPDevices.h"
#include "UPnPDevice.h"
#include "UPnPServices.h"
#include "UPnPService.h"
#include "upnpdocument.h"
#include "upnpdescriptiondoc.h"
#include "soapreq.h"
#include "DeviceHostSetup.h"
#include "DeviceHostICSSupport.h"
#include "testtarget.h"

#include "dlldatax.h"               // proxy/stub defines

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_UPnPDeviceFinder, CUPnPDeviceFinder)
OBJECT_ENTRY(CLSID_UPnPDevices, CUPnPDevices)
OBJECT_ENTRY(CLSID_UPnPDevice, CUPnPDevice)
OBJECT_ENTRY(CLSID_UPnPServices, CUPnPServices)
OBJECT_ENTRY(CLSID_UPnPService, CUPnPServicePublic)
OBJECT_ENTRY(CLSID_UPnPDescriptionDocument, CUPnPDescriptionDoc)
OBJECT_ENTRY(CLSID_SOAPRequest, CSOAPRequest)
OBJECT_ENTRY(CLSID_UPnPDeviceHostSetup, CUPnPDeviceHostSetup)
OBJECT_ENTRY(CLSID_UPnPDeviceHostICSSupport, CUPnPDeviceHostICSSupport)
END_OBJECT_MAP()


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for autogencrap.idl by adding the following
//      files to the Outputs.
//          upnp_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f autogencrapps.mk in the project directory.


// Delay load support
//
#include <delayimp.h>

EXTERN_C
FARPROC
WINAPI
DelayLoadFailureHook (
    UINT            unReason,
    PDelayLoadInfo  pDelayInfo
    );

PfnDliHook __pfnDliFailureHook = DelayLoadFailureHook;


// stuff to avoid unloading DLL while we may get callbacks from WinInet
#define  EXIT_WAIT_MS       5000        // up to 5 seconds for wininet callbacks

extern void WaitForAllDownloadsComplete(DWORD ms);



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    HRESULT hr = S_OK;
    BOOL    bRet = TRUE;

#ifdef _MERGE_PROXYSTUB
    {
        BOOL fResult;

        fResult = PrxDllMain(hInstance, dwReason, lpReserved);
        if (!fResult)
        {
            TraceError("PrxDllMain barfed in DllMain", E_UNEXPECTED);
            return FALSE;
        }
    }
#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeDebugging();

        _Module.Init(ObjectMap, hInstance, &LIBID_UPNPLib);
        DisableThreadLibraryCalls(hInstance);

    } else if (dwReason == DLL_PROCESS_DETACH) {
        _Module.Term();

        WaitForAllDownloadsComplete(EXIT_WAIT_MS);

        TermTestTarget();

        UnInitializeDebugging();
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    {
        HRESULT hr;

        hr = PrxDllCanUnloadNow();
        if (S_OK != hr)
        {
            return S_FALSE;
        }
    }
#endif
   return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    {
        HRESULT hr;

        hr = PrxDllGetClassObject(rclsid, riid, ppv);
        if (S_OK == hr)
        {
            return hr;
        }
    }
#endif
   return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    {
        HRESULT hr;

        hr = PrxDllRegisterServer();
        if (FAILED(hr))
        {
            TraceError("PrxDllRegisterServer barfed in DllRegisterServer",
                       E_UNEXPECTED);
            return hr;
        }
    }
#endif

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Universal Plug and Play API"
#define VER_INTERNALNAME_STR            "upnp.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\enumhelper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpenumhelper.h
//
//  Contents:   Declaration of CEnumHelper
//
//  Notes:      This is a virtual base class which "things that contain
//              lists of dual-interfaced objects" can implement so that
//              CUPnPEnumerator can enumerate their items.
//
//              This class is implemented on the "list" object, and is
//              called by the CUPnPEnumerator object.
//
//----------------------------------------------------------------------------


#ifndef __ENUMHELPER_H_
#define __ENUMHELPER_H_


/////////////////////////////////////////////////////////////////////////////
// CEnumHelper

class CEnumHelper
{
public:
    virtual LPVOID GetFirstItem() = 0;
    virtual LPVOID GetNextNthItem(ULONG ulSkip,
                                  LPVOID pCookie,
                                  ULONG * pulSkipped) = 0;
    virtual HRESULT GetPunk(LPVOID pCookie, IUnknown ** ppunk) = 0;
};

#endif // __ENUMHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\iconutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       iconutil.h
//
//  Contents:   Icon choosing utility functions
//
//  Notes:      Used by CUPnPDeviceNode to choose icons from description docs
//
//----------------------------------------------------------------------------


#ifndef __ICONUTIL_H_
#define __ICONUTIL_H_

CIconPropertiesNode * pipnGetBestIcon(LPCWSTR pszFormat,
                                      ULONG ulX,
                                      ULONG ulY,
                                      ULONG ulBpp,
                                      CIconPropertiesNode * pipnFirst);

#endif //__ICONUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\node.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       node.h
//
//  Contents:   Definition of CNode, the basis for the device tree
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#ifndef __NODE_H_
#define __NODE_H_


class CNode
{
public:
    CNode();
    virtual ~CNode();

    void AddChild(CNode * pnNewChild);

    CNode * GetFirstChild();

    CNode * GetParent();

    CNode * GetNextSibling();

    CNode * GetRoot();

#ifdef NEVER
    CNode * GetNthChild(ULONG ulNeeded, ULONG * pulSkipped);

    CNode * GetFirstSibling();
#endif // NEVER

    BOOL HasParent();

    BOOL HasChildren();

protected:
    void SetParent(CNode * pnParent);
    void SetNextSibling(CNode * pnNextSibling);

private:
// member data
    CNode * _pnParent;
    CNode * _pnFirstChild;
    CNode * _pnLastChild;
    CNode * _pnNextSibling;
};

#endif // __NODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\pch.h ===
#pragma once

//#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
//#define NOCOMM
#define NOCRYPT
//#define NOGDI
//#define NOICONS
#define NOIME
//#define NOMCX
//#define NOMDI
//#define NOMENUS
//#define NOMETAFILE
#define NOSOUND
//#define NOSYSPARAMSINFO
//#define NOWH
//#define NOWINABLE
//#define NOWINRES

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <windows.h>
#include <objbase.h>

#include <devguid.h>
#include <wchar.h>
#include <tchar.h>

#include <wininet.h>

#include <upnp.h>
#include <upnpp.h>

#include "ncmem.h"
#include "ncdefine.h"

#include <upnpatl.h>    // upnp common ATL usage includes
#include <atlctl.h>     // IObjectSafetyImpl
#include <ncbase.h>     // SAFE_RELEASE

#include <msxml2.h>

#include <ncdebug.h>    // our bug-detection utilities
#include <ncxml.h>      // xml dom helper functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UPnP.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPNPDEVICEFINDER            101
#define IDR_UPNPDEVICES                 102
#define IDR_UPNPDEVICE                  103
#define IDR_UPNPSERVICES                104
#define IDR_UPNPSERVICE                 105
#define IDR_UPNPDESCRIPTIONDOC          106
#define IDR_UPNPDEVICEFINDERCALLBACK    107
#define IDR_SOAPREQUEST                 108
#define IDR_DEVICEHOSTSETUP             109
#define IDR_DEVICEHOSTICSSUPPORT        110

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\rehyutil.h ===
/*
 * rehyutil.h
 *
 * Declaration of various utility functions used by the rehydrator.
 *
 * Owner: Shyam Pather (SPather)
 *
 * Copyright 1986-2000 Microsoft Corporation, All Rights Reserved
 */

#ifndef _REHYUTIL_H_
#define _REHYUTIL_H_

#include <pch.h>
#pragma hdrstop

#include "UPnP.h"
#include "rehy.h"
#include "ncstring.h"

extern
HRESULT
HrCreateElementWithType(
                        IN   IXMLDOMDocument *     pDoc,
                        IN   LPCWSTR               pcwszElementName,
                        IN   CONST SST_DATA_TYPE   sdtType,
                        IN   VARIANT               varData,
                        OUT  IXMLDOMElement **     ppElement);

extern
HRESULT
HrGetTypedValueFromElement(IXMLDOMNode * pxdn,
                           CONST SST_DATA_TYPE sdtType,
                           VARIANT * pvarOut);

extern
HRESULT
HrGetTypedValueFromChildElement(IXMLDOMNode * pxdn,
                                CONST LPCWSTR * arypszTokens,
                                CONST ULONG cTokens,
                                CONST SST_DATA_TYPE sdtType,
                                VARIANT * pvarOut);

extern
HRESULT
HrUpdateStateVariable(IN SERVICE_STATE_TABLE_ROW * pSSTRow,
                      IN IXMLDOMNode * pxdn);

extern
VOID
ClearSSTRowValue(IN VARIANT * pvarVal);


extern
HRESULT
HrProcessUPnPError(
    IN  IXMLDOMNode * pxdnUPnPError,
    OUT LONG        * plStatus);

extern
HRESULT
HrExtractFaultInformation(
    IN  ISOAPRequest * psr,
    OUT LONG         * plStatus);

extern
HRESULT
HrCreateVariantSafeArray(
    IN  unsigned long  cElements,
    OUT SAFEARRAY      ** ppsaNew);

#endif  // !_REHYUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\rehy.h ===
/*
 * rehy.h
 *
 * UPnP Rehydrator API declarations.
 *
 * Owner: Shyam Pather (SPather)
 *
 * Copyright 1986-2000 Microsoft Corporation, All Rights Reserved
 */

#ifndef _REHY_H_
#define _REHY_H_

#include <msxml2.h>

#include "upnpservice.h"

const unsigned int MAX_STRING_LENGTH = 0xffff;

extern "C"
HRESULT
HrRehydratorCreateServiceObject(
                              IN    LPCWSTR         pcwszSTI,
                              IN    LPCWSTR         pcwszControlURL,
                              IN    LPCWSTR         pcwszEventSubURL,
                              IN    LPCWSTR         pcwszId,
                              IN        IXMLDOMDocument *       pSCPD,
                              OUT       IUPnPService    **      pNewServiceObject);

extern "C"
HRESULT
HrRehydratorInvokeServiceAction(
    IN  SERVICE_ACTION  * pAction,
    IN  SAFEARRAY       * psaInArgs,
    IN  LPCWSTR         pcwszSTI,
    IN  LPCWSTR         pcwszControlURL,
    IN  OUT SAFEARRAY   ** ppsaOutArgs,
    OUT VARIANT         * pvReturnVal,
    OUT LONG            * plTransportStatus);


extern "C"
HRESULT
HrRehydratorInvokeServiceActionEx(
    IN  SERVICE_ACTION  * pAction,
    IN  SAFEARRAY       * psaInArgs,
    IN  LPCWSTR         pcwszSTI,
    IN  LPCWSTR         pcwszControlURL,
    IN  DWORD_PTR       pControlConnect,
    IN  OUT SAFEARRAY   ** ppsaOutArgs,
    OUT VARIANT         * pvReturnVal,
    OUT LONG            * plTransportStatus);


extern "C"
HRESULT
HrRehydratorQueryStateVariable(
    IN  OUT SERVICE_STATE_TABLE_ROW * psstr,
    IN  LPCWSTR                     pcwszSTI,
    IN  LPCWSTR                     pcwszControlURL,
    OUT LONG                        * plTransportStatus);


extern "C"
HRESULT
HrRehydratorQueryStateVariableEx(
    IN  OUT SERVICE_STATE_TABLE_ROW * psstr,
    IN  LPCWSTR                     pcwszSTI,
    IN  LPCWSTR                     pcwszControlURL,
    IN  DWORD_PTR                   pControlConnect,
    OUT LONG                        * plTransportStatus);


extern "C"
HRESULT 
HrCreateControlConnect(
    IN      LPCWSTR     bstrURL, 
    OUT     DWORD_PTR *     ppControlConnect);


extern "C"
HRESULT 
HrReleaseControlConnect(DWORD_PTR pConnect);


#endif // ! _REHY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\soapreq.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S O A P R E Q . H
//
//  Contents:   Definition of SOAP Request Class.
//
//  Notes:
//
//  Author:     SPather     January 16, 2000
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _SOAPREQ_H_
#define _SOAPREQ_H_

#include "resource.h"
#include "upnpatl.h"
#include "upnp.h"

#include <msxml2.h>
#include <wininet.h>

const WCHAR WSZ_SOAP_NAMESPACE_URI[] = L"http://schemas.xmlsoap.org/soap/envelope/";

class /* ATL_NO_VTABLE */ CSOAPRequest :
    public CComObjectRootEx <CComSingleThreadModel>,
    public CComCoClass<CSOAPRequest, &CLSID_SOAPRequest>,
    public ISOAPRequest
{
public:

    CSOAPRequest();

    ~CSOAPRequest();

DECLARE_REGISTRY_RESOURCEID(IDR_SOAPREQUEST)

DECLARE_NOT_AGGREGATABLE(CSOAPRequest)

    BEGIN_COM_MAP(CSOAPRequest)
        COM_INTERFACE_ENTRY(ISOAPRequest)
    END_COM_MAP()

    // ISOAPRequest Methods

    // Initialization

    STDMETHOD(Open)(/*[in]*/ BSTR bstrMethodName,
                    /*[in]*/ BSTR bstrInterfaceName,
                    /*[in]*/ BSTR bstrMethodNameSpace);

    // Parameter Manipulation

    STDMETHOD(SetParameter)(/*[in]*/ BSTR       bstrName,
                            /*[in]*/ IUnknown   * pUnkNewValue);

    // Invoke

    STDMETHOD(Execute)(/*[in]*/ BSTR bstrTargetURI,
                        /*[in]*/ DWORD_PTR pControlConnect);

    // Feedback

    STDMETHOD(get_ResponseElement)(/*[out, retval]*/ IUnknown   ** ppUnkValue);

    STDMETHOD(get_ResponseFaultDetail)(/*[out, reval]*/ IUnknown ** ppUnkValue);

    STDMETHOD(get_ResponseHTTPStatus)(/*[out, retval]*/ long    * plValue);

private:
    // Helper functions.

    VOID    Cleanup();
    VOID    CleanupFeedbackData();

    HRESULT HrCreateDocumentObject();
    HRESULT HrCreateElement(IN  LPCWSTR     pcwszElementName,
                            IN  LPCWSTR     pcwszNamespaceURI,
                            OUT IXMLDOMNode **ppxdnNewElt);
    HRESULT HrCreateBody(IN     BSTR            bstrMethodName,
                         IN     BSTR            bstrMethodNameSpace,
                         OUT    IXMLDOMNode     ** ppxdnBody);
    HRESULT HrGetSOAPEnvelopeChild(IN   LPCWSTR     pcwszChildName,
                                   OUT  IXMLDOMNode ** ppxdnChildNode);
    HRESULT HrGetBodyNode(OUT   IXMLDOMNode     ** ppxdnBody);
    HRESULT HrGetHeaderNode(OUT IXMLDOMNode     ** ppxdnHeader);

    HRESULT HrPOSTRequest(IN    BSTR    bstrTargetURI,
                            IN  DWORD_PTR   pControlConnect,
                            IN  DWORD       dwRequestType);

    HRESULT HrSetPOSTHeaders(OUT BSTR * pszHeaders);
    HRESULT HrSetMPOSTHeaders(OUT BSTR * pszHeaders);

    HRESULT HrProcessResponse();
    HRESULT HrParseResponse(IN  IXMLDOMElement  * pxdeResponseRoot);
    HRESULT HrParseMethodResponse(IN    IXMLDOMNode * pxdnMethodResponse);
    HRESULT HrParseFault(IN IXMLDOMNode * pxdnFaultNode);

    HRESULT HrSetEncodingStyleAttribute(IXMLDOMNode * pxdn);

    BOOL fIsSOAPElement(IN IXMLDOMNode * pxdn,
                        IN LPCWSTR pcwszSOAPElementBaseName);


    IXMLDOMDocument * m_pxdd;
    IXMLDOMNode     * m_pxdnEnvelope;

    BSTR    m_bstrMethodName;
    BSTR    m_bstrInterfaceName;

    long    m_lHTTPStatus;
    BSTR    m_bstrHTTPStatusText;

    BSTR    m_bstrResponseBody;

    IXMLDOMNode * m_pxdnResponseHeaders;

    BSTR    m_bstrFaultCode;
    BSTR    m_bstrFaultString;

    IXMLDOMNode * m_pxdnFaultDetail;


    IXMLDOMNode * m_pxdnResponseElement;

};

#endif // _SOAPREQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\testtarget.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       TESTTARGET.H
//
//  Contents:   Header for public function test for target computer
//
//  Notes:
//
//  Author:     henryr   8 Nov 2001
//
//----------------------------------------------------------------------------


#define TARGET_COMPLETE_FAIL    1
#define TARGET_COMPLETE_OK      2
#define TARGET_COMPLETE_ABORT   3


// public methods
BOOL TestTargetUrlOk(CONST SSDP_MESSAGE * pSsdpMessage,
                        SSDP_CALLBACK_TYPE sctType,
                        DWORD* cmsecMaxDelay,
                        DWORD* cmsecMinDelay);

VOID TargetAttemptCompletedW(LPWSTR wszUrl, int code);

VOID TargetAttemptCompletedA(LPSTR szUrl, int code);

BOOL InitTestTarget();

VOID TermTestTarget();

BOOL ValidateTargetUrlWithHostUrlW( LPCWSTR wszHostUrl, 
                                            LPCWSTR wszTargetUrl);

BOOL ValidateTargetUrlWithHostUrlA(LPCSTR szHostUrl, LPCSTR szTargetUrl);

BOOL fValidateUrl(const ULONG cElems, 
                    const DevicePropertiesParsingStruct dppsInfo [], 
                    const LPCWSTR arypszReadValues [], 
                    const LPCWSTR wszUrl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\soapsink.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       soapsink.h
//
//  Contents:   declaration of CSOAPRequestNotifySink
//
//  Notes:      Implementation of IDispatch that forwards
//              OnChanged events to the generic soap request object.
//
//----------------------------------------------------------------------------


#ifndef __CSOAPSINK_H_
#define __CSOAPSINK_H_

struct ControlConnect
{
    CRITICAL_SECTION    cs;
    HINTERNET           hConnect;
    INT                 nRefCnt;
    LPTSTR              pszHost;
    INTERNET_PORT       nPort;
};

HRESULT     CreateControlConnect(LPCTSTR pszURL, ControlConnect* * ppControlConnect);
HINTERNET   GetInternetConnect(ControlConnect* pConnection);
HRESULT     ReleaseControlConnect(ControlConnect* pConnection);


class CSOAPRequestAsync
{
public:
    CSOAPRequestAsync();
    ~CSOAPRequestAsync();

    BOOL Init(IN HANDLE* hEvent,
                IN  BSTR  pszTargetURI,
                IN  BSTR  pszRequest,
                IN  BSTR  pszHeaders,
                IN  BSTR  pszBody,
                DWORD_PTR pControlConnect);

    VOID DeInit();

    BOOL GetResults(long * plHTTPStatus,
                      BSTR * pszHTTPStatusText,
                      BSTR * pszResponse);

    VOID ExecuteRequest();

private:
    BOOL    m_bInProgress;
    BOOL    m_bAlive;
    LPTSTR  m_pszTargetURI;
    LPTSTR  m_pszRequest;
    LPTSTR  m_pszHeaders;
    LPSTR   m_pszBody;
    LPSTR   m_pszResponse;
    long    m_lHTTPStatus;
    LPTSTR  m_pszHTTPStatusText;
    HANDLE  m_hThread;
    HANDLE  m_hEvent;

    ControlConnect* m_pControlConnect;
};

#endif // __CSOAPSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpcommon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P C O M M O N . H 
//
//  Contents:   Common functions for upnp.dll
//
//  Notes:      
//
//  Author:     jeffspr   11 Nov 1999
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _UPNPCOMMON_H_
#define _UPNPCOMMON_H_

HRESULT HrSsdpStartup(BOOL * pfSsdpInitialized);

#endif //_UPNPCOMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdevicenode.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdevicenode.h
//
//  Contents:   Declaration of CUPnPDeviceNode
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#ifndef __UPNPDEVICENODE_H_
#define __UPNPDEVICENODE_H_

#include "resource.h"       // main symbols

class CNode;
class CUPnPDescriptionDoc;
class CUPnPDevice;
class CUPnPServiceNodeList;
class CIconPropertiesNode;


/////////////////////////////////////////////////////////////////////////////
// CUPnPDeviceNode
class CUPnPDeviceNode :
    public CNode
{
public:
    CUPnPDeviceNode();

    ~CUPnPDeviceNode();

public:

// IUPnPDevice Methods
    STDMETHOD(get_IsRootDevice)     (/* [out] */ VARIANT_BOOL * pvarb);

    STDMETHOD(get_RootDevice)       (/* [out] */ IUPnPDevice ** ppudDeviceRoot);

    STDMETHOD(get_ParentDevice)     (/* [out] */ IUPnPDevice ** ppudDeviceParent);

    STDMETHOD(get_HasChildren)      (/* [out] */ VARIANT_BOOL * pvarb);

    STDMETHOD(get_Children)         (/* [out] */ IUPnPDevices ** ppudChildren);

    STDMETHOD(get_UniqueDeviceName) (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_FriendlyName)     (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_Type)             (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_PresentationURL)  (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ManufacturerName) (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ManufacturerURL)  (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ModelName)        (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ModelNumber)      (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_Description)      (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ModelURL)         (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_UPC)              (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_SerialNumber)     (/* [out] */ BSTR * pbstr);

    STDMETHOD(IconURL)              (/* in */  BSTR bstrEncodingFormat,
                                     /* in */  LONG lSizeX,
                                     /* in */  LONG lSizeY,
                                     /* in */  LONG lBitDepth,
                                     /* out */ BSTR * pbstrIconUrl);

    STDMETHOD(get_Services)         (/* [out] */ IUPnPServices ** ppusServices);

// IUPnPDeviceDocumentAccess methods

    STDMETHOD(GetDocumentURL)(/*[out, retval]*/ BSTR * pbstrDocument);

// Public methods
    HRESULT HrInit(IXMLDOMNode * pxdn, CUPnPDescriptionDoc * pdoc, BSTR bstrUrl);

    // returns the COM wrapper for the current device node.
    // if one exists, it is addref()d and returned.
    // if one does not exist, one is created, and its refcount set to 1.
    HRESULT HrGetWrapper(IUPnPDevice ** ppud);

    // called by our wrapper when our wrapper goes away.
    // only our wrapper can call this
    void Unwrap();

    // returns the first device node with the specified udn
    // in the subtree rootead at this node.
    CUPnPDeviceNode * UdnGetDeviceByUdn(LPCWSTR pszUdn);


// Static parsing info

    // NOTE: REORDER THIS ON PAIN OF DEATH
    enum DeviceProperties { dpUdn = 0,
                            dpFriendlyName,
                            dpType,
                            dpPresentationUrl,
                            dpManufacturerName,
                            dpManufacturerUrl,
                            dpModelName,
                            dpModelNumber,
                            dpDescription,
                            dpModelUrl,
                            dpUpc,
                            dpSerialNumber,
         // --- add new values immediately above this line ---
                            dpLast };
    // NOTE: REORDER THIS ON PAIN OF DEATH
    //  after adding a property here, add its DevicePropertiesParsingStruct
    //  info to upnpdevicenode.cpp

protected:
// Internal Methods

    HRESULT HrReadStringValues(IXMLDOMNode * pxdn);

    HRESULT HrReadIconList(IXMLDOMNode * pxdn);

    HRESULT HrCreateChildren(IXMLDOMNode * pxdn);

    HRESULT HrInitServices(IXMLDOMNode * pxdn);

    HRESULT HrReturnStringValue(LPCWSTR pszValue, BSTR * pbstr);

    // returns TRUE if the given string is the same as our UDN
    BOOL fIsThisOurUdn(LPCWSTR pszUdn);

private:
// member data
    // the description doc that contains us.  we need this to create
    // a wrapper, as well as for its base url.
    CUPnPDescriptionDoc * m_pdoc;

    // our COM wrapper object.  this is around from when someone
    // calls GetWrapper() for the first time until the wrapper
    // is released (which may or may not have anything to do with
    // when we're going to be released).
    CComObject<CUPnPDevice> * m_pud;

    // the list of all our services
    CUPnPServiceNodeList m_usnlServiceList;

    // String-valued properties
    LPWSTR m_arypszStringProperties [dpLast];

// static parsing info
    static const DevicePropertiesParsingStruct s_dppsParsingInfo [/* dpLast */];

    // Icon list.  This must be non-NULL when we are successfully initialized
    CIconPropertiesNode * m_pipnIcons;

    BSTR m_bstrUrl;
};

//
class CIconPropertiesNode
{
public:
    CIconPropertiesNode();
    ~CIconPropertiesNode();

    HRESULT HrInit(IXMLDOMNode * pxdn, LPCWSTR pszBaseUrl);

    LPWSTR m_pszFormat;
    ULONG  m_ulSizeX;
    ULONG  m_ulSizeY;
    ULONG  m_ulBitDepth;
    LPWSTR m_pszUrl;

    CIconPropertiesNode * m_pipnNext;

    // NOTE: REORDER THIS ON PAIN OF DEATH
    enum IconProperties { ipMimetype = 0,
                          ipWidth,
                          ipHeight,
                          ipDepth,
                          ipUrl,
         // --- add new values immediately above this line ---
                          ipLast };
    // NOTE: REORDER THIS ON PAIN OF DEATH
    //  after adding a property here, add its DevicePropertiesParsingStruct
    //  info to upnpdevicenode.cpp

    static const DevicePropertiesParsingStruct s_dppsIconParsingInfo [/* ipLast */];
};

#endif //__UPNPDEVICENODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdevicefinder.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P N P D E V I C E F I N D E R . H
//
//  Contents:   Declaration of the CUPnPDeviceFinder class
//
//  Notes:
//
//  Author:     jeffspr   18 Nov 1999
//
//----------------------------------------------------------------------------

#ifndef __UPNPDEVICEFINDER_H_
#define __UPNPDEVICEFINDER_H_

#include "resource.h"       // main symbols
#include "ncbase.h"
#include "ssdpapi.h"
#include "UPnPDevices.h"
#include "list.h"

class CUPnPDeviceFinder;
class CUPnPDeviceFinderCallback;
class CUPnPDescriptionDoc;
interface IUPnPDeviceFinderCallback;

enum DFC_TYPE
{
    DFC_NEW_DEVICE,
    DFC_REMOVE_DEVICE,
    DFC_DONE,
};

enum DF_ADD_TYPE
{
    DF_ADD_SEARCH_RESULT,
    DF_ADD_NOTIFY,
    DF_REMOVE,
};

enum DFC_SEARCHSTATE
{
    DFC_SS_UNINITIALIZED,
    DFC_SS_INITIALIZED,
    DFC_SS_STARTED,
    DFC_SS_DONE,
    DFC_SS_CLEANUP,
};

enum DFC_CALLBACKFIRED
{
    DFC_CBF_NOT_FIRED,          // hasn't been stared/completed
    DFC_CBF_CURRENTLY_FIRING,   // is presently being called
    DFC_CBF_FIRED,              // has been called, object can be deleted
};

struct DFC_DEVICE_FINDER_INFO
{
    LIST_ENTRY                  m_link;
    CComObject<CUPnPDeviceFinderCallback> * m_pdfc;
};

struct DFC_DOCUMENT_LOADING_INFO
{
    LIST_ENTRY                m_link;
    CComObject<CUPnPDescriptionDoc> * m_pdoc;
    BSTR                              m_bstrUDN;

    BSTR                              m_bstrUrl;

    BOOL                              m_fSearchResult;
    DWORD                             m_cbfCallbackFired;
    GUID                        m_guidInterface;
};

/////////////////////////////////////////////////////////////////////////////
// CUPnPDeviceFinder
class ATL_NO_VTABLE CUPnPDeviceFinder :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUPnPDeviceFinder, &CLSID_UPnPDeviceFinder>,
    public IDispatchImpl<IUPnPDeviceFinder, &IID_IUPnPDeviceFinder, &LIBID_UPNPLib>
{
private:
    LIST_ENTRY      m_FinderList;
    BOOL            m_fSsdpInitialized;
    LONG            m_lNextFinderCookie;

    HRESULT HrAddDeviceToCollection(CComObject<CUPnPDevices> *  pCollection,
                                    CONST SSDP_MESSAGE *        pSsdpMessage);

    HRESULT HrAllocFinder(CComObject<CUPnPDeviceFinderCallback> ** ppdfc);
    VOID    DeleteFinder(CComObject<CUPnPDeviceFinderCallback> * pdfc);
    CComObject<CUPnPDeviceFinderCallback> * PdfcFindFinder(LONG lFind);

public:
    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPDEVICEFINDER)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFinder)

    BEGIN_COM_MAP(CUPnPDeviceFinder)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinder)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

    CUPnPDeviceFinder(VOID);

// IUPnPDeviceFinder
public:
    STDMETHOD(FindByType)(/* [in] */ BSTR bstrTypeURI,
                          /* [in] */ DWORD dwFlags,
                          /* [out, retval] */ IUPnPDevices ** pDevices);

    STDMETHOD(CreateAsyncFind)(/* [in] */ BSTR bstrTypeURI,
                               /* [in] */ DWORD dwFlags,
                               /* [in] */ IUnknown __RPC_FAR *punkDeviceFinderCallback,
                               /* [retval][out] */ LONG __RPC_FAR *plFindData);

    STDMETHOD(StartAsyncFind)(/* [in] */ LONG lFindData);

    STDMETHOD(CancelAsyncFind)(/* [in] */ LONG lFindData);

    STDMETHOD(FindByUDN)(/*[in]*/ BSTR bstrUDN,
                        /*[out, retval]*/ IUPnPDevice ** pDevice);

// ATL methods
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

// ssdp callback methods
    static VOID WINAPI NotificationCallbackHelper(LPVOID pvContext, BOOLEAN fTimeOut);
    static VOID NotificationCallback(SSDP_CALLBACK_TYPE sctType,
                                     CONST SSDP_MESSAGE * pSsdpMessage,
                                     LPVOID pContext);

};


class ATL_NO_VTABLE CUPnPDeviceFinderCallback :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IUPnPPrivateCallbackHelper,
    public IUPnPDescriptionDocumentCallback
{
public:
    CUPnPDeviceFinderCallback();
    ~CUPnPDeviceFinderCallback();

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFinderCallback)

    BEGIN_COM_MAP(CUPnPDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPPrivateCallbackHelper)
        COM_INTERFACE_ENTRY(IUPnPDescriptionDocumentCallback)
    END_COM_MAP()

    friend static VOID WINAPI CUPnPDeviceFinder::NotificationCallbackHelper(LPVOID pvContext, BOOLEAN fTimeOut);
    friend static VOID CUPnPDeviceFinder::NotificationCallback(SSDP_CALLBACK_TYPE sctType,
                                     CONST SSDP_MESSAGE * pSsdpMessage,
                                     LPVOID pContext);


// IUPnPPrivateCallbackHelper
    STDMETHOD(HandleDeviceAdd)    (/* [in] */ LPWSTR szwLocation,
                                   /* [in] */ BSTR bstrUdn,
                                   /* [in] */ BOOL fSearchResult,
                                   /* [in] */ GUID *guidInterface);

    STDMETHOD(HandleDeviceRemove) (/* [in] */ BSTR bstrUdn);

    STDMETHOD(HandleDone)         (VOID);

// IUPnPDescritionDocumentCallback
    STDMETHOD(LoadComplete)       (/* [in] */ HRESULT hrLoadResult);


// Internal methods
    HRESULT HrInit(IUnknown *punkCallback, LPCSTR pszSearchType, LONG lClientCookie);

    VOID DeInitSsdp(VOID);

    VOID DeInit(VOID);

    HRESULT HrStartSearch();

    HRESULT HrAllocLoader(/* in */ LPCWSTR pszUdn,
                          /* in */ BOOL fSearchResult,
                          /* in */ GUID *guidInterface,
                          /* out */ DFC_DOCUMENT_LOADING_INFO ** ppddli);

    VOID    DeleteLoader(DFC_DOCUMENT_LOADING_INFO * pdli);

    HRESULT HrEnsureSearchDoneFired();

    VOID    SetSearchState(DFC_SEARCHSTATE ss);

    DFC_SEARCHSTATE GetSearchState() const;

    VOID    RemoveOldLoaders();

    BOOL    IsBusy(); // Is one of our loaders still running?

    LONG    GetClientCookie() const;

private:
    HANDLE                      m_hSearch;
    HANDLE                      m_hNotify;
    CHAR *                      m_pszSearch;
    IUnknown *                  m_punkCallback;
    DWORD                       m_dwGITCookie;
    DFC_SEARCHSTATE             m_ss;
    BOOL                        m_fSsdpSearchDone;
    BOOL                        m_fCanceled;
    LONG                        m_lClientCookie;
    HANDLE                      m_hTimerQ;
    LONG                        m_lBusyCount;

#ifdef DBG
    long                        m_nThreadId;
#endif // DBG

// Loaders
    LIST_ENTRY                  m_LoaderList;

    CRITICAL_SECTION            m_cs;
    BOOL                        m_fCleanup;
};

class ATL_NO_VTABLE CFindSyncDeviceFinderCallback :
    public CComObjectRootEx<CComObjectThreadModel>,
    public IUPnPDeviceFinderCallback
{
public:
    CFindSyncDeviceFinderCallback();

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CFindSyncDeviceFinderCallback)

    BEGIN_COM_MAP(CFindSyncDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
    END_COM_MAP()

// IUPnPDeviceFinderCallback methods
    STDMETHOD(DeviceAdded)   (/* [in] */ LONG lFindData,
                              /* [in] */ IUPnPDevice * pDevice);

    STDMETHOD(DeviceRemoved) (/* [in] */ LONG lFindData,
                              /* [in] */ BSTR bstrUDN);

    STDMETHOD(SearchComplete)(/* [in] */ LONG lFindData);

// local methods
    HRESULT HrInit(HANDLE hEventSearchComplete,
                   CComObject<CUPnPDevices> * pSearchResults);

// ATL Methods
    HRESULT FinalRelease();

private:
    VOID SignalEvent();

protected:
    HANDLE m_hEventComplete;
    CComObject<CUPnPDevices> * m_pSearchResults;
};

class ATL_NO_VTABLE CFindByUdnDeviceFinderCallback :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IUPnPDeviceFinderCallback
{
public:
    CFindByUdnDeviceFinderCallback();

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CFindByUdnDeviceFinderCallback)

    BEGIN_COM_MAP(CFindByUdnDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
    END_COM_MAP()

// IUPnPDeviceFinderCallback methods
    STDMETHOD(DeviceAdded)   (/* [in] */ LONG lFindData,
                              /* [in] */ IUPnPDevice * pDevice);

    STDMETHOD(DeviceRemoved) (/* [in] */ LONG lFindData,
                              /* [in] */ BSTR bstrUDN);

    STDMETHOD(SearchComplete)(/* [in] */ LONG lFindData);

// local methods
    HRESULT HrInit(LPCWSTR pszDesiredUdn, HANDLE hEventLoaded);

    // returns an AddRef()'d pointer to the found device, or NULL if no
    // device with the given UDN was found
    IUPnPDevice * GetFoundDevice() const;

// ATL Methods
    HRESULT FinalRelease();

private:
    VOID SignalEvent();
    static VOID WINAPI LoadDocTimerCallback(LPVOID pvContext, BOOLEAN fTimeOut);

protected:
    HANDLE m_hEventLoaded;
    LPWSTR m_pszDesiredUdn;
    IUPnPDevice * m_pud;
};

class CFinderCollector {
public:
    CFinderCollector() {
        InitializeListHead(&m_FinderList);
    }
    ~CFinderCollector() {
        CleanUp(TRUE);
    }
    VOID Add(CComObject<CUPnPDeviceFinderCallback>* pdfc);
    VOID CleanUp(BOOL bForceRemoval);

private:
    LIST_ENTRY m_FinderList;
};



#endif //__UPNPDEVICEFINDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdevices.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       devices.h
//
//  Contents:   Declaration of CUPnPDevices, our IUPnPDevices object
//
//  Notes:      Also implements CEnumHelper so that the generic enumerator
//              classes can use it.
//
//----------------------------------------------------------------------------

#ifndef __UPNPDEVICES_H_
#define __UPNPDEVICES_H_

#include "resource.h"       // for IDR_UPNPDEVICES
#include "EnumHelper.h"

// An element in the Devices collection linked list.
// Hungarian: dln
struct DEVICE_LIST_NODE
{
    IUPnPDevice * m_pud;
    DEVICE_LIST_NODE * m_pdlnNext;
};

/////////////////////////////////////////////////////////////////////////////
// CUPnPDevices
class ATL_NO_VTABLE CUPnPDevices :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUPnPDevices, &CLSID_UPnPDevices>,
    public IDispatchImpl<IUPnPDevices, &IID_IUPnPDevices, &LIBID_UPNPLib>,
    public CEnumHelper
{
public:
    CUPnPDevices();
    ~CUPnPDevices();

    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPDEVICES)

    DECLARE_NOT_AGGREGATABLE(CUPnPDevices)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CUPnPDevices)
        COM_INTERFACE_ENTRY(IUPnPDevices)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

public:
// IUPnPDevices Methods
    STDMETHOD(get_Count)    (/* [retval][out] */ LONG * plCount);

    STDMETHOD(get__NewEnum) (/* [retval][out] */ LPUNKNOWN * ppunk);

    STDMETHOD(get_Item)     (/* [in] */ BSTR bstrUDN,
                             /* [retval][out] */ IUPnPDevice ** ppDevice);

// CEnumHelper methods
    LPVOID GetFirstItem();
    LPVOID GetNextNthItem(ULONG ulSkip,
                          LPVOID pCookie,
                          ULONG * pulSkipped);
    HRESULT GetPunk(LPVOID pCookie, IUnknown ** ppunk);

// ATL Methods
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

// Internal Methods
    HRESULT HrAddDevice(IUPnPDevice * pud);

    void AddToEnd(DEVICE_LIST_NODE * pdlnNew);
    DEVICE_LIST_NODE * pdlnFindDeviceByUdn(LPCWSTR pszUdn);

private:
    DEVICE_LIST_NODE * m_pdlnFirst;
    DEVICE_LIST_NODE * m_pdlnLast;
};

#endif //__UPNPDEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdevice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdevice.h
//
//  Contents:   Declaration of CUPnPDevice.
//
//  Notes:      This is simply a COM wrapper for a CUPnPDeviceNode.
//
//----------------------------------------------------------------------------


#ifndef __UPNPDEVICE_H_
#define __UPNPDEVICE_H_

#include "resource.h"       // main symbols

class CUPnPDeviceNode;

/////////////////////////////////////////////////////////////////////////////
// CUPnPDevice
class ATL_NO_VTABLE CUPnPDevice :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUPnPDevice, &CLSID_UPnPDevice>,
    public IDispatchImpl<IUPnPDevice, &IID_IUPnPDevice, &LIBID_UPNPLib>,
    public IUPnPDeviceDocumentAccess
{
public:
    CUPnPDevice();

    virtual ~CUPnPDevice();

    DECLARE_NOT_AGGREGATABLE(CUPnPDevice)

    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPDEVICE)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CUPnPDevice)
        COM_INTERFACE_ENTRY(IUPnPDevice)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IUPnPDeviceDocumentAccess)
    END_COM_MAP()

public:

// IUPnPDevice Methods
    STDMETHOD(get_IsRootDevice)     (/* [out] */ VARIANT_BOOL * pvarb);

    STDMETHOD(get_RootDevice)       (/* [out] */ IUPnPDevice ** ppudDeviceRoot);

    STDMETHOD(get_ParentDevice)     (/* [out] */ IUPnPDevice ** ppudDeviceParent);

    STDMETHOD(get_HasChildren)      (/* [out] */ VARIANT_BOOL * pvarb);

    STDMETHOD(get_Children)         (/* [out] */ IUPnPDevices ** ppudChildren);

    STDMETHOD(get_UniqueDeviceName) (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_FriendlyName)     (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_Type)             (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_PresentationURL)  (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ManufacturerName) (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ManufacturerURL)  (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ModelName)        (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ModelNumber)      (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_Description)      (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_ModelURL)         (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_UPC)              (/* [out] */ BSTR * pbstr);

    STDMETHOD(get_SerialNumber)     (/* [out] */ BSTR * pbstr);

    STDMETHOD(IconURL)              (/* in */  BSTR bstrEncodingFormat,
                                     /* in */  LONG lSizeX,
                                     /* in */  LONG lSizeY,
                                     /* in */  LONG lBitDepth,
                                     /* out */ BSTR * pbstrIconUrl);

    STDMETHOD(get_Services)         (/* [out] */ IUPnPServices ** ppusServices);

// IUPnPDeviceDocumentAccess methods

    STDMETHOD(GetDocumentURL)(/*[out, retval]*/ BSTR * pbstrDocument);

// ATL Methods
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

// Internal Methods

    // pdevnode is the node which we're wrapping.  we forward all
    //   calls to this node, and tell this node when we get destroyed
    // punk is some pointer that we need to keep our wrapped object around
    //   note that ref-ing this doesn't guarentee that our object will
    //   stay around, but it's how we signal that we'd _like_ to keep
    //   it around
    void Init(CUPnPDeviceNode * pdevnode, IUnknown * punk);
    void Deinit();

// member data
   CUPnPDeviceNode * _pdevnode;
   IUnknown * _punk;
};

#endif //__UPNPDEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdescriptiondoc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdescriptiondoc.h
//
//  Contents:   Declaration of UPnPDescriptionDoc
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#ifndef __UPNPDESCRIPTIONDOC_H_
#define __UPNPDESCRIPTIONDOC_H_

#include "resource.h"       // main symbols

class CUPnPDevice;
class CUPnPDocument;
class CUPnPDeviceNode;

/////////////////////////////////////////////////////////////////////////////
// CUPnPDescriptionDoc
class ATL_NO_VTABLE CUPnPDescriptionDoc :
    public CComCoClass<CUPnPDescriptionDoc, &CLSID_UPnPDescriptionDocument>,
    public IDispatchImpl<IUPnPDescriptionDocument, &IID_IUPnPDescriptionDocument, &LIBID_UPNPLib>,
    public CUPnPDocument
{
public:
    CUPnPDescriptionDoc();

    ~CUPnPDescriptionDoc();

    DECLARE_PROTECT_FINAL_CONSTRUCT();

    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPDESCRIPTIONDOC)

    DECLARE_NOT_AGGREGATABLE(CUPnPDescriptionDoc)

    BEGIN_COM_MAP(CUPnPDescriptionDoc)
        COM_INTERFACE_ENTRY(IUPnPDescriptionDocument)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_CHAIN(CUPnPDocument)
    END_COM_MAP()

public:

// IUPnPDescriptionDocument Methods
    STDMETHOD(get_ReadyState)   (/* [out] */ long * plReadyState);

    STDMETHOD(Load)             (/* [in] */ BSTR bstrUrl);

    STDMETHOD(LoadAsync)        (/* [in] */ BSTR bstrUrl,
                                 /* [in] */ IUnknown * punkCallback);

    STDMETHOD(get_LoadResult)   (/* [out] */ long * plError);

    STDMETHOD(Abort)            ( void );

    STDMETHOD(RootDevice)       (/* [out] */ IUPnPDevice ** ppudRootDevice);

    STDMETHOD(DeviceByUDN)      (/* [in] */ BSTR bstrUDN,
                                 /* [out] */ IUPnPDevice ** ppudDevice);

// CUPnPDocument virtual Methods

    HRESULT Initialize(LPVOID pvCookie);

    HRESULT OnLoadComplete();

    HRESULT OnLoadReallyDone();

// ATL Methods
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

// Internal Methods

    // calls the approprate member of _punkCallback when the load completes
    HRESULT HrFireCallback(HRESULT hrLoadResult);

// fun data
    // device object representing the root device
    CUPnPDeviceNode * _pudn;

    IUnknown * _punkCallback;
};

#endif //__UPNPDESCRIPTIONDOC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdocumentbsc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocumentbsc.h
//
//  Contents:   declaration of CUPnPDocumentBSC
//
//  Notes:      a helper class that implements IBindStatusCallback
//              and sends notifiations to a CUPnPDocument
//
//----------------------------------------------------------------------------


#ifndef __UPNPDOCUMENTBSC_H_
#define __UPNPDOCUMENTBSC_H_

#include "resource.h"       // main symbols


class ATL_NO_VTABLE CUPnPDocumentBSC :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IBindStatusCallback
{
public:

    CUPnPDocumentBSC();

    ~CUPnPDocumentBSC();

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CUPnPDocumentBSC)

    BEGIN_COM_MAP(CUPnPDocumentBSC)
        COM_INTERFACE_ENTRY(IBindStatusCallback)
    END_COM_MAP()


// IBindStatusCallback Methods

    // shouldn't be called
    STDMETHOD(GetBindInfo)      (/* [out] */ DWORD *grfBINDF,
                                 /* [unique][out][in] */ BINDINFO *pbindinfo);

    STDMETHOD(OnStartBinding)   (/* [in] */ DWORD dwReserved,
                                 /* [in] */ IBinding *pib);

    STDMETHOD(GetPriority)      (/* [out] */ LONG *pnPriority);

    STDMETHOD(OnProgress)       (/* [in] */ ULONG ulProgress,
                                 /* [in] */ ULONG ulProgressMax,
                                 /* [in] */ ULONG ulStatusCode,
                                 /* [in] */ LPCWSTR szStatusText);

    // shouldn't be called
    STDMETHOD(OnDataAvailable)  (/* [in] */ DWORD grfBSCF,
                                 /* [in] */ DWORD dwSize,
                                 /* [in] */ FORMATETC *pformatetc,
                                 /* [in] */ STGMEDIUM *pstgmed);

    // shouldn't be called
    STDMETHOD(OnObjectAvailable)(/* [in] */ REFIID riid,
                                 /* [iid_is][in] */ IUnknown *punk);

    STDMETHOD(OnLowResource)    (/* [in] */ DWORD dwReserved);

    STDMETHOD(OnStopBinding)    (/* [in] */ HRESULT hresult,
                                 /* [unique][in] */ LPCWSTR szError);

// ATL Methods
    HRESULT FinalConstruct();

    HRESULT FinalRelease();


// Internal Methods
    HRESULT Init(CUPnPDocument * pdoc, IBindCtx * pbc, ULONG ulNumFormats,
                 const LPCTSTR * arylpszContentTypes, BOOL fAsync);

    void    Deinit(IBindCtx * pbc);

    HRESULT Abort();

    BOOL    IsBinding();


    static
    HRESULT EnumFormatEtcFromLPCTSTRArray(ULONG ulNumFormats,
                                          const LPCTSTR * arylpszContentTypes,
                                          IEnumFORMATETC ** ppefc);

// Our data
    CUPnPDocument * _pdoc;

    // this will be valid from when we're init()ed until when we stop binding
    // (either through a load finishing or being aborted).

    IBindStatusCallback * _pbscOld;

    // this is valid only when a binding operation is in progress
    //  (e.g. OnStartBinding has been called, but OnStopBinding hasn't)
    //  this can only be freed through OnStopBinding or Abort
    IBinding * _pBinding;

    BOOL _fIsBinding;
    BOOL _fAsync;
};

#endif // __UPNPDOCUMENTBSC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpservicenode.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservicenode.h
//
//  Contents:   Declaration of CUPnPServiceNode
//
//  Notes:      This class performs two things:
//               - stores the state needed to create a service object
//               - calls CreateServiceObject when a service object is
//                 needed
//
//              IUPnPService methods are not implemented here, but on the
//              CUPnPService object.
//
//----------------------------------------------------------------------------


#ifndef __UPNPSERVICENODE_H_
#define __UPNPSERVICENODE_H_


class CUPnPDocument;
class CUPnPDescriptionDoc;

interface IXMLDOMNode;
interface IUPnPService;

/////////////////////////////////////////////////////////////////////////////
// UPnPServiceNode

class CUPnPServiceNode
{
public:
    CUPnPServiceNode();

    ~CUPnPServiceNode();

// Internal Methods
    // inits a service node from an xml <service> element, using the
    // given base url (which may be NULL) to fully-qualify any relative
    // urls in the service tag
    HRESULT HrInit(IXMLDOMNode * pxdn, LPCWSTR pszBaseUrl);

    // returns a service object initialized and ready to control the
    // given service.
    // The specified pDoc is asked if the given service object may
    // be created given the current security settings that it knows about.
    HRESULT HrGetServiceObject(IUPnPService ** ppud,
                               CUPnPDescriptionDoc * pDoc);

    LPCWSTR GetServiceId() const;

    void SetNext(CUPnPServiceNode * pusnNext);

    CUPnPServiceNode * GetNext() const;

private:
    // NOTE: REORDER THIS ON PAIN OF DEATH
    enum ServiceProperties { spServiceType,
                             spServiceId,
                             spControlUrl,
                             spEventSubUrl,
                             spSCPDUrl,
         // --- add new values immediately above this line ---
                             spLast };
    // NOTE: REORDER THIS ON PAIN OF DEATH
    //  after adding a property here, add its DevicePropertiesParsingStruct
    //  info to upnpservicenode.cpp

    // String-valued properties
    LPWSTR m_arypszStringProperties [spLast];

    CUPnPServiceNode * m_psnNext;

// static parsing info
    static const DevicePropertiesParsingStruct s_dppsParsingInfo [spLast];
};


#endif //__UPNPSERVICENODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpenumerator.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpenumerator.h
//
//  Contents:   declaration of CUPnPEnumerator & CEnumHelper
//
//  Notes:      definition of the enumerator object returned by
//              IUPnPServices::Item.
//              Supports both IEnumVARIANT and IEnumUnknown
//
//----------------------------------------------------------------------------


#ifndef __UPNPENUMERATOR_H_
#define __UPNPENUMERATOR_H_


class CEnumHelper;

/////////////////////////////////////////////////////////////////////////////
// CUPnPEnumerator

class ATL_NO_VTABLE CUPnPEnumerator :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IEnumVARIANT,
    public IEnumUnknown
{
public:
    CUPnPEnumerator();

    ~CUPnPEnumerator();

    DECLARE_PROTECT_FINAL_CONSTRUCT();

    DECLARE_NOT_AGGREGATABLE(CUPnPEnumerator)

    BEGIN_COM_MAP(CUPnPEnumerator)
        COM_INTERFACE_ENTRY(IEnumVARIANT)
        COM_INTERFACE_ENTRY(IEnumUnknown)
    END_COM_MAP()


// IEnumVARIANT Methods

    STDMETHOD(Next)(/* [in] */ ULONG celt,
                    /* [length_is][size_is][out] */ VARIANT * rgVar,
                    /* [out] */ ULONG * pCeltFetched);

    STDMETHOD(Skip)(/* [in] */ ULONG celt);

    STDMETHOD(Reset)();

    STDMETHOD(Clone)(/* [out] */ IEnumVARIANT ** ppEnum);

// IEnumUnknown Methods

    STDMETHOD(Next)(/* [in] */ ULONG celt,
                    /* [out] */ IUnknown ** rgelt,
                    /* [out] */ ULONG * pceltFetched);

// rem: the same as IEnumVARIANT's version
//    STDMETHOD(Skip)( /* [in] */ ULONG celt);
//    STDMETHOD(Reset)();

    STDMETHOD(Clone)(/* [out] */ IEnumUnknown ** ppenum);


// ATL Methods
    HRESULT FinalConstruct();

    HRESULT FinalRelease();

// Internal Methods
    void Init(IUnknown * punk, CEnumHelper * peh, LPVOID pvCookie);

    HRESULT HrGetWrappers(IUnknown ** ppunk, ULONG cunk, ULONG * pulWrapped);

    HRESULT HrCreateClonedEnumerator(CComObject<CUPnPEnumerator> ** ppueNew);

    // this creates an enumerator object, refcounts it, and stores it in
    // *ppunkNewEnum.  The first three parameters are passed to Init() when
    // the enumerator object is created.
    static HRESULT HrCreateEnumerator(IUnknown * punk,
                                      CEnumHelper * peh,
                                      LPVOID pvCookie,
                                      IUnknown ** ppunkNewEnum);

// private data

    // IUnknown * to the collection wrapper object which
    // created us.  This references the same object that
    // _peh does.
    IUnknown * m_punk;

    // The collection wrapper object which created us.
    CEnumHelper * m_peh;

    // Cookie that tells our collection where we are
    // in the list
    LPVOID m_pvCookie;
};

#endif //__UPNPENUMERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdocument.h ===
//depot/private/upnp/net/upnp/upnp/inc/upnpdocument.h#2 - edit change 2746 (text)
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocument.h
//
//  Contents:   declaration of CUPnPDocument
//
//  Notes:      an abstract base class to help load xml documents via
//              IPersistMoniker/IBindStatusCallback
//
//----------------------------------------------------------------------------


#ifndef __UPNPDOCUMENT_H_
#define __UPNPDOCUMENT_H_



class CUPnPDocumentCtx;

interface IXMLDOMDocument;
interface IPersistMoniker;


/////////////////////////////////////////////////////////////////////////////
// CUPnPDocument

class /*ATL_NO_VTABLE */CUPnPDocument :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IObjectWithSiteImpl<CUPnPDocument>,
    public IObjectSafetyImpl<CUPnPDocument, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
    friend CUPnPDocumentCtx;

    CUPnPDocument();

    ~CUPnPDocument();

    DECLARE_PROTECT_FINAL_CONSTRUCT();

    DECLARE_NOT_AGGREGATABLE(CUPnPDocument)

    BEGIN_COM_MAP(CUPnPDocument)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IObjectSafety)
    END_COM_MAP()

// Document Helper Methods
    HRESULT SyncLoadFromUrl   (/* [in] */ LPCWSTR pszUrl);

    HRESULT AsyncLoadFromUrl  (/* [in] */ LPCWSTR pszUrl, LPVOID pvCookie);

    HRESULT HrLoad       (LPCWSTR pszUrl,
                          LPVOID pvCookie,
                          BOOL fAsync);


// Virtual Methods - callbacks for our decendents

    // called when _rs changes.  ooh.
    virtual void OnReadyStateChange();

    // called when the document needs to be initialized
    // this is intended to completely clear document state
    // so that a document can be Load()ed...
    // pvCookie is a context that the derived document can
    // use to prepare itself for a particular load.
    virtual HRESULT Initialize(LPVOID pvCookie);

    // Called only when the unparsed document bits have been
    // loaded successfully.
    // The document must use this opportunity to perfom any
    // initial document parsing.
    // This method must return S_OK if its parsing has completed
    // successfully.  If the document is invalid, OnLoadComplete
    // should return S_FALSE.  If anything other than S_OK is
    // returned, the load will be considered a failure.
    virtual HRESULT OnLoadComplete();

    // This is always called when a load completes, successfully or not.
    virtual HRESULT OnLoadReallyDone();

    // an array of formats that will appear in an accept() header, and the
    // number of formats returned in the array
    virtual VOID GetAcceptFormats(CONST LPCTSTR ** ppszFormats,
                                  DWORD * pcFormats) const;

// ATL Methods
    HRESULT FinalConstruct();

    HRESULT FinalRelease();

// methods we provide to internal clients

    HRESULT DocumentDownloadReady      (HINTERNET hOpenUrl, DWORD dwError);

    // stops any currently running load operation
    HRESULT AbortLoading();

    // cleans any state from the document, stopping the bind operation if necessary
    // note that calling  this will likely call OnReinitialize().
    HRESULT Reset(LPVOID pvCookie);

    // retrieves _rs
    READYSTATE GetReadyState() const;

    // retrieves the base URL.  Note that the caller does NOT own this string,
    // and must not manipulate or free it.
    LPCWSTR GetBaseUrl() const;

    // returns an un-addref()'d pointer to the doc's xml document
    IXMLDOMDocument * GetXMLDocument() const;

    // retrieves the result of the load operation.  If the load failed, this
    // will explain why.
    HRESULT GetLoadResult() const;

    // returns TRUE if the specified URL can be safely loaded given the
    // current security settings, FALSE otherwise,
    BOOL fIsUrlLoadAllowed(LPCWSTR pszUrl) const;

    // retrieves the security url, as defined below
    // This method returns the security url.
    // Note that the caller does NOT own this string, and must not
    // manipulate or free it.
    // note: This string may very well be NULL, such as when we're
    // not running in IE.
    LPCWSTR GetSecurityUrl() const;

    // retrieves the host URL.  Note that the caller does NOT own this string,
    // and must not manipulate or free it.
    // note: This string may very well be NULL, such as when we're
    // not running in IE.
    LPCWSTR GetHostUrl() const;

    // Copies the safety settings that have been applied to another
    // CUPnPDocument, such that a load of this document has the same security
    // restrictions as the given document
    VOID CopySafety(CUPnPDocument * pdocParent);


protected:
// internal methods

    // called before performing an internal load operation in order
    // to prepare the document for loading, including reinitializing
    // the document state, including the host and security urls
    HRESULT HrPrepareForLoad(LPCWSTR pszUrl, LPVOID pvCookie);

    // this function copies/allocates the passed-in string into _pszBaseUrl
    // set to NULL to un-set the base url.
    HRESULT SetBaseUrl(LPCWSTR pszUrlNew);

    // this function sets _pszSecurityUrl to the host that loaded the page
    // that instantiated the control, if such information is gettable.
    // if it isn't, it sets _pszHostUrl to NULL
    HRESULT HrInitHostUrl();

    // this function sets _pszSecurityUrl to the security URL of _pszHostUrl
    HRESULT HrInitSecurityUrl();

    // this function copies/allocates the passed-in string into _pszSecurityUrl
    // set to NULL to un-set the security url
    HRESULT SetSecurityUrl(LPCWSTR pszSecurityUrlNew);

    // this function copies/allocates the passed-in string into _pszHostUrl
    // set to NULL to un-set the host url
    HRESULT SetHostUrl(LPCWSTR pszHostUrlNew);

    // use this to set the result returned by GetLoadResult
    void SetLoadResult(HRESULT hr);

    // changes _rs and calls OnReadyStateChange
    void SetReadyState(READYSTATE lrs);

    // called at the very end of the loading process, when a document
    // load completes (either successfully or unsuccessfully)
    void CompleteLoading();

    BSTR m_bstrFullUrl;

// fun data
private:

    // the xml document.  We use the xml document tree to store our data
    // for us.
    // IXMLDOMDocument.  This exists as long as we do.
    IXMLDOMDocument * _pxdd;

    // The CUPnPDocumentCtx manages callbacks from WinInet 
    // for asynchronous document loads
    CComObject<CUPnPDocumentCtx> * _puddctx;

/*
typedef enum tagREADYSTATE{
    READYSTATE_UNINITIALIZED = 0,
    READYSTATE_LOADING = 1,
    READYSTATE_LOADED = 2,
    READYSTATE_INTERACTIVE = 3,
    READYSTATE_COMPLETE = 4         // _hrLoadResult is valid
} READYSTATE;
*/
    READYSTATE _rs;

    HRESULT _hrLoadResult;

    // base url that we use for URLs contained in description documents
    LPWSTR _pszBaseUrl;

    // if we're running in IE, this is the URL of the page that is hosting
    // us
    LPWSTR _pszHostUrl;

    // When we are being called from untrusted code, this is the
    // string    "scheme:hostname"
    // where 'scheme' and 'hostname' are the scheme (e.g., 'http')
    // and hostname of the untrusted document from which we're being
    // loaded.
    // When running in untrusted code, we require that this scheme
    // be identical for all urls that we try to load from (the url to
    // load the description doc, dcpd, control url, event url, etc).
    // note: This string may very well be NULL, such as when we're
    // not running in IE.
    LPWSTR _pszSecurityUrl;

    static const LPCTSTR s_aryAcceptFormats [];

    static const DWORD s_cAcceptFormats;

    // other variables:
    LPSTR                       m_szPendingBuf;
    DWORD                       m_dwPendingSize;


    // As a consequence of deriving from IObjectSafetyImpl<>,
    //  m_dwCurrentSafety
    // contains the current set of flags passed to
    //  IObjectSafety::SetInterfaceSafetyOptions for _any_ interface
    // the flags are sticky, and aren't un-set.

    // As a conqsequence of deriving from IObjectWithSiteImpl<>,
    //  m_spUnkSite
    // contains a punk to the site which is hosting us.
};



#endif //__UPNPDOCUMENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdocumentnotifysink.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocumentnotifysink.h
//
//  Contents:   declaration of CUPnPDocumentNotifySink
//
//  Notes:      Implementation of IPropertyNotifySink that forwards
//              OnChanged events to the generic document object.
//
//----------------------------------------------------------------------------


#ifndef __UPNPDOCUMENTNOTIFYSINK_H_
#define __UPNPDOCUMENTNOTIFYSINK_H_

class CUPnPDocument;

interface IPropertyNotifySink;


/////////////////////////////////////////////////////////////////////////////
// CUPnPDocumentNotifySink
//  Implementation of IPropertyNotifySink for the generic document object.
class ATL_NO_VTABLE CUPnPDocumentNotifySink :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IPropertyNotifySink
{
public:

    CUPnPDocumentNotifySink();

    ~CUPnPDocumentNotifySink();

    HRESULT Init(CUPnPDocument * pdoc, IUnknown * pxdd);

    HRESULT Deinit();

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CUPnPDocumentNotifySink)

    BEGIN_COM_MAP(CUPnPDocumentNotifySink)
        COM_INTERFACE_ENTRY(IPropertyNotifySink)
    END_COM_MAP()


// IPropertyNotifySink Methods
    STDMETHOD(OnChanged)        (/* in */ DISPID dispid);

    STDMETHOD(OnRequestEdit)    (/* in */ DISPID dispid);

// ATL Methods
#ifdef ENABLETRACE
    HRESULT FinalConstruct()
    {
        TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentNotifySink::FinalConstruct");
        return S_OK;
    }

    HRESULT FinalRelease()
    {
        TraceTag(ttidUPnPDescriptionDoc, "OBJ: CUPnPDocumentNotifySink::FinalRelease");
        return S_OK;
    }
#endif // ENABLETRACE

// Member data

    // document to notify when interesting events occur
    CUPnPDocument * _pdoc;

    // object to which we're connected
    IUnknown * _punk;

    // TRUE if the doc has been connected
    BOOL _fAdvised;

    // cookie needed to unregister our connection point
    DWORD _dwNookieCookie;

};

#endif // __UPNPDOCUMENTNOTIFYSINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpdocumentctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpdocumentctx.h
//
//  Contents:   declaration of CUPnPDocumentCtx
//
//  Notes:      a helper class that implements IUPnPPrivateDocumentCallbackHelper
//              and sends notifiations to a CUPnPDocument
//
//----------------------------------------------------------------------------


#ifndef __UPNPDOCUMENTCTX_H_
#define __UPNPDOCUMENTCTX_H_

#include "resource.h"       // main symbols


class ATL_NO_VTABLE CUPnPDocumentCtx :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IUPnPPrivateDocumentCallbackHelper
{
public:

    CUPnPDocumentCtx();

    ~CUPnPDocumentCtx();

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CUPnPDocumentCtx)

    BEGIN_COM_MAP(CUPnPDocumentCtx)
        COM_INTERFACE_ENTRY(IUPnPPrivateDocumentCallbackHelper)
    END_COM_MAP()


// IUPnPPrivateDocumentCallbackHelper Methods

    STDMETHOD(DocumentDownloadReady)    (DWORD_PTR hOpenUrl);

    STDMETHOD(DocumentDownloadAbort)    (DWORD_PTR hOpenUrl, DWORD dwError);

    STDMETHOD(DocumentDownloadRedirect) (DWORD_PTR hOpenUrl, LPCWSTR strNewUrl);

// ATL Methods
    HRESULT FinalConstruct();

    HRESULT FinalRelease();


// Internal Methods
    HRESULT Init(CUPnPDocument* pDoc, DWORD* pdwContext);

    void    Deinit();

    HRESULT StartInternetOpenUrl(HINTERNET hInetSess,
                                           LPTSTR pszFullUrl,
                                           LPTSTR pszHdr,
                                           DWORD dwHdrLen,
                                           DWORD dwFlags);

    HRESULT EndInternetOpenUrl();

    static
    void __stdcall DocLoadCallback(HINTERNET hInternet,
                            DWORD_PTR dwContext,
                            DWORD dwInternetStatus,
                            LPVOID lpvStatusInformation,
                            DWORD dwStatusInformationLength);


    // Global Interface Table handle
    DWORD   m_dwGITCookie;

    // reference to CDocument
    CUPnPDocument * m_pDoc;

    // error code returned
    DWORD m_dwError;


private:

};

#endif // __UPNPDOCUMENTCTX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpservicenodelist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservicenodelist.h
//
//  Contents:   Declaration of CUPnPServiceNodeList
//
//  Notes:      This class performs two things:
//               - stores the state needed to create a service object
//               - calls CreateServiceObject when a service object is
//                 needed
//
//              IUPnPService methods are not implemented here, but on the
//              CUPnPService object.
//
//----------------------------------------------------------------------------


#ifndef __UPNPSERVICENODELIST_H_
#define __UPNPSERVICENODELIST_H_


class CUPnPDeviceNode;
class CUPnPServiceNode;
class CUPnPServiceNodeList;
class CUPnPServices;
class CUPnPDocument;
class CUPnPDescriptionDoc;

interface IXMLDOMNode;


/////////////////////////////////////////////////////////////////////////////
// CUPnPServiceNodeList

class CUPnPServiceNodeList :
    public CEnumHelper
{
public:
    CUPnPServiceNodeList();

    ~CUPnPServiceNodeList();

    HRESULT get_Count       ( /* [out, retval] */ LONG * pVal );

    HRESULT get__NewEnum    ( /* [out, retval] */ LPUNKNOWN * pVal );

    HRESULT get_Item        ( /* [in] */  BSTR bstrDCPI,
                      /* [out, retval] */ IUPnPService ** ppService);

// Internal Methods
    void Init (CUPnPDescriptionDoc * pDoc);

    // Creates a new service node, reading the necessary data
    // out of the given XMLDOMNode element.  If the required data
    // is not present, returns E_FAIL.
    // Any URLs in the service element are combined with the
    // given base url to make them fully-qualified.
    HRESULT HrAddService(IXMLDOMNode * pxdn, LPCWSTR pszBaseUrl);

    // returns a reference to the next service node in the list,
    // after the specified node.  If there is no next service,
    // this returns NULL in *ppszNext.
    // This method does not perform parameter validation.
    //
    void GetNextServiceNode ( CUPnPServiceNode * psnCurrent,
                              CUPnPServiceNode ** ppszNext );

    // returns an addref()'d IUPnPServices wrapper representing the
    // services list.
    // if one already exists, it is addref()d and returned.
    // if one does not exist, one is created, addref()d and returned
    // punk is what the wrapper will addref() if it's created
    HRESULT HrGetWrapper(IUPnPServices ** ppus);

    // called by our wrapper when our wrapper goes away.
    void Unwrap();

// CEnumHelper methods
    LPVOID GetFirstItem();
    LPVOID GetNextNthItem(ULONG ulSkip,
                          LPVOID pCookie,
                          ULONG * pulSkipped);
    HRESULT GetPunk(LPVOID pCookie, IUnknown ** ppunk);

private:
    // returns the service in the list with the specified Id.
    // If no service with the specified id exists, this
    // this returns NULL in *ppszResult.
    // This method does not perform parameter validation.
    //
    CUPnPServiceNode * psnFindServiceById(LPCWSTR pszServiceId);

    void addServiceToList(CUPnPServiceNode * pusnNew);

// member data
    // the document object which is addref'd when we create wrappers,
    // and that is asked if a service object may be created given its
    // current security settings.
    CUPnPDescriptionDoc * m_pDoc;

    // our service nodes are stored as a linked list.
    CUPnPServiceNode * m_psnFirst;
    CUPnPServiceNode * m_psnLast;

    // COM wrapper object for IUPnPServices implementation
    CUPnPServices * m_pusWrapper;
};

#endif // __UPNPSERVICENODELIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpservice.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservice.h
//
//  Contents:   Declaration of CUPnPService
//
//  Notes:      <blah>
//
//----------------------------------------------------------------------------


#ifndef __UPNPSERVICE_H_
#define __UPNPSERVICE_H_

#include "resource.h"       // main symbols
#include "upnpatl.h"

#include "ssdpapi.h"
#include "upnp.h"           // IUPnPPrivateServiceHelper

class CUPnPServiceCallback;

/*
 * Struct SERVICE_STATE_TABLE_ROW
 *
 * Represents a row of a service state table.
 */

typedef struct _SERVICE_STATE_TABLE_ROW
{
    LPWSTR          pwszVarName;
    SST_DATA_TYPE   sdtType;
    VARIANT         value;
    BOOL            bDoRemoteQuery;
} SERVICE_STATE_TABLE_ROW;

/*
 * Struct SERVICE_ACTION_ARGUMENT
 *
 * Represents an argument to an action.
 */

typedef struct _SERVICE_ACTION_ARGUMENT
{
    LPWSTR          pwszName;
    SST_DATA_TYPE   sdtType;
} SERVICE_ACTION_ARGUMENT;

/*
 * Struct SERVICE_ACTION
 *
 * Holds information about a service action.
 */

typedef struct _SERVICE_ACTION
{
    LPWSTR                     pwszName;
    LONG                       lNumInArguments;
    SERVICE_ACTION_ARGUMENT    * pInArguments;
    LONG                       lNumOutArguments;
    SERVICE_ACTION_ARGUMENT    * pOutArguments;
    SERVICE_ACTION_ARGUMENT    * pReturnValue;
} SERVICE_ACTION;


const LONG  CALLBACK_LIST_INIT_SIZE = 2;
const LONG  CALLBACK_LIST_DELTA = 2;

/*
 * Class CUPnPService - Instances of this class are UPnP Service objects.
 *
 * Inheritance:
 * CComObjectRootEx, IDispatchImpl
 *
 * Purpose:
 *      Objects of this class represent individual UPnP service instances.
 *
 * Hungarian: svc
 */

class ATL_NO_VTABLE CUPnPService :
        public CComObjectRootEx<CComMultiThreadModel>,
        public IDispatchImpl<IUPnPService, &IID_IUPnPService, &LIBID_UPNPLib>,
        public IUPnPServiceCallbackPrivate
{
public:
    CUPnPService();
    ~CUPnPService();

DECLARE_PROTECT_FINAL_CONSTRUCT()

        HRESULT FinalConstruct();
        HRESULT FinalRelease();


DECLARE_NOT_AGGREGATABLE(CUPnPService)

BEGIN_COM_MAP(CUPnPService)
        COM_INTERFACE_ENTRY(IUPnPService)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IUPnPServiceCallbackPrivate)
END_COM_MAP()

// IUPnPService
public:
        STDMETHOD(get_ServiceTypeIdentifier)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(InvokeAction)(/*[in]*/            BSTR    bstrActionName,
                                /*[in]*/            VARIANT vInActionArgs,
                                /*[in, out]*/       VARIANT * pvOutActionArgs,
                                /*[out, retval]*/   VARIANT * pvRetVal);
        STDMETHOD(QueryStateVariable)(/*[in]*/          BSTR bstrVariableName,
                                  /*[out, retval]*/ VARIANT *pValue);
        STDMETHOD(AddCallback)(/*[in]*/  IUnknown   * pUnkCallback);
        STDMETHOD(get_Id)(/*[out, retval]*/ BSTR * pbstrId);
        STDMETHOD(get_LastTransportStatus)(/*[out, retval]*/ long * plValue);

// IUPnPServiceCallbackPrivate
        STDMETHOD(AddTransientCallback)(/*[in]*/  IUnknown   * pUnkCallback,
                                        /* [out */ DWORD *pdwCookie);
        STDMETHOD(RemoveTransientCallback)(/*[in]*/  DWORD dwCookie);

public:
    HRESULT HrInitialize(IN LPCWSTR                    pcwszSTI,
                         IN LPCWSTR                    pcwszControlURL,
                         IN LPCWSTR                    pcwszEventSubURL,
                         IN LPCWSTR                    pcwszId,
                         IN LONG                       lNumStateVariables,
                         IN SERVICE_STATE_TABLE_ROW    * pSST,
                         IN LONG                       lNumActions,
                         IN SERVICE_ACTION             * pActionTable);
    HRESULT HrStartShutdown();

    static VOID EventNotifyCallback(SSDP_CALLBACK_TYPE  ssdpType,
                                    CONST SSDP_MESSAGE  * pssdpMsg,
                                    LPVOID              pContext);
    static DWORD EventingWorkerThreadProc(LPVOID    lpParameter);

private:
    enum SERVICE_CALLBACK_TYPE
    {
        SCT_STATE_CHANGE,
        SCT_DEAD
    };

    // Helper functions
    HRESULT HrFireServiceDiedCallbacks();
    HRESULT HrFireStateChangeCallbacks(IN  BSTR    bstrStateVarName);
    HRESULT HrInitializeEventing();
    VOID    freeStateTable();
    VOID    freeActionTable();
#ifdef DBG  // checked build only
    VOID    DumpInitialization();
#endif // DBG

    HRESULT HrValidateAction(IN  LPCWSTR        pcwszActionName,
                             IN  SAFEARRAY      * psaActionArgs,
                             OUT SERVICE_ACTION ** ppAction);
    BSTR    BSTRStripNameSpaceFromFQName(IN BSTR bstrFullyQualifiedName);
    HRESULT ParsePropertyNode(IN  IXMLDOMNode * pxdnPropNode);
    HRESULT HrParseEventAndUpdateStateTable(IN IXMLDOMDocument * pEventBody);
    HRESULT HrParseEventAndInvokeCallbacks(IN IXMLDOMDocument * pEventBody);
    BOOL    FHaveEventedVariables();

    HRESULT HrHandleEvent(CONST SSDP_MESSAGE * pssdpMsg);
    HRESULT HrFireCallbacks(IN SERVICE_CALLBACK_TYPE sct,
                            IN BSTR bstrStateVarName);


    HRESULT HrInvokeServiceDiedCallbacks(/* [in] */ IUnknown * punkService,
                                                    IGlobalInterfaceTable * pGIT);

    HRESULT HrInvokeStateChangeCallbacks(/* [in] */ IUnknown * punkService,
                                         /* [in] */ IGlobalInterfaceTable * pGIT,
                                         /* [in] */ LPCWSTR pszStateVarName,
                                         /* [in] */ LPVARIANT lpvarValue);

    HRESULT HrAddCallback(IUnknown * punkCallback, DWORD *pdwCookie);
    HRESULT HrRemoveCallback(DWORD dwCookie);


    HRESULT HrGrowCallbackList();

    VOID FreeCallbackList();


    LPWSTR                  m_pwszSTI;
    LPWSTR                  m_pwszControlURL;
    LPWSTR                  m_pwszEventSubURL;
    LPWSTR                  m_pwszId;
    LONG                    m_lNumStateVariables;
    SERVICE_STATE_TABLE_ROW * m_StateTable;
    CComAutoCriticalSection m_StateTableCS;
    LONG                    m_lNumActions;
    SERVICE_ACTION          * m_ActionTable;
    HANDLE                  m_hEventSub;
    LPWSTR                  m_pwszSubsID;
    DWORD                   m_dwSeqNumber;
    BOOL                    m_fCallbackCookieValid;
    DWORD                   m_dwCallbackCookie;
    CComObject<CUPnPServiceCallback> * m_psc;
    LONG                    m_lLastTransportStatus;
    CComAutoCriticalSection m_critSecCallback;

    LPDWORD                 m_arydwCallbackCookies;
    DWORD                   m_dwNumCallbacks;
    DWORD                   m_dwMaxCallbacks;
    BOOL                    m_bShutdown;

    DWORD_PTR               m_pControlConnect;
};

struct ServiceNode
{
    ServiceNode * m_pNext;
    CUPnPService * m_pService;
    long m_nRefs;
};

class CServiceLifetimeManager
{
public:
    ~CServiceLifetimeManager();

    static CServiceLifetimeManager & Instance()
    {
        return s_instance;
    }

    HRESULT AddService(CUPnPService * pService);
    HRESULT DerefService(CUPnPService * pService);
    HRESULT AddRefService(CUPnPService * pService);
private:
    CServiceLifetimeManager();
    CServiceLifetimeManager(const CServiceLifetimeManager &);
    CServiceLifetimeManager & operator=(const CServiceLifetimeManager &);
    static CServiceLifetimeManager s_instance;

    ServiceNode * m_pServiceNodeList;
    CRITICAL_SECTION m_critSec;
};

class ATL_NO_VTABLE CUPnPServiceCallback :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IUPnPPrivateServiceHelper2
{
public:
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    CUPnPServiceCallback();
    ~CUPnPServiceCallback();

    BEGIN_COM_MAP(CUPnPServiceCallback)
        COM_INTERFACE_ENTRY(IUPnPPrivateServiceHelper2)
    END_COM_MAP()

// IUPnPPrivateServiceHelper2
    STDMETHOD(GetServiceObject)(/* [out] */ IUnknown ** ppunkService);

// Internal methods
    VOID Init(CUPnPService * pService);

    VOID DeInit(VOID);

private:
    // Hard reference to service
    CUPnPService * m_pService;
};

class ATL_NO_VTABLE CUPnPServicePublic :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CUPnPServicePublic, &CLSID_UPnPService>,
        public IUPnPService,
        public IUPnPServiceCallbackPrivate
{
public:
    CUPnPServicePublic();
    ~CUPnPServicePublic();

DECLARE_REGISTRY_RESOURCEID(IDR_UPNPSERVICE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

        HRESULT FinalConstruct();
        HRESULT FinalRelease();

DECLARE_NOT_AGGREGATABLE(CUPnPServicePublic)

BEGIN_COM_MAP(CUPnPServicePublic)
        COM_INTERFACE_ENTRY(IUPnPService)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY(IUPnPServiceCallbackPrivate)
END_COM_MAP()

// IUPnPService
public:
        STDMETHOD(GetTypeInfoCount)(
            /* [out] */ UINT *pctinfo);
        STDMETHOD(GetTypeInfo)(
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        STDMETHOD(GetIDsOfNames)(
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        STDMETHOD(Invoke)(
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);

        STDMETHOD(get_ServiceTypeIdentifier)(/*[out, retval]*/ BSTR *pVal);
        STDMETHOD(InvokeAction)(/*[in]*/            BSTR    bstrActionName,
                                /*[in]*/            VARIANT vInActionArgs,
                                /*[in, out]*/       VARIANT * pvOutActionArgs,
                                /*[out, retval]*/   VARIANT * pvRetVal);
        STDMETHOD(QueryStateVariable)(/*[in]*/          BSTR bstrVariableName,
                                  /*[out, retval]*/ VARIANT *pValue);
        STDMETHOD(AddCallback)(/*[in]*/  IUnknown   * pUnkCallback);
        STDMETHOD(get_Id)(/*[out, retval]*/ BSTR * pbstrId);
        STDMETHOD(get_LastTransportStatus)(/*[out, retval]*/ long * plValue);

// IUPnPServiceCallbackPrivate
        STDMETHOD(AddTransientCallback)(/*[in]*/  IUnknown   * pUnkCallback,
                                        /* [out */ DWORD *pdwCookie);
        STDMETHOD(RemoveTransientCallback)(/*[in]*/  DWORD dwCookie);

        // Initialization function
        HRESULT HrInitialize(IN LPCWSTR                    pcwszSTI,
                             IN LPCWSTR                    pcwszControlURL,
                             IN LPCWSTR                    pcwszEventSubURL,
                             IN LPCWSTR                    pcwszId,
                             IN LONG                       lNumStateVariables,
                             IN SERVICE_STATE_TABLE_ROW    * pSST,
                             IN LONG                       lNumActions,
                             IN SERVICE_ACTION             * pActionTable);
private:
    CComObject<CUPnPService> * m_pService;
    BOOL                    m_fSsdpInitialized;
};

#endif //__UPNPSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpservices.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpservices.h
//
//  Contents:   Declaration of CUPnPServices, the wrapper class
//              for providing an IUPnPServices implementation
//              on top of a CUPnPServiceList.
//
//  Notes:      see "how this wrapper stuff works" in cupnpdevicenode.cpp
//              for an explanation of the wrapping strategy
//
//----------------------------------------------------------------------------


#ifndef __UPNPSERVICES_H_
#define __UPNPSERVICES_H_

#include "resource.h"       // main symbols


class CUPnPServiceNodeList;

/////////////////////////////////////////////////////////////////////////////
// CUPnPServices
class ATL_NO_VTABLE CUPnPServices :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUPnPServices, &CLSID_UPnPServices>,
    public IDispatchImpl<IUPnPServices, &IID_IUPnPServices, &LIBID_UPNPLib>,
    public CEnumHelper
{
public:
    CUPnPServices();

    ~CUPnPServices();

    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPSERVICES)

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    DECLARE_NOT_AGGREGATABLE(CUPnPServices)

    BEGIN_COM_MAP(CUPnPServices)
        COM_INTERFACE_ENTRY(IUPnPServices)
        COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()

// IUPnPServices methods
    STDMETHOD(get_Count)    ( /* [out, retval] */ LONG * pVal );

    STDMETHOD(get__NewEnum) ( /* [out, retval] */ LPUNKNOWN * pVal );

    STDMETHOD(get_Item)     ( /* [in] */  BSTR bstrDCPI,
                      /* [out, retval] */ IUPnPService ** ppService);

// CEnumHelper methods
    LPVOID GetFirstItem();
    LPVOID GetNextNthItem(ULONG ulSkip,
                          LPVOID pCookie,
                          ULONG * pulSkipped);
    HRESULT GetPunk(LPVOID pCookie, IUnknown ** ppunk);


// Internal methods
    // calls to this object will be forwarded to the specified
    // CUPnPServiceNodeList object
    void Init(CUPnPServiceNodeList * pusnl, IUnknown * punk);

    // calls to this object will no longer be forwarded to the
    // previously specified CUPnPServiceNodeList object.
    // Init() must be called before Deinit().
    void Deinit();

// ATL Methods
    HRESULT FinalConstruct();
    HRESULT FinalRelease();

private:
// member data
    IUnknown * m_punk;
    CUPnPServiceNodeList * m_pusnl;
};


#endif //__UPNPSERVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\rehy\rehycso.cpp ===
/*
* rehy.cpp
*
* Implementation of the HrRehydratorCreateServiceObject() API.
*
* Owner: Shyam Pather (SPather)
*
* Copyright 1986-2000 Microsoft Corporation, All Rights Reserved
*/

#include <pch.h>
#pragma hdrstop


#include "ncstring.h"
#include "Validate.h"

#include "rehy.h"
#include "rehyutil.h"

/*
 * Function:    HrParseSendEventsAttribute()
 *
 * Purpose:     Parses the "sendEvents" attribute in a <stateVariable> element
 *              and sets the bDoRemoteQuery field in the state table row
 *              appropriately.
 *
 * Arguments:
 *  psstrRow            [in]    The state table row for the state variable
 *  pxdnStateVarElement [in]    The <stateVariable> element
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrParseSendEventsAttribute(
    IN   SERVICE_STATE_TABLE_ROW * psstrRow,
    IN   IXMLDOMNode             * pxdnStateVarElement)
{
    HRESULT         hr = S_OK;
    IXMLDOMElement  * pxdeStateVar = NULL;

    hr = pxdnStateVarElement->QueryInterface(IID_IXMLDOMElement,
                                             (void **) &pxdeStateVar);

    if (SUCCEEDED(hr) && pxdeStateVar)
    {
        BSTR    bstrAttrName = NULL;

        bstrAttrName = SysAllocString(L"sendEvents");

        if (bstrAttrName)
        {
            VARIANT varAttrValue;

            VariantInit(&varAttrValue);

            hr = pxdeStateVar->getAttribute(bstrAttrName,
                                            &varAttrValue);

            if (SUCCEEDED(hr) && (varAttrValue.vt != VT_NULL))
            {
                Assert(varAttrValue.vt == VT_BSTR);

                if (_wcsicmp(V_BSTR(&varAttrValue), L"no") == 0)
                {
                    psstrRow->bDoRemoteQuery = TRUE;
                }
                VariantClear(&varAttrValue);
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                    TraceTag(ttidRehydrator,
                             "HrParseSendEventsAttribute(): "
                             "No value specified for sendEvents attribute - "
                             "assuming \"yes\"");
                }
                else
                {
                    TraceError("HrParseSendEventsAttribute(): "
                               "Failed to get value for sendEvents attribute - "
                               "assuming \"yes\"",
                               hr);
                }
            }

            SysFreeString(bstrAttrName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrParseSendEventsAttribute(): "
                       "Failed to allocate BSTR for attribute name",
                       hr);

        }

        pxdeStateVar->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }

        TraceError("HrParseSendEventsAttribute(): "
                   "Failed to get IXMLDOMElement interface",
                   hr);
    }


    TraceError("HrParseSendEventsAttribute(): "
               "Exiting",
               hr);
    return hr;
}

/*
 * Function:    HrInitializeSSTRow()
 *
 * Purpose:     Initializes a SERVICE_STATE_TABLE_ROW structure with the
 *              information from a <stateVariable> structure from an SCPD
 *              document.
 *
 * Arguments:
 *  psstrRow            [in]    Pointer to the structure to initialize
 *  pxdnStateVarElement [in]    The SCPD <stateVariable> element from which
 *                              to initialize the structure
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrInitializeSSTRow(
                   IN   SERVICE_STATE_TABLE_ROW * psstrRow,
                   IN   IXMLDOMNode             * pxdnStateVarElement
                   )
{
    HRESULT hr = S_OK;
    BSTR    bstrVarName;
    BSTR    bstrDataType;
    LPCWSTR pcwszNameToken = L"name";
    LPCWSTR pcwszDataTypeToken = L"dataType";

    // Determine if this is an evented variable or not.

    hr = HrParseSendEventsAttribute(psstrRow,
                                    pxdnStateVarElement);

    if (SUCCEEDED(hr))
    {

        // Get the value of the <name> element.

        hr = HrGetTextValueFromChildElement(pxdnStateVarElement,
                                            &pcwszNameToken,
                                            1,
                                            &bstrVarName);

        if (SUCCEEDED(hr) && bstrVarName)
        {
            psstrRow->pwszVarName = WszAllocateAndCopyWsz(bstrVarName);

            if (psstrRow->pwszVarName)
            {
                hr = HrGetTextValueFromChildElement(pxdnStateVarElement,
                                                    &pcwszDataTypeToken,
                                                    1,
                                                    &bstrDataType);

                if (SUCCEEDED(hr) && bstrDataType)
                {
                    SST_DATA_TYPE sdt;

                    VariantInit(&psstrRow->value);

                    sdt = GetTypeFromString(bstrDataType);
                    if (SDT_INVALID != sdt)
                    {
                        psstrRow->sdtType = sdt;

                        TraceTag(ttidRehydrator, "HrInitializeSSTRow(): "
                                 "State Variable: %S\ttype 0x%x",
                                 psstrRow->pwszVarName,
                                 psstrRow->sdtType);

                    }
                    else
                    {
                        hr = E_INVALIDARG;
                        TraceError("HrInitializeSSTRow(): "
                                   "Failed to get appropriate type",
                                   hr);
                    }

                    SysFreeString(bstrDataType);
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        // The XML DOM operation succeeded, but there was
                        // no <dataType> element.

                        hr = E_INVALIDARG;
                    }
                    TraceError("HrInitializeSSTRow(): "
                               "Failed to get state variable type",
                               hr);
                }

                // Something went wrong. Clean up what we've already allocated.

                if (FAILED(hr))
                {
                    MemFree(psstrRow->pwszVarName);
                    psstrRow->pwszVarName = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrInitializeSSTRow(): "
                           "Failed to allocate and copy state variable name",
                           hr);
            }

            SysFreeString(bstrVarName);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrInitializeSSTRow(): "
                       "Failed to get state variable name", hr);
        }
    }
    else
    {
        TraceError("HrInitializeSSTRow(): "
                   "Failed to parse 'sendEvents' attribute",
                   hr);
    }

    return hr;
}


/*
 * Function:    HrAllocStateTable()
 *
 * Purpose:     Allocates and initializes an array of SERVICE_STATE_TABLE_ROW
 *              structures to represent a list of <stateVariable> elements
 *              from an SCPD document.
 *
 * Arguments:
 *  pxdnlStateVarElements   [in]    List of <stateVariable> elements from the
 *                                  SCPD document
 *  plNumVars               [out]   Address at which to place the number of
 *                                  state variables exported by the service
 *  ppSST                   [out]   Address at which to place the pointer to
 *                                  the new array of SERVICE_STATE_TABLE_ROW
 *                                  structures (array length will equal the
 *                                  value placed at plNumVars)
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrAllocStateTable(IN    IXMLDOMNodeList         * pxdnlStateVarElements,
                  OUT   LONG                    * plNumVars,
                  OUT   SERVICE_STATE_TABLE_ROW **ppSST)
{
    HRESULT                 hr = S_OK;
    LONG                    lNumVars = 0;
    SERVICE_STATE_TABLE_ROW * pSST = NULL;

    *plNumVars = 0;
    *ppSST = NULL;

    // Determine how many state variables there are.

    hr = pxdnlStateVarElements->get_length(&lNumVars);

    if (SUCCEEDED(hr))
    {
        size_t sizeToAlloc = lNumVars * sizeof(SERVICE_STATE_TABLE_ROW);

        // Allocate an array of state table rows.

        pSST = (SERVICE_STATE_TABLE_ROW *) MemAlloc(sizeToAlloc);

        if (pSST)
        {
            LONG i;

            ZeroMemory((PVOID) pSST,
                       sizeToAlloc);

            // Initialize each element of the array

            for (i = 0; i < lNumVars; i++)
            {
                IXMLDOMNode * pxdnStateVarElement = NULL;

                hr = pxdnlStateVarElements->get_item(i,
                                                     &pxdnStateVarElement);

                if (SUCCEEDED(hr))
                {
                    hr = HrInitializeSSTRow(&(pSST[i]),
                                            pxdnStateVarElement);

                    if (FAILED(hr))
                    {
                        TraceError("HrAllocStateTable(): "
                                   "Failed to initialize SST Row",
                                   hr);
                    }

                    pxdnStateVarElement->Release();
                }
                else
                {
                    TraceError("HrAllocStateTable(): "
                               "Failed to get item from state var list", hr);
                }

                // If something failed, then we don't want to continue.

                if (FAILED(hr))
                {
                    break;
                }
            }

            // Clean up if something failed.

            if (FAILED(hr))
            {
                Assert(i < lNumVars);

                // i is the index of the row on which the failure occured.
                // Assume everything below that index was successfully
                // initialized, and therefore needs to be cleaned up.

                for (LONG j = 0; j < i; j++)
                {
                    SERVICE_STATE_TABLE_ROW * pRow = &(pSST[j]);

                    if (pRow->pwszVarName)
                    {
                        MemFree(pRow->pwszVarName);
                        pRow->pwszVarName = NULL;
                    }

                    VariantClear(&pRow->value);
                }

                MemFree(pSST);
                pSST = NULL;
            }

        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrAllocStateTable(): "
                       "Failed to allocate state table rows", hr);
        }
    }
    else
    {
        TraceError("HrAllocStateTable(): "
                   "Failed to get number of state variables", hr);
    }

    // At this point, either we're successful and have a valid pSST pointer,
    // or we've failed, and pSST is NULL.

    Assert((SUCCEEDED(hr) && (NULL != pSST)) ||
           (FAILED(hr) && (NULL == pSST)));

    if (SUCCEEDED(hr))
    {
        *plNumVars = lNumVars;
        *ppSST = pSST;
    }

    TraceError("HrAllocStateTable(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrCreateStateTable()
 *
 * Purpose:     Creates an array of SERVICE_STATE_TABLE_ROW structures to
 *              represent a state table as described in an SCPD document.
 *
 * Arguments:
 *  pxdeSDRoot  [in]    Pointer to the root element of the SCPD DOM Document
 *  plNumVars   [out]   Address at which to place the number of state
 *                      variables exported by the service
 *  ppSST       [out]   Address at which to place the pointer to the
 *                      new array of SERVICE_STATE_TABLE_ROW structures
 *                      (array length will equal the value placed at
 *                      plNumVars)
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrCreateStateTable(
                   IN   IXMLDOMElement          * pxdeSDRoot,
                   OUT  LONG                    * plNumVars,
                   OUT  SERVICE_STATE_TABLE_ROW ** ppSST)
{
    HRESULT                 hr = S_OK;
    LONG                    lNumVars = 0;
    SERVICE_STATE_TABLE_ROW * pSST = NULL;
    IXMLDOMNode             * pxdnRoot = NULL;

    *plNumVars = 0;
    *ppSST = NULL;

    // Need to work with the document as an IXMLDOMNode interface.

    hr = pxdeSDRoot->QueryInterface(IID_IXMLDOMNode, (void **) &pxdnRoot);

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode             * pxdnSSTElement = NULL;
        LPCWSTR                 arypszTokens[] = {L"serviceStateTable"};

        // Get the <serviceStateTable> element.

        hr = HrGetNestedChildElement(pxdnRoot,
                                     arypszTokens,
                                     1,
                                     &pxdnSSTElement);

        if (SUCCEEDED(hr) && pxdnSSTElement)
        {
            IXMLDOMNodeList * pxdnlStateVarElements = NULL;

            // Get the list of <stateVariable> nodes.
            BSTR bstrPattern = NULL;
            bstrPattern = SysAllocString(L"stateVariable");

            if (bstrPattern)
            {
                hr = pxdnSSTElement->selectNodes(bstrPattern, &pxdnlStateVarElements);
                SysFreeString(bstrPattern);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {

                hr = HrAllocStateTable(pxdnlStateVarElements,
                                       &lNumVars,
                                       &pSST);

                if (FAILED(hr))
                {
                    TraceError("HrCreateStateTable(): "
                               "Failed to allocate state table", hr);
                }

                pxdnlStateVarElements->Release();
            }
            else
            {
                TraceError("HrCreateStateTable(): "
                           "Failed to get <stateVariable> elements",
                           hr);
            }

            pxdnSSTElement->Release();
        }
        else
        {
            TraceError("HrCreateStateTable(): "
                       "Failed to get <serviceStateTable> element",
                       hr);
        }

        pxdnRoot->Release();
    }
    else
    {
        TraceError("HrCreateStateTable(): "
                   "Failed to get IXMLDOMNode interface on SCPD doc", hr);
    }


    // At this point, if we have a successful hr, we should have allocated an
    // SST. If we have failed, pSST should be NULL and all resources should be
    // freed.

    Assert((SUCCEEDED(hr) && (pSST != NULL)) ||
           (FAILED(hr) && (pSST == NULL)));

    if (SUCCEEDED(hr))
    {
        *plNumVars = lNumVars;
        *ppSST = pSST;
    }

    return hr;
}


/*
 * Function:    FreeSST()
 *
 * Purpose:     Frees any memory used by a service state table.
 *
 */

VOID
FreeSST(
        IN  LONG                    lNumStateVars,
        IN  SERVICE_STATE_TABLE_ROW * pSST)
{
    if (pSST)
    {
        for (LONG i = 0; i < lNumStateVars; i++)
        {
            if (pSST[i].pwszVarName)
            {
                MemFree(pSST[i].pwszVarName);
                pSST[i].pwszVarName = NULL;
            }

            VariantClear(&(pSST[i].value));
        }

        MemFree(pSST);
        pSST = NULL;
    }
}


/*
 * Function:    FreeAction()
 *
 * Purpose:     Frees memory used by an action structure.
 */

VOID
FreeAction(
           IN   SERVICE_ACTION  *pAction)
{
    if (pAction->pwszName)
    {
        MemFree(pAction->pwszName);
        pAction->pwszName = NULL;
    }

    if (pAction->pInArguments)
    {
        for (LONG j = 0; j < pAction->lNumInArguments; j++)
        {
            SERVICE_ACTION_ARGUMENT * pArg =
                &((pAction->pInArguments)[j]);

            if (pArg->pwszName)
            {
                MemFree(pArg->pwszName);
                pArg->pwszName = NULL;
            }
        }
        MemFree(pAction->pInArguments);
        pAction->pInArguments = NULL;
    }

    pAction->lNumInArguments = 0;

    if (pAction->pOutArguments)
    {
        for (LONG j = 0; j < pAction->lNumOutArguments; j++)
        {
            SERVICE_ACTION_ARGUMENT * pArg =
                &((pAction->pOutArguments)[j]);

            if (pArg->pwszName)
            {
                MemFree(pArg->pwszName);
                pArg->pwszName = NULL;
            }
        }
        MemFree(pAction->pOutArguments);
        pAction->pOutArguments = NULL;
    }

    pAction->lNumOutArguments = 0;

    pAction->pReturnValue = NULL;
}

/*
 * Function:    HrValidateArgumentChildren()
 *
 * Purpose:     Validates that the child nodes of an <argument> element are
 *              valid.
 *
 * Arguments:
 *  pxdnArg         [in]    The <argument> element to validate
 *  plNumInArgs     [out]   If the argument is valid and is an in argument, the
 *                          number at this location is incremented
 *  plNumOutArgs    [out]   If the argument is valid and is an out argument,
 *                          the number at this location is incremented
 *  pbHasRetVal     [out]   Set to true if the <argument> element contains an
 *                          empty <retval> element
 * Return Value:
 *  S_OK if the argument element is valid, E_INVALIDARG otherwise.
 */


HRESULT
HrValidateArgumentChildren(
    IN  IXMLDOMNode    * pxdnArg,
    OUT LONG           * plNumInArgs,
    OUT LONG           * plNumOutArgs,
    OUT BOOL           * pbHasRetVal)
{
    HRESULT hr = S_OK;
    IXMLDOMNodeList    * pxdnlArgChildren = NULL;

    *pbHasRetVal = FALSE;

    hr = pxdnArg->get_childNodes(&pxdnlArgChildren);

    if (SUCCEEDED(hr))
    {
        long lNumChildren;

        hr = pxdnlArgChildren->get_length(&lNumChildren);

        if (SUCCEEDED(hr))
        {
            BOOL bFoundName = FALSE;
            BOOL bFoundRSV = FALSE;
            BOOL bFoundDirection = FALSE;
            BOOL bFoundRetVal = FALSE;

            for (long i = 0;
                 (i < lNumChildren) && SUCCEEDED(hr);
                 i++)
            {
                IXMLDOMNode    * pxdnChild = NULL;

                hr = pxdnlArgChildren->get_item(i, &pxdnChild);

                if (SUCCEEDED(hr))
                {
                    BSTR bstrValue = NULL;

                    hr = HrGetTextValueFromElement(pxdnChild,
                                                   &bstrValue);
                    if (SUCCEEDED(hr))
                    {
                        if (FIsThisTheNodeName(pxdnChild,
                                               L"name"))
                        {
                            if (bFoundName)
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentChildren(): "
                                           "Duplicate <name> element found",
                                           hr);
                            }

                            bFoundName = TRUE;
                        }
                        else if (FIsThisTheNodeName(pxdnChild,
                                                    L"relatedStateVariable"))
                        {
                            if (bFoundRSV)
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentChildren(): "
                                           "Duplicate <relatedStateVariable> element found",
                                           hr);
                            }

                            bFoundRSV = TRUE;
                        }
                        else if (FIsThisTheNodeName(pxdnChild,
                                                    L"direction"))
                        {
                            if (bFoundDirection)
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentChildren(): "
                                           "Duplicate <direction> element found",
                                           hr);
                            }

                            bFoundDirection = TRUE;
                            if (wcscmp(bstrValue, L"in") == 0)
                            {
                                (*plNumInArgs)++;
                            }
                            else if (wcscmp(bstrValue, L"out") == 0)
                            {
                                (*plNumOutArgs)++;
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentChildren(): "
                                           "<direction> element contained "
                                           "invalid value",
                                           hr);
                            }
                        }
                        else if (FIsThisTheNodeName(pxdnChild,
                                                    L"retval"))
                        {
                            if (bFoundRetVal)
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentChildren(): "
                                           "Duplicate <retval> element found",
                                           hr);
                            }

                            bFoundRetVal = TRUE;
                            if (wcscmp(bstrValue, L"") == 0)
                            {
                                *pbHasRetVal = TRUE;
                            }
                            else
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentChildren(): "
                                           "<retval> element was "
                                           "not empty",
                                           hr);
                            }
                        }

                        SysFreeString(bstrValue);
                    }
                    else
                    {
                        TraceError("HrValidateArgumentChildren(): "
                                   "Failed to get text value from element",
                                   hr);
                    }

                    pxdnChild->Release();
                }
                else
                {
                    TraceError("HrValidateArgumentChildren(): "
                               "Failed to get child node",
                               hr);
                }
            }

            if (SUCCEEDED(hr))
            {
                if (bFoundName &&
                    bFoundRSV &&
                    bFoundDirection) // retval is optional, so we don't check
                {
                    TraceTag(ttidRehydrator,
                             "HrValidateArgumentChildren(): "
                             "Validation passed!");
                }
                else
                {
                    hr = E_INVALIDARG;
                    TraceError("HrValidateArgumentChildren(): "
                               "Validation failed: one or more elements "
                               "missing",
                               hr)
                }
            }
        }
        else
        {
            TraceError("HrValidateArgumentChildren(): "
                       "Failed to get number of children",
                       hr);
        }

        pxdnlArgChildren->Release();
    }
    else
    {
        TraceError("HrValidateArgumentChildren(): "
                   "Failed to get argument children",
                   hr);
    }


    TraceError("HrValidateArgumentChildren(): "
               "Exiting",
               hr);

    return hr;

}




/*
 * Function:    HrValidateArgumentList()
 *
 * Purpose:     Validates the list of arguments. The following must be true
 *              for this function to return success:
 *              1. Every argument must have <name>, <relatedStateVariable>, and
 *                 <direction> elements (in that order).
 *              2. The <direction> element value must be either "in" or "out".
 *              3. All in arguments must appear before any out arguments.
 *              4. The <retval> element must not appear in any in arguments.
 *              5. The <retval> element, if present, must be in the first out
 *                 argument.
 *
 * Arguments:
 *  pxdnlArguments  [in]    List of <argument> elements
 *  plNumInArgs     [out]   Returns the number of in arguments found
 *  plNumOutArgs    [out]   Returns the number of out arguments found
 *
 * Return Value:
 *  S_OK if the argument list is valid, E_INVALIDARG otherwise.
 */

HRESULT
HrValidateArgumentList(
    IN  IXMLDOMNodeList    * pxdnlArguments,
    OUT LONG               * plNumInArgs,
    OUT LONG               * plNumOutArgs)
{
    HRESULT hr = S_OK;
    LONG    lNumArgs = 0, lNumInArgs = 0, lNumOutArgs = 0;
    BOOL    bFoundFirstOutArg = FALSE;

    hr = pxdnlArguments->get_length(&lNumArgs);

    if (SUCCEEDED(hr))
    {
        for (long i = 0;
             (i < lNumArgs) && SUCCEEDED(hr);
             i++)
        {
            IXMLDOMNode    * pxdnArg = NULL;

            hr = pxdnlArguments->get_item(i, &pxdnArg);

            if (SUCCEEDED(hr))
            {
                LONG   lOldNumInArgs, lOldNumOutArgs;
                BOOL   bHasRetVal = FALSE;

                lOldNumInArgs = lNumInArgs;
                lOldNumOutArgs = lNumOutArgs;

                hr = HrValidateArgumentChildren(pxdnArg,
                                                &lNumInArgs,
                                                &lNumOutArgs,
                                                &bHasRetVal);

                if (SUCCEEDED(hr))
                {
                    if (lNumInArgs > lOldNumInArgs)
                    {
                        // Just found an in argument - must be before
                        // all out arguments, and must not have a retval.

                        if (bFoundFirstOutArg)
                        {
                            hr = E_INVALIDARG;
                            TraceError("HrValidateArgumentList(): "
                                       "in argument found after first out "
                                       "argument",
                                       hr);
                        }
                        else if (bHasRetVal)
                        {
                            hr = E_INVALIDARG;
                            TraceError("HrValidateArgumentList(): "
                                       "in argument has <retval> element",
                                       hr);

                        }
                    }
                    else
                    {
                        // Just found an out argument - if it's the first one
                        // it may contain a <retval> element.

                        if (!bFoundFirstOutArg)
                        {
                            bFoundFirstOutArg = TRUE;
                        }
                        else
                        {
                            if (bHasRetVal)
                            {
                                hr = E_INVALIDARG;
                                TraceError("HrValidateArgumentList(): "
                                           "<retval> tag found after the "
                                           "first out argument",
                                           hr);
                            }
                        }
                    }
                }
                pxdnArg->Release();
            }
            else
            {
                TraceError("HrValidateArgumentList(): "
                           "Failed to get length of argument list",
                           hr);
            }
        }
    }
    else
    {
        TraceError("HrValidateArgumentList(): "
                   "Failed to get length of argument list",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        *plNumInArgs = lNumInArgs;
        *plNumOutArgs = lNumOutArgs;
    }
    TraceError("HrValidateArgumentList(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrInitializeActionArguments()
 *
 * Purpose:     Allocates and initializes an array of SERVICE_ACTION_ARGUMENT
 *              structures to represent the arguments to an action.
 *
 * Arguments:
 *  pAction             [in]    Pointer to the SERVICE_ACTION structure in
 *                              which to create the argument array
 *  pxdnlArguments      [in]    List of <actionArgument> element nodes
 *                              specified in the <action> element
 *  lNumStateVars       [in]    Number of variables in the service's SST
 *  pSST                [in]    Pointer to the service's SST (created by
 *                              HrCreateStateTable())
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrInitializeActionArguments(IN  SERVICE_ACTION          * pAction,
                            IN  IXMLDOMNodeList         * pxdnlArguments,
                            IN  LONG                    lNumStateVars,
                            IN  SERVICE_STATE_TABLE_ROW * pSST)
{
    HRESULT hr = S_OK;
    LONG    lNumInArguments = 0, lNumOutArguments = 0;

    hr = HrValidateArgumentList(pxdnlArguments,
                                &lNumInArguments,
                                &lNumOutArguments);

    if (SUCCEEDED(hr))
    {
        // Allocate argument arrays.

        size_t sizeToAlloc = 0;

        sizeToAlloc = lNumInArguments * sizeof(SERVICE_ACTION_ARGUMENT);

        pAction->pInArguments = (SERVICE_ACTION_ARGUMENT *)
            MemAlloc(sizeToAlloc);

        sizeToAlloc = lNumOutArguments * sizeof(SERVICE_ACTION_ARGUMENT);

        pAction->pOutArguments = (SERVICE_ACTION_ARGUMENT *)
            MemAlloc(sizeToAlloc);

        if (pAction->pInArguments && pAction->pOutArguments)
        {
            pAction->lNumInArguments = 0;
            pAction->lNumOutArguments = 0;

            // Go through and initialize the in arguments.

            for (LONG i = 0; i < lNumInArguments; i++)
            {
                SERVICE_ACTION_ARGUMENT * psaaArg =
                    &(pAction->pInArguments[i]);

                IXMLDOMNode * pxdnArg = NULL;

                hr = pxdnlArguments->get_item(i, &pxdnArg);

                if (SUCCEEDED(hr))
                {
                    LPCWSTR pwszNameToken = L"name";
                    BSTR    bstrName;
                    LPCWSTR pwszRelVarToken = L"relatedStateVariable";
                    BSTR    bstrRelVar;

                    hr = HrGetTextValueFromChildElement(pxdnArg,
                                                        &pwszNameToken,
                                                        1,
                                                        &bstrName);

                    if (SUCCEEDED(hr))
                    {
                        psaaArg->pwszName = WszAllocateAndCopyWsz(bstrName);

                        if (psaaArg->pwszName)
                        {
                            hr =
                                HrGetTextValueFromChildElement(pxdnArg,
                                                               &pwszRelVarToken,
                                                               1,
                                                               &bstrRelVar);

                            if (SUCCEEDED(hr) && bstrRelVar)
                            {
                                SST_DATA_TYPE sdt = SDT_INVALID;

                                for (LONG j = 0; j < lNumStateVars; j++)
                                {
                                    if (_wcsicmp(bstrRelVar,
                                                 pSST[j].pwszVarName) == 0)
                                    {
                                        sdt = pSST[j].sdtType;
                                        break;
                                    }
                                }

                                if (sdt != SDT_INVALID)
                                {
                                    psaaArg->sdtType = sdt;
                                    TraceTag(ttidRehydrator,
                                             "ARGUMENT %S\t sdtType 0x%x",
                                             psaaArg->pwszName,
                                             psaaArg->sdtType);
                                }
                                else
                                {
                                    hr = E_FAIL;
                                    TraceError("HrInitializeActionArgument(): "
                                               "Could not find related state "
                                               "variable in SST", hr);
                                }

                                SysFreeString(bstrRelVar);
                            }
                            else
                            {
                                if (SUCCEEDED(hr))
                                {
                                    // The XML DOM operations succeeded,
                                    // but there was no <relatedStateVariable>
                                    // element.

                                    hr = E_INVALIDARG;
                                }
                                TraceError("HrInitializeActionArgument(): "
                                           "Could not get related state var",
                                           hr);
                            }

                            if (FAILED(hr)) {
                                MemFree(psaaArg->pwszName);
                                psaaArg->pwszName = NULL;
                            }

                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("HrInitializeActionArgument(): "
                                       "Could not copy action name", hr);
                        }


                        SysFreeString(bstrName);
                    }
                    else
                    {
                        TraceError("HrInitializeActionArguments(): "
                                   "Could not get argument name", hr);
                    }

                    pxdnArg->Release();
                }
                else
                {
                    TraceError("HrInitializeActionArguments(): "
                               "Failed to get argument element", hr);
                }

                if (SUCCEEDED(hr))
                {
                    pAction->lNumInArguments++;
                }
                else
                {
                    break;
                }
            }

            if (FAILED(hr))
            {
                for (LONG j = 0; j < pAction->lNumInArguments; j++)
                {
                    if ((pAction->pInArguments[j]).pwszName)
                    {
                        MemFree((pAction->pInArguments[j]).pwszName);
                        (pAction->pInArguments[j]).pwszName = NULL;
                    }
                }

                pAction->lNumInArguments = 0;
                MemFree(pAction->pInArguments);
                pAction->pInArguments = NULL;

                // Free the array of out arguments, though we don't
                // need to free anything inside it, because it has
                // not been initialized.

                pAction->lNumOutArguments = 0;
                MemFree(pAction->pOutArguments);
                pAction->pOutArguments = NULL;
            }

            for (i = 0;
                 SUCCEEDED(hr) && (i < lNumOutArguments);
                 i++)
            {
                SERVICE_ACTION_ARGUMENT * psaaArg =
                    &(pAction->pOutArguments[i]);

                IXMLDOMNode * pxdnArg = NULL;

                hr = pxdnlArguments->get_item(lNumInArguments + i, &pxdnArg);

                if (SUCCEEDED(hr))
                {
                    LPCWSTR pwszNameToken = L"name";
                    BSTR    bstrName;
                    LPCWSTR pwszRelVarToken = L"relatedStateVariable";
                    BSTR    bstrRelVar;
                    LPCWSTR pwszRetValToken = L"retval";

                    hr = HrGetTextValueFromChildElement(pxdnArg,
                                                        &pwszNameToken,
                                                        1,
                                                        &bstrName);

                    if (SUCCEEDED(hr))
                    {
                        psaaArg->pwszName = WszAllocateAndCopyWsz(bstrName);

                        if (psaaArg->pwszName)
                        {
                            hr =
                                HrGetTextValueFromChildElement(pxdnArg,
                                                               &pwszRelVarToken,
                                                               1,
                                                               &bstrRelVar);

                            if (SUCCEEDED(hr) && bstrRelVar)
                            {
                                SST_DATA_TYPE sdt = SDT_INVALID;
                                IXMLDOMNode   * pxdnRetVal = NULL;

                                for (LONG j = 0; j < lNumStateVars; j++)
                                {
                                    if (_wcsicmp(bstrRelVar,
                                                 pSST[j].pwszVarName) == 0)
                                    {
                                        sdt = pSST[j].sdtType;
                                        break;
                                    }
                                }

                                if (sdt != SDT_INVALID)
                                {
                                    psaaArg->sdtType = sdt;
                                    TraceTag(ttidRehydrator,
                                             "ARGUMENT %S\t sdtType 0x%x",
                                             psaaArg->pwszName,
                                             psaaArg->sdtType);

                                    hr = HrGetNestedChildElement(pxdnArg,
                                                                 &pwszRetValToken,
                                                                 1,
                                                                 &pxdnRetVal);

                                    if (S_OK == hr)
                                    {
                                        // There is a retval element.
                                        pAction->pReturnValue = psaaArg;
                                        pxdnRetVal->Release();
                                    }
                                    else
                                    {
                                        // Failed to get the retval element.
                                        // This is not an error - this arg is
                                        // just not the return value.
                                        hr = S_OK;
                                    }
                                }
                                else
                                {
                                    hr = E_FAIL;
                                    TraceError("HrInitializeActionArgument(): "
                                               "Could not find related state "
                                               "variable in SST", hr);
                                }

                                SysFreeString(bstrRelVar);
                            }
                            else
                            {
                                if (SUCCEEDED(hr))
                                {
                                    // The XML DOM operations succeeded,
                                    // but there was no <relatedStateVariable>
                                    // element.

                                    hr = E_INVALIDARG;
                                }
                                TraceError("HrInitializeActionArgument(): "
                                           "Could not get related state var",
                                           hr);
                            }

                            if (FAILED(hr)) {
                                MemFree(psaaArg->pwszName);
                                psaaArg->pwszName = NULL;
                            }

                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                            TraceError("HrInitializeActionArgument(): "
                                       "Could not copy action name", hr);
                        }


                        SysFreeString(bstrName);
                    }
                    else
                    {
                        TraceError("HrInitializeActionArguments(): "
                                   "Could not get argument name", hr);
                    }

                    pxdnArg->Release();
                }
                else
                {
                    TraceError("HrInitializeActionArguments(): "
                               "Failed to get argument element", hr);
                }

                if (SUCCEEDED(hr))
                {
                    pAction->lNumOutArguments++;
                }
                else
                {
                    break;
                }
            }

            if (FAILED(hr))
            {
                // Have to free both the in arguments we allocated, as well
                // as the out arguments.

                for (LONG j = 0; j < pAction->lNumInArguments; j++)
                {
                    if ((pAction->pInArguments[j]).pwszName)
                    {
                        MemFree((pAction->pInArguments[j]).pwszName);
                        (pAction->pInArguments[j]).pwszName = NULL;
                    }
                }

                pAction->lNumInArguments = 0;
                MemFree(pAction->pInArguments);
                pAction->pInArguments = NULL;

                for (j = 0; j < pAction->lNumOutArguments; j++)
                {
                    if ((pAction->pOutArguments[j]).pwszName)
                    {
                        MemFree((pAction->pOutArguments[j]).pwszName);
                        (pAction->pOutArguments[j]).pwszName = NULL;
                    }
                }

                pAction->lNumOutArguments = 0;
                MemFree(pAction->pOutArguments);
                pAction->pOutArguments = NULL;

                pAction->pReturnValue = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrInitializeActionArguments(): "
                       "Could not allocate argument arrays",
                       hr);
        }
    }
    else
    {
        TraceError("HrInitializeActionArguments(): "
                   "Argument list failed validation",
                   hr);
    }


    TraceError("HrInitializeActionArguments(): "
               "Exiting",
               hr);
    return hr;
}


/*
 * Function:    HrInitializeAction()
 *
 * Purpose:     Initializes a SERVICE_ACTION structure with the information
 *              contained in an <action> element from an SCPD document.
 *
 *
 * Arguments:
 *  pAction             [in]    Pointer to the SERVICE_ACTION structure to
 *                              initialize
 *  pActionElement      [in]    The <action> element from which to initialize
 *                              the structure
 *  lNumStateVars       [in]    Number of variables in the service's SST
 *  pSST                [in]    Pointer to the service's SST (created by
 *                              HrCreateStateTable())
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrInitializeAction(IN   SERVICE_ACTION          * pAction,
                   IN   IXMLDOMNode             * pxdnActionElement,
                   IN   LONG                    lNumStateVars,
                   IN   SERVICE_STATE_TABLE_ROW * pSST)
{
    HRESULT hr = S_OK;
    BSTR    bstrActionName;
    LPCWSTR pwszNameToken = L"name";

    hr = HrGetTextValueFromChildElement(pxdnActionElement,
                                        &pwszNameToken,
                                        1,
                                        &bstrActionName);

    if (SUCCEEDED(hr))
    {
        pAction->pwszName = WszAllocateAndCopyWsz(bstrActionName);

        if (pAction->pwszName)
        {
            IXMLDOMNode * pxdnArgListElement = NULL;

            TraceTag(ttidRehydrator, "Action: %S", pAction->pwszName);

            // Get the action arguments.

            hr = HrGetFirstChildElement(pxdnActionElement,
                                        L"argumentList",
                                        &pxdnArgListElement);

            if (SUCCEEDED(hr))
            {
                // The above call may have "succeeded", but if there
                // was no argument list element (it is optional) then
                // the pxdnArgListElement pointer will be null. This
                // is not an error; it just means that the action takes no
                // arguments.

                if (pxdnArgListElement)
                {
                    IXMLDOMNodeList * pxdnlArguments = NULL;

                    BSTR bstrPattern = NULL;
                    bstrPattern = SysAllocString(L"argument");

                    if (bstrPattern)
                    {
                        hr = pxdnArgListElement->selectNodes(bstrPattern, &pxdnlArguments);
                        SysFreeString(bstrPattern);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = HrInitializeActionArguments(pAction,
                                                         pxdnlArguments,
                                                         lNumStateVars,
                                                         pSST);

                        if (FAILED(hr))
                        {
                            TraceError("HrInitializeAction(): "
                                       "Failed to initialize action args",
                                       hr);
                        }

                        pxdnlArguments->Release();
                    }
                    else
                    {
                        TraceError("HrInitializeAction(): "
                                   "Could not get <argumentList> child "
                                   "elements",
                                   hr);
                    }


                    pxdnArgListElement->Release();
                }
                else
                {
                    pAction->lNumInArguments = 0;
                    pAction->pInArguments = NULL;
                    pAction->lNumOutArguments = 0;
                    pAction->pOutArguments = NULL;
                }
            }
            else
            {
                TraceError("HrInitializeAction(): "
                           "Could not get <argumentList> element",
                           hr);
            }


            if (FAILED(hr))
            {
                MemFree(pAction->pwszName);
                pAction->pwszName = NULL;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrInitializeAction(): Could not copy action name",
                       hr);

        }

        SysFreeString(bstrActionName);
    }
    else
    {
        TraceError("HrInitializeAction(): Could not get action name",
                   hr);
    }

    return hr;
}


/*
 * Function:    HrAllocActionTable()
 *
 * Purpose:     Allocates and initializes an array of SERVICE_ACTION
 *              structures to represent a list of <action> elements
 *              from an SCPD document.
 *
 *
 * Arguments:
 *  pxdnlActionElements [in]    List of <action> element nodes from the SCPD
 *  lNumStateVars       [in]    Number of variables in the service's SST
 *  pSST                [in]    Pointer to the service's SST (created by
 *                              HrCreateStateTable())
 *  plNumActions        [out]   Address at which to place the number of
 *                              action that will be in the new action table
 *  ppActionTable       [out]   Address at which to place the newly allocated
 *                              action table
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrAllocActionTable(
                   IN   IXMLDOMNodeList         * pxdnlActionElements,
                   IN   LONG                    lNumStateVars,
                   IN   SERVICE_STATE_TABLE_ROW * pSST,
                   OUT  LONG                    * plNumActions,
                   OUT  SERVICE_ACTION          ** ppActionTable)

{
    HRESULT         hr = S_OK;
    LONG            lNumActions = 0;
    SERVICE_ACTION  * pActionTable = NULL;

    *plNumActions = 0;
    *ppActionTable = NULL;

    // Determine how many actions there are.

    hr = pxdnlActionElements->get_length(&lNumActions);

    if (SUCCEEDED(hr))
    {
        if (lNumActions > 0)
        {
            size_t sizeToAlloc = lNumActions * sizeof(SERVICE_ACTION);

            // Allocate an array of action structures.

            pActionTable = (SERVICE_ACTION *) MemAlloc(sizeToAlloc);

            if (pActionTable)
            {
                LONG i;

                ZeroMemory((PVOID) pActionTable, sizeToAlloc);

                for (i = 0; i < lNumActions; i++)
                {
                    IXMLDOMNode * pxdnActionElement = NULL;

                    hr = pxdnlActionElements->get_item(i,
                                                       &pxdnActionElement);

                    if (SUCCEEDED(hr))
                    {
                        hr = HrInitializeAction(&(pActionTable[i]),
                                                pxdnActionElement,
                                                lNumStateVars,
                                                pSST);

                        pxdnActionElement->Release();
                    }
                    else
                    {
                        TraceError("HrAllocActionTable(): "
                                   "Failed to get <action> element", hr);
                    }

                    // If something failed, then we don't want to continue.

                    if (FAILED(hr))
                    {
                        break;
                    }
                }

                if (FAILED(hr))
                {
                    Assert(i < lNumActions);

                    for (LONG j = 0; j < i; j++)
                    {
                        FreeAction(&(pActionTable[j]));
                    }

                    MemFree(pActionTable);
                    pActionTable = NULL;
                }

            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrAllocActionTable(): "
                           "Failed to allocate array of actions", hr);
            }
        }
        else
        {
            TraceTag(ttidRehydrator,
                     "HrAllocateActionTable(): "
                     "Service has no actions, not building action table\n");
        }
    }
    else
    {
        TraceError("HrAllocActionTable(): Failed to get number of actions", hr);
    }

    if (SUCCEEDED(hr))
    {
        *plNumActions = lNumActions;
        *ppActionTable = pActionTable;
    }

    return hr;
}


/*
 * Function:    HrCreateActionTable()
 *
 * Purpose:     Creates an array of SERVICE_ACTION structures to
 *              represent the actions exported by a service declared
 *              in an SCPD document.
 *
 * Arguments:
 *  pxdeSDRoot      [in]    The root element of the SCPD DOM document
 *  lNumStateVars   [in]    Number of variables in the service's SST
 *  pSST            [in]    Pointer to the service's SST (created by
 *                          HrCreateStateTable())
 *  plNumActions    [out]   Address at which to place the number of
 *                          action that will be in the new action table
 *  ppActionTable   [out]   Address at which to place the newly allocated
 *                          action table
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrCreateActionTable(
                    IN   IXMLDOMElement          * pxdeSDRoot,
                    IN   LONG                    lNumStateVars,
                    IN   SERVICE_STATE_TABLE_ROW * pSST,
                    OUT  LONG                    * plNumActions,
                    OUT  SERVICE_ACTION          ** ppActionTable)
{
    HRESULT             hr = S_OK;
    LONG                lNumActions = 0;
    SERVICE_ACTION      * pActionTable = NULL;
    IXMLDOMNode         * pxdnRoot = NULL;

    *plNumActions = 0;
    *ppActionTable = NULL;

    // Need to work with the document as an IXMLDOMNode interface.

    hr = pxdeSDRoot->QueryInterface(IID_IXMLDOMNode, (void **) &pxdnRoot);

    if (SUCCEEDED(hr))
    {
        IXMLDOMNode * pxdnActionListElement = NULL;
        LPCWSTR     arypszTokens[] = {L"actionList"};

        // Get the <actionList> element.

        hr = HrGetNestedChildElement(pxdnRoot,
                                     arypszTokens,
                                     1,
                                     &pxdnActionListElement);

        if (SUCCEEDED(hr) && pxdnActionListElement)
        {
            IXMLDOMNodeList * pxdnlActionElements = NULL;

            // Get the list of <action> nodes.

            BSTR bstrPattern = NULL;
            bstrPattern = SysAllocString(L"action");

            if (bstrPattern)
            {
                hr = pxdnActionListElement->selectNodes(bstrPattern, &pxdnlActionElements);
                SysFreeString(bstrPattern);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                hr = HrAllocActionTable(pxdnlActionElements,
                                        lNumStateVars,
                                        pSST,
                                        &lNumActions,
                                        &pActionTable);

                if (FAILED(hr))
                {
                    TraceError("HrCreateActionTable(): "
                               "Failed to allocate action table",
                               hr);
                }

                pxdnlActionElements->Release();
            }
            else
            {
                TraceError("HrCreateActionTable(): "
                           "Failed to get <action> elements",
                           hr);
            }


            pxdnActionListElement->Release();
        }
        else
        {
            TraceError("HrCreateActionTable(): "
                       "Failed to get <actionList> element",
                       hr);

        }

        pxdnRoot->Release();
    }
    else
    {
        TraceError("HrCreateActionTable(): "
                   "Failed to get IXMLDOMNode interface on SCPD document",
                   hr);
    }

    if (SUCCEEDED(hr))
    {
        *plNumActions = lNumActions;
        *ppActionTable = pActionTable;
    }

    return hr;
}


/*
 * Function:    HrRehydratorCreateServiceObject()
 *
 * Purpose:     Create a new service object.
 *
 * Arguments:
 *  pcwszSTI           [in]    Service Type Identifier for the service
 *                              instance the object is to represent.
 *  pcwszControlURL    [in]    The HTTP URL to which control requests will
 *                              be sent.
 *  pcwszEventSubURL   [in]    The HTTP URL to which event subscription
 *                              requests will be sent
 *  pSCPD               [in]    Pointer to the DOM for the SCPD for the service
 *                              instance the object is to represent
 *  pNewServiceObject   [out]   Address at which to place the IUPnPService
 *                              pointer of the new service object
 *
 * Returns: S_OK if successful, other HRESULT if error.
 */

HRESULT
HrRehydratorCreateServiceObject(
                               IN    LPCWSTR         pcwszSTI,
                               IN    LPCWSTR         pcwszControlURL,
                               IN    LPCWSTR         pcwszEventSubURL,
                               IN    LPCWSTR         pcwszId,
                               IN    IXMLDOMDocument *       pSCPD,
                               OUT   IUPnPService    **      pNewServiceObject)
{
    HRESULT                     hr = S_OK;
    CComObject<CUPnPServicePublic>    * psvcObject = NULL;

    TraceTag(ttidRehydrator, "HrRehydratorCreateServiceObject(): Enter\n");

    // Check for null / invalid pointer / empty string arguments.

    if ((pcwszSTI == NULL) ||
        (pcwszControlURL == NULL) ||
        (pcwszEventSubURL == NULL) ||
        (pcwszId == NULL) ||
        (pSCPD == NULL) ||
        (pNewServiceObject == NULL))
    {
        hr = E_POINTER;
        TraceError("HrRehydratorCreateServiceObject(): "
                   "Pointer argument was NULL\n", hr);
    }
    else if (IsBadStringPtrW(pcwszSTI, MAX_STRING_LENGTH) ||
             IsBadStringPtrW(pcwszControlURL, MAX_STRING_LENGTH) ||
             IsBadStringPtrW(pcwszEventSubURL, MAX_STRING_LENGTH) ||
             IsBadStringPtrW(pcwszId, MAX_STRING_LENGTH) ||
             IsBadCodePtr((FARPROC) pSCPD) ||
             IsBadWritePtr((void *) pNewServiceObject, sizeof(IUPnPService *)))
    {
        hr = E_POINTER;
        TraceError("HrRehydratorCreateServiceObject(): "
                   "Bad non-NULL pointer argument", hr);
    }
    else if ((UNICODE_NULL == *pcwszSTI) ||
             (UNICODE_NULL == *pcwszControlURL) ||
             (UNICODE_NULL == *pcwszId))    // Note, we allow a blank event Sub URL
    {
        hr = E_INVALIDARG;
        TraceError("HrRehydratorCreateServiceObject(): "
                   "Emptry string argument", hr);
    }
    else
    {
        // Validate the service description.
        IXMLDOMElement * pxdeSDRoot = NULL;

        hr = pSCPD->get_documentElement(&pxdeSDRoot);

        if (S_OK == hr)
        {
            LPWSTR szError = NULL;

            Assert(pxdeSDRoot);

            hr = HrValidateServiceDescription(pxdeSDRoot, &szError);

            if (SUCCEEDED(hr))
            {
                TraceTag(ttidRehydrator,
                         "HrRehydratorCreateServiceObject(): "
                         "Service description document passed validation",
                         hr);
            }
            else if (UPNP_E_INVALID_DOCUMENT == hr)
            {
                TraceTag(ttidRehydrator,
                         "HrRehydratorCreateServiceObject(): "
                         "Service Description Validation failed: %S",
                         szError);
            }
            else
            {
                TraceError("HrRehydratorCreateServiceObject(): "
                           "Failed to validate service description",
                           hr);
            }

            if (szError)
            {
                delete [] szError;
                szError = NULL;
            }
        }

        if (SUCCEEDED(hr))
        {
            *pNewServiceObject = NULL;

            // Create an new service object instance.

            hr = CComObject<CUPnPServicePublic>::CreateInstance(&psvcObject);

            if (SUCCEEDED(hr))
            {
                Assert(psvcObject);

                LONG                    lNumStateVars;
                SERVICE_STATE_TABLE_ROW * pSST;

                psvcObject->AddRef();   // This brings the refcount to 1.

                hr = HrCreateStateTable(pxdeSDRoot, &lNumStateVars, &pSST);

                if (SUCCEEDED(hr))
                {
                    LONG            lNumActions;
                    SERVICE_ACTION  * pActionTable;

                    hr = HrCreateActionTable(pxdeSDRoot,
                                             lNumStateVars,
                                             pSST,
                                             &lNumActions,
                                             &pActionTable);

                    if (SUCCEEDED(hr))
                    {
                        hr = psvcObject->HrInitialize(pcwszSTI,
                                                      pcwszControlURL,
                                                      pcwszEventSubURL,
                                                      pcwszId,
                                                      lNumStateVars,
                                                      pSST,
                                                      lNumActions,
                                                      pActionTable);
                        if (SUCCEEDED(hr))
                        {
                            hr = psvcObject->QueryInterface(pNewServiceObject);
                        }
                        else
                        {
                            TraceError("HrRehydratorCreateServiceObject(): "
                                       "Failed to initialize service object", hr);
                        }
                    }
                    else
                    {
                        // This is really the only place we need to free the SST,
                        // because we have not yet called HrInitialize.
                        //
                        // After calling HrInitialize(), the memory for the SST and
                        // the action table is owned by the service object, and
                        // therefore will be freed by the service object. This is
                        // true whether or not HrInitialize() succeeds.

                        FreeSST(lNumStateVars, pSST);
                        pSST = NULL;
                        lNumStateVars = 0;
                        TraceError("HrRehydratorCreateServiceObject(): "
                                   "Failed to allocate action table", hr);
                    }
                }
                else
                {
                    TraceError("HrRehydratorCreateServiceObject(): "
                               "Failed to allocate state table", hr);
                }

                // If everything above succeeded, then we did a QueryInterface()
                // which would put the refcount at 2. This release takes it to 1,
                // where it should be for a newly created object. If something
                // above failed and we did not do a QueryInterface, then the
                // refcount is still 1, and this release will free the object.

                psvcObject->Release();
            }
            else
            {
                TraceError("HrRehydratorCreateServiceObject(): "
                           "Failed to create service object instance", hr);
            }
        }

        if (pxdeSDRoot)
        {
            pxdeSDRoot->Release();
            pxdeSDRoot = NULL;
        }
    }

    TraceTag(ttidRehydrator, "HrRehydratorCreateServiceObject(): Exit - "
             "Returning hr == 0x%x\n", hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\rehy\rehyinv.cpp ===
/*
 * HrRehy.cpp
 *
 * Implementation of the RehydratorInvokeServiceAction() API.
 *
 * Owner: Shyam Pather (SPather)
 *
 * Copyright 1986-2000 Microsoft Corporation, All Rights Reserved
 */

#include <pch.h>
#pragma hdrstop

#include "rehy.h"
#include "rehyutil.h"
#include "ncutil.h"
#include "soapsink.h"

/*
 * Function:    HrExtractResponseValues()
 *
 * Purpose:     Extracts an action's return value and the
 *              values of its out parameters from a SOAP
 *              response element.
 *
 * Arguments:
 *  pxdnResponse    [in]    The SOAP response element
 *  pAction         [in]    The action that was invoked
 *  psa             [in]    SAFEARRAY in which to put the
 *                          out parameter values
 *  pvRetVal        [out]   Returns the action's return value
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrExtractResponseValues(
    IN  IXMLDOMNode    * pxdnResponse,
    IN  SERVICE_ACTION * pAction,
    IN  SAFEARRAY      * psa,
    OUT VARIANT        * pvRetVal)
{
    HRESULT            hr = S_OK;
    IXMLDOMNodeList    * pxdnlChildren = NULL;

    hr = pxdnResponse->get_childNodes(&pxdnlChildren);

    if (SUCCEEDED(hr))
    {
        long lNumChildren;

        hr = pxdnlChildren->get_length(&lNumChildren);

        if (SUCCEEDED(hr))
        {
            if (lNumChildren == pAction->lNumOutArguments)
            {
                long       lSafeArrayIndex = 0;
                VARIANT    vRetVal;

                VariantInit(&vRetVal);

                for (long i = 0;
                     (i < lNumChildren) && SUCCEEDED(hr);
                     i++)
                {
                    IXMLDOMNode    * pxdnChild = NULL;
                    SERVICE_ACTION_ARGUMENT    * psaa;

                    psaa = &(pAction->pOutArguments[i]);

                    hr = pxdnlChildren->get_item(i,
                                                 &pxdnChild);

                    if (SUCCEEDED(hr))
                    {
                        VARIANT vChildValue;

                        VariantInit(&vChildValue);

                        if (FIsThisTheNodeName(pxdnChild,
                                               psaa->pwszName))
                        {
                            VARIANT    * pvDest;

                            if (psaa == pAction->pReturnValue)
                            {
                                pvDest = &vRetVal;
                            }
                            else
                            {
                                pvDest = &vChildValue;
                            }

                            hr = HrGetTypedValueFromElement(pxdnChild,
                                                            psaa->sdtType,
                                                            pvDest);

                            if (SUCCEEDED(hr))
                            {
                                if (psaa != pAction->pReturnValue)
                                {
                                    long rgIndices[1];

                                    // It's not the return value,
                                    // so put it in the array of
                                    // out parameters.

                                    rgIndices[0] = lSafeArrayIndex;

                                    hr = SafeArrayPutElement(psa,
                                                             rgIndices,
                                                             (void *) pvDest);

                                    lSafeArrayIndex++;
                                    if (FAILED(hr))
                                    {
                                        TraceError("HrExtractResponseValues(): "
                                                   "Failed to put out parameter "
                                                   "value into SAFEARRAY",
                                                   hr);
                                    }
                                }
                            }
                            else
                            {
                                TraceError("HrExtractResponseValues(): "
                                           "Failed to get type value "
                                           "from response element child",
                                           hr);
                            }

                        }
                        else
                        {
                            hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                            TraceError("HrExtractResponseValues(): "
                                       "Child name did not match "
                                       "out parameter name",
                                       hr);
                        }


                        VariantClear(&vChildValue);
                        pxdnChild->Release();
                    }
                }

                if (SUCCEEDED(hr))
                {
                    hr = VariantCopy(pvRetVal,
                                     &vRetVal);
                    if (FAILED(hr))
                    {
                        TraceError("HrExtractResponseValues(): "
                                   "Failed to copy return value "
                                   "VARIANT",
                                   hr);
                    }
                }

                VariantClear(&vRetVal);
            }
            else
            {
                hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                TraceError("HrExtractResponseValues(): "
                           "Number of response element "
                           "children did not match number "
                           "of out parameters expected",
                           hr);
            }
        }
        else
        {
            TraceError("HrExtractResponseValues(): "
                       "Could not get length of "
                       "response element child list",
                       hr);
        }

        pxdnlChildren->Release();
    }
    else
    {
        TraceError("HrExtractResponseValues(): "
                   "Could not get children of "
                   "response element",
                   hr);
    }


    TraceError("HrExtractResponseValues(): "
               "Exiting",
               hr);
    return hr;
}

/*
 * Function:    HrParseResponse()
 *
 * Purpose:     Parses the SOAP response element and extracts the
 *              return value and the values of any out parameters.
 *
 * Arguments:
 *  psr         [in]    The SOAP request object
 *  pAction     [in]    The action that was invoked using the SOAP
 *                      request object
 *  ppsaOutArgs [out]   Returns a SAFEARRAY of VARIANTs containing
 *                      the out parameter values, if any
 *  pvRetVal    [out]   Returns a VARIANT containing the action's
 *                      return value, if it has one
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  If the action does not have a return value, the VARIANT returned
 *  by pvRetVal will have type VT_EMPTY.
 *
 *  If the action does not have any out parameters, the SAFEARRAY
 *  returned by ppsaOutArgs will be empty.
 */

HRESULT
HrParseResponse(
    IN  ISOAPRequest   * psr,
    IN  SERVICE_ACTION * pAction,
    OUT SAFEARRAY      ** ppsaOutArgs,
    OUT VARIANT        * pvRetVal)
{
    HRESULT    hr = S_OK;
    SAFEARRAY  * psaOutArgs = NULL;
    long       cOutArgs;

    // Create a SAFEARRAY in which to store the out parameters.
    cOutArgs = pAction->lNumOutArguments;

    if (NULL != pAction->pReturnValue)
    {
        // One of the out parameters is the return value, so
        // since this is returned in its own VARIANT, there
        // will be one less element in the array of out
        // parameters.

        cOutArgs--;
    }

    hr = HrCreateVariantSafeArray(cOutArgs,
                                  &psaOutArgs);

    if (SUCCEEDED(hr))
    {
        VARIANT    vRetVal;
        IUnknown   * pUnkResponseElement = NULL;

        VariantInit(&vRetVal);

        // Get the response element and parse it.

        hr = psr->get_ResponseElement(&pUnkResponseElement);

        if (SUCCEEDED(hr))
        {
            IXMLDOMNode    * pxdnResponse = NULL;

            hr = pUnkResponseElement->QueryInterface(IID_IXMLDOMNode,
                                                     (void **) &pxdnResponse);

            if (SUCCEEDED(hr))
            {
                hr = HrExtractResponseValues(pxdnResponse,
                                             pAction,
                                             psaOutArgs,
                                             &vRetVal);

                pxdnResponse->Release();
            }
            else
            {
                TraceError("HrParseResponse(): "
                           "Failed to get response element",
                           hr);
            }


            pUnkResponseElement->Release();
        }
        else
        {
            TraceError("HrParseResponse(): "
                       "Failed to get response element",
                       hr);
        }

        // Return the out parameters and return value.

        if (SUCCEEDED(hr))
        {
            *ppsaOutArgs = psaOutArgs;
            hr = VariantCopy(pvRetVal,
                             &vRetVal);

            if (FAILED(hr))
            {
                TraceError("HrParseResponse(): "
                           "Failed to copy return value VARIANT",
                           hr);
            }
        }
        else
        {
            HRESULT hrTemp;

            hrTemp = SafeArrayDestroy(psaOutArgs);
            Assert(S_OK == hrTemp);
        }

        VariantClear(&vRetVal);
    }

    TraceError("HrParseResponse(): "
               "Exiting",
               hr);
    return hr;
}

/*
 * Function:    HrBuildAndSetArguments()
 *
 * Purpose:     Builds the argument nodes and adds them to the SOAP request.
 *
 * Arguments:
 *  psr             [in]    SOAP Request object
 *  pxddDummy       [in]    Dummy XML DOM Document object used to build
 *                          XML nodes
 *  pAction         [in]    The action table structure describing the
 *                          action to invoke
 *  psaArgValues    [in]    Array of values for the action's arguments
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrBuildAndSetArguments(
    IN  ISOAPRequest    * psr,
    IN  IXMLDOMDocument * pxddDummy,
    IN  SERVICE_ACTION  * pAction,
    IN  SAFEARRAY       * psaArgValues)
{
    HRESULT hr = S_OK;
    LONG    lUBound, lLBound, cArgs;

    do
    {
        hr = SafeArrayGetUBound(psaArgValues,
                                1,
                                &lUBound);
        TraceError("HrBuildAndSetArguments: SafeArrayGetUBound",
                   hr);

        if (FAILED(hr))
            break;

        hr = SafeArrayGetLBound(psaArgValues,
                                1,
                                &lLBound);
        TraceError("HrBuildAndSetArguments: SafeArrayGetLBound",
                   hr);

        if (FAILED(hr))
            break;

    } while (FALSE);

    if (SUCCEEDED(hr))
    {
        VARIANT HUGEP   * pVarArgs = NULL;

        cArgs = (lUBound - lLBound)+1;

        hr = SafeArrayAccessData(psaArgValues,
                                 (void HUGEP **)&pVarArgs);

        if (SUCCEEDED(hr) && pVarArgs)
        {
            for (LONG i = 0; i < cArgs; i++)
            {
                IXMLDOMElement *    pxdeArg;
                WCHAR *             pwszArgName;
                SST_DATA_TYPE       sdt;

                // Workaround VBScript behavior
                //
                if (pAction->lNumInArguments == i)
                {
                    if (pVarArgs[i].vt == VT_EMPTY)
                    {
                        continue;
                    }
                }

                Assert(pAction->pInArguments[i].pwszName);

                pxdeArg = NULL;
                pwszArgName = new WCHAR[lstrlenW(pAction->pInArguments[i].pwszName) + 1];

                if (NULL == pwszArgName)
                {
                    hr = E_OUTOFMEMORY;
                }

                if (SUCCEEDED(hr))
                {
                    lstrcpyW(pwszArgName, pAction->pInArguments[i].pwszName);

                    sdt = pAction->pInArguments[i].sdtType;
                    Assert(sdt < SDT_INVALID);

                    hr = HrCreateElementWithType(pxddDummy,
                                                 pwszArgName,
                                                 sdt,
                                                 pVarArgs[i],
                                                 &pxdeArg);
                }

                if (SUCCEEDED(hr) && pxdeArg)
                {
                    BSTR    bstrArgName = NULL;

                    bstrArgName = SysAllocString(pwszArgName);

                    if (bstrArgName)
                    {
                        hr = psr->SetParameter(bstrArgName,
                                               pxdeArg);

                        if (FAILED(hr))
                        {
                            TraceTag(ttidRehydrator,
                                     "HrBuildAndSetArguments(): "
                                     "Trying to set %S argument",
                                     pwszArgName);

                            TraceError("HrBuildAndSetArguments(): "
                                       "Failed to set parameter",
                                       hr);
                        }

                        SysFreeString(bstrArgName);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrBuildAndSetArguments(): "
                                   "Failed to allocate BSTR for arg name",
                                   hr);
                    }

                    pxdeArg->Release();
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                    }
                    TraceError("HrBuildAndSetArguments(): "
                               "Failed to create argument element", hr);
                }

                delete [] pwszArgName;
            }

            SafeArrayUnaccessData(psaArgValues);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrBuildAndSetArguments(): "
                       "Failed to access argument array data", hr);
        }

    }
    else
    {
        TraceError("HrBuildAndSetArguments(): "
                   "Failed to get array bounds", hr);
    }


    TraceError("HrBuildAndSetArguments(): "
               "Exiting",
               hr);

    return hr;
}

/*
 * Function:    HrOpenSOAPRequest()
 *
 * Purpose:     Initializes a SOAP Request object.
 *
 * Arguments:
 *  psr             [in]    SOAP Request object
 *  pAction         [in]    The action table structure describing the
 *                          action to invoke
 *  pcwszSTI        [in]    Service Type Identifier for the service
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrOpenSOAPRequest(
    IN  ISOAPRequest    * psr,
    IN  SERVICE_ACTION  * pAction,
    IN  LPCWSTR         pcwszSTI)
{
    HRESULT hr = S_OK;

    BSTR    bstrActionName = NULL;

    bstrActionName = SysAllocString(pAction->pwszName);

    if (bstrActionName)
    {
        BSTR    bstrSTI = NULL;

        bstrSTI = SysAllocString(pcwszSTI);

        if (bstrSTI)
        {
            hr = psr->Open(bstrActionName,
                           bstrSTI,
                           bstrSTI);

            SysFreeString(bstrSTI);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrOpenSOAPRequest(): "
                       "Failed to allocate BSTR for STI",
                       hr);
        }

        SysFreeString(bstrActionName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrOpenSOAPRequest(): "
                   "Failed to allocate BSTR for action name",
                   hr);
    }

    TraceError("HrOpenSOAPRequest(): "
               "Exiting",
               hr);

    return hr;
}



/*
 * Function:    HrRehydratorInvokeServiceAction()
 *
 * Purpose:     Invokes an action on a service instance
 *
 * Arguments:
 *  pAction         [in]    The action table structure describing the
 *                          action to invoke
 *  psaInArgs       [in]    Array of values for the action's in arguments
 *  pcwszSTI        [in]    Service Type Identifier for the service
 *  pcwszControlURL [in]    Control URL of the service instance
 *  ppsaOutArgs     [in]    SafeArray in which out parameter values will be
 *                          returned
 *  pvReturnVal     [in]    Returns the return value of the action
 *  plTransportStatus [out] Returns the status of the transport protocol
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrRehydratorInvokeServiceAction(
    IN  SERVICE_ACTION  * pAction,
    IN  SAFEARRAY       * psaInArgs,
    IN  LPCWSTR         pcwszSTI,
    IN  LPCWSTR         pcwszControlURL,
    IN  OUT SAFEARRAY   ** ppsaOutArgs,
    OUT VARIANT         * pvReturnVal,
    OUT LONG            * plTransportStatus)
{
    return HrRehydratorInvokeServiceActionEx(pAction,
                                            psaInArgs,
                                            pcwszSTI,
                                            pcwszControlURL,
                                            NULL,
                                            ppsaOutArgs,
                                            pvReturnVal,
                                            plTransportStatus);

}



/*
 * Function:    HrRehydratorInvokeServiceActionEx()
 *
 * Purpose:     Invokes an action on a service instance
 *
 * Arguments:
 *  pAction         [in]    The action table structure describing the
 *                          action to invoke
 *  psaInArgs       [in]    Array of values for the action's in arguments
 *  pcwszSTI        [in]    Service Type Identifier for the service
 *  pcwszControlURL [in]    Control URL of the service instance
 *  pControlConnect [in]    Info about a connection to be reused for control
 *  ppsaOutArgs     [in]    SafeArray in which out parameter values will be
 *                          returned
 *  pvReturnVal     [in]    Returns the return value of the action
 *  plTransportStatus [out] Returns the status of the transport protocol
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrRehydratorInvokeServiceActionEx(
    IN  SERVICE_ACTION  * pAction,
    IN  SAFEARRAY       * psaInArgs,
    IN  LPCWSTR         pcwszSTI,
    IN  LPCWSTR         pcwszControlURL,
    IN  DWORD_PTR       pControlConnect,
    IN  OUT SAFEARRAY   ** ppsaOutArgs,
    OUT VARIANT         * pvReturnVal,
    OUT LONG            * plTransportStatus)
{
    HRESULT hr = S_OK;

    *plTransportStatus = 0;

    // Create SOAP Request object.

    ISOAPRequest    * psr = NULL;

    hr = CoCreateInstance(CLSID_SOAPRequest,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISOAPRequest,
                          (void **) &psr);

    if (SUCCEEDED(hr) && psr)
    {
        // Create dummy document object to use for building XML nodes.

        IXMLDOMDocument * pxddDummy = NULL;

        hr = CoCreateInstance(CLSID_DOMDocument30,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IXMLDOMDocument,
                              (void **) &pxddDummy);

        if (SUCCEEDED(hr) && pxddDummy)
        {
            hr = HrOpenSOAPRequest(psr,
                                   pAction,
                                   pcwszSTI);

            if (SUCCEEDED(hr))
            {
                hr = HrBuildAndSetArguments(psr,
                                            pxddDummy,
                                            pAction,
                                            psaInArgs);

                if (SUCCEEDED(hr))
                {
                    BSTR    bstrControlURL = NULL;

                    bstrControlURL = SysAllocString(pcwszControlURL);

                    if (bstrControlURL)
                    {
                        hr = psr->Execute(bstrControlURL, pControlConnect);

                        HRESULT hrTemp = S_OK;
                        LONG    lHTTPStatus = 0;

                        hrTemp = psr->get_ResponseHTTPStatus(&lHTTPStatus);

                        if (SUCCEEDED(hrTemp))
                        {
                            SAFEARRAY * psaOutArgValues = NULL;
                            VARIANT   vRetVal;
                            LONG      lUPnPError;

                            *plTransportStatus = lHTTPStatus;

                            switch (hr)
                            {
                            case S_OK:
                                TraceTag(ttidRehydrator,
                                         "HrRehydratorInvokeServiceAction(): "
                                         "Execute() succeeded");

                                VariantInit(&vRetVal);

                                hr = HrParseResponse(psr,
                                                     pAction,
                                                     &psaOutArgValues,
                                                     &vRetVal);

                                if (SUCCEEDED(hr))
                                {
                                    if (ppsaOutArgs)
                                    {
                                        if (*ppsaOutArgs)
                                        {
                                           hr = SafeArrayDestroy(*ppsaOutArgs);

                                           Assert(S_OK == hr);
                                        }

                                        *ppsaOutArgs = psaOutArgValues;
                                    }
                                    else
                                    {
                                        // Not returning this, so clean it up.
                                        if (psaOutArgValues)
                                        {
                                            hr = SafeArrayDestroy(psaOutArgValues);
                                            Assert(S_OK == hr);
                                        }
                                    }

                                    if (pvReturnVal)
                                    {
                                        hr = VariantCopy(pvReturnVal,
                                                         &vRetVal);

                                        if (FAILED(hr))
                                        {
                                            TraceError("HrRehydratorInvokeServiceAction(): "
                                                       "Failed to copy variant return value",
                                                       hr);
                                        }
                                    }

                                    VariantClear(&vRetVal);
                                }
                                else
                                {
                                    hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                                    TraceError("HrRehydratorInvokeServiceAction(): "
                                               "Failed to parse response",
                                               hr);
                                }

                                break;
                            case SOAPREQ_E_TRANSPORTERROR:

                                hr = UPNP_E_TRANSPORT_ERROR;

                                break;
                            case SOAPREQ_E_TIMEOUT:
                                hr = UPNP_E_DEVICE_TIMEOUT;
                                break;

                            case SOAPREQ_E_METHODFAILED:

                                hr = HrExtractFaultInformation(psr,
                                                               &lUPnPError);

                                if (S_OK == hr)
                                {
                                    if ((lUPnPError >= FAULT_ACTION_SPECIFIC_BASE) &&
                                        (lUPnPError <= FAULT_ACTION_SPECIFIC_MAX))
                                    {
                                        hr = UPNP_E_ACTION_SPECIFIC_BASE +
                                            (lUPnPError - FAULT_ACTION_SPECIFIC_BASE);
                                    }
                                    else
                                    {
                                        switch (lUPnPError)
                                        {
                                            case FAULT_INVALID_ACTION:
                                                hr = UPNP_E_INVALID_ACTION;
                                                break;
                                            case FAULT_INVALID_ARG:
                                                hr = UPNP_E_INVALID_ARGUMENTS;
                                                break;
                                            case FAULT_INVALID_SEQUENCE_NUMBER:
                                                hr = UPNP_E_OUT_OF_SYNC;
                                                break;
                                            case FAULT_DEVICE_INTERNAL_ERROR:
                                                hr = UPNP_E_ACTION_REQUEST_FAILED;
                                                break;
                                            default:
                                                hr = UPNP_E_DEVICE_ERROR;
                                                break;
                                        };
                                    }
                                }
                                else if (S_FALSE == hr)
                                {
                                    // No <detail> element.

                                    hr = UPNP_E_PROTOCOL_ERROR;
                                }
                                else
                                {
                                    hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                                    TraceError("HrRehydratorInvokeServiceAction(): "
                                               "Failed to get response fault info",
                                               hr);
                                }
                                break;
                            case SOAPREQ_E_ERROR_PROCESSING_RESPONSE:
                                hr = UPNP_E_ERROR_PROCESSING_RESPONSE;

                                break;
                            default:

                                TraceError("HrRehydratorInvokeServiceAction(): "
                                           "Execute() failed",
                                           hr);

                            };
                        }
                        else
                        {
                            hr = hrTemp;
                            TraceError("HrRehydratorInvokeServiceAction(): "
                                       "Failed to get HTTP status",
                                       hr);
                        }


                        SysFreeString(bstrControlURL);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrRehydratorInvokeServiceAction(): "
                                   "Failed to allocate BSTR for control URL",
                                   hr);
                    }
                }
                else
                {
                    TraceError("HrRehydratorInvokeServiceAction(): "
                               "Failed to build and set arguments",
                               hr);
                }
            }
            else
            {
                TraceError("HrRehydratorInvokeServiceAction(): "
                           "Failed to open SOAP request",
                           hr);
            }

            pxddDummy->Release();
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrRehydratorInvokeServiceAction(): "
                       "Failed to create dummy document object",
                       hr);
        }

        psr->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("HrRehydratorInvokeServiceAction(): "
                   "Failed to create SOAP Request object",
                   hr);
    }



    TraceError("HrRehydratorInvokeServiceAction(): "
               "Exiting",
               hr);

    return hr;
}



/* Function:    HrCreateControlConnect
 * Purpose:     Create the Control Connect 
 *
 * Arguments:
 *  pszURL          [in]    URL string for connection
 *  pControlConnect [out]    returns a connection to be re-used for control
 *
 * Return Value:
 *  returns S_OK if released
 *  returns S_FALSE if ref count not zero
 *
*/
HRESULT 
HrCreateControlConnect(LPCWSTR pwszURL, DWORD_PTR * ppControlConnect)
{
    HRESULT hr;

    Assert(pwszURL);

    LPTSTR ptszURL = TszFromWsz(pwszURL);

    if (ptszURL)
    {
        hr = CreateControlConnect(ptszURL, (ControlConnect* *)ppControlConnect);
        MemFree(ptszURL);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



/* Function:    HrReleaseControlConnect
 * Purpose:     Release the Control Connect 
 *              if no longer being used, close the internet handle
 *
 * Arguments:
 *  pControlConnect [in]    Info about a connection to be re-used for control
 *
 * Return Value:
 * returns S_OK if released
 * returns S_FALSE if ref count not zero
 *
*/

HRESULT 
HrReleaseControlConnect(DWORD_PTR pConnect)
{
    return ReleaseControlConnect((ControlConnect*)pConnect);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\rehy\rehyqsv.cpp ===
/*
 * R E H Y Q S V . C P P
 *
 * Implementation of the RehydratorQueryStateVariable() API.
 *
 * Owner: Shyam Pather (SPather)
 *
 * Copyright 1986-2000 Microsoft Corporation, All Rights Reserved
 */

#include <pch.h>
#pragma hdrstop

#include "rehy.h"
#include "rehyutil.h"
#include "ncutil.h"



/*
 * Function:    HrExtractVariableValue()
 *
 * Purpose:     Extracts the the returned variable value from a SOAP response.
 *
 * Arguments:
 *  psr         [in]    The SOAP request object used to query the state variable --
 *                      the Execute() method should have returned S_OK
 *  vt          [in]    The data type of the variable
 *  pvarValue   [out]   Returns the variable value contained in the SOAP response
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrExtractVariableValue(
    IN      ISOAPRequest *              psr,
    IN OUT  SERVICE_STATE_TABLE_ROW *   pSSTRow)
{
    HRESULT     hr = S_OK;
    IUnknown    * pUnkResponse = NULL;

    hr = psr->get_ResponseElement(&pUnkResponse);

    if (SUCCEEDED(hr) && pUnkResponse)
    {
        IXMLDOMNode * pxdnResponse = NULL;

        hr = pUnkResponse->QueryInterface(IID_IXMLDOMNode,
                                          (void **) &pxdnResponse);

        if (SUCCEEDED(hr))
        {
            IXMLDOMNode    * pxdnChild = NULL;

            hr = pxdnResponse->get_firstChild(&pxdnChild);

            if (SUCCEEDED(hr) && pxdnChild)
            {
                if (FIsThisTheNodeName(pxdnChild, L"return"))
                {
                    hr = HrUpdateStateVariable(pSSTRow, pxdnChild);
                }
                else
                {
                    hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                    TraceError("HrExtractVariableValue(): "
                               "Response child element was not "
                               "<return>",
                               hr);
                }

                pxdnChild->Release();
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                    TraceError("HrExtractVariableValue(): "
                               "Response element was empty",
                               hr);
                }
                else
                {
                    TraceError("HrExtractVariableValue(): "
                               "Could not get child of response element",
                               hr);
                }
            }

            pxdnResponse->Release();
        }
        else
        {
            TraceError("HrExtractVariableValue(): "
                       "Could not get IXMLDOMNode interface on response "
                       "element",
                       hr);
        }

        pUnkResponse->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("HrExtractVariableValue(): "
                   "Could not get response element",
                   hr);
    }

    TraceError("HrExtractVariableValue(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrBuildAndSetVarName()
 *
 * Purpose:     Builds the varName node and adds it to the SOAP request.
 *
 * Arguments:
 *  psr             [in]    SOAP Request object
 *  pxddDummy       [in]    Dummy XML DOM Document object used to build
 *                          XML nodes
 *  pwszVarName     [in]    Value for the <varName> element
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrBuildAndSetVarName(
    IN  ISOAPRequest    * psr,
    IN  IXMLDOMDocument * pxddDummy,
    IN  LPCWSTR         pwszVarName)
{
    HRESULT         hr = S_OK;
    IXMLDOMElement  * pxdeVarName = NULL;

    WCHAR rgwszVarName[] = L"m:varName";

    hr = HrCreateElementWithTextValue(pxddDummy,
                                      rgwszVarName,
                                      pwszVarName,
                                      &pxdeVarName);

    if (SUCCEEDED(hr) && pxdeVarName)
    {
        BSTR    bstrVarNameName = NULL;

        bstrVarNameName = SysAllocString(L"varName");

        if (bstrVarNameName)
        {
            hr = psr->SetParameter(bstrVarNameName,
                                   pxdeVarName);

            if (FAILED(hr))
            {
                TraceError("HrBuildAndSetVarNameuments(): "
                           "Failed to set <varName> parameter",
                           hr);
            }

            SysFreeString(bstrVarNameName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrBuildAndSetVarNameuments(): "
                       "Failed to allocate BSTR for varName name",
                       hr);
        }

        pxdeVarName->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("HrBuildAndSetVarNameuments(): "
                   "Failed to create varName element", hr);
    }


    TraceError("HrBuildAndSetVarName(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrOpenQSVSOAPRequest()
 *
 * Purpose:     Initializes a SOAP Request object to do a QueryStateVariable.
 *
 * Arguments:
 *  psr             [in]    SOAP Request object
 *  pcwszSTI        [in]    Service Type Identifier for the service
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrOpenQSVSOAPRequest(
    IN  ISOAPRequest    * psr,
    IN  LPCWSTR         pcwszSTI)
{
    HRESULT hr = S_OK;

    BSTR    bstrMethodName = NULL;

    bstrMethodName = SysAllocString(L"QueryStateVariable");

    if (bstrMethodName)
    {
        BSTR    bstrSTI = NULL;

        bstrSTI = SysAllocString(pcwszSTI);

        if (bstrSTI)
        {
            hr = psr->Open(bstrMethodName,
                           bstrSTI,
                           bstrSTI);

            SysFreeString(bstrSTI);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrOpenQSVSOAPRequest(): "
                       "Failed to allocate BSTR for STI",
                       hr);
        }

        SysFreeString(bstrMethodName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        TraceError("HrOpenQSVSOAPRequest(): "
                   "Failed to allocate BSTR for method name",
                   hr);
    }

    TraceError("HrOpenQSVSOAPRequest(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrRehydratorQueryStateVariable()
 *
 * Purpose:     Sends a SOAP request to a device to query the value of a state
 *              variable.
 *
 * Arguments:
 *  psstr           [in, out]   The service state table row for the variable to
 *                              be queried -- on successful return, the value of
 *                              the variable is returned in the "value" field of
 *                              this structure
 *  pcwszSTI        [in]        The Service Type Identifier of the service to which
 *                              the variable belongs
 *  pcwszControlURL [in]        The URL to which the request will be sent
 *  plTransportStatus [out]     Returns the status of the transport protocol
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrRehydratorQueryStateVariable(
    IN  OUT SERVICE_STATE_TABLE_ROW * psstr,
    IN  LPCWSTR                     pcwszSTI,
    IN  LPCWSTR                     pcwszControlURL,
    OUT LONG                        * plTransportStatus)
{
    return HrRehydratorQueryStateVariableEx(psstr,
                                            pcwszSTI,
                                            pcwszControlURL,
                                            NULL,
                                            plTransportStatus);
}


/*
 * Function:    HrRehydratorQueryStateVariableEx()
 *
 * Purpose:     Sends a SOAP request to a device to query the value of a state
 *              variable.
 *
 * Arguments:
 *  psstr           [in, out]   The service state table row for the variable to
 *                              be queried -- on successful return, the value of
 *                              the variable is returned in the "value" field of
 *                              this structure
 *  pcwszSTI        [in]        The Service Type Identifier of the service to which
 *                              the variable belongs
 *  pcwszControlURL [in]        The URL to which the request will be sent
 *  pControlConnect [in]        Info about a connection to be reused for control
 *  plTransportStatus [out]     Returns the status of the transport protocol
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
HrRehydratorQueryStateVariableEx(
    IN  OUT SERVICE_STATE_TABLE_ROW * psstr,
    IN  LPCWSTR                     pcwszSTI,
    IN  LPCWSTR                     pcwszControlURL,
    IN  DWORD_PTR                   pControlConnect,
    OUT LONG                        * plTransportStatus)
{
    HRESULT hr = S_OK;

    * plTransportStatus = 0;

    // Create SOAP Request object.

    ISOAPRequest    * psr = NULL;

    hr = CoCreateInstance(CLSID_SOAPRequest,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_ISOAPRequest,
                          (void **) &psr);

    if (SUCCEEDED(hr) && psr)
    {
        // Create dummy document object to use for building XML nodes.

        IXMLDOMDocument * pxddDummy = NULL;

        hr = CoCreateInstance(CLSID_DOMDocument30,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IXMLDOMDocument,
                              (void **) &pxddDummy);

        if (SUCCEEDED(hr) && pxddDummy)
        {
            hr = HrOpenQSVSOAPRequest(psr,
                                      pcwszSTI);

            if (SUCCEEDED(hr))
            {
                hr = HrBuildAndSetVarName(psr,
                                          pxddDummy,
                                          psstr->pwszVarName);

                if (SUCCEEDED(hr))
                {
                    BSTR    bstrControlURL = NULL;

                    bstrControlURL = SysAllocString(pcwszControlURL);

                    if (bstrControlURL)
                    {
                        hr = psr->Execute(bstrControlURL, pControlConnect);

                        HRESULT hrTemp = S_OK;
                        LONG    lHTTPStatus = 0;

                        hrTemp = psr->get_ResponseHTTPStatus(&lHTTPStatus);

                        if (SUCCEEDED(hrTemp))
                        {
                            LONG    lUPnPError = 0;

                            *plTransportStatus = lHTTPStatus;

                            switch (hr)
                            {
                            case S_OK:
                                TraceTag(ttidRehydrator,
                                         "HrRehydratorQueryStateVariable(): "
                                         "Execute() succeeded");

                                hr = HrExtractVariableValue(psr,
                                                            psstr);
                                if (FAILED(hr))
                                {
                                    hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                                    TraceError("HrRehydratorInvokeServiceAction(): "
                                               "Failed to get response return value",
                                               hr);
                                }
                                break;

                            case SOAPREQ_E_TRANSPORTERROR:
                                TraceError("HrRehydratorQueryStateVariable(): "
                                           "Execute() failed (transport error)",
                                           hr);

                                hr = UPNP_E_TRANSPORT_ERROR;
                                break;

                            case SOAPREQ_E_METHODFAILED:
                                TraceError("HrRehydratorQueryStateVariable(): "
                                           "Execute() failed (method failure)",
                                           hr);

                                hr = HrExtractFaultInformation(psr,
                                                               &lUPnPError);

                                if (S_OK == hr)
                                {
                                    if ((lUPnPError >= FAULT_ACTION_SPECIFIC_BASE) &&
                                        (lUPnPError <= FAULT_ACTION_SPECIFIC_MAX))
                                    {
                                        hr = UPNP_E_ACTION_SPECIFIC_BASE +
                                            (lUPnPError - FAULT_ACTION_SPECIFIC_BASE);
                                    }
                                    else
                                    {
                                        switch (lUPnPError)
                                        {
                                        case FAULT_INVALID_VARIABLE:
                                            hr = UPNP_E_INVALID_VARIABLE;
                                            break;
                                        default:
                                            hr = UPNP_E_DEVICE_ERROR;
                                            break;
                                        };
                                    }
                                }
                                else if (S_FALSE == hr)
                                {
                                    // No <detail> element.

                                    hr = UPNP_E_PROTOCOL_ERROR;
                                }
                                else
                                {
                                    hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
                                    TraceError("HrRehydratorQueryStateVariable(): "
                                               "Failed to get response fault info",
                                               hr);
                                }
                                break;
                            case SOAPREQ_E_ERROR_PROCESSING_RESPONSE:

                                hr = UPNP_E_ERROR_PROCESSING_RESPONSE;

                                break;
                            case SOAPREQ_E_TIMEOUT:
                                hr = UPNP_E_DEVICE_TIMEOUT;

                                break;

                            default:
                                TraceError("HrRehydratorQueryStateVariable(): "
                                           "Execute() failed (unknown)",
                                           hr);
                                break;
                            }
                        }
                        else
                        {
                            hr = hrTemp;
                            TraceError("HrRehydratorQueryStateVariable(): "
                                       "Failed to get HTTP status",
                                       hr);

                        }

                        SysFreeString(bstrControlURL);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                        TraceError("HrRehydratorQueryStateVariable(): "
                                   "Failed to allocate BSTR for control URL",
                                   hr);
                    }
                }
                else
                {
                    TraceError("HrRehydratorQueryStateVariable(): "
                               "Failed to build and set variable name",
                               hr);
                }
            }
            else
            {
                TraceError("HrRehydratorQueryStateVariable(): "
                           "Failed to open SOAP request",
                           hr);
            }

            pxddDummy->Release();
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrRehydratorQueryStateVariable(): "
                       "Failed to create dummy document object",
                       hr);
        }

        psr->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("HrRehydratorQueryStateVariable(): "
                   "Failed to create SOAP Request object",
                   hr);
    }

    TraceError("HrRehydratorQueryStateVariable(): "
               "Exiting",
               hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\inc\upnpxmltags.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       upnpxmltags.h
//
//  Contents:   Declaration of string constants that appear as element
//              names in our xml documents.
//
//----------------------------------------------------------------------------


#ifndef __UPNPXMLTAGS_H_
#define __UPNPXMLTAGS_H_

#define DEFINE_XML_TAG(tagname) static CONST LPCWSTR tagname

struct XMLTags
{
    DEFINE_XML_TAG(pszElementRoot);
    DEFINE_XML_TAG(pszBaseUrl);
    DEFINE_XML_TAG(pszDevice);
    DEFINE_XML_TAG(pszUDN);
    DEFINE_XML_TAG(pszFriendlyName);
    DEFINE_XML_TAG(pszDeviceType);
    DEFINE_XML_TAG(pszPresentationURL);
    DEFINE_XML_TAG(pszManufacturer);
    DEFINE_XML_TAG(pszManufacturerURL);
    DEFINE_XML_TAG(pszModelName);
    DEFINE_XML_TAG(pszModelNumber);
    DEFINE_XML_TAG(pszModelDescription);
    DEFINE_XML_TAG(pszModelURL);
    DEFINE_XML_TAG(pszUPC);
    DEFINE_XML_TAG(pszSerialNumber);
    DEFINE_XML_TAG(pszService);
    DEFINE_XML_TAG(pszServiceType);
    DEFINE_XML_TAG(pszControlUrl);
    DEFINE_XML_TAG(pszEventSubUrl);
    DEFINE_XML_TAG(pszSCPDURL);
    DEFINE_XML_TAG(pszDeviceList);
    DEFINE_XML_TAG(pszServiceList);
    DEFINE_XML_TAG(pszServiceId);
    DEFINE_XML_TAG(pszIconList);
    DEFINE_XML_TAG(pszIcon);
    DEFINE_XML_TAG(pszMimetype);
    DEFINE_XML_TAG(pszWidth);
    DEFINE_XML_TAG(pszHeight);
    DEFINE_XML_TAG(pszDepth);
    DEFINE_XML_TAG(pszUrl);
};

#endif // __UPNPXMLTAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\rehy\rehyutil.cpp ===
/*
 * rehyutil.cpp
 *
 * Implementation of various utility functions used by the rehydrator.
 *
 * Owner: Shyam Pather (SPather)
 *
 * Copyright 1986-2000 Microsoft Corporation, All Rights Reserved
 */

#include <pch.h>
#pragma hdrstop

#include "ncutil.h"
#include "rehyutil.h"


/*
 * Function:    HrCreateElementWithType()
 *
 * Purpose:     Creates an XML element containing a binary value that is
 *              encoded in bin.base64.
 *
 * Arguments:
 *  pDoc                [in]    Document in which to create the element
 *  pcwszElementName    [in]    Name for the new element
 *  sdtType             [in]    The type of the data encoded in the element.
 *                              The type must be one of the xml-data types
 *                              listed in SST_DATA_TYPE
 *  varData             [in]    Data to insert as the element's value
 *  ppElement           [out]   Address at which to place the pointer to the
 *                              new element object
 *
 * Returns:
 *  S_OK if successful, other HRESULT otherwise. 
 *
 * Notes:
 *  This function does not actually insert the new element into the document 
 *  tree.
 */

HRESULT
HrCreateElementWithType(
                        IN   IXMLDOMDocument *     pDoc, 
                        IN   LPCWSTR               pcwszElementName,
                        IN   CONST SST_DATA_TYPE   sdtType,
                        IN   VARIANT               varData,
                        OUT  IXMLDOMElement **     ppElement)
{
    Assert(pDoc);
    Assert(pcwszElementName);
    Assert(sdtType < SDT_INVALID);
    Assert(ppElement);

    HRESULT         hr;
    LPCWSTR pszDataType;

    pszDataType = GetStringFromType(sdtType);
    Assert(pszDataType);

    hr = HrCreateElementWithType(pDoc,
                                 pcwszElementName,
                                 pszDataType,
                                 varData,
                                 ppElement);

    return hr; 
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetTypedValueFromElement
//
//  Purpose:    Given an IXMLDOMNode that should be of type
//              dt:string, returns a new BSTR containing that
//              string.
//
//  Arguments:
//      pxdn        IXMLDOMNode to extract the string from.
//                  It is intended that this node be of type
//                  NODE_ELEMENT.
//
//      sdtType     The type of the data encoded in the element.
//                  The type must be one of the xml-data types listed
//                  in SST_DATA_TYPE
//
//      pvarOut     Address of a VARIANT that will obtain the
//                  data value.  This must be freed when
//                  no longer needed.
//
//  Returns:
//      S_OK if *pvarOut contains the data of the desired type
//
//  Notes:
//
HRESULT
HrGetTypedValueFromElement(IXMLDOMNode * pxdn,
                           CONST SST_DATA_TYPE sdtType,
                           VARIANT * pvarOut)
{
    Assert(pxdn);
    Assert(sdtType < SDT_INVALID);
    Assert(pvarOut);

    HRESULT hr;
    LPCWSTR pszDataType;

    hr = S_OK;
    pszDataType = GetStringFromType(sdtType);
    Assert(pszDataType);

    hr = HrGetTypedValueFromElement(pxdn,
                                    pszDataType,
                                    pvarOut);

    TraceError("HrGetTypedValueFromElement", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetTypedValueFromChildElement
//
//  Purpose:    Given an IXMLDOMElement, finds its child element
//              of the given name, and extracts the data contained
//              in that child element, decoding it from the specified
//              format.
//
//  Arguments:
//      pxdn          The element which should contain the specified
//                    children
//
//      arypszTokens  A serial list of child element names that uniquely
//                    describe the desired element.
//
//      cTokens       The number of element names contained in
//                    arypszTokens.
//
//      sdtType       The type of the data encoded in the element.
//                    The type must be one of the xml-data types listed
//                    in SST_DATA_TYPE
//
//      pvarOut       Address of a VARIANT that will obtain the
//                    data value.  This must be freed when
//                    no longer needed.
//
//  Returns:
//      S_OK if *pbstrOut has been set to a new BSTR
//      S_FALSE if the specified element did not exist.
//              in this case, *pbstrOut is set to NULL
//
//  Notes:
//      for example, if the document looked like this:
//        <foo><bar>text</bar></foo>
//      and pxdn referred to <foo>, arypszTokens = [ "bar" ]
//      cTokens = 1, and sdtType = SDT_STRING, this would
//      return "text".
//      See the definition of HrGetNestedChildElement() for
//      further explination.
//
HRESULT
HrGetTypedValueFromChildElement(IXMLDOMNode * pxdn,
                                CONST LPCWSTR * arypszTokens,
                                CONST ULONG cTokens,
                                CONST SST_DATA_TYPE sdtType,
                                VARIANT * pvarOut)
{
    Assert(pxdn);
    Assert(arypszTokens);
    Assert(cTokens);
    Assert(sdtType < SDT_INVALID);
    Assert(pvarOut);

    HRESULT hr;
    LPCWSTR pszDataType;

    hr = S_OK;
    pszDataType = GetStringFromType(sdtType);
    Assert(pszDataType);

    hr = HrGetTypedValueFromChildElement(pxdn,
                                         arypszTokens,
                                         cTokens,
                                         pszDataType,
                                         pvarOut);

    // hr is S_FALSE if bstrResult is NULL, or S_OK if
    // pvarOut has been retrieved

    TraceErrorOptional("HrGetTypedValueFromChildElement", hr, (S_FALSE == hr));
    return hr;
}


HRESULT
HrUpdateStateVariable(IN SERVICE_STATE_TABLE_ROW * pSSTRow,
                      IN IXMLDOMNode * pxdn)
{
    Assert(pSSTRow);
    Assert(pxdn);

    HRESULT hr;
    SST_DATA_TYPE sdtDesired;
    VARIANT       varNew;

    hr = S_OK;
    sdtDesired = pSSTRow->sdtType;
    Assert(sdtDesired < SDT_INVALID);

    ::VariantInit(&varNew);

    hr = HrGetTypedValueFromElement(pxdn,
                                    sdtDesired,
                                    &varNew);
    if (SUCCEEDED(hr))
    {
        Assert(V_VT(&varNew) != VT_EMPTY);
        Assert(V_VT(&varNew) != VT_ERROR);

        ClearSSTRowValue(&pSSTRow->value);

        hr = ::VariantCopy(&pSSTRow->value, &varNew);
        if (FAILED(hr))
        {
            ::VariantInit(&pSSTRow->value);

            TraceError("HrUpdateStateVariable(): "
                       "VariantCopy", hr);
        }

        // ignore VariantClear()'s return result
        ::VariantClear(&varNew);
    }
    else
    {
        TraceError("HrUpdateStateVariable(): "
                   "HrGetTypedValueFromElement", hr);
    }

    TraceError("HrUpdateStateVariable()", hr);
    return hr;
}


/*
 * Function:    ClearSSTRowValue()
 *
 * Purpose:     Clears and frees resources used by the value field in an
 *              SST row.
 *
 * Arguments:
 *  pvarVal     [in]    Pointer to the SST row whose value is to be cleared
 *
 * Return Value:
 *  (none)
 *
 * Notes:
 *  (none)
 */

VOID
ClearSSTRowValue(
    IN VARIANT  * pvarVal)
{
    VariantClear(pvarVal);
    VariantInit(pvarVal);
}


/*
 * Function:    HrProcessUPnPError()
 *
 * Purpose:     Processes a <UPnPError> XML element from a SOAP response
 * 
 * Arguments:
 *  pxdnUPnPError   [in]    The <UPnPError> XML DOM Node
 *  plStatus        [out]   Returns the status indicated in the error element
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise. 
 */
 
HRESULT
HrProcessUPnPError(
    IN  IXMLDOMNode * pxdnUPnPError,
    OUT LONG        * plStatus)
{
    HRESULT     hr = S_OK;
    IXMLDOMNode * pxdnChild = NULL;
    BOOL        bFoundErrorCode = FALSE;

    hr = pxdnUPnPError->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode * pxdnNextSibling = NULL;
        BSTR        bstrNodeName = NULL;

        hr = pxdnChild->get_baseName(&bstrNodeName);

        if (SUCCEEDED(hr) && bstrNodeName)
        {
            IXMLDOMNode * pxdnValue = NULL;

            hr = pxdnChild->get_firstChild(&pxdnValue);

            if (SUCCEEDED(hr) && pxdnValue)
            {
                VARIANT varValue;
                
                VariantInit(&varValue);

                hr = pxdnValue->get_nodeValue(&varValue);

                if (SUCCEEDED(hr))
                {
                    Assert(VT_BSTR == varValue.vt);

                    if (wcscmp(bstrNodeName, L"errorCode") == 0)
                    {
                        LONG lValue;

                        bFoundErrorCode = TRUE;

                        TraceTag(ttidRehydrator,
                                 "HrProcessUPnPError(): "
                                 "<errorCode> contained %S",
                                 V_BSTR(&varValue));

                        hr = HrConvertStringToLong(V_BSTR(&varValue),
                                                   &lValue);

                        if (SUCCEEDED(hr))
                        {
                            *plStatus = lValue;
                        }
                        else
                        {
                            TraceError("HrProcessUPnPError(): "
                                       "Failed to convert errorCode value "
                                       "to long",
                                       hr);
                        }

                        VariantClear(&varValue);
                    }
                    else if (wcscmp(bstrNodeName, L"errorDescription") == 0)
                    {
                        // Not doing anything with this now. 

                        VariantClear(&varValue);
                    }                    
                }
                else
                {
                    TraceError("HrProcessUPnPError(): "
                               "Failed to get child node "
                               "value",
                               hr);
                }

                pxdnValue->Release();
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                TraceError("HrProcessUPnPError(): "
                           "Failed to get child value "
                           "node",
                           hr);                
            }

            SysFreeString(bstrNodeName);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrProcessUPnPError(): "
                       "Failed to get child base name",
                       hr);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }
    
    if (SUCCEEDED(hr))
    {
        if (bFoundErrorCode)
        {
            hr = S_OK;
        }
        else
        {
            hr = UPNP_E_ERROR_PROCESSING_RESPONSE;
            TraceError("HrProcessUPnPError(): "
                       "Did not find <errorCode> element in <UPnPError>",
                       hr);
        }
    }

    TraceError("HrProcessUPnPError(): "
               "Exiting",
               hr);
    return hr;
}

/*
 * Function:    HrExtractFaultInformation()
 *
 * Purpose:     Extracts the fault information from a soap request that has 
 *              executed and return SOAPREQ_E_METHODFAILED. 
 * 
 * Arguments:
 *  psr         [in]    The SOAP Request object
 *  plStatus    [out]   Returns the fault status of the request. 
 *
 * Return Value:
 *  S_OK if successful, S_FALSE if the SOAP fault element
 *  did not contain a <detail> element, or other HRESULT otherwise. 
 */
 
HRESULT
HrExtractFaultInformation(
    IN  ISOAPRequest * psr,
    OUT LONG         * plStatus)
{
    HRESULT hr = S_OK;
    IUnknown * pUnkDetail = NULL;

    hr = psr->get_ResponseFaultDetail(&pUnkDetail);

    if (SUCCEEDED(hr) && pUnkDetail)
    {
        IXMLDOMNode * pxdnDetail = NULL;

        hr = pUnkDetail->QueryInterface(IID_IXMLDOMNode, 
                                        (void **) &pxdnDetail);

        if (SUCCEEDED(hr) && pxdnDetail)
        {
            IXMLDOMNode * pxdnUPnPError = NULL;

            hr = pxdnDetail->get_firstChild(&pxdnUPnPError);

            if (SUCCEEDED(hr) && pxdnUPnPError)
            {
                hr = HrProcessUPnPError(pxdnUPnPError, plStatus);

                pxdnUPnPError->Release();
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                TraceError("HrExtractFaultInformation(): "
                           "Failed to get first child of "
                           "detail element",
                           hr);
            }

            pxdnDetail->Release();
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("HrExtractFaultInformation(): "
                       "Failed to get XML DOM node interface "
                       "on detail element",
                       hr);
        }
        pUnkDetail->Release();
    }
    else
    {
        if (S_FALSE == hr)
        {
            TraceError("HrExtractFaultInformation(): "
                       "<detail> element was not present",
                       hr);           
        }
        else
        {
            TraceError("HrExtractFaultInformation(): "
                       "Failed to get the detail element "
                       "from the SOAP request",
                       hr);
        }
    }
    

    TraceError("HrExtractFaultInformation(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    HrCreateVariantSafeArray()
 *
 * Purpose:     Creates a 1-dimensional SAFEARRAY of VARIANTs.
 * 
 * Arguments:
 *  cElements   [in]    Number of elements the array must hold
 *  ppsaNew     [out]   Returns a pointer to the newly created
 *                      SAFEARRAY when this function returns
 *                      success.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
HrCreateVariantSafeArray(
    IN  unsigned long  cElements,
    OUT SAFEARRAY      ** ppsaNew)
{
    HRESULT        hr = S_OK;
    SAFEARRAY      * psa = NULL;
    SAFEARRAYBOUND sab;

    sab.cElements = cElements;
    sab.lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT,
                          1,
                          &sab);

    if (psa)
    {
        *ppsaNew = psa;
    }
    else
    {
        hr = E_FAIL;
        TraceError("HrCreateVariantSafeArray(): "
                   "SafeArrayCreate() returned NULL",
                   hr);
    }

    TraceError("HrCreateVariantSafeArray(): "
               "Exiting",
               hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\rehy\soapsink.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       soapsink.cpp
//
//  Contents:   implementation of CSOAPRequestNotifySink
//
//  Notes:      Implementation of IPropertyNotifySink that forwards
//              OnChanged events to the generic document object.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "ncutil.h"
#include "ncbase.h"
#include "nccom.h"
#include "UPnP.h"

#include "soapsink.h"
#include "xmldomdid.h"
#include "rehy.h"


#define UPNP_MAX_SOAPSIZE    (100 * 1024)



static HINTERNET   g_hInetSoap = NULL;
static int g_hInetSoapCnt = 0;

const TCHAR c_szHttpVersion[]    =  TEXT("HTTP/1.1");

static DWORD WINAPI ExecHttpRequestThread(LPVOID lpParam);

// architecture doc says this is 30 seconds
//
const DWORD c_cmsecSendTimeout = 30 * 1000;


VOID
InitInternetForSoap()
{
    if (NULL == g_hInetSoap)
    {
        g_hInetSoap = InternetOpen(TEXT("Mozilla/4.0 (compatible; UPnP/1.0; Windows 9x)"),
                               INTERNET_OPEN_TYPE_DIRECT,
                               NULL, NULL, 0);

        if (g_hInetSoap)
        {
            InternetSetOption( g_hInetSoap,
                                   INTERNET_OPTION_CONNECT_TIMEOUT,
                                   (LPVOID)&c_cmsecSendTimeout,
                                   sizeof(c_cmsecSendTimeout));
        }
        TraceTag(ttidUPnPDocument, "InitInternetForSoap: create Internet session");

    }
    if (g_hInetSoap)
        g_hInetSoapCnt++;

}

VOID
CleanupInternetForSoap()
{
    if (g_hInetSoapCnt > 0)
        g_hInetSoapCnt--;

    if (0 == g_hInetSoapCnt)
    {
        InternetCloseHandle(g_hInetSoap);
        g_hInetSoap = NULL;

        TraceTag(ttidUPnPDocument, "CleanupInternetForSoap: close Async Internet session");
    }

}



CSOAPRequestAsync::CSOAPRequestAsync()
{
    m_bInProgress = FALSE;
    m_bAlive = FALSE;
    m_pszTargetURI = NULL;
    m_pszRequest = NULL;
    m_pszHeaders = NULL;
    m_pszBody = NULL;
    m_pszResponse = NULL;
    m_lHTTPStatus = 0;
    m_pszHTTPStatusText = NULL;
    m_hThread = NULL;
    m_pControlConnect = NULL;
    m_hEvent = NULL;

    InitInternetForSoap();
}


CSOAPRequestAsync::~CSOAPRequestAsync()
{
    if (m_pszTargetURI)
        MemFree(m_pszTargetURI);

    if (m_pszRequest)
        MemFree(m_pszRequest);

    if (m_pszHeaders)
        MemFree(m_pszHeaders);

    if (m_pszBody)
        MemFree(m_pszBody);

    if (m_pszResponse)
        MemFree(m_pszResponse);

    if (m_pszHTTPStatusText)
        MemFree(m_pszHTTPStatusText);

    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_hEvent)
        CloseHandle(m_hEvent);

    CleanupInternetForSoap();

}


// caller must call deInit even if Init returns FALSE
BOOL
CSOAPRequestAsync::Init(IN HANDLE* phEvent,
                        IN  BSTR  bstrTargetURI,
                        IN  BSTR  bstrRequest,
                        IN  BSTR  bstrHeaders,
                        IN  BSTR  bstrBody,
                        IN  DWORD_PTR pControlConnect)
{
    DWORD dwThread;

    if (!g_hInetSoap)
    {
        TraceTag(ttidSOAPRequest, "OBJ: CSOAPRequestAsync::Init, Inet handle not open");
        return FALSE;
    }

    m_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    m_pszTargetURI = TszFromWsz((LPCWSTR)bstrTargetURI);
    m_pszRequest = TszFromWsz((LPCWSTR)bstrRequest);
    m_pszHeaders = TszFromWsz((LPCWSTR)bstrHeaders);
    m_pszBody = Utf8FromWsz((LPCWSTR)bstrBody);
    m_pControlConnect = (ControlConnect*) pControlConnect;

    // OK if m_pControlConnect NULL
    if (m_hEvent && m_pszTargetURI && m_pszRequest && m_pszHeaders && m_pszBody)
    {
        m_bAlive = TRUE;
        // mark as in use by the thread
        m_bInProgress = TRUE;

        m_hThread = CreateThread(NULL, 0, 
                                ExecHttpRequestThread,
                                (LPVOID)this,
                                0, &dwThread);
        if (NULL == m_hThread)
        {
            m_bAlive = FALSE;
            m_bInProgress = FALSE;
        }
    }

    *phEvent = m_hEvent;

    return m_bAlive;
}

// thread routine, calls back to CSOAPRequestAsync
DWORD WINAPI ExecHttpRequestThread(LPVOID lpParam)
{
    CSOAPRequestAsync* pSOAPRequestAsync = (CSOAPRequestAsync*)lpParam;

    pSOAPRequestAsync->ExecuteRequest();

    return 0;
}

//
// Before calling destructor both m_bAlive and m_bInProgress must be FALSE
// DeInit sets m_bAlive to FALSE
// the execute thread will set m_bInProgress to FALSE when it completes
VOID
CSOAPRequestAsync::DeInit()
{
    DWORD dwResult;

    // indicate quick exit
    m_bAlive = FALSE;

    HrMyWaitForMultipleHandles(0,
                                INFINITE,
                                1,
                                &m_hThread,
                                &dwResult);
    delete this;
}


BOOL
CSOAPRequestAsync::GetResults(long * plHTTPStatus,
                              BSTR * pszHTTPStatusText,
                              BSTR * pszResponse)
{
    *pszHTTPStatusText = NULL;
    *pszResponse = NULL;

    if (!m_bInProgress)
    {
        LPWSTR szHTTPStatusText = NULL;
        LPWSTR szResponse = NULL;

        if (m_pszHTTPStatusText)
            szHTTPStatusText = WszFromTsz(m_pszHTTPStatusText);

        if (m_pszResponse)
            szResponse = WszFromUtf8(m_pszResponse);

        *plHTTPStatus = m_lHTTPStatus;

        if (szHTTPStatusText)
        {
            *pszHTTPStatusText = SysAllocString(szHTTPStatusText);
            MemFree(szHTTPStatusText);
        }

        if (szResponse)
        {
            *pszResponse = SysAllocString(szResponse);
            MemFree(szResponse);
        }

        return TRUE;
    }

    return FALSE;
}



/*
 * Function:    CSOAPRequestAsync::ExecuteRequest()
 *
 * Purpose:
 *
 * Arguments:
 *
 * Return Value:
 *
 * Notes:
 *  (none)
 */

VOID
CSOAPRequestAsync::ExecuteRequest()
{
    DWORD dwResult;
    URL_COMPONENTS  urlComp = {0};
    TCHAR           szUrlPath[INTERNET_MAX_URL_LENGTH];
    HRESULT         hr = S_OK;
    DWORD           dwSize = 0;
    DWORD           dwTotalSize = 0;
    LPSTR           pDoc = NULL;
    HINTERNET       hOpenUrl = NULL;
    HINTERNET       hConnect = NULL;
    BOOL            bCreateConnect = FALSE;
    ControlConnect* pControlConnect = NULL;

    if (m_bAlive)
    {
        if (!m_pControlConnect)
        {
            // in case not passed in, create a temporary one
            hr = CreateControlConnect(m_pszTargetURI, &m_pControlConnect);
            if (SUCCEEDED(hr))
            {
                bCreateConnect = TRUE;
            }
        }

        if (m_pControlConnect)
        {
            pControlConnect = m_pControlConnect;
            hConnect = GetInternetConnect(pControlConnect);
            if (!hConnect)
            {
                hr = HrFromLastWin32Error();
            }
            // if created it here, release one more time
            if (bCreateConnect)
            {
                ReleaseControlConnect(pControlConnect);
            }

        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (m_bAlive && SUCCEEDED(hr))
    {
        urlComp.dwStructSize = sizeof(URL_COMPONENTS);

        urlComp.lpszHostName = NULL;
        urlComp.dwHostNameLength = 0;

        urlComp.lpszUrlPath = szUrlPath;
        urlComp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

        if (InternetCrackUrl(m_pszTargetURI, 0, 0, &urlComp))
        {
            hOpenUrl = HttpOpenRequest(hConnect,
                                        m_pszRequest,
                                        szUrlPath,
                                        c_szHttpVersion,
                                        NULL, NULL,
                                        INTERNET_FLAG_KEEP_CONNECTION,
                                        0);
        }
        if (!hOpenUrl)
        {
            hr = HrFromLastWin32Error();
        }
    }

    if (m_bAlive && SUCCEEDED(hr))
    {
        if (!HttpSendRequest(hOpenUrl, 
                                m_pszHeaders,
                                _tcslen(m_pszHeaders),
                                m_pszBody,
                                strlen(m_pszBody)) )
        {
            hr = HrFromLastWin32Error();
        }
    }

    if (m_bAlive && SUCCEEDED(hr))
    {
        // get the HTTP status
        dwSize = sizeof(m_lHTTPStatus);
        if (!HttpQueryInfo(hOpenUrl, 
                            HTTP_QUERY_STATUS_CODE + HTTP_QUERY_FLAG_NUMBER, 
                            &m_lHTTPStatus, 
                            &dwSize, NULL) )
        {
            hr = HrFromLastWin32Error();
        }

        if (SUCCEEDED(hr))
        {
            TCHAR buf[1];

            // try to get actual size
            dwSize = 1;
            HttpQueryInfo(hOpenUrl, 
                                HTTP_QUERY_STATUS_TEXT, 
                                &buf[0], &dwSize, NULL);

            dwSize += sizeof(TCHAR);           // room for NULL

            if (m_pszHTTPStatusText)
                MemFree(m_pszHTTPStatusText);

            m_pszHTTPStatusText = (LPTSTR)MemAlloc(dwSize);
            if (m_pszHTTPStatusText)
            {
                if (!HttpQueryInfo(hOpenUrl, 
                                    HTTP_QUERY_STATUS_TEXT, 
                                    m_pszHTTPStatusText, 
                                    &dwSize, NULL) )
                {
                    hr = HrFromLastWin32Error();
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        // loop to read the data
        while (m_bAlive && SUCCEEDED(hr))
        {
    	    if (InternetQueryDataAvailable(hOpenUrl, &dwSize, 0, 0))
            {
                if (dwSize == 0)
                {
                    // end of doc
                    break;
                }
                if (dwTotalSize + dwSize > UPNP_MAX_SOAPSIZE)
                {
                    // download too long. Reject
                    MemFree(pDoc);
                    pDoc = NULL;
                    hr = E_OUTOFMEMORY;
                    break;
                }
                // realloc
                void* ReadBuf = MemAlloc(dwTotalSize + dwSize + 2);
                if (ReadBuf)
                {
                    DWORD dwReadSize = 0;

                    if (pDoc)
                    {
                        CopyMemory(ReadBuf, pDoc, dwTotalSize);
                        MemFree(pDoc);
                    }
                    pDoc = (LPSTR)ReadBuf;
                    ReadBuf = (BYTE*)ReadBuf + dwTotalSize;

                    if (!InternetReadFile(hOpenUrl, ReadBuf, 
                                            dwSize, &dwReadSize))
                    {
                        MemFree(pDoc);
                        pDoc = NULL;
                        hr = HrFromLastWin32Error();
                        break;
                    }
                    dwTotalSize += dwReadSize;
                    pDoc[dwTotalSize] = 0;

                    if (dwReadSize == 0)
                        break;
                }
                else
                {
                    MemFree(pDoc);
                    pDoc = NULL;
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            else
            {
                MemFree(pDoc);
                pDoc = NULL;
                hr = HrFromLastWin32Error();
                break;
            }
        }
    }


    InternetCloseHandle(hOpenUrl);

    if (pControlConnect)
    {
        ReleaseControlConnect(pControlConnect);

        m_pControlConnect = NULL;
    }

    // put data pointer in struct
    m_pszResponse = pDoc;
    m_bInProgress = FALSE;

    SetEvent(m_hEvent);

    TraceError("CSOAPRequestAsync::ExecuteRequest", hr);

}




/* Function:    CreateControlConnect
 * Purpose:     Create the Control Connect 
 *
 * Arguments:
 *  pszURL          [in]    URL string for connection
 *  pControlConnect [out]    returns a connection to be re-used for control
 *
 * Return Value:
 *  returns S_OK if released
 *  returns S_FALSE if ref count not zero
 *
*/
HRESULT 
CreateControlConnect(LPCTSTR pszURL, ControlConnect* * ppControlConnect)
{
    HRESULT hr = S_OK;
    URL_COMPONENTS  urlComp = {0};

    *ppControlConnect = NULL;

    ControlConnect* pConnection = (ControlConnect*) MemAlloc(sizeof(ControlConnect));

    if (pConnection)
    {
        pConnection->hConnect = NULL;
        pConnection->nRefCnt = 0;
        pConnection->pszHost = NULL;
        pConnection->nPort = 0;

        urlComp.dwStructSize = sizeof(URL_COMPONENTS);

        urlComp.lpszHostName = NULL;
        urlComp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

        urlComp.lpszUrlPath = NULL;
        urlComp.dwUrlPathLength = 0;

        if (InternetCrackUrl(pszURL, 0, 0, &urlComp))
        {
            pConnection->pszHost = (LPTSTR)MemAlloc(sizeof(TCHAR) * 
                                                    (urlComp.dwHostNameLength + 1));
            if (pConnection->pszHost)
            {
                _tcsncpy(pConnection->pszHost, urlComp.lpszHostName, 
                            urlComp.dwHostNameLength);
                pConnection->pszHost[urlComp.dwHostNameLength] = 0;

                pConnection->nPort = urlComp.nPort;
                pConnection->nRefCnt++;
                InitializeCriticalSection(&pConnection->cs);

                InitInternetForSoap();
            }
            else
            {
                MemFree(pConnection);
                pConnection = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            MemFree(pConnection);
            pConnection = NULL;
            hr = HrFromLastWin32Error();
        }

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    *ppControlConnect = pConnection;

    TraceError("CreateControlConnect", hr);
    return hr;
}


HINTERNET
GetInternetConnect(ControlConnect* pConnection)
{
    Assert(pConnection);

    EnterCriticalSection(&pConnection->cs);

    pConnection->nRefCnt++;

    if (NULL == pConnection->hConnect)
    {
        pConnection->hConnect = InternetConnect(g_hInetSoap,
                                                pConnection->pszHost,
                                                pConnection->nPort,
                                                NULL, NULL,
                                                INTERNET_SERVICE_HTTP,
                                                0, 0);

        if (NULL == pConnection->hConnect)
        {
            TraceError("GetInternetConnect", HrFromLastWin32Error());
        }
    }

    LeaveCriticalSection(&pConnection->cs);

    return pConnection->hConnect;
}


/* Function:    ReleaseControlConnect
 * Purpose:     Release the Control Connect 
 *              if no longer being used, close the internet handle
 *
 * Arguments:
 *  pControlConnect [in]    Info about a connection to be re-used for control
 *
 * Return Value:
 * returns S_OK if released
 * returns S_FALSE if ref count not zero
 *
*/

HRESULT 
ReleaseControlConnect(ControlConnect* pConnection)
{
    HRESULT hr = S_OK;

    if (pConnection)
    {
        EnterCriticalSection(&pConnection->cs);

        pConnection->nRefCnt--;

        if (0 == pConnection->nRefCnt)
        {
            if (pConnection->hConnect)
            {
                InternetCloseHandle(pConnection->hConnect);
                pConnection->hConnect = NULL;
            }
            if (pConnection->pszHost)
            {
                MemFree(pConnection->pszHost);
                pConnection->pszHost = NULL;
            }

            CleanupInternetForSoap();

            LeaveCriticalSection(&pConnection->cs);

            DeleteCriticalSection(&pConnection->cs);

            MemFree(pConnection);
        }
        else
        {
            hr = S_FALSE;

            LeaveCriticalSection(&pConnection->cs);
        }

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\downloadctest.cpp ===
// downloadctest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "downloadctest.h"
#include "downloadctestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestApp

BEGIN_MESSAGE_MAP(CDownloadctestApp, CWinApp)
	//{{AFX_MSG_MAP(CDownloadctestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestApp construction

CDownloadctestApp::CDownloadctestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDownloadctestApp object

CDownloadctestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestApp initialization

BOOL CDownloadctestApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CDownloadctestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\rehy\soapreq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S O A P R E Q . C P P
//
//  Contents:   Implementation of SOAP Request Class.
//
//  Notes:
//
//  Author:     SPather     January 16, 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "ncutil.h"
#include "nccom.h"
#include "ncbase.h"
#include "rehy.h"   // Needed for MAX_STRING_LENGTH
#include "soapreq.h"
#include "soapsink.h"

#define INITGUID
#include "guiddef.h"
DEFINE_GUID(CLSID_SOAPRequest, 0xaf2ac6ee, 0x2b16, 0x4756, 0x94, 0x75, 0xf3,
            0x19, 0xe5, 0x43, 0xef, 0xaa);

// architecture doc says this is 30 seconds
//
const DWORD c_csecSendTimeout = 30;


#define USE_POST        1
#define USE_MPOST       2

LPCWSTR c_szContentType = L"Content-Type: text/xml; charset=\"utf-8\"\r\n";
LPCWSTR c_szSoapAction = L"SOAPAction: ";
LPCWSTR c_szMPostMan =  L"Man: \"http://schemas.xmlsoap.org/soap/envelope/\"; ns=01\r\n";
LPCWSTR c_szMPostSoapAction = L"01-SOAPAction: ";


/*
 * Function:    bIsValidNonEmptyStringPtr()
 *
 * Purpose:     Determines whether a string pointer is valid
 *              and points to a non-empty string.
 *
 * Arguments:
 *  bstrString  [in]    The string to validate
 *  ucchMaxLen  [in]    The maximum length of the string
 *  phrRetVal   [out]   The HRESULT corresponding to the
 *                      problem with the string
 *
 * Return value:
 *  [Case]              [Return Value]  [Value set at phrRetVal]
 *  String pointer is
 *  valid, string is    TRUE            S_OK
 *  not empty
 *
 *  String pointer is
 *  not valid           FALSE           E_POINTER
 *
 *  String is empty     FALSE           E_INVALIDARG
 *
 * Notes:
 *  (none)
 */

BOOL
bIsValidNonEmptyStringPtr(
    IN  BSTR        bstrString,
    IN  UINT_PTR    ucchMaxLen,
    OUT HRESULT     * phrRetVal)
{
    BOOL    bRetVal = TRUE;
    HRESULT hr = S_OK;

    if (IsBadStringPtrW(bstrString, ucchMaxLen))
    {
        // Pointer was NULL or invalid.

        hr = E_POINTER;
    }
    else if (0 == SysStringLen(bstrString))
    {
        // String was empty.

        hr = E_INVALIDARG;
    }

    if (phrRetVal)
    {
        *phrRetVal = hr;
    }

    if (FAILED(hr))
    {
        bRetVal = FALSE;
    }

    return bRetVal;
}


// Constructor / Destructor

CSOAPRequest::CSOAPRequest()
{
    m_pxdd = NULL;
    m_pxdnEnvelope = NULL;

    m_bstrMethodName = NULL;
    m_bstrInterfaceName = NULL;

    m_lHTTPStatus = 0;
    m_bstrHTTPStatusText = NULL;

    m_bstrResponseBody = NULL;

    m_pxdnResponseHeaders = NULL;

    m_bstrFaultCode = NULL;
    m_bstrFaultString = NULL;

    m_pxdnFaultDetail = NULL;

    m_pxdnResponseElement = NULL;

}


CSOAPRequest::~CSOAPRequest()
{
    Cleanup();
}


/*
 * Function:    CSOAPRequest::Cleanup())
 *
 * Purpose:     Clean up any resources used by a SOAP Request object.
 *
 * Arguments:
 *  (none)
 *
 * Return Value:
 *  (none)
 *
 * Notes:
 *  (none)
 */

VOID
CSOAPRequest::Cleanup()
{
    if (m_pxdnEnvelope)
    {
        m_pxdnEnvelope->Release();
        m_pxdnEnvelope = NULL;
    }

    if (m_pxdd)
    {
        m_pxdd->Release();
        m_pxdd = NULL;
    }

    if (m_bstrMethodName)
    {
        SysFreeString(m_bstrMethodName);
        m_bstrMethodName = NULL;
    }

    if (m_bstrInterfaceName)
    {
        SysFreeString(m_bstrInterfaceName);
        m_bstrInterfaceName = NULL;
    }

    CleanupFeedbackData();
}


/*
 * Function:    CSOAPRequest::CleanupFeedbackData()
 *
 * Purpose:     Frees all resources used by feedback data (return values,
 *              HTTP Status codes etc).
 *
 * Arguments:
 *  (none)
 *
 * Return Value:
 *  (none)
 *
 * Notes:
 *  (none)
 */

VOID
CSOAPRequest::CleanupFeedbackData()
{
    m_lHTTPStatus = 0;

    if (m_bstrHTTPStatusText)
    {
        SysFreeString(m_bstrHTTPStatusText);
        m_bstrHTTPStatusText = NULL;
    }

    if (m_bstrResponseBody)
    {
        SysFreeString(m_bstrResponseBody);
        m_bstrResponseBody = NULL;
    }

    if (m_pxdnResponseHeaders)
    {
        m_pxdnResponseHeaders->Release();
        m_pxdnResponseHeaders = NULL;
    }

    if (m_bstrFaultCode)
    {
        SysFreeString(m_bstrFaultCode);
        m_bstrFaultCode = NULL;
    }

    if (m_bstrFaultString)
    {
        SysFreeString(m_bstrFaultString);
        m_bstrFaultString = NULL;
    }

    if (m_pxdnFaultDetail)
    {
        m_pxdnFaultDetail->Release();
        m_pxdnFaultDetail = NULL;
    }

    if (m_pxdnResponseElement)
    {
        m_pxdnResponseElement->Release();
        m_pxdnResponseElement = NULL;
    }
}


/*
 * Function:    CSOAPRequest::HrCreateDocumentObject())
 *
 * Purpose:     Creates the main document object for the SOAP request
 *              class, if one does not already exist.
 *
 * Arguments:
 *  (none)
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrCreateDocumentObject()
{
    HRESULT hr = S_OK;

    // Create a document object.

    hr = CoCreateInstance(CLSID_DOMDocument30,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IXMLDOMDocument,
                          (void **) &m_pxdd);
    if (SUCCEEDED(hr))
    {
        IXMLDOMProcessingInstruction* pxdpi = NULL;
        BSTR bstrTarget = SysAllocString(L"xml");
        BSTR bstrData = SysAllocString(L"version=\"1.0\"");
        if (bstrTarget && bstrData)
        {
            hr = m_pxdd->createProcessingInstruction(bstrTarget, bstrData, &pxdpi);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        SysFreeString(bstrTarget);
        SysFreeString(bstrData);

        if (SUCCEEDED(hr))
        {
            IXMLDOMNode* pxdn = NULL;
            hr = pxdpi->QueryInterface(IID_IXMLDOMNode, (void**)&pxdn);
            if (SUCCEEDED(hr))
            {
                hr = m_pxdd->appendChild(pxdn, NULL);
                pxdn->Release();
            }
        }

        if (pxdpi)
        {
            pxdpi->Release();
        }
    }

    TraceError("CSOAPRequest::HrCreateDocumentObject(): "
               "Exiting",
               hr);
    return hr;
}


/*
 * Function:    CSOAPRequest::HrCreateElement()
 *
 * Purpose:     Create an XML Element DOM object
 *
 * Arguments:
 *  pcwszElementName    [in]    Name of the element to be created
 *  pcwszNamespaceURI   [in]    URI identifying the namespace to which
 *                              the element name belongs
 *  ppxdnNewElt         [out]   The newly created element object
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrCreateElement(
    IN  LPCWSTR     pcwszElementName,
    IN  LPCWSTR     pcwszNamespaceURI,
    OUT IXMLDOMNode **ppxdnNewElt)
{
    HRESULT hr = S_OK;

    *ppxdnNewElt = NULL;

    if (NULL == m_pxdd)
    {
        hr = HrCreateDocumentObject();
    }

    if (SUCCEEDED(hr))
    {
        BSTR    bstrElementName = NULL;
        BSTR    bstrNamespaceURI = NULL;

        Assert(m_pxdd);

        // Allocate BSTRs

        bstrElementName = SysAllocString(pcwszElementName);

        if (bstrElementName)
        {
            if (pcwszNamespaceURI)
            {
                bstrNamespaceURI = SysAllocString(pcwszNamespaceURI);

                if (NULL == bstrNamespaceURI)
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CSOAPRequest::HrCreateElement(): "
                               "Failed to allocate memory for name string",
                               hr);
                }
            }

            if (SUCCEEDED(hr))
            {
                VARIANT varNodeType;

                VariantInit(&varNodeType);
                varNodeType.vt = VT_I4;
                V_I4(&varNodeType) = (int) NODE_ELEMENT;

                hr = m_pxdd->createNode(varNodeType,
                                        bstrElementName,
                                        bstrNamespaceURI,
                                        ppxdnNewElt);

                if (FAILED(hr))
                {
                    TraceError("CSOAPRequest::HrCreateElement(): "
                               "Failed to create element node",
                               hr);
                }


                if (bstrNamespaceURI)
                {
                    SysFreeString(bstrNamespaceURI);
                }
            }


            SysFreeString(bstrElementName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CSOAPRequest::HrCreateElement(): "
                       "Failed to allocate memory for name string",
                       hr);
        }

    }
    else
    {
        TraceError("CSOAPRequest::HrCreateElement(): "
                   "Failed to create document object",
                   hr);
    }

    TraceError("CSOAPRequest::HrCreateElement(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    CSOAPRequest::HrGetSOAPEnvelopeChild()
 *
 * Purpose:     Finds and returns a node representing a child of the
 *              Envelope element.
 *
 * Arguments:
 *  pcwszChildName  [in]    Name of the child element to look for
 *  ppxdnChildNode  [out]   Returns node representing the child element
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrGetSOAPEnvelopeChild(
    IN   LPCWSTR     pcwszChildName,
    OUT  IXMLDOMNode ** ppxdnChildNode)
{
    HRESULT     hr = S_OK;
    IXMLDOMNode * pxdnDesiredNode = NULL;
    IXMLDOMNode * pChild = NULL;

    // Starting from the envelope element, walk down the tree
    // to find the desired element.

    hr = m_pxdnEnvelope->get_firstChild(&pChild);

    if (SUCCEEDED(hr) && pChild)
    {
        while (pChild)
        {
            if (fIsSOAPElement(pChild, pcwszChildName))
            {
                pChild->AddRef();
                pxdnDesiredNode = pChild;
                break;
            }
            else
            {
                IXMLDOMNode * pNext = NULL;

                hr = pChild->get_nextSibling(&pNext);

                if (SUCCEEDED(hr))
                {
                    pChild->Release();
                    pChild = pNext;
                }
                else
                {
                    TraceError("CSOAPRequest::HrGetSOAPEnvelopeChild(): "
                               "Could not get next sibling",
                               hr);
                    break;
                }
            }
        };

        if (pChild)
        {
            pChild->Release();
        }
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }

        TraceError("CSOAPRequest::HrGetSOAPEnvelopeChild(): "
                   "Could not get first child of Envelope element",
                   hr);
    }

    *ppxdnChildNode = pxdnDesiredNode;

    TraceError("CSOAPRequest::HrGetSOAPEnvelopeChild(): "
               "Exiting",
               hr);

    return hr;

}


/*
 * Function:    CSOAPRequest::HrGetBodyNode()
 *
 * Purpose:     Returns the Body element of the request
 *
 * Arguments:
 *  ppxdnBody   [out]   The body node
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrGetBodyNode(
    OUT   IXMLDOMNode     ** ppxdnBody)
{
    return HrGetSOAPEnvelopeChild(L"Body",
                                  ppxdnBody);
}


/*
 * Function:    CSOAPRequest::HrGetHeaderNode()
 *
 * Purpose:     Returns the Header element of the request
 *
 * Arguments:
 *  ppxdnHeader   [out]   The Header node
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrGetHeaderNode(
    OUT   IXMLDOMNode     ** ppxdnHeader)
{
    return HrGetSOAPEnvelopeChild(L"Header",
                                  ppxdnHeader);
}


/*
 * Function:    CSOAPRequest::HrCreateBody()
 *
 * Purpose:     Creates a SOAP Body element, including the method element
 *              within it.
 * Arguments:
 *  bstrMethodName      [in]    The method name
 *  bstrMethodNameSpace [in]    The namespace URI for the namespace to which
 *                              the method name belongs
 *  ppxdnBody           [out]   The resulting Node object representing the Body
 *                              element
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrCreateBody(
    IN     BSTR            bstrMethodName,
    IN     BSTR            bstrMethodNameSpace,
    OUT    IXMLDOMNode     ** ppxdnBody)
{
    HRESULT     hr = S_OK;
    IXMLDOMNode * pxdnBody = NULL;

    *ppxdnBody = NULL;

    // Create the body element.

    hr = HrCreateElement(L"SOAP-ENV:Body",
                         WSZ_SOAP_NAMESPACE_URI,
                         &pxdnBody);

    if (SUCCEEDED(hr) && pxdnBody)
    {
        IXMLDOMNode * pxdnMethod = NULL;
        UINT        uiMethodNameLength;
        UINT        uiQualifiedNameLength;
        BSTR        bstrQualifiedMethodName;

        CONST       WCHAR rgszFmt [] = L"%ls%ls";

        CONST       WCHAR rgszPrefix [] = L"m:";
        CONST       SIZE_T cchPrefixLen = celems(rgszPrefix) - 1;

        // Create the method element.

        // First, append the "m:" namespace prefix to the
        // method name.

        uiMethodNameLength = SysStringLen(bstrMethodName);

        uiQualifiedNameLength = uiMethodNameLength + cchPrefixLen;

        bstrQualifiedMethodName = SysAllocStringLen(NULL, uiQualifiedNameLength + 1);

        if (bstrQualifiedMethodName)
        {
            // Keep BoundsChecker from faulting

            _snwprintf(bstrQualifiedMethodName,
                       uiQualifiedNameLength,
                       rgszFmt,
                       rgszPrefix,
                       bstrMethodName);

            // _snwprintf() above does not add a NULL terminator.

            bstrQualifiedMethodName[uiQualifiedNameLength] = UNICODE_NULL;

            hr = HrCreateElement(bstrQualifiedMethodName,
                                 bstrMethodNameSpace,
                                 &pxdnMethod);

            if (SUCCEEDED(hr) && pxdnMethod)
            {
                VARIANT varAfter;

                // Insert the method element into the body element.

                varAfter.vt = VT_EMPTY;

                hr = pxdnBody->insertBefore(pxdnMethod,
                                            varAfter,
                                            NULL);

                pxdnMethod->Release();
            }
            else
            {
                TraceError("CSOAPRequest::HrCreateBody(): "
                           "Failed to create method element",
                           hr);
            }

            SysFreeString(bstrQualifiedMethodName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CSOAPRequest::HrCreateBody(): "
                       "Failed to allocate qualified method name",
                       hr);
        }

        if (SUCCEEDED(hr))
        {
            pxdnBody->AddRef();
            *ppxdnBody = pxdnBody;
        }

        pxdnBody->Release();
    }
    else
    {
        TraceError("CSOAPRequest::HrCreateBody(): "
                   "Failed to create Body element",
                   hr);
    }

    TraceError("CSOAPRequest::HrCreateBody(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    CSOAPRequest::HrSetEncodingStyleAttribute()
 *
 * Purpose:     Sets the encoding style attribute on an element to specify the
 *              encoding syle described in Section 5 of the SOAP 1.1 spec.
 *
 * Arguments:
 *  pxdn    [in]    The XML node on which to set the attribute
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 */

HRESULT
CSOAPRequest::HrSetEncodingStyleAttribute(
    IXMLDOMNode * pxdn)
{
    HRESULT hr = S_OK;

    // First, get an IXMLDOMElement interface on the node.

    IXMLDOMElement * pxde = NULL;

    hr = pxdn->QueryInterface(IID_IXMLDOMElement,
                              (void **) &pxde);

    if (SUCCEEDED(hr) && pxde)
    {
        BSTR bstrAttrName = NULL;

        bstrAttrName = SysAllocString(L"SOAP-ENV:encodingStyle");

        if (bstrAttrName)
        {
            BSTR bstrAttrValue = NULL;

            bstrAttrValue = SysAllocString(L"http://schemas.xmlsoap.org/soap/encoding/");

            if (bstrAttrValue)
            {
                VARIANT varAttrValue;

                VariantInit(&varAttrValue);

                varAttrValue.vt = VT_BSTR;
                V_BSTR(&varAttrValue) = bstrAttrValue;

                hr = pxde->setAttribute(bstrAttrName, varAttrValue);

                if (FAILED(hr))
                {
                    TraceError("CSOAPRequest::HrSetEncodingStyleAttribute(): "
                               "Failed to set attribute",
                               hr);
                }

                SysFreeString(bstrAttrValue);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CSOAPRequest::HrSetEncodingStyleAttribute(): "
                           "Could not allocate BSTR for encoding style "
                           "attribute value",
                           hr);
            }

            SysFreeString(bstrAttrName);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CSOAPRequest::HrSetEncodingStyleAttribute(): "
                       "Could not allocate BSTR for encoding style attribute"
                       "name",
                       hr);
        }


        pxde->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("CSOAPRequest::HrSetEncodingStyleAttribute(): "
                   "Failed to get IXMLDOMElement interface",
                   hr);
    }



    TraceError("CSOAPRequest::HrSetEncodingStyleAttribute(): "
               "Exiting",
               hr);

    return hr;
}

// ISOAPRequest Methods

// Initialization

/*
 * Function:    CSOAPRequest::Open()
 *
 * Purpose:     Initialize a SOAP Request object.
 *
 * Arguments:
 *  bstrMethodName      [in]    Name of the SOAP method the request will
                                invoke
 *  bstrInterfaceName   [in]    Name of the interface to which the above
 *                              method belongs
 *  bstrMethodNameSpace [in]    Namespace URI for the method name
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

STDMETHODIMP
CSOAPRequest::Open(
    BSTR bstrMethodName,
    BSTR bstrInterfaceName,
    BSTR bstrMethodNameSpace)
{
    HRESULT         hr = S_OK;

    // Check arguments

    if (bIsValidNonEmptyStringPtr(bstrMethodName, MAX_STRING_LENGTH, &hr) &&
        bIsValidNonEmptyStringPtr(bstrInterfaceName, MAX_STRING_LENGTH, &hr) &&
        bIsValidNonEmptyStringPtr(bstrMethodNameSpace, MAX_STRING_LENGTH, &hr))
    {
        // Get rid of any previous initialization.

        Cleanup();

        // Store the method and interface names.

        m_bstrMethodName = SysAllocString(bstrMethodName);

        if (m_bstrMethodName)
        {
            m_bstrInterfaceName = SysAllocString(bstrInterfaceName);

            if (NULL == m_bstrInterfaceName)
            {
                hr = E_OUTOFMEMORY;
                TraceError("CSOAPRequest::Open(): "
                           "Failed to allocate memory for interface name",
                           hr);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("CSOAPRequest::Open(): "
                       "Failed to allocate memory for method name",
                       hr);
        }

        // Start building the XML for the request.

        if (SUCCEEDED(hr))
        {
            hr = HrCreateDocumentObject();

            if (SUCCEEDED(hr) && m_pxdd)
            {
                IXMLDOMNode * pxdnEnvelope = NULL;

                hr = HrCreateElement(L"SOAP-ENV:Envelope",
                                     L"http://schemas.xmlsoap.org/soap/envelope/",
                                     &pxdnEnvelope);

                if (SUCCEEDED(hr) && pxdnEnvelope)
                {
                    hr = HrSetEncodingStyleAttribute(pxdnEnvelope);

                    if (SUCCEEDED(hr))
                    {
                        IXMLDOMNode * pxdnBody = NULL;

                        hr = HrCreateBody(bstrMethodName,
                                          bstrMethodNameSpace,
                                          &pxdnBody);

                        if (SUCCEEDED(hr) && pxdnBody)
                        {
                            VARIANT varAfter;

                            varAfter.vt = VT_EMPTY;

                            hr = pxdnEnvelope->insertBefore(pxdnBody,
                                                            varAfter,
                                                            NULL);

                            if (SUCCEEDED(hr))
                            {
                                hr = m_pxdd->appendChild(pxdnEnvelope,
                                                         &m_pxdnEnvelope);

                                if (FAILED(hr))
                                {
                                    TraceError("CSOAPRequest::Open(): "
                                               "Could not append envelope "
                                               "element",
                                               hr);
                                }
                            }
                            else
                            {
                                TraceError("CSOAPRequest::Open(): "
                                           "Could not insert body element",
                                           hr);

                            }

                            pxdnBody->Release();
                        }
                        else
                        {
                            TraceError("CSOAPRequest::Open(): "
                                       "Could not create body element",
                                       hr);
                        }
                    }
                    else
                    {
                        TraceError("CSOAPRequest::Open(): "
                                   "Failed to set encoding style attribute",
                                   hr);
                    }

                    pxdnEnvelope->Release();
                }
                else
                {
                    TraceError("CSOAPRequest::Open(): "
                               "Could not create envelope element",
                               hr);
                }
            }
            else
            {
                TraceError("CSOAPRequest::Open(): "
                           "Failed to create DOM Document object", hr);
            }
        }
    }
    else
    {
        TraceError("CSOAPRequest::Open(): "
                   "Invalid input arguments",
                   hr);
    }

    TraceError("CSOAPRequest::Open(): "
               "Exiting",
               hr);

    return hr;
}


// Parameter Manipulation

/*
 * Function:    CSOAPRequest::SetParameter()
 *
 * Purpose:     Set the value of a parameter in the SOAP request. If the
 *              parameter exists, its value is replaced, otherwise it is
 *              created.
 *
 * Arguments:
 *  bstrName        [in]    Name of the parameter
 *  pUnkNewValue    [in]    The XML fragment representing the parameter.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  $ NYI   SPATHER Currently does not check if the param already exists.
 *  $ NYI   SPATHER Write some notes about what pUnkNewValue is supposed to
 *                  be.
 */

STDMETHODIMP
CSOAPRequest::SetParameter(
    IN  BSTR        bstrName,
    IN  IUnknown    * pUnkNewValue)
{
    HRESULT     hr = S_OK;
    IXMLDOMNode * pxdnBody = NULL;

    hr = HrGetBodyNode(&pxdnBody);

    if (SUCCEEDED(hr) && pxdnBody)
    {
        IXMLDOMNode * pxdnMethod = NULL;

        // Got the Body element, now get the method element. This
        // should be the first child of the body element.

        hr = pxdnBody->get_firstChild(&pxdnMethod);

        if (SUCCEEDED(hr) && pxdnMethod)
        {
            IXMLDOMNode * pxdnNewVal = NULL;

            // Get the IXMLDOMNode interface on the new value.

            hr = pUnkNewValue->QueryInterface(IID_IXMLDOMNode,
                                              (void **) &pxdnNewVal);

            if (SUCCEEDED(hr) && pxdnNewVal)
            {
                // Append the new value as a child of the method element.

                hr = pxdnMethod->appendChild(pxdnNewVal,
                                             NULL);
                pxdnNewVal->Release();
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }

                TraceError("CSOAPRequest::SetParameter(): "
                           "Could not get IXMLDOMNode interface on "
                           "new value",
                           hr);
            }

            pxdnMethod->Release();

        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }

            TraceError("CSOAPRequest::SetParameter(): "
                       "Could not find method element",
                       hr);
        }

        pxdnBody->Release();
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("CSOAPRequest::SetParameter(): "
                   "Could not find Body element",
                   hr);
    }

    TraceError("CSOAPRequest::SetParameter(): "
               "Exiting",
               hr);

    return hr;
}



// Invoke


/*
 * Function:    CSOAPRequest::HrSetPOSTHeaders()
 *
 * Purpose:     Sets the POST headers on an HTTP Request object
 *
 * Arguments:
 *  pszHeaders      Returns the pointer to the allocated wide string of additional headers.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrSetPOSTHeaders(
    OUT BSTR * pszHeaders)
{
    HRESULT hr = S_OK;
    INT     size = 0;
    LPWSTR  lpwszHeaders = NULL;
    SIZE_T  cchTotal;

    *pszHeaders = NULL;

    size = wcslen(c_szContentType);
    size += wcslen(c_szSoapAction);

    if (m_bstrInterfaceName)
    {
        // There is an interface name. The full method name is then
        // "InterfaceName#methodName".

        size += SysStringLen(m_bstrMethodName);
        size += SysStringLen(m_bstrInterfaceName);

        size += 1 + 2 + 3;      //  1 for #, 2 for quotes, 3 for \r\n\0
    }
    else
    {
        size += SysStringLen(m_bstrMethodName);

        size += 2 + 3;          //  2 for quotes, 3 for \r\n\0
    }

    lpwszHeaders = (LPWSTR) MemAlloc(size * sizeof(WCHAR));

    if (lpwszHeaders)
    {
        if (m_bstrInterfaceName)
        {
            _snwprintf(lpwszHeaders,
                       size,
                       L"%ls%ls\"%ls#%ls\"\r\n",
                       c_szContentType,
                       c_szSoapAction,
                       m_bstrInterfaceName,
                       m_bstrMethodName);
        }
        else
        {
            _snwprintf(lpwszHeaders,
                       size,
                       L"%ls%ls\"%ls\"\r\n",
                       c_szContentType,
                       c_szSoapAction,
                       m_bstrMethodName);
        }

        BSTR Tmp = SysAllocString(lpwszHeaders);
        if (NULL == Tmp)
        {
            hr = E_OUTOFMEMORY;
        }
        *pszHeaders = Tmp;

        MemFree(lpwszHeaders);

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*
 * Function:    CSOAPRequest::HrSetMPOSTHeaders()
 *
 * Purpose:     Sets the M-POST headers on an HTTP Request object
 *
 * Arguments:
 *  phttpRequest    [in]    The HTTP request object on which to set the headers.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrSetMPOSTHeaders(
    OUT BSTR * pszHeaders)
{
    HRESULT hr = S_OK;
    INT     size = 0;
    LPWSTR  lpwszHeaders = NULL;
    SIZE_T  cchTotal;

    size = wcslen(c_szContentType);
    size += wcslen(c_szMPostMan);
    size += wcslen(c_szMPostSoapAction);

    if (m_bstrInterfaceName)
    {
        // There is an interface name. The full method name is then
        // "InterfaceName#methodName".

        size += SysStringLen(m_bstrMethodName);
        size += SysStringLen(m_bstrInterfaceName);

        size += 1 + 2 + 3;      //  1 for #, 2 for quotes, 3 for \r\n\0
    }
    else
    {
        size += SysStringLen(m_bstrMethodName);

        size += 2 + 3;          //  2 for quotes, 3 for \r\n\0
    }

    lpwszHeaders = (LPWSTR) MemAlloc(size * sizeof(WCHAR));

    if (lpwszHeaders)
    {
        if (m_bstrInterfaceName)
        {
            _snwprintf(lpwszHeaders,
                       size,
                       L"%ls%ls%ls\"%ls#%ls\"\r\n",
                       c_szContentType,
                       c_szMPostMan,
                       c_szMPostSoapAction,
                       m_bstrInterfaceName,
                       m_bstrMethodName);
        }
        else
        {
            _snwprintf(lpwszHeaders,
                       size,
                       L"%ls%ls%ls\"%ls\"\r\n",
                       c_szContentType,
                       c_szMPostMan,
                       c_szMPostSoapAction,
                       m_bstrMethodName);
        }

        BSTR Tmp = SysAllocString(lpwszHeaders);
        if (NULL == Tmp)
        {
            hr = E_OUTOFMEMORY;
        }
        *pszHeaders = Tmp;

        MemFree(lpwszHeaders);

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*
 * Function:    CSOAPRequest::HrParseFault()
 *
 * Purpose:     Parses a <SOAP-ENV:fault> element from a method response.
 *
 * Arguments:
 *  pxdnFaultNode   [in]    Node object representing the <SOAP-ENV:fault>
 *                          element.
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrParseFault(
    IN IXMLDOMNode * pxdnFaultNode)
{
    HRESULT hr = S_OK;

    IXMLDOMNode * pxdnChild = NULL;
    BOOL        bFoundFaultCode = FALSE;
    BOOL        bFoundFaultString = FALSE;
    BOOL        bFoundDetail = FALSE;

    // Go through the child nodes of the <SOAP-ENV:fault> element to find
    // the runcode, faultcode, and faultstring elements.

    hr = pxdnFaultNode->get_firstChild(&pxdnChild);

    while (SUCCEEDED(hr) && pxdnChild)
    {
        IXMLDOMNode * pxdnNextSibling = NULL;
        BSTR    bstrNodeName = NULL;

        // Get the node name, then its text value. Decide what to do with
        // the text value based on the node name.

        hr = pxdnChild->get_baseName(&bstrNodeName);

        if (SUCCEEDED(hr) && bstrNodeName)
        {
            // Get the first child, which should be the text contents
            // of this node.

            IXMLDOMNode * pxdnText = NULL;

            hr = pxdnChild->get_firstChild(&pxdnText);

            if (SUCCEEDED(hr) && pxdnText)
            {
                VARIANT varValue;

                VariantInit(&varValue);

                hr = pxdnText->get_nodeValue(&varValue);

                if (SUCCEEDED(hr))
                {
                    if (wcscmp(bstrNodeName, L"faultcode") == 0)
                    {
                        Assert(VT_BSTR == varValue.vt);

                        bFoundFaultCode = TRUE;

                        m_bstrFaultCode = V_BSTR(&varValue);

                        // Don't want to do VariantClear() here because we
                        // are saving the string.
                    }
                    else if (wcscmp(bstrNodeName, L"faultstring") == 0)
                    {
                        Assert(VT_BSTR == varValue.vt);

                        bFoundFaultString = TRUE;

                        m_bstrFaultString = V_BSTR(&varValue);

                        // Don't want to do VariantClear() here because
                        // we are saving the string.
                    }
                    else if (wcscmp(bstrNodeName, L"detail") == 0)
                    {
                        bFoundDetail = TRUE;

                        pxdnChild->AddRef();
                        m_pxdnFaultDetail = pxdnChild;

                        VariantClear(&varValue);
                    }
                    else
                    {
                        // An unrecognized element was found. According to
                        // SOAP, this is allowed - we will do nothing with
                        // it.

                        VariantClear(&varValue);
                    }
                }
                else
                {
                    TraceError("CSOAPRequest::HrParseFault(): "
                               "Failed to get node value",
                               hr);
                }

                pxdnText->Release();
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                }
                TraceError("CSOAPRequest::HrParseFault(): "
                           "Failed to get child text node",
                           hr);
            }

            SysFreeString(bstrNodeName);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
            }
            TraceError("CSOAPRequest::HrParseFault(): "
                       "Failed to get child node name",
                       hr);
        }

        if (FAILED(hr))
        {
            pxdnChild->Release();
            break;
        }

        hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
        pxdnChild->Release();
        pxdnChild = pxdnNextSibling;
    }

    if (SUCCEEDED(hr))
    {
        // Last time through the loop would have returned S_FALSE. As long
        // as we found all the required elements, we can return S_OK;

        if (bFoundFaultCode && bFoundFaultString) // don't need the detail element
        {
            hr = S_OK;
        }
        else
        {
            hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
            TraceTag(ttidSOAPRequest,
                     "CSOAPRequest::HrParseFault(): "
                     "<SOAP-ENV:fault> element not complete:\n");
            if (!bFoundFaultCode)
            {
                TraceTag(ttidSOAPRequest,
                         "CSOAPRequest::HrParseFault(): "
                         "\tMissing <faultcode> element\n");
            }
            if (!bFoundFaultString)
            {
                TraceTag(ttidSOAPRequest,
                         "CSOAPRequest::HrParseFault(): "
                         "\tMissing <faultstring> element\n");
            }
        }
    }

    TraceError("CSOAPRequest::HrParseFault(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    CSOAPRequest::HrParseMethodResponse()
 *
 * Purpose:     Parses the <m:%method%Response> element in a SOAP
 *              response and extracts the return value from it.
 *
 * Arguments:
 *  pxdnMethodResponse  [in]    The <m:%method%Response> node
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrParseMethodResponse(
    IN  IXMLDOMNode * pxdnMethodResponse)
{
    HRESULT hr = S_OK;

    // Verify that the element name is correct.

    BSTR    bstrElementName = NULL;

    hr = pxdnMethodResponse->get_baseName(&bstrElementName);

    if (SUCCEEDED(hr) && bstrElementName)
    {
        UINT    ucchMethodNameLen = SysStringLen(m_bstrMethodName);

        if ((wcsncmp(bstrElementName,
                     m_bstrMethodName,
                     ucchMethodNameLen) == 0) &&
            (wcscmp(bstrElementName + ucchMethodNameLen,
                    L"Response") == 0))
        {
            pxdnMethodResponse->AddRef();
            m_pxdnResponseElement = pxdnMethodResponse;
        }
        else
        {
            hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
            TraceTag(ttidSOAPRequest,
                     "CSOAPRequest::HrParseMethodResponse(): "
                     "Method response element had invalid name: '%S'\n",
                     bstrElementName);
        }


        SysFreeString(bstrElementName);
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
        }
        TraceError("CSOAPRequest::HrParseMethodResponse(): "
                   "Could not get element name",
                   hr);
    }


    TraceError("CSOAPRequest::HrParseMethodResponse(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    CSOAPRequest::fIsSOAPElement()
 *
 * Purpose:     Determines whether an XML DOM node is a specific SOAP element.
 *
 * Arguments:
 *  pxdn                       [in]    The XML DOM node
 *  pcwszSOAPElementBaseName   [in]    The base name of the SOAP element
 *                                     e.g. "Header", "Body", or "Fault"
 *
 * Return Value:
 *  TRUE if the node's base name matches pcwszSOAPElementBaseName and its
 *  namespace URI matches the SOAP namespace URI; FALSE otherwise.
 */

BOOL
CSOAPRequest::fIsSOAPElement(
    IN IXMLDOMNode * pxdn,
    IN LPCWSTR     pcwszSOAPElementBaseName)
{
    HRESULT hr = S_OK;
    BOOL    fRetVal = FALSE;

    BSTR        bstrNodeBaseName = NULL;

    hr = pxdn->get_baseName(&bstrNodeBaseName);

    if (SUCCEEDED(hr) && bstrNodeBaseName)
    {
        BSTR bstrNamespaceURI = NULL;

        hr = pxdn->get_namespaceURI(&bstrNamespaceURI);

        if (SUCCEEDED(hr) && bstrNamespaceURI)
        {
            if ((wcscmp(bstrNodeBaseName, pcwszSOAPElementBaseName) == 0) &&
                (wcscmp(bstrNamespaceURI, WSZ_SOAP_NAMESPACE_URI) == 0))
            {
                fRetVal = TRUE;
            }

            SysFreeString(bstrNamespaceURI);
        }
        else
        {
            if (SUCCEEDED(hr))
            {
                hr = E_FAIL;
            }
            TraceError("CSOAPRequest::fIsSOAPElement(): "
                       "Failed to get namespace URI",
                       hr);
        }

        SysFreeString(bstrNodeBaseName);
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
        TraceError("CSOAPRequest::fIsSOAPElement(): "
                   "Failed to get node base name",
                   hr);
    }

    return fRetVal;
}


/*
 * Function:    CSOAPRequest::HrParseResponse()
 *
 * Purpose:     Parses the XML fragment sent in the server's response and
 *              extracts the relevant information from it.
 *
 * Arguments:
 *  pxdeResponseRoot    [in]    The root element of the response XML fragment
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrParseResponse(
    IN  IXMLDOMElement  * pxdeResponseRoot)
{
    HRESULT hr = S_OK;

    if (fIsSOAPElement(pxdeResponseRoot, L"Envelope"))
    {
        // The response root is the "Envelope" element. Go through its children,
        // which should include the <SOAP-ENV:Header> and / or <SOAP-ENV:Body>
        // elements.

        IXMLDOMNode * pxdnChild = NULL;
        BOOL        bFoundBodyElement = FALSE;

        hr = pxdeResponseRoot->get_firstChild(&pxdnChild);

        while (SUCCEEDED(hr) && pxdnChild)
        {
            IXMLDOMNode * pxdnNextSibling = NULL;

            if (fIsSOAPElement(pxdnChild, L"Header"))
            {
                // Found the header element.

                pxdnChild->AddRef();
                m_pxdnResponseHeaders = pxdnChild;
            }
            else if (fIsSOAPElement(pxdnChild, L"Body"))
            {
                // Found body element. Child is either method response
                // element or <SOAP-ENV:fault> element.

                IXMLDOMNode * pxdnBodyChild = NULL;

                bFoundBodyElement = TRUE;

                hr = pxdnChild->get_firstChild(&pxdnBodyChild);

                if (SUCCEEDED(hr) && pxdnBodyChild)
                {
                    // Determine if it's a fault element or a method
                    // response element.

                    if (fIsSOAPElement(pxdnBodyChild, L"Fault"))
                    {
                        if (HTTP_STATUS_SERVER_ERROR == m_lHTTPStatus)
                        {
                            hr = HrParseFault(pxdnBodyChild);

                            if (SUCCEEDED(hr))
                            {
                                hr = SOAPREQ_E_METHODFAILED;
                            }
                        }
                        else
                        {
                            hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                            TraceTag(ttidSOAPRequest,
                                     "CSOAPRequest::HrParseResponse(): "
                                     "HTTP Status was %ld -- should be "
                                     "500 for SOAP fault",
                                     m_lHTTPStatus);
                        }

                    }
                    else
                    {
                        if (HTTP_STATUS_OK == m_lHTTPStatus)
                        {
                            hr = HrParseMethodResponse(pxdnBodyChild);
                        }
                        else
                        {
                            hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                            TraceTag(ttidSOAPRequest,
                                     "CSOAPRequest::HrParseResponse(): "
                                     "HTTP Status was %ld -- should be "
                                     "200 for successful SOAP response",
                                     m_lHTTPStatus);
                        }

                    }

                    pxdnBodyChild->Release();
                }
                else
                {
                    if (SUCCEEDED(hr))
                    {
                        hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                    }

                    TraceError("CSOAPRequest::HrParseResponse(): "
                               "Failed to get child of body element",
                               hr);
                }
            }
            else
            {
                hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                TraceTag(ttidSOAPRequest,
                         "CSOAPRequest::HrParseResponse(): "
                         "Unknown element found in response envelope");
            }

            if (FAILED(hr))
            {
                pxdnChild->Release();
                break;
            }

            hr = pxdnChild->get_nextSibling(&pxdnNextSibling);
            pxdnChild->Release();
            pxdnChild = pxdnNextSibling;

        }

        if (SUCCEEDED(hr))
        {
            // Last time through the loop would have returned S_FALSE. As
            // long as we found a <SOAP-ENV:Body> element (required) we can
            // return S_OK.

            if (bFoundBodyElement)
            {
                hr = S_OK;
            }
            else
            {
                hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                TraceError("CSOAPRequest::HrParseResponse(): "
                           "Response did not contain a <SOAP-ENV:Body> element",
                           hr);
            }
        }
    }
    else
    {
        hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
        TraceError("CSOAPRequest::HrParseResponse(): "
                   "SOAP envelope element not found",
                   hr);
    }

    TraceError("CSOAPRequest::HrParseResponse(): "
               "Exiting",
               hr);

    return hr;
}


/*
 * Function:    CSOAPRequest::HrProcessResponse()
 *
 * Purpose:     Processes an HTTP Response to a SOAP Request.
 *
 * Arguments:
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrProcessResponse()
{
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        if (m_bstrResponseBody &&
            (wcslen(m_bstrResponseBody) > 0) &&
            ((m_lHTTPStatus == HTTP_STATUS_OK) ||
             (m_lHTTPStatus == HTTP_STATUS_SERVER_ERROR)))
        {
            IXMLDOMDocument * pxddResponse = NULL;

            hr = CoCreateInstance(CLSID_DOMDocument30,
                                  NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IXMLDOMDocument,
                                  (void **) &pxddResponse);

            if (SUCCEEDED(hr) && pxddResponse)
            {
                hr = pxddResponse->put_async(VARIANT_FALSE);

                if (SUCCEEDED(hr))
                {
                    VARIANT_BOOL    vbSuccess;

                    pxddResponse->put_resolveExternals(VARIANT_FALSE);
                    hr = pxddResponse->loadXML(m_bstrResponseBody,
                                               &vbSuccess);

                    if (SUCCEEDED(hr) && (VARIANT_TRUE == vbSuccess))
                    {
                        IXMLDOMElement  * pxdeResponseRoot = NULL;

                        hr = pxddResponse->get_documentElement(&pxdeResponseRoot);

                        if (SUCCEEDED(hr) && pxdeResponseRoot)
                        {
                            hr = HrParseResponse(pxdeResponseRoot);

                            pxdeResponseRoot->Release();
                        }
                        else
                        {
                            if (SUCCEEDED(hr))
                            {
                                hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                            }
                            TraceError("CSOAPRequest::HrProcessResponse(): "
                                       "Failed to get document element",
                                       hr);
                        }
                    }
                    else
                    {
                        hr = SOAPREQ_E_ERROR_PROCESSING_RESPONSE;
                        TraceError("CSOAPRequest::HrProcessResponse(): "
                                   "Failed to load XML",
                                   hr);
                    }

                }
                else
                {
                    TraceError("CSOAPRequest::HrProcessResponse(): "
                               "Failed to set async property",
                               hr);
                }

                pxddResponse->Release();
            }
            else
            {
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;
                }
                TraceError("CSOAPRequest::HrProcessResponse(): "
                           "Failed to create DOM Document object",
                           hr);
            }
        }
        else
        {
            TraceTag(ttidSOAPRequest,
                     "CSOAPRequest::HrProcessResponse(): "
                     "No response text found - HTTP status is %ld",
                     m_lHTTPStatus);

            hr = SOAPREQ_E_TRANSPORTERROR;
        }

    }
    else
    {
        TraceError("CSOAPRequest::HrProcessResponse(): "
                       "Failed to get response text",
                       hr);
    }

    TraceError("CSOAPRequest::HrProcessResponse(): "
               "Exiting",
               hr);

    return hr;
}



/*
 * Function:    CSOAPRequest::HrPOSTRequest()
 *
 * Purpose:     Sends the request to the server using the HTTP "POST" verb.
 *
 * Arguments:
 *  bstrTargetURI   [in]    URI identifying the server
 *
 * Return Value:
 *
 * Notes:
 *  (none)
 */

HRESULT
CSOAPRequest::HrPOSTRequest(
    IN    BSTR      bstrTargetURI,
    IN    DWORD_PTR  pControlConnect,
    IN    DWORD     dwRequestType)
{
    HRESULT hr = S_OK;
    BSTR    bstrHeaders = NULL;
    BSTR    bstrRequest = NULL;

    CSOAPRequestAsync* pSOAPAsync = new CSOAPRequestAsync;


    if (pSOAPAsync && SUCCEEDED(hr))
    {
        if (dwRequestType == USE_POST)
        {
            hr = HrSetPOSTHeaders(&bstrHeaders);
            bstrRequest = SysAllocString(L"POST");
        }
        else
        {
            hr = HrSetMPOSTHeaders(&bstrHeaders);
            bstrRequest = SysAllocString(L"M-POST");
        }

        if (SUCCEEDED(hr))
        {
            VARIANT varBodyText;

            VariantInit(&varBodyText);

            varBodyText.vt = VT_BSTR;

            hr = m_pxdd->get_xml(&(V_BSTR(&varBodyText)));

            if (SUCCEEDED(hr) && V_BSTR(&varBodyText))
            {
                DWORD   dwResult;
                HANDLE  hDoneEvent = NULL;

                TraceTag(ttidSOAPRequest,
                         "CSOAPRequest::HrPOSTRequest(): "
                         "%S",
                         V_BSTR(&varBodyText));

                if (pSOAPAsync->Init(&hDoneEvent,
                                    bstrTargetURI,
                                    bstrRequest,
                                    bstrHeaders,
                                    V_BSTR(&varBodyText),
                                    pControlConnect) )
                {
                    Assert(hDoneEvent);

                    hr = HrMyWaitForMultipleHandles(0,
                                            c_csecSendTimeout * 1000,
                                            1,
                                            &hDoneEvent,
                                            &dwResult);

                    if (WAIT_OBJECT_0 == dwResult)
                    {
                        if (pSOAPAsync->GetResults(&m_lHTTPStatus,
                                                &m_bstrHTTPStatusText,
                                                &m_bstrResponseBody))
                        {
                            hr = HrProcessResponse();

                            TraceError("CSOAPRequest::HrPOSTRequest(): "
                                       "Error Processing Response",
                                       hr);

                        }
                        else
                        {
                            hr = SOAPREQ_E_METHODFAILED;
                            TraceError("CSOAPRequest::HrPOSTRequest(): "
                                       "results not available",
                                       hr);
                        }
                    }
                    else if (WAIT_TIMEOUT == dwResult)
                    {
                        hr = SOAPREQ_E_TIMEOUT;
                        TraceError("CSOAPRequest::HrPOSTRequest(): "
                                   "Request timed out",
                                   hr);
                    }
                }
                else
                {
                    hr = HrFromLastWin32Error();
                    TraceError("CSOAPRequest::HrMPOSTRequest(): "
                               "Unable to send request",
                               hr);
                }

                VariantClear(&varBodyText);
            }
            else
            {
                TraceError("CSOAPRequest::HrPOSTRequest(): "
                           "Failed to get body text",
                           hr);
            }

        }
        else
        {
            TraceError("CSOAPRequest::HrPOSTRequest(): "
                       "Failed to set SOAP Headers",
                       hr);
        }

    }
    else
    {
        TraceError("CSOAPRequest::HrPOSTRequest(): "
                   "Failed to create HTTP Request",
                   hr);
    }


    if (pSOAPAsync)
    {
        // do not delete it.
        // instead call DiInit so it can be deleted gracefully
        pSOAPAsync->DeInit();
    }

    if (bstrHeaders)
        SysFreeString(bstrHeaders);
    if (bstrRequest)
        SysFreeString(bstrRequest);

    TraceError("CSOAPRequest::HrPOSTRequest(): "
               "Exiting",
               hr);

    return hr;
}



/*
 * Function:    CSOAPRequest::Execute()
 *
 * Purpose:
 *
 * Arguments:
 *
 * Return Value:
 *
 * Notes:
 *  (none)
 */

STDMETHODIMP
CSOAPRequest::Execute(
    BSTR bstrTargetURI,
    DWORD_PTR pControlConnect)
{
    HRESULT hr = S_OK;

    // Clean up the return data from any previous Execute() attempt.

    CleanupFeedbackData();

    // First, try POST.

    hr = HrPOSTRequest(bstrTargetURI, pControlConnect, USE_POST);

    if ((SOAPREQ_E_TRANSPORTERROR == hr) &&
        (405 == m_lHTTPStatus))
    {
        // HTTP status was "405 - Method Not Allowed". Try M-POST.

        TraceTag(ttidSOAPRequest,
                 "CSOAPRequest::Execute(): "
                 "POST failed with HTTP 405. Trying M-POST\n");

        hr = HrPOSTRequest(bstrTargetURI, pControlConnect, USE_MPOST);

        if (FAILED(hr))
        {
            TraceError("CSOAPRequest::Execute(): "
                       "Failed to M-POST Request",
                       hr);
        }
    }
    else if (FAILED(hr))
    {
        TraceError("CSOAPRequest::Execute(): "
                   "Failed to POST Request",
                   hr);
    }

    TraceError("CSOAPRequest::Execute(): "
               "Exiting",
               hr);

    return hr;
}


// Feedback

/*
 * Function:    CSOAPRequest::get_ResponseReturnValue()
 *
 * Purpose:
 *
 * Arguments:
 *
 * Return Value:
 *
 * Notes:
 *  (none)
 */

STDMETHODIMP
CSOAPRequest::get_ResponseElement(
    IUnknown    ** ppUnkValue)
{
    HRESULT hr = S_OK;

    if (!IsBadWritePtr((void *)ppUnkValue, sizeof(IUnknown *)))
    {
        *ppUnkValue = NULL;

        if (m_pxdnResponseElement)
        {
            hr = m_pxdnResponseElement->QueryInterface(IID_IUnknown,
                                                       (void **) ppUnkValue);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * Function:    CSOAPRequest::get_ResponseFaultDetail()
 *
 * Purpose:
 *
 * Arguments:
 *
 * Return Value:
 *
 */

STDMETHODIMP
CSOAPRequest::get_ResponseFaultDetail(
    IUnknown ** ppUnkValue)
{
    HRESULT hr = S_OK;

    if (!IsBadWritePtr((void *) ppUnkValue, sizeof(IUnknown *)))
    {
        *ppUnkValue = NULL;

        if (m_pxdnFaultDetail)
        {
            hr = m_pxdnFaultDetail->QueryInterface(IID_IUnknown,
                                                   (void **) ppUnkValue);
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

/*
 * Function:    CSOAPRequest::get_ResponseHTTPStatus()
 *
 * Purpose:     Returns the HTTP status of the SOAP Request
 *
 * Arguments:
 *  plValue     [out]    Address at which to place HTTP status value
 *
 * Return Value:
 *  S_OK if successful, other HRESULT otherwise.
 *
 * Notes:
 *  (none)
 */

STDMETHODIMP
CSOAPRequest::get_ResponseHTTPStatus(
    OUT long    * plValue)
{
    HRESULT hr = S_OK;

    if (!IsBadWritePtr((void *) plValue, sizeof(long)))
    {
        *plValue = m_lHTTPStatus;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\downloadctest.h ===
// downloadctest.h : main header file for the DOWNLOADCTEST application
//

#if !defined(AFX_DOWNLOADCTEST_H__F738A362_59ED_11D3_990B_00C04F529B35__INCLUDED_)
#define AFX_DOWNLOADCTEST_H__F738A362_59ED_11D3_990B_00C04F529B35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestApp:
// See downloadctest.cpp for the implementation of this class
//

class CDownloadctestApp : public CWinApp
{
public:
	CDownloadctestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDownloadctestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDownloadctestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOWNLOADCTEST_H__F738A362_59ED_11D3_990B_00C04F529B35__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\downloadctestdlg.h ===
// downloadctestDlg.h : header file
//

#if !defined(AFX_DOWNLOADCTESTDLG_H__F738A364_59ED_11D3_990B_00C04F529B35__INCLUDED_)
#define AFX_DOWNLOADCTESTDLG_H__F738A364_59ED_11D3_990B_00C04F529B35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MAX_DEVICES 1000
#define MAX_SERVICES 1000
#define IMAGE_DEVICE 0
#define IMAGE_SERVICE 1
#define IMAGE_DEVICE_SELECTED 2
#define IMAGE_SERVICE_SELECTED 3

#define FLAG_IS_SERVICE 0x80000000


#define IMAGE_PROPERTY 4

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestDlg dialog

class CDownloadctestDlg : public CDialog,
  public IUPnPDescriptionDocumentCallback
{
// Construction
public:
    CDownloadctestDlg(CWnd* pParent = NULL);    // standard constructor
    ~CDownloadctestDlg();

#ifdef NEVER
    void LoadFromMoniker(IMoniker * pmk);
#endif // NEVER
    HTREEITEM AddDeviceToTree(IUPnPDevice * pud, HTREEITEM tiParent);
    void AddChildElements(IUPnPDevice * pParent, HTREEITEM tiParent);
    void ClearDeviceTree();
    void ClearSelectionProperties();
    void AddPropertyToList(LPCWSTR pszName, LPCWSTR pszValue);
    void DisplayDeviceProperties(IUPnPDevice * pud);
    void AutosizeList();

    HTREEITEM AddServiceToTree(ULONG ulServiceIndex, HTREEITEM tiParent);
    HRESULT AddServicesToList(HTREEITEM tiParent, IUPnPDevice * pud);
    void DisplayServiceProperties(ULONG ulIndex);
    void EnableCSOButton(BOOL fEnable);
    void EnableGDBUDNButton(BOOL fEnable);

// Dialog Data
    //{{AFX_DATA(CDownloadctestDlg)
	enum { IDD = IDD_DOWNLOADCTEST_DIALOG };
    CListCtrl   m_listSelectionProperties;
    CTreeCtrl   m_treeDevice;
    BOOL    m_bSynchronous;
    BOOL    m_bAbortImmediately;
	CString	m_sURL;
	//}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDownloadctestDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    IUPnPDescriptionDocument * m_pudd;
    DWORD m_dwCookie;

    IUPnPDevice * m_pDeviceArray [ MAX_DEVICES ];
    UPNP_SERVICE_PRIVATE m_pServiceArray [ MAX_SERVICES ];

    DWORD m_cDevices;
    DWORD m_cServices;
    DWORD m_cProps;

    CImageList m_imgList;

    // IUPnPDescriptionDocumentCallback methods
    STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(LoadComplete)(HRESULT hrLoadResult);

    ULONG m_dwRef;

    // Generated message map functions
    //{{AFX_MSG(CDownloadctestDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnLoad();
    afx_msg void OnGetrootdevice();
    afx_msg void OnSelchangedDevicetree(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCreateServiceObject();
	afx_msg void OnGetdevicebyudn();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOWNLOADCTESTDLG_H__F738A364_59ED_11D3_990B_00C04F529B35__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\propertynotifysink1.cpp ===
// PropertyNotifySink1.cpp: implementation of the CPropertyNotifySink class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "downloadctest.h"
#include "PropertyNotifySink1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\propertynotifysink1.h ===
// PropertyNotifySink1.h: interface for the CPropertyNotifySink class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROPERTYNOTIFYSINK1_H__F6DB32F0_5A04_11D3_990C_00C04F529B35__INCLUDED_)
#define AFX_PROPERTYNOTIFYSINK1_H__F6DB32F0_5A04_11D3_990C_00C04F529B35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

// _WIN32_WINNT = 0x0500
class CPropertyNotifySink : IPropertyNotifySink
{
public:
    CPropertyNotifySink()
    {
        _ulRef = 0;
    }
    virtual ~CPropertyNotifySink()
    {
        ASSERT(0 == _ulRef);
    }

// IUnknown methods
    HRESULT STDMETHODCALLTYPE QueryInterface (REFIID piid, LPVOID* ppresult)
    {
        HRESULT hr;
        ASSERT(ppresult);

        if (IsEqualIID(piid, IID_IUnknown))
        {
            hr = S_OK;
            *ppresult = static_cast<IUnknown*>(this);
        }
        else if (IsEqualIID(piid, IID_IPropertyNotifySink))
        {
            hr = S_OK;
            *ppresult = static_cast<IPropertyNotifySink*>(this);
        }
        else
        {
            hr = E_NOINTERFACE;
            *ppresult = NULL;
        }

        if (!hr)
        {
            AddRef();
        }

        return hr;
    }
    ULONG STDMETHODCALLTYPE AddRef()
    {
        return ++_ulRef;
    }
    ULONG STDMETHODCALLTYPE Release()
    {
        if (--_ulRef > 0)
        {
            return _ulRef;
        }
        else
        {
            TRACE(_T("CPropertyNotifySink going away\n"));
            delete this;
            return 0;
        }
    }

// IPropertyNotifySink methods
    HRESULT STDMETHODCALLTYPE OnChanged(DISPID dispid)
    {
        TRACE(_T("IPropertyNotifySink::OnChanged(): %Lx\n"), dispid);
//        TRACE(_T("IPropertyNotifySink::OnChanged(): %Lx DISPID_XMLDOCUMENT_READYSTATE=%Lx %Lx\n"), dispid, DISPID_XMLDOCUMENT_READYSTATE, DISPID_UNKNOWN );
        return S_OK;
    }
    HRESULT STDMETHODCALLTYPE OnRequestEdit(DISPID dispid)
    {
        TRACE(_T("IPropertyNotifySink::OnRequestEdit(): %Lx\n"), dispid);
    //        TRACE(_T("IPropertyNotifySink::OnRequestEdit(): %Lx DISPID_XMLDOCUMENT_READYSTATE=%Lx %Lx\n"), dispid, DISPID_XMLDOCUMENT_READYSTATE, DISPID_UNKNOWN );
        return S_OK;
    }

// private:
    ULONG _ulRef;
};

#endif // !defined(AFX_PROPERTYNOTIFYSINK1_H__F6DB32F0_5A04_11D3_990C_00C04F529B35__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\downloadctestdlg.cpp ===
// downloadctestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "downloadctest.h"
#include <upnp.h>
#include "downloadctestDlg.h"
#include "objbase.h"
#include "objidl.h"
#include "urlmon.h"
#include "PropertyNotifySink1.h"

 // ugh.
#include <upnp_i.c>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// BUGBUG(cmr): this is WACK.  This is crazy and WACK.

#undef VARIANT_TRUE
#undef VARIANT_FALSE

#define VARIANT_TRUE ((VARIANT_BOOL)-1)
#define VARIANT_FALSE ((VARIANT_BOOL)0)













// the following were stolen from http://kbinternal./kb/articles/q138/8/13.htm

/*
* AnsiToUnicode converts the ANSI string pszA to a Unicode string
* and returns the Unicode string through ppszW. Space for the
* the converted string is allocated by AnsiToUnicode.
*/ 

HRESULT AnsiToUnicode(LPCSTR pszA, LPWSTR * ppszW)
{

   ULONG cCharacters;
   DWORD dwError;

   // If input is null then just return the same.
   if (NULL == pszA)
   {
       *ppszW = NULL;
       return NOERROR;
   }

   // Determine number of wide characters to be allocated for the
   // Unicode string.
   cCharacters =  strlen(pszA)+1;

   // Use of the OLE allocator is required if the resultant Unicode
   // string will be passed to another COM component and if that
   // component will free it. Otherwise you can use your own allocator.
   *ppszW = new WCHAR [cCharacters];
   if (NULL == *ppszW)
       return E_OUTOFMEMORY;

   // Covert to Unicode.
   if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, cCharacters,
                 *ppszW, cCharacters))
   {
       dwError = GetLastError();
       delete [] *ppszW;
       *ppszW = NULL;
       return HRESULT_FROM_WIN32(dwError);
   }

   return NOERROR;
}
/*
* UnicodeToAnsi converts the Unicode string pszW to an ANSI string
* and returns the ANSI string through ppszA. Space for the
* the converted string is allocated by UnicodeToAnsi.
*/ 

HRESULT UnicodeToAnsi(LPCWSTR pszW, LPSTR * ppszA)
{

   ULONG cbAnsi, cCharacters;
   DWORD dwError;

   // If input is null then just return the same.
   if (NULL == pszW)
   {
       *ppszA = NULL;
       return NOERROR;
   }

   cCharacters = wcslen(pszW)+1;
   // Determine number of bytes to be allocated for ANSI string. An
   // ANSI string can have at most 2 bytes per character (for Double
   // Byte Character Strings.)
   cbAnsi = cCharacters*2;

   // Use of the OLE allocator is not required because the resultant
   // ANSI  string will never be passed to another COM component. You
   // can use your own allocator.
   *ppszA = (LPSTR) new CHAR [cbAnsi];
   if (NULL == *ppszA)
       return E_OUTOFMEMORY;

   // Convert to ANSI.
   if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                 cbAnsi, NULL, NULL))
   {
       dwError = GetLastError();
       delete [] ppszA;
       *ppszA = NULL;
       return HRESULT_FROM_WIN32(dwError);
   }
   return NOERROR;

}

LPWSTR CopyWCHAR(LPCWSTR pszIn)
{
    LPWSTR pszResult;
    ULONG cch;

    cch = wcslen(pszIn) + 1;
    pszResult = new WCHAR [cch];
    if (pszResult)
    {
        wcsncpy(pszResult, pszIn, cch);
        pszResult[cch-1] = 0;
    }

    return pszResult;
}

LPTSTR CopyTCHAR(LPCTSTR pszIn)
{
    LPTSTR pszResult;
    ULONG cch;

    cch = _tcslen(pszIn) + 1;
    pszResult = new TCHAR [cch];
    if (pszResult)
    {
        _tcsncpy(pszResult, pszIn, cch);
        pszResult[cch-1] = 0;
    }

    return pszResult;
}

#ifdef UNICODE
LPWSTR TCHARtoWCHAR(LPCTSTR pszIn)
{
    return CopyWCHAR(pszIn);
}
LPTSTR WCHARtoTCHAR(LPCWSTR pszIn)
{
    return CopyWCHAR(pszIn);
}

#else // this isn't UNICODE
LPWSTR TCHARtoWCHAR(LPCTSTR pszIn)
{
    HRESULT hr;
    LPWSTR pszResult;

    hr = AnsiToUnicode(pszIn, &pszResult);
    ASSERT(SUCCEEDED(hr));

    return pszResult;
}

LPTSTR WCHARtoTCHAR(LPCWSTR pszIn)
{
    HRESULT hr;
    LPTSTR pszResult;

    hr = UnicodeToAnsi(pszIn, &pszResult);
    ASSERT(SUCCEEDED(hr));

    return pszResult;
}
#endif // UNICODE


//#include "msxml.c"

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestDlg dialog

CDownloadctestDlg::CDownloadctestDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CDownloadctestDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDownloadctestDlg)
    m_bSynchronous = FALSE;
    m_bAbortImmediately = FALSE;
	m_sURL = _T("");
	//}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent DestroyIcon in Win32
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);

    m_pudd = NULL;

    memset(m_pDeviceArray, 0, sizeof(m_pDeviceArray));
    memset(m_pServiceArray, 0, sizeof(m_pServiceArray));
    m_cDevices = 0;
    m_cServices = 0;
    m_cProps = 0;
    m_dwRef = 0;
}

CDownloadctestDlg::~CDownloadctestDlg()
{
    ULONG ulTemp;
    ULONG ul;

    // free all the devices

    TRACE(_T("releasing %d devices\n"), m_cDevices);
    for (ulTemp = 0; ulTemp < m_cDevices; ++ulTemp)
    {
        ULONG ulResult;
        ASSERT(m_pDeviceArray[ulTemp]);
        ulResult = m_pDeviceArray[ulTemp]->Release();
        TRACE(_T("m_pDeviceArray[%d]->Release returned %d\n"), ulTemp, ulResult);

        m_pDeviceArray[ulTemp] = NULL;
    }
    m_cDevices = 0;

    TRACE(_T("freeing %d services\n"), m_cServices);
    for (ulTemp = 0; ulTemp < m_cServices; ++ulTemp)
    {
        ASSERT(m_pServiceArray[ulTemp].wszServiceType);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszServiceType);

        ASSERT(m_pServiceArray[ulTemp].wszServiceId);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszServiceId);

        ASSERT(m_pServiceArray[ulTemp].wszControlUrl);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszControlUrl);

        ASSERT(m_pServiceArray[ulTemp].wszEventSubUrl);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszEventSubUrl);

        ASSERT(m_pServiceArray[ulTemp].wszScpd);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszScpd);
    }

    ASSERT(0 == m_dwRef);

    if (m_pudd)
    {
        ul = m_pudd->Release();
        TRACE(_T("m_pudd->Release() returned %d\n"), ul);
    }
}

void CDownloadctestDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDownloadctestDlg)
    DDX_Control(pDX, IDC_LIST_SELECTIONPROPERTIES, m_listSelectionProperties);
    DDX_Control(pDX, IDC_DEVICETREE, m_treeDevice);
    DDX_Check(pDX, IDC_CHECK1, m_bSynchronous);
    DDX_Check(pDX, IDC_ABORTIMMEDIATELY, m_bAbortImmediately);
	DDX_CBString(pDX, IDC_COMBOBOXEX1, m_sURL);
	DDV_MaxChars(pDX, m_sURL, 512);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDownloadctestDlg, CDialog)
    //{{AFX_MSG_MAP(CDownloadctestDlg)
    ON_WM_SYSCOMMAND()
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_LOAD, OnLoad)
    ON_BN_CLICKED(IDC_GETROOTDEVICE, OnGetrootdevice)
    ON_NOTIFY(TVN_SELCHANGED, IDC_DEVICETREE, OnSelchangedDevicetree)
	ON_BN_CLICKED(IDC_CREATE_SERVICE_OBJECT, OnCreateServiceObject)
    ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_GETDEVICEBYUDN, OnGetdevicebyudn)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDownloadctestDlg message handlers

HRESULT getConnectionPoint(IUnknown * punk, REFIID riid, IConnectionPoint ** ppCP)
{
    HRESULT hr;
    ULONG ul;
    IConnectionPointContainer * pCPC;

    ASSERT(punk);
    ASSERT(ppCP);

    hr = punk->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
    ASSERT(SUCCEEDED(hr) && pCPC);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pCPC->FindConnectionPoint(riid, ppCP);
    ASSERT(SUCCEEDED(hr) && ppCP);

    ul = pCPC->Release();
    TRACE(_T("pCPC->Release() returned %d\n"), ul);

    return hr;
}

BOOL CDownloadctestDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
//    CPropertyNotifySink * pPNS;
//    IUnknown * punk;
    CListCtrl * plist;
//    HDITEM  hdi;

    HRESULT hr;

    // Add "About..." menu item to system menu.

    // IDM_ABOUTBOX must be in the system command range.
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
    ASSERT(IDM_ABOUTBOX < 0xF000);

    CMenu* pSysMenu = GetSystemMenu(FALSE);
    if (pSysMenu != NULL)
    {
        CString strAboutMenu;
        strAboutMenu.LoadString(IDS_ABOUTBOX);
        if (!strAboutMenu.IsEmpty())
        {
            pSysMenu->AppendMenu(MF_SEPARATOR);
            pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
        }
    }

    // Set the icon for this dialog.  The framework does this automatically
    //  when the application's main window is not a dialog
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon

    // remove items from the tree control
    plist = (CListCtrl*)GetDlgItem(IDC_LIST_SELECTIONPROPERTIES);
    ASSERT(plist);

/*
    hdi.mask = HDI_TEXT | HDI_WIDTH | HDI_FORMAT;
    hdi.cxy = 100; // Make all columns 100 pixels wide.
    hdi.fmt = HDF_STRING;

    hdi.pszText = TEXT("property");
    plist->GetHeaderCtrl()->InsertItem(0, &hdi);

    hdi.pszText = TEXT("value");
    plist->GetHeaderCtrl()->InsertItem(0, &hdi);
*/

    plist->InsertColumn(0, TEXT("property"), LVCFMT_LEFT, 130, 0);

    plist->InsertColumn(1, TEXT("value"), LVCFMT_LEFT, -1, 1);

    VERIFY(plist->SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER));

    hr = CoInitializeEx ( NULL, COINIT_APARTMENTTHREADED );
//    hr = CoInitializeEx ( NULL, COINIT_MULTITHREADED );
    ASSERT(SUCCEEDED(hr));

    {
        // set image list
        CTreeCtrl * ptree;

        ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
        ASSERT(ptree);

        VERIFY(m_imgList.Create(IDB_IMAGELIST, 16, 0, (COLORREF)0x00ff00ff));

        ptree->SetImageList(&m_imgList, TVSIL_NORMAL);
    }

    {
        hr = CoCreateInstance ( CLSID_UPnPDescriptionDocument,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_IUPnPDescriptionDocument,
                                (void**)&m_pudd );
        ASSERT(SUCCEEDED(hr) && m_pudd);
    }

//    m_sURL.LoadString(IDS_STRING_URL);
        //_T("http://rude-3.dsl.speakeasy.net/~foo/description.xml");
    UpdateData(FALSE);

    return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDownloadctestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
    if ((nID & 0xFFF0) == IDM_ABOUTBOX)
    {
        CAboutDlg dlgAbout;
        dlgAbout.DoModal();
    }
    else
    {
        CDialog::OnSysCommand(nID, lParam);
    }
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDownloadctestDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDownloadctestDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}


void CDownloadctestDlg::OnLoad() 
{
    HRESULT hr;
    LPWSTR pstr;
    BSTR bstrUrl;

    ASSERT(m_pudd);

    ClearDeviceTree();
    ClearSelectionProperties();

    UpdateData(TRUE);
    // make m_bSynchronous, m_sURL, etc. valid

    pstr = TCHARtoWCHAR(m_sURL.GetBuffer(0));
    ASSERT(pstr);

    bstrUrl = ::SysAllocString(pstr);
    ASSERT(bstrUrl);

    if (m_bSynchronous)
    {
        hr = m_pudd->Load(bstrUrl);
        if (SUCCEEDED(hr))
        {
            OnGetrootdevice();
        }
    }
    else
    {
        IUnknown * punk;

        punk = dynamic_cast<IUnknown *>(this);
        ASSERT(punk);

        hr = m_pudd->LoadAsync(bstrUrl, punk);
        ASSERT(SUCCEEDED(hr));

        if (m_bAbortImmediately)
        {
            hr = m_pudd->Abort();
            ASSERT(SUCCEEDED(hr));
        }
    }

    ::SysFreeString(bstrUrl);
    delete [] pstr;
}


HRESULT
CDownloadctestDlg::AddServicesToList(HTREEITEM tiParent, IUPnPDevice * pud)
{
    ASSERT(pud);

    IUPnPDevicePrivate * pudf;
    ULONG ulNumServices;
    ULONG ulNumWritten;
    ULONG ulTemp;
    ULONG ulLast;
    HRESULT hr;

    pudf = NULL;
    hr = pud->QueryInterface(IID_IUPnPDevicePrivate, (void**)&pudf);
    ASSERT(SUCCEEDED(hr) && pudf);

    ulNumServices = 0;
    hr = pudf->GetNumServices(&ulNumServices);
    ASSERT(SUCCEEDED(hr) && ulNumServices);

    ulNumWritten = 0;
    hr = pudf->GetServiceInfo(0,
                              ulNumServices,
                              &(m_pServiceArray[m_cServices]),
                              &ulNumWritten);
    ASSERT(SUCCEEDED(hr) && ulNumWritten);

    ulTemp = m_cServices;
    ulLast = ulNumWritten + m_cServices;
    for ( ; ulTemp < ulLast; ++ulTemp )
    {
        AddServiceToTree(ulTemp, tiParent);
    }

    m_cServices += ulNumWritten;

    pudf->Release();

    return hr;
}

HTREEITEM
CDownloadctestDlg::AddServiceToTree(ULONG ulServiceIndex, HTREEITEM tiParent)
{
    ASSERT(m_pServiceArray[ulServiceIndex].wszServiceType);

    CTreeCtrl * ptree;
    HTREEITEM ti;
    LPTSTR pszTemp;

    ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
    ASSERT(ptree);

    pszTemp = NULL;
    pszTemp = WCHARtoTCHAR(m_pServiceArray[ulServiceIndex].wszServiceType);
    ASSERT(pszTemp);

    ti = ptree->InsertItem(TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                           pszTemp,
                           IMAGE_SERVICE,
                           IMAGE_SERVICE_SELECTED,
                           0,
                           0,
                           ulServiceIndex | FLAG_IS_SERVICE,
                           tiParent,
                           TVI_LAST);

    delete [] pszTemp;

    return ti;
}

HTREEITEM
CDownloadctestDlg::AddDeviceToTree(IUPnPDevice * pud, HTREEITEM tiParent)
{
    CTreeCtrl * ptree;
    BSTR bstrTemp;
    LPTSTR pszTemp;
    HRESULT hr;
    HTREEITEM ti;

    ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
    ASSERT(ptree);

    ASSERT(pud);

    bstrTemp = NULL;
    hr = pud->get_FriendlyName(&bstrTemp);
    pszTemp = WCHARtoTCHAR(bstrTemp);
    ASSERT(SUCCEEDED(hr) && bstrTemp && pszTemp);
    TRACE(_T("CDownloadctestDlg::get_FriendlyName(): bstr= %s\n"), pszTemp);

    m_pDeviceArray[m_cDevices] = pud;
    ti = ptree->InsertItem(TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE,
                           pszTemp,
                           IMAGE_DEVICE,
                           IMAGE_DEVICE_SELECTED,
                           0,
                           0,
                           m_cDevices,
                           tiParent,
                           TVI_LAST);
    m_cDevices++;

    ::SysFreeString(bstrTemp);
    delete [] pszTemp;

    return ti;
}

void
CDownloadctestDlg::ClearDeviceTree()
{
    CTreeCtrl * ptree;
    ULONG ulTemp;

    // remove items from the tree control
    ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
    ASSERT(ptree);

    VERIFY(ptree->DeleteAllItems());

    // free all the devices
    TRACE(_T("releasing %d devices\n"), m_cDevices);
    for (ulTemp = 0; ulTemp < m_cDevices; ++ulTemp)
    {
        ULONG ulResult;
        ASSERT(m_pDeviceArray[ulTemp]);
        ulResult = m_pDeviceArray[ulTemp]->Release();
        TRACE(_T("m_pDeviceArray[%d]->Release returned %d\n"), ulTemp, ulResult);

        m_pDeviceArray[ulTemp] = NULL;
    }
    m_cDevices = 0;

    TRACE(_T("freeing %d services\n"), m_cServices);
    for (ulTemp = 0; ulTemp < m_cServices; ++ulTemp)
    {
        ASSERT(m_pServiceArray[ulTemp].wszServiceType);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszServiceType);

        ASSERT(m_pServiceArray[ulTemp].wszServiceId);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszServiceId);

        ASSERT(m_pServiceArray[ulTemp].wszControlUrl);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszControlUrl);

        ASSERT(m_pServiceArray[ulTemp].wszEventSubUrl);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszEventSubUrl);

        ASSERT(m_pServiceArray[ulTemp].wszScpd);
        CoTaskMemFree(m_pServiceArray[ulTemp].wszScpd);
    }
    m_cServices = 0;
}

void
CDownloadctestDlg::ClearSelectionProperties()
{
    CListCtrl * plist;

    // remove items from the tree control
    plist = (CListCtrl*)GetDlgItem(IDC_LIST_SELECTIONPROPERTIES);
    ASSERT(plist);

    VERIFY(plist->DeleteAllItems());

    VERIFY(plist->SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER));

    m_cProps = 0;
}

void
CDownloadctestDlg::AddChildElements(IUPnPDevice * pParent, HTREEITEM tiParent)
{
    ASSERT(pParent);
    ASSERT(tiParent);

    {
        // add the services
        AddServicesToList(tiParent, pParent);
    }

    {
        // add the devices
        HRESULT hr;
        IUnknown * punkEnum;
        IEnumUnknown * peu;
        IUPnPDevices * puds;

        puds = NULL;
        hr = pParent->get_Children(&puds);
        ASSERT(SUCCEEDED(hr) && puds);

        punkEnum = NULL;
        hr = puds->get__NewEnum(&punkEnum);
        ASSERT(SUCCEEDED(hr) && punkEnum);

        peu = NULL;
        hr = punkEnum->QueryInterface(IID_IEnumUnknown, (void**) &peu);
        ASSERT(SUCCEEDED(hr) && peu);

        while (1)
        {
            IUnknown * punkDevice;
            IUPnPDevice * pudChild;

            punkDevice = NULL;
            hr = peu->Next(1, &punkDevice, NULL);
            ASSERT(SUCCEEDED(hr));
            if (S_FALSE == hr)
            {
                ASSERT(NULL == punkDevice);
                break;
            }
            ASSERT(punkDevice);

            pudChild = NULL;
            hr = punkDevice->QueryInterface(IID_IUPnPDevice, (void**) &pudChild);
            ASSERT(SUCCEEDED(hr) && pudChild);

            {
                HTREEITEM tiChild;

                // woohoo! we gots a child!
                tiChild = AddDeviceToTree(pudChild, tiParent);

                AddChildElements(pudChild, tiChild);
            }

            // don't release pudChild, it's in the global device array

            punkDevice->Release();
        }

        punkEnum->Release();
        peu->Release();
        puds->Release();;
    }

    {
        // expand the list
        // todo(cmr): move to separate function?
        CTreeCtrl * ptree;

        ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
        ASSERT(ptree);

        ptree->Expand(tiParent, TVE_EXPAND);
    }
}

void CDownloadctestDlg::OnGetrootdevice()
{
    HTREEITEM tiRoot;
    IUPnPDevice * pudRoot;
    HRESULT hr;

    {
        HRESULT hr2;
        READYSTATE rs;

        hr = m_pudd->get_ReadyState((LONG*)&(rs));
        ASSERT(SUCCEEDED(hr));

        if (rs < READYSTATE_COMPLETE)
        {
            AfxMessageBox(IDS_NOT_DONE);
            return;
        }

        hr2 = S_OK;
        hr = m_pudd->get_LoadResult((LONG*)&hr2);
        ASSERT(SUCCEEDED(hr));
        ASSERT(SUCCEEDED(hr2));
        if (FAILED(hr))
        {
            return;
        }

        if (FAILED(hr2))
        {
            // BUGBUG(darn MFC...) AfxMessageBox(IDS_LOAD_FAILED);
            return;
        }

    }

    ClearDeviceTree();
    ClearSelectionProperties();
    ASSERT(!m_cDevices);
    ASSERT(!m_cServices);

    hr = m_pudd->RootDevice(&pudRoot);
    ASSERT(SUCCEEDED(hr) && pudRoot);

    m_cDevices = 0;
    tiRoot = AddDeviceToTree(pudRoot, NULL);

    AddChildElements(pudRoot, tiRoot);
}


void
CDownloadctestDlg::AddPropertyToList(LPCWSTR pszName, LPCWSTR pszValue)
{
    ASSERT(pszName);

    CListCtrl * plist;
    LPTSTR pszRealValue;
    LPTSTR pszTemp;
    BOOL deleteMe;

    deleteMe = FALSE;

    // remove items from the tree control
    plist = (CListCtrl*)GetDlgItem(IDC_LIST_SELECTIONPROPERTIES);
    ASSERT(plist);

    pszTemp = WCHARtoTCHAR(pszName);
    ASSERT(pszTemp);

    plist->InsertItem(LVIF_TEXT, // | LVIF_DI_SETITEM,
                      m_cProps,
                      pszTemp,
                      0,
                      0,
                      IMAGE_PROPERTY,
                      0);

    if (pszValue)
    {
        if (pszValue[0])
        {
            pszRealValue = WCHARtoTCHAR(pszValue);
        }
        else
        {
            pszRealValue = CopyTCHAR(TEXT("(empty)"));
        }
    }
    else
    {
        pszRealValue = CopyTCHAR(TEXT("(null)"));
    }

    VERIFY(plist->SetItemText(m_cProps, 1, pszRealValue));
    ++m_cProps;

    delete [] pszTemp;
    delete [] pszRealValue;
}


void
CDownloadctestDlg::AutosizeList()
{
    CListCtrl * plist;

    // remove items from the tree control
    plist = (CListCtrl*)GetDlgItem(IDC_LIST_SELECTIONPROPERTIES);
    ASSERT(plist);

    VERIFY(plist->SetColumnWidth(1, LVSCW_AUTOSIZE));
}


void
CDownloadctestDlg::DisplayServiceProperties(ULONG ulIndex)
{
    ASSERT(ulIndex < m_cServices);

    AddPropertyToList(L"Service Type", m_pServiceArray[ulIndex].wszServiceType);
    AddPropertyToList(L"Service Id", m_pServiceArray[ulIndex].wszServiceId);
    AddPropertyToList(L"Control URL", m_pServiceArray[ulIndex].wszControlUrl);
    AddPropertyToList(L"Event Subscription URL", m_pServiceArray[ulIndex].wszEventSubUrl);
    AddPropertyToList(L"SCPD", m_pServiceArray[ulIndex].wszScpd);
}


void
CDownloadctestDlg::DisplayDeviceProperties(IUPnPDevice * pud)
{
    HRESULT hr;
    BSTR bstrTemp;
    VARIANT_BOOL varb;

    ASSERT(pud);

    LPCWSTR pszTrue = L"Yes";
    LPCWSTR pszFalse = L"No";
    LPCWSTR pszError = L"<<error reading value>>";

#define BOOL_TO_STRING(x) (VARIANT_TRUE == x) ? pszTrue : pszFalse

    varb = VARIANT_FALSE;
    hr = pud->get_IsRootDevice(&varb);
    AddPropertyToList(L"Is Root Device", SUCCEEDED(hr) ? BOOL_TO_STRING(varb) : pszError);

    varb = VARIANT_FALSE;
    hr = pud->get_HasChildren(&varb);
    AddPropertyToList(L"Has Chidren", SUCCEEDED(hr) ? BOOL_TO_STRING(varb) : pszError);

    bstrTemp = NULL;
    hr = pud->get_UniqueDeviceName(&bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_UniqueDeviceName(): bstr= %s\n"), bstrTemp);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
    AddPropertyToList(L"UDN", SUCCEEDED(hr) ? bstrTemp : pszError);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_FriendlyName(&bstrTemp);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_FriendlyName(): bstr= %s\n"), bstrTemp);
    AddPropertyToList(L"Friendly Name", SUCCEEDED(hr) ? bstrTemp : pszError);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_Type(&bstrTemp);
    AddPropertyToList(L"Type", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_Type(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_PresentationURL(&bstrTemp);
    AddPropertyToList(L"Presentation URL", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_PresentationURL(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_ManufacturerName(&bstrTemp);
    AddPropertyToList(L"Manufacturer Name", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_ManufacturerName(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_ManufacturerURL(&bstrTemp);
    AddPropertyToList(L"Manufacturer URL", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_ManufacturerURL(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_ModelName(&bstrTemp);
    AddPropertyToList(L"Model Name", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_ModelName(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_ModelNumber(&bstrTemp);
    AddPropertyToList(L"Model Number", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_ModelNumber(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_Description(&bstrTemp);
    AddPropertyToList(L"Description", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_Description(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_ModelURL(&bstrTemp);
    AddPropertyToList(L"Model URL", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_ModelURL(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_UPC(&bstrTemp);
    AddPropertyToList(L"UPC", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_UPC(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    hr = pud->get_SerialNumber(&bstrTemp);
    AddPropertyToList(L"Serial Number", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_SerialNumber(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp);

    bstrTemp = NULL;
    BSTR bstrTemp2 = ::SysAllocString(L"image/png");
    hr = pud->IconURL(bstrTemp2, 32, 32, 24, &bstrTemp);
    AddPropertyToList(L"32x32x24 png Icon Url", SUCCEEDED(hr) ? bstrTemp : pszError);
//    ASSERT(SUCCEEDED(hr) && bstrTemp);
//    TRACE(_T("CDownloadctestDlg::get_SerialNumber(): bstr= %s\n"), bstrTemp);
    ::SysFreeString(bstrTemp2);
    ::SysFreeString(bstrTemp);

}

void CDownloadctestDlg::EnableCSOButton(BOOL fEnable)
{
    CButton * pbutton = (CButton*)GetDlgItem(IDC_CREATE_SERVICE_OBJECT);
    ASSERT(pbutton);

    pbutton->EnableWindow(fEnable);
}

void CDownloadctestDlg::EnableGDBUDNButton(BOOL fEnable)
{
    CButton * pbutton = (CButton*)GetDlgItem(IDC_GETDEVICEBYUDN);
    ASSERT(pbutton);

    pbutton->EnableWindow(fEnable);
}

void CDownloadctestDlg::OnSelchangedDevicetree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;

    ASSERT(pNMTreeView);

    ULONG ulTemp;

    ulTemp = pNMTreeView->itemNew.lParam;

    ClearSelectionProperties();

    if (ulTemp & FLAG_IS_SERVICE)
    {
        ULONG ulSelectedIndex;

        ulSelectedIndex = ulTemp ^ FLAG_IS_SERVICE;

        ASSERT(ulSelectedIndex < m_cServices);

        DisplayServiceProperties(ulSelectedIndex);

        EnableCSOButton(TRUE);

        EnableGDBUDNButton(FALSE);
    }
    else
    {
        IUPnPDevice * pud;
        ULONG ulSelectedIndex;

        ulSelectedIndex = ulTemp;

        pud = m_pDeviceArray[ulSelectedIndex];
        ASSERT(pud);

        DisplayDeviceProperties(pud);
        // don't free, it's in m_pDeviceArray

        EnableCSOButton(FALSE);

        EnableGDBUDNButton(TRUE);
    }

    AutosizeList();

    // note: this is ignored
    *pResult = 0;
}

void CDownloadctestDlg::OnCreateServiceObject() 
{
    if (!m_cServices) return;

    CTreeCtrl * ptree;
    HTREEITEM htiSelectedService;
    HTREEITEM htiParentDevice;
    DWORD dwSelectedIndex;
    LPCWSTR pszDesiredServiceId;

    ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
    ASSERT(ptree);

    // get selection out of tree control
    htiSelectedService = ptree->GetSelectedItem();
    ASSERT(htiSelectedService);

    dwSelectedIndex = ptree->GetItemData(htiSelectedService);

    if (!(dwSelectedIndex & FLAG_IS_SERVICE))
    {
        // we didn't have a service selected
        return;
    }

    // find out what the service type is
    dwSelectedIndex ^= FLAG_IS_SERVICE;
    ASSERT(dwSelectedIndex < m_cServices);

    // dwSelectedIndex references our m_pServiceArray array
    pszDesiredServiceId = m_pServiceArray[dwSelectedIndex].wszServiceId;
    ASSERT(pszDesiredServiceId);

    // now get the parent IUPnPDevice, so that we can get its services
    // collection, and then the service object out of it
    htiParentDevice = ptree->GetParentItem(htiSelectedService);
    ASSERT(htiParentDevice);

    dwSelectedIndex = ptree->GetItemData(htiParentDevice);
    ASSERT(!(dwSelectedIndex & FLAG_IS_SERVICE));
    ASSERT(dwSelectedIndex < m_cDevices);

    // dwSelectedIndex NOW references our m_pDeviceArray array
    {
        // get services collection
        IUPnPServices * puss;
        IUPnPService * pus;
        IUPnPDevice * pud;
        BSTR bstrServiceId;
        ULONG ulResult;
        HRESULT hr;

        pud = m_pDeviceArray[dwSelectedIndex];
        ASSERT(pud);

        puss = NULL;
        hr = pud->get_Services(&puss);
        ASSERT(SUCCEEDED(hr) && puss);

        bstrServiceId = ::SysAllocString(pszDesiredServiceId);

        pus = NULL;
        hr = puss->get_Item(bstrServiceId, &pus);
        ASSERT(SUCCEEDED(hr) && pus);

        // woo hoo!
        // we created a service object!
        // we could do something with it if we wanted, you know!

        ulResult = puss->Release();
        TRACE(_T("puss->Release returned %d\n"), ulResult);

        if (pus)
        {
            ulResult = pus->Release();
            TRACE(_T("pus->Release returned %d\n"), ulResult);
        }

        // don't free pud, it's still just in the device array

        ::SysFreeString(bstrServiceId);
    }
}

void CDownloadctestDlg::OnGetdevicebyudn() 
{
    if (!m_cDevices) return;

    HRESULT hr;
    CTreeCtrl * ptree;
    HTREEITEM htiSelectedDevice;
    DWORD dwSelectedIndex;
    BSTR bstrDesiredUdn;

    ptree = (CTreeCtrl*)GetDlgItem(IDC_DEVICETREE);
    ASSERT(ptree);

    // get selection out of tree control
    htiSelectedDevice = ptree->GetSelectedItem();
    ASSERT(htiSelectedDevice);

    dwSelectedIndex = ptree->GetItemData(htiSelectedDevice);

    if (dwSelectedIndex & FLAG_IS_SERVICE)
    {
        // we didn't have a device selected
        return;
    }

    // dwSelectedIndex references our m_pDeviceArray array
    bstrDesiredUdn = NULL;
    hr = m_pDeviceArray[dwSelectedIndex]->get_UniqueDeviceName(&bstrDesiredUdn);
    ASSERT(SUCCEEDED(hr) && bstrDesiredUdn);

    {
        IUPnPDevice * pud;

        pud = NULL;
        hr = m_pudd->DeviceByUDN(bstrDesiredUdn, &pud);
        ASSERT(SUCCEEDED(hr) && pud);
        if (SUCCEEDED(hr))
        {
            BSTR bstrFound;
            int result;

            bstrFound = NULL;

            hr = pud->get_UniqueDeviceName(&bstrFound);
            ASSERT(SUCCEEDED(hr) && bstrFound);

            result = wcscmp(bstrFound, bstrDesiredUdn);
            ASSERT(result == 0);
            TRACE(_T("looking for UDN=%S, found UDN=%S\n"), bstrDesiredUdn, bstrFound);

            ::SysFreeString(bstrFound);
            pud->Release();
        }
        else
        {
            TRACE(_T("looking for UDN=%S, not found!\n"), bstrDesiredUdn);
        }
    }

    ::SysFreeString(bstrDesiredUdn);
}


STDMETHODIMP
CDownloadctestDlg::QueryInterface(REFIID iid, void ** ppvObject)
{
    TRACE("IUPnPDescriptionDocumentCallback::QueryInterface(), m_dwRef=%d\n", m_dwRef);

    HRESULT hr;
    LPVOID pvResult;

    hr = E_NOINTERFACE;
    pvResult = NULL;

    if (!ppvObject)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if (IsEqualIID(iid, IID_IUPnPDescriptionDocumentCallback))
    {
        hr = S_OK;

        AddRef();

        pvResult = dynamic_cast<IUPnPDescriptionDocumentCallback*>(this);
    }
    else if (IsEqualIID(iid, IID_IUnknown))
    {
        hr = S_OK;

        AddRef();

        pvResult = dynamic_cast<IUnknown *>(this);
    }


    *ppvObject = pvResult;

Cleanup:
    return hr;
}

ULONG
CDownloadctestDlg::AddRef()
{
    TRACE("IUPnPDescriptionDocumentCallback::AddRef(), m_dwRef=%d\n", m_dwRef);
    return ++m_dwRef;
}

ULONG
CDownloadctestDlg::Release()
{
    TRACE("IUPnPDescriptionDocumentCallback::Release(), m_dwRef=%d\n", m_dwRef);

    ASSERT(m_dwRef > 0);
    return --m_dwRef;
}

STDMETHODIMP
CDownloadctestDlg::LoadComplete(HRESULT hrLoadResult)
{
    TRACE("IUPnPDescriptionDocumentCallback::LoadComplete(), hrLoadResult=%x\n", hrLoadResult);

    if (SUCCEEDED(hrLoadResult))
    {
        OnGetrootdevice();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	downloadctest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by downloadctest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_DOWNLOADCTEST_DIALOG        102
#define IDS_STRING_URL                  102
#define IDS_NOT_DONE                    103
#define IDS_LOAD_FAILED                 104
#define IDR_MAINFRAME                   128
#define IDR_MAINFRAME1                  129
#define IDB_BITMAP1                     129
#define IDB_IMAGELIST                   130
#define IDC_EDIT1                       1000
#define IDC_LOAD                        1001
#define IDC_GETROOTDEVICE               1003
#define IDC_CHECK1                      1004
#define IDC_ABORTIMMEDIATELY            1005
#define IDC_DEVICETREE                  1006
#define IDC_LIST_SELECTIONPROPERTIES    1009
#define IDC_COMBOBOXEX1                 1010
#define IDC_CREATE_SERVICE_OBJECT       1012
#define IDC_GETDEVICEBYUDN              1013
#define ID_BUTTON32771                  32771
#define ID_BUTTON32772                  32772

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\downloadctest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F738A366_59ED_11D3_990B_00C04F529B35__INCLUDED_)
#define AFX_STDAFX_H__F738A366_59ED_11D3_990B_00C04F529B35__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#include <upnp.h>               // UPNP includes
//#include "msxml.h"          // XML parser includes
//#include "msxmldid.h"       // XML parser DISPIDs
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F738A366_59ED_11D3_990B_00C04F529B35__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\common\upscmn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P S C M N . C P P 
//
//  Contents:   Common fns for UPnP Folder and Tray code.
//
//  Notes:      
//
//  Author:     jeffspr   7 Dec 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include <upscmn.h>
#include <oleauto.h>

//+---------------------------------------------------------------------------
//
//  Function:   HrSysAllocString
//
//  Purpose:    Simple HR wrapper for HrSysAllocString
//
//  Arguments:
//      pszSource [in]  Source string (WCHAR)
//      pbstrDest [out] Output param -- pointer to BSTR
//
//  Returns:    S_OK on success, E_OUTOFMEMORY if the alloc failed.
//
//  Author:     jeffspr   16 Sep 1999
//
//  Notes:
//
HRESULT HrSysAllocString(LPCWSTR pszSource, BSTR *pbstrDest)
{
    HRESULT hr  = S_OK;

    Assert(pszSource);
    Assert(pbstrDest);

    *pbstrDest = SysAllocString(pszSource);
    if (!*pbstrDest)
    {
        TraceTag(ttidError, "HrSysAllocString failed on %S", pszSource);
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrSysAllocString");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnp\test-clients\samplecppclient\main.cpp ===
#include <objbase.h>
#include <comdef.h>

#include <iostream>
#include <iomanip>

#include <atlbase.h>

#include "UPnP.h"
#include "UPnP_i.c"

using namespace std;

int main(int argc, char *argv[])
{   
    HRESULT hr = S_OK;  

    do {
    
        //
        // Initialize COM.
        //
    
        hr = CoInitialize(NULL);
        
        if (FAILED(hr)) {
            cerr << "Failed to initialize COM: hr == " 
                << hex << hr << endl;
            break;
        }

        //
        // Create the rehydrator.
        //
        IUPnPDeviceFinder *pDeviceFinder;

        hr = CoCreateInstance(
            CLSID_UPnPDeviceFinder, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_IUPnPDeviceFinder, 
            (void **)&pDeviceFinder);
        
        if (FAILED(hr)) {
            cerr << "Failed to create rehydrator: hr == " 
                << hex << hr << endl;
            break;
        }
        
        //
        // Find Devices.
        //

        IDispatch *pTempDispatch;

        hr = pDeviceFinder->FindByType(_bstr_t("upnp:devType:All"), 0, &pTempDispatch);
        
        pDeviceFinder->Release();

        if (FAILED(hr)) {
            cerr << "FindByType() failed: hr == " 
                << hex << hr << endl;
            break;
        }

        IUPnPDevices *pDevices;

        hr = pTempDispatch->QueryInterface(IID_IUPnPDevices, (void **)&pDevices);

        pTempDispatch->Release();

        if (FAILED(hr)) {
            cerr << "Failed to QI()  for IUPnPDevices interface: hr == " 
                << hex << hr << endl;
            break;
        }
        
        //
        // Walk the devices collection and print what we found.
        //

        long lDevCount;

        do {
            hr = pDevices->get_Count(&lDevCount);   
            if (FAILED(hr)) break;

            for (long i = 1; i <= lDevCount; i++) {
                VARIANT var;
                    
                VariantInit(&var);

                hr = pDevices->get_Item(i, &var);
                if (FAILED(hr)) break;

                if (!(V_VT(&var) & VT_DISPATCH)) {
                    cerr << "Collection returned something other than an IDispatch pointer!\n";
                    hr = E_FAIL;
                    break;
                }

                pTempDispatch = V_DISPATCH(&var);
                
                IUPnPDevice *pDevice;

                hr = pTempDispatch->QueryInterface(IID_IUPnPDevice, (void **)&pDevice);

                pTempDispatch->Release();

                if (FAILED(hr)) break;

                do {    
                    BSTR bstrTemp;
                
                    hr = pDevice->get_UniqueDeviceName(&bstrTemp);
                    if (FAILED(hr)) break;  

                    wcout << L"Unique Device Name: " << bstrTemp << endl;

                    hr = pDevice->get_DisplayName(&bstrTemp);
                    if (FAILED(hr)) break;  

                    wcout << L"Display Name: " << bstrTemp << endl;
                    
                    hr = pDevice->get_Location(&bstrTemp);
                    if (FAILED(hr)) break;  
                
                    wcout << L"Location: " << bstrTemp << endl;

                    hr = pDevice->get_Type(&bstrTemp);
                    if (FAILED(hr)) break;  

                    wcout << L"Type: " << bstrTemp << endl;         

                    wcout << L"---------" << endl;
                } while (FALSE);

                pDevice->Release();

                if (FAILED(hr)) {
                    cerr << "Error obtaining one of the device properties: hr == "
                        << hex << hr << endl;
                    break;
                }
            }


        } while (FALSE);

        if (FAILED(hr)) {
            cerr << "Error enumerating devices: hr == "
                << hex << hr << endl;
        }

        pDevices->Release();

    } while (FALSE);

    //
    // Uninitialize COM.
    //
    CoUninitialize();

    return (FAILED(hr) ? -1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\dlldatax.h ===
#pragma once

#ifdef _MERGE_PROXYSTUB

extern "C"
{

BOOL
WINAPI
PrxDllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved);

STDAPI
PrxDllCanUnloadNow ();

STDAPI
PrxDllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv);

STDAPI
PrxDllRegisterServer ();

STDAPI
PrxDllUnregisterServer ();

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\common\windutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       W I N D U T I L . C P P
//
//  Contents:   Window utilities -- For now, just CenterWindow
//
//  Notes:
//
//  Author:     jeffspr   22 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop



//+---------------------------------------------------------------------------
//
//  Function:   FCenterWindow
//
//  Purpose:    Center a child window on the parent
//
//  Arguments:
//      hwndChild  [in]     Child window handle
//      hwndParent [in]     Parent window handle (or NULL for desktop)
//
//  Returns:
//
//  Author:     jeffspr   22 May 1998
//
//  Notes:
//
BOOL FCenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc = NULL;
    BOOL    fReturn = TRUE;

    AssertSz(hwndChild, "Bad Child Window param to CenterWindow");

    // Get the Height and Width of the child window
    //
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    //
    if (NULL == hwndParent)
    {
        GetWindowRect (GetDesktopWindow(), &rParent);
    }
    else
    {
        GetWindowRect (hwndParent, &rParent);
    }

    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    //
    hdc = GetDC (hwndChild);
    if (hdc)
    {
        wScreen = GetDeviceCaps (hdc, HORZRES);
        hScreen = GetDeviceCaps (hdc, VERTRES);
        ReleaseDC (hwndChild, hdc);

        // Calculate new X position, then adjust for screen
        //
        xNew = rParent.left + ((wParent - wChild) / 2);
        if (xNew < 0)
        {
            xNew = 0;
        }
        else if ((xNew + wChild) > wScreen)
        {
            xNew = wScreen - wChild;
        }

        // Calculate new Y position, then adjust for screen
        //
        yNew = rParent.top + ((hParent - hChild) / 2);
        if (yNew < 0)
        {
            yNew = 0;
        }
        else if ((yNew + hChild) > hScreen)
        {
            yNew = hScreen - hChild;
        }

        // Set it, and return
        //
        fReturn = SetWindowPos (hwndChild, NULL,
                             xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
    }
    else
    {
        fReturn = FALSE;
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\clistndn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C L I S T N D N. H
//
//  Contents:   Version of CList for NewDeviceNodes.
//
//  Notes:
//
//  Author:     donryan   21 Feb 2000
//
//----------------------------------------------------------------------------

#ifndef _CLISTNDN_H_
#define _CLISTNDN_H_

#include <clist.h>
#include <tfind.h>

#pragma once


class CListString : public CList< LPTSTR, LPCTSTR >
{
protected:
    virtual BOOL FCompare(LPTSTR pszCurrentNodeString, LPCTSTR pszKey);
};

class CListNameMap : public CList< NAME_MAP *, LPCTSTR >
{
protected:
    virtual BOOL FCompare(NAME_MAP *, LPCTSTR szUdn);
};

class CListNDN : public CList< NewDeviceNode *, LPCTSTR >
{
protected:
    virtual BOOL FCompare(NewDeviceNode * pFirst, LPCTSTR pszUDN);
};

class CListFolderDeviceNode : public CList< FolderDeviceNode *, PCWSTR >
{
protected:
    virtual BOOL FCompare(FolderDeviceNode * pFirst, PCWSTR pszUDN);
};

#endif // _CLISTNDN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\cmdtable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M D T A B L E . C P P
//
//  Contents:   Command-table code -- determines which menu options are
//              available by the selection count, among other criteria
//
//  Notes:
//
//  Author:     jeffspr   28 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "upsres.h"     // Folder resource IDs
#include "cmdtable.h"   // Header for this file


// Enable this if we have checked items
//
// #define CHECKED_ITEMS_PRESENT    1

//---[ Prototypes ]-----------------------------------------------------------

VOID DoMenuItemExceptionLoop(
    LPCITEMIDLIST * apidlSelected,
    DWORD           cPidl);

VOID DoMenuItemCheckLoop(VOID);


COMMANDTABLEENTRY   g_cteFolderCommands[] =
{
    // command id
    //    |                           valid when 0 items selected
    //    |                             |
    //    |                             |       valid when multiple items selected
    //    |                             |        |       command is currently enabled
    //    |                             |        |        |      new state (temp)
    //    |                             |        |        |       |
    //    |                             |        |        |       |
    //    |                             |        |        |       |
    //    |                             |        |        |       |
    //    v                             v        v        v       v
    //
    { CMIDM_CREATE_SHORTCUT,            false,  false,  true,   true     },
    { SFVIDM_FILE_LINK,                 false,  false,  true,   true     },
    { CMIDM_DELETE,                     false,  false,  false,  true     },
    { SFVIDM_FILE_DELETE,               false,  false,  false,  true     },
    { CMIDM_RENAME,                     false,  false,  true,   true     },
    { SFVIDM_FILE_RENAME,               false,  false,  true,   true     },
    { CMIDM_PROPERTIES,                 false,  false,  true,   true     },
    { SFVIDM_FILE_PROPERTIES,           false,  false,  true,   true     },
    { CMIDM_ARRANGE_BY_NAME,            true,   true,   true,   true     },
    { CMIDM_ARRANGE_BY_URL,             true,   true,   true,   true     },
    { CMIDM_INVOKE,                     false,  false,  true,   true     }
};

const DWORD g_nFolderCommandCount = celems(g_cteFolderCommands);

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableOrDisableMenuItems
//
//  Purpose:    Enable, disable, and or check/uncheck menu items depending
//              on the current selection count, as well as exceptions for
//              the type and state of the connections themselves
//
//  Arguments:
//      hwnd            [in]   Our window handle
//      apidlSelected   [in]   Currently selected objects
//      cPidl           [in]   Number selected
//      hmenu           [in]   Our command menu handle
//      idCmdFirst      [in]   First valid command
//
//  Returns:
//
//  Author:     jeffspr   2 Feb 1998
//
//  Notes:
//
HRESULT HrEnableOrDisableMenuItems(
    HWND            hwnd,
    LPCITEMIDLIST * apidlSelected,
    DWORD           cPidl,
    HMENU           hmenu,
    UINT            idCmdFirst)
{
    HRESULT hr      = S_OK;
    DWORD   dwLoop  = 0;

    // Loop through, and set the new state, based on the selection
    // count compared to the flags for 0-select and multi-select
    //
    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        // If nothing is selected, then check the current state, and
        // if different, adjust
        //
        if (cPidl == 0)
        {
            g_cteFolderCommands[dwLoop].fNewState =
                g_cteFolderCommands[dwLoop].fValidOnZero;
        }
        else
        {
            // If singly-selected, then by default, we're always on.
            //
            if (cPidl == 1)
            {
                g_cteFolderCommands[dwLoop].fNewState =
                    g_cteFolderCommands[dwLoop].fValidOnSingle;
            }
            else
            {
                // Multi-selected
                //
                g_cteFolderCommands[dwLoop].fNewState =
                    g_cteFolderCommands[dwLoop].fValidOnMultiple;
            }
        }
    }

    for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        DWORD dwCommandId = 0;

        switch(g_cteFolderCommands[dwLoop].iCommandId)
        {
            case SFVIDM_FILE_DELETE:
            case SFVIDM_FILE_RENAME:
            case SFVIDM_FILE_LINK:
            case SFVIDM_FILE_PROPERTIES:
                dwCommandId = g_cteFolderCommands[dwLoop].iCommandId;
                break;
            default:
                dwCommandId = g_cteFolderCommands[dwLoop].iCommandId +
                    idCmdFirst - CMIDM_FIRST;
                break;
        }

        // Enable or disable the menu item, as appopriate
        //
        EnableMenuItem(hmenu, dwCommandId,
                       g_cteFolderCommands[dwLoop].fNewState ?
                       MF_ENABLED | MF_BYCOMMAND :     // enable
                       MF_GRAYED | MF_BYCOMMAND);      // disable
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrEnableOrDisableMenuItems");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoMenuItemExceptionLoop
//
//  Purpose:    Check for various menu item exceptions.
//
//  Arguments:
//      apidlSelected   [in]   Selected items
//      cPidl           [in]   Count of selected items
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
VOID DoMenuItemExceptionLoop(
    LPCITEMIDLIST * apidlSelected,
    DWORD           cPidl)
{
    DWORD   dwLoop               = 0;
    DWORD   dwObjectLoop         = 0;
    bool    fEnableDelete        = false;   // For now, this is ALWAYS disabled (jeffspr)
    bool    fEnableRename        = true;

    if (cPidl)
    {
        // Loop through each of the selected objects
        //
        for (dwObjectLoop = 0; dwObjectLoop < cPidl; dwObjectLoop++)
        {
            // Validate the pidls
            //
            PUPNPDEVICEFOLDPIDL pudfp   = NULL;

            if (!(apidlSelected[dwObjectLoop]) ||
                ILIsEmpty(apidlSelected[dwObjectLoop]))
            {
                AssertSz(FALSE, "Bogus pidl array in DoMenuItemExceptionLoop (status)");
            }
            else
            {
                pudfp = ConvertToUPnPDevicePIDL(apidlSelected[dwObjectLoop]);
            }

            if (pudfp)
            {
                // Loop through the commands
                //
                for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
                {
                    // Only allow items to be changed to ENABLED states when they're
                    // previously DISABLED
                    //
                    if (g_cteFolderCommands[dwLoop].fNewState)
                    {
                    }
                }
            }
        }

        // Loop through the commands, and disable the commands, if appropriate
        //
        for (dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
        {
            switch(g_cteFolderCommands[dwLoop].iCommandId)
            {
                case CMIDM_DELETE:
                case SFVIDM_FILE_DELETE:
                    g_cteFolderCommands[dwLoop].fNewState = fEnableDelete;
                    break;
                case CMIDM_RENAME:
                case SFVIDM_FILE_RENAME:
                    g_cteFolderCommands[dwLoop].fNewState = fEnableRename;
                    break;
                default:
                    break;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\cmdtable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C M D T A B L E . H
//
//  Contents:   Command-table code -- determines which menu options are
//              available by the selection count, among other criteria
//
//  Notes:
//
//  Author:     jeffspr   28 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _CMDTABLE_H_
#define _CMDTABLE_H_

struct CommandTableEntry
{
    int     iCommandId;         // Associated command ID
    bool    fValidOnZero;       // Is this option valid when 0 items selected?
    bool    fValidOnMultiple;   // Is this option valid with > 1 selected?
    bool    fValidOnSingle;     // Is this option valid with == 1 selected?
    bool    fNewState;          // What's the new state? (work variable)
};

typedef CommandTableEntry   COMMANDTABLEENTRY;
typedef CommandTableEntry * PCOMMANDTABLEENTRY;

extern COMMANDTABLEENTRY    g_cteFolderCommands[];
extern const DWORD          g_nFolderCommandCount;

struct CommandCheckEntry
{
    int  iCommandId;        // Associated command ID
    bool fCurrentlyChecked; // Is this menu item already checked?
    bool fNewCheckState;    // What's the new check state?
};

typedef CommandCheckEntry   COMMANDCHECKENTRY;
typedef CommandCheckEntry * PCOMMANDCHECKENTRY;

extern COMMANDCHECKENTRY    g_cceFolderCommands[];
extern const DWORD          g_nFolderCommandCheckCount;

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrEnableOrDisableMenuItems(
    HWND            hwnd,
    LPCITEMIDLIST * apidlSelected,
    DWORD           cPidl,
    HMENU           hmenu,
    UINT            idCmdFirst);

#endif  // _CMDTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\icomtarg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O M T A R G . C P P
//
//  Contents:   ICommandTarget implementation for IUPnPTray
//
//  Notes:
//
//  Author:     jeffspr   20 Jan 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "tfind.h"      // for tray init functions, etc.
#include "upnptray.h"

extern CONST TCHAR c_szMainWindowClassName[];

HRESULT CUPnPTray::QueryStatus(
    const GUID *    pguidCmdGroup,
    ULONG           cCmds,
    OLECMD          prgCmds[],
    OLECMDTEXT *    pCmdText)
{
    HRESULT hr  = E_NOTIMPL;

    TraceTag(ttidShellFolderIface, "OBJ: CCT - IOleCommandTarget::QueryStatus");

    TraceHr(ttidError, FAL, hr, (hr == E_NOTIMPL), "CUPnPTray::QueryStatus");
    return hr;
}

HRESULT CUPnPTray::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdexecopt,
    VARIANTARG *    pvaIn,
    VARIANTARG *    pvaOut)
{
    HRESULT hr  = S_OK;

    TraceTag(ttidShellFolderIface, "OBJ: CCT - IOleCommandTarget::Exec");

    if (IsEqualGUID(*pguidCmdGroup, CGID_ShellServiceObject))
    {
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
            case SSOCMDID_OPEN:
                TraceTag(ttidShellFolder, "The Net Connections Tray is being initialized");
                hr = HrHandleTrayOpen();
                break;

            case SSOCMDID_CLOSE:
                TraceTag(ttidShellFolder, "The Net Connections Tray is being destroyed");
                hr = HrHandleTrayClose();
                break;

            default:
                hr = S_OK;
                break;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPTray::Exec");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPTray::HrHandleTrayOpen
//
//  Purpose:    Handler for the Net Connections Tray object ::Exec call
//              SSOCMDID_OPEN command
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Jan 1998
//
//  Notes:
//
HRESULT CUPnPTray::HrHandleTrayOpen()
{
    HRESULT hr          = S_OK;

    m_hwnd = StartUPnPTray();
    if (!m_hwnd)
    {
        TraceError("CUPnPTray::HrHandleTrayOpen - could not create tray "
                   "window", hr);
        hr = E_FAIL;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPTray::HrHandleTrayOpen()");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPTray::HrHandleTrayClose
//
//  Purpose:    Handler for the Net Connections Tray object ::Exec call
//              SSOCMDID_CLOSE command
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Jan 1998
//
//  Notes:
//
HRESULT CUPnPTray::HrHandleTrayClose()
{
    HRESULT hr  = S_OK;

    UnregisterClass (c_szMainWindowClassName,
                     _Module.GetResourceInstance());

    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPTray::HrHandleTrayClose()");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\dllmain.cpp ===
#include "pch.h"
#pragma hdrstop

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "ncatl.h"

#include "nsbase.h"
#include "upnpshell.h"
#include "upnpfold.h"

// Connection Folder Objects
//
// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>
#include <shlobjp.h>

#define INITGUID
#include "upclsid.h"

//+---------------------------------------------------------------------------
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for foo.idl by adding the following
//      files to the Outputs.
//          foo_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f foops.mk in the project directory.

// Proxy/Stub registration entry points
//
#include "dlldatax.h"
#include "upnptray.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)

    // Connection Folder and enumerator
    //
    OBJECT_ENTRY(CLSID_UPnPDeviceFolder,        CUPnPDeviceFolder)
    OBJECT_ENTRY(CLSID_UPnPMonitor,             CUPnPTray)

END_OBJECT_MAP()

//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
//#ifdef _MERGE_PROXYSTUB
//    if (!PrxDllMain(hInstance, dwReason, lpReserved))
//    {
//        return FALSE;
//    }
//#endif

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        InitializeDebugging();

        if (FIsDebugFlagSet (dfidNetShellBreakOnInit))
        {
            DebugBreak();
        }

        _Module.Init(ObjectMap, hInstance);

        InitializeCriticalSection(&g_csFolderDeviceList);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DbgCheckPrematureDllUnload ("netshell.dll", _Module.GetLockCount());

        DeleteCriticalSection(&g_csFolderDeviceList);

        _Module.Term();

        UnInitializeDebugging();
    }
    return TRUE;
}

//+---------------------------------------------------------------------------
// Used to determine whether the DLL can be unloaded by OLE
//
STDAPI
DllCanUnloadNow ()
{
//#ifdef _MERGE_PROXYSTUB
//    if (PrxDllCanUnloadNow() != S_OK)
//    {
//        return S_FALSE;
//    }
//#endif

    return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
// Returns a class factory to create an object of the requested type
//
STDAPI
DllGetClassObject (
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID*     ppv)
{
//#ifdef _MERGE_PROXYSTUB
//    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
//    {
//        return S_OK;
//    }
//#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

//+---------------------------------------------------------------------------
// DllRegisterServer - Adds entries to the system registry
//
STDAPI
DllRegisterServer ()
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
//#ifdef _MERGE_PROXYSTUB
//        hr = PrxDllRegisterServer ();
//        if (FAILED(hr))
//        {
//            goto Exit;
//        }
//#endif

        hr = NcAtlModuleRegisterServer (&_Module);
        if (SUCCEEDED(hr))
        {
            hr = HrRegisterFolderClass();
            if (SUCCEEDED(hr))
            {
                // Notify the shell to reload the new shell extension
                SHEnableServiceObject(CLSID_UPnPMonitor, TRUE);
            }
        }

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "upnpfold!DllRegisterServer");
    return hr;
}

//+---------------------------------------------------------------------------
// DllUnregisterServer - Removes entries from the system registry
//
STDAPI
DllUnregisterServer ()
{
//#ifdef _MERGE_PROXYSTUB
//    PrxDllUnregisterServer ();
//#endif
CONST WCHAR c_szNetworkNeighborhoodFolderPathCLSID[]   = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}";

    _Module.UnregisterServer ();
    HrUnRegisterDelegateFolderKey();
    HrUnRegisterUPnPUIKey();
    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATHW, c_szNetworkNeighborhoodFolderPathCLSID, NULL);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\icomtargf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       I C O M T A R G F . C P P
//
//  Contents:   ICommandTarget implementation for IConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   12 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::QueryStatus
//
//  Purpose:    [IOleCommandTarget] Queries the object for the status of one
//              or more commands generated by user interface events.
//
//              This interface is required but is currently unimplemented
//
//  Arguments:
//      pguidCmdGroup [in]      // Pointer to command group
//      cCmds         [in]      // Number of commands in prgCmds array
//      prgCmds       [in,out]  // Array of commands
//      pCmdText      [in,out]  // Pointer to name or status of command
//
//  Returns:
//
//  Author:     jeffspr   12 Aug 1999
//
//  Notes:
//
HRESULT CUPnPDeviceFolder::QueryStatus(
    const GUID *    pguidCmdGroup,
    ULONG           cCmds,
    OLECMD          prgCmds[],
    OLECMDTEXT *    pCmdText)
{
    HRESULT hr  = E_NOTIMPL;

    TraceHr(ttidError, FAL, hr, (hr == E_NOTIMPL), "CUPnPDeviceFolder::QueryStatus");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::Exec
//
//  Purpose:    [IOleCommandTarget] Executes a specified command or displays
//              help for a command.
//
//              This method is not currently referenced, but if the shell
//              wanted to enumerate only incoming our outgoing connections,
//              it would use the CFCID_SETENUMTYPE command to force the
//              issue (that is unimplemented on our side, however)
//
//  Arguments:
//      pguidCmdGroup [in]      // Pointer to command group
//      nCmdID        [in]      // Identifier of command to execute
//      nCmdexecopt   [in]      // Options for executing the command
//      pvaIn         [in]      // Pointer to input arguments
//      pvaOut        [in,out]  // Pointer to command output
//
//  Returns:
//
//  Author:     jeffspr   12 Aug 1999
//
//  Notes:
//
HRESULT CUPnPDeviceFolder::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdexecopt,
    VARIANTARG *    pvaIn,
    VARIANTARG *    pvaOut)
{
    HRESULT hr  = NOERROR;

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolder::Exec");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\foldreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D R E G . C P P
//
//  Contents:   Register the folder class
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

extern const WCHAR c_szUPnPUIDll[];
extern const TCHAR c_sztUPnPUIDll[];

//---[ Constants ]------------------------------------------------------------

static const TCHAR  c_szShellFolderAttributeVal[]   =   TEXT("Attributes");

static const TCHAR  c_szShellFolderKey[]        =
        TEXT("CLSID\\{e57ce731-33e8-4c51-8354-bb4de9d215d1}\\ShellFolder");

static const TCHAR c_szDelegateFolderKey[] = 
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NetworkNeighborhood\\NameSpace\\DelegateFolders"); 

static const TCHAR c_szDelegateCLSID[] = 
        TEXT("{e57ce731-33e8-4c51-8354-bb4de9d215d1}");

static const TCHAR c_szCLSID[] =
        TEXT("CLSID");



//---[ Constant globals ]-----------------------------------------------------
//
const WCHAR c_szUPnPUIDll[]   = L"upnpui.dll";
const TCHAR c_sztUPnPUIDll[]  = TEXT("upnpui.dll");


//+---------------------------------------------------------------------------
//
//  Function:   HrRegisterFolderClass
//
//  Purpose:    Fix the registry values for the Shell entries under HKCR,
//              CLSID\{CLSID}. The code generated from the RGS script doesn't
//              support our replaceable params by default, so we'll fix
//              it up after the fact.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   23 Sep 1997
//
//  Notes:
//
HRESULT HrRegisterFolderClass()
{
    HRESULT hr      = S_OK;
    LONG    lResult = 0;

    TCHAR szRegValue[MAX_PATH+1];
    TCHAR szWinDir[MAX_PATH+1];

    // Adjust the AppID for Local Server or Service
    CRegKey keyShellFolder;

    if (GetWindowsDirectory(szWinDir, MAX_PATH+1))
    {
        lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szShellFolderKey);
        if (lResult == ERROR_SUCCESS)
        {
            DWORD dwFlags   = SFGAO_FOLDER;

            hr = RegSetValueEx(keyShellFolder,
                    c_szShellFolderAttributeVal,
                    0,
                    REG_BINARY,
                    (LPBYTE) &dwFlags,
                    sizeof (dwFlags));

            keyShellFolder.Close();
        }
        else
        {
            // Translate LRESULT to HR
            //
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else    // GetWindowsDirectory failed
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}

HRESULT HrUnRegisterUPnPUIKey() {
    HRESULT hr      = S_OK;
    LONG    lResult = 0;

    TCHAR szWinDir[MAX_PATH+1];

    // Adjust the AppID for Local Server or Service
    CRegKey keyShellFolder;

    if (GetWindowsDirectory(szWinDir, MAX_PATH+1))
    {
        lResult = keyShellFolder.Open(HKEY_CLASSES_ROOT, c_szCLSID);
        if (lResult == ERROR_SUCCESS)
        {
            lResult = keyShellFolder.RecurseDeleteKey(c_szDelegateCLSID);
            if(lResult != ERROR_SUCCESS)
                hr = HRESULT_FROM_WIN32(lResult);
            
            keyShellFolder.Close();
        }
        else
        {
            // Translate LRESULT to HR
            //
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else    // GetWindowsDirectory failed
    {
        hr = HrFromLastWin32Error();
    }


    return hr;
}

HRESULT HrUnRegisterDelegateFolderKey()
{
    HRESULT hr      = S_OK;
    LONG    lResult = 0;

    TCHAR szWinDir[MAX_PATH+1];

    // Adjust the AppID for Local Server or Service
    CRegKey keyShellFolder;

    if (GetWindowsDirectory(szWinDir, MAX_PATH+1))
    {
        lResult = keyShellFolder.Open(HKEY_LOCAL_MACHINE, c_szDelegateFolderKey);
        if (lResult == ERROR_SUCCESS)
        {

            hr = keyShellFolder.DeleteSubKey(c_szDelegateCLSID);

            keyShellFolder.Close();
        }
        else
        {
            // Translate LRESULT to HR
            //
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else    // GetWindowsDirectory failed
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\idelegate.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I D E L E G A T E . C P P
//
//  Contents:   IDelegateFolder implementation fopr CUPnPDeviceFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::SetItemAlloc
//
//  Purpose:    IDelegateFolder::SetItemAlloc implementation for
//              CUPnPDeviceFolder
//
//  Arguments:
//      pmalloc [in]    Our new allocator for creating delegate items
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::SetItemAlloc(
        IMalloc *pMalloc)
{
    if (m_pDelegateMalloc) m_pDelegateMalloc->Release();
    if (pMalloc)
    {
        m_cbDelegate = FIELD_OFFSET(DELEGATEITEMID, rgb);
    }
    else  /* Not delegating, use regular malloc */
    {
        m_cbDelegate = 0;
        pMalloc = m_pMalloc;
    }

    m_pDelegateMalloc = pMalloc;
    m_pDelegateMalloc->AddRef();
    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\icontextm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I C O N T E X T M . C P P
//
//  Contents:   IContextMenu implementation for CUPnPDeviceFolderExtractIcon
//
//  Notes:
//
//  Author:     jeffspr   24 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "upsres.h"
#include "oncommand.h"
#include "cmdtable.h"

struct ContextMenuEntry
{
    INT                 iMenu;
    INT                 iVerbMenu;
    INT                 iDefaultCmd;
};

static const ContextMenuEntry   c_CMEArray[] =
{
  // standard (no menu deviances yet)
    { MENU_STANDARD,    MENU_STANDARD_V,    CMIDM_INVOKE },
};

const DWORD g_dwContextMenuEntryCount = celems(c_CMEArray);

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderContextMenu::CreateInstance
//
//  Purpose:    Create an instance of the CUPnPDeviceFolderContextMenu object
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CUPnPDeviceFolderContextMenu::CreateInstance(
    REFIID          riid,
    void**          ppv,
    CMENU_TYPE      cmt,
    HWND            hwndOwner,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    LPSHELLFOLDER   psf)
{
    HRESULT hr = E_OUTOFMEMORY;

    CUPnPDeviceFolderContextMenu * pObj    = NULL;

    TraceTag(ttidShellFolderIface, "OBJ: CCFCM - IContextMenu::CreateInstance");

    pObj = new CComObject <CUPnPDeviceFolderContextMenu>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->HrInitialize(cmt, hwndOwner, cidl, apidl, psf);
            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderContextMenu::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderContextMenu::CUPnPDeviceFolderContextMenu
//
//  Purpose:    Constructor for CUPnPDeviceFolderContextMenu. Initialize
//              data members
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
CUPnPDeviceFolderContextMenu::CUPnPDeviceFolderContextMenu()
{
    m_psf           = NULL;
    m_cidl          = 0;
    m_apidl         = NULL;
    m_hwndOwner     = NULL;
    m_cmt           = CMT_OBJECT;   // arbitrary. Just make sure it's something
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderContextMenu::HrInitialize
//
//  Purpose:    Initialization for the context menu object. Make copies of
//              the pidl array, etc.
//
//  Arguments:
//      hwndOwner [in]  Our parent hwnd
//      cidl      [in]  Count of objects
//      apidl     [in]  Pidl array of selected items
//      psf       [in]  Our shell folder pointer
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CUPnPDeviceFolderContextMenu::HrInitialize(
    CMENU_TYPE      cmt,
    HWND            hwndOwner,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    LPSHELLFOLDER   psf)
{
    HRESULT hr  = NOERROR;

    // Grab and addref the folder object
    //
    Assert(psf);
    psf->AddRef();
    m_psf = static_cast<CUPnPDeviceFolder *>(psf);

    // Copy the context menu type (object -vs- background)
    //
    m_cmt = cmt;

    // Note: This will be NULL if the context menu is invoked from the desktop
    //
    m_hwndOwner = hwndOwner;

    if (cidl)
    {
        Assert(CMT_OBJECT == cmt);

        // Clone the pidl array
        //
        hr = HrCloneRgIDL(apidl, cidl, &m_apidl, &m_cidl);
        if (FAILED(hr))
        {
            TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL failed on apidl in "
                    "CUPnPDeviceFolderContextMenu::HrInitialize");
        }
    }
    else
    {
        Assert(CMT_BACKGROUND == cmt);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderContextMenu::HrInitialize");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderContextMenu::~CUPnPDeviceFolderContextMenu
//
//  Purpose:    Destructor. Free the pidl array and release the shell folder
//              object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
CUPnPDeviceFolderContextMenu::~CUPnPDeviceFolderContextMenu()
{
    if (m_apidl)
    {
        FreeRgIDL(m_cidl, m_apidl);
        m_apidl = NULL;
        m_cidl = 0;
    }

    if (m_psf)
    {
        ReleaseObj(reinterpret_cast<LPSHELLFOLDER>(m_psf));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderContextMenu::QueryContextMenu
//
//  Purpose:    Adds menu items to the specified menu. The menu items should
//              be inserted in the menu at the position specified by
//              indexMenu, and their menu item identifiers must be between
//              the idCmdFirst and idCmdLast parameter values.
//
//  Arguments:
//      hmenu      [in] Handle to the menu. The handler should specify this
//                      handle when adding menu items
//      indexMenu  [in] Zero-based position at which to insert the first
//                      menu item.
//      idCmdFirst [in] Min value the handler can specify for a menu item
//      idCmdLast  [in] Max value the handler can specify for a menu item
//      uFlags     [in] Optional flags specifying how the context menu
//                      can be changed. See MSDN for the full list.
//
//  Returns:
//
//  Author:     jeffspr   7 Aug 1998
//
//  Notes:
//
HRESULT CUPnPDeviceFolderContextMenu::QueryContextMenu(
    HMENU   hmenu,
    UINT    indexMenu,
    UINT    idCmdFirst,
    UINT    idCmdLast,
    UINT    uFlags)
{
    HRESULT         hr                  = NOERROR;
    QCMINFO         qcm                 = {hmenu, indexMenu, idCmdFirst, idCmdLast};
    INT             iDefaultCmd         = 0;
    BOOL            fValidMenu          = FALSE;
    BOOL            fVerbsOnly          = !!(uFlags & CMF_VERBSONLY);
    INT             iMenuResourceId     = 0;
    INT             iPopupResourceId    = 0;

    TraceTag(ttidShellFolderIface, "OBJ: CCFCM - IContextMenu::QueryContextMenu");

    if (!(uFlags & CMF_DVFILE))
    {
        if (CMT_OBJECT == m_cmt)
        {
            PUPNPDEVICEFOLDPIDL    pudfp = NULL;

            if (FIsUPnPDeviceFoldPidl(m_apidl[0]))
            {
                pudfp = ConvertToUPnPDevicePIDL(m_apidl[0]);
            }

            if(pudfp)
            {
                DWORD           dwLoop  = 0;

                for (dwLoop = 0; (dwLoop < g_dwContextMenuEntryCount) && !fValidMenu; dwLoop++)
                {

                    // Leave dwLoop alone, since this is how we pick the menu below
                    fValidMenu = TRUE;

                    if (fValidMenu)
                    {
                        iPopupResourceId = 0;
                        if (fVerbsOnly)
                        {
                            iMenuResourceId = c_CMEArray[dwLoop].iVerbMenu;
                        }
                        else
                        {
                            iMenuResourceId = c_CMEArray[dwLoop].iMenu;
                        }

                        iDefaultCmd = c_CMEArray[dwLoop].iDefaultCmd;
                    }
                }
            }
        }
        else
        {
            if (CMT_BACKGROUND == m_cmt)
            {
                AssertSz(m_hwndOwner, "Background context menu requires a valid HWND");
                if (m_cidl > 0)
                {
                    AssertSz(FALSE, "We shouldn't be getting this interface if connections are selected");
                }
                else
                {
                    fValidMenu = TRUE;
                    iMenuResourceId = MENU_MERGE_FOLDER_BACKGROUND;
                    iPopupResourceId = POPUP_MERGE_FOLDER_BACKGROUND;
                }
            }
            else
            {
                AssertSz(FALSE, "Don't support context menus for this CMENU_TYPE. Not background or object?");
            }
        }

        // If we have a valid menu to give to the user, then do the merge,
        // enable or disable as appropriate, and set the appropriate HR to
        // specify the number of items added.
        //
        if (fValidMenu)
        {
            MergeMenu(_Module.GetResourceInstance(),
                        iMenuResourceId,
                        iPopupResourceId,
                        (LPQCMINFO)&qcm);

            // Enable/Disable the menu items as appropriate. Ignore the return from this
            // as we're getting it for debugging purposes only.
            //
            hr = HrEnableOrDisableMenuItems(
                m_hwndOwner,
                (LPCITEMIDLIST *) m_apidl,
                m_cidl,
                hmenu,
                idCmdFirst);

            if (CMT_OBJECT == m_cmt)
            {
                // $$REVIEW: Find out why I'm only doing this for CMT_OBJECT instead of for background.
                // Pre-icomtextm|mb combine, mb had this commented out.
                //
                SetMenuDefaultItem(hmenu, idCmdFirst + iDefaultCmd, FALSE);
            }

            hr = ResultFromShort(qcm.idCmdFirst - idCmdFirst);
        }
    }

    // Ignore this trace if it's a short, basically.
    //
    TraceHr(ttidError, FAL, hr, SUCCEEDED(hr), "CUPnPDeviceFolderContextMenu::QueryContextMenu");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderContextMenu::InvokeCommand
//
//  Purpose:    Carries out the command associated with a context menu item.
//
//  Arguments:
//      lpici [in]  Address of a CMINVOKECOMMANDINFO structure containing
//                  information about the command.
//
//  Returns:        Returns NOERROR if successful, or an OLE-defined
//                  error code otherwise.
//
//  Author:     jeffspr   27 Apr 1999
//
//  Notes:
//
HRESULT CUPnPDeviceFolderContextMenu::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    HRESULT             hr      = NOERROR;
    UINT                uiCmd   = 0;

    TraceTag(ttidShellFolderIface, "OBJ: CCFCM - IContextMenu::InvokeCommand");

    Assert(lpici);
    Assert(lpici->lpVerb);

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        // Only folder objects currently support string-based invoke commands.
        // (The background does not)
        //
        if (CMT_OBJECT == m_cmt)
        {
            if (0 == lstrcmpA(pszCmd, "delete"))
            {
                uiCmd = CMIDM_DELETE;
            }
            else if (0 == lstrcmpA(pszCmd, "properties"))
            {
                uiCmd = CMIDM_PROPERTIES;
            }
            else if (0 == lstrcmpA(pszCmd, "rename"))
            {
                uiCmd = CMIDM_RENAME;
            }
            else if (0 == lstrcmpA(pszCmd, "link"))
            {
                uiCmd = CMIDM_CREATE_SHORTCUT;
            }
        }

        if (0 == uiCmd)
        {
            TraceTag(ttidError, "Unprocessed InvokeCommand<%s>\n", pszCmd);
            hr = E_INVALIDARG;
        }
    }
    else
    {
        uiCmd = (UINT)LOWORD((DWORD_PTR)lpici->lpVerb);
    }

    if (SUCCEEDED(hr))
    {
        // Handle the actual command
        //
        hr = HrFolderCommandHandler(uiCmd, m_apidl, m_cidl, m_hwndOwner, lpici, m_psf);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderContextMenu::InvokeCommand");
    return hr;
}

HRESULT CUPnPDeviceFolderContextMenu::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT *      pwReserved,
    PSTR        pszName,
    UINT        cchMax)
{
    HRESULT hr  = E_FAIL;   // Not handled

    TraceTag(ttidShellFolderIface, "OBJ: CCFCM - IContextMenu::GetCommandString");

    // note(cmr): GCS_HELPTEXT is defined as GCS_HELPTEXTW on UNICODE builds
    //            and GCS_HELPTEXTA otherwise.
    //            When we get GCS_HELPTEXTW, we really need to return a PWSTR
    //            in pszName (yes, even though it's defined as a PSTR).
    //            When we get GCS_HELPTEXTA, we just return a PSTR in pszName.
    //            GCS_VERB has the same semantics (with GCS_VERBW and GCS_VERBA)
    //            Basically, we just treat pszName as a PTSTR, and everything
    //            works fine.

    *((PTSTR)pszName) = TEXT('\0');

    if (uType == GCS_HELPTEXT)
    {
        int iLength = LoadString(   _Module.GetResourceInstance(),
                                    idCmd + IDS_CMIDM_START,
                                    (LPTSTR)pszName,
                                    cchMax);
        if (iLength > 0)
        {
            hr = NOERROR;
        }
        else
        {
            AssertSz(FALSE, "Resource string not found for one of the connections folder commands");
        }
    }
    else
    {
        if (uType == GCS_VERB && idCmd == CMIDM_RENAME)
        {
            // "rename" is language independent
            _tcsncpy((LPTSTR)pszName, TEXT("rename"), cchMax);
            pszName[cchMax - 1] = TEXT('\0');

            hr = NOERROR;
        }
    }

    TraceHr(ttidError, FAL, hr, (hr == E_FAIL), "CUPnPDeviceFolderContextMenu::GetCommandString");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ienumidl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I E N U M I D L . C P P
//
//  Contents:   IEnumIDList implementation for CUPnPDeviceFolderEnum
//
//  Notes:
//
//  Author:     jeffspr   07 Sep 1999
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "tfind.h"
#include "upscmn.h"     // UPNP Shell common fns

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::CUPnPDeviceFolderEnum
//
//  Purpose:    Constructor for the enumerator
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CUPnPDeviceFolderEnum::CUPnPDeviceFolderEnum()
{
    m_cDevices              = 0;

    m_pidlFolder            = NULL;
    m_dwFlags               = 0;

    m_fFirstEnumeration     = TRUE;
    m_psf = NULL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUPnPDeviceFolderEnum
//
//  Purpose:    Destructor for the enumerator. Standard cleanup.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CUPnPDeviceFolderEnum::~CUPnPDeviceFolderEnum()
{
    if (m_pidlFolder)
        FreeIDL(m_pidlFolder);

    m_psf->Release();
}

//+---------------------------------------------------------------------------
//
//  Function:   CUPnPDeviceFolderEnum::Initialize
//
//  Purpose:    Initialization for the enumerator object
//
//  Arguments:
//      pidlFolder        [in]  Pidl for the folder itself
//      psf               [in]  pointer to our folder object
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
VOID CUPnPDeviceFolderEnum::Initialize(
    LPITEMIDLIST        pidlFolder,
    CUPnPDeviceFolder * psf)
{
    m_pidlFolder        = (pidlFolder) ? CloneIDL (pidlFolder) : NULL;

    m_psf = psf;
    m_psf->AddRef();

    (VOID)HrStartSearch();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::CreateInstance
//
//  Purpose:    Create an instance of the CUPnPDeviceFolderEnum object, and
//              returns the requested interface
//
//  Arguments:
//      riid [in]   Interface requested
//      ppv  [out]  Pointer to receive the requested interface
//
//  Returns:    Standard OLE HRESULT
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
HRESULT CUPnPDeviceFolderEnum::CreateInstance(
    REFIID  riid,
    void**  ppv)
{
    HRESULT                 hr      = E_OUTOFMEMORY;
    CUPnPDeviceFolderEnum * pObj    = NULL;

    TraceTag(ttidShellFolderIface, "OBJ: CCFE - IEnumIDList::CreateInstance");

    pObj = new CComObject <CUPnPDeviceFolderEnum>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderEnum::CreateInstance");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::Next
//
//  Purpose:    Retrieves the specified number of item identifiers in the
//              enumeration sequence and advances the current position
//              by the number of items retrieved.
//
//  Arguments:
//      celt         []     Max number requested
//      rgelt        []     Array to fill
//      pceltFetched []     Return count for # filled.
//
//  Returns:    S_OK if successful, S_FALSE if there are no more items
//              in the enumeration sequence, or an OLE-defined error value
//              otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderEnum::Next(
        ULONG           celt,
        LPITEMIDLIST *  rgelt,
        ULONG *         pceltFetched)
{
    HRESULT hr  = S_OK;

    TraceTag(ttidShellFolderIface, "OBJ: CCFE - IEnumIDList::Next");

    Assert(celt >= 1);
    Assert(rgelt);
    Assert(pceltFetched || (celt == 1));

    // If the caller asks for the fetch count, zero it out for now.
    //
    if (pceltFetched)
    {
        *pceltFetched   = 0;
    }

    // Init the output list pointer
    //
    *rgelt = NULL;

    BOOL fExist = TRUE;
    ULONG celtFetched = 0;

    FolderDeviceNode * pCurrentNode;
    LPITEMIDLIST pidl;

    // build a list of devices currently in our folder list
    if (m_fFirstEnumeration)
    {
        BuildCurrentDeviceList();

        // get the first node
        fExist = m_CListDevices.FFirst(&pCurrentNode);
        if (fExist)
        {
            hr = m_psf->HrMakeUPnPDevicePidl(pCurrentNode, &pidl);

            if (SUCCEEDED(hr))
            {
                rgelt[celtFetched] = pidl;
                celtFetched++;
            }
        }

        m_fFirstEnumeration = FALSE;
    }

    while ((celtFetched < celt) && fExist)
    {
        // move to the next node
        fExist = m_CListDevices.FNext(&pCurrentNode);

        if (fExist)
        {
            hr = m_psf->HrMakeUPnPDevicePidl(pCurrentNode, &pidl);

            if (SUCCEEDED(hr))
            {
                rgelt[celtFetched] = pidl;
                celtFetched++;
            }
            else
            {
                break;
            }
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = celtFetched;
    }

    if ((hr == S_OK) &&
        ((celtFetched == 0) || (celtFetched < celt)))
    {
        // done enumerating existing elements
        hr = S_FALSE;
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CUPnPDeviceFolderEnum::Next");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::Skip
//
//  Purpose:    Skips over the specified number of elements in the
//              enumeration sequence.
//
//  Arguments:
//      celt [in]   Number of item identifiers to skip.
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderEnum::Skip(
        ULONG   celt)
{
    HRESULT hr  = S_OK;

    TraceTag(ttidShellFolderIface, "OBJ: CCFE - IEnumIDList::Skip");

    NYI("CUPnPDeviceFolderEnum::Skip");

    // Currently, do nothing
    //

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderEnum::Skip");
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::Reset
//
//  Purpose:    Returns to the beginning of the enumeration sequence. For us,
//              this means do all of the actual enumeration
//
//  Arguments:
//      (none)
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderEnum::Reset()
{
    HRESULT hr  = S_OK;

    TraceTag(ttidShellFolderIface, "OBJ: CCFE - IEnumIDList::Reset");

    // per RaymondC: I don't think the shell calls Reset.
    // It just creates a new enumerator.

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderEnum::Reset");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::Clone
//
//  Purpose:    Creates a new item enumeration object with the same contents
//              and state as the current one.
//
//  Arguments:
//      ppenum [out]    Return a clone of the current internal PIDL
//
//  Returns:    Returns S_OK if successful, or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   5 Nov 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderEnum::Clone(
        IEnumIDList **  ppenum)
{
    NYI("CUPnPDeviceFolderEnum::Clone");

    TraceTag(ttidShellFolderIface, "OBJ: CCFE - IEnumIDList::Clone");

    *ppenum = NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderEnum::BuildCurrentDeviceList
//
//  Purpose:    Walk through the global list of discovered devices
//              and create an internal list for enumeration
//
//  Arguments:
//
//  Returns:
//
//  Author:     tongl   18 Feb 2000
//
//  Notes:
//

VOID CUPnPDeviceFolderEnum::BuildCurrentDeviceList()
{
    // The list should not be there yet as this is the first enumeration
    Assert(!m_cDevices);

    EnterCriticalSection(&g_csFolderDeviceList);

    FolderDeviceNode * pCurrentNode = NULL;
    BOOL fReturn = g_CListFolderDeviceNode.FFirst(&pCurrentNode);

    while (fReturn)
    {
        if (!pCurrentNode->fDeleted)
        {
            m_CListDevices.FAdd(pCurrentNode);
            m_cDevices++;
        }

        // move to the next node
        fReturn = g_CListFolderDeviceNode.FNext(&pCurrentNode);
    }

    LeaveCriticalSection(&g_csFolderDeviceList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\iextract.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I E X T R A C T . C P P
//
//  Contents:   IExtract implementation for CUPnPDeviceFolderExtractIcon
//
//  Notes:
//
//  Author:     jeffspr   7 Oct 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include "upsres.h"
#include "upscmn.h"

extern const WCHAR c_szUPnPUIDll[];
static const WCHAR* c_szDllName = c_szUPnPUIDll;

typedef struct 
{
        BSTR m_DeviceType ;
        WORD m_wResourceID;
} DeviceTypeIconMAPPING ;

static CONST DeviceTypeIconMAPPING g_DeviceTypeIconConvtTable[] =
{
        {L"Camcorder" ,              IDI_UPNP_CAMCORDER},
        {L"DigitalSecurityCamera" ,     IDI_UPNP_DIGITAL_SECURITY_CAMERA},
     // {L"DisplayDevice" ,            IDI_UPNP_DISPLAY_DEVICE},
        {L"InternetGateway" ,         IDI_UPNP_INTERNET_GATEWAY},
        {L"PrinterDevice" ,            IDI_UPNP_PRINTER_DEVICE},
        {L"ScannerDevice" ,           IDI_UPNP_SCANNER_DEVICE},
        {L"AudioPlayer" ,              IDI_UPNP_AUDIO_PLAYER}
};

WORD GetDefaultDeviceIconResourceID(BSTR bstrDeviceType) 
{
    CONST int nSize = celems(g_DeviceTypeIconConvtTable);
    int i ;

    if( bstrDeviceType != NULL )
    {
        for( i = 0 ; i < nSize ; i++ ) 
        {  
            // ignore case ??
    	    if ( wcsstr(bstrDeviceType , g_DeviceTypeIconConvtTable[i].m_DeviceType) )
        	    return g_DeviceTypeIconConvtTable[i].m_wResourceID;
        }
    }
    
    return 0 ;
}

CUPnPDeviceFolderExtractIcon::CUPnPDeviceFolderExtractIcon()
{
    m_DeviceType = NULL;
    m_DeviceUDN  = NULL;
}    

CUPnPDeviceFolderExtractIcon::~CUPnPDeviceFolderExtractIcon()
{ 
    SysFreeString(m_DeviceType);
    SysFreeString(m_DeviceUDN);
}

HRESULT CUPnPDeviceFolderExtractIcon::CreateInstance(
    LPCITEMIDLIST apidl,
    REFIID  riid,
    void**  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CUPnPDeviceFolderExtractIcon * pObj    = NULL;

    pObj = new CComObject <CUPnPDeviceFolderExtractIcon>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(hr))
            {
                hr = pObj->GetUnknown()->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}


HRESULT CUPnPDeviceFolderExtractIcon::Initialize(LPCITEMIDLIST apidl) 
{
    HRESULT hr = S_OK;
    PUPNPDEVICEFOLDPIDL    pupdfp       = NULL;
    CUPnPDeviceFoldPidl    udfp;
    PCWSTR psz = NULL;
    PCWSTR pszUdn = NULL;
    
    if (!FIsUPnPDeviceFoldPidl(apidl) )
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        pupdfp = ConvertToUPnPDevicePIDL(apidl);
        hr = udfp.HrInit(pupdfp);
        if (SUCCEEDED(hr))
        {
            psz = udfp.PszGetTypePointer();
            hr = HrSysAllocString(psz,&m_DeviceType);
            pszUdn = udfp.PszGetUDNPointer();
            hr = HrSysAllocString(pszUdn,&m_DeviceUDN);                               
        }        
    }

    return hr;
    
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderExtractIcon::GetIconLocation
//
//  Purpose:
//
//  Arguments:
//      uFlags     [in]     Address of a UINT value that receives zero or a
//                          combination of the following values:
//
//          GIL_ASYNC       The calling application supports asynchronous
//                          retrieval of icons.
//          GIL_FORSHELL    The icon is to be displayed in a shell folder.
//
//      wzIconFile [out]    Address of the buffer that receives the icon
//                          location. The icon location is a null-terminated
//                          string that identifies the file that contains
//                          the icon.
//      cchMax     [in]     Size of the buffer that receives the icon location.
//      piIndex    [out]    Address of an INT that receives the icon index,
//                          which further describes the icon location.
//      pwFlags    [in]     Address of a UINT value that receives zero or a
//                          combination of the following values:
//
//          GIL_DONTCACHE   Don't cache the physical bits.
//          GIL_NOTFILENAME This isn't a filename/index pair. Call
//                          IExtractIcon::Extract instead
//          GIL_PERCLASS    (Only internal to the shell)
//          GIL_PERINSTANCE Each object of this class has the same icon.
//
//
//  Returns:    S_OK if the function returned a valid location,
//              or S_FALSE if the shell should use a default icon.
//
//  Author:     jeffspr   25 Nov 1998
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderExtractIcon::GetIconLocation(
    UINT    uFlags,
    PWSTR   szIconFile,
    UINT    cchMax,
    int *   piIndex,
    UINT *  pwFlags)
{
    HRESULT hr  = S_OK;
    WORD wResourceID = 0;

    TraceTag(ttidShellFolderIface, "OBJ: CCFEI - IExtractIcon::GetIconLocation, flags: %d", uFlags);

    Assert(pwFlags);
    Assert(szIconFile);
    Assert(piIndex);

#ifdef DBG
    // Easy way to check if certain flags are set
    //
    BOOL    fAsync      = (uFlags & GIL_ASYNC);
    BOOL    fForShell   = (uFlags & GIL_FORSHELL);
    BOOL    fOpenIcon   = (uFlags & GIL_OPENICON);
#endif

    *pwFlags = GIL_PERINSTANCE ;

    if((wResourceID = GetDefaultDeviceIconResourceID(m_DeviceType))) 
    {
        *piIndex = (-1)*wResourceID ;
    }
    else
    {
        *piIndex = 1 ;
    }

    lstrcpyW(szIconFile, c_szUPnPUIDll);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderExtractIcon::GetIconLocation
//
//  Purpose:    ANSI wrapper for the above UNICODE GetIconLocation
//
//  Arguments:
//      uFlags     []   See above
//      szIconFile []   See above
//      cchMax     []   See above
//      piIndex    []   See above
//      pwFlags    []   See above
//
//  Returns:
//
//  Author:     jeffspr   6 Apr 1999
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderExtractIcon::GetIconLocation(
    UINT    uFlags,
    PSTR   szIconFile,
    UINT    cchMax,
    int *   piIndex,
    UINT *  pwFlags)
{
    HRESULT hr  = S_OK;

    WCHAR * pszIconFileW = new WCHAR[cchMax];
    if (!pszIconFileW)
    {
        hr = ERROR_OUTOFMEMORY;
    }
    else
    {
        hr = GetIconLocation(uFlags, pszIconFileW, cchMax, piIndex, pwFlags);
        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte(CP_ACP, 0, pszIconFileW, -1, szIconFile, cchMax, NULL, NULL);
        }

        delete [] pszIconFileW;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CUPnPDeviceFolderExtractIcon::GetIconLocation(A)");
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderExtractIcon::Extract
//
//  Purpose:    Grab the actual icon for the caller.
//
//  Arguments:
//      wzFile      []  Filename from where we'll retrieve the icon
//      nIconIndex  []  Index of the icon (though this is bogus)
//      phiconLarge []  Return pointer for the large icon handle
//      phiconSmall []  Return pointer for the small icon handle
//      nIconSize   []  Size of the icon requested.
//
//  Returns:
//
//  Author:     jeffspr   9 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderExtractIcon::Extract(
    PCWSTR  wzFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    HRESULT         hr              = S_OK;
    int             nSizeLarge      = 0;
    int             nSizeSmall      = 0;
    
    TraceTag(ttidShellFolderIface, "OBJ: CCFEI - IExtractIcon::Extract");

    Assert(wzFile);
    Assert(phiconLarge);
    Assert(phiconSmall);

    nSizeLarge = LOWORD(nIconSize);
    nSizeSmall = HIWORD(nIconSize);

    TraceTag(ttidShellFolder,
            "Extract: %S, index: %d, nIconSize: large=%d small=%d",
            wzFile, nIconIndex, nSizeLarge, nSizeSmall);

    hr = HrLoadIcons(wzFile, nIconIndex, nSizeLarge, nSizeSmall,
                     phiconLarge, phiconSmall);

    return hr;
}

HRESULT CUPnPDeviceFolderExtractIcon::HrLoadIcons(
    PCWSTR pszFile,
    UINT   nIconIndex,
    int    nSizeLarge,
    int    nSizeSmall,
    HICON * phiconLarge,
    HICON * phiconSmall)
{
    HRESULT hr  = S_OK;
    WORD wResourceID = 0 ;

    wResourceID = GetDefaultDeviceIconResourceID(m_DeviceType);
    if(!wResourceID)
        wResourceID = IDI_UPNPDEVICE;
    
    if (phiconLarge)
    {
        int cx = nSizeLarge;
        int cy = nSizeLarge;

        *phiconLarge = (HICON) LoadImage(_Module.GetResourceInstance(),
                                         MAKEINTRESOURCE(wResourceID),
                                         IMAGE_ICON,
                                         cx,
                                         cy,
                                         LR_DEFAULTCOLOR);

        if (!*phiconLarge)
        {
            AssertSz(FALSE, "Unable to load large icon in CUPnPDeviceFolderExtractIcon::GetWizardIcons");
        }
    }

    if (phiconSmall)
    {
        int cx = nSizeSmall;
        int cy = nSizeSmall;

        *phiconSmall = (HICON) LoadImage(_Module.GetResourceInstance(),
                                         MAKEINTRESOURCE(wResourceID),
                                         IMAGE_ICON,
                                         cx,
                                         cy,
                                         LR_DEFAULTCOLOR);
        if (!*phiconSmall)
        {
            AssertSz(FALSE, "Unable to load small icon in CUPnPDeviceFolderExtractIcon::GetWizardIcons");
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolderExtractIcon::Extract
//
//  Purpose:    ANSI version of the above Extract
//
//  Arguments:
//      pszFile     [] Filename from where we'll retrieve the icon
//      nIconIndex  [] Index of the icon (though this is bogus)
//      phiconLarge [] Return pointer for the large icon handle
//      phiconSmall [] Return pointer for the small icon handle
//      nIconSize   [] Size of the icon requested.
//
//  Returns:
//
//  Author:     jeffspr   6 Apr 1999
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolderExtractIcon::Extract(
    PCSTR  pszFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    HRESULT hr          = S_OK;
    INT     cch         = 0;
    WCHAR * pszFileW    = NULL;

    Assert(pszFile);

    cch = lstrlenA(pszFile) + 1;
    pszFileW = new WCHAR[cch];

    if (!pszFileW)
    {
        hr = ERROR_OUTOFMEMORY;
    }
    else
    {
        MultiByteToWideChar(CP_ACP, 0, pszFile, -1, pszFileW, cch);

        hr = Extract(pszFileW, nIconIndex, phiconLarge, phiconSmall, nIconSize);

        delete [] pszFileW;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CUPnPDeviceFolderExtractIcon::Extract(A)");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nsbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <winuser.h>
#include <atlimpl.cpp>
#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\iolewind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I O L E W I N D . C P P
//
//  Contents:   IOleWindow implementation for CUPnPDeviceFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

STDMETHODIMP CUPnPDeviceFolder::GetWindow(
        HWND *  lphwnd)
{
    TraceTag(ttidShellFolderIface, "OBJ: CCF - IOleWindow::GetWindow");

    return E_NOTIMPL;
}

STDMETHODIMP CUPnPDeviceFolder::ContextSensitiveHelp(
        BOOL    fEnterMode)
{
    TraceTag(ttidShellFolderIface, "OBJ: CCF - IOleWindow::ContextSensitiveHelp");

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ipersist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P E R S I S T . C P P
//
//  Contents:   IPersist implementation fopr CUPnPDeviceFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetClassID
//
//  Purpose:    IPersist::GetClassID implementation for CUPnPDeviceFolder
//
//  Arguments:
//      lpClassID []
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::GetClassID(
    LPCLSID lpClassID)
{
    *lpClassID = CLSID_UPnPDeviceFolder;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ipersistf2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       I P E R S I S T F 2 . C P P
//
//  Contents:   IPersistFolder2 interface for CUPnPDeviceFolder
//
//  Notes:
//
//  Author:     jeffspr   16 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetCurFolder
//
//  Purpose:    Return a copy of the item id list for the current folder.
//
//  Arguments:
//      ppidl [out] Return pointer for the pidl
//
//  Returns:
//
//  Author:     jeffspr   16 Mar 1998
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::GetCurFolder(
    LPITEMIDLIST *ppidl)
{
    HRESULT hr  = NOERROR;

    TraceTag(ttidShellFolderIface, "OBJ: CCF - IPersistFolder2::GetCurFolder");

    *ppidl = ILClone(m_pidlFolderRoot);

    if (NULL == *ppidl)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder2.

Exit:
    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CUPnPDeviceFolder::GetCurFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ipersistf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I P E R S I S T F . C P P
//
//  Contents:   IPersistFolder implementation for CConnectionFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::Initialize
//
//  Purpose:    IPersistFolder::Initialize implementation for
//              CUPnPDeviceFolder
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   22 Sep 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::Initialize(
    LPCITEMIDLIST   pidl)
{
    HRESULT hr  = S_OK;

    TraceTag(ttidShellFolderIface, "OBJ: CCF - IPersistFolder::Initialize");

    // Store the pidl for the relative position in the namespace. We'll
    // use this later to generate absolute pidls
    //
    m_pidlFolderRoot = ILClone(pidl);

    // This should always be valid
    //
    AssertSz(m_pidlFolderRoot, "Hey, we should have a valid folder pidl");

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\iqinfo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I Q I N F O . C P P
//
//  Contents:   IQueryInfo implementation for CUPnPDeviceFolderQueryInfo
//
//  Notes:
//
//  Author:     jeffspr   16 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "upsres.h"
#include "shutil.h"

HRESULT CUPnPDeviceFolderQueryInfo::CreateInstance(
    REFIID  riid,
    void**  ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    CUPnPDeviceFolderQueryInfo * pObj    = NULL;

    pObj = new CComObject <CUPnPDeviceFolderQueryInfo>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            hr = pObj->QueryInterface (riid, ppv);
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }
    return hr;
}

CUPnPDeviceFolderQueryInfo::CUPnPDeviceFolderQueryInfo()
{
    m_pidl = NULL;
}

CUPnPDeviceFolderQueryInfo::~CUPnPDeviceFolderQueryInfo()
{
    if (m_pidl)
        FreeIDL(m_pidl);
}

HRESULT CUPnPDeviceFolderQueryInfo::GetInfoTip(
    DWORD dwFlags,
    WCHAR **ppwszTip)
{
    TraceTag(ttidShellFolderIface, "OBJ: CCFQI - IQueryInfo::GetInfoTip");

    HRESULT             hr      = NOERROR;
    PUPNPDEVICEFOLDPIDL pudfp   = ConvertToUPnPDevicePIDL(m_pidl);

    if(pudfp)
    {
        hr = HrDupeShellString(WszLoadIds(IDS_UPNPDEV_INFOTIP), ppwszTip);
    }
    else
    {
        // no info tip
        hr = E_FAIL;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolderQueryInfo::GetInfoTip");
    return hr;
}

HRESULT CUPnPDeviceFolderQueryInfo::GetInfoFlags(
    DWORD *pdwFlags)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ishellei.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L E I . C P P
//
//  Contents:   IShellExtInit implementation for CUPnPDeviceFolder
//
//  Notes:
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

STDMETHODIMP CUPnPDeviceFolder::Initialize(
        LPCITEMIDLIST   pidlFolder,
        LPDATAOBJECT    lpdobj,
        HKEY            hkeyProgID)
{
    TraceTag(ttidShellFolderIface, "OBJ: CCF - IShellExtInit::Initialize");

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\oncommand_dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D _ D B G . H 
//
//  Contents:   Debug command handler header
//
//  Notes:      
//
//  Author:     jeffspr   23 Jul 1998
//
//----------------------------------------------------------------------------

#ifndef _ONCOMMAND_DBG_H_
#define _ONCOMMAND_DBG_H_

// All of these below handle individual commands
//
HRESULT HrOnCommandDebugTracing(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugRefresh(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDebugTestAsyncFind(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);


#endif // _ONCOMMAND_DBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\oncommand.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D . H
//
//  Contents:   Command handler prototypes for the InvokeCommand code.
//
//  Notes:
//
//  Author:     jeffspr   4 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _ONCOMMAND_H_
#define _ONCOMMAND_H_

//---[ Typedefs ]-------------------------------------------------------------

// Typedefs for the functions that we'll GetProcAddress from the
// NetWare config DLL
typedef HRESULT (WINAPI *FOLDERONCOMMANDPROC)(
    LPITEMIDLIST *,
    ULONG,
    HWND,
    LPSHELLFOLDER);

struct FoldOnCommandParams
{
    FOLDERONCOMMANDPROC     pfnfocp;
    LPITEMIDLIST *          apidl;
    ULONG                   cidl;
    HWND                    hwndOwner;
    LPSHELLFOLDER           psf;
    HINSTANCE               hInstFolder;
};

typedef struct FoldOnCommandParams   FOLDONCOMMANDPARAMS;
typedef struct FoldOnCommandParams * PFOLDONCOMMANDPARAMS;

HRESULT HrCommandHandlerThread(
    FOLDERONCOMMANDPROC     pfnCommandHandler,
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

DWORD WINAPI FolderCommandHandlerThreadProc(LPVOID lpParam);


//---[ Internal versions of the command handlers ]----------------------------
//
//  These are called by the standard handler functions once they've retrieved
//  the actual data from the pidls. They are also called from those pieces
//  of the code that keep the native data, such as the tray
//
//

//---[ Standard command handler functions ]----------------------------------
//
//  These are the pidl based functions that are called from the shell folder
//
HRESULT HrFolderCommandHandler(
    UINT                    uiCommand,
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPCMINVOKECOMMANDINFO   lpici,
    LPSHELLFOLDER           psf);

// All of these below handle individual commands
//
HRESULT HrOnCommandInvoke(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandProperties(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandDelete(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

HRESULT HrOnCommandCreateShortcut(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

#endif // _ONCOMMAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\openfold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . C P P
//
//  Contents:   Folder launching code for the connections folder
//
//  Notes:
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenSpecialShellFolder
//
//  Purpose:    Open one of the standard shell folders by CSIDL id.
//
//  Arguments:
//      hwnd              [in] Window for popups if needed.
//      iStandardFolderID [in] CSIDL_ of the folder in question.
//
//  Returns:
//
//  Author:     jeffspr   24 Jan 2000
//
//  Notes:
//
HRESULT HrOpenSpecialShellFolder(HWND hwnd, INT iStandardFolderID)
{
    HRESULT         hr          = S_OK;
    HCURSOR         hcWait      = SetCursor(LoadCursor(NULL, IDC_WAIT));
    LPITEMIDLIST    pidlFolder  = NULL;;

    hr = SHGetSpecialFolderLocation(hwnd, iStandardFolderID, &pidlFolder);
    if (SUCCEEDED(hr))
    {
        Assert(pidlFolder);

        SHELLEXECUTEINFO shei = { 0 };
        shei.cbSize     = sizeof(shei);
        shei.fMask      = SEE_MASK_IDLIST | SEE_MASK_INVOKEIDLIST | SEE_MASK_FLAG_DDEWAIT;
        shei.nShow      = SW_SHOW;    // used to be SW_SHOWNORMAL
        shei.lpIDList   = pidlFolder;

        ShellExecuteEx(&shei);
        SHFree(pidlFolder);
    }

    if (hcWait)
    {
        SetCursor(hcWait);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOpenConnectionsFolder");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ishellf2.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L F 2 . C P P
//
//  Contents:   IShellFolder2 implementation for CUPnPDeviceFolder
//
//  Notes:      The IShellFolder2 interface extends the capabilities of
//              IShellFolder.  It provides the shell information that
//              can be used to populate the column ("details") view.
//
//              The methods of IShellFolder2 superset those of IShellFolder.
//              This file only implements the methods specific to
//              IShellFolder2.
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetDefaultSearchGUID
//
//  Purpose:    Returns the globally unique identifier (GUID) of the default
//              search object for the folder.
//
//  Arguments:
//      lpGUID                 [out]    GUID of the default search object.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::GetDefaultSearchGUID(GUID * pguid)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::EnumSearches
//
//  Purpose:    Requests a pointer to an interface that allows a client
//              to enumerate the available search objects.
//
//  Arguments:
//      ppEnum                 [out]    Address of a pointer to an enumerator
//                                      object's IEnumExtraSearch interface.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::EnumSearches(IEnumExtraSearch ** ppenum)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetDefaultColumn
//
//  Purpose:    Gets the default sorting and display columns.
//
//  Arguments:
//      dwReserved             [in]     Reserved. Set to zero.
//      pSort                  [out]    Pointer to a value that receives the
//                                      index of the default sorted column.
//      pDisplay               [out]    Pointer to a value that receives the
//                                      index of the default display column.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::GetDefaultColumn(DWORD dwRes,
                                    ULONG * pSort,
                                    ULONG * pDisplay)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetDefaultColumnState
//
//  Purpose:    Retrieves the default state for a specified column.
//
//  Arguments:
//      iColumn                [in]     Integer that specifies the column
//                                      number.
//      pcsFlags               [out]    Pointer to a value that contains flags
//                                      that indicate the default column state.
//                                      This parameter can include a combination
//                                      of the SHCOLSTATE_* flags.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::GetDefaultColumnState(UINT iColumn, DWORD * pcsFlags)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrVariantFromSz
//
//  Purpose:    Converts the given string into a variant to pass back from
//              GetDetailsEx().
//
//  Arguments:
//      sz   [in]   String to convert
//      pvar [out]  Returns new allocated BSTR in variant
//
//  Returns:    S_OK if success, E_FAIL if string was empty, OLE error otherwise
//
//  Author:     danielwe   2001/05/3
//
//  Notes:      Nothing needs to be freed after this
//
HRESULT HrVariantFromSz(LPCWSTR sz, VARIANT *pvar)
{
    HRESULT hr = S_OK;

    if (*sz)
    {
        BSTR bstr;

        bstr = ::SysAllocString(sz);
        if (bstr)
        {
            V_VT(pvar) = VT_BSTR;
            V_BSTR(pvar) = bstr;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("HrVariantFromSz: SysAllocString", hr);
        }
    }
    else
    {
        hr = E_FAIL;
    }

    TraceError("HrVariantFromSz", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetDetailsEx
//
//  Purpose:    Retrieves detailed information, identified by a property
//              set ID (FMTID) and property ID (PID), on an item in a shell
//              folder.
//
//  Arguments:
//      pidl                   [in]     PIDL of the item, relative to the
//                                      parent folder.  This method accepts
//                                      only single-level PIDLs.  The structure
//                                      must contain exactly one SHITEMID
//                                      structure followed by a terminating
//                                      zero.
//      pscid                  [in]     Pointer to an SHCOLUMNID structure that
//                                      identifies the column.
//      pv                     [out]    Pointer to a VARIANT with the requested
//                                      information.  The value will be fully
//                                      typed.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:      In the "My Network Places" folder, there are two columns:
//              "Name" and "Comment".  The "Name" column should contain
//              the display name (a.k.a. FriendlyName) of the device, which
//              is returned by GetDisplayNameOf().  This supplies the value
//              of the "Comment" column, which is:
//               - the device's get_Description() property, if supplied
//               - an empty string otherwise (returning an error yields this)
//
STDMETHODIMP
CUPnPDeviceFolder::GetDetailsEx(LPCITEMIDLIST pidl,
                                const SHCOLUMNID * pscid,
                                VARIANT * pv)
{
    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::GetDetailsEx");

    HRESULT hr;
    PUPNPDEVICEFOLDPIDL pupdfp;

    hr = S_OK;
    pupdfp = NULL;

    if (!pidl)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pscid)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (!pv)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure that the pidls passed in are our pidls.
    //
    {
        BOOL fResult;

        fResult = FIsUPnPDeviceFoldPidl(pidl);
        if (!fResult)
        {
            // not one of our PIDLs, can't do anything

            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    pupdfp = ConvertToUPnPDevicePIDL(pidl);

    if (IsEqualGUID(pscid->fmtid, FMTID_SummaryInformation))
    {
        switch (pscid->pid)
        {
            case PIDSI_COMMENTS:  // "Comment" column
                {
                    CUPnPDeviceFoldPidl udfp;

                    hr = udfp.HrInit(pupdfp);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrVariantFromSz(udfp.PszGetDescriptionPointer(), pv);
                        if (FAILED(hr))
                        {
                            goto Cleanup;
                        }
                    }
                    break;
                }

            default:
                TraceTag(ttidShellFolderIface, "CUPnPDeviceFolder::GetDetailsEx: "
                         "Unknown column: %x", pscid->pid);
                hr = E_FAIL;
                goto Cleanup;

                break;
        }
    }
    else if (IsEqualGUID(pscid->fmtid, FMTID_ShellDetails))
    {
        switch (pscid->pid)
        {
            case PID_NETWORKLOCATION:
                BSTR bstrLocation;

                bstrLocation= ::SysAllocString(WszLoadIds(IDS_LOCAL_NETWORK));
                if (bstrLocation)
                {
                    V_VT(pv) = VT_BSTR;
                    V_BSTR(pv) = bstrLocation;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceError("CUPnPDeviceFolder::GetDetailsEx: "
                               "SysAllocString", hr);
                }
                break;

            case PID_COMPUTERNAME:
                {
                    CUPnPDeviceFoldPidl udfp;

                    hr = udfp.HrInit(pupdfp);
                    if (SUCCEEDED(hr))
                    {
                        hr = HrVariantFromSz(udfp.PszGetNamePointer(), pv);
                        if (FAILED(hr))
                        {
                            goto Cleanup;
                        }
                    }
                }
                break;

            default:
                TraceTag(ttidShellFolderIface, "CUPnPDeviceFolder::GetDetailsEx: "
                         "Unknown column: %x", pscid->pid);
                hr = E_FAIL;
                goto Cleanup;

                break;
        }
    }
    else
    {
        // We have a guid we don't know about
        //
        TraceTag(ttidShellFolderIface, "CUPnPDeviceFolder::GetDetailsEx: "
                 "Unknown FMTID");

        hr = E_FAIL;
        goto Cleanup;
    }

    Assert(SUCCEEDED(hr));

Cleanup:
    TraceError("CUPnPDeviceFolder::GetDetailsEx", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetDetailsOf
//
//  Purpose:    Retrieves detailed information, identified by a column index,
//               on an item in a shell folder.
//
//  Arguments:
//      pidl                   [in]     PIDL of the item for which you are
//                                      requesting information.  This method
//                                      accepts only single-level PIDLs.  The
//                                      structure must contain exactly one
//                                      SHITEMID structure followed by a
//                                      terminating zero. If this parameter is
//                                      set to NULL, the title of the
//                                      information field specified by iColumn
//                                      is returned.
//      iColumn                [in]     Zero-based index of the desired
//                                      information field.  It is identical to
//                                      the column number of the information as
//                                      it is displayed in a Details view.
//      pDetails               [out]    Pointer to a SHELLDETAILS structure that
//                                      contains the information.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::GetDetailsOf(LPCITEMIDLIST pidl,
                                UINT iColumn,
                                SHELLDETAILS * psd)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::MapColumnToSCID
//
//  Purpose:    Converts a column to the appropriate property set ID (FMTID)
//              and property ID (PID).
//
//  Arguments:
//      iColumn                [in]     Integer that specifies the column
//                                      number.
//      pscid                  [out]    Pointer to an SHCOLUMNID structure
//                                      containing the FMTID and PID.
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Notes:
//
STDMETHODIMP
CUPnPDeviceFolder::MapColumnToSCID(UINT iColumn,
                                   SHCOLUMNID * pscid)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\pidlutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L U T I L . C P P
//
//  Contents:   PIDL utility routines. This stuff is mainly copied from the
//              existing Namespace extension samples and real code, since
//              everyone and their gramma uses this stuff.
//
//  Notes:
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "pidlutil.h"

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   ILNext
//
//  Purpose:    Return the next PIDL in the list
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILNext(LPCITEMIDLIST pidl)
{
    if (pidl)
    {
        pidl = (LPITEMIDLIST) ((BYTE *)pidl + pidl->mkid.cb);
    }

    return (LPITEMIDLIST)pidl;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILIsEmpty
//
//  Purpose:    Is this PIDL empty
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
BOOL ILIsEmpty(LPCITEMIDLIST pidl)
{
   return (!pidl || !pidl->mkid.cb);

}
#endif // #if DBG


//+---------------------------------------------------------------------------
//
//  Function:   ILSkip
//
//  Purpose:    Skip to an offset
//
//  Arguments:
//      pidl    The input pidl
//      cb      Offset to skip to
//
//  Returns:
//
//  Author:     tongl   2/16/00    (from raymondc)
//
//  Notes:
//
LPITEMIDLIST ILSkip(LPCITEMIDLIST pidl, UINT cb)
{
    return const_cast<LPITEMIDLIST>
           (reinterpret_cast<LPCITEMIDLIST>
            (reinterpret_cast<const BYTE *>(pidl) + cb));
}

//+---------------------------------------------------------------------------
//
//  Function:   ILGetSizePriv
//
//  Purpose:    Return the size of a pidl.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetSizePriv(LPCITEMIDLIST pidl)
{
   UINT cbTotal = 0;

   if (pidl)
   {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator
        while (pidl->mkid.cb)
        {
            cbTotal += pidl->mkid.cb;
            pidl = ILNext(pidl);
        }
    }

    return cbTotal;
}

VOID FreeIDL(LPITEMIDLIST pidl)
{
    Assert(pidl);

    SHFree(pidl);
}


//+---------------------------------------------------------------------------
//
//  Function:   ILIsSingleID
//
//  Purpose:    Returns TRUE if the idlist has just one ID in it.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
BOOL ILIsSingleID(LPCITEMIDLIST pidl)
{
    if (pidl == NULL)
        return FALSE;

    return (pidl->mkid.cb == 0 || ILNext(pidl)->mkid.cb == 0);
}


//+---------------------------------------------------------------------------
//
//  Function:   ILGetCID
//
//  Purpose:    Returns the number of ID's in the list.
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetCID(LPCITEMIDLIST pidl)
{
    UINT cid = 0;

    while (!ILIsEmpty(pidl))
    {
        ++ cid;
        pidl = ILNext(pidl);
    }

    return cid;
}


//+---------------------------------------------------------------------------
//
//  Function:   ILGetSizeCID
//
//  Purpose:    Get the length of the first cid items in a pidl.
//
//  Arguments:
//      pidl []
//      cid  []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
UINT ILGetSizeCID(LPCITEMIDLIST pidl, UINT cid)
{
    UINT cbTotal = 0;

    if (pidl)
    {
        cbTotal += sizeof(pidl->mkid.cb);       // Null terminator

        while (cid && !ILIsEmpty(pidl))
        {
            cbTotal += pidl->mkid.cb;
            pidl = ILNext(pidl);
            -- cid;
        }
    }

    return cbTotal;
}

//+---------------------------------------------------------------------------
//
//  Function:   CloneIDL
//
//  Purpose:    Clone an IDL (return a duplicate)
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST CloneIDL(LPCITEMIDLIST pidl)
{
    UINT            cb      = 0;
    LPITEMIDLIST    pidlRet = NULL;

    if (pidl)
    {
        cb = ILGetSizePriv(pidl);

        pidlRet = (LPITEMIDLIST) SHAlloc(cb);
        if (pidlRet)
        {
            memcpy(pidlRet, pidl, cb);
        }
    }

    return pidlRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILCreate
//
//  Purpose:    Create a PIDL
//
//  Arguments:
//      cbSize []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILCreate(DWORD dwSize)
{
   LPITEMIDLIST pidl = (LPITEMIDLIST) SHAlloc(dwSize);

   return pidl;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILCombinePriv
//
//  Purpose:    Combine two PIDLs
//
//  Arguments:
//      pidl1 []
//      pidl2 []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILCombinePriv(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPITEMIDLIST    pidlNew     = NULL;
    // Let me pass in NULL pointers
    if (!pidl1)
    {
        if (!pidl2)
        {
            pidlNew = NULL;
        }
        else
        {
            pidlNew = CloneIDL(pidl2);
        }
    }
    else
    {
        if (!pidl2)
        {
            pidlNew = CloneIDL(pidl1);
        }
        else
        {
            UINT cb1 = ILGetSizePriv(pidl1) - sizeof(pidl1->mkid.cb);
            UINT cb2 = ILGetSizePriv(pidl2);

            pidlNew = ILCreate(cb1 + cb2);
            if (pidlNew)
            {
                memcpy(pidlNew, pidl1, cb1);
                memcpy((PWSTR)(((LPBYTE)pidlNew) + cb1), pidl2, cb2);
                Assert (ILGetSizePriv(pidlNew) == cb1+cb2);
            }
        }
    }

    return pidlNew;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILFindLastIDPriv
//
//  Purpose:    Find the last ID in an IDL
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997    (from brianwen)
//
//  Notes:
//
LPITEMIDLIST ILFindLastIDPriv(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    Assert(pidl);

    // Find the last one in the list
    //
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}

//+---------------------------------------------------------------------------
//
//  Function:   ILRemoveLastIDPriv
//
//  Purpose:    Remove the last ID from an IDL
//
//  Arguments:
//      pidl []
//
//  Returns:
//
//  Author:     jeffspr   1 Oct 1997
//
//  Notes:
//
BOOL ILRemoveLastIDPriv(LPITEMIDLIST pidl)
{
    BOOL    fRemoved = FALSE;

    Assert(pidl);

    if (pidl->mkid.cb)
    {
        LPITEMIDLIST pidlLast = (LPITEMIDLIST)ILFindLastIDPriv(pidl);

        Assert(pidlLast->mkid.cb);
        Assert(ILNext(pidlLast)->mkid.cb==0);

        // Remove the last one
        pidlLast->mkid.cb = 0; // null-terminator
        fRemoved = TRUE;
    }

    return fRemoved;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCloneRgIDL
//
//  Purpose:    Clone a pidl array
//
//  Arguments:
//      rgpidl              [in]    PIDL array to clone
//      cidl                [in]    Count of the pidl array
//      pppidl              [out]   Return pointer for pidl array
//
//  Returns:
//
//  Author:     jeffspr   22 Oct 1997
//
//  Notes:
//
HRESULT HrCloneRgIDL(
    LPCITEMIDLIST * rgpidl,
    ULONG           cidl,
    LPITEMIDLIST ** pppidl,
    ULONG *         pcidl)
{
    HRESULT         hr              = NOERROR;
    LPITEMIDLIST *  rgpidlReturn    = NULL;
    ULONG           irg             = 0;
    ULONG           cidlCopied      = 0;

    Assert(pppidl);
    Assert(pcidl);
    Assert(rgpidl);

    if (!rgpidl || !cidl)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    else
    {
        // Alloc the return buffer
        //
        rgpidlReturn = (LPITEMIDLIST *) SHAlloc(cidl * sizeof(LPITEMIDLIST));
        if (!rgpidlReturn)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        else
        {
            // Clone all elements within the passed in PIDL array
            //
            for (irg = 0; irg < cidl; irg++)
            {
                if (rgpidl[irg])
                {
                    // Clone this element in the PIDL array
                    //
                    rgpidlReturn[cidlCopied++] = CloneIDL ((LPITEMIDLIST) rgpidl[irg]);
                    if (!rgpidlReturn[irg])
                    {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                }
                else
                {
                    // Make sure that we don't try to delete bogus data later.
                    //
                    rgpidlReturn[cidlCopied++] = NULL;

                    AssertSz(FALSE, "Bogus element in the rgpidl in HrCloneRgIDL");
                    hr = E_INVALIDARG;
                    goto Exit;
                }
            }
        }
    }

Exit:
    if (FAILED(hr))
    {
        // Free the already-allocated IDLISTs
        //
        ULONG irgT = 0;

        for (irgT = 0; irgT < irg; irgT++)
        {
            if (rgpidlReturn[irgT])
            {
                FreeIDL(rgpidlReturn[irgT]);
            }
        }

        SHFree(rgpidlReturn);
        *pppidl = NULL;
    }
    else
    {
        // Fill in the return var.
        //
        *pppidl = rgpidlReturn;
        *pcidl = cidlCopied;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL");
    return hr;

}       //  HrCloneRgIDL

//+---------------------------------------------------------------------------
//
//  Function:   FreeRgIDL
//
//  Purpose:    Free a PIDL array
//
//  Arguments:
//      cidl  [in]  Size of PIDL array
//      apidl [in]  Pointer to the array itself.
//
//  Returns:
//
//  Author:     jeffspr   27 Oct 1997
//
//  Notes:
//
VOID FreeRgIDL(
    UINT            cidl,
    LPITEMIDLIST  * apidl)
{
    if (apidl)
    {
        for (UINT i = 0; i < cidl; i++)
        {
            FreeIDL(apidl[i]);
        }

        SHFree(apidl);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\oncommand_dbg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D _ D B G . C P P
//
//  Contents:   Debug command handlers
//
//  Notes:
//
//  Author:     jeffspr   23 Jul 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "oncommand.h"

#if DBG                     // Debug menu commands
#include "oncommand_dbg.h"  //
#endif

#include "shutil.h"
#include <upsres.h>

//---[ Globals ]--------------------------------------------------------------

// Used as the caption for all debugging message boxes
//
const WCHAR c_szDebugCaption[]      = L"UPnP Device Config Debugging";

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugTracing
//
//  Purpose:    Command handler for CMIDM_DEBUG_TRACING. It will eventually
//              bring up the tracing change dialog.
//
//  Arguments:
//      apidl     [] Ignored
//      cidl      [] Ignored
//      hwndOwner [] Ignored
//      psf       [] Ignored
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugTracing(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

//    hr = HrOpenTracingUI(hwndOwner);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugTracing");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugRefresh
//
//  Purpose:    Test the flushing of the connection cache (does the folder
//              still work properly)? This will simulate the current response
//              to an external refresh request
//
//  Arguments:
//      apidl     [in]  Ignored
//      cidl      [in]  Ignored
//      hwndOwner [in]  Ignored
//      psf       [in]  Ignored
//
//  Returns:
//
//  Author:     jeffspr   17 Nov 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugRefresh(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    // Force a refresh without having the window to work with.
    //
    ForceRefresh(NULL);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugRefresh");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugTestAsyncFind
//
//  Purpose:    Simple test of async find
//
//  Arguments:
//      apidl     []
//      cidl      []
//      hwndOwner []
//      psf       []
//
//  Returns:
//
//  Author:     jeffspr   22 Nov 1999
//
//  Notes:
//
HRESULT HrOnCommandDebugTestAsyncFind(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    // hr = HrStartAsyncFind();

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugTestAsyncFind");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\oncommand.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D . C P P
//
//  Contents:   Command handlers for the context menus, etc.
//
//  Notes:
//
//  Author:     jeffspr   4 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "upsres.h"
#include "oncommand.h"

#if DBG                     // Debug menu commands
#include "oncommand_dbg.h"  //
#endif

#include "shutil.h"
#include <upsres.h>
#include "tfind.h"

//---[ Externs ]--------------------------------------------------------------

extern const WCHAR c_szUPnPUIDll[];
extern const TCHAR c_sztUPnPUIDll[];

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrCreateDevicePropertySheets(
            HWND            hwndOwner,
            NewDeviceNode * pNDN);

//---[ Constants ]------------------------------------------------------------


HRESULT HrCommandHandlerThread(
    FOLDERONCOMMANDPROC     pfnCommandHandler,
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT         hr          = S_OK;
    LPITEMIDLIST *  apidlCopy   = NULL;
    ULONG           cidlCopy    = 0;

    // If there are pidls to copy, copy them
    //
    if (apidl)
    {
        hr = HrCloneRgIDL((LPCITEMIDLIST *) apidl, cidl, &apidlCopy, &cidlCopy);
    }

    // If either there were no pidls, or the Clone succeeded, then we want to continue
    //
    if (SUCCEEDED(hr))
    {
        PFOLDONCOMMANDPARAMS  pfocp = new FOLDONCOMMANDPARAMS;

        if (pfocp)
        {
            pfocp->pfnfocp         = pfnCommandHandler;
            pfocp->apidl           = apidlCopy;
            pfocp->cidl            = cidlCopy;
            pfocp->hwndOwner       = hwndOwner;
            pfocp->psf             = psf;
            pfocp->hInstFolder     = NULL;

            // This should be Release'd in the thread called.
            //
            psf->AddRef();

            // This will always succeed in retail, but will test the flag in debug
            //
            if (!FIsDebugFlagSet (dfidDisableShellThreading))
            {
                // Run in a thread using the QueueUserWorkItem
                //

                HANDLE      hthrd = NULL;
                HINSTANCE   hInstFolder = LoadLibrary(c_sztUPnPUIDll);

                if (hInstFolder)
                {
                    pfocp->hInstFolder = hInstFolder;

                    DWORD  dwThreadId;
                    hthrd = CreateThread(NULL, 0,
                                    (LPTHREAD_START_ROUTINE)FolderCommandHandlerThreadProc,
                                    (LPVOID)pfocp, 0, &dwThreadId);
                }

                if (NULL != hthrd)
                {
                    CloseHandle(hthrd);
                }
                else
                {
                    pfocp->hInstFolder = NULL;
                    FolderCommandHandlerThreadProc(pfocp);
                }
            }
            else
            {
                // Run directly in this same thread
                //
                FolderCommandHandlerThreadProc((PVOID) pfocp);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }


    // Don't release the psf here. This should have been taken care of by the called ThreadProc
    //
    TraceError("HrCommandHandlerThread", hr);
    return hr;
}

DWORD WINAPI FolderCommandHandlerThreadProc(LPVOID lpParam)
{
    HRESULT                     hr                  = S_OK;
    PFOLDONCOMMANDPARAMS        pfocp               = (PFOLDONCOMMANDPARAMS) lpParam;
    BOOL                        fCoInited           = FALSE;

    Assert(pfocp);

    hr = CoInitializeEx (NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (SUCCEEDED(hr))
    {
        // We don't care if this is S_FALSE or not, since we'll soon
        // overwrite the hr. If it's already initialized, great...

        fCoInited = TRUE;

        // Call the specific handler
        //
        hr = pfocp->pfnfocp(
            pfocp->apidl,
            pfocp->cidl,
            pfocp->hwndOwner,
            pfocp->psf);
    }

    // Remove the ref that we have on this object. The thread handler would have addref'd
    // this before queueing our action
    //
    if (pfocp->psf)
    {
        ReleaseObj(pfocp->psf);
    }

    // Release apidl
    //
    if (pfocp->apidl)
    {
        FreeRgIDL(pfocp->cidl, pfocp->apidl);
    }

    // Remove this object. We're responsible for this now.
    //
    HINSTANCE hInstFolder = pfocp->hInstFolder;
    pfocp->hInstFolder = NULL;

    delete pfocp;

    if (fCoInited)
    {
        CoUninitialize();
    }

    if (hInstFolder)
    {
        FreeLibraryAndExitThread(hInstFolder, hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrFolderCommandHandler
//
//  Purpose:    Command handler switch -- all commands come through this
//              point.
//
//  Arguments:
//      uiCommand [in]  The command-id that's been invoked.
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      lpici     [in]  Command context info
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   11 Feb 1998
//
//  Notes:
//
HRESULT HrFolderCommandHandler(
    UINT                    uiCommand,
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPCMINVOKECOMMANDINFO   lpici,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    CWaitCursor wc;     // Bring up wait cursor now. Remove when we go out of scope.

#if 0
    // refresh all permission so subsequent calls can use cached value
    RefreshAllPermission();
#endif

    switch(uiCommand)
    {
        case CMIDM_INVOKE:
            Assert(apidl);
            hr = HrCommandHandlerThread(HrOnCommandInvoke, apidl, cidl, hwndOwner, psf);
            break;

        case CMIDM_ARRANGE_BY_NAME:
            ShellFolderView_ReArrange(hwndOwner, ICOL_NAME);
            break;

        case CMIDM_ARRANGE_BY_URL:
            ShellFolderView_ReArrange(hwndOwner, ICOL_URL);
            break;

        case CMIDM_CREATE_SHORTCUT:
            Assert(apidl);
            hr = HrCommandHandlerThread(HrOnCommandCreateShortcut, apidl, cidl, hwndOwner, psf);
            break;

        case CMIDM_DELETE:
            Assert(apidl);
            hr = HrCommandHandlerThread(HrOnCommandDelete, apidl, cidl, hwndOwner, psf);
            break;

        case CMIDM_PROPERTIES:
            Assert(apidl);
            hr = HrCommandHandlerThread(HrOnCommandProperties, apidl, cidl, hwndOwner, psf);
            break;

#if DBG
        case CMIDM_DEBUG_TRACING:
            hr = HrOnCommandDebugTracing(apidl, cidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_REFRESH:
            hr = HrOnCommandDebugRefresh(apidl, cidl, hwndOwner, psf);
            break;

        case CMIDM_DEBUG_TESTASYNCFIND:
            hr = HrOnCommandDebugTestAsyncFind(apidl, cidl, hwndOwner, psf);
            break;
#endif

        default:
            AssertSz(FALSE, "Unknown command in HrFolderCommandHandler");
            hr = E_FAIL;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrFolderCommandHandler");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandInvoke
//
//  Purpose:    Command handler for CMIDM_INVOKE
//
//  Arguments:
//      apidl     [in] PIDL array (item 0 is our item to work on)
//      cidl      [in] Size of the array
//      hwndOwner [in] Owner hwnd
//      psf       [in] Our IShellFolder *
//
//  Returns:
//
//  Author:     jeffspr   8 Sep 1999
//
//  Notes:
//
HRESULT HrOnCommandInvoke(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT             hr      = S_OK;
    BOOL                fResult = FALSE;
    PUPNPDEVICEFOLDPIDL pudfp   = ConvertToUPnPDevicePIDL(apidl[0]);
    IUPnPDeviceFinder * pdf     = NULL;
    LPTSTR              szUrl   = NULL;

    Assert(pudfp);
    Assert(cidl > 0);

    hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER,
                          IID_IUPnPDeviceFinder, (LPVOID *)&pdf);
    if (SUCCEEDED(hr))
    {
        IUPnPDevice *   pdev = NULL;
        CUPnPDeviceFoldPidl udfp;

        hr = udfp.HrInit(pudfp);
        if (SUCCEEDED(hr))
        {
            PCWSTR szUDN = udfp.PszGetUDNPointer();
            Assert(szUDN);
            BSTR bstrUDN = ::SysAllocString(szUDN);
            if (bstrUDN)
            {
                hr = pdf->FindByUDN(bstrUDN, &pdev);
                if (S_OK == hr)
                {
                    BSTR    bstrUrl;

                    hr = pdev->get_PresentationURL(&bstrUrl);
                    if (SUCCEEDED(hr))
                    {
                        // Note: PresentationURL might be NULL

                        if (S_OK == hr)
                        {
                            Assert(bstrUrl);

                            szUrl = TszFromWsz(bstrUrl);
                        }

                        SysFreeString(bstrUrl);
                    }

                    ReleaseObj(pdev);
                }
                else if (hr == S_FALSE)
                {
                    PTSTR pszText = NULL;
                    PTSTR pszTitle = NULL;

                    pszText = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_DEVICE_OFFLINE_MSG));
		            pszTitle = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_DEVICE_OFFLINE_TITLE));

                    if( pszText && pszTitle )
                    {
				        MessageBox(hwndOwner, pszText, pszTitle, MB_OK | MB_ICONWARNING );
				    
                    }
                    
                    delete pszText;
				    delete pszTitle;
					
                	TraceTag(ttidError,
                             "Can not bring up control page for device UDN=%S because FindByUDN returns S_FALSE.",
                             szUDN);
                }

                ::SysFreeString(bstrUDN);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrOnCommandInvoke: SysAllocString", hr);
            }
        }

        ReleaseObj(pdf);
    }

    if (szUrl)
    {
        SHELLEXECUTEINFO    sei = {0};

        // Check these masks if we ever need to use different icons and such
        // for the instances that we launch. SEE_MASK_ICON is a possibility.
        // SEE_MASK_FLAG_NO_UI can be used if we don't want to show an error
        // on failure.
        //
        sei.cbSize          = sizeof(SHELLEXECUTEINFO);
        sei.fMask           = SEE_MASK_FLAG_DDEWAIT;
        sei.hwnd            = hwndOwner;
        sei.lpFile          = szUrl;
        sei.nShow           = SW_SHOW;

        fResult = ShellExecuteEx(&sei);
        if (!fResult)
        {
            hr = HrFromLastWin32Error();
        }

        delete [] szUrl;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandInvoke");
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandProperties
//
//  Purpose:    Command handler for the CMIDM_PROPERTIES command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   4 Nov 1997
//
//  Notes:
//
HRESULT HrOnCommandProperties(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT             hr      = S_OK;
    PUPNPDEVICEFOLDPIDL pudfp   = ConvertToUPnPDevicePIDL(apidl[0]);
    IUPnPDeviceFinder * pdf     = NULL;

    Assert(pudfp);
    Assert(cidl > 0);

    // instantiate device finder
    hr = CoCreateInstance(
                CLSID_UPnPDeviceFinder,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IUPnPDeviceFinder,
                (LPVOID *)&pdf
                );

    if (SUCCEEDED(hr))
    {
        CUPnPDeviceFoldPidl udfp;

        hr = udfp.HrInit(pudfp);
        if (SUCCEEDED(hr))
        {
            // retrieve the device object associated with UDN

            IUPnPDevice * pdev = NULL;
            PCWSTR szUDN = udfp.PszGetUDNPointer();
            Assert(szUDN);
            BSTR bstrUDN = ::SysAllocString(szUDN);
            if (bstrUDN)
            {
                hr = pdf->FindByUDN(bstrUDN, &pdev);
                if (hr == S_OK)
                {
                    NewDeviceNode * pNDN = NULL;

                    // convert device object to device node
                    hr = HrCreateDeviceNodeFromDevice(pdev, &pNDN);
                    if (SUCCEEDED(hr))
                    {
                        // display property pages for given device node
                        hr = HrCreateDevicePropertySheets(hwndOwner, pNDN);

                        // nuke device node
                        delete pNDN;
                    }

                    ReleaseObj(pdev);
                }
                else if (hr == S_FALSE)
                {
                    PTSTR pszText = NULL;
                    PTSTR pszTitle = NULL;

                    pszText = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_DEVICE_OFFLINE_MSG));
		            pszTitle = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_DEVICE_OFFLINE_TITLE));

                    if( pszText && pszTitle )
                    {
					    MessageBox(hwndOwner, pszText, pszTitle, MB_OK | MB_ICONWARNING);
                    }
                    
                    delete pszText;
					delete pszTitle;
					
                    TraceTag(ttidError,
                             "Can not bring up property for device UDN=%S because"
                             " FindByUDN returns S_FALSE.",
                             szUDN);
                }
                ::SysFreeString(bstrUDN);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("HrOnCommandInvoke: SysAllocString", hr);
            }
        }

        ReleaseObj(pdf);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandProperties");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDelete
//
//  Purpose:    Command handler for the CMIDM_DELETE command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//      psf       [in]  Our folder
//
//  Returns:
//
//  Author:     jeffspr   3 Dec 1997
//
//  Notes:
//
HRESULT HrOnCommandDelete(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT                 hr          = S_OK;
    DWORD                   dwLoop      = 0;
    INT                     iMBResult   = 0;

#if 0
    // Bring up the prompt for the delete
    //
    if (cidl > 1)
    {
        WCHAR   wszItemCount[8];

        // Convert the item count to a string
        //
        _itow( cidl, wszItemCount, 10 );

        // Bring up the message box
        //
        iMBResult = NcMsgBox(
            _Module.GetResourceInstance(),
            NULL,
            IDS_CONFOLD_DELETE_CONFIRM_MULTI_CAPTION,
            IDS_CONFOLD_DELETE_CONFIRM_MULTI,
            MB_YESNO | MB_ICONQUESTION,
            wszItemCount);
    }
    else if (cidl == 1)
    {
        PCCONFOLDENTRY  pccfe   = NULL;

        // Convert the pidl to a confoldentry, and use the name
        // to bring up the confirm message box
        //
        hr = HrPidlToCConFoldEntry(apidl[0], &pccfe);
        if (SUCCEEDED(hr))
        {
            // Don't let them try to delete a wizard
            //
            if (pccfe->m_fWizard)
            {
                NcMsgBox(
                    _Module.GetResourceInstance(),
                    NULL,
                    IDS_CONFOLD_ERROR_DELETE_CAPTION,
                    IDS_CONFOLD_ERROR_DELETE_WIZARD,
                    MB_ICONEXCLAMATION);

                delete pccfe;
                goto Exit;
            }
            else
            {
                // Check to see if this connection is in the process of activating.
                // If so, then we won't allow the delete.
                //
                hr = HrCheckForActivation(NULL, pccfe, &fActivating);
                if (S_OK == hr)
                {
                    if (!fActivating)
                    {
                        if ((pccfe->m_ncs == NCS_CONNECTING) ||
                            (pccfe->m_ncs == NCS_CONNECTED) ||
                            (pccfe->m_ncs == NCS_DISCONNECTING))
                        {
                            // You can't delete an active connection
                            //
                            NcMsgBox(
                                 _Module.GetResourceInstance(),
                                 NULL,
                                 IDS_CONFOLD_ERROR_DELETE_CAPTION,
                                 IDS_CONFOLD_ERROR_DELETE_ACTIVE,
                                 MB_ICONEXCLAMATION);

                            delete pccfe;
                            goto Exit;
                        }
                        else
                        {
                            // Ask for delete confirmation
                            //
                            iMBResult = NcMsgBox(
                                _Module.GetResourceInstance(),
                                NULL,
                                IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                IDS_CONFOLD_DELETE_CONFIRM_SINGLE,
                                MB_YESNO | MB_ICONQUESTION,
                                pccfe->m_pszName);
                        }
                    }
                    else
                    {
                        // Bring up the MB about "Hey, you can't delete while
                        // the connection is activating."
                        //
                        iMBResult = NcMsgBox(
                            _Module.GetResourceInstance(),
                            NULL,
                            IDS_CONFOLD_ERROR_DELETE_CAPTION,
                            IDS_CONFOLD_ERROR_DELETE_ACTIVE,
                            MB_ICONEXCLAMATION);

                        delete pccfe;
                        goto Exit;
                    }
                }
                else
                {
                    // If the connection wasn't found, then we should just drop out of here
                    // because we sure can't delete it.
                    //
                    if (S_FALSE == hr)
                    {
                        delete pccfe;
                        goto Exit;
                    }
                }

                delete pccfe;
                pccfe = NULL;
            }
        }
        else
        {
            AssertSz(FALSE, "Couldn't get ConFoldEntry from pidl in HrOnCommandDelete");
            goto Exit;
        }
    }
    else
    {
        // No connections were specified. Take a hike.
        //
        goto Exit;
    }

    // If the user said "Yes" to the prompt
    //
    if (iMBResult == IDYES)
    {
        CConnectionFolder * pcf         = static_cast<CConnectionFolder *>(psf);
        LPITEMIDLIST        pidlFolder  = pcf ? pcf->PidlGetFolderRoot() : NULL;
        BOOL                fShowActivationWarning = FALSE;
        BOOL                fShowNotDeletableWarning = FALSE;

        Assert(pidlFolder);

        for (dwLoop = 0; dwLoop < cidl; dwLoop++)
        {
            PCCONFOLDENTRY  pccfe   = NULL;

            hr = HrPidlToCConFoldEntry(apidl[dwLoop], &pccfe);
            if (SUCCEEDED(hr))
            {
                // If this is a LAN connection the user doesn't have rights
                //
                if ((NCM_LAN == pccfe->m_ncm) || (pccfe->m_fWizard))
                {
                    fShowNotDeletableWarning = TRUE;
                    continue;
                }

                // If this is a RAS connection and the user doesn't have rights
                // then skip
                //
                if (NCM_LAN != pccfe->m_ncm)
                {
                    if ((!FHasPermission(NCPERM_DeleteConnection)) ||
                        ((pccfe->m_dwCharacteristics & NCCF_ALL_USERS) &&
                         !FHasPermission(NCPERM_DeleteAllUserConnection)))
                    {
                        fShowNotDeletableWarning = TRUE;
                        continue;
                    }
                }

                hr = HrCheckForActivation(NULL, pccfe, &fActivating);
                if (S_OK == hr)
                {
                    // Only allow deletion if this connection is inactive and
                    // it allows removal.
                    //
                    if (fActivating || (pccfe->m_ncs == NCS_CONNECTING) ||
                        (pccfe->m_ncs == NCS_CONNECTED) ||
                        (pccfe->m_ncs == NCS_DISCONNECTING))
                    {
                        fShowActivationWarning = TRUE;
                    }
                    else if (pccfe->m_dwCharacteristics & NCCF_ALLOW_REMOVAL)
                    {
                        hr = HrNetConFromPidl(apidl[dwLoop], &pNetCon);
                        if (SUCCEEDED(hr))
                        {
                            hr = pNetCon->Delete();
                            if (SUCCEEDED(hr) && pcf)
                            {
                                hr = HrDeleteFromCclAndNotifyShell(pidlFolder, apidl[dwLoop], pccfe);
                            }

                            ReleaseObj(pNetCon);
                        }
                    }
                    else
                    {
                        // The selected item is not deletable
                        //
                        fShowNotDeletableWarning = TRUE;
                    }
                }
            }
        }

        if (fShowNotDeletableWarning)
        {
            // You can't delete an item that doesn't support it
            //
            NcMsgBox(
                 _Module.GetResourceInstance(),
                 NULL,
                 IDS_CONFOLD_ERROR_DELETE_CAPTION,
                 (1 == cidl) ?
                     IDS_CONFOLD_ERROR_DELETE_NOSUPPORT :
                     IDS_CONFOLD_ERROR_DELETE_NOSUPPORT_MULTI,
                 MB_ICONEXCLAMATION);
        }
        else if (fShowActivationWarning)
        {
            // You can't delete an active connection. Note, if more
            // than one are being deleted, then we put up the warning
            // that says 'one or more are being ignored'.
            //
            NcMsgBox(
                 _Module.GetResourceInstance(),
                 NULL,
                 IDS_CONFOLD_ERROR_DELETE_CAPTION,
                 (1 == cidl) ?
                     IDS_CONFOLD_ERROR_DELETE_ACTIVE :
                     IDS_CONFOLD_ERROR_DELETE_ACTIVE_MULTI,
                 MB_ICONEXCLAMATION);
        }
    }


Exit:

#endif
    TraceError("HrOnCommandDelete", hr);
    return hr;
}

HRESULT HrCreateShortcutWithPath(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf,
    PCWSTR                  pszDir)
{
    HRESULT         hr              = S_OK;
    LPDATAOBJECT    pdtobj          = NULL;
    LPITEMIDLIST *  apidlInternal   = NULL;
    ULONG           cidlInternal    = 0;
    DWORD           dwLoop          = 0;

    if (cidl > 0)
    {
        apidlInternal = new LPITEMIDLIST[cidl];
        if (apidlInternal)
        {
            for (;dwLoop < cidl; dwLoop++)
            {
                apidlInternal[cidlInternal++] = apidl[dwLoop];
            }

            hr = psf->GetUIObjectOf(
                hwndOwner,
                cidlInternal,
                (LPCITEMIDLIST *) apidlInternal,
                IID_IDataObject,
                NULL,
                (LPVOID *) &pdtobj);
            if (SUCCEEDED(hr))
            {
                SHCreateLinks(hwndOwner, pszDir, pdtobj,
                              SHCL_USEDESKTOP | SHCL_USETEMPLATE | SHCL_CONFIRM,
                              NULL);

                ReleaseObj(pdtobj);
            }

            delete apidlInternal;
        }
    }

    TraceError("HrCreateShortcutWithPath", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandCreateShortcut
//
//  Purpose:    Command handler for the CMIDM_CREATE_SHORTCUT command.
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   13 Mar 1998
//
//  Notes:
//
HRESULT HrOnCommandCreateShortcut(
    LPITEMIDLIST *          apidl,
    ULONG                   cidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT         hr              = S_OK;

    hr = HrCreateShortcutWithPath(  apidl,
                                    cidl,
                                    hwndOwner,
                                    psf,
                                    NULL);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandCreateShortcut");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\ishellf.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S H E L L F . C P P
//
//  Contents:   IShellFolder implementation for CUPnPDeviceFolder
//              Implemention of CUPnPDeviceFoldPidl
//
//  Notes:      The IShellFolder interface is used to manage folders within
//              the namespace. Objects that support IShellFolder are
//              usually created by other shell folder objects, with the root
//              object (the Desktop shell folder) being returned from the
//              SHGetDesktopFolder function.
//
//  Author:     jeffspr   22 Sep 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <upscmn.h>
#include "tfind.h"
#include "clist.h"
#include "clistndn.h"

#include "tconst.h"

CUPnPDeviceFoldPidl::CUPnPDeviceFoldPidl()
{
    // if these change, the UPNPUI_PIDL_HEADER structure
    // above needs to change to be the right size
    // Why we used 4 different types, I don't know...
    Assert(2 == sizeof(WORD));
    Assert(2 == sizeof(USHORT));
    Assert(4 == sizeof(DWORD));
    Assert(4 == sizeof(ULONG));

    m_pszName = NULL;
    m_pszUrl = NULL;
    m_pszUdn = NULL;
    m_pszType = NULL;
    m_pszDesc = NULL;
}


CUPnPDeviceFoldPidl::~CUPnPDeviceFoldPidl()
{
    if (m_pszName)
    {
        delete [] m_pszName;
    }

    if (m_pszUrl)
    {
        delete [] m_pszUrl;
    }

    if (m_pszUdn)
    {
        delete [] m_pszUdn;
    }

    if (m_pszType)
    {
        delete [] m_pszType;
    }

    if (m_pszDesc)
    {
        delete [] m_pszDesc;
    }
}


HRESULT
CUPnPDeviceFoldPidl::HrInit(FolderDeviceNode * pDeviceNode)
{
    Assert(!m_pszName);
    Assert(!m_pszUrl);
    Assert(!m_pszUdn);
    Assert(!m_pszType);
    Assert(!m_pszDesc);

    Assert(pDeviceNode);
    Assert(pDeviceNode->pszDisplayName);
    Assert(pDeviceNode->pszPresentationURL);
    Assert(pDeviceNode->pszUDN);
    Assert(pDeviceNode->pszType);

    HRESULT hr;

    LPWSTR  pszName;
    LPWSTR  pszUrl;
    LPWSTR  pszUdn;
    LPWSTR  pszType;
    LPWSTR  pszDesc;

    ULONG   cchName;
    ULONG   cchUrl;
    ULONG   cchUdn;
    ULONG   cchType;
    ULONG   cchDesc;

    hr = E_OUTOFMEMORY;

    pszName = NULL;
    pszUrl = NULL;
    pszUdn = NULL;
    pszType = NULL;
    pszDesc  = NULL;

    // Get the size of the name, and tack on a trailing NULL (since we now
    // have something else in the buffer behind it.
    //
    cchName = lstrlenW(pDeviceNode->pszDisplayName);
    pszName = new WCHAR [cchName + 1];
    if (!pszName)
    {
        goto Cleanup;
    }

    cchUrl = lstrlenW(pDeviceNode->pszPresentationURL);
    pszUrl = new WCHAR [cchUrl + 1];
    if (!pszUrl)
    {
        goto Cleanup;
    }

    cchUdn = lstrlenW(pDeviceNode->pszUDN);
    pszUdn = new WCHAR [cchUdn + 1];
    if (!pszUdn)
    {
        goto Cleanup;
    }

    cchType = lstrlenW(pDeviceNode->pszType);
    pszType = new WCHAR [cchType + 1];
    if (!pszType)
    {
        goto Cleanup;
    }

    cchDesc = lstrlenW(pDeviceNode->pszDescription);
    pszDesc = new WCHAR [cchDesc + 1];
    if (!pszDesc)
    {
        goto Cleanup;
    }

    // everything that can fail has succeeded.

    hr = S_OK;

    // We don't need to check these since we know there's
    // enough room.
    wcscpy(pszName, pDeviceNode->pszDisplayName);
    wcscpy(pszUrl, pDeviceNode->pszPresentationURL);
    wcscpy(pszUdn, pDeviceNode->pszUDN);
    wcscpy(pszType, pDeviceNode->pszType);
    wcscpy(pszDesc, pDeviceNode->pszDescription);

    m_pszName = pszName;
    m_pszUrl = pszUrl;
    m_pszUdn = pszUdn;
    m_pszType = pszType;
    m_pszDesc = pszDesc;

Cleanup:
    if (FAILED(hr))
    {
        if (pszName)
        {
            delete [] pszName;
        }

        if (pszUrl)
        {
            delete [] pszUrl;
        }

        if (pszUdn)
        {
            delete [] pszUdn;
        }

        if (pszType)
        {
            delete [] pszType;
        }

        if (pszDesc)
        {
            delete [] pszDesc;
        }
    }

    Assert(FImplies(SUCCEEDED(hr), pszName));
    Assert(FImplies(SUCCEEDED(hr), pszUrl));
    Assert(FImplies(SUCCEEDED(hr), pszUdn));
    Assert(FImplies(SUCCEEDED(hr), pszType));
    Assert(FImplies(SUCCEEDED(hr), pszDesc));

    return hr;
}


HRESULT
HrCopyUnalignedBytesToNewString(BYTE * pByteData,
                                ULONG cbData,
                                LPWSTR * ppszResult)
{
    Assert(ppszResult);

    HRESULT hr;
    LPWSTR pszResult;
    ULONG cchMax;

    hr = S_OK;
    pszResult = NULL;

    {
        BOOL fInvalid;

        fInvalid = IsBadReadPtr(pByteData, cbData);
        if (fInvalid)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
    }

    if (!cbData || cbData % sizeof(WCHAR))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    cchMax = (cbData / sizeof(WCHAR)) - 1;
    pszResult = new WCHAR [ cchMax + 1 ];
    if (!pszResult)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    ::CopyMemory(pszResult, pByteData, cbData);

    // make sure that the data is null-terminated.
    pszResult[cchMax] = UNICODE_NULL;

Cleanup:
    if (FAILED(hr))
    {
        if (pszResult)
        {
            delete [] pszResult;
            pszResult = NULL;
        }
    }

    *ppszResult = pszResult;

    TraceError("HrCopyUnalignedBytesToNewString", hr);
    return hr;
}


HRESULT
CUPnPDeviceFoldPidl::HrInit(PUPNPDEVICEFOLDPIDL pidl)
{
    Assert(!m_pszName);
    Assert(!m_pszUrl);
    Assert(!m_pszUdn);
    Assert(!m_pszType);
    Assert(!m_pszDesc);

    HRESULT hr;
    UNALIGNED UPNPUI_PIDL_HEADER * puph;

    LPWSTR  pszName;
    LPWSTR  pszUrl;
    LPWSTR  pszUdn;
    LPWSTR  pszType;
    LPWSTR  pszDesc;

    hr = S_OK;
    puph = (UPNPUI_PIDL_HEADER *) pidl;

    pszName = NULL;
    pszUrl = NULL;
    pszUdn = NULL;
    pszType = NULL;
    pszDesc = NULL;

    {
        BOOL fInvalid;

        fInvalid = IsBadReadPtr(pidl, sizeof(UPNPUI_PIDL_HEADER));
        if (fInvalid)
        {
            hr = E_POINTER;
            goto Cleanup;
        }
    }

    // minimal version checking should have happened already,
    // so we just assert that everything is ok here
    //
    Assert(UPNPDEVICEFOLDPIDL_LEADID == puph->uLeadId);
    Assert(UPNPDEVICEFOLDPIDL_TRAILID == puph->uTrailId);

    {
        BYTE * pbString;
        ULONG ulOffset;
        ULONG cb;

        pbString = (BYTE *)pidl;
        ulOffset = puph->ulNameOffset;
        ulOffset += sizeof(UPNPUI_PIDL_HEADER);
        cb = puph->cbName;

        pbString += ulOffset;

        hr = HrCopyUnalignedBytesToNewString(pbString,
                                             cb,
                                             &pszName);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    {
        BYTE * pbString;
        ULONG ulOffset;
        ULONG cb;

        pbString = (BYTE *)pidl;
        ulOffset = puph->ulUrlOffset;
        ulOffset += sizeof(UPNPUI_PIDL_HEADER);
        cb = puph->cbUrl;

        pbString += ulOffset;

        hr = HrCopyUnalignedBytesToNewString(pbString,
                                             cb,
                                             &pszUrl);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    {
        BYTE * pbString;
        ULONG ulOffset;
        ULONG cb;

        pbString = (BYTE *)pidl;
        ulOffset = puph->ulUdnOffset;
        ulOffset += sizeof(UPNPUI_PIDL_HEADER);
        cb = puph->cbUdn;

        pbString += ulOffset;

        hr = HrCopyUnalignedBytesToNewString(pbString,
                                             cb,
                                             &pszUdn);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    {
        BYTE * pbString;
        ULONG ulOffset;
        ULONG cb;

        pbString = (BYTE *)pidl;
        ulOffset = puph->ulTypeOffset;
        ulOffset += sizeof(UPNPUI_PIDL_HEADER);
        cb = puph->cbType;

        pbString += ulOffset;

        hr = HrCopyUnalignedBytesToNewString(pbString,
                                             cb,
                                             &pszType);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    {
        BYTE * pbString;
        ULONG ulOffset;
        ULONG cb;

        pbString = (BYTE *)pidl;
        ulOffset = puph->ulDescOffset;
        ulOffset += sizeof(UPNPUI_PIDL_HEADER);
        cb = puph->cbDesc;

        pbString += ulOffset;

        hr = HrCopyUnalignedBytesToNewString(pbString,
                                             cb,
                                             &pszDesc);
        if (FAILED(hr))
        {
            goto Cleanup;
        }
    }

    m_pszName = pszName;
    m_pszUrl = pszUrl;
    m_pszUdn = pszUdn;
    m_pszType = pszType;
    m_pszDesc = pszDesc;

Cleanup:
    if (FAILED(hr))
    {
        if (pszName)
        {
            delete [] pszName;
        }

        if (pszUrl)
        {
            delete [] pszUrl;
        }

        if (pszUdn)
        {
            delete [] pszUdn;
        }

        if (pszType)
        {
            delete [] pszType;
        }

        if (pszDesc)
        {
            delete [] pszDesc;
        }
    }

    Assert(FImplies(SUCCEEDED(hr), pszName));
    Assert(FImplies(SUCCEEDED(hr), pszUrl));
    Assert(FImplies(SUCCEEDED(hr), pszUdn));
    Assert(FImplies(SUCCEEDED(hr), pszType));
    Assert(FImplies(SUCCEEDED(hr), pszDesc));

    TraceError("CUPnPDeviceFoldPidl::HrInit", hr);
    return hr;
}


HRESULT
CUPnPDeviceFoldPidl::HrPersist(IMalloc * pMalloc, LPITEMIDLIST * ppidl)
{
    Assert(m_pszName);
    Assert(m_pszUrl);
    Assert(m_pszUdn);
    Assert(m_pszType);
    Assert(m_pszDesc);
    Assert(pMalloc);
    Assert(ppidl);

    HRESULT hr;

    ULONG cbTotalPidlSize;
    ULONG cbName;
    ULONG cbUrl;
    ULONG cbUdn;
    ULONG cbType;
    ULONG cbDesc;

    ULONG ulNameOffset;
    ULONG ulUrlOffset;
    ULONG ulUdnOffset;
    ULONG ulTypeOffset;
    ULONG ulDescOffset;

    UNALIGNED UPNPUI_PIDL_HEADER * puph;
    LPBYTE pbData;

    hr = S_OK;

    pbData = NULL;

    cbName = wcslen(m_pszName);
    cbName = (cbName + 1) * sizeof(WCHAR);

    cbUrl = wcslen(m_pszUrl);
    cbUrl = (cbUrl + 1) * sizeof(WCHAR);

    cbUdn = wcslen(m_pszUdn);
    cbUdn = (cbUdn + 1) * sizeof(WCHAR);

    cbType = wcslen(m_pszType);
    cbType = (cbType + 1) * sizeof(WCHAR);

    cbDesc = wcslen(m_pszDesc);
    cbDesc = (cbDesc + 1) * sizeof(WCHAR);

    ulNameOffset = 0;
    ulUrlOffset = ulNameOffset + cbName;
    ulUdnOffset = ulUrlOffset + cbUrl;
    ulTypeOffset = ulUdnOffset + cbUdn;
    ulDescOffset = ulTypeOffset + cbType;

    cbTotalPidlSize = sizeof(UPNPUI_PIDL_HEADER);
    cbTotalPidlSize += cbName;
    cbTotalPidlSize += cbUrl;
    cbTotalPidlSize += cbUdn;
    cbTotalPidlSize += cbType;
    cbTotalPidlSize += cbDesc;

    // don't count the PIDL-terminating bytes in the size
    //
    pbData = (BYTE *) pMalloc->Alloc(cbTotalPidlSize +
                                     FIELD_OFFSET(ITEMIDLIST, mkid.cb) + sizeof(USHORT));
    if (!pbData)
    {
        hr = E_OUTOFMEMORY;

        TraceError("CUPnPDeviceFoldPidl::HrPersist: Alloc()", hr);
        goto Cleanup;
    }

    // delegate folder alert: since we're a delete folder, the Alloc() above
    // doesn't just allocate the bytes we asked for, but rather a bunch for our
    // delegate folder prefix, then the bytes we asked for.  We need to skip
    // the prefix bytes and just write to our own.
    puph = (UPNPUI_PIDL_HEADER *)ConvertToUPnPDevicePIDL((ITEMIDLIST*)pbData);

    puph->iCB = cbTotalPidlSize;
    puph->uLeadId = UPNPDEVICEFOLDPIDL_LEADID;
    puph->dwVersion = UP_DEVICE_FOLDER_IDL_VERSION;
    puph->uTrailId = UPNPDEVICEFOLDPIDL_TRAILID;
    puph->uVOID = 0;
    puph->dwCharacteristics = 0;

    puph->ulNameOffset = ulNameOffset;
    puph->cbName = cbName;
    puph->ulUrlOffset = ulUrlOffset;
    puph->cbUrl = cbUrl;
    puph->ulUdnOffset = ulUdnOffset;
    puph->cbUdn = cbUdn;
    puph->ulTypeOffset = ulTypeOffset;
    puph->cbType = cbType;
    puph->ulDescOffset = ulDescOffset;
    puph->cbDesc = cbDesc;

    {
        LPBYTE pbDynamicField;
        LPBYTE pbName;
        LPBYTE pbUrl;
        LPBYTE pbUdn;
        LPBYTE pbType;
        LPBYTE pbDesc;

        // note: this has to be puph (not pbData) because we still
        //       have to skip the "delegate folder prefix" junk.
        pbDynamicField = ((BYTE *)puph) + sizeof(UPNPUI_PIDL_HEADER);
        pbName = pbDynamicField + ulNameOffset;
        pbUrl = pbDynamicField + ulUrlOffset;
        pbUdn = pbDynamicField + ulUdnOffset;
        pbType = pbDynamicField + ulTypeOffset;
        pbDesc = pbDynamicField + ulDescOffset;

        ::CopyMemory(pbName, m_pszName, cbName);
        ::CopyMemory(pbUrl, m_pszUrl, cbUrl);
        ::CopyMemory(pbUdn, m_pszUdn, cbUdn);
        ::CopyMemory(pbType, m_pszType, cbType);
        ::CopyMemory(pbDesc, m_pszDesc, cbDesc);
    }

    {
        // terminate the PIDL
        LPITEMIDLIST pidlNext;

        pidlNext = ILNext((LPITEMIDLIST)puph);

        Assert((FIELD_OFFSET(ITEMIDLIST, mkid.cb) +
               sizeof(pidlNext->mkid.cb)) == sizeof(USHORT));
        pidlNext->mkid.cb = 0;
    }

Cleanup:
    Assert(FImplies(FAILED(hr), !pbData));
    Assert(FImplies(SUCCEEDED(hr), pbData));

    *ppidl = (LPITEMIDLIST)pbData;

    TraceError("CUPnPDeviceFoldPidl::HrPersist", hr);
    return hr;
}


PCWSTR
CUPnPDeviceFoldPidl::PszGetNamePointer() const
{
    return m_pszName;
}


PCWSTR
CUPnPDeviceFoldPidl::PszGetURLPointer() const
{
    return m_pszUrl;
}


PCWSTR
CUPnPDeviceFoldPidl::PszGetUDNPointer() const
{
    return m_pszUdn;
}


PCWSTR
CUPnPDeviceFoldPidl::PszGetTypePointer() const
{
    return m_pszType;
}


PCWSTR
CUPnPDeviceFoldPidl::PszGetDescriptionPointer() const
{
    return m_pszDesc;
}

HRESULT CUPnPDeviceFoldPidl::HrSetName(PCWSTR szName)
{
    HRESULT     hr = S_OK;

    if (szName)
    {
        // Free old name
        delete [] m_pszName;

        // Copy in new name
        m_pszName = WszDupWsz(szName);
        if (!m_pszName)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("CUPnPDeviceFoldPidl::HrSetName", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::HrMakeUPnPDevicePidl
//
//  Purpose:    Private function of the folder object that constructs the
//              UPNP device pidl using the delegated allocator
//
//  Arguments:
//      FolderDeviceNode       [in]     Structure that contains all the
//                                      strings we need for the pidl
//      ppidl                  [out]    The result pidl
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     tongl   15 Feb 2000
//
//  Notes:
//

HRESULT CUPnPDeviceFolder::HrMakeUPnPDevicePidl(FolderDeviceNode * pDeviceNode,
                                                LPITEMIDLIST *  ppidl)
{
    HRESULT hr;
    CUPnPDeviceFoldPidl udfp;

    hr = udfp.HrInit(pDeviceNode);
    if (SUCCEEDED(hr))
    {
        hr = udfp.HrPersist(m_pDelegateMalloc, ppidl);
    }

    return hr;
}

HRESULT CUPnPDeviceFolder::HrMakeUPnPDevicePidl(IUPnPDevice * pDevice,
                                                LPITEMIDLIST *  ppidl)
{
    HRESULT hr = S_OK;
    Assert(pDevice);

    BSTR    bstrUDN             = NULL;
    BSTR    bstrDisplayName     = NULL;
    BSTR    bstrType            = NULL;
    BSTR    bstrPresentationURL = NULL;
    BSTR    bstrDescription     = NULL;

    Assert(pDevice);
    pDevice->AddRef();

    hr = pDevice->get_UniqueDeviceName(&bstrUDN);
    if (SUCCEEDED(hr))
    {
        hr = pDevice->get_FriendlyName(&bstrDisplayName);
        if (SUCCEEDED(hr))
        {
            hr = pDevice->get_Type(&bstrType);
            if (SUCCEEDED(hr))
            {
                hr = pDevice->get_PresentationURL(&bstrPresentationURL);
                if (SUCCEEDED(hr))
                {
                    hr = pDevice->get_Description(&bstrDescription);
                    if (SUCCEEDED(hr))
                    {
                        FolderDeviceNode * pDevNode = new FolderDeviceNode;
                        if (pDevNode)
                        {
                            // the buffers in FolderDeviceNode are MAX_PATH
                            // wide, so we can only copy MAX_PATH - 1 chars
                            // and still have room for the terminating null
                            //
                            CONST SIZE_T cchMax = MAX_PATH - 1;

                            Assert(bstrUDN);
                            wcscpy(pDevNode->pszUDN, L"");
                            wcsncat(pDevNode->pszUDN,(PWSTR)bstrUDN,cchMax);

                            Assert(bstrDisplayName);
                            wcscpy(pDevNode->pszDisplayName, L"");
                            wcsncat(pDevNode->pszDisplayName,(PWSTR)bstrDisplayName,cchMax);

                            Assert(bstrType);
                            wcscpy(pDevNode->pszType, L"");
                            wcsncat(pDevNode->pszType,(PWSTR)bstrType,cchMax);

                            wcscpy(pDevNode->pszPresentationURL, L"");
                            if (bstrPresentationURL)
                            {
                                wcsncat(pDevNode->pszPresentationURL,
                                        (PWSTR)bstrPresentationURL,
                                        cchMax);
                            }

                            wcscpy(pDevNode->pszDescription, L"");
                            if (bstrDescription)
                            {
                                wcsncat(pDevNode->pszDescription,
                                        (PWSTR)bstrDescription,
                                        cchMax);
                            }

                            hr = HrMakeUPnPDevicePidl(pDevNode, ppidl);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        TraceTag(ttidShellFolder, "Failed in pDevice->get_Description from HrMakeUPnPDevicePidl");
                    }
                }
                else
                {
                    TraceTag(ttidShellFolder, "Failed in pDevice->get_PresentationURL from HrMakeUPnPDevicePidl");
                }
            }
            else
            {
                TraceTag(ttidShellFolder, "Failed in pDevice->get_Type from HrMakeUPnPDevicePidl");
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Failed in pDevice->get_FriendlyName from HrMakeUPnPDevicePidl");
        }
    }
    else
    {
        TraceTag(ttidShellFolder, "Failed in pDevice->get_UniqueDeviceName from HrMakeUPnPDevicePidl");
    }

    SysFreeString(bstrUDN);
    SysFreeString(bstrDisplayName);
    SysFreeString(bstrPresentationURL);
    SysFreeString(bstrType);
    SysFreeString(bstrDescription);

    ReleaseObj(pDevice);

    TraceError("CUPnPDeviceFolder::HrMakeUPnPDevicePidl", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::ParseDisplayName
//
//  Purpose:    Translates a file object or folder's display name into an
//              item identifier.
//
//  Arguments:
//      hwndOwner       [in]    Handle of owner window
//      pbcReserved     [in]    Reserved
//      lpszDisplayName [in]    Pointer to diplay name
//      pchEaten        [out]   Pointer to value for parsed characters
//      ppidl           [out]   Pointer to new item identifier list
//      pdwAttributes   [out]   Address receiving attributes of file object
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     tongl  16 Feb 2000
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::ParseDisplayName(
    HWND            hwndOwner,
    LPBC            pbcReserved,
    LPOLESTR        lpszDisplayName,
    ULONG *         pchEaten,
    LPITEMIDLIST *  ppidl,
    ULONG *         pdwAttributes)
{
    TraceTag(ttidShellFolderIface, "CUPnPDeviceFolder::ParseDisplayName");

    HRESULT hr = S_OK;

    // note: this is bogus, but we're doing this all over...
    Assert(lpszDisplayName);
    Assert(ppidl);
    *ppidl = NULL;

    // first, make sure that this is one of our display names:
    //  it must start with c_szDelegateFolderPrefix
    //
    int result;

    result = wcsncmp(lpszDisplayName,
                     c_szDelegateFolderPrefix,
                     c_cchDelegateFolderPrefix);
    if (0 == result)
    {
        LPCWSTR pszUdn = NULL;
        LPITEMIDLIST pidlDevice = NULL;
        FolderDeviceNode * pDeviceNode = NULL;

        // this is OK since lpszDisplayName is an LPOLESTR
        pszUdn = lpszDisplayName + c_cchDelegateFolderPrefix;

        // search our list of devices and try to find a matching UDN
        if (g_CListFolderDeviceNode.FFind(pszUdn, &pDeviceNode))
        {
            Assert(pDeviceNode);

            // yes, this is one of our devices, construct the pidl using
            // the allocator we are given
            hr = HrMakeUPnPDevicePidl(pDeviceNode, &pidlDevice);

            if (SUCCEEDED(hr))
            {
                Assert(pidlDevice);
                *ppidl = pidlDevice;

                if (pdwAttributes)
                {
                    *pdwAttributes = 0;
                }
            }
        }
        else
        {
            // no, we don't have such a device in the list

            // (tongl): try to do a SearchByUDN before we fail the call,
            // as this may be a device discovered by the search from the
            // tray icon, and we are asked for the pidl to create a shortcut.

            BSTR bstrUdn = NULL;
            IUPnPDeviceFinder * pdf = NULL;

            bstrUdn = ::SysAllocString(pszUdn);
            if (bstrUdn)
            {
                hr = CoCreateInstance(CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER,
                                      IID_IUPnPDeviceFinder, (LPVOID *)&pdf);
                if (SUCCEEDED(hr))
                {
                    IUPnPDevice *   pdev = NULL;

                    hr = pdf->FindByUDN(bstrUdn, &pdev);
                    if (S_OK == hr)
                    {
                        hr = HrMakeUPnPDevicePidl(pdev, &pidlDevice);
                        ReleaseObj(pdev);
                    }
                    ReleaseObj(pdf);
                }

                ::SysFreeString(bstrUdn);
            }
            else
            {
                hr = E_OUTOFMEMORY;
                TraceError("CUPnPDeviceFolder::ParseDisplayName: "
                           "SysAllocString", hr);
            }
        }
    }
    else
    {
        TraceTag(ttidShellFolderIface,
                 "CUPnPDeviceFolder::ParseDisplayName: "
                 "passed non-upnp display name");
        hr = E_FAIL;
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CUPnPDeviceFolder::ParseDisplayName");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::EnumObjects
//
//  Purpose:    Determines the contents of a folder by creating an item
//              enumeration object (a set of item identifiers) that can be
//              retrieved using the IEnumIDList interface.
//
//  Arguments:
//      hwndOwner    [in]   Handle of owner window
//      grfFlags     [in]   Items to include in enumeration
//      ppenumIDList [out]  Pointer to IEnumIDList
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::EnumObjects(
    HWND            hwndOwner,
    DWORD           grfFlags,
    LPENUMIDLIST *  ppenumIDList)
{
    HRESULT hr  = NOERROR;

    Assert(ppenumIDList);
    *ppenumIDList = NULL;

    if ((grfFlags & SHCONTF_FOLDERS) && !(grfFlags & SHCONTF_NONFOLDERS))
    {
        // if shell wants to enumerate only folders, we don't return anything
        hr = E_NOTIMPL;
    }
    else
    {
        // Create the IEnumIDList object (CUPnPDeviceFolderEnum)
        //
        hr = CUPnPDeviceFolderEnum::CreateInstance (
                IID_IEnumIDList,
                reinterpret_cast<void**>(ppenumIDList));

        if (SUCCEEDED(hr))
        {
            Assert(*ppenumIDList);

            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            reinterpret_cast<CUPnPDeviceFolderEnum *>(*ppenumIDList)->Initialize(
                m_pidlFolderRoot, this);
        }
        else
        {
            // On all failures, this should be NULL.
            if (*ppenumIDList)
            {
                ReleaseObj(*ppenumIDList);
            }

            *ppenumIDList = NULL;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolder::EnumObjects");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::BindToObject
//
//  Purpose:    Creates an IShellFolder object for a subfolder.
//
//  Arguments:
//      pidl        [in]    Pointer to an ITEMIDLIST
//      pbcReserved [in]    Reserved - specify NULL
//      riid        [in]    Interface to return
//      ppvOut      [out]   Address that receives interface pointer;
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:      We don't need this function, since we don't have subfolders.
//
STDMETHODIMP CUPnPDeviceFolder::BindToObject(
    LPCITEMIDLIST   pidl,
    LPBC            pbcReserved,
    REFIID          riid,
    LPVOID *        ppvOut)
{
    HRESULT hr  = E_NOTIMPL;

    // Note - If we add code here, then we ought to param check pidl
    //
    Assert(pidl);

    *ppvOut = NULL;

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CUPnPDeviceFolder::BindToObject");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::BindToStorage
//
//  Purpose:    Reserved for a future use. This method should
//              return E_NOTIMPL.
//
//  Arguments:
//      pidl        []  Pointer to an ITEMIDLIST
//      pbcReserved []  Reservedspecify NULL
//      riid        []  Interface to return
//      ppvObj      []  Address that receives interface pointer);
//
//  Returns:    E_NOTIMPL always
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::BindToStorage(
    LPCITEMIDLIST   pidl,
    LPBC            pbcReserved,
    REFIID          riid,
    LPVOID *        ppvObj)
{
    HRESULT hr  = E_NOTIMPL;

    // Note - If we add code here, then we ought to param check pidl
    //
    Assert(pidl);

    *ppvObj = NULL;

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "CUPnPDeviceFolder::BindToStorage");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::CompareIDs
//
//  Purpose:    Determines the relative ordering of two file objects or
//              folders, given their item identifier lists.
//
//  Arguments:
//      lParam [in]     Type of comparison to perform
//      pidl1  [in]     Address of ITEMIDLIST structure
//      pidl2  [in]     Address of ITEMIDLIST structure
//
//  Returns:    Returns a handle to a result code. If this method is
//              successful, the CODE field of the status code (SCODE) has
//              the following meaning:
//
//              CODE field          Meaning
//              ----------          -------
//              Less than zero      The first item should precede the second
//                                  (pidl1 < pidl2).
//              Greater than zero   The first item should follow the second
//                                  (pidl1 > pidl2)
//              Zero                The two items are the same (pidl1 = pidl2)
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:      Passing 0 as the lParam indicates sort by name.
//              0x00000001-0x7fffffff are for folder specific sorting rules.
//              0x80000000-0xfffffff are used the system.
//
STDMETHODIMP CUPnPDeviceFolder::CompareIDs(
    LPARAM          lParam,
    LPCITEMIDLIST   pidl1,
    LPCITEMIDLIST   pidl2)
{
    HRESULT                hr            = S_OK;
    PUPNPDEVICEFOLDPIDL    pupdfp1       = NULL;
    PUPNPDEVICEFOLDPIDL    pupdfp2       = NULL;
    CUPnPDeviceFoldPidl    udfp1;
    CUPnPDeviceFoldPidl    udfp2;
    LPCWSTR                psz1;
    LPCWSTR                psz2;
    CONST INT              ciTieBreaker  = -1;
    int                    iCompare      = 0;
    int                    result;

    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::CompareIDs");

    // Make sure that the pidls passed in are our pidls.
    //
    if (!FIsUPnPDeviceFoldPidl(pidl1) || !FIsUPnPDeviceFoldPidl(pidl2))
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    pupdfp1 = ConvertToUPnPDevicePIDL(pidl1);
    pupdfp2 = ConvertToUPnPDevicePIDL(pidl2);

    hr = udfp1.HrInit(pupdfp1);
    if (FAILED(hr))
    {
        goto Exit;
    }

    hr = udfp2.HrInit(pupdfp2);
    if (FAILED(hr))
    {
        goto Exit;
    }

    // We use the following procedure to compare PIDLs:
    //    1. If two UDNs are the same, the PIDLs are the same
    //    2. Otherwise, the PIDLs _must_ be different, and
    //          A. will be sorted based on the desired column
    //          B. If the column text matches, we'll return
    //             ciTieBreaker (-1), so that the PIDLs are
    //             distinguished.
    //

    psz1 = udfp1.PszGetUDNPointer();
    psz2 = udfp2.PszGetUDNPointer();
    Assert(psz1 && psz2);
    result = wcscmp(psz1, psz2);
    if (0 == result)
    {
        // The UDNs match, these are effectively the same PIDL
        TraceTag(ttidShellFolder, "CUPnPDeviceFolder::CompareIDs: "
                 "UDN equal, automatically returning equality");

        iCompare = 0;
    }
    else
    {
        // Sort based on the desired column

        switch(lParam & SHCIDS_COLUMNMASK)
        {
            case ICOL_NAME:
                psz1 = udfp1.PszGetNamePointer();
                psz2 = udfp2.PszGetNamePointer();
                break;

            case ICOL_URL:
                psz1 = udfp1.PszGetURLPointer();
                psz2 = udfp2.PszGetURLPointer();
                break;

            case ICOL_UDN:
                psz1 = udfp1.PszGetUDNPointer();
                psz2 = udfp2.PszGetUDNPointer();
                break;

            case ICOL_TYPE:
                psz1 = udfp1.PszGetTypePointer();
                psz2 = udfp2.PszGetTypePointer();
                break;

            default:
                AssertSz(FALSE, "Sorting on unknown category");
                break;
        }

        Assert(psz1 && psz2);
        iCompare = _wcsicmp(psz1, psz2);

        // Ensure that we don't return equality
        if (0 == iCompare)
        {
            TraceTag(ttidShellFolder, "CUPnPDeviceFolder::CompareIDs: "
                     "UDNs unequal but column-text equal, breaking tie");

            iCompare = ciTieBreaker;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = ResultFromShort(iCompare);
    }

    TraceTag(ttidShellFolder, "CUPnPDeviceFolder::CompareIDs: returning %d", iCompare);
Exit:

    TraceHr(ttidError, FAL, hr, SUCCEEDED(hr), "CUPnPDeviceFolder::CompareIDs");
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::CreateViewObject
//
//  Purpose:    Creates a view object of a folder.
//
//  Arguments:
//      hwndOwner [in]      Handle of owner window
//      riid      [in]      Interface identifier
//      ppvOut    [none]    Reserved
//
//  Returns:    Returns NOERROR if successful or an OLE defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::CreateViewObject(
    HWND        hwndOwner,
    REFIID      riid,
    LPVOID *    ppvOut)
{
    HRESULT hr  = E_NOINTERFACE;

    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::CreateViewObject");

    Assert(ppvOut);

    // Pre-initialize the out param, per OLE guidelines
    //
    *ppvOut = NULL;

    // (tongl) We are a delegate folder now, CreateViewObject is never called.
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetAttributesOf
//
//  Purpose:    Retrieves the attributes that all passed-in objects (file
//              objects or subfolders) have in common.
//
//  Arguments:
//      cidl     [in]   Number of file objects
//      apidl    [in]   Pointer to array of pointers to ITEMIDLIST structures
//      rgfInOut [out]  Address of value containing attributes of the
//                      file objects
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::GetAttributesOf(
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    ULONG *         rgfInOut)
{
    HRESULT             hr              = S_OK;
    ULONG               rgfMask         = 0;
    PUPNPDEVICEFOLDPIDL pupdfp            = NULL;

    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::GetAttributesOf");

    if (cidl > 0)
    {
        // Prepopulate with all values (removed CANCOPY and CANMOVE)
        //
        rgfMask =   /* SFGAO_CANDELETE  | */    // Don't support delete
                    SFGAO_CANRENAME     |
                    SFGAO_CANLINK       |
                    SFGAO_HASPROPSHEET;

        // Disable propsheets for > 1 object
        //
        if (cidl > 1)
        {
            rgfMask &= ~SFGAO_HASPROPSHEET;
        }
    }
    else
    {
        // Apparently, we're called with 0 objects to indicate that we're
        // supposed to return flags for the folder itself, not an individual
        // object. Weird.
        rgfMask = SFGAO_CANCOPY   |
                  SFGAO_CANDELETE |
                  SFGAO_CANMOVE   |
                  SFGAO_CANRENAME;
    }

    if (SUCCEEDED(hr))
    {
        *rgfInOut &= rgfMask;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetUIObjectOf
//
//  Purpose:    Creates a COM object that can be used to carry out actions
//              on the specified file objects or folders, typically, to
//              create context menus or carry out drag-and-drop operations.
//
//  Arguments:
//      hwndOwner [in]      Handle to owner window
//      cidl      [in]      Number of objects specified in apidl
//      apidl     [in]      Pointer to an array of pointers to an ITEMIDLIST
//      riid      [in]      Interface to return
//      prgfInOut [none]    Reserved
//      ppvOut    [out]     Address to receive interface pointer
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::GetUIObjectOf(
    HWND            hwndOwner,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    REFIID          riid,
    UINT *          prgfInOut,
    LPVOID *        ppvOut)
{
    HRESULT hr  = E_NOINTERFACE;

    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::GetUIObjectOf");

    if (cidl >= 1)
    {
        Assert(apidl);
        Assert(apidl[0]);
        Assert(ppvOut);

        if (riid == IID_IDataObject)
        {
            // Need to initialize so the SUCCEEED check below doesn't fail.
            //
            hr = S_OK;
            Assert(m_pidlFolderRoot);

            if (SUCCEEDED(hr))
            {
                Assert(m_pidlFolderRoot);

                // Internal IDataObject impl removed. Replaced with common
                // shell code.
                //
                hr = CIDLData_CreateFromIDArray(m_pidlFolderRoot, cidl, apidl, (IDataObject **) ppvOut);
            }
        }
        else if (riid == IID_IContextMenu)
        {
            // Create our context menu object if only one device is selected
            //

            hr = CUPnPDeviceFolderContextMenu::CreateInstance (
                    IID_IContextMenu,
                    reinterpret_cast<void**>(ppvOut),
                    CMT_OBJECT,
                    hwndOwner,
                    cidl,
                    apidl,
                    this);
            if (SUCCEEDED(hr))
            {
                Assert(*ppvOut);
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }
        else if (riid == IID_IExtractIconA || riid == IID_IExtractIconW)
        {
            if (cidl == 1)
            {
                hr = CUPnPDeviceFolderExtractIcon::CreateInstance (
                        apidl[0],
                        riid,
                        reinterpret_cast<void**>(ppvOut));
                if(SUCCEEDED(hr))
                {
                    hr = reinterpret_cast<CUPnPDeviceFolderExtractIcon *>
                            (*ppvOut)->Initialize((LPITEMIDLIST)apidl[0]);
                }
                if (SUCCEEDED(hr))
                {
                    Assert(*ppvOut);
                }
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }
        else if (riid == IID_IDropTarget)
        {
            // We don't support drag/drop
            //
            hr = E_NOINTERFACE;
        }
        else if (riid == IID_IQueryInfo)
        {
            if (cidl == 1)
            {
                // Create the IQueryInfo interface
                hr = CUPnPDeviceFolderQueryInfo::CreateInstance (
                        IID_IQueryInfo,
                        reinterpret_cast<void**>(ppvOut));

                if (SUCCEEDED(hr))
                {
                    Assert(*ppvOut);

                    reinterpret_cast<CUPnPDeviceFolderQueryInfo *>
                        (*ppvOut)->PidlInitialize((LPITEMIDLIST)apidl[0]);

                    // Normalize return code
                    //
                    hr = NOERROR;
                }
            }
            else
            {
                AssertSz(FALSE, "GetUIObjectOf asked for query info for more than one item!");
                hr = E_NOINTERFACE;
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "CUPnPDeviceFolder::GetUIObjectOf asked for object "
                     "that it didn't know how to create. 0x%08x", riid.Data1);

            hr = E_NOINTERFACE;
        }
    }

    if (FAILED(hr))
    {
        *ppvOut = NULL;
    }

    TraceHr(ttidError, FAL, hr, (hr == E_NOINTERFACE), "CUPnPDeviceFolder::GetUIObjectOf");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrTszToStrRet
//
//  Purpose:    Convert a TCHAR string to a STRRET, depending on the platform
//
//  Arguments:
//      pszName [in]        input string
//      pStrRet [in/out]    output STRRET
//
//  Returns:
//
//  Author:     jeffspr   25 Jan 2000
//
//  Notes:
//
HRESULT HrTszToStrRet(LPCTSTR pszName, STRRET *pStrRet)
{
    HRESULT hr  = S_OK;

#ifdef UNICODE
    pStrRet->uType = STRRET_WSTR;

    // Allocate a new POLESTR block, which the shell can then free,
    // and copy the displayable portion to it.
    //
    hr = HrDupeShellString(
            pszName,
            &pStrRet->pOleStr);
#else
    pStrRet->uType = STRRET_CSTR;
    lstrcpyn(pStrRet->cStr, pszName, celems(pStrRet->cStr));
    hr = S_OK;
#endif

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::GetDisplayNameOf
//
//  Purpose:    Retrieves the display name for the specified file object or
//              subfolder, returning it in a STRRET structure.
//
//  Arguments:
//      pidl   [in]     Pointer to an ITEMIDLIST
//      uFlags [in]     Type of display to return
//      lpName [out]    Pointer to a STRRET structure
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::GetDisplayNameOf(
    LPCITEMIDLIST   pidl,
    DWORD           uFlags,
    LPSTRRET        lpName)
{
    HRESULT                 hr              = S_OK;
    PCWSTR                  pwszStrToCopy   = NULL;
    PTSTR                   pszTemp         = NULL;
    PUPNPDEVICEFOLDPIDL     pupdfp          = NULL;

    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::GetDisplayNameOf");

    Assert(pidl);
    Assert(lpName);

    if (!pidl || !lpName)
    {
        hr = E_INVALIDARG;
    }
    else if (FIsUPnPDeviceFoldPidl(pidl))
    {
        CUPnPDeviceFoldPidl udfp;

        pupdfp = ConvertToUPnPDevicePIDL(pidl);

#ifdef DBG
        // Throw these in here just so I can quickly peek at the values
        // set while I'm dorking around in the debugger.
        //
        DWORD   dwInFolder          = (uFlags & SHGDN_INFOLDER);
        DWORD   dwForAddressBar     = (uFlags & SHGDN_FORADDRESSBAR);
        DWORD   dwForParsing        = (uFlags & SHGDN_FORPARSING);
#endif

        if (uFlags & SHGDN_FORPARSING)
        {
#if 0
            AssertSz(FALSE, "SHGDN_FORPARSING support NYI in GetDisplayNameOf");
#endif
        }

        hr = udfp.HrInit(pupdfp);
        if (SUCCEEDED(hr))
        {
            pwszStrToCopy = udfp.PszGetNamePointer();
            Assert(pwszStrToCopy);

            pszTemp = TszFromWsz(pwszStrToCopy);
            if (!pszTemp)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                hr = HrTszToStrRet(pszTemp, lpName);

                free((PVOID) pszTemp);
            }
        }
    }
    else
    {
        // not a valid connections pidl (neither Win2K nor Win98).
        //
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolder::GetDisplayNameOf");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::SetNameOf
//
//  Purpose:    Changes the name of a file object or subfolder, changing its
//              item identifier in the process.
//
//  Arguments:
//      hwndOwner [in]      Handle of owner window
//      pidl      [in]      Pointer to an ITEMIDLIST structure
//      lpszName  [in]      Pointer to string specifying new display name
//      uFlags    [in]      Type of name specified in lpszName
//      ppidlOut  [out]     Pointer to new ITEMIDLIST
//
//  Returns:    Returns NOERROR if successful or an OLE-defined error
//              value otherwise.
//
//  Author:     jeffspr   18 Oct 1997
//
//  Notes:
//
STDMETHODIMP CUPnPDeviceFolder::SetNameOf(
    HWND            hwndOwner,
    LPCITEMIDLIST   pidl,
    LPCOLESTR       lpszName,
    DWORD           uFlags,
    LPITEMIDLIST *  ppidlOut)
{
    HRESULT             hr = S_OK;
    PUPNPDEVICEFOLDPIDL pupdfp = NULL;

    TraceTag(ttidShellFolderIface, "OBJ: CUPnPDeviceFolder::SetNameOf");

    Assert(hwndOwner);
    Assert(pidl);
    Assert(lpszName);

    if (!pidl && !lpszName)
    {
        hr = E_INVALIDARG;
    }
    else if (!*lpszName)
    {
        hr = S_OK;
    }
    else if (FIsUPnPDeviceFoldPidl(pidl))
    {
        CUPnPDeviceFoldPidl udfp;

        pupdfp = ConvertToUPnPDevicePIDL(pidl);

        hr = udfp.HrInit(pupdfp);
        if (SUCCEEDED(hr))
        {
            // Change the name of the item in the PIDL
            hr = udfp.HrSetName(lpszName);
        }

        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST    pidlOut;

            // Persist the PIDL data to a new PIDL so we can generate an event
            // for it
            hr = udfp.HrPersist(m_pDelegateMalloc, &pidlOut);
            if (SUCCEEDED(hr))
            {
                NAME_MAP *  pnm;

                pnm = new NAME_MAP;
                if (pnm)
                {
                    // Copy the name and UDN to a struct to keep in a list
                    // of mapped UDNs to friendly names.
                    //
                    pnm->szName = TszDupTsz(udfp.PszGetNamePointer());
                    if (!pnm->szName)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        pnm->szUdn = TszDupTsz(udfp.PszGetUDNPointer());
                        if (!pnm->szUdn)
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        else
                        {
                            // Delete the item and re-add it again
                            g_CListNameMap.FDelete(udfp.PszGetUDNPointer());
                            g_CListNameMap.FAdd(pnm);

                            // Notify the shell of the rename
                            GenerateEvent(SHCNE_RENAMEITEM, m_pidlFolderRoot,
                                          pidl, pidlOut);

                            FolderDeviceNode * pDeviceNode;

                            if (g_CListFolderDeviceNode.FFind(pnm->szUdn,
                                                              &pDeviceNode))
                            {
                                // Delete the node's old name and give it the new
                                // one
                                //
                                wcscpy(pDeviceNode->pszDisplayName,
                                       pnm->szName);
                            }
                        }
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if (ppidlOut)
                {
                    *ppidlOut = pidlOut;
                }
                else
                {
                    FreeIDL(pidlOut);
                }
            }
        }
    }
    else
    {
        // not a valid UPnP pidl
        //
        hr = E_INVALIDARG;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CUPnPDeviceFolder::SetNameOf");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\tconst.h ===
#pragma once

#ifndef _CONST_H_
#define _CONST_H_

#define TIMER_NUM           1

#define TIMER_FREQUENCY     (1000 * 60 * 5) /* 5 minutes == 1000 mill * 60 seconds * 5 min */

#define MAX_BALLOON_FIRINGS 12

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\shutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S H U T I L . H
//
//  Contents:   Various shell utilities to be used by the connections folder
//
//  Notes:
//
//  Author:     jeffspr   21 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _SHUTIL_H_
#define _SHUTIL_H_

HRESULT HrDupeShellStringLength(
    PCWSTR     pszInput,
    ULONG      cchInput,
    PWSTR *    ppszOutput);

inline
HRESULT HrDupeShellString(
    PCWSTR     pszInput,
    PWSTR *    ppszOutput)
{
    return HrDupeShellStringLength(pszInput, wcslen(pszInput), ppszOutput);
}

VOID ForceRefresh(HWND hwnd);

VOID GenerateEvent(LONG lEventId, const LPCITEMIDLIST pidlFolder,
                   LPCITEMIDLIST  pidlIn, LPCITEMIDLIST pidlNewIn);

//---[ Menu merging functions ]-----------------------------------------------

VOID MergeMenu(
    HINSTANCE   hinst,
    UINT        idMainMerge,
    UINT        idPopupMerge,
    LPQCMINFO   pqcm);

INT IMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int   idCmdFirst,
    int   idCmdLast);

HRESULT HrGetMenuFromID(
    HMENU   hmenuMain,
    UINT    uID,
    HMENU * phmenu);

HRESULT HrLoadPopupMenu(
    HINSTANCE   hinst,
    UINT        id,
    HMENU *     phmenu);

HRESULT HrShellView_GetSelectedObjects(
    HWND                hwnd,
    LPCITEMIDLIST **    papidlSelection,
    UINT *              lpcidl);

#endif // _SHUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\shutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S H U T I L . C P P
//
//  Contents:   Various shell utilities to be used by the connections shell
//
//  Notes:
//
//  Author:     jeffspr   21 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   HrDupeShellStringLength
//
//  Purpose:    Duplicate a string using SHAlloc, so we can return it to the
//              shell. This is required because the shell typically releases
//              the strings that we pass it (so we need to use their
//              allocator).
//
//  Arguments:
//      pszInput   [in]  String to duplicate
//      cchInput   [in]  Count of characters to copy (not including null term)
//      ppszOutput [out] Return pointer for the newly allocated string.
//
//  Returns:
//
//  Author:     jeffspr   21 Oct 1997
//
//  Notes:
//
HRESULT HrDupeShellStringLength(
    PCWSTR     pszInput,
    ULONG      cchInput,
    PWSTR *    ppszOutput)
{
    HRESULT hr = S_OK;

    Assert(pszInput);
    Assert(ppszOutput);

    ULONG cbString = (cchInput + 1) * sizeof(WCHAR);

    // Allocate a new POLESTR block, which the shell can then free.
    //
    PWSTR pszOutput = (PWSTR) SHAlloc(cbString);

    // If the alloc failed, return E_OUTOFMEMORY
    //
    if (NULL != pszOutput)
    {
        // Copy the memory into the alloc'd block
        //
        CopyMemory(pszOutput, pszInput, cbString);
        pszOutput[cchInput] = 0;
        *ppszOutput = pszOutput;
    }
    else
    {
        *ppszOutput = NULL;
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrDupeShellStringLength");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadPopupMenu
//
//  Purpose:    Load a popup menu as the first child of a loadable parent
//              menu
//
//  Arguments:
//      hinst  [in]     Our instance handle
//      id     [in]     ID of the parent menu
//      phmenu [out]    Return pointer for the popup menu
//
//  Returns:
//
//  Author:     jeffspr   27 Oct 1997
//
//  Notes:
//
HRESULT HrLoadPopupMenu(
    HINSTANCE   hinst,
    UINT        id,
    HMENU *     phmenu)
{
    HRESULT hr          = S_OK;
    HMENU   hmParent    = NULL;
    HMENU   hmPopup     = NULL;

    Assert(id);
    Assert(hinst);
    Assert(phmenu);

    // Load the parent menu
    //
    hmParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (NULL == hmParent)
    {
        AssertSz(FALSE, "Can't load parent menu in HrLoadPopupMenu");
        hr = HrFromLastWin32Error();
    }
    else
    {
        // Load the popup from the parent (first submenu), then
        // remove the parent menu
        //
        hmPopup = GetSubMenu(hmParent, 0);
        RemoveMenu(hmParent, 0, MF_BYPOSITION);
        DestroyMenu(hmParent);
    }

    if (phmenu)
    {
        *phmenu = hmPopup;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrLoadPopupMenu");
    return hr;
}


HRESULT HrGetMenuFromID(
    HMENU   hmenuMain,
    UINT    uID,
    HMENU * phmenu)
{
    HRESULT         hr          = S_OK;
    HMENU           hmenuReturn = NULL;
    MENUITEMINFO    mii = {0};

    Assert(hmenuMain);
    Assert(uID);
    Assert(phmenu);

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.cch    = 0;     // just in case

    if (!GetMenuItemInfo(hmenuMain, uID, FALSE, &mii))
    {
        hr = E_FAIL;
    }
    else
    {
        hmenuReturn = mii.hSubMenu;
    }

    if (phmenu)
    {
        *phmenu = mii.hSubMenu;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetMenuFromID");
    return hr;
}


INT IMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int   idCmdFirst,
    int   idCmdLast)
{
    HRESULT hr      = S_OK;
    int     iCount  = 0;
    int     idTemp  = 0;
    int     idMax   = idCmdFirst;
    HMENU   hmFromId = NULL;

    for (iCount = GetMenuItemCount(hmMerge) - 1; iCount >= 0; --iCount)
    {
        MENUITEMINFO mii = {0};

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_ID | MIIM_SUBMENU;
        mii.cch    = 0;     // just in case
        mii.hSubMenu = NULL;

        if (!GetMenuItemInfo(hmMerge, iCount, TRUE, &mii))
        {
            TraceHr(ttidError, FAL, E_FAIL, FALSE, "GetMenuItemInfo failed in iMergePopupMenus");
            continue;
        }

        hr = HrGetMenuFromID(hmMain, mii.wID, &hmFromId);
        if (SUCCEEDED(hr))
        {
            idTemp = Shell_MergeMenus(
                        hmFromId,
                        mii.hSubMenu,
                        0,
                        idCmdFirst,
                        idCmdLast,
                        MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

            if (idMax < idTemp)
            {
                idMax = idTemp;
            }
        }
        else
        {
            TraceHr(ttidError, FAL, E_FAIL, FALSE, "HrGetMenuFromId failed in iMergePopupMenus");
            continue;
        }
    }

    return idMax;
}


VOID MergeMenu(
    HINSTANCE   hinst,
    UINT        idMainMerge,
    UINT        idPopupMerge,
    LPQCMINFO   pqcm)
{
    HMENU hmMerge   = NULL;
    UINT  idMax     = 0;
    UINT  idTemp    = 0;

    Assert(pqcm);
    Assert(idMainMerge || idPopupMerge);
    Assert(hinst);

    idMax = pqcm->idCmdFirst;

    if (idMainMerge
        && (SUCCEEDED(HrLoadPopupMenu(hinst, idMainMerge, &hmMerge))))
    {
        Assert(hmMerge);

        if (hmMerge)
        {
            idMax = Shell_MergeMenus(
                            pqcm->hmenu,
                            hmMerge,
                            pqcm->indexMenu,
                            pqcm->idCmdFirst,
                            pqcm->idCmdLast,
                            MM_SUBMENUSHAVEIDS);

            DestroyMenu(hmMerge);
        }
    }

    if (idPopupMerge
        && (hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge))) != NULL)
    {
        idTemp = IMergePopupMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast);

        if (idMax < idTemp)
        {
            idMax = idTemp;
        }

        DestroyMenu(hmMerge);
    }

    pqcm->idCmdFirst = idMax;
}

//+---------------------------------------------------------------------------
//
//  Function:   GenerateEvent
//
//  Purpose:    Generate a Shell Notification event.
//
//  Arguments:
//      lEventId   [in]     The event ID to post
//      pidlFolder [in]     Folder pidl
//      pidlIn     [in]     First pidl that we reference
//      pidlNewIn  [in]     If needed, the second pidl.
//
//  Returns:
//
//  Author:     jeffspr   16 Dec 1997
//
//  Notes:
//
VOID GenerateEvent(LONG lEventId, const LPCITEMIDLIST pidlFolder,
                   LPCITEMIDLIST  pidlIn, LPCITEMIDLIST pidlNewIn)
{
    // Build an absolute pidl from the folder pidl + the object pidl
    //
    LPITEMIDLIST pidl = ILCombinePriv(pidlFolder, pidlIn);
    if (pidl)
    {
        // If we have two pidls, call the notify with both
        //
        if (pidlNewIn)
        {
            // Build the second absolute pidl
            //

            LPITEMIDLIST pidlNew = ILCombinePriv(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                // Make the notification, and free the new pidl
                //
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                FreeIDL(pidlNew);
            }
        }
        else
        {
            // Make the single-pidl notification
            //
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }

        // Always refresh, then free the newly allocated pidl
        //
        SHChangeNotifyHandleEvents();
        FreeIDL(pidl);
    }
}

VOID ForceRefresh(HWND hwnd)
{
    LPSHELLBROWSER  psb = FileCabinet_GetIShellBrowser(hwnd);
    LPSHELLVIEW     psv = NULL;

    // Did we get the shellview?
#if 0   // We can't require this, since we may need to refresh without a folder
        // actually being open
    AssertSz(psb, "FileCabinet_GetIShellBrowser failed in ForceRefresh()");
#endif

    if (psb && SUCCEEDED(psb->QueryActiveShellView(&psv)))
    {
        // $$TODO: Flush the connection list
        //

        Assert(psv);
        if (psv)
        {
            psv->Refresh();
            psv->Release();
        }
    }
    else
    {
        // $$TODO: Refresh the connection list.
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   HrShellView_GetSelectedObjects
//
//  Purpose:    Get the selected data objects. We only care about the first
//              one (we'll ignore the rest)
//
//  Arguments:
//      hwnd            [in]    Our window handle
//      papidlSelection [out]   Return array for selected pidls
//      lpcidl          [out]   Count of returned pidls
//
//  Returns:    S_OK if 1 or more items are selected.
//              S_FALSE if 0 items are selected
//              OLE HRESULT otherwise
//
//  Author:     jeffspr   13 Jan 1998
//
//  Notes:
//
HRESULT HrShellView_GetSelectedObjects(
    HWND                hwnd,
    LPCITEMIDLIST **    papidlSelection,
    UINT *              lpcidl)
{
    HRESULT         hr      = S_OK;
    LPCITEMIDLIST * apidl   = NULL;
    UINT            cpidl   = 0;

    // Get the selected object list from the shell
    //
    cpidl = ShellFolderView_GetSelectedObjects(hwnd, &apidl);

    // If the GetSelectedObjects failed, NULL out the return
    // params.
    //
    if (-1 == cpidl)
    {
        cpidl = 0;
        apidl = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // If no items were selected, return S_FALSE
        //
        if (0 == cpidl)
        {
            Assert(!apidl);
            hr = S_FALSE;
        }
    }

    // Fill in the out params
    //
    *papidlSelection = apidl;
    *lpcidl = cpidl;

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "HrShellView_GetSelectedObjects");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\tdevices.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T D E V I C E S . C P P
//
//  Contents:   Device dialog for UPnP Device Tray
//
//  Notes:
//
//  Author:     jeffspr   16 Dec 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <windowsx.h>
#include "tfind.h"
#include "clist.h"
#include "clistndn.h"

extern CComModule _Module;

#include <atlbase.h>
#include <atlwin.h>


//---[ Prototypes ]-----------------------------------------------------------

BOOL CALLBACK DevicePropsGenPageProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam);

HRESULT HrCreateDevicePropertySheets(
    HWND            hwndOwner,
    NewDeviceNode * pNDN);

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDevicePropertySheets
//
//  Purpose:    Bring up the propsheet pages for a selected device
//
//  Arguments:
//      hwndOwner [in]  Our parent window
//      pNDN      [in]  The device info
//
//  Returns:
//
//  Author:     jeffspr   6 Jan 2000
//
//  Notes:
//
HRESULT HrCreateDevicePropertySheets(
    HWND            hwndOwner,
    NewDeviceNode * pNDN)
{
    Assert(pNDN);

    HRESULT         hr                      = S_OK;
    PROPSHEETPAGE   psp[2]                  = {0};
    PROPSHEETHEADER psh                     = {0};
    TCHAR *         szGenPage               = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_GENERAL));

    // Fill in the propsheet info for the General and Advanced pages
    // of the device propsheet dialog
    //
    psp[0].dwSize       = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags      = PSP_USETITLE;
    psp[0].hInstance    = _Module.GetResourceInstance();
    psp[0].pszTemplate  = MAKEINTRESOURCE(IDD_DEVICE_PROPERTIES_GEN);
    psp[0].pszIcon      = NULL;
    psp[0].pfnDlgProc   = (DLGPROC)DevicePropsGenPageProc;
    psp[0].pszTitle     = szGenPage;
    psp[0].lParam       = (LPARAM) pNDN;

    psh.dwSize          = sizeof(PROPSHEETHEADER);
    psh.dwFlags         = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW |
                          PSH_NOCONTEXTHELP | PSH_PROPTITLE;
    psh.hwndParent      = hwndOwner;
    psh.hInstance       = _Module.GetResourceInstance();
    psh.pszIcon         = NULL;
    psh.pszCaption      = pNDN->pszDisplayName;
    psh.nPages          = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp            = (LPCPROPSHEETPAGE) &psp;

    if (PropertySheet(&psh) == -1)
    {
        hr = E_FAIL;
    }

    delete szGenPage;

    return hr;
}

//---[ DevicePropsGenPageProc ]------------------------------------------------
//
//  Dlg Proc for the Discovered Devices dialog
//
//-----------------------------------------------------------------------------

BOOL CALLBACK DevicePropsGenPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static LPPROPSHEETPAGE  pPSP        = NULL;
    static BOOL             fApplyNow   = FALSE;
    HRESULT                 hr          = S_OK;
    int                     iSelection  = 0;
    static NewDeviceNode *  pNDN        = NULL;

    // WM_COMMAND stuff
    static int  iID = 0;
    static HWND hwndCtl= NULL;
    static UINT uiCodeNotify = 0;

    // WM_NOTIFY stuff
    static NMHDR FAR *pnmhdr = NULL;

    switch(message)
    {
        case WM_INITDIALOG:
            pPSP = (LPPROPSHEETPAGE)lParam;
            fApplyNow=FALSE;

            AssertSz(pPSP, "Propsheet page NULL in DevicePropsGenPageProc");

            pNDN = (NewDeviceNode *) pPSP->lParam;
            Assert(pNDN);

            // Fill in the text fields from the device data
            //
            SendDlgItemMessage(hDlg, IDC_TXT_DEVICE_CAPTION, WM_SETTEXT, 0,
                (LPARAM) pNDN->pszDisplayName);
            SendDlgItemMessage(hDlg, IDC_TXT_MODEL_MANUFACTURER, WM_SETTEXT, 0,
                (LPARAM) pNDN->pszManufacturerName);
            SendDlgItemMessage(hDlg, IDC_TXT_MODEL_DESCRIPTION, WM_SETTEXT, 0,
                (LPARAM) pNDN->pszDescription);
            SendDlgItemMessage(hDlg, IDC_TXT_MODEL_NUMBER, WM_SETTEXT, 0,
                (LPARAM) pNDN->pszModelNumber);
            SendDlgItemMessage(hDlg, IDC_TXT_MODEL_NAME, WM_SETTEXT, 0,
                (LPARAM) pNDN->pszModelName);
            SendDlgItemMessage(hDlg, IDC_TXT_LOCATION, WM_SETTEXT, 0,
                (LPARAM) pNDN->pszPresentationURL);

            if(!GetParent(GetParent(hDlg)))
            {
                SetForegroundWindow(GetParent(hDlg));
            }

            // disable cancel button as this is a readonly page
            ::PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0L);

            return FALSE;

        case WM_DESTROY:
            break;

        case WM_COMMAND:
            iID             = GET_WM_COMMAND_ID(wParam, lParam);
            hwndCtl         = GET_WM_COMMAND_HWND(wParam, lParam);
            uiCodeNotify    = (UINT) GET_WM_COMMAND_CMD(wParam, lParam);

            return(FALSE);

        case WM_NOTIFY:
            // See commctrl.h if Chicago's version of WM_NOTIFY changes.
            pnmhdr  = (NMHDR FAR *)lParam;
            iID     = (int) wParam;

            AssertSz(pnmhdr, "Travel Experts");

            switch(pnmhdr->code)
            {
                case PSN_APPLY:
                    break;

                case PSN_KILLACTIVE:
                    // validate here
                    return TRUE;

                case PSN_SETACTIVE:
                    return TRUE;

                case PSN_WIZBACK:
                case PSN_WIZNEXT:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                    break;

                case PSN_RESET:                 // Cancelling dialog
                    break;

                case PSN_HELP:                  // Help button was pressed
    //                dwMailHelpContext = IDH_INTERNET_SEND_DLG;
    //                WinHelp(hDlg, MAIL_HELP_NAME, HELP_CONTEXT, dwMailHelpContext);
                    break;

                // We don't process any of these
                //
                case PSN_GETOBJECT:
                case PSN_TRANSLATEACCELERATOR:
                case PSN_QUERYINITIALFOCUS:
                    break;


                default:
                    // This will break in the future. In my way of thinking, this is good
                    // because it informs us of new functionality that we can support,
                    // so I'll fire this assert.
                    //
                    //AssertSz(FALSE, "Eeeeeeee-gads! Unknown PSN_");
                    break;
        }

        return TRUE;
    }
//
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\tfind.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T F I N D . H
//
//  Contents:   Tray find device callback for UPnP Tray Monitor
//
//  Notes:
//
//  Author:     jeffspr   7 Dec 1999
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _TRAYFIND_H_
#define _TRAYFIND_H_

#include <upnp.h>
#include <upnpshell.h>
#include <upclsid.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>
#include "nsbase.h"
#include <clist.h>

extern CONST WCHAR c_szNetworkNeighborhoodFolderPath[];
extern CONST WCHAR c_szDelegateFolderPrefix[];
extern CONST SIZE_T c_cchDelegateFolderPrefix;

extern CONST TCHAR c_szMainWindowClassName[];
extern CONST TCHAR c_szMainWindowTitle[];

#define WM_USER_TRAYCALLBACK        (WM_USER+1)

struct NAME_MAP
{
    LPTSTR  szUdn;
    LPTSTR  szName;
};

struct NewDeviceNode
{
public:
    NewDeviceNode();
    ~NewDeviceNode();

    PTSTR   pszUDN;
    PTSTR   pszDisplayName;
    PTSTR   pszType;
    PTSTR   pszPresentationURL;
    PTSTR   pszManufacturerName;
    PTSTR   pszModelNumber;
    PTSTR   pszModelName;
    PTSTR   pszDescription;
};


class /* ATL_NO_VTABLE */ CUPnPMonitorDeviceFinderCallback :
    public CComObjectRootEx <CComMultiThreadModel>,
    public IUPnPDeviceFinderCallback
{

public:
    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(GetControllingUnknown(),
                                             &m_pUnkMarshaler);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler->Release();
    }

    IUnknown *m_pUnkMarshaler;

    CUPnPMonitorDeviceFinderCallback();

    ~CUPnPMonitorDeviceFinderCallback();

    DECLARE_NOT_AGGREGATABLE(CUPnPMonitorDeviceFinderCallback)
    DECLARE_GET_CONTROLLING_UNKNOWN()

    BEGIN_COM_MAP(CUPnPMonitorDeviceFinderCallback)
        COM_INTERFACE_ENTRY(IUPnPDeviceFinderCallback)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler)
    END_COM_MAP()

    // *** IUPnPDeviceFinderCallback methods ***
    STDMETHOD(DeviceAdded)(LONG lFindData, IUPnPDevice * pDevice);
    STDMETHOD(DeviceRemoved)(LONG lFindData, BSTR bstrUDN);
    STDMETHOD(SearchComplete)(LONG lFindData);
};

HWND StartUPnPTray();
HRESULT HrInitializeUI();
HRESULT HrInitTrayData();
HRESULT HrSaveTrayData();
HRESULT HrLoadPersistedDevices();
HRESULT HrSavePersistedDevices();
HRESULT HrOpenUPnPRegRoot(HKEY * phkeyRegRoot);

HRESULT HrStartSearch(VOID);

extern IUPnPDeviceFinder *  g_pdfTray;
extern HWND                 g_hwnd;
extern BOOL                 g_fSearchInProgress;


VOID RemoveTrayIcon(HWND hwnd);
HRESULT HrUpdateTrayInfo();
HRESULT HrCreateDeviceNodeFromDevice(IUPnPDevice *pDevice,
                                     NewDeviceNode ** ppNDN);
LPWSTR CreateChangeNotifyString(LPCWSTR pszUdn);


// device cache used by the folder object
//
struct FolderDeviceNode
{
    WCHAR   pszUDN[MAX_PATH];
    WCHAR   pszDisplayName[MAX_PATH];
    WCHAR   pszPresentationURL[MAX_PATH];
    WCHAR   pszType[MAX_PATH];
    WCHAR   pszDescription[MAX_PATH];
    BOOL    fDeleted;
};

class CListFolderDeviceNode;

extern CListFolderDeviceNode    g_CListFolderDeviceNode;
extern CRITICAL_SECTION         g_csFolderDeviceList;

class CListString;
class CListNDN;
class CListNameMap;

// Our full device list.
//
extern CListString          g_CListUDN;
extern CListString          g_CListUDNSearch;
extern CListNameMap         g_CListNameMap;
extern CListNDN             g_CListNewDeviceNode;

#endif // _TRAYFIND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\tfind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T F I N D . C P P
//
//  Contents:   Asynchronous find mechanism for UPnP tray monitor.
//
//  Notes:
//
//  Author:     jeffspr   22 Nov 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <wininet.h>

#include "tfind.h"
#include "clist.h"
#include "clistndn.h"

#include "tconst.h"

extern UINT     g_iTotalBalloons;

CListString         g_CListUDN;
CListString         g_CListUDNSearch;
CListNDN            g_CListNewDeviceNode;
CListNameMap        g_CListNameMap;

BOOL                g_fIconPresent              = FALSE;

// (tongl)
// List of devices currently on the network
// This is the cached device list to show in "My Network Places" folder
CListFolderDeviceNode       g_CListFolderDeviceNode;
CRITICAL_SECTION            g_csFolderDeviceList;

// CLSID_NetworkNeighborhood
CONST WCHAR c_szNetworkNeighborhoodFolderPath[]   = L"::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\";
// CLSID UPnP Delegate Folder - note "," is used for the new parse syntax (guru)
CONST WCHAR c_szUPnPFolderPath[] = L"::{e57ce731-33e8-4c51-8354-bb4de9d215d1},";
CONST WCHAR c_szDelegateFolderPrefix[]            = L"__upnpitem:";
CONST SIZE_T c_cchDelegateFolderPrefix            = celems(c_szDelegateFolderPrefix) - 1;

BOOL CListFolderDeviceNode::FCompare(FolderDeviceNode * pNode, PCWSTR pszUDN)
{
    // see whether UDNs match between two device nodes
    Assert(pNode);
    Assert(pszUDN);
    return (wcscmp(pNode->pszUDN, pszUDN) == 0);
}

BOOL CListNDN::FCompare(NewDeviceNode * pNode, LPCTSTR pszUDN)
{
    // see whether UDNs match between two device nodes
    Assert(pNode);
    Assert(pszUDN);
    return (_tcscmp(pNode->pszUDN, pszUDN) == 0);
}


BOOL CListString::FCompare(LPTSTR pszCurrentNodeString, LPCTSTR pszKey)
{
    // see whether UDNs match between two device nodes
    Assert(pszCurrentNodeString);
    Assert(pszKey);
    return (_tcscmp(pszCurrentNodeString, pszKey) == 0);
}

BOOL CListNameMap::FCompare(NAME_MAP *pnm, LPCTSTR szUdn)
{
    // see whether UDNs match between two device nodes
    Assert(pnm);
    Assert(szUdn);
    return (_tcscmp(pnm->szUdn, szUdn) == 0);
}

TCHAR * BSTRToTsz(BSTR bstrInput)
{
    return TszFromWsz(bstrInput);
}

// The string created is:
// "::CLSID_NetworkNeighborhood\\__upnpitem:UPNP_device_UDN"
//

// The new shell changes
// "::CLSID_NetworkNeighborhood\\::GUID for UPnP Delegate Folder,<parse string>
// <parse string >  __upnpitem:UDN of the device

LPWSTR
CreateChangeNotifyString(LPCWSTR pszUdn)
{
    LPWSTR pszNotifyString;

    pszNotifyString = new WCHAR [ MAX_PATH ];
    if (pszNotifyString)
    {
        Assert((celems(c_szNetworkNeighborhoodFolderPath) +
                celems(c_szDelegateFolderPrefix)) < MAX_PATH);

        CONST SIZE_T cchMax = MAX_PATH
                - (celems(c_szNetworkNeighborhoodFolderPath) * sizeof(WCHAR))
                - (celems(c_szUPnPFolderPath) * sizeof(WCHAR))
                - (celems(c_szDelegateFolderPrefix) * sizeof(WCHAR))
                + 2;  // +2 we have subtracted Three null characters

        // note: we know that the folder path and the prefix can fit
        //       in the MAX_PATH buffer
        wcscpy(pszNotifyString, c_szNetworkNeighborhoodFolderPath);
        wcscat(pszNotifyString, c_szUPnPFolderPath);
        wcscat(pszNotifyString, c_szDelegateFolderPrefix);
        wcsncat(pszNotifyString, pszUdn, cchMax);
    }
    else
    {
        TraceTag(ttidShellFolder, "CreateChangeNotifyString: new failed");
    }

    return pszNotifyString;
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDeviceNode::NewDeviceNode
//
//  Purpose:    Initializes a NewDeviceNode structure.
//
//  Notes:
//

NewDeviceNode::NewDeviceNode()
{
    pszUDN = NULL;
    pszDisplayName = NULL;
    pszType = NULL;
    pszPresentationURL = NULL;
    pszManufacturerName = NULL;
    pszModelName = NULL;
    pszModelNumber = NULL;
    pszDescription = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   NewDeviceNode::~NewDeviceNode
//
//  Purpose:    Deletes a NewDeviceNode structure.
//
//  Author:     donryan 18 Feb 2000
//
//  Notes:      Moved from CUPnPMonitorDeviceFinderCallback::DeviceAdded
//

NewDeviceNode::~NewDeviceNode()
{
    delete pszUDN;
    delete pszDisplayName;
    delete pszType;
    delete pszPresentationURL;
    delete pszManufacturerName;
    delete pszModelName;
    delete pszModelNumber;
    delete pszDescription;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrMapUdnToFriendlyName
//
//  Purpose:    Given a UPnP device and UDN, maps the UDN to a friendly name
//              from the registry if it is present, otherwise falls back to
//              the friendly name from the device
//
//  Arguments:
//      pdev      [in]      UPnP device to check
//      bstrUdn   [in]      UDN of device
//      pbstrName [out]     Returns friendly name of device
//
//  Returns:    S_OK if success, E_OUTOFMEMORY if no memory, or Win32 error
//              code
//
//  Author:     danielwe   2000/10/25
//
//  Notes:
//
HRESULT HrMapUdnToFriendlyName(IUPnPDevice *pdev, BSTR bstrUdn, BSTR *pbstrName)
{
    HRESULT     hr = S_OK;
    NAME_MAP *  pnm = NULL;

    Assert(pbstrName);

    *pbstrName = NULL;

    if (g_CListNameMap.FFind(bstrUdn, &pnm))
    {
        Assert(pnm);

        *pbstrName = SysAllocString(pnm->szName);
        if (!*pbstrName)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // UDN doesn't have a mapping in registry. Fall back to device's
        // friendly name
        //
        hr = pdev->get_FriendlyName(pbstrName);
    }

    TraceError("HrMapUdnToFriendlyName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateDeviceNodeFromDevice
//
//  Purpose:    Utility function to transfer information from device object
//              into NewDeviceNode structure.
//
//  Arguments:
//      pDevice [in]  The device pointer
//      ppNDN   [out] The pointer to the NewDeviceNode pointer.
//
//  Returns:
//
//  Author:     donryan 18 Feb 2000
//
//  Notes:      Moved from CUPnPMonitorDeviceFinderCallback::DeviceAdded
//
HRESULT
HrCreateDeviceNodeFromDevice(
    IUPnPDevice * pDevice,
    NewDeviceNode ** ppNDN
    )
{
    HRESULT hr                      = S_OK;
    BSTR    bstrUDN                 = NULL;
    BSTR    bstrDisplayName         = NULL;
    BSTR    bstrType                = NULL;
    BSTR    bstrPresentationURL     = NULL;
    BSTR    bstrManufacturerName    = NULL;
    BSTR    bstrModelName           = NULL;
    BSTR    bstrModelNumber         = NULL;
    BSTR    bstrDescription         = NULL;
    PTSTR   pszUDN                  = NULL;
    NewDeviceNode * pNDN            = NULL;

    Assert(pDevice);
    Assert(ppNDN);

    hr = pDevice->get_UniqueDeviceName(&bstrUDN);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_UniqueDeviceName");
        goto Exit;
    }

    hr = HrMapUdnToFriendlyName(pDevice, bstrUDN, &bstrDisplayName);
    if (FAILED(hr))
    {
        goto Exit;
    }

    hr = pDevice->get_Type(&bstrType);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_Type");
        goto Exit;
    }

    hr = pDevice->get_PresentationURL(&bstrPresentationURL);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_PresentationURL");
        goto Exit;
    }

    hr = pDevice->get_ManufacturerName(&bstrManufacturerName);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_ManufacturerName");
        goto Exit;
    }

    hr = pDevice->get_ModelName(&bstrModelName);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_ModelName");
        goto Exit;
    }

    hr = pDevice->get_ModelNumber(&bstrModelNumber);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_ModelNumber");
        goto Exit;
    }

    hr = pDevice->get_Description(&bstrDescription);
    if (FAILED(hr))
    {
        TraceTag(ttidShellTray, "Error calling pDevice->get_Description");
        goto Exit;
    }

    // Create a new Device node, copy the strings into it, and add it to the device map
    //
    pNDN = new NewDeviceNode;
    if (pNDN)
    {
        Assert(bstrUDN);
        pNDN->pszUDN = BSTRToTsz(bstrUDN);

        Assert(bstrDisplayName);
        pNDN->pszDisplayName = BSTRToTsz(bstrDisplayName);

        Assert(bstrType);
        pNDN->pszType = BSTRToTsz(bstrType);

        if (bstrPresentationURL)
        {
            pNDN->pszPresentationURL = BSTRToTsz(bstrPresentationURL);
        }
        else
        {
            pNDN->pszPresentationURL = new TCHAR [ 1 ];
            if (pNDN->pszPresentationURL)
            {
                pNDN->pszPresentationURL[0] = TEXT('\0');
            }
        }

        Assert(bstrManufacturerName);
        pNDN->pszManufacturerName = BSTRToTsz(bstrManufacturerName);

        Assert(bstrModelName);
        pNDN->pszModelName = BSTRToTsz(bstrModelName);

        if (bstrModelNumber)
        {
            pNDN->pszModelNumber = BSTRToTsz(bstrModelNumber);
        }
        else
        {
            pNDN->pszModelNumber = new TCHAR [ 1 ];
            if (pNDN->pszModelNumber)
            {
                pNDN->pszModelNumber[0] = TEXT('\0');
            }
        }

        if (bstrDescription)
        {
            pNDN->pszDescription = BSTRToTsz(bstrDescription);
        }
        else
        {
            pNDN->pszDescription = new TCHAR [ 1 ];
            if (pNDN->pszDescription)
            {
                pNDN->pszDescription[0] = TEXT('\0');
            }
        }

        // If they didn't all copy fine, delete them
        //
        if (!(pNDN->pszUDN && pNDN->pszDisplayName &&
            pNDN->pszType && pNDN->pszPresentationURL &&
            pNDN->pszManufacturerName && pNDN->pszModelName &&
            pNDN->pszModelNumber && pNDN->pszDescription))
        {
            hr = E_OUTOFMEMORY;
            delete pNDN;
            pNDN = NULL;
        }
    }
    else
    {
        TraceTag(ttidShellTray, "Could not allocate NewDeviceNode");
        hr = E_OUTOFMEMORY;
    }

Exit:

    // transfer
    *ppNDN = pNDN;

    SysFreeString(bstrUDN);
    SysFreeString(bstrDisplayName);
    SysFreeString(bstrPresentationURL);
    SysFreeString(bstrType);
    SysFreeString(bstrManufacturerName);
    SysFreeString(bstrModelName);
    SysFreeString(bstrModelNumber);
    SysFreeString(bstrDescription);

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrCreateDeviceNodeFromDevice");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrAddFolderDevice
//
//  Purpose:
//
//  Arguments:
//      pDevice
//
//  Returns:
//
//  Author:     tongl   15 Feb 2000
//
//  Notes:
//
HRESULT HrAddFolderDevice(IUPnPDevice * pDevice)
{
    HRESULT hr = S_OK;

    BSTR    bstrUDN                 = NULL;
    BSTR    bstrDisplayName         = NULL;
    BSTR    bstrType                = NULL;
    BSTR    bstrPresentationURL     = NULL;
    BSTR    bstrDescription         = NULL;

    // (tongl) Per cmr, some device property (display name, presentation url)
    // could change on an existing device and this function will be called but
    // the device was not first removed. In this case we need to notify shell
    // to first remove the existing device then add the new one.
    BOOL    fUpdate = FALSE;
    BOOL    fUpdateOldDevice = FALSE;

    // fNewNode - If its really a new device
    // fUpdate  - The device is in MNP but must be updated bcoz device property has 
    //            changed. Note above.
    // fUpdateOldDevice - An old device has sent bye bye and later comes up alive
    //                   with same UDN. We have cached the list of UDNs. 
    //                   

    Assert(pDevice);

    pDevice->AddRef();
    hr = pDevice->get_UniqueDeviceName(&bstrUDN);
    if (SUCCEEDED(hr))
    {
        // If we're doing a search right now, just add this UDN to the list
        // of devices that we've found so far in the search
        //
        if (g_fSearchInProgress)
        {
            if (!g_CListUDNSearch.FAdd(WszDupWsz(bstrUDN)))
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        TraceTag(ttidShellFolder, "Failed in pDevice->get_UniqueDeviceName from HrAddFolderDevice");
    }

    if (SUCCEEDED(hr))
    {
        hr = HrMapUdnToFriendlyName(pDevice, bstrUDN, &bstrDisplayName);
        if (SUCCEEDED(hr))
        {
            hr = pDevice->get_Type(&bstrType);
            if (SUCCEEDED(hr))
            {
                hr = pDevice->get_PresentationURL(&bstrPresentationURL);
                if (SUCCEEDED(hr))
                {
                    hr = pDevice->get_Description(&bstrDescription);
                    if (SUCCEEDED(hr))
                    {
                        BOOL    fNewNode;

                        EnterCriticalSection(&g_csFolderDeviceList);

                        FolderDeviceNode * pNewDevice = NULL;
                        if( g_CListFolderDeviceNode.FFind((PWSTR)bstrUDN, &pNewDevice))
                        {
                            Assert(pNewDevice);

                            fNewNode = FALSE;

                            if (!pNewDevice->fDeleted)
                            {
                                // Only update if friendly name or description
                                // changed.
                                //
                                if ((wcscmp(pNewDevice->pszDescription, bstrDescription)) ||
                                    (wcscmp(pNewDevice->pszDisplayName, bstrDisplayName)))
                                {
                                    fUpdate = TRUE;
                                }
                            }
                            else
                            {
                                fUpdateOldDevice = TRUE;
                            }
                                
                        }
                        else
                        {
                            // truely a new device
                            pNewDevice = new FolderDeviceNode;

                            fNewNode = TRUE;

                            if (!pNewDevice)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }

                        if (pNewDevice)
                        {
                            CONST SIZE_T cchMax = MAX_PATH - 1;

                            pNewDevice->fDeleted = FALSE;

                            Assert(bstrUDN);
                            wcscpy(pNewDevice->pszUDN, L"");
                            wcsncat(pNewDevice->pszUDN,(PWSTR)bstrUDN, cchMax);

                            Assert(bstrDisplayName);
                            wcscpy(pNewDevice->pszDisplayName, L"");
                            wcsncat(pNewDevice->pszDisplayName, bstrDisplayName, cchMax);

                            Assert(bstrType);
                            wcscpy(pNewDevice->pszType, L"");
                            wcsncat(pNewDevice->pszType, (PWSTR)bstrType, cchMax);

                            wcscpy(pNewDevice->pszPresentationURL, L"");
                            if (bstrPresentationURL)
                            {
                                wcsncat(pNewDevice->pszPresentationURL,
                                        (PWSTR)bstrPresentationURL,
                                        cchMax);
                            }

                            wcscpy(pNewDevice->pszDescription, L"");
                            if (bstrDescription)
                            {
                                wcsncat(pNewDevice->pszDescription,
                                        (PWSTR)bstrDescription,
                                        cchMax);
                            }

                            // add to our list if a true new device
                            if (fNewNode)
                            {
                                g_CListFolderDeviceNode.FAdd(pNewDevice);

                                TraceTag(ttidShellFolder, "HrAddFolderDevice: Added %S to g_CListFolderDeviceNode", bstrDisplayName);
                            }
                            else
                            {
                                TraceTag(ttidShellFolder, "HrAddFolderDevice: Modified %S in g_CListFolderDeviceNode", bstrDisplayName);
                            }
                            TraceTag(ttidShellFolder, "HrAddFolderDevice: Now, g_CListFolderDeviceNode has %d elements", g_CListFolderDeviceNode.GetCount());

                        }
                        LeaveCriticalSection(&g_csFolderDeviceList);

                        if (fNewNode || fUpdate || fUpdateOldDevice)
                        {
                            if (SUCCEEDED(hr))
                            {
                                // notify shell to add the new device
                                LPWSTR pszNotifyString;

                                pszNotifyString = CreateChangeNotifyString(bstrUDN);
                                if (pszNotifyString)
                                {
                                    if (fUpdate)
                                    {
                                        TraceTag(ttidShellFolder, "Generating update device event for %S", bstrDisplayName);
                                        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATHW, pszNotifyString, NULL);
                                    }
                                    else
                                    {
                                        // Assert(fNewNode);
                                        // fNewNode or fUpdateOldDevice 
                                        TraceTag(ttidShellFolder, "Generating new device event for %S", bstrDisplayName);
                                        SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, pszNotifyString, NULL);
                                    }

                                    delete [] pszNotifyString;
                                }
                            }
                            else
                            {
                                // Don't make a failure here.
                                //
                                TraceTag(ttidShellFolder, "Couldn't add device to list in CUPnPDeviceFolderDeviceFinderCallback::DeviceAdded");
                            }
                        }
                        else
                        {
                            TraceTag(ttidShellFolder, "Nothing about device %S:%S changed", bstrUDN, bstrDisplayName);
                        }
                    }
                    else
                    {
                        TraceTag(ttidShellFolder, "Failed in get_Description from HrAddFolderDevice");
                    }
                }
                else
                {
                    TraceTag(ttidShellFolder, "Failed in get_PresentationURL from HrAddFolderDevice");
                }
            }
            else
            {
                TraceTag(ttidShellFolder, "Failed in pDevice->get_Type from HrAddFolderDevice");
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Failed in pDevice->get_FriendlyName from HrAddFolderDevice");
        }
    }

    SysFreeString(bstrUDN);
    SysFreeString(bstrDisplayName);
    SysFreeString(bstrPresentationURL);
    SysFreeString(bstrType);
    SysFreeString(bstrDescription);

    pDevice->Release();

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "HrAddFolderDevice");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrDeleteFolderDevice
//
//  Purpose:
//
//  Arguments:
//      szUDN
//
//  Returns:
//
//  Author:     tongl   18 Feb 2000
//
//  Notes:
//

HRESULT HrDeleteFolderDevice(PWSTR  szUDN)
{
    HRESULT hr = S_OK;
    FolderDeviceNode * pDevice = NULL;

    EnterCriticalSection(&g_csFolderDeviceList);
    if (g_CListFolderDeviceNode.FFind(szUDN, &pDevice))
    {
        pDevice->fDeleted = TRUE;
    }
    else
    {
        // can't delete a device that's not in our cache
        TraceTag(ttidShellFolder, "The device to delete is not in the cache: %S.", szUDN);
        hr = E_FAIL;
    }
    LeaveCriticalSection(&g_csFolderDeviceList);

    if (SUCCEEDED(hr))
    {
        // notify shell to delete the device
        LPWSTR pszNotifyString;

        pszNotifyString = CreateChangeNotifyString(szUDN);
        if (pszNotifyString)
        {
            TraceTag(ttidShellFolder, "Delete device event for %S", szUDN);
            SHChangeNotify(SHCNE_DELETE, SHCNF_PATHW, pszNotifyString, NULL);

            delete [] pszNotifyString;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("HrDeleteFolderDevice", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPMonitorDeviceFinderCallback::DeviceAdded
//
//  Purpose:    Our callback for "new device" -- duh. Here we get the
//              important properties, pack them in a struct, and store them
//              in our device list. We'll use this data if the user opens
//              properties on one of the dialogs, or adds shortcuts.
//
//  Arguments:
//      lFindData  [in] Our callback ID
//      pDevice    [in] The device pointer.
//
//  Returns:
//
//  Author:     jeffspr   23 Nov 1999
//
//  Notes:
//
HRESULT CUPnPMonitorDeviceFinderCallback::DeviceAdded(LONG lFindData,
    IUPnPDevice *   pDevice)
{
    HRESULT hr           = S_OK;
    NewDeviceNode * pNDN = NULL;

    Assert(pDevice);
    pDevice->AddRef();

#if DBG

    BSTR bstrUDN = NULL;
    hr = pDevice->get_UniqueDeviceName(&bstrUDN);

    TraceTag(ttidShellTray, "DeviceFinderCallback -- New Device. SearchId: %x, UDN: %S",
             lFindData, bstrUDN);

    SysFreeString(bstrUDN);

#endif // DBG

    BSTR    bstrPresUrl;

    hr = pDevice->get_PresentationURL(&bstrPresUrl);
    if (S_OK == hr)
    {
        URL_COMPONENTS  urlComp = {0};

        TraceTag(ttidShellTray, "Checking if %S is a valid URL...",
                 bstrPresUrl);

        // All we want to do here is verify that the URL is valid. We don't
        // need anything back from this function
        //
        urlComp.dwStructSize = sizeof(URL_COMPONENTS);
        if (!InternetCrackUrl(bstrPresUrl, 0, 0, &urlComp))
        {
            TraceTag(ttidShellTray, "%S is NOT a valid URL!", bstrPresUrl);
            hr = HrFromLastWin32Error();
        }

        SysFreeString(bstrPresUrl);
    }
    else
    {
        hr = E_FAIL;
        TraceError("Device did not have presentation URL!", hr);
    }

    if (SUCCEEDED(hr))
    {
        // (tongl)
        // add the device to our folder device list and notify shell in case folder is open
        hr = HrAddFolderDevice(pDevice);
        if (SUCCEEDED(hr))
        {
            // transfer information from device object
            hr = HrCreateDeviceNodeFromDevice(pDevice, &pNDN);
            if (SUCCEEDED(hr))
            {
                // Assuming we don't already have this device is our list, add it.
                //
                if (!g_CListUDN.FFind(pNDN->pszUDN, NULL))
                {
                    // Add it to the New Device list.
                    //
                    g_CListNewDeviceNode.FAdd(pNDN);

                    // reset the total balloon count
                    g_iTotalBalloons =0;
                }
                else
                {
                    // Cleanup already known device
                    //
                    delete pNDN;
                }
            }
        }
    }

    pDevice->Release();

    if (SUCCEEDED(hr))
    {
        if (!g_fSearchInProgress)
        {
            hr = HrUpdateTrayInfo();
        }
    }

    TraceError("CUPnPMonitorDeviceFinderCallback::DeviceAdded", hr);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPMonitorDeviceFinderCallback::DeviceRemoved
//
//  Purpose:    Device removed notification. NYI
//
//  Arguments:
//      lFindData []
//      bstrUDN   []
//
//  Returns:
//
//  Author:     jeffspr   23 Nov 1999
//
//  Notes:
//
HRESULT CUPnPMonitorDeviceFinderCallback::DeviceRemoved(
    LONG    lFindData,
    BSTR    bstrUDN)
{
    TraceTag(ttidShellTray, "CUPnPMonitorDeviceFinderCallback::DeviceRemoved"
             " lFindData = %x, UDN = %S", lFindData, bstrUDN);

    Assert(bstrUDN);

    // (tongl)
    // delete the device from our folder device list and notify shell in case folder is open
    HrDeleteFolderDevice((PWSTR)bstrUDN);

    HRESULT hr = S_OK;
    LPTSTR pszUdn;
    BOOL fResult;

    pszUdn = BSTRToTsz(bstrUDN);
    if (!pszUdn)
    {
        TraceTag(ttidShellTray, "Could not copy UDN to TCHAR");
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // search through new device list for new node, removing any nodes
    // with matching UDNs
    //
    fResult = g_CListNewDeviceNode.FDelete(pszUdn);
    if (!fResult)
    {
        // node wasn't deleted

        TraceTag(ttidShellTray, "CUPnPMonitorDeviceFinderCallback::DeviceRemoved: "
                 "%S not found in g_CListNewDeviceNode", pszUdn);
    }

    // update tray information if search has completed
    if (!g_fSearchInProgress)
    {
        hr = HrUpdateTrayInfo();
    }
    else
    {
        // search is still running so delete this from the search list
        fResult = g_CListUDNSearch.FDelete(pszUdn);
        if (!fResult)
        {
            // node wasn't deleted

            TraceTag(ttidShellTray, "CUPnPMonitorDeviceFinderCallback::DeviceRemoved: "
                     "%S not found in g_CListUDNSearch", pszUdn);
        }
    }

Exit:
    delete [] pszUdn;

    TraceError("CUPnPMonitorDeviceFinderCallback::DeviceRemoved", hr);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPMonitorDeviceFinderCallback::SearchComplete
//
//  Purpose:    Search complete. At this point I can add the tray icon
//              if needed and allow for the UI to come up.
//
//  Arguments:
//      lFindData []
//
//  Returns:
//
//  Author:     jeffspr   6 Jan 2000
//
//  Notes:
//
HRESULT CUPnPMonitorDeviceFinderCallback::SearchComplete(LONG lFindData)
{
    TraceTag(ttidShellTray, "CUPnPMonitorDeviceFinderCallback::SearchComplete"
             " lFindData = %x", lFindData);

    HRESULT hr  = S_OK;

    g_fSearchInProgress = FALSE;

    // Add the tray icon and such (if appropriate)
    //
    hr = HrInitializeUI();
    if (SUCCEEDED(hr))
    {
        EnterCriticalSection(&g_csFolderDeviceList);

        FolderDeviceNode * pCurrentNode = NULL;
        BOOL fReturn = g_CListFolderDeviceNode.FFirst(&pCurrentNode);

        // Loop through all UDNs in the cached list of devices we've found
        // and for each one, see if it was found during the search. If not,
        // we should delete it from the folder view and from the cache.
        while (fReturn && SUCCEEDED(hr))
        {
            LPWSTR  szUdn;

            if (!g_CListUDNSearch.FFind(pCurrentNode->pszUDN, &szUdn))
            {
                hr = HrDeleteFolderDevice(pCurrentNode->pszUDN);
                if (SUCCEEDED(hr))
                {
                    if (!g_CListFolderDeviceNode.FDelete(pCurrentNode->pszUDN))
                    {
                        hr = E_FAIL;
                    }
                }
            }

            // move to the next node
            fReturn = g_CListFolderDeviceNode.FNext(&pCurrentNode);
        }

        LeaveCriticalSection(&g_csFolderDeviceList);
    }

    g_CListUDNSearch.Flush();

    TraceError("CUPnPMonitorDeviceFinderCallback::SearchComplete", hr);
    return S_OK;
}

CUPnPMonitorDeviceFinderCallback::CUPnPMonitorDeviceFinderCallback()
{
    m_pUnkMarshaler = NULL;
    TraceTag(ttidShellTray, "CUPnPMonitorDeviceFinderCallback");
}

CUPnPMonitorDeviceFinderCallback::~CUPnPMonitorDeviceFinderCallback()
{
    TraceTag(ttidShellTray, "~CUPnPMonitorDeviceFinderCallback");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\updpidl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C F P I D L . C P P
//
//  Contents:   Connections Folder structures and classes.
//
//  Notes:
//
//  Author:     jeffspr   11 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToUPnPDevicePIDL
//
//  Purpose:    Convert a pidl to UPNPDEVICEFOLDPIDL
//
//  Arguments:
//      pidl []     PIDL to convert
//
//
//  Returns:    The converted pidl
//
//  Author:     tongl   16 Feb 2000
//
//  Notes:
//
//
PUPNPDEVICEFOLDPIDL ConvertToUPnPDevicePIDL(LPCITEMIDLIST pidl)
{
    return reinterpret_cast<PUPNPDEVICEFOLDPIDL>
                            (ILSkip(pidl, FIELD_OFFSET(DELEGATEITEMID, rgb)));
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsUPnPDeviceFoldPidl
//
//  Purpose:    Determine whether a particular PIDL is a UPNPDEVICEFOLDPIDL
//
//  Arguments:
//      pidl []     PIDL to test
//
//
//  Returns:    TRUE if it is a UPNPDEVICEFOLDPIDL, FALSE otherwise
//
//  Author:     jeffspr   24 Oct 1997
//
//  Notes:      tongl 2/16/00: use the ConvertToUPnPDevicePIDL as we are
//              a delegate folder now
//
//
BOOL FIsUPnPDeviceFoldPidl(LPCITEMIDLIST pidl)
{
    BOOL  fReturn    = FALSE;
    if (pidl)
    {
        PUPNPDEVICEFOLDPIDL pudfp = ConvertToUPnPDevicePIDL(pidl);
        UNALIGNED UPNPUI_PIDL_HEADER * puph;

        puph = (UPNPUI_PIDL_HEADER *)pudfp;

        if (puph->iCB >= CBUPNPDEVICEFOLDPIDL_MIN)
        {
            if (puph->uLeadId == UPNPDEVICEFOLDPIDL_LEADID &&
                puph->uTrailId == UPNPDEVICEFOLDPIDL_TRAILID)
            {
                if (UPNPDEVICEFOLDPIDL_MINVER(puph->dwVersion) <=
                        UPNPDEVICEFOLDPIDL_MINVER(UP_DEVICE_FOLDER_IDL_VERSION))
                {
                    fReturn    = TRUE;
                }
                else
                {
                    TraceTag(ttidShellFolder, "Pidl version (0x%x) != UP_DEVICE_FOLDER_IDL_VERSION (0x%x)",
                             puph->dwVersion, UP_DEVICE_FOLDER_IDL_VERSION);
                }
            }
            else
            {
                TraceTag(ttidShellFolder, "Pidl format != connections pidl format. Lead or trail ID not found");
            }
        }
        else
        {
            TraceTag(ttidShellFolder, "Pidl size inconsistent with UPNPDEVICEFOLDPIDL");
        }
    }
    else
    {
        TraceTag(ttidShellFolder, "Pidl NULL in FIsUPnPDeviceFoldPidl");
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\tmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T M A I N . C P P
//
//  Contents:   Main code for UPnP Shell tray object
//
//  Notes:
//
//  Author:     jeffspr   19 Jan 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <upscmn.h>
#include "tfind.h"
#include <ncreg.h>
#include <ncfile.h>
#include <lm.h>

#include "clist.h"
#include "clistndn.h"

#include "tconst.h"

DWORD   g_dwDeviceFinderCookie = 0;
LONG    g_lFindData = 0;

const TCHAR c_szUPnPDeviceList[]        = TEXT("PersistedDeviceUDNs");
const DWORD c_dwTimeout                 = 10000;

CONST TCHAR c_szMainWindowClassName[]   = TEXT("UPnP Notification Monitor");
CONST TCHAR c_szMainWindowTitle[]       = TEXT("UPnP Notification Monitor");
CONST TCHAR c_szNameMap[]               = TEXT("FriendlyNames");

UINT        g_iTotalBalloons    = 0;
BOOL        g_fTrayPresent      = FALSE;
BOOL        g_fCoInitialized    = FALSE;
HWND        g_hwnd              = NULL;
BOOL        g_fDialogLaunched   = FALSE;
BOOL        g_fSearchInProgress = FALSE;

VOID OpenContextMenu(HWND hwnd, POINT * pPoint);
VOID OnTaskBarIconRButtonUp(HWND hwnd);
VOID DeInitTrayData(VOID);

LRESULT CALLBACK DiscoveredDevicesDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

VOID AddTrayIcon(HWND hwnd, INT iDevices, PTSTR szName)
{
    NOTIFYICONDATA  nid = {0};
    INT             iTrayID = IDI_TRAYICON;
    HICON           hiconTray = LoadIcon(_Module.GetResourceInstance(),
                                         MAKEINTRESOURCE(IDI_TRAYICON));
    if (hiconTray)
    {
        nid.uID                 = 0;
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = hwnd;
        nid.uCallbackMessage    = WM_USER_TRAYCALLBACK;
        nid.hIcon               = hiconTray;
        nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_TIP | NIF_INFO;
        nid.uTimeout            = c_dwTimeout;
        nid.dwInfoFlags         = NIIF_INFO;

        TCHAR * szTitle = NULL;
        TCHAR * szInfo = NULL;
        TCHAR * szInstructions = NULL;

        if (iDevices == 1)
        {
            _tcsncpy(nid.szInfoTitle, szName, celems(nid.szInfoTitle));
            nid.szInfoTitle[celems(nid.szInfoTitle) - 1] = TEXT('\0');

            szInfo = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_VIEWINFO_1));
            if(szInfo)
                _tcscpy(nid.szInfo, szInfo);
            else
            {
                TraceTag(ttidShellFolder, "AddTrayIcon:"
                         "Memory Allocation Failed");
            }
        }
        else
        {
            szTitle = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_DEVICES_DISCOVERED));
            if(szTitle)
                _tcscpy(nid.szInfoTitle, szTitle);
            else
            {
                TraceTag(ttidShellFolder, "AddTrayIcon:"
                         "Memory Allocation Failed");
            }

            szInfo = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_VIEWINFO_N));
            if(szInfo)
                _tcscpy(nid.szInfo, szInfo);
            else
            {
                TraceTag(ttidShellFolder, "AddTrayIcon:"
                         "Memory Allocation Failed");
            }
        };

        szInstructions = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_INSTRUCTIONS));
        if(szInstructions)
            _tcscpy(nid.szTip, szInstructions);
        else
        {
            TraceTag(ttidShellFolder, "AddTrayIcon:"
                         "Memory Allocation Failed");
        }

        delete szTitle;
        delete szInfo;
        delete szInstructions;

        g_iTotalBalloons++;
    }

    g_fTrayPresent = Shell_NotifyIcon(NIM_ADD, &nid);
    if (g_fTrayPresent)
    {
        g_fDialogLaunched = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ForceTrayBalloon
//
//  Purpose:    Force the tray balloon to come back up because the user
//              hasn't yet touched it.
//
//  Arguments:
//      hwnd [in]   Our tray window
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
VOID ForceTrayBalloon(HWND hwnd, INT iDevices, PTSTR szName)
{
    NOTIFYICONDATA  nid ={0};

    nid.uID                 = 0;
    nid.cbSize              = sizeof(NOTIFYICONDATA);
    nid.hWnd                = hwnd;
    nid.uFlags              = NIF_INFO;
    nid.uTimeout            = c_dwTimeout;
    nid.dwInfoFlags         = NIIF_INFO;

    TCHAR * szTitle = NULL;
    TCHAR * szInfo = NULL;
    TCHAR * szInstructions = NULL;

    if (iDevices == 1)
    {
        _tcsncpy(nid.szInfoTitle, szName, celems(nid.szInfoTitle));
        nid.szInfoTitle[celems(nid.szInfoTitle) - 1] = TEXT('\0');

        szInfo = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_VIEWINFO_1));
        if(szInfo)
            _tcscpy(nid.szInfo, szInfo);
        else
        {
            TraceTag(ttidShellFolder, "ForceTrayBalloon:"
                         "Memory Allocation Failed");
        }
    }
    else
    {
        szTitle = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_DEVICES_DISCOVERED));
        if(szTitle)
            _tcscpy(nid.szInfoTitle, szTitle);
        else
        {
            TraceTag(ttidShellFolder, "ForceTrayBalloon:"
                         "Memory Allocation Failed");
        }
        szInfo = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_VIEWINFO_N));
        if(szInfo)
            _tcscpy(nid.szInfo, szInfo);
        else
        {
            TraceTag(ttidShellFolder, "ForceTrayBalloon:"
                         "Memory Allocation Failed");
        }
    };

    szInstructions = TszFromWsz(WszLoadIds(IDS_UPNPTRAYUI_INSTRUCTIONS));
    if(szInstructions)
        _tcscpy(nid.szTip, szInstructions);
    else
    {
        TraceTag(ttidShellFolder, "ForceTrayBalloon:"
                       "Memory Allocation Failed");
    }

    delete szTitle;
    delete szInfo;
    delete szInstructions;

    g_iTotalBalloons++;
    g_fTrayPresent = Shell_NotifyIcon(NIM_MODIFY, &nid);
}


//+---------------------------------------------------------------------------
//
//  Function:   RemoveTrayIcon
//
//  Purpose:    Remove the UPNP Monitor icon from the tray. This is done when
//              the devices dialog has gone away.
//
//  Arguments:
//      hwnd [in]   Our tray window
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
VOID RemoveTrayIcon(HWND hwnd)
{
    if (g_fTrayPresent)
    {
        NOTIFYICONDATA  nid = {0};

        nid.uID                 = 0;
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = hwnd;
        nid.uCallbackMessage    = WM_USER_TRAYCALLBACK;
        nid.uFlags              = 0;

        g_fTrayPresent = !(Shell_NotifyIcon(NIM_DELETE, &nid));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateShortcut
//
//  Purpose:    Create a shortcut for the item passed in.
//
//  Arguments:
//      lpszExe  [in] What this is a shortcut to.
//      lpszLink [in] The file location for the shortcut
//      lpszDesc [in] Description (name that will appear)
//
//  Returns:
//
//  Author:     jeffspr   13 Jan 2000
//
//  Notes:
//
HRESULT HrCreateShortcut (HWND hwnd, LPCTSTR lpszLink, LPCTSTR szUdn)
{
    HRESULT         hr  = S_OK;

    IShellFolder *  psfDeskTop = NULL;

    LPWSTR          wszUdn = NULL;
    LPWSTR          wszLink = NULL;

    wszUdn = WszFromTsz(szUdn);
    wszLink = WszFromTsz(lpszLink);

    if (!wszUdn || !wszLink)
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    CoInitialize(NULL);

    // Create a pidl for the connection
    //
    // (tongl 2/16/00): we are now a delegated folder, the pidl must be constructed
    // within the IShellFolder object using the allocator set by IDelegate.
    // We call parseDisplayName giving the UDN to get the absolute pidl
    // (i.e. including the pidl for any parent folders)
    //
    hr = SHGetDesktopFolder(&psfDeskTop);

    if (SUCCEEDED(hr))
    {
        Assert(psfDeskTop);

        LPITEMIDLIST pidlFull = NULL;
        LPWSTR pszNotifyString;

        pszNotifyString = CreateChangeNotifyString(wszUdn);
        if (pszNotifyString)
        {
            hr = psfDeskTop->ParseDisplayName(  NULL,               //  hwndOwner
                                                NULL,               //  pbcReserved
                                                pszNotifyString,    //  lpszDisplayName
                                                NULL,               //  pchEaten,
                                                &pidlFull,          //  ppidl,
                                                NULL                //  pdwAttributes
                                             );

            delete [] pszNotifyString;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            Assert(pidlFull);

            IShellLink *psl = NULL;

            hr = CoCreateInstance(CLSID_ShellLink, NULL,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IShellLink, (LPVOID*)&psl);

            if (SUCCEEDED(hr))
            {
                IPersistFile *ppf = NULL;

                // Set the combined IDL
                //
                hr = psl->SetIDList(pidlFull);
                if (SUCCEEDED(hr))
                {
                    hr = psl->QueryInterface(IID_IPersistFile,
                                             (LPVOID *)&ppf);
                    if (SUCCEEDED(hr))
                    {
                        // Create the link file.
                        //
                        hr = ppf->Save(wszLink, TRUE);

                        ReleaseObj(ppf);
                    }
                }

                ReleaseObj(psl);
            }

            FreeIDL(pidlFull);
        }
        ReleaseObj(psfDeskTop);
    }

    Error:
    free(wszUdn);
    free(wszLink);

    TraceError("HrCreateShortcut", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayViewDevices
//
//  Purpose:    If one new device in the list, bring up dialog to create
//              shortcut. In either case bring up NetworkNeighborhood
//              folder.
//
//  Arguments:
//      hwnd [in]   Our parent hwnd.
//
//  Returns:
//
//  Author:     tongl   25 Feb 2000
//
//  Notes:
//
VOID OnTrayViewDevices(HWND hwnd)
{
    if (g_fDialogLaunched)
        return;

    g_fDialogLaunched = TRUE;
    RemoveTrayIcon(g_hwnd);

    NewDeviceNode * pNDN    = NULL;

    // In any case:
    // 1) persist discovered devices so they don't show as new devices
    // again

    // Walk through the new device list and add them to the known
    // device list
    //
    BOOL fFind = g_CListNewDeviceNode.FFirst(&pNDN);
    while (fFind)
    {
        LPTSTR pszUdn = TszDupTsz(pNDN->pszUDN);
        if (pszUdn)
        {
            BOOL fResult;

            fResult = g_CListUDN.FAdd(pszUdn);
            if (!fResult)
            {
                TraceTag(ttidShellFolder,
                         "OnTrayViewDevices: "
                         "could not add UDN to g_CListUDN");

                delete [] pszUdn;
            }
        }
        else
        {
            TraceTag(ttidShellFolder,
                     "OnTrayViewDevices: "
                     "could not copy UDN");
        }
        fFind = g_CListNewDeviceNode.FNext(&pNDN);
    }

    // save the known device list to registry
    HrSaveTrayData();

    // flush the new devices list
    g_CListNewDeviceNode.Flush();

    // allow tray icons to be added for new devices
    g_fDialogLaunched = FALSE;

    // 2) bring up the folder
    HrOpenSpecialShellFolder(hwnd, CSIDL_NETWORK);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayLButtonDown
//
//  Purpose:    Message processing for an LBUTTONDOWN message on the tray
//              icon
//
//  Arguments:
//      hwnd [in]   Our tray window
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
VOID OnTrayLButtonDown(HWND hwnd)
{
    // Otherwise, launch it.
    //
    OnTrayViewDevices(hwnd);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnTrayLButtonUp
//
//  Purpose:    Message processing for an LBUTTONUP message on the tray icon
//
//  Arguments:
//      hwnd [in]   Our tray window
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
VOID OnTrayLButtonUp(HWND hwnd)
{
    // Remove the tray icon since we're loading the dialog box and won't have
    // any items to display there anymore.
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   ProcessTrayCallback
//
//  Purpose:    Message processing for the tray icon callback messages.
//              Mostly these are button up/down events
//
//  Arguments:
//      hwnd   [in] Our tray window
//      wParam [in] standard tray callback param. see usage below
//      lParam [in] standard tray callback param. see usage below
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
VOID ProcessTrayCallback(
                        HWND    hwnd,
                        WPARAM  wParam,
                        LPARAM  lParam)
{
    UINT    uID         = (UINT) wParam;
    UINT    uMouseMsg   = (UINT) lParam;
    DWORD   dwError     = 0;

    switch (uMouseMsg)
    {
        case WM_LBUTTONDOWN:
            OnTrayLButtonDown(hwnd);
            break;

        case WM_LBUTTONUP:
            OnTrayLButtonUp(hwnd);
            break;

        case WM_RBUTTONUP:
            OnTaskBarIconRButtonUp(hwnd);
            break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   MainWindowProc
//
//  Purpose:    Main window for the tray monitor
//
//  Arguments:
//      hwnd   [in] Standard
//      unMsg  [in] Standard
//      wParam [in] Standard
//      lParam [in] Standard
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
LRESULT CALLBACK MainWindowProc (
                                HWND    hwnd,
                                UINT    unMsg,
                                WPARAM  wParam,
                                LPARAM  lParam)
{
    BOOL    fDoDefault = FALSE;
    LRESULT lr = 0;
    HRESULT hr = S_OK;

    switch (unMsg)
    {
        case WM_CREATE:
            g_hwnd = hwnd;

            hr = HrInitTrayData();
            if (SUCCEEDED(hr))
            {
                hr = HrStartSearch();
            }

            break;

        case WM_DESTROY:
            hr = HrSaveTrayData();
            if (SUCCEEDED(hr))
            {
                RemoveTrayIcon(hwnd);
                DeInitTrayData();
            }

            g_hwnd = NULL;

            PostQuitMessage (0);
            break;

        case WM_USER_TRAYCALLBACK:
            ProcessTrayCallback(hwnd, wParam, lParam);
            break;

        default:
            fDoDefault = TRUE;
    }

    if (fDoDefault)
    {
        lr = DefWindowProc (hwnd, unMsg, wParam, lParam);
    }

    return lr;
}

VOID OnTaskBarIconRButtonUp(HWND hwnd)
{
    POINT   pt;

    GetCursorPos(&pt);
    OpenContextMenu(hwnd, &pt);
}

#if (WINVER > 0x0400)
VOID SetIconFocus(HWND hwnd)
{
    NOTIFYICONDATA nid;

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = hwnd;
    nid.uID     = 0;

    Shell_NotifyIcon(NIM_SETFOCUS, &nid);
}
#endif

VOID OpenContextMenu(HWND hwnd, POINT * pPoint)
{
    HRESULT         hr                      = S_OK;
    INT             iCmd                    = 0;
    INT             iMenu                   = 0;
    HMENU           hmenu                   = 0;
    BOOL            fDisconnected           = FALSE;
    INT             iIdCustomMin            = -1;
    INT             iIdCustomMax            = -1;
    BOOL            fBranded                = FALSE;

    // Find the connection info based on the tray icon id.
    //
    hmenu = LoadMenu(_Module.GetResourceInstance(),
                     MAKEINTRESOURCE(POPUP_TRAY));
    if (hmenu)
    {
        // Get the first menu from the popup. For some reason, this hack is
        // required instead of tracking on the outside menu
        //
        HMENU   hmenuTrack  = GetSubMenu(hmenu, 0);

        // Set the default menu item
        //
        SetMenuDefaultItem(hmenuTrack, CMIDM_TRAY_VIEW_DEVICES, FALSE);

        // Set the owner window to be foreground as a hack so the
        // popup menu disappears when the user clicks elsewhere.
        //
        SetForegroundWindow(hwnd);

        // Part of the above hack. Bring up the menu and figure out the result
        iCmd = TrackPopupMenu(hmenuTrack, TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON,
                              pPoint->x, pPoint->y, 0, hwnd, NULL);
        DestroyMenu(hmenu);

        MSG msgTmp;
        while (PeekMessage(&msgTmp, hwnd, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
        {
            DispatchMessage(&msgTmp);
        }

        // Process the command
        //
        switch (iCmd)
        {
            case CMIDM_TRAY_VIEW_DEVICES:
                // (TongL) - per design change 2/22/00
                OnTrayViewDevices(hwnd);
                break;

                // Tray menu cancelled without selection
                //
            case 0:
                break;

                // Unknown command
                //
            default:
                break;
        }

        // Shift the focus back to the shell
        //
#if (WINVER > 0x0400)
        SetIconFocus(hwnd);
#endif
    }
}

HWND StartUPnPTray()
{
    WNDCLASSEX  wcex;

    // Register our window class.
    //
    ZeroMemory (&wcex, sizeof(wcex));
    wcex.cbSize        = sizeof(wcex);
    wcex.style         = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc   = MainWindowProc;
    wcex.hInstance     = _Module.GetResourceInstance();
    wcex.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszClassName = c_szMainWindowClassName;

    if (RegisterClassEx (&wcex))
    {
        // Create our main window.
        //
        HWND hwnd;

        hwnd = CreateWindowEx (
                              0,
                              c_szMainWindowClassName,
                              c_szMainWindowTitle,
                              WS_OVERLAPPEDWINDOW,
                              0, 0, 0, 0,
                              NULL,
                              NULL,
                              _Module.GetResourceInstance(),
                              NULL);
        if (hwnd)
        {
            ShowWindow (hwnd, SW_HIDE);

            return hwnd;
        }
    }

    return NULL;
}

HRESULT HrRegisterInGit(IUnknown *punk, DWORD *pdwCookie)
{
    HRESULT     hr = S_OK;

    IGlobalInterfaceTable * pgit;

    pgit = NULL;

    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IGlobalInterfaceTable,
                          (LPVOID*)&pgit);
    if (SUCCEEDED(hr))
    {
        hr = pgit->RegisterInterfaceInGlobal(punk, IID_IUPnPDeviceFinder,
                                             pdwCookie);

        pgit->Release();
    }

    TraceError("HrRegisterInGit", hr);
    return hr;
}

HRESULT HrGetDeviceFinderFromGit(IUPnPDeviceFinder **ppdf)
{
    HRESULT     hr = S_OK;

    IGlobalInterfaceTable * pgit;

    pgit = NULL;

    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IGlobalInterfaceTable,
                          (LPVOID*)&pgit);
    if (SUCCEEDED(hr))
    {
        hr = pgit->GetInterfaceFromGlobal(g_dwDeviceFinderCookie,
                                          IID_IUPnPDeviceFinder,
                                          (LPVOID *)ppdf);

        pgit->Release();
    }

    TraceError("HrGetDeviceFinderFromGit", hr);
    return hr;
}

VOID UnregisterInGit(DWORD dwCookie)
{
    HRESULT     hr = S_OK;

    IGlobalInterfaceTable * pgit;

    pgit = NULL;

    hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IGlobalInterfaceTable,
                          (LPVOID*)&pgit);
    if (SUCCEEDED(hr))
    {
        hr = pgit->RevokeInterfaceFromGlobal(dwCookie);

        pgit->Release();
    }

    TraceError("HrUnregisterInGit", hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInitTrayData
//
//  Purpose:    Load the tray data during app (or service) startup
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   9 Dec 1999
//
//  Notes:
//
HRESULT HrInitTrayData()
{
    HRESULT hr = HrLoadPersistedDevices();

    Assert(!g_dwDeviceFinderCookie);

    if (!g_fCoInitialized)
    {
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
        if (SUCCEEDED(hr))
        {
            g_fCoInitialized = TRUE;

            IUPnPDeviceFinder * pdfTray = NULL;

            hr = CoCreateInstance(CLSID_UPnPDeviceFinder,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IUPnPDeviceFinder,
                                 (void **)&pdfTray);
            if (SUCCEEDED(hr))
            {
                hr = HrRegisterInGit(pdfTray, &g_dwDeviceFinderCookie);

                pdfTray->Release();
            }
        }
    }

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrInitTrayData");
    return hr;
}

VOID DeInitTrayData()
{
    g_CListFolderDeviceNode.Flush();
    g_CListNewDeviceNode.Flush();
    g_CListUDN.Flush();
    g_CListNameMap.Flush();

    UnregisterInGit(g_dwDeviceFinderCookie);

    if (g_fCoInitialized)
    {
        CoUninitialize();
    }
}

HRESULT HrStartSearch()
{
    HRESULT     hr = S_OK;

    if (!g_fSearchInProgress && g_dwDeviceFinderCookie)
    {
        CComObject<CUPnPMonitorDeviceFinderCallback> * pCallback = NULL;

        TraceTag(ttidShellTray, "DeviceFinderCallback created. Turn on "
                 "thread id tracing to get useful info");

        IUPnPDeviceFinderCallback * pudfc           = NULL;

        pCallback->CreateInstance(&pCallback);
        hr = pCallback->QueryInterface(IID_IUPnPDeviceFinderCallback,
                                       (LPVOID *)&pudfc);
        if (S_OK == hr)
        {
            // Find the devices
            //
            BSTR    bstrFind    = NULL;

            hr = HrSysAllocString(L"upnp:rootdevice", &bstrFind);
            if (SUCCEEDED(hr))
            {
                LONG                lFindData = 0;
                IUPnPDeviceFinder * pdfTray = NULL;

                hr = HrGetDeviceFinderFromGit(&pdfTray);
                if (SUCCEEDED(hr))
                {
                    if (g_lFindData)
                    {
                        // Cancel outstanding search first
                        hr = pdfTray->CancelAsyncFind(g_lFindData);
                    }
                    if (SUCCEEDED(hr))
                    {
                        hr = pdfTray->CreateAsyncFind(bstrFind, 0, pudfc, &g_lFindData);
                        if (SUCCEEDED(hr))
                        {
                            g_fSearchInProgress = TRUE;
                            hr = pdfTray->StartAsyncFind(g_lFindData);
                            if (FAILED(hr))
                            {
                                g_fSearchInProgress = FALSE;
                            }

                            // This has been handed off to the device finder now
                            ReleaseObj(pudfc);
                        }
                    }

                    ReleaseObj(pdfTray);
                }

                ::SysFreeString(bstrFind);
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            TraceError("Failed to create callback object in "
                       "StartUPnPFind", hr);
        }
    }
    else
    {
        TraceTag(ttidShellTray, "Not starting search again since we are already"
                 " searching...");
    }

    TraceError("HrStartSearch", hr);
    return hr;
}

HRESULT HrSaveTrayData()
{
    HRESULT hr = HrSavePersistedDevices();

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrSaveTrayData");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOpenUPnPRegRoot
//
//  Purpose:    Open the UPnP registry root, and return it to the caller
//
//  Arguments:
//      phkeyRegRoot [out]   Return var for HKEY
//
//  Returns:
//
//  Author:     jeffspr   13 Dec 1999
//
//  Notes:
//
HRESULT HrOpenUPnPRegRoot(HKEY * phkeyRegRoot)
{
    HRESULT hr              = S_OK;
    HKEY    hkeyRegRoot     = NULL;
    DWORD   dwDisposition   = 0;

    hr = HrRegCreateKeyEx(
                         HKEY_CURRENT_USER,
                         c_szUPnPRegRoot,
                         REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS,
                         NULL,
                         &hkeyRegRoot,
                         &dwDisposition);
    if (SUCCEEDED(hr))
    {
        *phkeyRegRoot = hkeyRegRoot;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInputUDNListFromRegistry
//
//  Purpose:    Import UDN lists from registry.
//
//  Arguments:
//      hkeyList [in]   HKEY to read from
//      pszValue [in]   Registry value to load
//      pCList   [in]   CList to populate
//
//  Returns:
//
//  Author:     jeffspr   18 Jan 2000
//
//  Notes:
//
HRESULT HrInputUDNListFromRegistry(HKEY hkeyList,
                                   LPCTSTR pszValue,
                                   CListString * pCList)
{
    HRESULT hr          = S_OK;
    LPBYTE  pbDevices   = NULL;
    DWORD   dwSize      = 0;
    DWORD   dwType      = REG_MULTI_SZ;

    Assert(hkeyList);
    Assert(pszValue);
    Assert(pCList);

    // Query the multi-sz from our registry location.
    //
    hr = HrRegQueryValueWithAlloc (
                                  hkeyList,
                                  pszValue,
                                  &dwType,
                                  &pbDevices,
                                  &dwSize);
    if (SUCCEEDED(hr))
    {
        // Walk through the multi-sz and copy into our UDN list
        //
        TCHAR * pszIterate = (TCHAR *) pbDevices;
        while (pszIterate[0] != TEXT('\0'))
        {
            pCList->FAdd(TszDupTsz(pszIterate));
            pszIterate += (_tcslen(pszIterate) + 1);
        }

        delete pbDevices;
    }
    else
    {
        // Ignore this, just means that we don't have any devices listed yet.
        //
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            hr = S_OK;
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInputNameMapFromRegistry
//
//  Purpose:    Reads the mapping between UDN and friendly name from the
//              registry into the given list
//
//  Arguments:
//      hkeyParent [in]     Parent HKEY of UPnP
//      pCList     [in out] List to add items to
//
//  Returns:    S_OK if success, E_OUTOFMEMORY if no memory, Win32 error
//              otherwise
//
//  Author:     danielwe   2000/10/25
//
//  Notes:
//
HRESULT HrInputNameMapFromRegistry(HKEY hkeyParent, CListNameMap * pCList)
{
    HRESULT hr = S_OK;
    HKEY    hkey;

    Assert(hkeyParent);
    Assert(pCList);

    hr = HrRegOpenKeyEx(hkeyParent, c_szNameMap, KEY_READ, &hkey);
    if (SUCCEEDED(hr))
    {
        WCHAR   szValueName[MAX_PATH];
        WCHAR   szValueData[MAX_PATH];
        DWORD   cbValueName;
        DWORD   cbValueData;
        DWORD   dwIndex = 0;
        DWORD   dwType;

        do
        {
            cbValueName = MAX_PATH;
            cbValueData = MAX_PATH;

            // Enumerate each value name
            hr = HrRegEnumValue(hkey, dwIndex, szValueName, &cbValueName,
                                &dwType, (LPBYTE)szValueData, &cbValueData);
            if (S_OK == hr)
            {
                NAME_MAP *  pnm;

                pnm = new NAME_MAP;
                if (pnm)
                {
                    pnm->szName = TszDupTsz(szValueData);
                    if (!pnm->szName)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    pnm->szUdn = TszDupTsz(szValueName);
                    if (!pnm->szUdn)
                    {
                        hr = E_OUTOFMEMORY;
                        break;
                    }

                    pCList->FAdd(pnm);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            ++dwIndex;
        } while (S_OK == hr);

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkey);
    }

    TraceError("HrInputNameMapFromRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSaveNameMapToRegistry
//
//  Purpose:    Persists the in-memory mapping of UDN to friendly name into
//              the registry
//
//  Arguments:
//      hkeyParent [in]     Parent HKEY of UPnP
//      pCList     [in out] List to add items to
//
//  Returns:    S_OK if success, E_OUTOFMEMORY if no memory, Win32 error
//              otherwise
//
//  Author:     danielwe   2000/10/25
//
//  Notes:
//
HRESULT HrSaveNameMapToRegistry(HKEY hkeyParent, CListNameMap * pCList)
{
    HRESULT hr = S_OK;
    HKEY    hkey;

    Assert(hkeyParent);
    Assert(pCList);

    hr = HrRegCreateKeyEx(hkeyParent, c_szNameMap, 0, KEY_ALL_ACCESS, NULL,
                          &hkey, NULL);
    if (SUCCEEDED(hr))
    {
        BOOL        fRet;
        NAME_MAP *  pnm;

        fRet = pCList->FFirst(&pnm);
        while (fRet && SUCCEEDED(hr))
        {
            hr = HrRegSetSz(hkey, pnm->szUdn, pnm->szName);
            fRet = pCList->FNext(&pnm);
        }


        RegCloseKey(hkey);
    }

    TraceError("HrSaveNameMapToRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadPersistedDevices
//
//  Purpose:    Load the persisted device list out of the registry
//              and populate our linked lists before we start the
//              UPnP device finder.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   9 Dec 1999
//
//  Notes:
//
HRESULT HrLoadPersistedDevices()
{
    HRESULT hr              = S_OK;
    HKEY    hkeyRegRoot     = NULL;

    hr = HrOpenUPnPRegRoot(&hkeyRegRoot);
    if (SUCCEEDED(hr))
    {
        hr = HrInputUDNListFromRegistry(hkeyRegRoot, c_szUPnPDeviceList, &g_CListUDN);
        if (SUCCEEDED(hr))
        {
            hr = HrInputNameMapFromRegistry(hkeyRegRoot, &g_CListNameMap);
        }
    }

    RegSafeCloseKey(hkeyRegRoot);

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrLoadPersistedDevices");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSaveUDNListToRegistry
//
//  Purpose:    Save a PTSTR CList object to a multi-sz in the given key
//
//  Arguments:
//      hkeyList [in] Reg key to write to
//      pszValue [in] Reg value name
//      pCList   [in] List object to process
//
//  Returns:
//
//  Author:     jeffspr   19 Jan 2000
//
//  Notes:
//
HRESULT HrSaveUDNListToRegistry(HKEY hkeyList,
                                LPCTSTR pszValue,
                                CListString * pCList)
{
    HRESULT hr              = S_OK;
    DWORD   dwStringSize    = 0;
    LPTSTR  pszFind         = NULL;
    LPBYTE  pbBuffer        = NULL;

    BOOL fReturn = pCList->FFirst(&pszFind);
    while (fReturn)
    {
        dwStringSize += (_tcslen(pszFind) + 1);
        fReturn = pCList->FNext(&pszFind);
    }

    // If there aren't any items, then we need at least a trailing NULL
    //
    if (dwStringSize == 0)
    {
        dwStringSize++;
    }

    pbBuffer = new BYTE[(dwStringSize+1) * sizeof(TCHAR)];
    if (!pbBuffer)
    {
        TraceTag(ttidShellTray, "Failed to allocate blob for persisted device write");
        hr = E_OUTOFMEMORY;
    }
    else
    {
        LPTSTR  pszOffset           = (LPTSTR) pbBuffer;
        DWORD   dwStringUsedTotal   = 0;
        DWORD   dwStringUsedTemp    = 0;

        pszOffset[0] = TEXT('\0');  // just in case we don't add any items

        fReturn = pCList->FFirst(&pszFind);
        while (fReturn)
        {
            dwStringUsedTemp = (_tcslen(pszFind) + 1);
            dwStringUsedTotal += dwStringUsedTemp;

            Assert(dwStringUsedTotal <= dwStringSize);

            _tcscpy(pszOffset, pszFind);
            pszOffset += dwStringUsedTemp;

            // Set the terminating double-NULL
            //
            pszOffset[0] = TEXT('\0');

            // Get the next item from the list.
            //
            fReturn = pCList->FNext(&pszFind);
        }

        // Make sure we cover the minimal case
        //
        if (dwStringUsedTotal == 0)
            dwStringUsedTotal = 1;  // we have at least a double-NULL

        // Save our string back into the registry
        //
        hr = HrRegSetValueEx (
                             hkeyList,
                             pszValue,
                             REG_MULTI_SZ,
                             (const BYTE *)pbBuffer,
                             (dwStringUsedTotal + 1) * sizeof(TCHAR));
    }

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrSaveUDNListToRegistry");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrSavePersistedDevices
//
//  Purpose:    Write our list back to the registry
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   13 Dec 1999
//
//  Notes:
//
HRESULT HrSavePersistedDevices()
{
    HRESULT hr              = S_OK;
    HKEY    hkeyRegRoot     = NULL;

    hr = HrOpenUPnPRegRoot(&hkeyRegRoot);
    if (SUCCEEDED(hr))
    {
        hr = HrSaveUDNListToRegistry(hkeyRegRoot, c_szUPnPDeviceList, &g_CListUDN);
        if (SUCCEEDED(hr))
        {
            hr = HrSaveNameMapToRegistry(hkeyRegRoot, &g_CListNameMap);
        }
    }

    RegSafeCloseKey(hkeyRegRoot);

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrSavePersistedDevices");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsJoinedToDomain
//
//  Purpose:    Returns whether or not the machine is joined to a domain
//
//  Arguments:
//      (none)
//
//  Returns:    TRUE if joined, FALSE if not
//
//  Author:     danielwe   2001/04/16
//
//  Notes:
//
BOOL FIsJoinedToDomain()
{
    LPTSTR                  szDomain;
    NETSETUP_JOIN_STATUS    njs;

    if (NERR_Success == NetGetJoinInformation(NULL, &szDomain, &njs))
    {
        NetApiBufferFree(szDomain);

        return !!(njs == NetSetupDomainName);
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateTrayInfo
//
//  Purpose:    Update the tray as needed. This should get called at the
//              initial SearchComplete and for every new device afterwards
//              to make sure that we have the correct tooltip and add
//              the tray icon again as needed
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
HRESULT HrUpdateTrayInfo()
{
    HRESULT         hr      = S_OK;
    NewDeviceNode * pNDN    = NULL;
    int iElements           = 0;

    // retrieve number of new devices pending...
    iElements = g_CListNewDeviceNode.GetCount();
    BOOL fRet = g_CListNewDeviceNode.FFirst(&pNDN);

    TCHAR szDisplayName[MAX_PATH];
    if (fRet)
    {
        _tcscpy(szDisplayName, TEXT(""));
        _tcsncat(szDisplayName, pNDN->pszDisplayName, MAX_PATH - 1);
    }

    // check if we need to add the tray icon
    if (fRet && (iElements > 0) && (!g_fTrayPresent) && (!g_fDialogLaunched))
    {
        if (!FIsJoinedToDomain())
        {
            AddTrayIcon(g_hwnd, iElements, szDisplayName);
        }
    }
    else if ((iElements == 0) && (g_fTrayPresent))
    {
        // no more devices...
        RemoveTrayIcon(g_hwnd);
    }

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrUpdateTrayInfo");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrInitializeUI
//
//  Purpose:    Initialize the tray
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   28 Jan 2000
//
//  Notes:
//
HRESULT HrInitializeUI()
{
    HRESULT hr = HrUpdateTrayInfo();

    TraceHr(ttidShellTray, FAL, hr, FALSE, "HrInitializeUI");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\updpidl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P D P I D L . H
//
//  Contents:   UP Device Folder structures, classes, and prototypes
//
//  Notes:
//
//  Author:     jeffspr   11 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _UPDPIDL_H_
#define _UPDPIDL_H_

// Max sizes of our pidl fields
//
// $$REVIEW:
//
#define MAX_UPnPDeviceName      MAX_PATH
#define MAX_UPnPURL             MAX_PATH
#define MAX_UPnPUDN             MAX_PATH
#define MAX_UPnPType            MAX_PATH
#define MAX_UPnPDescription     MAX_PATH


typedef LPITEMIDLIST PUPNPDEVICEFOLDPIDL;

// Pidl Version Definition
//
// This defines the version number of the ConFoldPidl structure. When this
// changes, we'll need to invalidate the entries.
//    This has the following format:
//             +-----------+-----------+
//             | HIGH WORD |  LOW WORD |
//             +-----------+-----------+
//               current      lowest
//                 version      version
//    "current version" : the version of the shell code which
//                        created the PIDL
//    "lowest version":   the lowest version of the shell code
//                        which can read the PIDL
//    example: shell code version "1" can read a PIDL marked
//             as "0x00030001" but not one marked as "0x00050003".
//             shell code version "3" can read a PIDL marked
//             as "0x00030001" and get more information from it
//             than a version "1" client.
//
#define UP_DEVICE_FOLDER_IDL_VERSION  0x00010001

class CUPnPDeviceFoldPidl
{
public:
    CUPnPDeviceFoldPidl();
    ~CUPnPDeviceFoldPidl();

    HRESULT HrInit(FolderDeviceNode * pDeviceNode);

    HRESULT HrInit(PUPNPDEVICEFOLDPIDL pPidl);

    HRESULT HrPersist(IMalloc * pMalloc, LPITEMIDLIST * ppidl);

    PCWSTR PszGetNamePointer() const;
    PCWSTR PszGetURLPointer() const;
    PCWSTR PszGetUDNPointer() const;
    PCWSTR PszGetTypePointer() const;
    PCWSTR PszGetDescriptionPointer() const;

    HRESULT HrSetName(PCWSTR szName);

private:
/* this is the structure of our PIDLs, in byte-order.  All
   numbers are saved as big-endian unsigned integers.

    0   1   2   3   4   5   6   7   <- byte
  |   |   |   |   |   |   |   |   |
  +===============================+
  |  iCB  |uLeadId|   dwVersion   |
  +-------------------------------+
  |uTrlId | VOID  | dwUnusedFlags |
  +-------------------------------+
  | ulNameOffset  | cbName        |
  +-------------------------------+
  | ulUrlOffset   | cbUrl         |
  +-------------------------------+
  | ulUdnOffset   | cbUdn         |
  +-------------------------------+
  | ulTypeOffset  | cbType        |
  +-------------------------------+
  | ulDescOffset  | cbDesc        |
  +-------------------------------+
  | set of NULL-terminated        |
  | unicode strings, byte-packed. |
  | The offset and length of a    |
  | given string is specified by  |
  | the headers above...          |
  /                               /
  +-------------------------------+
  |   0   |
  +-------+

  the names in the table above represent
  the following:

   iCB:         Total size of the structure
                (including iCB itself).
                [note: Milennium seems to
                miscalculate this field, always
                storing a value two greater than
                what it really is.  Oops.
                If the "highest version" is
                specified as 1, this bug should
                be assumed.]

   ulLeadId:    Always UPNPDEVICEFOLDPIDL_LEADID

   dwVersion:   the min/max versions of the PIDL,
                as described in "Pidl Version Definition"
                above.
   uTrlId:      Always UPNPDEVICEFOLDPIDL_TRAILID
   VOID:        Not usable - these bytes are garbage
                and can never be used
   dwUnusedFlags: Flags for future use.  These
                are currently always set to zero.

   ulNameOffset,
   ulUrlOffset,
   etc.:        Offset of the string fields stored
                in the variable-length section.  The
                offset given is relative to the start
                of the variable-length section, not
                from the start of the entire structure.

   cbName, cbUrl,
   etc.:        Length, in bytes, of each string in
                the variable-length section.

*/

    LPWSTR  m_pszName;
    LPWSTR  m_pszUrl;
    LPWSTR  m_pszUdn;
    LPWSTR  m_pszType;
    LPWSTR  m_pszDesc;
};

// IMPORTANT: you MUST declare pointers to this structure
//      as UNALIGNED, or using it will break on win64, and
//      cause performance degredation on axp
//
# pragma pack (1)
struct UPNPUI_PIDL_HEADER
{
    WORD    iCB;            // 2 bytes
    USHORT  uLeadId;        // 2 bytes
    DWORD   dwVersion;      // 4 bytes
    USHORT  uTrailId;       // 2 bytes
    USHORT  uVOID;          // 2 bytes
    DWORD   dwCharacteristics;  // 4 bytes

    ULONG   ulNameOffset;   // 4 bytes
    ULONG   cbName;         // etc...
    ULONG   ulUrlOffset;
    ULONG   cbUrl;
    ULONG   ulUdnOffset;
    ULONG   cbUdn;
    ULONG   ulTypeOffset;
    ULONG   cbType;
    ULONG   ulDescOffset;
    ULONG   cbDesc;
};
# pragma pack ()


// One of our pidls must be at least this size, it will likely be bigger.
//
#define CBUPNPDEVICEFOLDPIDL_MIN    sizeof(UPNPUI_PIDL_HEADER)

// More versioning info. This will help me identify PIDLs as being mine
//
#define UPNPDEVICEFOLDPIDL_LEADID     0x6EFF
#define UPNPDEVICEFOLDPIDL_TRAILID    0x7EFF

#define UPNPDEVICEFOLDPIDL_MINVER(x) (LOWORD(x))
#define UPNPDEVICEFOLDPIDL_MAXVER(x) (HIWORD(x))

PUPNPDEVICEFOLDPIDL ConvertToUPnPDevicePIDL(LPCITEMIDLIST pidl);
BOOL    FIsUPnPDeviceFoldPidl(LPCITEMIDLIST pidl);

HRESULT HrMakeUPnPDevicePidl(
    LPWSTR          pszName,
    LPWSTR          pszURL,
    LPWSTR          pszUDN,
    LPWSTR          pszType,
    LPWSTR          pszDescription,
    LPITEMIDLIST *  ppidl);

#endif // _UPDPIDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\upnptray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       U P N P T R A Y . H
//
//  Contents:   Tray code for UPnP
//
//  Notes:
//
//  Author:     jeffspr   20 Jan 2000
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _UPNPTRAY_H_
#define _UPNPTRAY_H_

#include "ncbase.h"
#include "upsres.h"

//---[ UPnP Tray Classes ]----------------------------------------------

class ATL_NO_VTABLE CUPnPTray :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPTray, &CLSID_UPnPMonitor>,
    public IOleCommandTarget
{
private:
    LPITEMIDLIST    m_pidl;
    HWND            m_hwnd;

public:
    CUPnPTray()
    {
        m_pidl = NULL;
        m_hwnd = NULL;
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPTRAY)

    DECLARE_NOT_AGGREGATABLE(CUPnPTray)

    BEGIN_COM_MAP(CUPnPTray)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
    END_COM_MAP()

    // IOleCommandTarget members
    STDMETHODIMP    QueryStatus(
        const GUID *    pguidCmdGroup,
        ULONG           cCmds,
        OLECMD          prgCmds[],
        OLECMDTEXT *    pCmdText);

    STDMETHODIMP    Exec(
        const GUID *    pguidCmdGroup,
        DWORD           nCmdID,
        DWORD           nCmdexecopt,
        VARIANTARG *    pvaIn,
        VARIANTARG *    pvaOut);

    // Handlers for various Exec Command IDs
    //
    HRESULT HrHandleTrayOpen();
    HRESULT HrHandleTrayClose();

};

#endif // _UPNPTRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\upsres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P S R E S . H
//
//  Contents:   Master resource header for upnpfold.dll
//
//  Notes:
//
//  Author:     jeffspr     07 Sep 1999
//
//----------------------------------------------------------------------------

#pragma once

//+---------------------------------------------------------------------------
// Icon resources
//

#define IDI_UPNP_FOLDER                     0

//+---------------------------------------------------------------------------
// Registry resources
//

// UPNP Folder (100-129)
//
#define IDR_UPNPFOLD                        100
#define IDR_UPNPTRAY                        101

//---[ Menus, etc ]------------------------------------------------------------

#define MENU_STANDARD                       200
#define MENU_STANDARD_V                     201

#define MENU_MERGE_UPNPDEVICE               210
#define POPUP_MERGE_UPNPDEVICE              211

#define MENU_MERGE_FOLDER_BACKGROUND        0           // unused
#define POPUP_MERGE_FOLDER_BACKGROUND       220

//---[ Tray resources ]--------------------------------------------------------

// Icons
//
#define IDI_TRAYICON                            300
#define IDI_UPNPDEVICE                          301
#define IDI_UPNP_CAMCORDER                      302 
#define IDI_UPNP_DIGITAL_SECURITY_CAMERA        303
#define IDI_UPNP_DISPLAY_DEVICE                 304
#define IDI_UPNP_INTERNET_GATEWAY               305
#define IDI_UPNP_PRINTER_DEVICE                 306
#define IDI_UPNP_SCANNER_DEVICE                 307
#define IDI_UPNP_AUDIO_PLAYER                   308

// Tray commands
//
#define CMIDM_TRAY_VIEW_DEVICES             5200
//#define CMIDM_TRAY_OPEN_MNP                 5201

// Context menu
//
#define POPUP_TRAY                          5300

// Discovered devices dialog
#define IDD_DEVICE_PROPERTIES               6000
#define IDD_DEVICE_PROPERTIES_GEN           6001

#define IDC_BUTTON_PROPERTIES               6431
#define IDC_BUTTON_DELETE                   6432
#define IDC_CB_CREATE_SHORTCUTS             6433
#define IDC_DEVICE_LIST                     6435
#define IDC_ICON_DEVICE                     6436
#define IDC_PRESENTATION_URL_TEXT           6437
#define IDC_DIVIDE_LINE                     6438

#define IDC_TXT_MODEL_MANUFACTURER          7000
#define IDC_TXT_MODEL_NAME                  7001
#define IDC_TXT_MODEL_NUMBER                7002
#define IDC_TXT_MODEL_DESCRIPTION           7003
#define IDC_TXT_LOCATION                    7004
#define IDC_TXT_DEVICE_CAPTION              7010

#define IDC_STATIC                          -1



//+---------------------------------------------------------------------------
// String resources
//

//---[ Folder strings ]-------------------------------------------------------

// Folder registration strings
//
#define IDS_UPNPFOLD_NAME                   1100
#define IDS_UPNPFOLD_INFOTIP                1101
#define IDS_UPNPDEV_INFOTIP                 1102
#define IDS_LOCAL_NETWORK                   1103

// Connections Folder Toolbar Strings
//
#define IDS_TOOLBAR_INVOKE_STRING           1201

// Strings used by tray related UIs and tooltip/balloon tips
//
#define IDS_UPNPTRAYUI_MANUFACTURER         1301
#define IDS_UPNPTRAYUI_GENERAL              1302
#define IDS_UPNPTRAYUI_WEBDEVICE            1305
#define IDS_UPNPTRAYUI_WEBDEVICES           1306
#define IDS_UPNPTRAYUI_DEVICES_DISCOVERED   1307
#define IDS_UPNPTRAYUI_VIEWINFO_1           1308
#define IDS_UPNPTRAYUI_VIEWINFO_N           1309
#define IDS_UPNPTRAYUI_INSTRUCTIONS             1310
#define IDS_UPNPTRAYUI_SHORTCUT             1311
#define IDS_UPNPTRAYUI_DEVICE_REMOVED       1312
#define IDS_UPNPTRAYUI_DEVICE_OFFLINE_MSG   1313
#define IDS_UPNPTRAYUI_DEVICE_OFFLINE_TITLE  1314

//---[ Commands (context/menus) ]----------------------------------------------

#define CMIDM_FIRST                         0x0000
#define CMIDM_INVOKE                        (CMIDM_FIRST + 0x0001)
#define CMIDM_CREATE_SHORTCUT               (CMIDM_FIRST + 0x0002)
#define CMIDM_DELETE                        (CMIDM_FIRST + 0x0003)
#define CMIDM_RENAME                        (CMIDM_FIRST + 0x0004)
#define CMIDM_PROPERTIES                    (CMIDM_FIRST + 0x0005)

#define CMIDM_ARRANGE                       (CMIDM_FIRST + 0x0026)
#define CMIDM_ARRANGE_BY_NAME               (CMIDM_FIRST + 0x0027)
#define CMIDM_ARRANGE_BY_URL                (CMIDM_FIRST + 0x0028)

// Debug only commands
//
#if DBG
#define CMIDM_DEBUG                         (CMIDM_FIRST + 0x0040)
#define CMIDM_DEBUG_TRACING                 (CMIDM_FIRST + 0x0041)
#define CMIDM_DEBUG_REFRESH                 (CMIDM_FIRST + 0x0042)
#define CMIDM_DEBUG_TESTASYNCFIND           (CMIDM_FIRST + 0x0043)
#endif

//---[ Strings for command ID's (shows in status line) ]-----------------------
//
#define IDS_CMIDM_START                     12000

#define IDS_CMIDM_INVOKE                    (IDS_CMIDM_START + CMIDM_INVOKE)
#define IDS_CMIDM_CREATE_SHORTCUT           (IDS_CMIDM_START + CMIDM_CREATE_SHORTCUT)
#define IDS_CMIDM_DELETE                    (IDS_CMIDM_START + CMIDM_DELETE)
#define IDS_CMIDM_RENAME                    (IDS_CMIDM_START + CMIDM_RENAME)
#define IDS_CMIDM_PROPERTIES                (IDS_CMIDM_START + CMIDM_PROPERTIES)

#define IDS_CMIDM_ARRANGE                   (IDS_CMIDM_START + CMIDM_ARRANGE)
#define IDS_CMIDM_ARRANGE_BY_NAME           (IDS_CMIDM_START + CMIDM_ARRANGE_BY_NAME)
#define IDS_CMIDM_ARRANGE_BY_URL            (IDS_CMIDM_START + CMIDM_ARRANGE_BY_URL)

// Debug only commands
//
#if DBG
#define IDS_CMIDM_DEBUG                     (IDS_CMIDM_START + CMIDM_DEBUG)
#define IDS_CMIDM_DEBUG_TRACING             (IDS_CMIDM_START + CMIDM_DEBUG_TRACING)
#define IDS_CMIDM_DEBUG_REFRESH             (IDS_CMIDM_START + CMIDM_DEBUG_REFRESH)
#define IDS_CMIDM_DEBUG_TESTASYNCFIND       (IDS_CMIDM_START + CMIDM_DEBUG_TESTASYNCFIND)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\upnpfold.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N F O L D . C P P
//
//  Contents:   CUPnPDeviceFolder base functions.
//
//  Notes:
//
//  Author:     jeffspr   18 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

// Map of replaceable items in connfold.rgs file
// this allows us to localize these items
//
struct _ATL_REGMAP_ENTRY g_FolderRegMap[] =
{
    { L"UPNPDeviceFolderName",      NULL },
    { L"UPNPDeviceFolderInfoTip",   NULL },
    { NULL,                         NULL }
};

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::UpdateRegistry
//
//  Purpose:    Apply registry data in upnpfold.rgs
//
//  Arguments:
//      fRegister [in]   Whether to register
//
//  Returns:
//
//  Author:     jeffspr   4 Sep 1999
//
//  Notes:
//
HRESULT WINAPI CUPnPDeviceFolder::UpdateRegistry(BOOL fRegister)
{
    HRESULT hr  = S_OK;

    // Fill in localized strings for the two replaceable parameters
    //
    g_FolderRegMap[0].szData = WszLoadIds(IDS_UPNPFOLD_NAME);
    g_FolderRegMap[1].szData = WszLoadIds(IDS_UPNPFOLD_INFOTIP);

    if (!g_FolderRegMap[0].szData || !g_FolderRegMap[1].szData)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = _Module.UpdateRegistryFromResourceD(
            IDR_UPNPFOLD,
            fRegister,
            g_FolderRegMap);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::CUPnPDeviceFolder
//
//  Purpose:    Constructor for the primary Folder object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CUPnPDeviceFolder::CUPnPDeviceFolder()
{
    m_pidlFolderRoot    = NULL;
    SHGetMalloc(&m_pMalloc);
    m_pDelegateMalloc = NULL;   /* Not delegating yet, use regular malloc */
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::~CUPnPDeviceFolder
//
//  Purpose:    Destructor for the primary folder object
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   18 Mar 1998
//
//  Notes:
//
CUPnPDeviceFolder::~CUPnPDeviceFolder()
{
    if (m_pidlFolderRoot)
        FreeIDL(m_pidlFolderRoot);

    if (m_pMalloc)
        m_pMalloc->Release();

    if (m_pDelegateMalloc)
        m_pDelegateMalloc->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUPnPDeviceFolder::PidlGetFolderRoot
//
//  Purpose:    Return the folder pidl. If NULL at this time, generate
//              the pidl for future usage.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   10 Jan 1999
//
//  Notes:
//
LPITEMIDLIST CUPnPDeviceFolder::PidlGetFolderRoot()
{
    HRESULT hr  = S_OK;

    Assert(m_pidlFolderRoot);
    return m_pidlFolderRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "UPNP Tray Monitor and Folder"
#define VER_INTERNALNAME_STR            "upnpui.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\dll\upnpfold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       U P N P F O L D . H
//
//  Contents:   CUPnPDeviceFolder object definition.
//
//  Notes:
//
//  Author:     jeffspr   03 Sep 1999
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _UPNPFOLD_H_
#define _UPNPFOLD_H_

#include <upnpshell.h>
#include <upclsid.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>
#include "pidlutil.h"
#include "nsbase.h"
#include "upsres.h"
#include "tfind.h"
#include "updpidl.h"
#include "clistndn.h"

//---[ Connection Folder Types ]----------------------------------------------

// The details list view columns.  These are used by the view and
// context menus

enum
{
    ICOL_NAME           = 0,
    ICOL_URL,           // 1
    ICOL_UDN,           // 2
    ICOL_TYPE,          // 3
    ICOL_MAX            // End of list.
};


// The details list view columns.  These are used by the view and
// context menus

typedef struct tagCOLS
{
    short int iColumn;
    short int iStringRes;
    short int iColumnSize;
    short int iFormat;
} COLS;


DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

struct __declspec(uuid("ADD8BA80-002B-11D0-8F0F-00C04FD7D062")) IDelegateFolder;

//---[ Connection Folder Classes ]--------------------------------------------

class ATL_NO_VTABLE CUPnPDeviceFolder :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPDeviceFolder, &CLSID_UPnPDeviceFolder>,
    public IPersistFolder2,
    public IShellExtInit,
    public IShellFolder2,   // includes IShellFolder
    public IDelegateFolder,
    public IOleCommandTarget
{
private:
    LPITEMIDLIST    m_pidlFolderRoot;

    IMalloc *       m_pMalloc;
    IMalloc *       m_pDelegateMalloc;
    UINT            m_cbDelegate;      /* Size of delegate header (0 if not delegating) */

    HRESULT HrMakeUPnPDevicePidl(IUPnPDevice * pdev,
                                 LPITEMIDLIST *  ppidl);

public:

    CUPnPDeviceFolder();
    ~CUPnPDeviceFolder();

    static HRESULT WINAPI UpdateRegistry(BOOL fRegister);

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFolder)

    BEGIN_COM_MAP(CUPnPDeviceFolder)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistFolder)
        COM_INTERFACE_ENTRY(IPersistFolder2)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellFolder)
        // There's no __declspec(uuid(... entry for IShellFolder2, so we need
        // to do this. See: "COM_INTERFACE_ENTRY Macros" in MSDN for more info
        COM_INTERFACE_ENTRY_IID(IID_IShellFolder2, IShellFolder2)
        COM_INTERFACE_ENTRY(IDelegateFolder)
        COM_INTERFACE_ENTRY(IOleCommandTarget)
    END_COM_MAP()

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (
        LPCLSID lpClassID);

    // *** IPersistFolder methods ***
    STDMETHOD(Initialize) (
        LPCITEMIDLIST   pidl);

    // *** IPersistFolder2 methods ***
    STDMETHOD(GetCurFolder) (
        LPITEMIDLIST *ppidl);

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (
        HWND            hwndOwner,
        LPBC            pbcReserved,
        LPOLESTR        lpszDisplayName,
        ULONG *         pchEaten,
        LPITEMIDLIST *  ppidl,
        ULONG *         pdwAttributes);

    STDMETHOD(EnumObjects) (
        HWND            hwndOwner,
        DWORD           grfFlags,
        LPENUMIDLIST *  ppenumIDList);

    STDMETHOD(BindToObject) (
        LPCITEMIDLIST   pidl,
        LPBC            pbcReserved,
        REFIID          riid,
        LPVOID *        ppvOut);

    STDMETHOD(BindToStorage) (
        LPCITEMIDLIST   pidl,
        LPBC            pbcReserved,
        REFIID          riid,
        LPVOID *        ppvObj);

    STDMETHOD(CompareIDs) (
        LPARAM          lParam,
        LPCITEMIDLIST   pidl1,
        LPCITEMIDLIST   pidl2);

    STDMETHOD(CreateViewObject) (
        HWND        hwndOwner,
        REFIID      riid,
        LPVOID *    ppvOut);

    STDMETHOD(GetAttributesOf) (
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        ULONG *         rgfInOut);

    STDMETHOD(GetUIObjectOf) (
        HWND            hwndOwner,
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        REFIID          riid,
        UINT *          prgfInOut,
        LPVOID *        ppvOut);

    STDMETHOD(GetDisplayNameOf) (
        LPCITEMIDLIST   pidl,
        DWORD           uFlags,
        LPSTRRET        lpName);

    STDMETHOD(SetNameOf) (
        HWND            hwndOwner,
        LPCITEMIDLIST   pidl,
        LPCOLESTR       lpszName,
        DWORD           uFlags,
        LPITEMIDLIST *  ppidlOut);

    // *** IShellFolder2 methods ***
    STDMETHOD(GetDefaultSearchGUID) (
        GUID *          pguid);

    STDMETHOD(EnumSearches) (
        IEnumExtraSearch ** ppenum);

    STDMETHOD(GetDefaultColumn) (
        DWORD           dwRes,
        ULONG *         pSort,
        ULONG *         pDisplay);

    STDMETHOD(GetDefaultColumnState) (
        UINT            iColumn,
        DWORD *         pcsFlags);

    STDMETHOD(GetDetailsEx) (
        LPCITEMIDLIST   pidl,
        const SHCOLUMNID *  pscid,
        VARIANT *       pv);

    STDMETHOD(GetDetailsOf) (
        LPCITEMIDLIST   pidl,
        UINT            iColumn,
        SHELLDETAILS *  psd);

    STDMETHOD(MapColumnToSCID) (
        UINT            iColumn,
        SHCOLUMNID *    pscid);

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (
        HWND *  lphwnd);

    STDMETHOD(ContextSensitiveHelp) (
        BOOL    fEnterMode);

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize) (
        LPCITEMIDLIST   pidlFolder,
        LPDATAOBJECT    lpdobj,
        HKEY            hkeyProgID);

    // IOleCommandTarget members
    STDMETHODIMP    QueryStatus(
        const GUID *    pguidCmdGroup,
        ULONG           cCmds,
        OLECMD          prgCmds[],
        OLECMDTEXT *    pCmdText);

    STDMETHODIMP    Exec(
        const GUID *    pguidCmdGroup,
        DWORD           nCmdID,
        DWORD           nCmdexecopt,
        VARIANTARG *    pvaIn,
        VARIANTARG *    pvaOut);

    // *** IDelegateFolder members ***
    STDMETHOD(SetItemAlloc)(
        IMalloc *pmalloc);

    // Other interfaces
    LPITEMIDLIST PidlGetFolderRoot();

    HRESULT HrMakeUPnPDevicePidl(FolderDeviceNode * pDeviceNode,
                                 LPITEMIDLIST *  ppidl);
};

class ATL_NO_VTABLE CUPnPDeviceFolderEnum :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPDeviceFolderEnum, &CLSID_UPnPDeviceEnum>,
    public IEnumIDList
{
private:
    LPITEMIDLIST            m_pidlFolder;

    CListFolderDeviceNode   m_CListDevices;
    DWORD                   m_cDevices;

    DWORD                   m_dwFlags;
    CUPnPDeviceFolder *     m_psf;

    BOOL                    m_fFirstEnumeration;

public:

    CUPnPDeviceFolderEnum();
    ~CUPnPDeviceFolderEnum();

    VOID Initialize(
        LPITEMIDLIST        pidlFolder,
        CUPnPDeviceFolder * psf
        );

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFolderEnum)

    BEGIN_COM_MAP(CUPnPDeviceFolderEnum)
        COM_INTERFACE_ENTRY(IEnumIDList)
    END_COM_MAP()

    // *** IEnumIDList methods ***
    STDMETHOD(Next) (
        ULONG           celt,
        LPITEMIDLIST *  rgelt,
        ULONG *         pceltFetched);

    STDMETHOD(Skip) (
        ULONG   celt);

    STDMETHOD(Reset) ();

    STDMETHOD(Clone) (
        IEnumIDList **  ppenum);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv);

private:
    VOID BuildCurrentDeviceList();
};

struct __declspec(uuid("000214ec-0000-0000-c000-000000000046")) IShellDetails;

class ATL_NO_VTABLE CUPnPDeviceFolderDetails :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPDeviceFolderDetails, &CLSID_UPnPDeviceDetails>,
    public IShellDetails
{
private:
    HWND               m_hwndOwner;

public:
    CUPnPDeviceFolderDetails();
    ~CUPnPDeviceFolderDetails();

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFolderDetails)

    BEGIN_COM_MAP(CUPnPDeviceFolderDetails)
        COM_INTERFACE_ENTRY(IShellDetails)
    END_COM_MAP()

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(
        LPCITEMIDLIST   pidl,
        UINT            iColumn,
        LPSHELLDETAILS  pDetails);

    STDMETHOD(ColumnClick)(
        UINT    iColumn);

    HRESULT HrInitialize(HWND hwndOwner);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv);
};



typedef enum CMENU_TYPE
{
    CMT_OBJECT      = 1,
    CMT_BACKGROUND  = 2
};

class ATL_NO_VTABLE CUPnPDeviceFolderContextMenu :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPDeviceFolderContextMenu, &CLSID_UPnPDeviceContextMenu>,
    public IContextMenu
{
private:
    HWND                m_hwndOwner;
    LPITEMIDLIST *      m_apidl;
    ULONG               m_cidl;
    LPSHELLFOLDER       m_psf;
    CMENU_TYPE          m_cmt;

public:
    CUPnPDeviceFolderContextMenu();
    ~CUPnPDeviceFolderContextMenu();

//    DECLARE_REGISTRY_RESOURCEID(IDR_UPNPFOLDCONTEXTMENU)

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFolderContextMenu)

    BEGIN_COM_MAP(CUPnPDeviceFolderContextMenu)
        COM_INTERFACE_ENTRY(IContextMenu)
    END_COM_MAP()

    // *** IContextMenu methods ***

    STDMETHOD(QueryContextMenu) (
        HMENU   hmenu,
        UINT    indexMenu,
        UINT    idCmdFirst,
        UINT    idCmdLast,
        UINT    uFlags);

    STDMETHOD(InvokeCommand) (
        LPCMINVOKECOMMANDINFO lpici);

    STDMETHOD(GetCommandString) (
        UINT_PTR    idCmd,
        UINT        uType,
        UINT *      pwReserved,
        PSTR       pszName,
        UINT        cchMax);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv,
        CMENU_TYPE                          cmt,
        HWND                                hwndOwner,
        UINT                                cidl,
        LPCITEMIDLIST *                     apidl,
        LPSHELLFOLDER                       psf);

private:
    HRESULT HrInitialize(
        CMENU_TYPE      cmt,
        HWND            hwndOwner,
        UINT            cidl,
        LPCITEMIDLIST * apidl,
        LPSHELLFOLDER   psf);
};

class ATL_NO_VTABLE CUPnPDeviceFolderExtractIcon :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPDeviceFolderExtractIcon, &CLSID_UPnPDeviceExtractIcon>,
    public IExtractIconW,
    public IExtractIconA
{
private:
    BSTR m_DeviceType;
    BSTR m_DeviceUDN; // Not used currently. Needed for downloading device specific icon
    
    HRESULT HrLoadIcons(
        PCWSTR  pszFile,
        UINT    nIconIndex,
        int     nSizeLarge,
        int     nSizeSmall,
        HICON * phiconLarge,
        HICON * phiconSmall);
public:
    CUPnPDeviceFolderExtractIcon();
    ~CUPnPDeviceFolderExtractIcon();

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFolderExtractIcon)

    BEGIN_COM_MAP(CUPnPDeviceFolderExtractIcon)
        COM_INTERFACE_ENTRY(IExtractIconW)
        COM_INTERFACE_ENTRY(IExtractIconA)
    END_COM_MAP()

    // *** IExtractIconW methods ***
    STDMETHOD(GetIconLocation) (
        UINT    uFlags,
        PWSTR  szIconFile,
        UINT    cchMax,
        int *   piIndex,
        UINT *  pwFlags);

    STDMETHOD(Extract) (
        PCWSTR pszFile,
        UINT    nIconIndex,
        HICON * phiconLarge,
        HICON * phiconSmall,
        UINT    nIconSize);

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation) (
        UINT    uFlags,
        PSTR   szIconFile,
        UINT    cchMax,
        int *   piIndex,
        UINT *  pwFlags);

    STDMETHOD(Extract) (
        PCSTR  pszFile,
        UINT    nIconIndex,
        HICON * phiconLarge,
        HICON * phiconSmall,
        UINT    nIconSize);

public:
    static HRESULT CreateInstance (
        LPCITEMIDLIST       apidl,
        REFIID              riid,
        void**              ppv);

    HRESULT Initialize(
        LPCITEMIDLIST apidl); 

};

class ATL_NO_VTABLE CUPnPDeviceFolderQueryInfo :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass <CUPnPDeviceFolderQueryInfo, &CLSID_UPnPDeviceQueryInfo>,
    public IQueryInfo
{
private:
    LPITEMIDLIST    m_pidl;

public:
    CUPnPDeviceFolderQueryInfo();
    ~CUPnPDeviceFolderQueryInfo();

    VOID PidlInitialize(LPITEMIDLIST pidl)
    {
        m_pidl = (pidl) ? CloneIDL (pidl) : NULL;
    }

    DECLARE_NOT_AGGREGATABLE(CUPnPDeviceFolderQueryInfo)

    BEGIN_COM_MAP(CUPnPDeviceFolderQueryInfo)
        COM_INTERFACE_ENTRY(IQueryInfo)
    END_COM_MAP()

    // *** IQueryInfo methods ***
    STDMETHOD(GetInfoTip) (
        DWORD dwFlags,
        WCHAR **ppwszTip);

    STDMETHOD(GetInfoFlags) (
        DWORD *pdwFlags);

public:
    static HRESULT CreateInstance (
        REFIID                              riid,
        void**                              ppv);
};

//---[ Helper Functions ]------------------------------------------------------

HRESULT HrRegisterFolderClass(VOID);
HRESULT HrUnRegisterDelegateFolderKey(VOID);
HRESULT HrUnRegisterUPnPUIKey(VOID);

HRESULT CALLBACK HrShellViewCallback(
    IShellView *    psvOuter,
    IShellFolder *  psf,
    HWND            hwnd,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT CALLBACK HrShellContextMenuCallback(
    LPSHELLFOLDER   psf,
    HWND            hwndView,
    LPDATAOBJECT    pdtobj,
    UINT            uMsg,
    WPARAM          wParam,
    LPARAM          lParam);

HRESULT HrDataObjGetHIDA(
    IDataObject *   pdtobj,
    STGMEDIUM *     pmedium,
    LPIDA *         ppida);

VOID HIDAReleaseStgMedium(
    LPIDA       pida,
    STGMEDIUM * pmedium);

HRESULT HrSHReleaseStgMedium(
    LPSTGMEDIUM pmedium);

LPITEMIDLIST ILFromHIDA(
    LPIDA   pida,
    UINT    iPidaIndex);

#endif // _UPNPFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\nsbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N S B A S E . H
//
//  Contents:   Base include file for netshell.dll.  Defines globals.
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#include "ncatl.h"
#include "upclsid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\openfold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       O P E N F O L D . H 
//
//  Contents:   Utility function for opening the UPnP device folder
//
//  Notes:      
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#ifndef _OPENFOLD_H_
#define _OPENFOLD_H_

// Get an IShellFolder * given the folder pidl
//
HRESULT HrGetUPnPDeviceIShellFolder(
    LPITEMIDLIST    pidlFolder, 
    LPSHELLFOLDER * ppsf);

HRESULT HrOpenSpecialShellFolder(HWND hwnd, INT iStandardFolderID);

#endif // _OPENFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\pch.h ===
#pragma once

//#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
//#define NOCOMM
#define NOCRYPT
//#define NOGDI
//#define NOICONS
#define NOIME
//#define NOMCX
//#define NOMDI
//#define NOMENUS
//#define NOMETAFILE
#define NOSOUND
//#define NOSYSPARAMSINFO
//#define NOWH
//#define NOWINABLE
//#define NOWINRES

//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <windows.h>
#include <objbase.h>

#include <devguid.h>
#include <wchar.h>
#include <tchar.h>

#include <upnp.h>
#include <upnpp.h>

#include "ncmem.h"
#include "ncdefine.h"
#include "ncdebug.h"

#include <shellapi.h>

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

// Undocument shell32 stuff.  Sigh.
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))

#include <upnpatl.h>

#include "nsbase.h"
#include "upsres.h"
#include <ncdebug.h>
#include <upnpshell.h>
#include <commui.h>
#include "upnpfold.h"
#include "shutil.h"
#include "openfold.h"
#include "updpidl.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\pidlutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L U T I L . H
//
//  Contents:   Various PIDL utilities
//
//  Notes:
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

#include <windows.h>
#include <shlobj.h>

// These functions are so trivial & get called so often they should be inlined
// for ship.
//
#if DBG
LPITEMIDLIST    ILNext(LPCITEMIDLIST pidl);
BOOL            ILIsEmpty(LPCITEMIDLIST pidl);
#else
#define ILNext(pidl)    ((LPITEMIDLIST) ((BYTE *)pidl + ((LPITEMIDLIST)pidl)->mkid.cb))
#define ILIsEmpty(pidl) (!pidl || !((LPITEMIDLIST)pidl)->mkid.cb)
#endif

LPITEMIDLIST    ILSkip(LPCITEMIDLIST pidl, UINT cb);
UINT            ILGetSizePriv(LPCITEMIDLIST pidl);
VOID            FreeIDL(LPITEMIDLIST pidl);
int             ILCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL            ILIsSingleID(LPCITEMIDLIST pidl);
UINT            ILGetCID(LPCITEMIDLIST pidl);
UINT            ILGetSizeCID(LPCITEMIDLIST pidl, UINT cid);
BOOL            ILIsDesktopID(LPCITEMIDLIST pidl);

LPITEMIDLIST    ILCreate(DWORD dwSize);
LPITEMIDLIST    ILFindLastIDPriv(LPCITEMIDLIST pidl);
LPITEMIDLIST    ILCombinePriv(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL            ILIsEqual(LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
LPITEMIDLIST    CloneIDL(LPCITEMIDLIST pidl);
BOOL            ILRemoveLastIDPRiv(LPITEMIDLIST pidl);

HRESULT HrCloneRgIDL(
    LPCITEMIDLIST * rgpidl,
    ULONG           cidl,
    LPITEMIDLIST ** ppidl,
    ULONG *         pcidl);

VOID FreeRgIDL(
    UINT            cidl,
    LPITEMIDLIST  * apidl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlalgor.h ===
#pragma once
#ifndef _STLALGOR_H_
#define _STLALGOR_H_
//#include <iterator>
//#include <memory>
//#include <xutility>

#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

const int _CHUNK_SIZE = 7;
const int _SORT_MAX = 16;
// TEMPLATE FUNCTION _Median
template<class _Ty> inline
_Ty _Median(_Ty _X, _Ty _Y, _Ty _Z)
{
    if (_X < _Y)
        return (_Y < _Z ? _Y : _X < _Z ? _Z : _X);
    else
        return (_X < _Z ? _X : _Y < _Z ? _Z : _Y);
}
// TEMPLATE FUNCTION _Median WITH PRED
template<class _Ty, class _Pr> inline
_Ty _Median(_Ty _X, _Ty _Y, _Ty _Z, _Pr _P)
{
    if (_P(_X, _Y))
        return (_P(_Y, _Z) ? _Y : _P(_X, _Z) ? _Z : _X);
    else
        return (_P(_X, _Z) ? _X : _P(_Y, _Z) ? _Z : _Y);
}
// TEMPLATE FUNCTION for_each
template<class _II, class _Fn> inline
_Fn for_each(_II _F, _II _L, _Fn _Op)
{
    for (; _F != _L; ++_F)
        _Op(*_F);
    return (_Op);
}
// TEMPLATE FUNCTION find
template<class _II, class _Ty> inline
_II find(_II _F, _II _L, const _Ty& _V)
{
    for (; _F != _L; ++_F)
        if (*_F == _V)
            break;
    return (_F);
}
// TEMPLATE FUNCTION find_if
template<class _II, class _Pr> inline
_II find_if(_II _F, _II _L, _Pr _P)
{
    for (; _F != _L; ++_F)
        if (_P(*_F))
            break;
    return (_F);
}
// TEMPLATE FUNCTION adjacent_find
template<class _FI> inline
_FI adjacent_find(_FI _F, _FI _L)
{
    for (_FI _Fb; (_Fb = _F) != _L && ++_F != _L; )
        if (*_Fb == *_F)
            return (_Fb);
    return (_L);
}
// TEMPLATE FUNCTION adjacent_find WITH PRED
template<class _FI, class _Pr> inline
_FI adjacent_find(_FI _F, _FI _L, _Pr _P)
{
    for (_FI _Fb; (_Fb = _F) != _L && ++_F != _L; )
        if (_P(*_Fb, *_F))
            return (_Fb);
    return (_L);
}
// TEMPLATE FUNCTION count
template<class _II, class _Ty> inline
_CNTSIZ(_II) count(_II _F, _II _L, const _Ty& _V)
{
    _CNTSIZ(_II) _N = 0;
    for (; _F != _L; ++_F)
        if (*_F == _V)
            ++_N;
    return (_N);
}
// TEMPLATE FUNCTION count_if
template<class _II, class _Pr> inline
_CNTSIZ(_II) count_if(_II _F, _II _L, _Pr _P)
{
    _CNTSIZ(_II) _N = 0;
    for (; _F != _L; ++_F)
        if (_P(*_F))
            ++_N;
    return (_N);
}
// TEMPLATE FUNCTION search
template<class _FI1, class _FI2> inline
_FI1 search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)
{
    return (_Search(_F1, _L1, _F2, _L2,
                    _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2> inline
_FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
             _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    for (; _D2 <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_FI2 _X2 = _F2; ; ++_X1, ++_X2)
            if (_X2 == _L2)
                return (_F1);
            else if (!(*_X1 == *_X2))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION search WITH PRED
template<class _FI1, class _FI2, class _Pr> inline
_FI1 search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pr _P)
{
    return (_Search(_F1, _L1, _F2, _L2, _P,
                    _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2,
class _Pr> inline
_FI1 _Search(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
             _Pr _P, _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    for (; _D2 <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_FI2 _X2 = _F2; ; ++_X1, ++_X2)
            if (_X2 == _L2)
                return (_F1);
            else if (!_P(*_X1, *_X2))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION search_n
template<class _FI1, class _Pd2, class _Ty> inline
_FI1 search_n(_FI1 _F1, _FI1 _L1, _Pd2 _N, const _Ty& _V)
{
    return (_Search_n(_F1, _L1, _N, _V, _Dist_type(_F1)));
}
template<class _FI1, class _Pd2, class _Ty, class _Pd1> inline
_FI1 _Search_n(_FI1 _F1, _FI1 _L1,
               _Pd2 _N, const _Ty& _V, _Pd1 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    for (; _N <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_Pd2 _D2 = _N; ; ++_X1, --_D2)
            if (_D2 == 0)
                return (_F1);
            else if (!(*_X1 == _V))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION search_n WITH PRED
template<class _FI1, class _Pd2, class _Ty, class _Pr> inline
_FI1 search_n(_FI1 _F1, _FI1 _L1,
              _Pd2 _N, const _Ty& _V, _Pr _P)
{
    return (_Search_n(_F1, _L1,
                      _N, _V, _P, _Dist_type(_F1)));
}
template<class _FI1, class _Pd2,
class _Ty, class _Pd1, class _Pr> inline
_FI1 _Search_n(_FI1 _F1, _FI1 _L1,
               _Pd2 _N, const _Ty& _V, _Pr _P, _Pd1 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    for (; _N <= _D1; ++_F1, --_D1)
    {
        _FI1 _X1 = _F1;
        for (_Pd2 _D2 = _N; ; ++_X1, --_D2)
            if (_D2 == 0)
                return (_F1);
            else if (!_P(*_X1, _V))
                break;
    }
    return (_L1);
}
// TEMPLATE FUNCTION find_end
template<class _FI1, class _FI2> inline
_FI1 find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)
{
    return (_Find_end(_F1, _L1, _F2, _L2,
                      _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2> inline
_FI1 _Find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
               _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    _FI1 _Ans = _L1;
    if (0 < _D2)
        for (; _D2 <= _D1; ++_F1, --_D1)
        {
            _FI1 _X1 = _F1;
            for (_FI2 _X2 = _F2; ; ++_X1)
                if (!(*_X1 == *_X2))
                    break;
                else if (++_X2 == _L2)
                {
                    _Ans = _F1;
                    break;
                }
        }
    return (_Ans);
}
// TEMPLATE FUNCTION find_end WITH PRED
template<class _FI1, class _FI2, class _Pr> inline
_FI1 find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pr _P)
{
    return (_Find_end(_F1, _L1, _F2, _L2, _P,
                      _Dist_type(_F1), _Dist_type(_F2)));
}
template<class _FI1, class _FI2, class _Pd1, class _Pd2,
class _Pr> inline
_FI1 _Find_end(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2, _Pr _P,
               _Pd1 *, _Pd2 *)
{
    _Pd1 _D1 = 0;
    _Distance(_F1, _L1, _D1);
    _Pd2 _D2 = 0;
    _Distance(_F2, _L2, _D2);
    _FI1 _Ans = _L1;
    if (0 < _D2)
        for (; _D2 <= _D1; ++_F1, --_D1)
        {
            _FI1 _X1 = _F1;
            for (_FI2 _X2 = _F2; ; ++_X1)
                if (!_P(*_X1, *_X2))
                    break;
                else if (++_X2 == _L2)
                {
                    _Ans = _F1;
                    break;
                }
        }
    return (_Ans);
}
// TEMPLATE FUNCTION find_first_of
template<class _FI1, class _FI2> inline
_FI1 find_first_of(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2)
{
    for (; _F1 != _L1; ++_F1)
        for (_FI2 _X2 = _F2; _X2 != _L2; ++_X2)
            if (*_F1 == *_X2)
                return (_F1);
    return (_F1);
}
// TEMPLATE FUNCTION find_first_of WITH PRED
template<class _FI1, class _FI2, class _Pr> inline
_FI1 find_first_of(_FI1 _F1, _FI1 _L1, _FI2 _F2, _FI2 _L2,
                   _Pr _P)
{
    for (; _F1 != _L1; ++_F1)
        for (_FI2 _X2 = _F2; _X2 != _L2; ++_X2)
            if (_P(*_F1, *_X2))
                return (_F1);
    return (_F1);
}
// TEMPLATE FUNCTION iter_swap
template<class _FI1, class _FI2> inline
void iter_swap(_FI1 _X, _FI2 _Y)
{
    _Iter_swap(_X, _Y, _Val_type(_X));
}
template<class _FI1, class _FI2, class _Ty> inline
void _Iter_swap(_FI1 _X, _FI2 _Y, _Ty *)
{
    _Ty _Tmp = *_X;
    *_X = *_Y, *_Y = _Tmp;
}
// TEMPLATE FUNCTION swap_ranges
template<class _FI1, class _FI2> inline
_FI2 swap_ranges(_FI1 _F, _FI1 _L, _FI2 _X)
{
    for (; _F != _L; ++_F, ++_X)
        iter_swap(_F, _X);
    return (_X);
}
// TEMPLATE FUNCTION transform WITH UNARY OP
template<class _II, class _OI, class _Uop> inline
_OI transform(_II _F, _II _L, _OI _X, _Uop _U)
{
    for (; _F != _L; ++_F, ++_X)
        *_X = _U(*_F);
    return (_X);
}
// TEMPLATE FUNCTION transform WITH BINARY OP
template<class _II1, class _II2, class _OI, class _Bop> inline
_OI transform(_II1 _F1, _II1 _L1, _II2 _F2, _OI _X, _Bop _B)
{
    for (; _F1 != _L1; ++_F1, ++_F2, ++_X)
        *_X = _B(*_F1, *_F2);
    return (_X);
}
// TEMPLATE FUNCTION replace
template<class _FI, class _Ty> inline
void replace(_FI _F, _FI _L, const _Ty& _Vo, const _Ty& _Vn)
{
    for (; _F != _L; ++_F)
        if (*_F == _Vo)
            *_F = _Vn;
}
// TEMPLATE FUNCTION replace_if
template<class _FI, class _Pr, class _Ty> inline
void replace_if(_FI _F, _FI _L, _Pr _P, const _Ty& _V)
{
    for (; _F != _L; ++_F)
        if (_P(*_F))
            *_F = _V;
}
// TEMPLATE FUNCTION replace_copy
template<class _II, class _OI, class _Ty> inline
_OI replace_copy(_II _F, _II _L, _OI _X,
                 const _Ty& _Vo, const _Ty& _Vn)
{
    for (; _F != _L; ++_F, ++_X)
        *_X = *_F == _Vo ? _Vn : *_F;
    return (_X);
}
// TEMPLATE FUNCTION replace_copy_if
template<class _II, class _OI, class _Pr, class _Ty> inline
_OI replace_copy_if(_II _F, _II _L, _OI _X,
                    _Pr _P, const _Ty& _V)
{
    for (; _F != _L; ++_F, ++_X)
        *_X = _P(*_F) ? _V : *_F;
    return (_X);
}
// TEMPLATE FUNCTION generate
template<class _FI, class _Gen> inline
void generate(_FI _F, _FI _L, _Gen _G)
{
    for (; _F != _L; ++_F)
        *_F = _G();
}
// TEMPLATE FUNCTION generate_n
template<class _OI, class _Pd, class _Gen> inline
void generate_n(_OI _F, _Pd _N, _Gen _G)
{
    for (; 0 < _N; --_N, ++_F)
        *_F = _G();
}
// TEMPLATE FUNCTION remove
template<class _FI, class _Ty> inline
_FI remove(_FI _F, _FI _L, const _Ty& _V)
{
    _F = find(_F, _L, _V);
    if (_F == _L)
        return (_F);
    else
    {
        _FI _Fb = _F;
        return (remove_copy(++_F, _L, _Fb, _V));
    }
}
// TEMPLATE FUNCTION remove_if
template<class _FI, class _Pr> inline
_FI remove_if(_FI _F, _FI _L, _Pr _P)
{
    _F = find_if(_F, _L, _P);
    if (_F == _L)
        return (_F);
    else
    {
        _FI _Fb = _F;
        return (remove_copy_if(++_F, _L, _Fb, _P));
    }
}
// TEMPLATE FUNCTION remove_copy
template<class _II, class _OI, class _Ty> inline
_OI remove_copy(_II _F, _II _L, _OI _X, const _Ty& _V)
{
    for (; _F != _L; ++_F)
        if (!(*_F == _V))
            *_X++ = *_F;
    return (_X);
}
// TEMPLATE FUNCTION remove_copy_if
template<class _II, class _OI, class _Pr> inline
_OI remove_copy_if(_II _F, _II _L, _OI _X, _Pr _P)
{
    for (; _F != _L; ++_F)
        if (!_P(*_F))
            *_X++ = *_F;
    return (_X);
}
// TEMPLATE FUNCTION unique
template<class _FI> inline
_FI unique(_FI _F, _FI _L)
{
    _F = adjacent_find(_F, _L);
    return (unique_copy(_F, _L, _F));
}
// TEMPLATE FUNCTION unique WITH PRED
template<class _FI, class _Pr> inline
_FI unique(_FI _F, _FI _L, _Pr _P)
{
    _F = adjacent_find(_F, _L, _P);
    return (unique_copy(_F, _L, _F, _P));
}
// TEMPLATE FUNCTION unique_copy
template<class _II, class _OI> inline
_OI unique_copy(_II _F, _II _L, _OI _X)
{
    return (_F == _L ? _X :
            _Unique_copy(_F, _L, _X, _Iter_cat(_F)));
}
template<class _II, class _OI> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, input_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _Val_type(_F)));
}
template<class _II, class _OI, class _Ty> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, _Ty *)
{
    _Ty _V = *_F;
    for (*_X++ = _V; ++_F != _L; )
        if (!(_V == *_F))
            _V = *_F, *_X++ = _V;
    return (_X);
}
template<class _FI, class _OI> inline
_OI _Unique_copy(_FI _F, _FI _L, _OI _X, forward_iterator_tag)
{
    _FI _Fb = _F;
    for (*_X++ = *_Fb; ++_F != _L; )
        if (!(*_Fb == *_F))
            _Fb = _F, *_X++ = *_Fb;
    return (_X);
}
template<class _BI, class _OI> inline
_OI _Unique_copy(_BI _F, _BI _L, _OI _X,
                 bidirectional_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, forward_iterator_tag()));
}
template<class _RI, class _OI> inline
_OI _Unique_copy(_RI _F, _RI _L, _OI _X,
                 random_access_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, forward_iterator_tag()));
}
// TEMPLATE FUNCTION unique_copy WITH PRED
template<class _II, class _OI, class _Pr> inline
_OI unique_copy(_II _F, _II _L, _OI _X, _Pr _P)
{
    return (_F == _L ? _X :
            _Unique_copy(_F, _L, _X, _P, _Iter_cat(_F)));
}
template<class _II, class _OI, class _Pr> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, _Pr _P,
                 input_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _P, _Val_type(_F)));
}
template<class _II, class _OI, class _Ty, class _Pr> inline
_OI _Unique_copy(_II _F, _II _L, _OI _X, _Pr _P, _Ty *)
{
    _Ty _V = *_F;
    for (*_X++ = _V; ++_F != _L; )
        if (!_P(_V, *_F))
            _V = *_F, *_X++ = _V;
    return (_X);
}
template<class _FI, class _OI, class _Pr> inline
_OI _Unique_copy(_FI _F, _FI _L, _OI _X, _Pr _P,
                 forward_iterator_tag)
{
    _FI _Fb = _F;
    for (*_X++ = *_Fb; ++_F != _L; )
        if (!_P(*_Fb, *_F))
            _Fb = _F, *_X++ = *_Fb;
    return (_X);
}
template<class _BI, class _OI, class _Pr> inline
_OI _Unique_copy(_BI _F, _BI _L, _OI _X, _Pr _P,
                 bidirectional_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _P,
                         forward_iterator_tag()));
}
template<class _RI, class _OI, class _Pr> inline
_OI _Unique_copy(_RI _F, _RI _L, _OI _X, _Pr _P,
                 random_access_iterator_tag)
{
    return (_Unique_copy(_F, _L, _X, _P,
                         forward_iterator_tag()));
}
// TEMPLATE FUNCTION reverse
template<class _BI> inline
void reverse(_BI _F, _BI _L)
{
    _Reverse(_F, _L, _Iter_cat(_F));
}
template<class _BI> inline
void _Reverse(_BI _F, _BI _L, bidirectional_iterator_tag)
{
    for (; _F != _L && _F != --_L; ++_F)
        iter_swap(_F, _L);
}
template<class _RI> inline
void _Reverse(_RI _F, _RI _L, random_access_iterator_tag)
{
    for (; _F < _L; ++_F)
        iter_swap(_F, --_L);
}
// TEMPLATE FUNCTION reverse_copy
template<class _BI, class _OI> inline
_OI reverse_copy(_BI _F, _BI _L, _OI _X)
{
    for (; _F != _L; ++_X)
        *_X = *--_L;
    return (_X);
}
// TEMPLATE FUNCTION rotate
template<class _FI> inline
void rotate(_FI _F, _FI _M, _FI _L)
{
    if (_F != _M && _M != _L)
        _Rotate(_F, _M, _L, _Iter_cat(_F));
}
template<class _FI> inline
void _Rotate(_FI _F, _FI _M, _FI _L,
             forward_iterator_tag)
{
    for (_FI _X = _M; ; )
    {
        iter_swap(_F, _X);
        if (++_F == _M)
            if (++_X == _L)
                break;
            else
                _M = _X;
        else if (++_X == _L)
            _X = _M;
    }
}
template<class _BI> inline
void _Rotate(_BI _F, _BI _M, _BI _L,
             bidirectional_iterator_tag)
{
    reverse(_F, _M);
    reverse(_M, _L);
    reverse(_F, _L);
}
template<class _RI> inline
void _Rotate(_RI _F, _RI _M, _RI _L,
             random_access_iterator_tag)
{
    _Rotate(_F, _M, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Rotate(_RI _F, _RI _M, _RI _L, _Pd *, _Ty *)
{
    _Pd _D = _M - _F;
    _Pd _N = _L - _F;
    for (_Pd _I = _D; _I != 0; )
    {
        _Pd _J = _N % _I;
        _N = _I, _I = _J;
    }
    if (_N < _L - _F)
        for (; 0 < _N; --_N)
        {
            _RI _X = _F + _N;
            _RI _Y = _X;
            _Ty _V = *_X;
            _RI _Z = _Y + _D == _L ? _F : _Y + _D;
            while (_Z != _X)
            {
                *_Y = *_Z;
                _Y = _Z;
                _Z = _D < _L - _Z ? _Z + _D
                     : _F + (_D - (_L - _Z));
            }
            *_Y = _V;
        }
}
// TEMPLATE FUNCTION rotate_copy
template<class _FI, class _OI> inline
_OI rotate_copy(_FI _F, _FI _M, _FI _L, _OI _X)
{
    return (copy(_F, _M, copy(_M, _L, _X)));
}
// TEMPLATE FUNCTION random_shuffle
template<class _RI> inline
void random_shuffle(_RI _F, _RI _L)
{
    if (_F != _L)
        _Random_shuffle(_F, _L, _Dist_type(_F));
}
template<class _RI, class _Pd> inline
void _Random_shuffle(_RI _F, _RI _L, _Pd *)
{
    const int _RBITS = 15;
    const int _RMAX = (1U << _RBITS) - 1;
    _RI _X = _F;
    for (_Pd _D = 1; ++_X != _L; ++_D)
    {
        unsigned long _Rm = _RMAX;
        unsigned long _Rn = rand() & _RMAX;
        for (; _Rm < _D && _Rm != ~0UL;
            _Rm = _Rm << _RBITS | _RMAX)
            _Rn = _Rn << _RBITS | _RMAX;
        iter_swap(_X, _F + _Pd(_Rn % _D));
    }
}
template<class _RI, class _Pf> inline
void random_shuffle(_RI _F, _RI _L, _Pf& _R)
{
    if (_F != _L)
        _Random_shuffle(_F, _L, _R, _Dist_type(_F));
}
template<class _RI, class _Pf, class _Pd> inline
void _Random_shuffle(_RI _F, _RI _L, _Pf& _R, _Pd *)
{
    _RI _X = _F;
    for (_Pd _D = 1; ++_X != _L; ++_D)
        iter_swap(_X, _F + _Pd(_R(_D)));
}
// TEMPLATE FUNCTION partition
template<class _BI, class _Pr> inline
_BI partition(_BI _F, _BI _L, _Pr _P)
{
    for (; ; ++_F)
    {
        for (; _F != _L && _P(*_F); ++_F)
            ;
        if (_F == _L)
            break;
        for (; _F != --_L && !_P(*_L); )
            ;
        if (_F == _L)
            break;
        iter_swap(_F, _L);
    }
    return (_F);
}
// TEMPLATE FUNCTION stable_partition
template<class _FI, class _Pr> inline
_FI stable_partition(_FI _F, _FI _L, _Pr _P)
{
    return (_F == _L ? _F : _Stable_partition(_F, _L, _P,
                                              _Dist_type(_F), _Val_type(_F)));
}
template<class _FI, class _Pr, class _Pd, class _Ty> inline
_FI _Stable_partition(_FI _F, _FI _L, _Pr _P, _Pd *, _Ty *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    _Temp_iterator<_Ty> _Xb(_N);
    return (_Stable_partition(_F, _L, _P, _N, _Xb));
}
template<class _FI, class _Pr, class _Pd, class _Ty> inline
_FI _Stable_partition(_FI _F, _FI _L, _Pr _P, _Pd _N,
                      _Temp_iterator<_Ty>& _Xb)
{
    if (_N == 1)
        return (_P(*_F) ? _L : _F);
    else if (_N <= _Xb._Maxlen())
    {
        _FI _X = _F;
        for (_Xb._Init(); _F != _L; ++_F)
            if (_P(*_F))
                *_X++ = *_F;
            else
                *_Xb++ = *_F;
        copy(_Xb._First(), _Xb._Last(), _X);
        return (_X);
    }
    else
    {
        _FI _M = _F;
        advance(_M, _N / 2);
        _FI _Lp = _Stable_partition(_F, _M, _P, _N / 2, _Xb);
        _FI _Rp = _Stable_partition(_M, _L, _P, _N - _N / 2, _Xb);
        _Pd _D1 = 0;
        _Distance(_Lp, _M, _D1);
        _Pd _D2 = 0;
        _Distance(_M, _Rp, _D2);
        return (_Buffered_rotate(_Lp, _M, _Rp, _D1, _D2, _Xb));
    }
}
// TEMPLATE FUNCTION sort
template<class _RI> inline
void sort(_RI _F, _RI _L)
{
    _Sort_0(_F, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Sort_0(_RI _F, _RI _L, _Ty *)
{
    if (_L - _F <= _SORT_MAX)
        _Insertion_sort(_F, _L);
    else
    {
        _Sort(_F, _L, (_Ty *)0);
        _Insertion_sort(_F, _F + _SORT_MAX);
        for (_F += _SORT_MAX; _F != _L; ++_F)
            _Unguarded_insert(_F, _Ty(*_F));
    }
}
template<class _RI, class _Ty> inline
void _Sort(_RI _F, _RI _L, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1))));
        if (_L - _M <= _M - _F)
            _Sort(_M, _L, _Val_type(_F)), _L = _M;
        else
            _Sort(_F, _M, _Val_type(_F)), _F = _M;
    }
}
template<class _RI, class _Ty> inline
_RI _Unguarded_partition(_RI _F, _RI _L, _Ty _Piv)
{
    for (; ; ++_F)
    {
        for (; *_F < _Piv; ++_F)
            ;
        for (; _Piv < *--_L; )
            ;
        if (_L <= _F)
            return (_F);
        iter_swap(_F, _L);
    }
}
template<class _RI> inline
void _Insertion_sort(_RI _F, _RI _L)
{
    _Insertion_sort_1(_F, _L, _Val_type(_F));
}
template<class _BI, class _Ty> inline
void _Insertion_sort_1(_BI _F, _BI _L, _Ty *)
{
    if (_F != _L)
        for (_BI _M = _F; ++_M != _L; )
        {
            _Ty _V = *_M;
            if (!(_V < *_F))
                _Unguarded_insert(_M, _V);
            else
            {
                copy_backward(_F, _M, _M + 1);
                *_F = _V;
            }
        }
}
template<class _BI, class _Ty> inline
void _Unguarded_insert(_BI _L, _Ty _V)
{
    for (_BI _M = _L; _V < *--_M; _L = _M)
        *_L = *_M;
    *_L = _V;
}
// TEMPLATE FUNCTION sort WITH PRED
template<class _RI, class _Pr> inline
void sort(_RI _F, _RI _L, _Pr _P)
{
    _Sort_0(_F, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Sort_0(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    if (_L - _F <= _SORT_MAX)
        _Insertion_sort(_F, _L, _P);
    else
    {
        _Sort(_F, _L, _P, (_Ty *)0);
        _Insertion_sort(_F, _F + _SORT_MAX, _P);
        for (_F += _SORT_MAX; _F != _L; ++_F)
            _Unguarded_insert(_F, _Ty(*_F), _P);
    }
}
template<class _RI, class _Ty, class _Pr> inline
void _Sort(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1)), _P), _P);
        if (_L - _M <= _M - _F)
            _Sort(_M, _L, _P, _Val_type(_F)), _L = _M;
        else
            _Sort(_F, _M, _P, _Val_type(_F)), _F = _M;
    }
}
template<class _RI, class _Ty, class _Pr> inline
_RI _Unguarded_partition(_RI _F, _RI _L, _Ty _Piv, _Pr _P)
{
    for (; ; ++_F)
    {
        for (; _P(*_F, _Piv); ++_F)
            ;
        for (; _P(_Piv, *--_L); )
            ;
        if (_L <= _F)
            return (_F);
        iter_swap(_F, _L);
    }
}
template<class _RI, class _Pr> inline
void _Insertion_sort(_RI _F, _RI _L, _Pr _P)
{
    _Insertion_sort_1(_F, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Insertion_sort_1(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    if (_F != _L)
        for (_RI _M = _F; ++_M != _L; )
        {
            _Ty _V = *_M;
            if (!_P(_V, *_F))
                _Unguarded_insert(_M, _V, _P);
            else
            {
                copy_backward(_F, _M, _M + 1);
                *_F = _V;
            }
        }
}
template<class _RI, class _Ty, class _Pr> inline
void _Unguarded_insert(_RI _L, _Ty _V, _Pr _P)
{
    for (_RI _M = _L; _P(_V, *--_M); _L = _M)
        *_L = *_M;
    *_L = _V;
}
// TEMPLATE FUNCTION stable_sort
template<class _BI> inline
void stable_sort(_BI _F, _BI _L)
{
    if (_F != _L)
        _Stable_sort(_F, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _BI, class _Pd, class _Ty> inline
void _Stable_sort(_BI _F, _BI _L, _Pd *, _Ty *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    _Temp_iterator<_Ty> _Xb(_N);
    _Stable_sort(_F, _L, _N, _Xb);
}
template<class _BI, class _Pd, class _Ty> inline
void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                  _Temp_iterator<_Ty>& _Xb)
{
    if (_N <= _SORT_MAX)
        _Insertion_sort(_F, _L);
    else
    {
        _Pd _N2 = (_N + 1) / 2;
        _BI _M = _F;
        advance(_M, _N2);
        if (_N2 <= _Xb._Maxlen())
        {
            _Buffered_merge_sort(_F, _M, _N2, _Xb);
            _Buffered_merge_sort(_M, _L, _N - _N2, _Xb);
        }
        else
        {
            _Stable_sort(_F, _M, _N2, _Xb);
            _Stable_sort(_M, _L, _N - _N2, _Xb);
        }
        _Buffered_merge(_F, _M, _L, _N2, _N - _N2, _Xb);
    }
}
template<class _BI, class _Pd, class _Ty> inline
void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                          _Temp_iterator<_Ty>& _Xb)
{
    _BI _M = _F;
    for (_Pd _I = _N; _CHUNK_SIZE <= _I; _I -= _CHUNK_SIZE)
    {
        _BI _Mn = _M;
        advance(_Mn, (int)_CHUNK_SIZE);
        _Insertion_sort(_M, _Mn);
        _M = _Mn;
    }
    _Insertion_sort(_M, _L);
    for (_Pd _D = _CHUNK_SIZE; _D < _N; _D *= 2)
    {
        _BI _Ft = _F;
        _Chunked_merge(_F, _L, _Xb._Init(), _D, _N);
        _Chunked_merge(_Xb._First(), _Xb._Last(), _Ft,
                       _D *= 2, _N);
    }
}
template<class _BI, class _OI, class _Pd> inline
void _Chunked_merge(_BI _F, _BI _L, _OI& _X, _Pd _D, _Pd _N)
{
    _Pd _D2 = _D * 2;
    for (; _D2 <= _N; _N -= _D2)
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        _BI _F2 = _F1;
        advance(_F2, _D);
        _X = merge(_F, _F1, _F1, _F2, _X);
        _F = _F2;
    }
    if (_N <= _D)
        copy(_F, _L, _X);
    else
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        merge(_F, _F1, _F1, _L, _X);
    }
}
// TEMPLATE FUNCTION stable_sort WITH PRED
template<class _BI, class _Pr> inline
void stable_sort(_BI _F, _BI _L, _Pr _P)
{
    if (_F != _L)
        _Stable_sort(_F, _L,
                     _Dist_type(_F), _Val_type(_F), _P);
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Stable_sort(_BI _F, _BI _L, _Pd *, _Ty *, _Pr _P)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    _Temp_iterator<_Ty> _Xb(_N);
    _Stable_sort(_F, _L, _N, _Xb, _P);
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Stable_sort(_BI _F, _BI _L, _Pd _N,
                  _Temp_iterator<_Ty>& _Xb, _Pr _P)
{
    if (_N <= _SORT_MAX)
        _Insertion_sort(_F, _L, _P);
    else
    {
        _Pd _N2 = (_N + 1) / 2;
        _BI _M = _F;
        advance(_M, _N2);
        if (_N2 <= _Xb._Maxlen())
        {
            _Buffered_merge_sort(_F, _M, _N2, _Xb, _P);
            _Buffered_merge_sort(_M, _L, _N - _N2, _Xb, _P);
        }
        else
        {
            _Stable_sort(_F, _M, _N2, _Xb, _P);
            _Stable_sort(_M, _L, _N - _N2, _Xb, _P);
        }
        _Buffered_merge(_F, _M, _L, _N2, _N - _N2, _Xb, _P);
    }
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Buffered_merge_sort(_BI _F, _BI _L, _Pd _N,
                          _Temp_iterator<_Ty>& _Xb, _Pr _P)
{
    _BI _M = _F;
    for (_Pd _I = _N; _CHUNK_SIZE <= _I; _I -= _CHUNK_SIZE)
    {
        _BI _Mn = _M;
        advance(_Mn, (int)_CHUNK_SIZE);
        _Insertion_sort(_M, _Mn, _P);
        _M = _Mn;
    }
    _Insertion_sort(_M, _L, _P);
    for (_Pd _D = _CHUNK_SIZE; _D < _N; _D *= 2)
    {
        _BI _Ft = _F;
        _Chunked_merge(_F, _L, _Xb._Init(), _D, _N, _P);
        _Chunked_merge(_Xb._First(), _Xb._Last(), _Ft,
                       _D *= 2, _N, _P);
    }
}
template<class _BI, class _OI, class _Pd, class _Pr> inline
void _Chunked_merge(_BI _F, _BI _L, _OI& _X,
                    _Pd _D, _Pd _N, _Pr _P)
{
    _Pd _D2 = _D * 2;
    for (; _D2 <= _N; _N -= _D2)
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        _BI _F2 = _F1;
        advance(_F2, _D);
        _X = merge(_F, _F1, _F1, _F2, _X, _P);
        _F = _F2;
    }
    if (_N <= _D)
        copy(_F, _L, _X);
    else
    {
        _BI _F1 = _F;
        advance(_F1, _D);
        merge(_F, _F1, _F1, _L, _X, _P);
    }
}
// TEMPLATE FUNCTION partial_sort
template<class _RI> inline
void partial_sort(_RI _F, _RI _M, _RI _L)
{
    _Partial_sort(_F, _M, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Partial_sort(_RI _F, _RI _M, _RI _L, _Ty *)
{
    make_heap(_F, _M);
    for (_RI _I = _M; _I < _L; ++_I)
        if (*_I < *_F)
            _Pop_heap(_F, _M, _I, _Ty(*_I), _Dist_type(_F));
    sort_heap(_F, _M);
}
// TEMPLATE FUNCTION partial_sort WITH PRED
template<class _RI, class _Pr> inline
void partial_sort(_RI _F, _RI _M, _RI _L, _Pr _P)
{
    _Partial_sort(_F, _M, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Partial_sort(_RI _F, _RI _M, _RI _L, _Pr _P, _Ty *)
{
    make_heap(_F, _M, _P);
    for (_RI _I = _M; _I < _L; ++_I)
        if (_P(*_I, *_F))
            _Pop_heap(_F, _M, _I, _Ty(*_I), _P, _Dist_type(_F));
    sort_heap(_F, _M, _P);
}
// TEMPLATE FUNCTION partial_sort_copy
template<class _II, class _RI> inline
_RI partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2)
{
    return (_Partial_sort_copy(_F1, _L1, _F2, _L2,
                               _Dist_type(_F2), _Val_type(_F1)));
}
template<class _II, class _RI, class _Pd, class _Ty> inline
_RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                       _Pd *, _Ty *)
{
    _RI _X = _F2;
    if (_X != _L2)
    {
        for (; _F1 != _L1 && _X != _L2; ++_F1, ++_X)
            *_X = *_F1;
        make_heap(_F2, _X);
        for (; _F1 != _L1; ++_F1)
            if (*_F1 < *_F2)
                _Adjust_heap(_F2, _Pd(0), _Pd(_X - _F2),
                             _Ty(*_F1));
        sort_heap(_F2, _X);
    }
    return (_X);
}
// TEMPLATE FUNCTION partial_sort_copy WITH PRED
template<class _II, class _RI, class _Pr> inline
_RI partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                      _Pr _P)
{
    return (_Partial_sort_copy(_F1, _L1, _F2, _L2, _P,
                               _Dist_type(_F2), _Val_type(_F1)));
}
template<class _II, class _RI, class _Pd,
class _Ty, class _Pr> inline
_RI _Partial_sort_copy(_II _F1, _II _L1, _RI _F2, _RI _L2,
                       _Pr _P, _Pd *, _Ty *)
{
    _RI _X = _F2;
    if (_X != _L2)
    {
        for (; _F1 != _L1 && _X != _L2; ++_F1, ++_X)
            *_X = *_F1;
        make_heap(_F2, _X, _P);
        for (; _F1 != _L1; ++_F1)
            if (_P(*_F1, *_F2))
                _Adjust_heap(_F2, _Pd(0), _Pd(_X - _F2),
                             _Ty(*_F1), _P);
        sort_heap(_F2, _X, _P);
    }
    return (_X);
}
// TEMPLATE FUNCTION nth_element
template<class _RI> inline
void nth_element(_RI _F, _RI _Nth, _RI _L)
{
    _Nth_element(_F, _Nth, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Nth_element(_RI _F, _RI _Nth, _RI _L, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1))));
        if (_M <= _Nth)
            _F = _M;
        else
            _L = _M;
    }
    _Insertion_sort(_F, _L);
}
// TEMPLATE FUNCTION nth_element WITH PRED
template<class _RI, class _Pr> inline
void nth_element(_RI _F, _RI _Nth, _RI _L, _Pr _P)
{
    _Nth_element(_F, _Nth, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Nth_element(_RI _F, _RI _Nth, _RI _L, _Pr _P, _Ty *)
{
    for (; _SORT_MAX < _L - _F; )
    {
        _RI _M = _Unguarded_partition(_F, _L, _Median(_Ty(*_F),
                                                      _Ty(*(_F + (_L - _F) / 2)), _Ty(*(_L - 1)), _P), _P);
        if (_M <= _Nth)
            _F = _M;
        else
            _L = _M;
    }
    _Insertion_sort(_F, _L, _P);
}
// TEMPLATE FUNCTION lower_bound
template<class _FI, class _Ty> inline
_FI lower_bound(_FI _F, _FI _L, const _Ty& _V)
{
    return (_Lower_bound(_F, _L, _V, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd> inline
_FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (*_M < _V)
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION lower_bound WITH PRED
template<class _FI, class _Ty, class _Pr> inline
_FI lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
{
    return (_Lower_bound(_F, _L, _V, _P, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd, class _Pr> inline
_FI _Lower_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (_P(*_M, _V))
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION upper_bound
template<class _FI, class _Ty> inline
_FI upper_bound(_FI _F, _FI _L, const _Ty& _V)
{
    return (_Upper_bound(_F, _L, _V, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd> inline
_FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (!(_V < *_M))
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION upper_bound WITH PRED
template<class _FI, class _Ty, class _Pr> inline
_FI upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
{
    return (_Upper_bound(_F, _L, _V, _P, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd, class _Pr> inline
_FI _Upper_bound(_FI _F, _FI _L, const _Ty& _V, _Pr _P, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (!_P(_V, *_M))
            _F = ++_M, _N -= _N2 + 1;
        else
            _N = _N2;
    }
    return (_F);
}
// TEMPLATE FUNCTION equal_range
template<class _FI, class _Ty> inline
pair<_FI, _FI> equal_range(_FI _F, _FI _L, const _Ty& _V)
{
    return (_Equal_range(_F, _L, _V, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd> inline
pair<_FI, _FI> _Equal_range(_FI _F, _FI _L,
                            const _Ty& _V, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (*_M < _V)
            _F = ++_M, _N -= _N2 + 1;
        else if (_V < *_M)
            _N = _N2;
        else
        {
            _FI _F2 = lower_bound(_F, _M, _V);
            advance(_F, _N);
            _FI _L2 = upper_bound(++_M, _F, _V);
            return (pair<_FI, _FI>(_F2, _L2));
        }
    }
    return (pair<_FI, _FI>(_F, _F));
}
// TEMPLATE FUNCTION equal_range WITH PRED
template<class _FI, class _Ty, class _Pr> inline
pair<_FI, _FI> equal_range(_FI _F, _FI _L, const _Ty& _V,
                           _Pr _P)
{
    return (_Equal_range(_F, _L, _V, _P, _Dist_type(_F)));
}
template<class _FI, class _Ty, class _Pd, class _Pr> inline
pair<_FI, _FI> _Equal_range(_FI _F, _FI _L, const _Ty& _V,
                            _Pr _P, _Pd *)
{
    _Pd _N = 0;
    _Distance(_F, _L, _N);
    for (; 0 < _N; )
    {
        _Pd _N2 = _N / 2;
        _FI _M = _F;
        advance(_M, _N2);
        if (_P(*_M, _V))
            _F = ++_M, _N -= _N2 + 1;
        else if (_P(_V, *_M))
            _N = _N2;
        else
        {
            _FI _F2 = lower_bound(_F, _M, _V, _P);
            advance(_F, _N);
            _FI _L2 = upper_bound(++_M, _F, _V, _P);
            return (pair<_FI, _FI>(_F2, _L2));
        }
    }
    return (pair<_FI, _FI>(_F, _F));
}
// TEMPLATE FUNCTION binary_search
template<class _FI, class _Ty> inline
bool binary_search(_FI _F, _FI _L, const _Ty& _V)
{
    _FI _I = lower_bound(_F, _L, _V);
    return (_I != _L && !(_V < *_I));
}
// TEMPLATE FUNCTION binary_search WITH PRED
template<class _FI, class _Ty, class _Pr> inline
bool binary_search(_FI _F, _FI _L, const _Ty& _V, _Pr _P)
{
    _FI _I = lower_bound(_F, _L, _V, _P);
    return (_I != _L && !_P(_V, *_I));
}
// TEMPLATE FUNCTION merge
template<class _II1, class _II2, class _OI> inline
_OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_X)
        if (*_F2 < *_F1)
            *_X = *_F2++;
        else
            *_X = *_F1++;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION merge WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI merge(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X,
          _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_X)
        if (_P(*_F2, *_F1))
            *_X = *_F2++;
        else
            *_X = *_F1++;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION inplace_merge
template<class _BI> inline
void inplace_merge(_BI _F, _BI _M, _BI _L)
{
    if (_F != _L)
        _Inplace_merge(_F, _M, _L,
                       _Dist_type(_F), _Val_type(_F));
}
template<class _BI, class _Pd, class _Ty> inline
void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pd *, _Ty *)
{
    _Pd _D1 = 0;
    _Distance(_F, _M, _D1);
    _Pd _D2 = 0;
    _Distance(_M, _L, _D2);
    _Temp_iterator<_Ty> _Xb(_D1 < _D2 ? _D1 : _D2);
    _Buffered_merge(_F, _M, _L, _D1, _D2, _Xb);
}
template<class _BI, class _Pd, class _Ty> inline
void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                     _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb)
{
    if (_D1 == 0 || _D2 == 0)
        ;
    else if (_D1 + _D2 == 2)
    {
        if (*_M < *_F)
            iter_swap(_F, _M);
    }
    else if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
    {
        copy(_F, _M, _Xb._Init());
        merge(_Xb._First(), _Xb._Last(), _M, _L, _F);
    }
    else if (_D2 <= _Xb._Maxlen())
    {
        copy(_M, _L, _Xb._Init());
        _Merge_backward(_F, _M, _Xb._First(), _Xb._Last(), _L);
    }
    else
    {
        _BI _Fn, _Ln;
        _Pd _D1n, _D2n;
        if (_D2 < _D1)
        {
            _D1n = _D1 / 2;
            _Fn = _F;
            advance(_Fn, _D1n);
            _Ln = lower_bound(_M, _L, _Ty(*_Fn));
            _Distance(_M, _Ln, _D2n);
        }
        else
        {
            _D2n = _D2 / 2;
            _Ln = _M;
            advance(_Ln, _D2n);
            _Fn = upper_bound(_F, _M, _Ty(*_Ln));
            _Distance(_F, _Fn, _D1n);
        }
        _BI _Mn = _Buffered_rotate(_Fn, _M, _Ln,
                                   _D1 - _D1n, _D2n, _Xb);
        _Buffered_merge(_F, _Fn, _Mn, _D1n, _D2n, _Xb);
        _Buffered_merge(_Mn, _Ln, _L,
                        _D1 - _D1n, _D2 - _D2n, _Xb);
    }
}
template<class _BI1, class _BI2, class _BI3> inline
_BI3 _Merge_backward(_BI1 _F1, _BI1 _L1, _BI2 _F2, _BI2 _L2,
                     _BI3 _X)
{
    for (; ; )
        if (_F1 == _L1)
            return (copy_backward(_F2, _L2, _X));
        else if (_F2 == _L2)
            return (copy_backward(_F1, _L1, _X));
        else if (*--_L2 < *--_L1)
            *--_X = *_L1, ++_L2;
        else
            *--_X = *_L2, ++_L1;
}
template<class _BI, class _Pd, class _Ty> inline
_BI _Buffered_rotate(_BI _F, _BI _M, _BI _L,
                     _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb)
{
    if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
    {
        copy(_F, _M, _Xb._Init());
        copy(_M, _L, _F);
        return (copy_backward(_Xb._First(), _Xb._Last(), _L));
    }
    else if (_D2 <= _Xb._Maxlen())
    {
        copy(_M, _L, _Xb._Init());
        copy_backward(_F, _M, _L);
        return (copy(_Xb._First(), _Xb._Last(), _F));
    }
    else
    {
        rotate(_F, _M, _L);
        advance(_F, _D2);
        return (_F);
    }
}
// TEMPLATE FUNCTION inplace_merge WITH PRED
template<class _BI, class _Pr> inline
void inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P)
{
    if (_F != _L)
        _Inplace_merge(_F, _M, _L, _P,
                       _Dist_type(_F), _Val_type(_F));
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Inplace_merge(_BI _F, _BI _M, _BI _L, _Pr _P,
                    _Pd *, _Ty *)
{
    _Pd _D1 = 0;
    _Distance(_F, _M, _D1);
    _Pd _D2 = 0;
    _Distance(_M, _L, _D2);
    _Temp_iterator<_Ty> _Xb(_D1 < _D2 ? _D1 : _D2);
    _Buffered_merge(_F, _M, _L, _D1, _D2, _Xb, _P);
}
template<class _BI, class _Pd, class _Ty, class _Pr> inline
void _Buffered_merge(_BI _F, _BI _M, _BI _L,
                     _Pd _D1, _Pd _D2, _Temp_iterator<_Ty>& _Xb, _Pr _P)
{
    if (_D1 == 0 || _D2 == 0)
        ;
    else if (_D1 + _D2 == 2)
    {
        if (_P(*_M, *_F))
            iter_swap(_F, _M);
    }
    else if (_D1 <= _D2 && _D1 <= _Xb._Maxlen())
    {
        copy(_F, _M, _Xb._Init());
        merge(_Xb._First(), _Xb._Last(), _M, _L, _F, _P);
    }
    else if (_D2 <= _Xb._Maxlen())
    {
        copy(_M, _L, _Xb._Init());
        _Merge_backward(_F, _M, _Xb._First(), _Xb._Last(),
                        _L, _P);
    }
    else
    {
        _BI _Fn, _Ln;
        _Pd _D1n, _D2n;
        if (_D2 < _D1)
        {
            _D1n = _D1 / 2;
            _Fn = _F;
            advance(_Fn, _D1n);
            _Ln = lower_bound(_M, _L, _Ty(*_Fn), _P);
            _Distance(_M, _Ln, _D2n);
        }
        else
        {
            _D2n = _D2 / 2;
            _Ln = _M;
            advance(_Ln, _D2n);
            _Fn = upper_bound(_F, _M, _Ty(*_Ln), _P);
            _Distance(_F, _Fn, _D1n);
        }
        _BI _Mn = _Buffered_rotate(_Fn, _M, _Ln,
                                   _D1 - _D1n, _D2n, _Xb);
        _Buffered_merge(_F, _Fn, _Mn, _D1n, _D2n, _Xb, _P);
        _Buffered_merge(_Mn, _Ln, _L,
                        _D1 - _D1n, _D2 - _D2n, _Xb, _P);
    }
}
template<class _BI1, class _BI2, class _BI3, class _Pr> inline
_BI3 _Merge_backward(_BI1 _F1, _BI1 _L1, _BI2 _F2, _BI2 _L2,
                     _BI3 _X, _Pr _P)
{
    for (; ; )
        if (_F1 == _L1)
            return (copy_backward(_F2, _L2, _X));
        else if (_F2 == _L2)
            return (copy_backward(_F1, _L1, _X));
        else if (_P(*--_L2, *--_L1))
            *--_X = *_L1, ++_L2;
        else
            *--_X = *_L2, ++_L1;
}
// TEMPLATE FUNCTION includes
template<class _II1, class _II2> inline
bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F2 < *_F1)
            return (false);
        else if (*_F1 < *_F2)
            ++_F1;
        else
            ++_F2;
    return (_F2 == _L2);
}
// TEMPLATE FUNCTION includes WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool includes(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F2, *_F1))
            return (false);
        else if (_P(*_F1, *_F2))
            ++_F1;
        else
            ++_F2;
    return (_F2 == _L2);
}
// TEMPLATE FUNCTION set_union
template<class _II1, class _II2, class _OI> inline
_OI set_union(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            *_X++ = *_F1++;
        else if (*_F2 < *_F1)
            *_X++ = *_F2++;
        else
            *_X++ = *_F1++, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION set_union WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_union(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _OI _X,
              _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            *_X++ = *_F1++;
        else if (_P(*_F2, *_F1))
            *_X++ = *_F2++;
        else
            *_X++ = *_F1++, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION set_intersection
template<class _II1, class _II2, class _OI> inline
_OI set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                     _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            ++_F1;
        else if (*_F2 < *_F1)
            ++_F2;
        else
            *_X++ = *_F1++, ++_F2;
    return (_X);
}
// TEMPLATE FUNCTION set_intersection WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                     _OI _X, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            ++_F1;
        else if (_P(*_F2, *_F1))
            ++_F2;
        else
            *_X++ = *_F1++, ++_F2;
    return (_X);
}
// TEMPLATE FUNCTION set_difference
template<class _II1, class _II2, class _OI> inline
_OI set_difference(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                   _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            *_X++ = *_F1++;
        else if (*_F2 < *_F1)
            ++_F2;
        else
            ++_F1, ++_F2;
    return (copy(_F1, _L1, _X));
}
// TEMPLATE FUNCTION set_difference WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_difference(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2,
                   _OI _X, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            *_X++ = *_F1++;
        else if (_P(*_F2, *_F1))
            ++_F2;
        else
            ++_F1, ++_F2;
    return (copy(_F1, _L1, _X));
}
// TEMPLATE FUNCTION set_symmetric_difference
template<class _II1, class _II2, class _OI> inline
_OI set_symmetric_difference(_II1 _F1, _II1 _L1, _II2 _F2,
                             _II2 _L2, _OI _X)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (*_F1 < *_F2)
            *_X++ = *_F1++;
        else if (*_F2 < *_F1)
            *_X++ = *_F2++;
        else
            ++_F1, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION set_symmetric_difference WITH PRED
template<class _II1, class _II2, class _OI, class _Pr> inline
_OI set_symmetric_difference(_II1 _F1, _II1 _L1, _II2 _F2,
                             _II2 _L2, _OI _X, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; )
        if (_P(*_F1, *_F2))
            *_X++ = *_F1++;
        else if (_P(*_F2, *_F1))
            *_X++ = *_F2++;
        else
            ++_F1, ++_F2;
    return (copy(_F2, _L2, copy(_F1, _L1, _X)));
}
// TEMPLATE FUNCTION push_heap
template<class _RI> inline
void push_heap(_RI _F, _RI _L)
{
    _Push_heap_0(_F, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Push_heap_0(_RI _F, _RI _L, _Pd *, _Ty *)
{
    _Push_heap(_F, _Pd(_L - _F - 1), _Pd(0), _Ty(*(_L - 1)));
}
template<class _RI, class _Pd, class _Ty> inline
void _Push_heap(_RI _F, _Pd _H, _Pd _J, _Ty _V)
{
    for (_Pd _I = (_H - 1) / 2; _J < _H && *(_F + _I) < _V;
        _I = (_H - 1) / 2)
        *(_F + _H) = *(_F + _I), _H = _I;
    *(_F + _H) = _V;
}
// TEMPLATE FUNCTION push_heap WITH PRED
template<class _RI, class _Pr> inline
void push_heap(_RI _F, _RI _L, _Pr _P)
{
    _Push_heap_0(_F, _L, _P,
                 _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Push_heap_0(_RI _F, _RI _L, _Pr _P, _Pd *, _Ty *)
{
    _Push_heap(_F, _Pd(_L - _F - 1), _Pd(0),
               _Ty(*(_L - 1)), _P);
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Push_heap(_RI _F, _Pd _H, _Pd _J, _Ty _V, _Pr _P)
{
    for (_Pd _I = (_H - 1) / 2; _J < _H && _P(*(_F + _I), _V);
        _I = (_H - 1) / 2)
        *(_F + _H) = *(_F + _I), _H = _I;
    *(_F + _H) = _V;
}
// TEMPLATE FUNCTION pop_heap
template<class _RI> inline
void pop_heap(_RI _F, _RI _L)
{
    _Pop_heap_0(_F, _L, _Val_type(_F));
}
template<class _RI, class _Ty> inline
void _Pop_heap_0(_RI _F, _RI _L, _Ty *)
{
    _Pop_heap(_F, _L - 1, _L - 1, _Ty(*(_L - 1)),
              _Dist_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Pop_heap(_RI _F, _RI _L, _RI _X, _Ty _V, _Pd *)
{
    *_X = *_F;
    _Adjust_heap(_F, _Pd(0), _Pd(_L - _F), _V);
}
template<class _RI, class _Pd, class _Ty> inline
void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V)
{
    _Pd _J = _H;
    _Pd _K = 2 * _H + 2;
    for (; _K < _N; _K = 2 * _K + 2)
    {
        if (*(_F + _K) < *(_F + (_K - 1)))
            --_K;
        *(_F + _H) = *(_F + _K), _H = _K;
    }
    if (_K == _N)
        *(_F + _H) = *(_F + (_K - 1)), _H = _K - 1;
    _Push_heap(_F, _H, _J, _V);
}
// TEMPLATE FUNCTION pop_heap WITH PRED
template<class _RI, class _Pr> inline
void pop_heap(_RI _F, _RI _L, _Pr _P)
{
    _Pop_heap_0(_F, _L, _P, _Val_type(_F));
}
template<class _RI, class _Ty, class _Pr> inline
void _Pop_heap_0(_RI _F, _RI _L, _Pr _P, _Ty *)
{
    _Pop_heap(_F, _L - 1, _L - 1, _Ty(*(_L - 1)), _P,
              _Dist_type(_F));
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Pop_heap(_RI _F, _RI _L, _RI _X, _Ty _V, _Pr _P, _Pd *)
{
    *_X = *_F;
    _Adjust_heap(_F, _Pd(0), _Pd(_L - _F), _V, _P);
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Adjust_heap(_RI _F, _Pd _H, _Pd _N, _Ty _V, _Pr _P)
{
    _Pd _J = _H;
    _Pd _K = 2 * _H + 2;
    for (; _K < _N; _K = 2 * _K + 2)
    {
        if (_P(*(_F + _K), *(_F + (_K - 1))))
            --_K;
        *(_F + _H) = *(_F + _K), _H = _K;
    }
    if (_K == _N)
        *(_F + _H) = *(_F + (_K - 1)), _H = _K - 1;
    _Push_heap(_F, _H, _J, _V, _P);
}
// TEMPLATE FUNCTION make_heap
template<class _RI> inline
void make_heap(_RI _F, _RI _L)
{
    if (2 <= _L - _F)
        _Make_heap(_F, _L, _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty> inline
void _Make_heap(_RI _F, _RI _L, _Pd *, _Ty *)
{
    _Pd _N = _L - _F;
    for (_Pd _H = _N / 2; 0 < _H; )
        --_H, _Adjust_heap(_F, _H, _N, _Ty(*(_F + _H)));
}
// TEMPLATE FUNCTION make_heap WITH PRED
template<class _RI, class _Pr> inline
void make_heap(_RI _F, _RI _L, _Pr _P)
{
    if (2 <= _L - _F)
        _Make_heap(_F, _L, _P,
                   _Dist_type(_F), _Val_type(_F));
}
template<class _RI, class _Pd, class _Ty, class _Pr> inline
void _Make_heap(_RI _F, _RI _L, _Pr _P, _Pd *, _Ty *)
{
    _Pd _N = _L - _F;
    for (_Pd _H = _N / 2; 0 < _H; )
        --_H, _Adjust_heap(_F, _H, _N, _Ty(*(_F + _H)), _P);
}
// TEMPLATE FUNCTION sort_heap
template<class _RI> inline
void sort_heap(_RI _F, _RI _L)
{
    for (; 1 < _L - _F; --_L)
        pop_heap(_F, _L);
}
// TEMPLATE FUNCTION sort_heap WITH PRED
template<class _RI, class _Pr> inline
void sort_heap(_RI _F, _RI _L, _Pr _P)
{
    for (; 1 < _L - _F; --_L)
        pop_heap(_F, _L, _P);
}
// TEMPLATE FUNCTION max_element
template<class _FI> inline
_FI max_element(_FI _F, _FI _L)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (*_X < *_F)
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION max_element WITH PRED
template<class _FI, class _Pr> inline
_FI max_element(_FI _F, _FI _L, _Pr _P)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (_P(*_X, *_F))
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION min_element
template<class _FI> inline
_FI min_element(_FI _F, _FI _L)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (*_F < *_X)
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION min_element WITH PRED
template<class _FI, class _Pr> inline
_FI min_element(_FI _F, _FI _L, _Pr _P)
{
    _FI _X = _F;
    if (_F != _L)
        for (; ++_F != _L; )
            if (_P(*_F, *_X))
                _X = _F;
    return (_X);
}
// TEMPLATE FUNCTION next_permutation
template<class _BI> inline
bool next_permutation(_BI _F, _BI _L)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (*--_I < *_Ip)
        {
            _BI _J = _L;
            for (; !(*_I < *--_J); )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}
// TEMPLATE FUNCTION next_permutation WITH PRED
template<class _BI, class _Pr> inline
bool next_permutation(_BI _F, _BI _L, _Pr _P)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (_P(*--_I, *_Ip))
        {
            _BI _J = _L;
            for (; !_P(*_I, *--_J); )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}
// TEMPLATE FUNCTION prev_permutation
template<class _BI> inline
bool prev_permutation(_BI _F, _BI _L)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (!(*--_I < *_Ip))
        {
            _BI _J = _L;
            for (; *_I < *--_J; )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}
// TEMPLATE FUNCTION prev_permutation WITH PRED
template<class _BI, class _Pr> inline
bool prev_permutation(_BI _F, _BI _L, _Pr _P)
{
    _BI _I = _L;
    if (_F == _L || _F == --_I)
        return (false);
    for (; ; )
    {
        _BI _Ip = _I;
        if (!_P(*--_I, *_Ip))
        {
            _BI _J = _L;
            for (; _P(*_I, *--_J); )
                ;
            iter_swap(_I, _J);
            reverse(_Ip, _L);
            return (true);
        }
        if (_I == _F)
        {
            reverse(_F, _L);
            return (false);
        }
    }
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLALGOR_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stliter.h ===
#pragma once
#ifndef _STLITER_H_
#define _STLITER_H_
//#include <utility>

#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS reverse_bidirectional_iterator
template<class _BI, class _Ty, class _Rt = _Ty&,
class _Pt = _Ty *, class _D = ptrdiff_t>
class reverse_bidirectional_iterator : public _Bidit<_Ty, _D>
{
public:
    typedef reverse_bidirectional_iterator<_BI,
    _Ty, _Rt, _Pt, _D> _Myt;
    typedef _BI iter_type;
    typedef _Rt reference_type;
    typedef _Pt pointer_type;
    reverse_bidirectional_iterator()
    {
    }
    explicit reverse_bidirectional_iterator(_BI _X) : current(_X)
    {
    }
    _BI base() const
    {
        return (current);
    }
    _Rt operator*() const
    {
        _BI _Tmp = current;
        return (*--_Tmp);
    }
    _Pt operator->() const
    {
        return (&**this);
    }
    _Myt& operator++()
    {
        --current;
        return (*this);
    }
    _Myt operator++(int)
    {
        _Myt _Tmp = *this;
        --current;
        return (_Tmp);
    }
    _Myt& operator--()
    {
        ++current;
        return (*this);
    }
    _Myt operator--(int)
    {
        _Myt _Tmp = *this;
        ++current;
        return (_Tmp);
    }
protected:
    _BI current;
};
template<class _BI, class _Ty, class _Rt, class _Pt,
class _D> inline
bool operator==(const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _X,
                const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_X.base() == _Y.base());
}
template<class _BI, class _Ty, class _Rt, class _Pt, class _D> inline
bool operator!=(const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _X,
                const reverse_bidirectional_iterator<_BI,
                _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X == _Y));
}

// TEMPLATE CLASS back_insert_iterator
template<class _C>
class back_insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    explicit back_insert_iterator(_C& _X) : container(_X)
    {
    }
    back_insert_iterator<_C>& operator=(const value_type& _V)
    {
        container.push_back(_V);
        return (*this);
    }
    back_insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    back_insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    back_insert_iterator<_C> operator++(int)
    {
        return (*this);
    }protected:
    _C& container;
};
template<class _C> inline
back_insert_iterator<_C> back_inserter(_C& _X)
{
    return (back_insert_iterator<_C>(_X));
}

// TEMPLATE CLASS front_insert_iterator
template<class _C>
class front_insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    explicit front_insert_iterator(_C& _X) : container(_X)
    {
    }
    front_insert_iterator<_C>& operator=(
                                        const value_type& _V)
    {
        container.push_front(_V);
        return (*this);
    }
    front_insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    front_insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    front_insert_iterator<_C> operator++(int)
    {
        return (*this);
    }
protected:
    _C& container;
};

template<class _C> inline
front_insert_iterator<_C> front_inserter(_C& _X)
{
    return (front_insert_iterator<_C>(_X));
}

// TEMPLATE CLASS insert_iterator
template<class _C>
class insert_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _C container_type;
    typedef _C::value_type value_type;
    insert_iterator(_C& _X, _C::iterator _I) : container(_X), iter(_I)
    {
    }
    insert_iterator<_C>& operator=(
                                  const value_type& _V)
    {
        iter = container.insert(iter, _V);
        ++iter;
        return (*this);
    }
    insert_iterator<_C>& operator*()
    {
        return (*this);
    }
    insert_iterator<_C>& operator++()
    {
        return (*this);
    }
    insert_iterator<_C>& operator++(int)
    {
        return (*this);
    }
protected:
    _C& container;
    _C::iterator iter;
};

template<class _C, class _XI> inline
insert_iterator<_C> inserter(_C& _X, _XI _I)
{
    return (insert_iterator<_C>(_X, _C::iterator(_I)));
}

/*
// TEMPLATE CLASS istream_iterator
template<class _U, class _E = char, class _Tr = char_traits<_E> >
class istream_iterator : public iterator<input_iterator_tag, _U, ptrdiff_t>
{
public:
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_istream<_E, _Tr> istream_type;
    istream_iterator() : _Istr(0)
    {
    }
    istream_iterator(istream_type& _I) : _Istr(&_I)
    {
        _Getval();
    }
    const _U& operator*() const
    {
        return (_Val);
    }
    const _U *operator->() const
    {
        return (&**this);
    }
    istream_iterator<_U, _E, _Tr>& operator++()
    {
        _Getval();
        return (*this);
    }
    istream_iterator<_U, _E, _Tr> operator++(int)
    {
        istream_iterator<_U, _E, _Tr> _Tmp = *this;
        _Getval();
        return (_Tmp);
    }
    bool _Equal(const istream_iterator<_U, _E, _Tr>& _X) const
    {
        return (_Istr == _X._Istr);
    }
protected:
    void _Getval()
    {
        if (_Istr != 0 && !(*_Istr >> _Val))
            _Istr = 0;
    }
    istream_type *_Istr;
    _U _Val;
};
template<class _U, class _E, class _Tr> inline
bool operator==(const istream_iterator<_U, _E, _Tr>& _X,
                const istream_iterator<_U, _E, _Tr>& _Y)
{
    return (_X._Equal(_Y));
}
template<class _U, class _E, class _Tr> inline
bool operator!=(const istream_iterator<_U, _E, _Tr>& _X,
                const istream_iterator<_U, _E, _Tr>& _Y)
{
    return (!(_X == _Y));
}
// TEMPLATE CLASS ostream_iterator
template<class _U, class _E = char,
class _Tr = char_traits<_E> >
class ostream_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _U value_type;
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_ostream<_E, _Tr> ostream_type;
    ostream_iterator(ostream_type& _O,
                     const _E *_D = 0) : _Ostr(&_O), _Delim(_D)
    {
    }
    ostream_iterator<_U, _E, _Tr>& operator=(const _U& _X)
    {
        *_Ostr << _X;
        if (_Delim != 0)
            *_Ostr << _Delim;
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr>& operator*()
    {
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr>& operator++()
    {
        return (*this);
    }
    ostream_iterator<_U, _E, _Tr> operator++(int)
    {
        return (*this);
    }
protected:
    const _E *_Delim;
    ostream_type *_Ostr;
};
*/

// TEMPLATE FUNCTION _Val_type
template<class _C, class _Ty, class _D> inline
_Ty *_Val_type(const iterator<_C, _Ty, _D>&)
{
    return ((_Ty *)0);
}
template<class _Ty> inline
_Ty *_Val_type(const _Ty *)
{
    return ((_Ty *)0);
}
// TEMPLATE FUNCTION advance
template<class _II, class _D> inline
void advance(_II& _I, _D _N)
{
    _Advance(_I, _N, _Iter_cat(_I));
}
template<class _II, class _D> inline
void _Advance(_II& _I, _D _N, input_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
}
template<class _FI, class _D> inline
void _Advance(_FI& _I, _D _N, forward_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
}
template<class _BI, class _D> inline
void _Advance(_BI& _I, _D _N, bidirectional_iterator_tag)
{
    for (; 0 < _N; --_N)
        ++_I;
    for (; _N < 0; ++_N)
        --_I;
}
template<class _RI, class _D> inline
void _Advance(_RI& _I, _D _N, random_access_iterator_tag)
{
    _I += _N;
}
// TEMPLATE FUNCTION _Dist_type
template<class _C, class _Ty, class _D> inline
_D *_Dist_type(const iterator<_C, _Ty, _D>&)
{
    return ((_D *)0);
}
template<class _Ty> inline
ptrdiff_t *_Dist_type(const _Ty *)
{
    return ((ptrdiff_t *)0);
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLITER_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlexcep.h ===
/***
*exception - Defines class exception and related functions
*
*   Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*   Modified January 1996 by P.J. Plauger
*
*Purpose:
*       Defines class exception (and derived class bad_exception)
*       plus new and unexpected handler functions.
*
*       [Public]
*
****/

#ifndef _STLEXCEP_H_
#define _STLEXCEP_H_
//#include <xstddef>
//#include <eh.h>

#include <stlxstdd.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#if !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif

/*
#ifndef _CRTIMP
#ifdef  _NTSDK
// definition compatible with NT SDK
#define _CRTIMP
#else   // ndef _NTSDK
// current definition
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // _NTSDK
#endif  // _CRTIMP
*/

typedef const char *__exString;

class /*_CRTIMP*/ exception
{
public:
    exception();
    exception(const __exString&);
    exception(const exception&);
    exception& operator= (const exception&);
    virtual ~exception();
    virtual __exString what() const;
private:
    __exString _m_what;
    int _m_doFree;
};

_STD_BEGIN
using ::exception;

// CLASS bad_exception
class /*_CRTIMP*/ bad_exception : public exception
{
public:
    bad_exception(const char *_S = "bad exception") _THROW0()
    : exception(_S)
    {
    }
    virtual ~bad_exception() _THROW0()
    {
    }
protected:
    virtual void _Doraise() const
    {
        _RAISE(*this);
    }
};

/*_CRTIMP*/
bool __cdecl uncaught_exception();

_STD_END

#ifdef __RTTI_OLDNAMES
typedef exception xmsg;        // A synonym for folks using older standard
#endif

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLEXCEP_H_ */

/*
 * 1994-1995, Microsoft Corporation. All rights reserved.
 * Modified January 1996 by P.J. Plauger
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlnew.h ===
#pragma once
#ifndef _STLNEW_H_
#define _STLNEW_H_
//#include <exception>

#include <stlexcep.h>
#include "ncmem.h"

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// CLASS bad_alloc
class /*_CRTIMP*/ bad_alloc : public exception
{
public:
    bad_alloc(const char *_S = "bad allocation") _THROW0() : exception(_S)
    {
    }
    virtual ~bad_alloc() _THROW0()
    {
    }
protected:
    virtual void _Doraise() const
    {
        _RAISE(*this);
    }
};

// SUPPORT TYPES
struct nothrow_t
{
};
extern /*_CRTIMP*/ const nothrow_t nothrow;

_STD_END

/*
typedef void (__cdecl *new_handler)();
extern new_handler _New_hand;

// new AND delete DECLARATIONS
void  __cdecl operator delete(void *) _THROW0();
void* __cdecl operator new(size_t) _THROW1(std::bad_alloc);
void* __cdecl operator new(size_t, const std::nothrow_t&) _THROW0();
*/

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
{
    return (_P);
}
#if  _MSC_VER >= 1200
inline void __cdecl operator delete(void *, void*)
{
    return;
}
#endif
#endif

/*
#ifdef _CRTIMP
_CRTIMP
#endif
new_handler __cdecl set_new_handler(new_handler) _THROW0();
*/

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLNEW_H_ */

/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stllist.h ===
#pragma once
#ifndef _STLLIST_H_
#define _STLLIST_H_
//#include <cstddef>
//#include <functional>
//#include <iterator>
//#include <memory>
//#include <stdexcept>
//#include <xutility>

#include <stlxstdd.h>
#include <stlfunc.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS list
template<class _Ty, class _A = allocator<_Ty> >
class list
{
protected:
    typedef _POINTER_X(void, _A) _Genptr;
    struct _Node;
    friend struct _Node;
    struct _Node
    {
        _Genptr _Next, _Prev;
        _Ty _Value;
    };
    typedef _POINTER_X(_Node, _A) _Nodeptr;
    struct _Acc;
    friend struct _Acc;
    struct _Acc
    {
        typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;
        typedef _A::reference _Vref;
        static _Nodepref _Next(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Next);
        }
        static _Nodepref _Prev(_Nodeptr _P)
        {
            return ((_Nodepref)(*_P)._Prev);
        }
        static _Vref _Value(_Nodeptr _P)
        {
            return ((_Vref)(*_P)._Value);
        }
    };
public:
    typedef list<_Ty, _A> _Myt;
    typedef _A allocator_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    typedef _A::pointer _Tptr;
    typedef _A::const_pointer _Ctptr;
    typedef _A::reference reference;
    typedef _A::const_reference const_reference;
    typedef _A::value_type value_type;
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator : public _Bidit<_Ty, difference_type>
    {
    public:
        iterator()
        {

        }
        iterator(_Nodeptr _P)
        : _Ptr(_P)
        {

        }
        reference operator*() const
        {
            return (_Acc::_Value(_Ptr));
        }
        _Tptr operator->() const
        {
            return (&**this);
        }
        iterator& operator++()
        {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        _Nodeptr _Mynode() const
        {
            return (_Ptr);
        }
    protected:
        _Nodeptr _Ptr;
    };
    // CLASS const_iterator
    class const_iterator;
    friend class const_iterator;
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        {

        }
        const_iterator(_Nodeptr _P)
        : iterator(_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (_Acc::_Value(_Ptr));
        }
        _Ctptr operator->() const
        {
            return (&**this);
        }
        const_iterator& operator++()
        {
            _Ptr = _Acc::_Next(_Ptr);
            return (*this);
        }
        const_iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Ptr = _Acc::_Prev(_Ptr);
            return (*this);
        }
        const_iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
    };
    typedef reverse_bidirectional_iterator<iterator,
    value_type, reference, _Tptr, difference_type>
    reverse_iterator;
    typedef reverse_bidirectional_iterator<const_iterator,
    value_type, const_reference, _Ctptr, difference_type>
    const_reverse_iterator;
    explicit list(const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {

    }
    explicit list(size_type _N, const _Ty& _V = _Ty(),
                  const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _N, _V);
    }
    list(const _Myt& _X)
    : allocator(_X.allocator),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _X.begin(), _X.end());
    }
    typedef const_iterator _It;
    list(_It _F, _It _L, const _A& _Al = _A())
    : allocator(_Al),
    _Head(_Buynode()), _Size(0)
    {
        insert(begin(), _F, _L);
    }
    ~list()
    {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0;
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this != &_X)
        {
            iterator _F1 = begin();
            iterator _L1 = end();
            const_iterator _F2 = _X.begin();
            const_iterator _L2 = _X.end();
            for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
                *_F1 = *_F2;
            erase(_F1, _L1);
            insert(_L1, _F2, _L2);
        }
        return (*this);
    }
    iterator begin()
    {
        return (iterator(_Acc::_Next(_Head)));
    }
    const_iterator begin() const
    {
        return (const_iterator(_Acc::_Next(_Head)));
    }
    iterator end()
    {
        return (iterator(_Head));
    }
    const_iterator end() const
    {
        return (const_iterator(_Head));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, _Ty _X = _Ty())
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else
            while (_N < size())
                pop_back();
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(--end()));
    }
    const_reference back() const
    {
        return (*(--end()));
    }
    void push_front(const _Ty& _X)
    {
        insert(begin(), _X);
    }
    void pop_front()
    {
        erase(begin());
    }
    void push_back(const _Ty& _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(--end());
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const _Ty& _X = _Ty())
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const _Ty& _X = _Ty())
    {
        _Nodeptr _S = _P._Mynode();
        _Acc::_Prev(_S) = _Buynode(_S, _Acc::_Prev(_S));
        _S = _Acc::_Prev(_S);
        _Acc::_Next(_Acc::_Prev(_S)) = _S;
        allocator.construct(&_Acc::_Value(_S), _X);
        ++_Size;
        return (iterator(_S));
    }
    void insert(iterator _P, size_type _M, const _Ty& _X)
    {
        for (; 0 < _M; --_M)
            insert(_P, _X);
    }
    void insert(iterator _P, const _Ty *_F, const _Ty *_L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            insert(_P, *_F);
    }
    iterator erase(iterator _P)
    {
        _Nodeptr _S = (_P++)._Mynode();
        _Acc::_Next(_Acc::_Prev(_S)) = _Acc::_Next(_S);
        _Acc::_Prev(_Acc::_Next(_S)) = _Acc::_Prev(_S);
        allocator.destroy(&_Acc::_Value(_S));
        _Freenode(_S);
        --_Size;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        while (_F != _L)
            erase(_F++);
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    void swap(_Myt& _X)
    {
        if (allocator == _X.allocator)
        {
            std::swap(_Head, _X._Head);
            std::swap(_Size, _X._Size);
        }
        else
        {
            iterator _P = begin();
            splice(_P, _X);
            _X.splice(_X.begin(), *this, _P, end());
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    void splice(iterator _P, _Myt& _X)
    {
        if (!_X.empty())
        {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F)
    {
        iterator _L = _F;
        if (_P != _F && _P != ++_L)
        {
            _Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (_F != _L)
        {
            if (&_X != this)
            {
                size_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N;
            }
            _Splice(_P, _X, _F, _L);
        }
    }
    void remove(const _Ty& _V)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F;
    }
    typedef binder2nd<not_equal_to<_Ty> > _Pr1;
    void remove_if(_Pr1 _Pr)
    {
        iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F;
    }
    void unique()
    {
        iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (*_F == *_M)
                    erase(_M);
                else
                    _F = _M;
    }
    typedef not_equal_to<_Ty> _Pr2;
    void unique(_Pr2 _Pr)
    {
        iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (_Pr(*_F, *_M))
                    erase(_M);
                else
                    _F = _M;
    }
    void merge(_Myt& _X)
    {
        if (&_X != this)
        {
            iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (*_F2 < *_F1)
                {
                    iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2;
                }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    typedef greater<_Ty> _Pr3;
    void merge(_Myt& _X, _Pr3 _Pr)
    {
        if (&_X != this)
        {
            iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (_Pr(*_F2, *_F1))
                {
                    iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2;
                }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void sort()
    {
        if (2 <= size())
        {
            const size_t _MAXN = 15;
            _Myt _X(allocator), _A[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
            {
                _X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
                {
                    _A[_I].merge(_X);
                    _A[_I].swap(_X);
                }
                if (_I == _MAXN)
                    _A[_I].merge(_X);
                else
                {
                    _A[_I].swap(_X);
                    if (_I == _N)
                        ++_N;
                }
            }
            while (0 < _N)
                merge(_A[--_N]);
        }
    }
    void sort(_Pr3 _Pr)
    {
        if (2 <= size())
        {
            const size_t _MAXN = 15;
            _Myt _X(allocator), _A[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
            {
                _X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !_A[_I].empty(); ++_I)
                {
                    _A[_I].merge(_X, _Pr);
                    _A[_I].swap(_X);
                }
                if (_I == _MAXN)
                    _A[_I].merge(_X, _Pr);
                else
                {
                    _A[_I].swap(_X);
                    if (_I == _N)
                        ++_N;
                }
            }
            while (0 < _N)
                merge(_A[--_N], _Pr);
        }
    }
    void reverse()
    {
        if (2 <= size())
        {
            iterator _L = end();
            for (iterator _F = ++begin(); _F != _L; )
            {
                iterator _M = _F;
                _Splice(begin(), *this, _M, ++_F);
            }
        }
    }
protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
    {
        _Nodeptr _S = (_Nodeptr)allocator._Charalloc(
                                                    1 * sizeof (_Node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S);
    }
    void _Freenode(_Nodeptr _S)
    {
        allocator.deallocate(_S, 1);
    }
    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
    {
        if (allocator == _X.allocator)
        {
            _Acc::_Next(_Acc::_Prev(_L._Mynode())) =
            _P._Mynode();
            _Acc::_Next(_Acc::_Prev(_F._Mynode())) =
            _L._Mynode();
            _Acc::_Next(_Acc::_Prev(_P._Mynode())) =
            _F._Mynode();
            _Nodeptr _S = _Acc::_Prev(_P._Mynode());
            _Acc::_Prev(_P._Mynode()) =
            _Acc::_Prev(_L._Mynode());
            _Acc::_Prev(_L._Mynode()) =
            _Acc::_Prev(_F._Mynode());
            _Acc::_Prev(_F._Mynode()) = _S;
        }
        else
        {
            insert(_P, _F, _L);
            _X.erase(_F, _L);
        }
    }
    void _Xran() const
    {
        _THROW(out_of_range, "invalid list<T> subscript");
    }
    _A allocator;
    _Nodeptr _Head;
    size_type _Size;
};

// list TEMPLATE OPERATORS
template<class _Ty, class _A> inline
bool operator==(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _Ty, class _A> inline
bool operator!=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _Ty, class _A> inline
bool operator<(const list<_Ty, _A>& _X,
               const list<_Ty, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _Ty, class _A> inline
bool operator>(const list<_Ty, _A>& _X,
               const list<_Ty, _A>& _Y)
{
    return (_Y < _X);
}
template<class _Ty, class _A> inline
bool operator<=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _Ty, class _A> inline
bool operator>=(const list<_Ty, _A>& _X,
                const list<_Ty, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLLIST_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlmap.h ===
#pragma once
#ifndef _STLMAP_H_
#define _STLMAP_H_
//#include <functional>
//#include <xtree>

#include <stlfunc.h>
#include <stlxtree.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS map
template<class _K, class _Ty, class _Pr = less<_K>, class _A = allocator<_Ty> >
class map
{
public:
    typedef map<_K, _Ty, _Pr, _A> _Myt;
    typedef pair<const _K, _Ty> value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X.first);
        }
    };
    class value_compare
    : public binary_function<value_type, value_type, bool>
    {
        friend class map<_K, _Ty, _Pr, _A>;
    public:
        bool operator()(const value_type& _X,
                        const value_type& _Y) const
        {
            return (comp(_X.first, _Y.first));
        }
        _PROTECTED:
        value_compare(_Pr _Pred)
        : comp(_Pred)
        {

        }
        _Pr comp;
    };
    typedef _K key_type;
    typedef _Ty referent_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _A::reference _Tref;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<iterator, bool> _Pairib;
    typedef pair<iterator, iterator> _Pairii;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit map(const _Pr& _Pred = _Pr(), const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {

    }
    typedef const value_type *_It;
    map(_It _F, _It _L, const _Pr& _Pred = _Pr(),
        const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator begin()
    {
        return (_Tr.begin());
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    iterator end()
    {
        return (_Tr.end());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    reverse_iterator rbegin()
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    reverse_iterator rend()
    {
        return (_Tr.rend());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    _Tref operator[](const key_type& _Kv)
    {
        iterator _P = insert(value_type(_Kv, _Ty())).first;
        return ((*_P).second);
    }
    _Pairib insert(const value_type& _X)
    {
        _Imp::_Pairib _Ans = _Tr.insert(_X);
        return (_Pairib(_Ans.first, _Ans.second));
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv)
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (value_compare(_Tr.key_comp()));
    }
    iterator find(const _K& _Kv)
    {
        return (_Tr.find(_Kv));
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    iterator lower_bound(const _K& _Kv)
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    iterator upper_bound(const _K& _Kv)
    {
        return (_Tr.upper_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Pairii equal_range(const _K& _Kv)
    {
        return (_Tr.equal_range(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};
// map TEMPLATE OPERATORS
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator==(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator!=(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<(const map<_K, _Ty, _Pr, _A>& _X,
               const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>(const map<_K, _Ty, _Pr, _A>& _X,
               const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<=(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>=(const map<_K, _Ty, _Pr, _A>& _X,
                const map<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}
// TEMPLATE CLASS multimap
template<class _K, class _Ty, class _Pr = less<_K>,
class _A = allocator<_Ty> >
class multimap
{
public:
    typedef multimap<_K, _Ty, _Pr, _A> _Myt;
    typedef pair<const _K, _Ty> value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X.first);
        }
    };
    class value_compare
    : public binary_function<value_type, value_type, bool>
    {
        friend class map<_K, _Ty, _Pr, _A>;
    public:
        bool operator()(const value_type& _X,
                        const value_type& _Y) const
        {
            return (comp(_X.first, _Y.first));
        }
        _PROTECTED:
        value_compare(_Pr _Pred)
        : comp(_Pred)
        {

        }
        _Pr comp;
    };
    typedef _K key_type;
    typedef _Ty referent_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<iterator, iterator> _Pairii;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit multimap(const _Pr& _Pred = _Pr(),
                      const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {

    }
    typedef const value_type *_It;
    multimap(_It _F, _It _L, const _Pr& _Pred = _Pr(),
             const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator begin()
    {
        return (_Tr.begin());
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    iterator end()
    {
        return (_Tr.end());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    reverse_iterator rbegin()
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    reverse_iterator rend()
    {
        return (_Tr.rend());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    iterator insert(const value_type& _X)
    {
        return (_Tr.insert(_X).first);
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv = _K())
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (value_compare(_Tr.key_comp()));
    }
    iterator find(const _K& _Kv)
    {
        return (_Tr.find(_Kv));
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    iterator lower_bound(const _K& _Kv)
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    iterator upper_bound(const _K& _Kv)
    {
        return (_Tr.upper_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Pairii equal_range(const _K& _Kv)
    {
        return (_Tr.equal_range(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};
// multimap TEMPLATE OPERATORS
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator==(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator!=(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<(const multimap<_K, _Ty, _Pr, _A>& _X,
               const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>(const multimap<_K, _Ty, _Pr, _A>& _X,
               const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator<=(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Ty, class _Pr, class _A> inline
bool operator>=(const multimap<_K, _Ty, _Pr, _A>& _X,
                const multimap<_K, _Ty, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLMAP_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlmem.h ===
#pragma once
#ifndef _STLMEM_H_
#define _STLMEM_H_
//#include <memory>

#include <stlxmem.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

// TEMPLATE OPERATOR new
template<class _Ty> inline
void *operator new(size_t _N, std::allocator<_Ty>& _Al)
{
    return (_Al._Charalloc(_N));
}

_STD_BEGIN

// TEMPLATE FUNCTION get_temporary_buffer
template<class _Ty> inline
pair<_Ty _FARQ *, _PDFT>
get_temporary_buffer(_PDFT _N, _Ty _FARQ *)
{
    _Ty _FARQ *_P;
    for (_P = 0; 0 < _N; _N /= 2)
        if ((_P = (_Ty _FARQ *)operator new(
                                           (_SIZT)_N * sizeof (_Ty), nothrow)) != 0)
            break;
    return (pair<_Ty _FARQ *, _PDFT>(_P, _N));
}

// TEMPLATE FUNCTION return_temporary_buffer
template<class _Ty> inline
void return_temporary_buffer(_Ty *_P)
{
    operator delete(_P);
}

// TEMPLATE FUNCTION uninitialized_copy
template<class _II, class _FI> inline
_FI uninitialized_copy(_II _F, _II _L, _FI _X)
{
    for (; _F != _L; ++_X, ++_F)
        _Construct(&*_X, *_F);
    return (_X);
}

// TEMPLATE FUNCTION uninitialized_fill
template<class _FI, class _Ty> inline
void uninitialized_fill(_FI _F, _FI _L, const _Ty& _X)
{
    for (; _F != _L; ++_F)
        _Construct(&*_F, _X);
}

// TEMPLATE FUNCTION uninitialized_fill_n
template<class _FI, class _S, class _Ty> inline
void uninitialized_fill_n(_FI _F, _S _N, const _Ty& _X)
{
    for (; 0 < _N; --_N, ++_F)
        _Construct(&*_F, _X);
}

// TEMPLATE CLASS raw_storage_iterator
template<class _OI, class _Ty>
class raw_storage_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _OI iterator_type;
    typedef _Ty element_type;
    explicit raw_storage_iterator(_OI _X) : _Next(_X)
    {
    }
    raw_storage_iterator<_OI, _Ty>& operator*()
    {
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty>& operator=(const _Ty& _X)
    {
        _Construct(&*_Next, _X);
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty>& operator++()
    {
        ++_Next;
        return (*this);
    }
    raw_storage_iterator<_OI, _Ty> operator++(int)
    {
        raw_storage_iterator<_OI, _Ty> _Ans = *this;
        ++_Next;
        return (_Ans);
    }
private:
    _OI _Next;
};

// TEMPLATE CLASS _Temp_iterator
template<class _Ty>
class _Temp_iterator : public iterator<output_iterator_tag, void, void>
{
public:
    typedef _Ty _FARQ *_Pty;
    _Temp_iterator(_PDFT _N = 0)
    {
        pair<_Pty, _PDFT> _Pair =
        get_temporary_buffer(_N, (_Pty)0);
        _Buf._Begin = _Pair.first;
        _Buf._Cur = _Pair.first;
        _Buf._Hiwater = _Pair.first;
        _Buf._Len = _Pair.second;
        _Pb = &_Buf;
    }
    _Temp_iterator(const _Temp_iterator<_Ty>& _X)
    {
        _Buf._Begin = 0;
        _Buf._Cur = 0;
        _Buf._Hiwater = 0;
        _Buf._Len = 0;
        *this = _X;
    }
    ~_Temp_iterator()
    {
        if (_Buf._Begin != 0)
        {
            for (_Pty _F = _Buf._Begin;
                _F != _Buf._Hiwater; ++_F)
                _Destroy(&*_F);
            return_temporary_buffer(_Buf._Begin);
        }
    }
    _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _X)
    {
        _Pb = _X._Pb;
        return (*this);
    }
    _Temp_iterator<_Ty>& operator=(const _Ty& _V)
    {
        if (_Pb->_Cur < _Pb->_Hiwater)
            *_Pb->_Cur++ = _V;
        else
        {
            _Construct(&*_Pb->_Cur, _V);
            _Pb->_Hiwater = ++_Pb->_Cur;
        }
        return (*this);
    }
    _Temp_iterator<_Ty>& operator*()
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& operator++()
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& operator++(int)
    {
        return (*this);
    }
    _Temp_iterator<_Ty>& _Init()
    {
        _Pb->_Cur = _Pb->_Begin;
        return (*this);
    }
    _Pty _First() const
    {
        return (_Pb->_Begin);
    }
    _Pty _Last() const
    {
        return (_Pb->_Cur);
    }
    _PDFT _Maxlen() const
    {
        return (_Pb->_Len);
    }
private:
    struct _Bufpar
    {
        _Pty _Begin;
        _Pty _Cur;
        _Pty _Hiwater;
        _PDFT _Len;
    } _Buf, *_Pb;
};

// TEMPLATE CLASS auto_ptr
template<class _Ty>
class auto_ptr
{
public:
    typedef _Ty element_type;
    explicit auto_ptr(_Ty *_P = 0) _THROW0() : _Owns(_P != 0), _Ptr(_P)
    {
    }
    auto_ptr(const auto_ptr<_Ty>& _Y) _THROW0()
        : _Owns(_Y._Owns), _Ptr(_Y.release())
    {
    }
    auto_ptr<_Ty>& operator=(const auto_ptr<_Ty>& _Y) _THROW0()
    {
        if (_Ptr != _Y.get())
        {
            if (_Owns)
                delete _Ptr;
            _Owns = _Y._Owns;
            _Ptr = _Y.release();
        }
        else if (_Y._Owns)
            _Owns = true;
        return (*this);
    }
    ~auto_ptr()
    {
        if (_Owns)
            delete _Ptr;
    }
    _Ty& operator*() const _THROW0()
    {
        return (*get());
    }
    _Ty *operator->() const _THROW0()
    {
        return (get());
    }
    _Ty *get() const _THROW0()
    {
        return (_Ptr);
    }
    _Ty *release() const _THROW0()
    {
        ((auto_ptr<_Ty> *)this)->_Owns = false;
        return (_Ptr);
    }
private:
    bool _Owns;
    _Ty *_Ptr;
};

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLMEM_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlxutil.h ===
#pragma once
#ifndef _STLXUTIL_H_
#define _STLXUTIL_H_
//#include <utility>

#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE FUNCTION copy
template<class _II, class _OI> inline
_OI copy(_II _F, _II _L, _OI _X)
{
    for (; _F != _L; ++_X, ++_F)
        *_X = *_F;
    return (_X);
}
// TEMPLATE FUNCTION copy_backward
template<class _BI1, class _BI2> inline
_BI2 copy_backward(_BI1 _F, _BI1 _L, _BI2 _X)
{
    while (_F != _L)
        *--_X = *--_L;
    return (_X);
}
// TEMPLATE FUNCTION equal
template<class _II1, class _II2> inline
bool equal(_II1 _F, _II1 _L, _II2 _X)
{
    return (mismatch(_F, _L, _X).first == _L);
}
// TEMPLATE FUNCTION equal WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool equal(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
{
    return (mismatch(_F, _L, _X, _P).first == _L);
}
// TEMPLATE FUNCTION fill
template<class _FI, class _Ty> inline
void fill(_FI _F, _FI _L, const _Ty& _X)
{
    for (; _F != _L; ++_F)
        *_F = _X;
}
// TEMPLATE FUNCTION fill_n
template<class _OI, class _Sz, class _Ty> inline
void fill_n(_OI _F, _Sz _N, const _Ty& _X)
{
    for (; 0 < _N; --_N, ++_F)
        *_F = _X;
}
// TEMPLATE FUNCTION lexicographical_compare
template<class _II1, class _II2> inline
bool lexicographical_compare(_II1 _F1, _II1 _L1,
                             _II2 _F2, _II2 _L2)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
        if (*_F1 < *_F2)
            return (true);
        else if (*_F2 < *_F1)
            return (false);
    return (_F1 == _L1 && _F2 != _L2);
}
// TEMPLATE FUNCTION lexicographical_compare WITH PRED
template<class _II1, class _II2, class _Pr> inline
bool lexicographical_compare(_II1 _F1, _II1 _L1,
                             _II2 _F2, _II2 _L2, _Pr _P)
{
    for (; _F1 != _L1 && _F2 != _L2; ++_F1, ++_F2)
        if (_P(*_F1, *_F2))
            return (true);
        else if (_P(*_F2, *_F1))
            return (false);
    return (_F1 == _L1 && _F2 != _L2);
}
// TEMPLATE FUNCTION max
#ifndef _MAX
 #define _MAX   _cpp_max
 #define _MIN   _cpp_min
#endif
template<class _Ty> inline
const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y)
{
    return (_X < _Y ? _Y : _X);
}
// TEMPLATE FUNCTION max WITH PRED
template<class _Ty, class _Pr> inline
const _Ty& _cpp_max(const _Ty& _X, const _Ty& _Y, _Pr _P)
{
    return (_P(_X, _Y) ? _Y : _X);
}
// TEMPLATE FUNCTION min
template<class _Ty> inline
const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y)
{
    return (_Y < _X ? _Y : _X);
}
// TEMPLATE FUNCTION min WITH PRED
template<class _Ty, class _Pr> inline
const _Ty& _cpp_min(const _Ty& _X, const _Ty& _Y, _Pr _P)
{
    return (_P(_Y, _X) ? _Y : _X);
}
// TEMPLATE FUNCTION mismatch
template<class _II1, class _II2> inline
pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X)
{
    for (; _F != _L && *_F == *_X; ++_F, ++_X)
        ;
    return (pair<_II1, _II2>(_F, _X));
}
// TEMPLATE FUNCTION mismatch WITH PRED
template<class _II1, class _II2, class _Pr> inline
pair<_II1, _II2> mismatch(_II1 _F, _II1 _L, _II2 _X, _Pr _P)
{
    for (; _F != _L && _P(*_F, *_X); ++_F, ++_X)
        ;
    return (pair<_II1, _II2>(_F, _X));
}
// TEMPLATE FUNCTION swap
template<class _Ty> inline
void swap(_Ty& _X, _Ty& _Y)
{
    _Ty _Tmp = _X;
    _X = _Y, _Y = _Tmp;
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXUTIL_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlfunc.h ===
#pragma once
#ifndef _STLFUNC_H_
#define _STLFUNC_H_
//#include <xstddef>

#include <stddef.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE STRUCT unary_function
template<class _A, class _R>
struct unary_function
{
    typedef _A argument_type;
    typedef _R result_type;
};

// TEMPLATE STRUCT binary_function
template<class _A1, class _A2, class _R>
struct binary_function
{
    typedef _A1 first_argument_type;
    typedef _A2 second_argument_type;
    typedef _R result_type;
};

// TEMPLATE STRUCT plus
template<class _Ty>
struct plus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X + _Y);
    }
};

// TEMPLATE STRUCT minus
template<class _Ty>
struct minus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X - _Y);
    }
};

// TEMPLATE STRUCT multiplies
template<class _Ty>
struct multiplies : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X * _Y);
    }
};

// TEMPLATE STRUCT divides
template<class _Ty>
struct divides : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X / _Y);
    }
};

// TEMPLATE STRUCT modulus
template<class _Ty>
struct modulus : binary_function<_Ty, _Ty, _Ty>
{
    _Ty operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X % _Y);
    }
};

// TEMPLATE STRUCT negate
template<class _Ty>
struct negate : unary_function<_Ty, _Ty>
{
    _Ty operator()(const _Ty& _X) const
    {
        return (-_X);
    }
};

// TEMPLATE STRUCT equal_to
template<class _Ty>
struct equal_to : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X == _Y);
    }
};

// TEMPLATE STRUCT not_equal_to
template<class _Ty>
struct not_equal_to : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X != _Y);
    }
};

// TEMPLATE STRUCT greater
template<class _Ty>
struct greater : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X > _Y);
    }
};

// TEMPLATE STRUCT less
template<class _Ty>
struct less : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X < _Y);
    }
};

// TEMPLATE STRUCT greater_equal
template<class _Ty>
struct greater_equal : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X >= _Y);
    }
};

// TEMPLATE STRUCT less_equal
template<class _Ty>
struct less_equal : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X <= _Y);
    }
};

// TEMPLATE STRUCT logical_and
template<class _Ty>
struct logical_and : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X && _Y);
    }
};

// TEMPLATE STRUCT logical_or
template<class _Ty>
struct logical_or : binary_function<_Ty, _Ty, bool>
{
    bool operator()(const _Ty& _X, const _Ty& _Y) const
    {
        return (_X || _Y);
    }
};

// TEMPLATE STRUCT logical_not
template<class _Ty>
struct logical_not : unary_function<_Ty, bool>
{
    bool operator()(const _Ty& _X) const
    {
        return (!_X);
    }
};

// TEMPLATE CLASS unary_negate
template<class _Ufn>
class unary_negate
: public unary_function<_Ufn::argument_type, bool>
{
public:
    explicit unary_negate(const _Ufn& _X)
    : _Fn(_X)
    {

    }
    bool operator()(const _Ufn::argument_type& _X) const
    {
        return (!_Fn(_X));
    }
protected:
    _Ufn _Fn;
};

// TEMPLATE FUNCTION not1
template<class _Ufn> inline
unary_negate<_Ufn> not1(const _Ufn& _X)
{
    return (unary_negate<_Ufn>(_X));
}

// TEMPLATE CLASS binary_negate
template<class _Bfn>
class binary_negate
: public binary_function<_Bfn::first_argument_type,
_Bfn::second_argument_type, bool>
{
public:
    explicit binary_negate(const _Bfn& _X)
    : _Fn(_X)
    {

    }
    bool operator()(const _Bfn::first_argument_type& _X,
                    const _Bfn::second_argument_type& _Y) const
    {
        return (!_Fn(_X, _Y));
    }
protected:
    _Bfn _Fn;
};

// TEMPLATE FUNCTION not2
template<class _Bfn> inline
binary_negate<_Bfn> not2(const _Bfn& _X)
{
    return (binary_negate<_Bfn>(_X));
}

// TEMPLATE CLASS binder1st
template<class _Bfn>
class binder1st
: public unary_function<_Bfn::second_argument_type,
_Bfn::result_type>
{
public:
    binder1st(const _Bfn& _X,
              const _Bfn::first_argument_type& _Y)
    : op(_X), value(_Y)
    {

    }
    result_type operator()(const argument_type& _X) const
    {
        return (op(value, _X));
    }
protected:
    _Bfn op;
    _Bfn::first_argument_type value;
};

// TEMPLATE FUNCTION bind1st
template<class _Bfn, class _Ty> inline
binder1st<_Bfn> bind1st(const _Bfn& _X, const _Ty& _Y)
{
    return (binder1st<_Bfn>(_X,
                            _Bfn::first_argument_type(_Y)));
}

// TEMPLATE CLASS binder2nd
template<class _Bfn>
class binder2nd
: public unary_function<_Bfn::first_argument_type,
_Bfn::result_type>
{
public:
    binder2nd(const _Bfn& _X,
              const _Bfn::second_argument_type& _Y)
    : op(_X), value(_Y)
    {

    }
    result_type operator()(const argument_type& _X) const
    {
        return (op(_X, value));
    }
protected:
    _Bfn op;
    _Bfn::second_argument_type value;
};

// TEMPLATE FUNCTION bind2nd
template<class _Bfn, class _Ty> inline
binder2nd<_Bfn> bind2nd(const _Bfn& _X, const _Ty& _Y)
{
    return (binder2nd<_Bfn>(_X,
                            _Bfn::second_argument_type(_Y)));
}

// TEMPLATE CLASS pointer_to_unary_function
template<class _A, class _R>
class pointer_to_unary_function
: public unary_function<_A, _R>
{
public:
    explicit pointer_to_unary_function(_R (__cdecl *_X)(_A))
    : _Fn(_X)
    {

    }
    _R operator()(_A _X) const
    {
        return (_Fn(_X));
    }
protected:
    _R (__cdecl *_Fn)(_A);
};

// TEMPLATE CLASS pointer_to_binary_function
template<class _A1, class _A2, class _R>
class pointer_to_binary_function
: public binary_function<_A1, _A2, _R>
{
public:
    explicit pointer_to_binary_function(
                                       _R (__cdecl *_X)(_A1, _A2))
    : _Fn(_X)
    {

    }
    _R operator()(_A1 _X, _A2 _Y) const
    {
        return (_Fn(_X, _Y));
    }
protected:
    _R (__cdecl *_Fn)(_A1, _A2);
};

// TEMPLATE FUNCTION ptr_fun
template<class _A, class _R> inline
pointer_to_unary_function<_A, _R>
ptr_fun(_R (__cdecl *_X)(_A))
{
    return (pointer_to_unary_function<_A, _R>(_X));
}
template<class _A1, class _A2, class _R> inline
pointer_to_binary_function<_A1, _A2, _R>
ptr_fun(_R (__cdecl *_X)(_A1, _A2))
{
    return (pointer_to_binary_function<_A1, _A2, _R>(_X));
}

// TEMPLATE CLASS mem_fun_t
template<class _R, class _Ty>
class mem_fun_t : public unary_function<_Ty *, _R>
{
public:
    explicit mem_fun_t(_R (_Ty::*_Pm)())
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty *_P)
    {
        return ((_P->*_Ptr)());
    }
private:
    _R (_Ty::*_Ptr)();
};

// TEMPLATE FUNCTION mem_fun
template<class _R, class _Ty> inline
mem_fun_t<_R, _Ty> mem_fun(_R (_Ty::*_Pm)())
{
    return (mem_fun_t<_R, _Ty>(_Pm));
}

// TEMPLATE CLASS mem_fun1_t
template<class _R, class _Ty, class _A>
class mem_fun1_t : public binary_function<_Ty *, _A, _R>
{
public:
    explicit mem_fun1_t(_R (_Ty::*_Pm)(_A))
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty *_P, _A _Arg)
    {
        return ((_P->*_Ptr)(_Arg));
    }
private:
    _R (_Ty::*_Ptr)(_A);
};

// TEMPLATE FUNCTION mem_fun1
template<class _R, class _Ty, class _A> inline
mem_fun1_t<_R, _Ty, _A> mem_fun1(_R (_Ty::*_Pm)(_A))
{
    return (mem_fun1_t<_R, _Ty, _A>(_Pm));
}

// TEMPLATE CLASS mem_fun_ref_t
template<class _R, class _Ty>
class mem_fun_ref_t : public unary_function<_Ty *, _R>
{
public:
    explicit mem_fun_ref_t(_R (_Ty::*_Pm)())
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty& _X)
    {
        return ((_X.*_Ptr)());
    }
private:
    _R (_Ty::*_Ptr)();
};

// TEMPLATE FUNCTION mem_fun_ref
template<class _R, class _Ty> inline
mem_fun_ref_t<_R, _Ty> mem_fun_ref(_R (_Ty::*_Pm)())
{
    return (mem_fun_ref_t<_R, _Ty>(_Pm));
}

// TEMPLATE CLASS mem_fun1_ref_t
template<class _R, class _Ty, class _A>
class mem_fun1_ref_t : public binary_function<_Ty *, _A, _R>
{
public:
    explicit mem_fun1_ref_t(_R (_Ty::*_Pm)(_A))
    : _Ptr(_Pm)
    {

    }
    _R operator()(_Ty& _X, _A _Arg)
    {
        return ((_X.*_Ptr)(_Arg));
    }
private:
    _R (_Ty::*_Ptr)(_A);
};

// TEMPLATE FUNCTION mem_fun1_ref
template<class _R, class _Ty, class _A> inline
mem_fun1_ref_t<_R, _Ty, _A> mem_fun1_ref(_R (_Ty::*_Pm)(_A))
{
    return (mem_fun1_ref_t<_R, _Ty, _A>(_Pm));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLFUNC_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlvec.h ===
#pragma once
#ifndef _STLVEC_H_
#define _STLVEC_H_
//#include <climits>
//#include <memory>
//#include <stdexcept>

#include <limits.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS vector
template<class _Ty, class _A = allocator<_Ty> >
class vector
{
public:
    typedef vector<_Ty, _A>     _Myt;
    typedef _A                  allocator_type;
    typedef _A::size_type       size_type;
    typedef _A::difference_type difference_type;
    typedef _A::pointer         _Tptr;
    typedef _A::const_pointer   _Ctptr;
    typedef _A::reference       reference;
    typedef _A::const_reference const_reference;
    typedef _A::value_type      value_type;
    typedef _Tptr               iterator;
    typedef _Ctptr              const_iterator;
    typedef reverse_iterator<const_iterator, value_type, const_reference,
                                _Ctptr, difference_type>
                const_reverse_iterator;

    typedef reverse_iterator<iterator, value_type,reference, _Tptr,
                                difference_type>
                reverse_iterator;

    explicit vector(const _A& _Al = _A())
    : allocator(_Al), _First(0), _Last(0), _End(0)
    {

    }
    explicit vector(size_type _N, const _Ty& _V = _Ty(),
                    const _A& _Al = _A())
    : allocator(_Al)
    {
        _First = allocator.allocate(_N, (void *)0);
        _Ufill(_First, _N, _V);
        _Last = _First + _N;
        _End = _Last;
    }
    vector(const _Myt& _X)
    : allocator(_X.allocator)
    {
        _First = allocator.allocate(_X.size(), (void *)0);
        _Last = _Ucopy(_X.begin(), _X.end(), _First);
        _End = _Last;
    }
    typedef const_iterator _It;
    vector(_It _F, _It _L, const _A& _Al = _A())
    : allocator(_Al), _First(0), _Last(0), _End(0)
    {
        insert(begin(), _F, _L);
    }
    ~vector()
    {
        _Destroy(_First, _Last);
        allocator.deallocate(_First, _End - _First);
        _First = 0, _Last = 0, _End = 0;
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this == &_X)
            ;
        else if (_X.size() <= size())
        {
            iterator _S = copy(_X.begin(), _X.end(), _First);
            _Destroy(_S, _Last);
            _Last = _First + _X.size();
        }
        else if (_X.size() <= capacity())
        {
            const_iterator _S = _X.begin() + size();
            copy(_X.begin(), _S, _First);
            _Ucopy(_S, _X.end(), _Last);
            _Last = _First + _X.size();
        }
        else
        {
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _First = allocator.allocate(_X.size(), (void *)0);
            _Last = _Ucopy(_X.begin(), _X.end(),
                           _First);
            _End = _Last;
        }
        return (*this);
    }
    void reserve(size_type _N)
    {
        if (capacity() < _N)
        {
            iterator _S = allocator.allocate(_N, (void *)0);
            _Ucopy(_First, _Last, _S);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size();
            _First = _S;
        }
    }
    size_type capacity() const
    {
        return (_First == 0 ? 0 : _End - _First);
    }
    iterator begin()
    {
        return (_First);
    }
    const_iterator begin() const
    {
        return ((const_iterator)_First);
    }
    iterator end()
    {
        return (_Last);
    }
    const_iterator end() const
    {
        return ((const_iterator)_Last);
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, const _Ty& _X = _Ty())
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else if (_N < size())
            erase(begin() + _N, end());
    }
    size_type size() const
    {
        return (_First == 0 ? 0 : _Last - _First);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    const_reference at(size_type _P) const
    {
        ASSERT (_P < size());
        return (*(begin() + _P));
    }
    reference at(size_type _P)
    {
        ASSERT (_P < size());
        return (*(begin() + _P));
    }
    const_reference operator[](size_type _P) const
    {
        return (*(begin() + _P));
    }
    reference operator[](size_type _P)
    {
        return (*(begin() + _P));
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(end() - 1));
    }
    const_reference back() const
    {
        return (*(end() - 1));
    }
    void push_back(const _Ty& _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(end() - 1);
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const _Ty& _X = _Ty())
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const _Ty& _X = _Ty())
    {
        size_type _O = _P - begin();
        insert(_P, 1, _X);
        return (begin() + _O);
    }
    void insert(iterator _P, size_type _M, const _Ty& _X)
    {
        if ((size_type)(_End - _Last) < _M)
        {
            size_type _N = size() + (_M < size() ? size() : _M);
            iterator _S = allocator.allocate(_N, (void *)0);
            iterator _Q = _Ucopy(_First, _P, _S);
            _Ufill(_Q, _M, _X);
            _Ucopy(_P, _Last, _Q + _M);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size() + _M;
            _First = _S;
        }
        else if ((size_type)(_Last - _P) < _M)
        {
            _Ucopy(_P, _Last, _P + _M);
            _Ufill(_Last, _M - (_Last - _P), _X);
            fill(_P, _Last, _X);
            _Last += _M;
        }
        else if (0 < _M)
        {
            _Ucopy(_Last - _M, _Last, _Last);
            copy_backward(_P, _Last - _M, _Last);
            fill(_P, _P + _M, _X);
            _Last += _M;
        }
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        difference_type _M = 0;
        _Distance(_F, _L, _M);
        if (_End - _Last < _M)
        {
            size_type _N = size() + (_M < (difference_type)size() ? size() : _M);
            iterator _S = allocator.allocate(_N, (void *)0);
            iterator _Q = _Ucopy(_First, _P, _S);
            _Q = _Ucopy(_F, _L, _Q);
            _Ucopy(_P, _Last, _Q);
            _Destroy(_First, _Last);
            allocator.deallocate(_First, _End - _First);
            _End = _S + _N;
            _Last = _S + size() + _M;
            _First = _S;
        }
        else if (_Last - _P < _M)
        {
            _Ucopy(_P, _Last, _P + _M);
            _Ucopy(_F + (_Last - _P), _L, _Last);
            copy(_F, _F + (_Last - _P), _P);
            _Last += _M;
        }
        else if (0 < _M)
        {
            _Ucopy(_Last - _M, _Last, _Last);
            copy_backward(_P, _Last - _M, _Last);
            copy(_F, _L, _P);
            _Last += _M;
        }
    }
    iterator erase(iterator _P)
    {
        copy(_P + 1, end(), _P);
        _Destroy(_Last - 1, _Last);
        --_Last;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        iterator _S = copy(_L, end(), _F);
        _Destroy(_S, end());
        _Last = _S;
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
/*
    bool operator==(const _Myt& _X) const
    {
        return (size() == _X.size()
                && equal(begin(), end(), _X.begin()));
    }
    bool operator!=(const _Myt& _X) const
    {
        return (!(*this == _X));
    }
    bool operator<(const _Myt& _X) const
    {
        return (lexicographical_compare(begin(), end(),
                                        _X.begin(), _X.end()));
    }
    bool operator>(const _Myt& _X) const
    {
        return (_X < *this);
    }
    bool operator<=(const _Myt& _X) const
    {
        return (!(_X < *this));
    }
    bool operator>=(const _Myt& _X) const
    {
        return (!(*this < _X));
    }
*/
    void swap(_Myt& _X)
    {
        if (allocator == _X.allocator)
        {
            std::swap(_First, _X._First);
            std::swap(_Last, _X._Last);
            std::swap(_End, _X._End);
        }
        else
        {
            _Myt _Ts = *this; *this = _X, _X = _Ts;
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
protected:
    void _Destroy(iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            allocator.destroy(_F);
    }
    iterator _Ucopy(const_iterator _F, const_iterator _L,
                    iterator _P)
    {
        for (; _F != _L; ++_P, ++_F)
            allocator.construct(_P, *_F);
        return (_P);
    }
    void _Ufill(iterator _F, size_type _N, const _Ty &_X)
    {
        for (; 0 < _N; --_N, ++_F)
            allocator.construct(_F, _X);
    }
    _A allocator;
    iterator _First, _Last, _End;
};

/*
// CLASS vector<_Bool, allocator>
typedef unsigned int _Vbase;
const int _VBITS = CHAR_BIT * sizeof (_Vbase);
typedef allocator<_Vbase> _Bool_allocator;
class vector<_Bool, _Bool_allocator>
{
public:
    typedef _Bool_allocator _A;
    typedef _Bool _Ty;
    typedef vector<_Ty, _A> _Myt;
    typedef vector<_Vbase, _A> _Vbtype;
    typedef _A allocator_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    // CLASS reference
    class reference
    {
    public:
        reference()
        : _Mask(0), _Ptr(0)
        {

        }
        reference(size_t _O, _Vbase *_P)
        : _Mask((_Vbase)1 << _O), _Ptr(_P)
        {

        }
        reference& operator=(const reference& _X)
        {
            return (*this = bool(_X));
        }
        reference& operator=(bool _V)
        {
            if (_V)
                *_Ptr |= _Mask;
            else
                *_Ptr &= ~_Mask;
            return (*this);
        }
        void flip()
        {
            *_Ptr ^= _Mask;
        }
        bool operator~() const
        {
            return (!bool(*this));
        }
        operator bool() const
        {
            return ((*_Ptr & _Mask) != 0);
        }
    protected:
        _Vbase _Mask, *_Ptr;
    };
    typedef const reference const_reference;
    typedef bool value_type;
    // CLASS iterator
    class iterator : public _Ranit<_Bool, difference_type>
    {
    public:
        iterator()
        : _Off(0), _Ptr(0)
        {

        }
        iterator(size_t _O, _Vbase *_P)
        : _Off(_O), _Ptr(_P)
        {

        }
        reference operator*() const
        {
            return (reference(_Off, _Ptr));
        }
        iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            _Inc();
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            _Dec();
            return (_Tmp);
        }
        iterator& operator+=(difference_type _N)
        {
            _Off += (size_t)_N;
            _Ptr += _Off / _VBITS;
            _Off %= _VBITS;
            return (*this);
        }
        iterator& operator-=(difference_type _N)
        {
            return (*this += -_N);
        }
        iterator operator+(difference_type _N) const
        {
            iterator _Tmp = *this;
            return (_Tmp += _N);
        }
        iterator operator-(difference_type _N) const
        {
            iterator _Tmp = *this;
            return (_Tmp -= _N);
        }
        difference_type operator-(const iterator _X) const
        {
            return (_VBITS * (_Ptr - _X._Ptr)
                    + (difference_type)_Off
                    - (difference_type)_X._Off);
        }
        reference operator[](difference_type _N) const
        {
            return (*(*this + _N));
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr && _Off == _X._Off);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        bool operator<(const iterator& _X) const
        {
            return (_Ptr < _X._Ptr
                    || _Ptr == _X._Ptr && _Off < _X._Off);
        }
        bool operator>(const iterator& _X) const
        {
            return (_X < *this);
        }
        bool operator<=(const iterator& _X) const
        {
            return (!(_X < *this));
        }
        bool operator>=(const iterator& _X) const
        {
            return (!(*this < _X));
        }
    protected:
        void _Dec()
        {
            if (_Off != 0)
                --_Off;
            else
                _Off = _VBITS - 1, --_Ptr;
        }
        void _Inc()
        {
            if (_Off < _VBITS - 1)
                ++_Off;
            else
                _Off = 0, ++_Ptr;
        }
        size_t _Off;
        _Vbase *_Ptr;
    };
    // CLASS const_iterator
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        : iterator()
        {

        }
        const_iterator(size_t _O, const _Vbase *_P)
        : iterator(_O, (_Vbase *)_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (reference(_Off, _Ptr));
        }
        const_iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        const_iterator operator++(int)
        {
            const_iterator _Tmp = *this;
            _Inc();
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        const_iterator operator--(int)
        {
            const_iterator _Tmp = *this;
            _Dec();
            return (_Tmp);
        }
        const_iterator& operator+=(difference_type _N)
        {
            _Off += (size_t)_N;
            _Ptr += _Off / _VBITS;
            _Off %= _VBITS;
            return (*this);
        }
        const_iterator& operator-=(difference_type _N)
        {
            return (*this += -_N);
        }
        const_iterator operator+(difference_type _N) const
        {
            const_iterator _Tmp = *this;
            return (_Tmp += _N);
        }
        const_iterator operator-(difference_type _N) const
        {
            const_iterator _Tmp = *this;
            return (_Tmp -= _N);
        }
        difference_type operator-(const const_iterator _X) const
        {
            return (_VBITS * (_Ptr - _X._Ptr)
                    + (difference_type)_Off
                    - (difference_type)_X._Off);
        }
        const_reference operator[](difference_type _N) const
        {
            return (*(*this + _N));
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr && _Off == _X._Off);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
        bool operator<(const const_iterator& _X) const
        {
            return (_Ptr < _X._Ptr
                    || _Ptr == _X._Ptr && _Off < _X._Off);
        }
        bool operator>(const const_iterator& _X) const
        {
            return (_X < *this);
        }
        bool operator<=(const const_iterator& _X) const
        {
            return (!(_X < *this));
        }
        bool operator>=(const const_iterator& _X) const
        {
            return (!(*this < _X));
        }
    };
    typedef reverse_iterator<const_iterator, value_type,
    const_reference, const_reference *, difference_type>
    const_reverse_iterator;
    typedef reverse_iterator<iterator, value_type,
    reference, reference *, difference_type>
    reverse_iterator;
    explicit vector(const _A& _Al = _A())
    : _Size(0), _Vec(_Al)
    {

    }
    explicit vector(size_type _N, const bool _V = false,
                    const _A& _Al = _A())
    : _Vec(_Nw(_N), _V ? -1 : 0, _Al)
    {
        _Trim(_N);
    }
    typedef const_iterator _It;
    vector(_It _F, _It _L, const _A& _Al = _A())
    : _Size(0), _Vec(_Al)
    {
        insert(begin(), _F, _L);
    }
    ~vector()
    {
        _Size = 0;
    }
    void reserve(size_type _N)
    {
        _Vec.reserve(_Nw(_N));
    }
    size_type capacity() const
    {
        return (_Vec.capacity() * _VBITS);
    }
    iterator begin()
    {
        return (iterator(0, _Vec.begin()));
    }
    const_iterator begin() const
    {
        return (const_iterator(0, _Vec.begin()));
    }
    iterator end()
    {
        iterator _Tmp = begin();
        if (0 < _Size)
            _Tmp += _Size;
        return (_Tmp);
    }
    const_iterator end() const
    {
        const_iterator _Tmp = begin();
        if (0 < _Size)
            _Tmp += _Size;
        return (_Tmp);
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    void resize(size_type _N, bool _X = false)
    {
        if (size() < _N)
            insert(end(), _N - size(), _X);
        else if (_N < size())
            erase(begin() + _N, end());
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (_Vec.max_size() * _VBITS);
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (_Vec.get_allocator());
    }
    const_reference at(size_type _P) const
    {
        if (size() <= _P)
            _Xran();
        return (*(begin() + _P));
    }
    reference at(size_type _P)
    {
        if (size() <= _P)
            _Xran();
        return (*(begin() + _P));
    }
    const_reference operator[](size_type _P) const
    {
        return (*(begin() + _P));
    }
    reference operator[](size_type _P)
    {
        return (*(begin() + _P));
    }
    reference front()
    {
        return (*begin());
    }
    const_reference front() const
    {
        return (*begin());
    }
    reference back()
    {
        return (*(end() - 1));
    }
    const_reference back() const
    {
        return (*(end() - 1));
    }
    void push_back(const bool _X)
    {
        insert(end(), _X);
    }
    void pop_back()
    {
        erase(end() - 1);
    }
    void assign(_It _F, _It _L)
    {
        erase(begin(), end());
        insert(begin(), _F, _L);
    }
    void assign(size_type _N, const bool _X = false)
    {
        erase(begin(), end());
        insert(begin(), _N, _X);
    }
    iterator insert(iterator _P, const bool _X = false)
    {
        size_type _O = _P - begin();
        insert(_P, 1, _X);
        return (begin() + _O);
    }
    void insert(iterator _P, size_type _M, const bool _X)
    {
        if (0 < _M)
        {
            if (capacity() - size() < _M)
            {
                size_type _O = _P - begin();
                _Vec.resize(_Nw(size() + _M), 0);
                _P = begin() + _O;
            }
            copy_backward(_P, end(), end() + _M);
            fill(_P, _P + _M, _X);
            _Size += _M;
        }
    }
    void insert(iterator _P, _It _F, _It _L)
    {
        size_type _M = 0;
        _Distance(_F, _L, _M);
        if (0 < _M)
        {
            if (capacity() - size() < _M)
            {
                size_type _O = _P - begin();
                _Vec.resize(_Nw(size() + _M), 0);
                _P = begin() + _O;
            }
            copy_backward(_P, end(), end() + _M);
            copy(_F, _L, _P);
            _Size += _M;
        }
    }
    iterator erase(iterator _P)
    {
        copy(_P + 1, end(), _P);
        _Trim(_Size - 1);
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        iterator _S = copy(_L, end(), _F);
        _Trim(_S - begin());
        return (_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    void flip()
    {
        for (_Vbtype::iterator _S = _Vec.begin();
            _S != _Vec.end(); ++_S)
            *_S = ~*_S;
        _Trim(_Size);
    }
    bool operator==(const _Myt& _X) const
    {
        return (_Size == _X._Size && _Vec == _X._Vec);
    }
    bool operator!=(const _Myt& _X) const
    {
        return (!(*this == _X));
    }
    bool operator<(const _Myt& _X) const
    {
        return (_Size < _X._Size
                || _Size == _X._Size && _Vec < _X._Vec);
    }
    bool operator>(const _Myt& _X) const
    {
        return (_X < *this);
    }
    bool operator<=(const _Myt& _X) const
    {
        return (!(_X < *this));
    }
    bool operator>=(const _Myt& _X) const
    {
        return (!(*this < _X));
    }
    void swap(_Myt& _X)
    {
        std::swap(_Size, _X._Size);
        _Vec.swap(_X._Vec);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    static void swap(reference _X, reference _Y)
    {
        bool _V = _X;
        _X = _Y;
        _Y = _V;
    }
protected:
    static size_type _Nw(size_type _N)
    {
        return ((_N + _VBITS - 1) / _VBITS);
    }
    void _Trim(size_type _N)
    {
        size_type _M = _Nw(_N);
        if (_M < _Vec.size())
            _Vec.erase(_Vec.begin() + _M, _Vec.end());
        _Size = _N;
        _N %= _VBITS;
        if (0 < _N)
            _Vec[_M - 1] &= ((_Vbase)1 << _N) - 1;
    }
    void _Xran() const
    {
        _THROW(out_of_range, "invalid vector<bool> subscript");
    }
    size_type _Size;
    _Vbtype _Vec;
};
typedef vector<_Bool, _Bool_allocator> _Bvector;
*/

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLVEC_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlset.h ===
#pragma once
#ifndef _STLSET_H_
#define _STLSET_H_
//#include <functional>
//#include <xtree>

#include <stlfunc.h>
#include <stlxtree.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN
// TEMPLATE CLASS set
template<class _K, class _Pr = less<_K>, class _A = allocator<_K> >
class set
{
public:
    typedef set<_K, _Pr, _A> _Myt;
    typedef _K value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X);
        }
    };
    typedef _Pr value_compare;
    typedef _K key_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::const_reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::const_iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::const_reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<iterator, bool> _Pairib;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit set(const _Pr& _Pred = _Pr(), const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {

    }
    typedef const value_type *_It;
    set(_It _F, _It _L, const _Pr& _Pred = _Pr(),
        const _A& _Al = _A())
    : _Tr(_Pred, false, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    _Pairib insert(const value_type& _X)
    {
        _Imp::_Pairib _Ans = _Tr.insert(_X);
        return (_Pairib(_Ans.first, _Ans.second));
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv)
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (_Tr.key_comp());
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};

// set TEMPLATE OPERATORS
template<class _K, class _Pr, class _A> inline
bool operator==(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Pr, class _A> inline
bool operator!=(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Pr, class _A> inline
bool operator<(const set<_K, _Pr, _A>& _X,
               const set<_K, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Pr, class _A> inline
bool operator>(const set<_K, _Pr, _A>& _X,
               const set<_K, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Pr, class _A> inline
bool operator<=(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Pr, class _A> inline
bool operator>=(const set<_K, _Pr, _A>& _X,
                const set<_K, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

// TEMPLATE CLASS multiset
template<class _K, class _Pr = less<_K>, class _A = allocator<_K> >
class multiset
{
public:
    typedef multiset<_K, _Pr, _A> _Myt;
    typedef _K value_type;
    struct _Kfn : public unary_function<value_type, _K>
    {
        const _K& operator()(const value_type& _X) const
        {
            return (_X);
        }
    };
    typedef _Pr value_compare;
    typedef _K key_type;
    typedef _Pr key_compare;
    typedef _A allocator_type;
    typedef _Tree<_K, value_type, _Kfn, _Pr, _A> _Imp;
    typedef _Imp::size_type size_type;
    typedef _Imp::difference_type difference_type;
    typedef _Imp::const_reference reference;
    typedef _Imp::const_reference const_reference;
    typedef _Imp::const_iterator iterator;
    typedef _Imp::const_iterator const_iterator;
    typedef _Imp::const_reverse_iterator reverse_iterator;
    typedef _Imp::const_reverse_iterator const_reverse_iterator;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit multiset(const _Pr& _Pred = _Pr(),
                      const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {

    }
    typedef const value_type *_It;
    multiset(_It _F, _It _L, const _Pr& _Pred = _Pr(),
             const _A& _Al = _A())
    : _Tr(_Pred, true, _Al)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    const_iterator begin() const
    {
        return (_Tr.begin());
    }
    const_iterator end() const
    {
        return (_Tr.end());
    }
    const_reverse_iterator rbegin() const
    {
        return (_Tr.rbegin());
    }
    const_reverse_iterator rend() const
    {
        return (_Tr.rend());
    }
    size_type size() const
    {
        return (_Tr.size());
    }
    size_type max_size() const
    {
        return (_Tr.max_size());
    }
    bool empty() const
    {
        return (_Tr.empty());
    }
    _A get_allocator() const
    {
        return (_Tr.get_allocator());
    }
    iterator insert(const value_type& _X)
    {
        return (_Tr.insert(_X).first);
    }
    iterator insert(iterator _P, const value_type& _X)
    {
        return (_Tr.insert((_Imp::iterator&)_P, _X));
    }
    void insert(_It _F, _It _L)
    {
        for (; _F != _L; ++_F)
            _Tr.insert(*_F);
    }
    iterator erase(iterator _P)
    {
        return (_Tr.erase((_Imp::iterator&)_P));
    }
    iterator erase(iterator _F, iterator _L)
    {
        return (_Tr.erase((_Imp::iterator&)_F,
                          (_Imp::iterator&)_L));
    }
    size_type erase(const _K& _Kv)
    {
        return (_Tr.erase(_Kv));
    }
    void clear()
    {
        _Tr.clear();
    }
    void swap(_Myt& _X)
    {
        std::swap(_Tr, _X._Tr);
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
    key_compare key_comp() const
    {
        return (_Tr.key_comp());
    }
    value_compare value_comp() const
    {
        return (_Tr.key_comp());
    }
    const_iterator find(const _K& _Kv) const
    {
        return (_Tr.find(_Kv));
    }
    size_type count(const _K& _Kv) const
    {
        return (_Tr.count(_Kv));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (_Tr.lower_bound(_Kv));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (_Tr.upper_bound(_Kv));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Tr.equal_range(_Kv));
    }
protected:
    _Imp _Tr;
};

// multiset TEMPLATE OPERATORS
template<class _K, class _Pr, class _A> inline
bool operator==(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Pr, class _A> inline
bool operator!=(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Pr, class _A> inline
bool operator<(const multiset<_K, _Pr, _A>& _X,
               const multiset<_K, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Pr, class _A> inline
bool operator>(const multiset<_K, _Pr, _A>& _X,
               const multiset<_K, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Pr, class _A> inline
bool operator<=(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Pr, class _A> inline
bool operator>=(const multiset<_K, _Pr, _A>& _X,
                const multiset<_K, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLSET_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlutil.h ===
#pragma once
#ifndef _STLUTIL_H_
#define _STLUTIL_H_

#include <stlxstdd.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE STRUCT pair
template<class _T1, class _T2> struct pair
{
    typedef _T1 first_type;
    typedef _T2 second_type;
    pair()
    : first(_T1()), second(_T2())
    {

    }
    pair(const _T1& _V1, const _T2& _V2)
    : first(_V1), second(_V2)
    {

    }
    _T1 first;
    _T2 second;
};
template<class _T1, class _T2> inline
bool __cdecl operator==(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (_X.first == _Y.first && _X.second == _Y.second);
}
template<class _T1, class _T2> inline
bool __cdecl operator!=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_X == _Y));
}
template<class _T1, class _T2> inline
bool __cdecl operator<(const pair<_T1, _T2>& _X,
                       const pair<_T1, _T2>& _Y)
{
    return (_X.first < _Y.first ||
            !(_Y.first < _X.first) && _X.second < _Y.second);
}
template<class _T1, class _T2> inline
bool __cdecl operator>(const pair<_T1, _T2>& _X,
                       const pair<_T1, _T2>& _Y)
{
    return (_Y < _X);
}
template<class _T1, class _T2> inline
bool __cdecl operator<=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_Y < _X));
}
template<class _T1, class _T2> inline
bool __cdecl operator>=(const pair<_T1, _T2>& _X,
                        const pair<_T1, _T2>& _Y)
{
    return (!(_X < _Y));
}
template<class _T1, class _T2> inline
pair<_T1, _T2> __cdecl make_pair(const _T1& _X, const _T2& _Y)
{
    return (pair<_T1, _T2>(_X, _Y));
}


// ITERATOR TAGS (from <iterator>)
struct input_iterator_tag
{
};
struct output_iterator_tag
{
};
struct forward_iterator_tag
: public input_iterator_tag
{
};
struct bidirectional_iterator_tag
: public forward_iterator_tag
{
};
struct random_access_iterator_tag
: public bidirectional_iterator_tag
{
};


// TEMPLATE CLASS iterator (from <iterator>)
template<class _C, class _Ty, class _D = ptrdiff_t>
struct iterator
{
   typedef _C iterator_category;
   typedef _Ty value_type;
   typedef _D distance_type;
};

template<class _Ty, class _D>
struct _Bidit : public iterator<bidirectional_iterator_tag, _Ty, _D>
{
};

template<class _Ty, class _D>
struct _Ranit : public iterator<random_access_iterator_tag, _Ty, _D>
{
};

// TEMPLATE CLASS iterator_traits (from <iterator>)
template<class _It>
struct iterator_traits
{
   typedef _It::iterator_category iterator_category;
   typedef _It::value_type value_type;
   typedef _It::distance_type distance_type;
};

// TEMPLATE FUNCTION _Iter_cat (from <iterator>)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4700)

template<class _C, class _Ty, class _D>
inline
_C __cdecl _Iter_cat(const iterator<_C, _Ty, _D>&)
{
    _C _X;
    return (_X);
}

template<class _Ty>
inline
random_access_iterator_tag __cdecl _Iter_cat(const _Ty *)
{
    random_access_iterator_tag _X;
    return (_X);
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4700)
#endif

// TEMPLATE FUNCTION _Distance
template<class _II>
inline
_CNTSIZ(_II) __cdecl distance(_II _F, _II _L)
{
    _CNTSIZ(_II) _N = 0;
    _Distance(_F, _L, _N, _Iter_cat(_F));
    return (_N);
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N)
{
    _Distance(_F, _L, _N, _Iter_cat(_F));
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N, input_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N, forward_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _II, class _D>
inline
void __cdecl _Distance(_II _F, _II _L, _D& _N,
                       bidirectional_iterator_tag)
{
    for (; _F != _L; ++_F)
        ++_N;
}

template<class _RI, class _D>
inline
void __cdecl _Distance(_RI _F, _RI _L, _D& _N,
                       random_access_iterator_tag)
{
    _N += (_D)(_L - _F);
}

// TEMPLATE CLASS reverse_iterator (from <iterator>)
template<class _RI, class _Ty, class _Rt = _Ty&, class _Pt = _Ty *,
            class _D = ptrdiff_t>
class reverse_iterator : public _Ranit<_Ty, _D>
{
public:
   typedef reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> _Myt;
   typedef _RI iter_type;
   typedef _Rt reference_type;
   typedef _Pt pointer_type;
   reverse_iterator()
   {
   }
   explicit reverse_iterator(_RI _X)
   : current(_X)
   {
   }
   _RI base() const
   {
       return (current);
   }
   _Rt operator*() const
   {
       return (*(current - 1));
   }
   _Pt operator->() const
   {
       return (&**this);
   }
   _Myt& operator++()
   {
       --current;
       return (*this);
   }
   _Myt operator++(int)
   {
       _Myt _Tmp = *this;
       --current;
       return (_Tmp);
   }
   _Myt& operator--()
   {
       ++current;
       return (*this);
   }
   _Myt operator--(int)
   {
       _Myt _Tmp = *this;
       ++current;
       return (_Tmp);
   }
   _Myt& operator+=(_D _N)
   {
       current -= _N;
       return (*this);
   }
   _Myt operator+(_D _N) const
   {
       return (_Myt(current - _N));
   }
   _Myt& operator-=(_D _N)
   {
       current += _N;
       return (*this);
   }
   _Myt operator-(_D _N) const
   {
       return (_Myt(current + _N));
   }
   _Rt operator[](_D _N) const
   {
       return (*(*this + _N));
   }
protected:
   _RI current;
};

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator==(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_X.base() == _Y.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator!=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X == _Y));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator<(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y.base() < _X.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator>(
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                      const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y < _X);
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator<=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_Y < _X));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
bool __cdecl operator>=(
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                       const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (!(_X < _Y));
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
_D __cdecl operator-(
                    const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _X,
                    const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (_Y.base() - _X.base());
}

template<class _RI, class _Ty, class _Rt, class _Pt, class _D>
inline
reverse_iterator<_RI, _Ty, _Rt, _Pt, _D> __cdecl operator+(_D _N,
               const reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>& _Y)
{
    return (reverse_iterator<_RI, _Ty, _Rt, _Pt, _D>(
                                                    _Y.base() - _N));
}

/*
// TEMPLATE CLASS istreambuf_iterator (from <iterator>)
template<class _E, class _Tr = char_traits<_E> >
class istreambuf_iterator :
    public iterator<input_iterator_tag, _E, _Tr::off_type>
{
public:
    typedef istreambuf_iterator<_E, _Tr> _Myt;
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef _Tr::int_type int_type;
    typedef basic_streambuf<_E, _Tr> streambuf_type;
    typedef basic_istream<_E, _Tr> istream_type;
    istreambuf_iterator(streambuf_type *_Sb = 0) _THROW0()
    : _Sbuf(_Sb), _Got(_Sb == 0)
    {

    }
    istreambuf_iterator(istream_type& _I) _THROW0()
    : _Sbuf(_I.rdbuf()), _Got(_I.rdbuf() == 0)
    {

    }
    const _E& operator*() const
    {
        if (!_Got)
            ((_Myt *)this)->_Peek();
        return (_Val);
    }
    const _E *operator->() const
    {
        return (&**this);
    }
    _Myt& operator++()
    {
        _Inc();
        return (*this);
    }
    _Myt operator++(int)
    {
        if (!_Got)
            _Peek();
        _Myt _Tmp = *this;
        _Inc();
        return (_Tmp);
    }
    bool equal(const _Myt& _X) const
    {
        if (!_Got)
            ((_Myt *)this)->_Peek();
        if (!_X._Got)
            ((_Myt *)&_X)->_Peek();
        return (_Sbuf == 0 && _X._Sbuf == 0
                || _Sbuf != 0 && _X._Sbuf != 0);
    }
private:
    void _Inc()
    {
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _Sbuf->sbumpc()))
            _Sbuf = 0, _Got = true;
        else
            _Got = false;
    }
    _E _Peek()
    {
        int_type _C;
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _C = _Sbuf->sgetc()))
            _Sbuf = 0;
        else
            _Val = _Tr::to_char_type(_C);
        _Got = true;
        return (_Val);
    }
    streambuf_type *_Sbuf;
    bool _Got;
    _E _Val;
};
template<class _E, class _Tr> inline
bool __cdecl operator==(const istreambuf_iterator<_E, _Tr>& _X,
                        const istreambuf_iterator<_E, _Tr>& _Y)
{
    return (_X.equal(_Y));
}
template<class _E, class _Tr> inline
bool __cdecl operator!=(const istreambuf_iterator<_E, _Tr>& _X,
                        const istreambuf_iterator<_E, _Tr>& _Y)
{
    return (!(_X == _Y));
}

// TEMPLATE CLASS ostreambuf_iterator (from <iterator>)
template<class _E, class _Tr = char_traits<_E> >
class ostreambuf_iterator :
    public iterator<output_iterator_tag, void, void>
{
    typedef ostreambuf_iterator<_E, _Tr> _Myt;
public:
    typedef _E char_type;
    typedef _Tr traits_type;
    typedef basic_streambuf<_E, _Tr> streambuf_type;
    typedef basic_ostream<_E, _Tr> ostream_type;
    ostreambuf_iterator(streambuf_type *_Sb) _THROW0()
    : _Failed(false), _Sbuf(_Sb)
    {

    }
    ostreambuf_iterator(ostream_type& _O) _THROW0()
    : _Failed(false), _Sbuf(_O.rdbuf())
    {

    }
    _Myt& operator=(_E _X)
    {
        if (_Sbuf == 0
            || _Tr::eq_int_type(_Tr::eof(), _Sbuf->sputc(_X)))
            _Failed = true;
        return (*this);
    }
    _Myt& operator*()
    {
        return (*this);
    }
    _Myt& operator++()
    {
        return (*this);
    }
    _Myt& operator++(int)
    {
        return (*this);
    }
    bool failed() const _THROW0()
    {
        return (_Failed);
    }
private:
    bool _Failed;
    streambuf_type *_Sbuf;
};
*/

// TEMPLATE OPERATORS
namespace rel_ops
{
    template<class _Ty> inline
    bool __cdecl operator!=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_X == _Y));
    }
    template<class _Ty> inline
    bool __cdecl operator>(const _Ty& _X, const _Ty& _Y)
    {
        return (_Y < _X);
    }
    template<class _Ty> inline
    bool __cdecl operator<=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_Y < _X));
    }
    template<class _Ty> inline
    bool __cdecl operator>=(const _Ty& _X, const _Ty& _Y)
    {
        return (!(_X < _Y));
    }
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLUTIL_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\upscmn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P S C M N . H 
//
//  Contents:   Common fns for UPnP Folder and Tray
//
//  Notes:      
//
//  Author:     jeffspr   7 Dec 1999
//
//----------------------------------------------------------------------------

#ifndef _UPSCMN_H_
#define _UPSCMN_H_

// our registry root
//
extern const TCHAR c_szUPnPRegRoot[];

HRESULT HrSysAllocString(LPCWSTR pszSource, BSTR *pbstrDest);

#endif // _UPSCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlxstdd.h ===
#pragma once
#ifndef _STLXSTDD_H_
#define _STLXSTDD_H_

//#ifndef _YVALS
//#include <yvals.h>
//#endif
//#include <cstddef>

#include <stddef.h>

/*
// Define _CRTIMP
#ifndef _CRTIMP
#ifdef  CRTDLL2
#define _CRTIMP __declspec(dllexport)
#else   // ndef CRTDLL2
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // CRTDLL2
#endif  // _CRTIMP
*/

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */


// begin yyvals.h include

#pragma warning(disable: 4244)

//#pragma warning(4: 4018 4114 4146 4244 4245)
//#pragma warning(4: 4663 4664 4665)
//#pragma warning(disable: 4237 4514)

// 4284:
// return type for 'identifier::operator >' is not a UDT or reference to a
// UDT. Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

// 4290: C++ Exception Specification ignored
// A function was declared using exception specification.
// At this time the implementation details of exception specification have
// not been standardized, and are accepted but not implemented in Microsoft
// Visual C++.
//
#pragma warning(disable: 4290)



// NAMESPACE
#if defined(__cplusplus)
#define _STD            std::
#define _STD_BEGIN      namespace std {
#define _STD_END        };
#define _STD_USING
#else
#define _STD            ::
#define _STD_BEGIN
#define _STD_END
#endif // __cplusplus

_STD_BEGIN

// TYPE bool
#if defined(__cplusplus)
typedef bool _Bool;
#endif // __cplusplus

// INTEGER PROPERTIES
#define _MAX_EXP_DIG    8   // for parsing numerics
#define _MAX_INT_DIG    32
#define _MAX_SIG_DIG    36

// STDIO PROPERTIES
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)    ((long)(fp))
#endif // _FPOS_T_DEFINED

// NAMING PROPERTIES
#if defined(__cplusplus)
#define _C_LIB_DECL extern "C" {
#define _END_C_LIB_DECL }
#else
#define _C_LIB_DECL
#define _END_C_LIB_DECL
#endif // __cplusplus
#define _CDECL

/*
// CLASS _Lockit
#if defined(__cplusplus)
class _CRTIMP _Lockit
{   // lock while object in existence
public:
    #ifdef _MT
        #define _LOCKIT(x)  lockit x
        _Lockit();
        ~_Lockit();
    #else
        #define _LOCKIT(x)
        _Lockit()
        {
        }
        ~_Lockit()
        {
        }
    #endif // _MT
};
#endif // __cplusplus
*/

// MISCELLANEOUS MACROS
#define _L(c)   L##c
#define _Mbstinit(x)    mbstate_t x = {0}
#define _MAX    _cpp_max
#define _MIN    _cpp_min

// end yyvals.h include


// EXCEPTION MACROS
//#define _TRY_BEGIN              try {
//#define _CATCH(x)               } catch (x) {
//#define _CATCH_ALL              } catch (...) {
//#define _CATCH_END              }
#define _RAISE(x)               throw (x)
//#define _RERAISE                throw
#define _THROW0()               throw ()
#define _THROW1(x)              throw (x)
#define _THROW(x, y)            throw x(y)

// explicit KEYWORD
// BITMASK MACROS
#define _BITMASK(E, T)          typedef int T
#define _BITMASK_OPS(T)

// MISCELLANEOUS MACROS
#define _DESTRUCTOR(ty, ptr)    (ptr)->~ty()
#define _PROTECTED              public
#define _TDEF(x)                = x
#define _TDEF2(x, y)            = x, y
#define _CNTSIZ(iter)           ptrdiff_t
#define _TDEFP(x)
#define _STCONS(ty, name, val)  enum {name = val}

// TYPE DEFINITIONS
enum _Uninitialized
{
    _Noinit
};

// FUNCTIONS
/*_CRTIMP*/
void __cdecl _Nomemory();

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXSTDD_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlxtree.h ===
#pragma once
#ifndef _STLTREE_H_
#define _STLTREE_H_
//#include <cstddef>
//#include <iterator>
//#include <memory>
//#include <xutility>

#include <stddef.h>
#include <stliter.h>
#include <stlmem.h>
#include <stlxutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

_STD_BEGIN

// TEMPLATE CLASS _Tree
template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
class _Tree
{
protected:
    typedef _POINTER_X(void, _A) _Genptr;
    enum _Redbl
    {
        _Red, _Black
    };
    struct _Node;
    friend struct _Node;
    struct _Node
    {
        _Genptr _Left, _Parent, _Right;
        _Ty _Value;
        _Redbl _Color;
    };
    typedef _POINTER_X(_Node, _A) _Nodeptr;
    typedef _REFERENCE_X(_Nodeptr, _A) _Nodepref;
    typedef _REFERENCE_X(const _K, _A) _Keyref;
    typedef _REFERENCE_X(_Redbl, _A) _Rbref;
    typedef _REFERENCE_X(_Ty, _A) _Vref;
    static _Rbref _Color(_Nodeptr _P)
    {
        return ((_Rbref)(*_P)._Color);
    }
    static _Keyref _Key(_Nodeptr _P)
    {
        return (_Kfn()(_Value(_P)));
    }
    static _Nodepref _Left(_Nodeptr _P)
    {
        return ((_Nodepref)(*_P)._Left);
    }
    static _Nodepref _Parent(_Nodeptr _P)
    {
        return ((_Nodepref)(*_P)._Parent);
    }
    static _Nodepref _Right(_Nodeptr _P)
    {
        return ((_Nodepref)(*_P)._Right);
    }
    static _Vref _Value(_Nodeptr _P)
    {
        return ((_Vref)(*_P)._Value);
    }
public:
    typedef _Tree<_K, _Ty, _Kfn, _Pr, _A> _Myt;
    typedef _K key_type;
    typedef _Ty value_type;
    typedef _A::size_type size_type;
    typedef _A::difference_type difference_type;
    typedef _POINTER_X(_Ty, _A) _Tptr;
    typedef _POINTER_X(const _Ty, _A) _Ctptr;
    typedef _REFERENCE_X(_Ty, _A) reference;
    typedef _REFERENCE_X(const _Ty, _A) const_reference;
    // CLASS iterator
    class iterator;
    friend class iterator;
    class iterator : public _Bidit<_Ty, difference_type>
    {
    public:
        iterator()
        {
        }
        iterator(_Nodeptr _P) : _Ptr(_P)
        {
        }
        reference operator*() const
        {
            return (_Value(_Ptr));
        }
        _Tptr operator->() const
        {
            return (&**this);
        }
        iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const iterator& _X) const
        {
            return (!(*this == _X));
        }
        void _Dec()
        {
            //_Lockit _Lk;
            if (_Color(_Ptr) == _Red
                && _Parent(_Parent(_Ptr)) == _Ptr)
                _Ptr = _Right(_Ptr);
            else if (_Left(_Ptr) != _Nil)
                _Ptr = _Max(_Left(_Ptr));
            else
            {
                _Nodeptr _P;
                while (_Ptr == _Left(_P = _Parent(_Ptr)))
                    _Ptr = _P;
                _Ptr = _P;
            }
        }
        void _Inc()
        {
            //_Lockit _Lk;
            if (_Right(_Ptr) != _Nil)
                _Ptr = _Min(_Right(_Ptr));
            else
            {
                _Nodeptr _P;
                while (_Ptr == _Right(_P = _Parent(_Ptr)))
                    _Ptr = _P;
                if (_Right(_Ptr) != _P)
                    _Ptr = _P;
            }
        }
        _Nodeptr _Mynode() const
        {
            return (_Ptr);
        }
    protected:
        _Nodeptr _Ptr;
    };
    // CLASS const_iterator
    class const_iterator;
    friend class const_iterator;
    class const_iterator : public iterator
    {
    public:
        const_iterator()
        {

        }
        const_iterator(_Nodeptr _P)
        : iterator(_P)
        {

        }
        const_iterator(const iterator& _X)
        : iterator(_X)
        {

        }
        const_reference operator*() const
        {
            return (_Value(_Ptr));
        }
        _Ctptr operator->() const
        {
            return (&**this);
        }
        const_iterator& operator++()
        {
            _Inc();
            return (*this);
        }
        const_iterator operator++(int)
        {
            iterator _Tmp = *this;
            ++*this;
            return (_Tmp);
        }
        const_iterator& operator--()
        {
            _Dec();
            return (*this);
        }
        const_iterator operator--(int)
        {
            iterator _Tmp = *this;
            --*this;
            return (_Tmp);
        }
        bool operator==(const const_iterator& _X) const
        {
            return (_Ptr == _X._Ptr);
        }
        bool operator!=(const const_iterator& _X) const
        {
            return (!(*this == _X));
        }
    };
    typedef reverse_bidirectional_iterator<iterator,
    value_type, reference, _Tptr, difference_type>
    reverse_iterator;
    typedef reverse_bidirectional_iterator<const_iterator,
    value_type, const_reference, _Ctptr, difference_type>
    const_reverse_iterator;
    typedef pair<iterator, bool> _Pairib;
    typedef pair<iterator, iterator> _Pairii;
    typedef pair<const_iterator, const_iterator> _Paircc;
    explicit _Tree(const _Pr& _Parg, bool _Marg = true,
                   const _A& _Al = _A())
    : allocator(_Al),
    key_compare(_Parg), _Multi(_Marg)
    {
        _Init();
    }
    _Tree(const _Ty *_F, const _Ty *_L,
          const _Pr& _Parg, bool _Marg = true,
          const _A& _Al = _A())
    : allocator(_Al),
    key_compare(_Parg), _Multi(_Marg)
    {
        _Init();
        insert(_F, _L);
    }
    _Tree(const _Myt& _X)
    : allocator(_X.allocator),
    key_compare(_X.key_compare), _Multi(_X._Multi)
    {
        _Init();
        _Copy(_X);
    }
    ~_Tree()
    {
        erase(begin(), end());
        _Freenode(_Head);
        _Head = 0, _Size = 0;
        {
            //_Lockit _Lk;
            if (--_Nilrefs == 0)
            {
                _Freenode(_Nil);
                _Nil = 0;
            }
        }
    }
    _Myt& operator=(const _Myt& _X)
    {
        if (this != &_X)
        {
            erase(begin(), end());
            key_compare = _X.key_compare;
            _Copy(_X);
        }
        return (*this);
    }
    iterator begin()
    {
        return (iterator(_Lmost()));
    }
    const_iterator begin() const
    {
        return (const_iterator(_Lmost()));
    }
    iterator end()
    {
        return (iterator(_Head));
    }
    const_iterator end() const
    {
        return (const_iterator(_Head));
    }
    reverse_iterator rbegin()
    {
        return (reverse_iterator(end()));
    }
    const_reverse_iterator rbegin() const
    {
        return (const_reverse_iterator(end()));
    }
    reverse_iterator rend()
    {
        return (reverse_iterator(begin()));
    }
    const_reverse_iterator rend() const
    {
        return (const_reverse_iterator(begin()));
    }
    size_type size() const
    {
        return (_Size);
    }
    size_type max_size() const
    {
        return (allocator.max_size());
    }
    bool empty() const
    {
        return (size() == 0);
    }
    _A get_allocator() const
    {
        return (allocator);
    }
    _Pr key_comp() const
    {
        return (key_compare);
    }
    _Pairib insert(const value_type& _V)
    {
        _Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        bool _Ans = true;
        {
            //_Lockit Lk;
            while (_X != _Nil)
            {
                _Y = _X;
                _Ans = key_compare(_Kfn()(_V), _Key(_X));
                _X = _Ans ? _Left(_X) : _Right(_X);
            }
        }
        if (_Multi)
            return (_Pairib(_Insert(_X, _Y, _V), true));
        iterator _P = iterator(_Y);
        if (!_Ans)
            ;
        else if (_P == begin())
            return (_Pairib(_Insert(_X, _Y, _V), true));
        else
            --_P;
        if (key_compare(_Key(_P._Mynode()), _Kfn()(_V)))
            return (_Pairib(_Insert(_X, _Y, _V), true));
        return (_Pairib(_P, false));
    }
    iterator insert(iterator _P, const value_type& _V)
    {
        if (size() == 0)
            ;
        else if (_P == begin())
        {
            if (key_compare(_Kfn()(_V), _Key(_P._Mynode())))
                return (_Insert(_Head, _P._Mynode(), _V));
        }
        else if (_P == end())
        {
            //_Lockit Lk;
            if (key_compare(_Key(_Rmost()), _Kfn()(_V)))
                return (_Insert(_Nil, _Rmost(), _V));
        }
        else
        {
            iterator _Pb = _P;
            if (key_compare(_Key((--_Pb)._Mynode()), _Kfn()(_V))
                && key_compare(_Kfn()(_V), _Key(_P._Mynode())))
            {
                //_Lockit _Lk;
                if (_Right(_Pb._Mynode()) == _Nil)
                    return (_Insert(_Nil, _Pb._Mynode(), _V));
                else
                    return (_Insert(_Head, _P._Mynode(), _V));
            }
        }
        return (insert(_V).first);
    }
    void insert(iterator _F, iterator _L)
    {
        for (; _F != _L; ++_F)
            insert(*_F);
    }
    void insert(const value_type *_F, const value_type *_L)
    {
        for (; _F != _L; ++_F)
            insert(*_F);
    }
    iterator erase(iterator _P)
    {
        _Nodeptr _X;
        _Nodeptr _Y = (_P++)._Mynode();
        _Nodeptr _Z = _Y;
        //_Lockit _Lk;
        if (_Left(_Y) == _Nil)
            _X = _Right(_Y);
        else if (_Right(_Y) == _Nil)
            _X = _Left(_Y);
        else
            _Y = _Min(_Right(_Y)), _X = _Right(_Y);
        if (_Y != _Z)
        {
            _Parent(_Left(_Z)) = _Y;
            _Left(_Y) = _Left(_Z);
            if (_Y == _Right(_Z))
                _Parent(_X) = _Y;
            else
            {
                _Parent(_X) = _Parent(_Y);
                _Left(_Parent(_Y)) = _X;
                _Right(_Y) = _Right(_Z);
                _Parent(_Right(_Z)) = _Y;
            }
            if (_Root() == _Z)
                _Root() = _Y;
            else if (_Left(_Parent(_Z)) == _Z)
                _Left(_Parent(_Z)) = _Y;
            else
                _Right(_Parent(_Z)) = _Y;
            _Parent(_Y) = _Parent(_Z);
            std::swap(_Color(_Y), _Color(_Z));
            _Y = _Z;
        }
        else
        {
            _Parent(_X) = _Parent(_Y);
            if (_Root() == _Z)
                _Root() = _X;
            else if (_Left(_Parent(_Z)) == _Z)
                _Left(_Parent(_Z)) = _X;
            else
                _Right(_Parent(_Z)) = _X;
            if (_Lmost() != _Z)
                ;
            else if (_Right(_Z) == _Nil)
                _Lmost() = _Parent(_Z);
            else
                _Lmost() = _Min(_X);
            if (_Rmost() != _Z)
                ;
            else if (_Left(_Z) == _Nil)
                _Rmost() = _Parent(_Z);
            else
                _Rmost() = _Max(_X);
        }
        if (_Color(_Y) == _Black)
        {
            while (_X != _Root() && _Color(_X) == _Black)
                if (_X == _Left(_Parent(_X)))
                {
                    _Nodeptr _W = _Right(_Parent(_X));
                    if (_Color(_W) == _Red)
                    {
                        _Color(_W) = _Black;
                        _Color(_Parent(_X)) = _Red;
                        _Lrotate(_Parent(_X));
                        _W = _Right(_Parent(_X));
                    }
                    if (_Color(_Left(_W)) == _Black
                        && _Color(_Right(_W)) == _Black)
                    {
                        _Color(_W) = _Red;
                        _X = _Parent(_X);
                    }
                    else
                    {
                        if (_Color(_Right(_W)) == _Black)
                        {
                            _Color(_Left(_W)) = _Black;
                            _Color(_W) = _Red;
                            _Rrotate(_W);
                            _W = _Right(_Parent(_X));
                        }
                        _Color(_W) = _Color(_Parent(_X));
                        _Color(_Parent(_X)) = _Black;
                        _Color(_Right(_W)) = _Black;
                        _Lrotate(_Parent(_X));
                        break;
                    }
                }
                else
                {
                    _Nodeptr _W = _Left(_Parent(_X));
                    if (_Color(_W) == _Red)
                    {
                        _Color(_W) = _Black;
                        _Color(_Parent(_X)) = _Red;
                        _Rrotate(_Parent(_X));
                        _W = _Left(_Parent(_X));
                    }
                    if (_Color(_Right(_W)) == _Black
                        && _Color(_Left(_W)) == _Black)
                    {
                        _Color(_W) = _Red;
                        _X = _Parent(_X);
                    }
                    else
                    {
                        if (_Color(_Left(_W)) == _Black)
                        {
                            _Color(_Right(_W)) = _Black;
                            _Color(_W) = _Red;
                            _Lrotate(_W);
                            _W = _Left(_Parent(_X));
                        }
                        _Color(_W) = _Color(_Parent(_X));
                        _Color(_Parent(_X)) = _Black;
                        _Color(_Left(_W)) = _Black;
                        _Rrotate(_Parent(_X));
                        break;
                    }
                }
            _Color(_X) = _Black;
        }
        _Destval(&_Value(_Y));
        _Freenode(_Y);
        --_Size;
        return (_P);
    }
    iterator erase(iterator _F, iterator _L)
    {
        if (size() == 0 || _F != begin() || _L != end())
        {
            while (_F != _L)
                erase(_F++);
            return (_F);
        }
        else
        {
            //_Lockit Lk;
            _Erase(_Root());
            _Root() = _Nil, _Size = 0;
            _Lmost() = _Head, _Rmost() = _Head;
            return (begin());
        }
    }
    size_type erase(const _K& _X)
    {
        _Pairii _P = equal_range(_X);
        size_type _N = 0;
        _Distance(_P.first, _P.second, _N);
        erase(_P.first, _P.second);
        return (_N);
    }
    void erase(const _K *_F, const _K *_L)
    {
        for (; _F != _L; ++_F)
            erase(*_F);
    }
    void clear()
    {
        erase(begin(), end());
    }
    iterator find(const _K& _Kv)
    {
        iterator _P = lower_bound(_Kv);
        return (_P == end()
                || key_compare(_Kv, _Key(_P._Mynode()))
                ? end() : _P);
    }
    const_iterator find(const _K& _Kv) const
    {
        const_iterator _P = lower_bound(_Kv);
        return (_P == end()
                || key_compare(_Kv, _Key(_P._Mynode()))
                ? end() : _P);
    }
    size_type count(const _K& _Kv) const
    {
        _Paircc _Ans = equal_range(_Kv);
        size_type _N = 0;
        _Distance(_Ans.first, _Ans.second, _N);
        return (_N);
    }
    iterator lower_bound(const _K& _Kv)
    {
        return (iterator(_Lbound(_Kv)));
    }
    const_iterator lower_bound(const _K& _Kv) const
    {
        return (const_iterator(_Lbound(_Kv)));
    }
    iterator upper_bound(const _K& _Kv)
    {
        return (iterator(_Ubound(_Kv)));
    }
    const_iterator upper_bound(const _K& _Kv) const
    {
        return (iterator(_Ubound(_Kv)));
    }
    _Pairii equal_range(const _K& _Kv)
    {
        return (_Pairii(lower_bound(_Kv), upper_bound(_Kv)));
    }
    _Paircc equal_range(const _K& _Kv) const
    {
        return (_Paircc(lower_bound(_Kv), upper_bound(_Kv)));
    }
    void swap(_Myt& _X)
    {
        std::swap(key_compare, _X.key_compare);
        if (allocator == _X.allocator)
        {
            std::swap(_Head, _X._Head);
            std::swap(_Multi, _X._Multi);
            std::swap(_Size, _X._Size);
        }
        else
        {
            _Myt _Ts = *this; *this = _X, _X = _Ts;
        }
    }
    friend void swap(_Myt& _X, _Myt& _Y)
    {
        _X.swap(_Y);
    }
protected:
    static _Nodeptr _Nil;
    static size_t _Nilrefs;
    void _Copy(const _Myt& _X)
    {
        //_Lockit _Lk;
        _Root() = _Copy(_X._Root(), _Head);
        _Size = _X.size();
        if (_Root() != _Nil)
        {
            _Lmost() = _Min(_Root());
            _Rmost() = _Max(_Root());
        }
        else
            _Lmost() = _Head, _Rmost() = _Head;
    }
    _Nodeptr _Copy(_Nodeptr _X, _Nodeptr _P)
    {
        //_Lockit _Lk;
        _Nodeptr _R = _X;
        for (; _X != _Nil; _X = _Left(_X))
        {
            _Nodeptr _Y = _Buynode(_P, _Color(_X));
            if (_R == _X)
                _R = _Y;
            _Right(_Y) = _Copy(_Right(_X), _Y);
            _Consval(&_Value(_Y), _Value(_X));
            _Left(_P) = _Y;
            _P = _Y;
        }
        _Left(_P) = _Nil;
        return (_R);
    }
    void _Erase(_Nodeptr _X)
    {
        //_Lockit _Lk;
        for (_Nodeptr _Y = _X; _Y != _Nil; _X = _Y)
        {
            _Erase(_Right(_Y));
            _Y = _Left(_Y);
            _Destval(&_Value(_X));
            _Freenode(_X);
        }
    }
    void _Init()
    {
        //_Lockit _Lk;
        if (_Nil == 0)
        {
            _Nil = _Buynode(0, _Black);
            _Left(_Nil) = 0, _Right(_Nil) = 0;
        }
        ++_Nilrefs;
        _Head = _Buynode(_Nil, _Red), _Size = 0;
        _Lmost() = _Head, _Rmost() = _Head;
    }
    iterator _Insert(_Nodeptr _X, _Nodeptr _Y, const _Ty& _V)
    {
        //_Lockit _Lk;
        _Nodeptr _Z = _Buynode(_Y, _Red);
        _Left(_Z) = _Nil, _Right(_Z) = _Nil;
        _Consval(&_Value(_Z), _V);
        ++_Size;
        if (_Y == _Head || _X != _Nil
            || key_compare(_Kfn()(_V), _Key(_Y)))
        {
            _Left(_Y) = _Z;
            if (_Y == _Head)
            {
                _Root() = _Z;
                _Rmost() = _Z;
            }
            else if (_Y == _Lmost())
                _Lmost() = _Z;
        }
        else
        {
            _Right(_Y) = _Z;
            if (_Y == _Rmost())
                _Rmost() = _Z;
        }
        for (_X = _Z; _X != _Root()
            && _Color(_Parent(_X)) == _Red; )
            if (_Parent(_X) == _Left(_Parent(_Parent(_X))))
            {
                _Y = _Right(_Parent(_Parent(_X)));
                if (_Color(_Y) == _Red)
                {
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Y) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _X = _Parent(_Parent(_X));
                }
                else
                {
                    if (_X == _Right(_Parent(_X)))
                    {
                        _X = _Parent(_X);
                        _Lrotate(_X);
                    }
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _Rrotate(_Parent(_Parent(_X)));
                }
            }
            else
            {
                _Y = _Left(_Parent(_Parent(_X)));
                if (_Color(_Y) == _Red)
                {
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Y) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _X = _Parent(_Parent(_X));
                }
                else
                {
                    if (_X == _Left(_Parent(_X)))
                    {
                        _X = _Parent(_X);
                        _Rrotate(_X);
                    }
                    _Color(_Parent(_X)) = _Black;
                    _Color(_Parent(_Parent(_X))) = _Red;
                    _Lrotate(_Parent(_Parent(_X)));
                }
            }
        _Color(_Root()) = _Black;
        return (iterator(_Z));
    }
    _Nodeptr _Lbound(const _K& _Kv) const
    {
        //_Lockit _Lk;
        _Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        while (_X != _Nil)
            if (key_compare(_Key(_X), _Kv))
                _X = _Right(_X);
            else
                _Y = _X, _X = _Left(_X);
        return (_Y);
    }
    _Nodeptr& _Lmost()
    {
        return (_Left(_Head));
    }
    _Nodeptr& _Lmost() const
    {
        return (_Left(_Head));
    }
    void _Lrotate(_Nodeptr _X)
    {
        //_Lockit _Lk;
        _Nodeptr _Y = _Right(_X);
        _Right(_X) = _Left(_Y);
        if (_Left(_Y) != _Nil)
            _Parent(_Left(_Y)) = _X;
        _Parent(_Y) = _Parent(_X);
        if (_X == _Root())
            _Root() = _Y;
        else if (_X == _Left(_Parent(_X)))
            _Left(_Parent(_X)) = _Y;
        else
            _Right(_Parent(_X)) = _Y;
        _Left(_Y) = _X;
        _Parent(_X) = _Y;
    }
    static _Nodeptr _Max(_Nodeptr _P)
    {
        //_Lockit _Lk;
        while (_Right(_P) != _Nil)
            _P = _Right(_P);
        return (_P);
    }
    static _Nodeptr _Min(_Nodeptr _P)
    {
        //_Lockit _Lk;
        while (_Left(_P) != _Nil)
            _P = _Left(_P);
        return (_P);
    }
    _Nodeptr& _Rmost()
    {
        return (_Right(_Head));
    }
    _Nodeptr& _Rmost() const
    {
        return (_Right(_Head));
    }
    _Nodeptr& _Root()
    {
        return (_Parent(_Head));
    }
    _Nodeptr& _Root() const
    {
        return (_Parent(_Head));
    }
    void _Rrotate(_Nodeptr _X)
    {
        //_Lockit _Lk;
        _Nodeptr _Y = _Left(_X);
        _Left(_X) = _Right(_Y);
        if (_Right(_Y) != _Nil)
            _Parent(_Right(_Y)) = _X;
        _Parent(_Y) = _Parent(_X);
        if (_X == _Root())
            _Root() = _Y;
        else if (_X == _Right(_Parent(_X)))
            _Right(_Parent(_X)) = _Y;
        else
            _Left(_Parent(_X)) = _Y;
        _Right(_Y) = _X;
        _Parent(_X) = _Y;
    }
    _Nodeptr _Ubound(const _K& _Kv) const
    {
        //_Lockit _Lk;
        _Nodeptr _X = _Root();
        _Nodeptr _Y = _Head;
        while (_X != _Nil)
            if (key_compare(_Kv, _Key(_X)))
                _Y = _X, _X = _Left(_X);
            else
                _X = _Right(_X);
        return (_Y);
    }
    _Nodeptr _Buynode(_Nodeptr _Parg, _Redbl _Carg)
    {
        _Nodeptr _S = (_Nodeptr)allocator._Charalloc(
                                                    1 * sizeof (_Node));
        _Parent(_S) = _Parg;
        _Color(_S) = _Carg;
        return (_S);
    }
    void _Consval(_Tptr _P, const _Ty& _V)
    {
        _Construct(&*_P, _V);
    }
    void _Destval(_Tptr _P)
    {
        _Destroy(&*_P);
    }
    void _Freenode(_Nodeptr _S)
    {
        allocator.deallocate(_S, 1);
    }
    _A          allocator;
    _Pr         key_compare;
    _Nodeptr    _Head;
    bool        _Multi;
    size_type   _Size;
};

template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
_Tree<_K, _Ty, _Kfn, _Pr, _A>::_Nodeptr
_Tree<_K, _Ty, _Kfn, _Pr, _A>::_Nil = 0;

template<class _K, class _Ty, class _Kfn, class _Pr, class _A>
size_t _Tree<_K, _Ty, _Kfn, _Pr, _A>::_Nilrefs = 0;

// tree TEMPLATE OPERATORS
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator==(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (_X.size() == _Y.size()
            && equal(_X.begin(), _X.end(), _Y.begin()));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator!=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (!(_X == _Y));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator<(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
               const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (lexicographical_compare(_X.begin(), _X.end(),
                                    _Y.begin(), _Y.end()));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator>(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
               const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (_Y < _X);
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator<=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (!(_Y < _X));
}
template<class _K, class _Ty, class _Kfn,
class _Pr, class _A> inline
bool operator>=(const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _X,
                const _Tree<_K, _Ty, _Kfn, _Pr, _A>& _Y)
{
    return (!(_X < _Y));
}

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLTREE_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\upclsid.h ===
#include <guiddef.h>

// Reserved GUIDS for our use
//
// e57ce731-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceFolder
// e57ce732-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceDetails      
// e57ce733-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceEnum         
// e57ce734-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceContextMenu 
// e57ce735-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceExtractIcon  
// e57ce736-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceQueryInfo    
// e57ce737-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPDeviceFolderDeviceFinderCallback
// e57ce738-33e8-4c51-8354-bb4de9d215d1     CLSID_UPnPTrayMonitor
// ...                                               
// e57ce73F-33e8-4c51-8354-bb4de9d215d1     ???

DEFINE_GUID(CLSID_UPnPDeviceFolder,                     0xe57ce731,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);
DEFINE_GUID(CLSID_UPnPDeviceDetails,                    0xe57ce732,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1); 
DEFINE_GUID(CLSID_UPnPDeviceEnum,                       0xe57ce733,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);  
DEFINE_GUID(CLSID_UPnPDeviceContextMenu,                0xe57ce734,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);  
DEFINE_GUID(CLSID_UPnPDeviceExtractIcon,                0xe57ce735,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);  
DEFINE_GUID(CLSID_UPnPDeviceQueryInfo,                  0xe57ce736,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);  
DEFINE_GUID(CLSID_UPnPDeviceFolderDeviceFinderCallback, 0xe57ce737,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);  
DEFINE_GUID(CLSID_UPnPMonitor,                          0xe57ce738,0x33e8,0x4c51,0x83,0x54,0xbb,0x4d,0xe9,0xd2,0x15,0xd1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\stlxmem.h ===
#pragma once
#ifndef _STLXMEM_H_
#define _STLXMEM_H_
//#include <cstdlib>
//#include <new>
//#include <utility>

#include <stdlib.h>
#include <stlnew.h>
#include <stlutil.h>

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#ifndef _FARQ   /* specify standard memory model */
#define _FARQ
#define _PDFT  ptrdiff_t
#define _SIZT  size_t
#endif
#define _POINTER_X(T, A)   T _FARQ *
#define _REFERENCE_X(T, A) T _FARQ &

_STD_BEGIN

// TEMPLATE FUNCTION _Allocate
template<class _Ty> inline
_Ty _FARQ *_Allocate(_PDFT _N, _Ty _FARQ *)
{
    if (_N < 0)
        _N = 0;
    return ((_Ty _FARQ *)operator new((_SIZT)_N * sizeof (_Ty), raiseexception));
}

// TEMPLATE FUNCTION _Construct
template<class _T1, class _T2> inline
void _Construct(_T1 _FARQ *_P, const _T2& _V)
{
    new ((void _FARQ *)_P) _T1(_V);
}

// TEMPLATE FUNCTION _Destroy
template<class _Ty> inline
void _Destroy(_Ty _FARQ *_P)
{
    _DESTRUCTOR(_Ty, _P);
}
inline void _Destroy(char _FARQ *_P)
{

}
inline void _Destroy(wchar_t _FARQ *_P)
{

}

// TEMPLATE CLASS allocator
template<class _Ty>
class allocator
{
public:
    typedef _SIZT size_type;
    typedef _PDFT difference_type;
    typedef _Ty _FARQ *pointer;
    typedef const _Ty _FARQ *const_pointer;
    typedef _Ty _FARQ& reference;
    typedef const _Ty _FARQ& const_reference;
    typedef _Ty value_type;
    pointer address(reference _X) const
    {
        return (&_X);
    }
    const_pointer address(const_reference _X) const
    {
        return (&_X);
    }
    pointer allocate(size_type _N, const void *)
    {
        return (_Allocate((difference_type)_N, (pointer)0));
    }
    char _FARQ *_Charalloc(size_type _N)
    {
        return (_Allocate((difference_type)_N, (char _FARQ *)0));
    }
    void deallocate(void _FARQ *_P, size_type)
    {
        operator delete(_P);
    }
    void construct(pointer _P, const _Ty& _V)
    {
        _Construct(_P, _V);
    }
    void destroy(pointer _P)
    {
        _Destroy(_P);
    }
    _SIZT max_size() const
    {
        _SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
        return (0 < _N ? _N : 1);
    }
};
template<class _Ty, class _U> inline
bool operator==(const allocator<_Ty>&, const allocator<_U>&)
{
    return (true);
}
template<class _Ty, class _U> inline
bool operator!=(const allocator<_Ty>&, const allocator<_U>&)
{
    return (false);
}

// CLASS allocator<void>
class /*_CRTIMP*/ allocator<void>
{
public:
    typedef void _Ty;
    typedef _Ty _FARQ *pointer;
    typedef const _Ty _FARQ *const_pointer;
    typedef _Ty value_type;
};

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXMEM_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\upnp\upnpui\inc\windutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       W I N D U T I L . H 
//
//  Contents:   Window utilities for the connections shell
//
//  Notes:      
//
//  Author:     jeffspr   22 May 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _WINDUTIL_H_
#define _WINDUTIL_H_

BOOL FCenterWindow (HWND hwndChild, HWND hwndParent);

#endif _WINDUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\connect.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    connect.cxx

Abstract:

    Contains the entry points for the Winnet Connection API supported by the
    Multi-Provider Router.
    Contains:
        WNetAddConnectionW
        WNetAddConnection2W
        WNetAddConnection3W
        WNetUseConnectionW
        WNetCancelConnection2W
        WNetCancelConnectionW
        WNetGetConnectionW
        WNetSetConnectionW
        WNetRestoreConnectionW
        WNetRestoreConnection2W
        DoRestoreConnection
        MprRestoreThisConnection
        MprCreateConnectionArray
        MprSortConnectionArray
        MprRefcountConnectionArray
        MprAddPrintersToConnArray
        MprForgetPrintConnection
        MprFreeConnectionArray
        MprNotifyErrors
        MprNotifyShell
        MprCancelConnection2

Author:

    Dan Lafferty (danl)     09-Oct-1991

Environment:

    User Mode -Win32

Notes:

Revision History:

    09-Oct-1991     danl
        created
    03-Jan-1992     terryk
        Changed WNetRestoreConnections WNetRestoreConnection
    13-Jan-1992     Johnl
        Added MPR.H to include file list
    31-Jan-1992     Johnl
        Added fForgetConnection to WNetCancelConnectionW
    01-Apr-1992     Johnl
        Changed CONNECTION_REMEMBER to CONNECT_UPDATE_PROFILE, updated
        WNetCancelConnection2 to match spec
    22-Jul-1992     danl
        WNetAddConnection2:  If attempting to connect to a drive that is
        already remembered in the registry, we will allow the connect as
        long as the remote name for the connection is the same as the
        one that is remembered.  If the remote names are not the same
        return ERROR_DEVICE_ALREADY_REMEMBERED.
    26-Aug-1992     danl
        WNetAddConnectionW:  Put Try & except around STRLEN(lpLocalName).
    04-Sept-1992    danl
        Re-Write MprRestoreThisConnection.
    08-Sept-1992    danl
        WNetCancelConnect2W:  If no providers claim responsibility for
        the cancel, and if the connect info is in the registry, then
        remove it, and return SUCCESS.
    09-Sept-1992    danl
        WNetCancelConnect2W: If the provider returns WN_BAD_LOCALNAME,
        WN_NO_NETWORK, or WN_BAD_NETNAME, then return WN_NOT_CONNECTED.
    22-Sept-1992    danl
        WNetRestoreConnection: For WN_CANCEL case, set continue Flag to false.
        We don't want to ask for password again if they already said CANCEL.
    02-Nov-1992     danl
        Fail with NO_NETWORK if there are no providers.
    24-Nov-1992     Yi-HsinS
        Added checking in the registry to see whether we need to
        restore connection or not. ( support of RAS )
    16-Nov-1993     Danl
        AddConnect2:  If provider returns ERROR_INVALID_LEVEL or
        ERROR_INVALID_PARAMETER, continue trying other providers.
    19-Apr-1994     Danl
        DoRestoreConnection:  Fix timeout logic where we would ignore the
        provider-supplied timeout if the timeout was smaller than the default.
        Now, if all the providers know their timeouts, the larger of those
        timeouts is used.  Even if smaller than the default.
        AddConnection3:  Fixed Prototype to be more like AddConnection2.
    19-May-1994     Danl
        AddConnection3:  Changed comments for dwType probe to match the code.
        Also re-arrange the code here to make it more efficient.
    07-Feb-1995     AnirudhS
        MprGetConnection:  Fixed so that, like AddConnection and
        CancelConnection, it doesn't stop routing on errors.
    10-Feb-1995     AnirudhS
        WNetAddConnection3:  If provider returns WN_ALREADY_CONNECTED, stop
        trying other providers.
    08-May-1995     AnirudhS
        Add WNetUseConnection and make WNetAddConnection3 call through to it.
    12-Jun-1995     AnirudhS
        Send WM_DEVICECHANGE message to notify shell of connections.
    13-Jun-1995     AnirudhS
        Add WNetSetConnection.
    07-Jul-1995     AnirudhS
        Tidy up auto-picking logic in WNetUseConnection and CAutoPickedDevice.
    12-Jul-1995     AnirudhS
        Rename WNetRestoreConnection to WNetRestoreConnectionW to match
        winnetwk.w.
    14-Sep-1995     AnirudhS
        WNetGetConnection: Optimize for non-network drives by not calling
        the providers.  This enables the shell to open the "My Computer"
        folder much quicker.
    18-Oct-1995     AnirudhS
        WNetUseConnection: When saving the connection to the registry, if a
        username is not supplied, get it from the provider, so that the
        right username will be used at the next logon.
    15-Jan-1996     AnirudhS
        WNetRestoreConnection, etc.: Restore the connections in a deferred
        state if the remembered user name is the default user.
    08-Mar-1996     AnirudhS
        WNetRestoreConnection, etc.: Use the provider type in preference to
        the provider name when saving and restoring connections, so that
        floating profiles work in a multi-language environment.  See
        comments at MprReadConnectionInfo for details.
    20-Mar-1996     Anirudhs
        Add WNetGetConnection3.
    25-Mar-1996     AnirudhS
        WNetRestoreConnection, etc.: Don't display the "restoring connections"
        dialog if all connections are deferred.  Don't defer connections if
        a registry flag says not to.
    11-Apr-1996     AnirudhS
        WNetUseConnection: Convert to CRoutedOperation base class.
        Return WN_NO_MORE_DEVICES instead of WN_NO_MORE_ENTRIES.
    04-Jun-1996     AnirudhS
        WNetRestoreConnection: Don't defer connections if logged on locally.
        This is a temporary fix for bug 36827 for NT 4.0.
    07-Jun-1996     AnirudhS
        MprNotifyShell: Don't call BroadcastSystemMessage here.  Instead use
        a simple scheme to have a trusted system component broadcast on our
        behalf.  This fixes a deadlock that caused 20-second delays that were
        visible to the user.
    28-Jun-1996     AnirudhS
        Don't defer a connection if a password was explicitly supplied when
        the connection was made.
    08-Feb-1997     AnirudhS
        QFE 55011: Add WN_CONNECTED_OTHER_PASSWORD so the MPR knows if the
        provider prompted the user for an explicit password.
    21-Feb-1997     AnirudhS
        Add DEFER_UNKNOWN so MPR automatically discovers whether to defer a
        connection at future logons.
    03-Mar-1998     jschwart
        Fix bugs caused by moving WNetRestoreConnection from userinit.exe
        into winlogon.exe:  Add impersonation code to WNetRestoreConnection
        so a reconnection is attempted in the user's context.  Add code to
        close registry key handles that were leaked inWNetRestoreConnection,
        MprRestoreThisConnection, and CreateConnectionArray.
    05-May-1999     jschwart
        Make provider addition/removal dynamic
    04-Mar-2000     dsheldon
        Added WNetRestoreConnection2W with a flags field that allows us to
        reduce the amount of user interaction required to reconnect drives,
        and allow the shell to handle errors after logon instead.

--*/

//
// INCLUDES
//

#include "precomp.hxx"
extern "C" {
#include <ntlsa.h>      // LsaGetUserName
#include <winsvcp.h>    // SC_BSM_EVENT_NAME
}
#include <wincred.h>

#include <shellapi.h>
#include <shlapip.h>

#include <tstr.h>       // WCSSIZE, STRLEN
#include "connify.h"    // MprAddConnectNotify
#include "mprui.h"      // ShowReconnectDialog, etc.
#include <apperr.h>


//
// DATA STRUCTURES
//

typedef struct _CONNECTION_INFO
{
    BOOL                  ContinueFlag;
    DWORD                 ProviderIndex;
    DWORD                 ProviderWait;
    DWORD                 ProviderFlags;
    DWORD                 DeferFlags;     // flags read from registry
    DWORD                 Status;
    LPTSTR                UserName;
    BOOL                  Defer;          // our computed decision on whether to defer
    NETRESOURCEW          NetResource;
    HKEY                  RegKey;         // handle to the key with the connection info
    HINSTANCE             hProviderDll;   // Variables to keep provider DLLs loaded
    PF_NPGetCaps          pfGetCaps;
    PF_NPAddConnection3   pfAddConnection3;
    PF_NPAddConnection    pfAddConnection;
    PF_NPCancelConnection pfCancelConnection;
    DWORD                 dwConnectCaps;
}
CONNECTION_INFO, *LPCONNECTION_INFO;


//
// EXTERNAL GLOBALS
//

    extern  DWORD       GlobalNumActiveProviders;
    extern  BOOL        g_LUIDDeviceMapsEnabled;

//
// Defines
//

#define INVALID_WINDOW_HANDLE    ((HWND) INVALID_HANDLE_VALUE)


//
// Local Function Prototypes
//

VOID
DoRestoreConnection(
    PARAMETERS *        Params
    );

DWORD
MprRestoreThisConnection(
    HWND                hWnd,
    PARAMETERS *        Params,
    LPCONNECTION_INFO   ConnectInfo,
    DWORD               dwFlags
    );

DWORD
MprCreateConnectionArray(
    LPDWORD             lpNumConnections,
    LPCTSTR             lpDevice,
    LPDWORD             lpRegMaxWait,
    LPCONNECTION_INFO   *ConnectArray
    );

VOID
MprSortConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubKeys
    );

VOID
MprRefcountConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubkeys
    );

DWORD
MprAddPrintersToConnArray(
    LPDWORD             lpNumConnections,
    LPCONNECTION_INFO   *ConnectArray
    );

VOID
MprFreeConnectionArray(
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections
    );

BOOL
MprUserNameMatch (
    IN  PUNICODE_STRING DomainName,
    IN  PUNICODE_STRING UserName,
    IN  LPCWSTR         RememberedName,
    IN  BOOL            fMustMatchCompletely
    );

DWORD
MprNotifyErrors(
    HWND                hWnd,
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections,
    DWORD               dwFlags
    );

VOID
MprNotifyShell(
    IN LPCWSTR          pwszDevice
    );

DWORD
MprCancelConnection2 (
    IN  LPCWSTR  lpName,
    IN  DWORD    dwFlags,
    IN  BOOL     fForce,
    IN  BOOL     fCheckProviders
    );

BOOL
MprBroadcastDriveChange(
    IN LPCWSTR          pwszDevice,
    IN BOOL             DeleteAction
    );

DWORD
WNetAddConnectionW (
    IN  LPCWSTR  lpRemoteName,
    IN  LPCWSTR  lpPassword,
    IN  LPCWSTR  lpLocalName
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  The connection is remembered.

Arguments:

    lpRemoteName -  Specifies the network resource to connect to.

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpLocalName - This should contain the name of a local device to be
        redirected, such as "F:" or "LPT1:"  The string is treated in a
        case insensitive manner, and may be the empty string in which case
        a connection to the network resource is made without making a
        decision.

Return Value:



--*/

{
    DWORD           status = WN_SUCCESS;
    NETRESOURCEW    netResource;
    DWORD           numchars;

    //
    // load up the net resource structure
    //

    netResource.dwScope = 0;
    netResource.dwUsage = 0;
    netResource.lpRemoteName = (LPWSTR) lpRemoteName;
    netResource.lpLocalName = (LPWSTR) lpLocalName;
    netResource.lpProvider = NULL;
    netResource.lpComment = NULL;


    __try {
        numchars = STRLEN(lpLocalName);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetAddConnectionW:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS) {
        SetLastError(status);
        return status;
    }

    if (numchars == 0) {
        netResource.dwType = RESOURCETYPE_ANY;
    }
    else if (numchars > 2) {
        netResource.dwType = RESOURCETYPE_PRINT;
    }
    else {
        netResource.dwType = RESOURCETYPE_DISK;
    }

    //
    // Call WNetUseConnection so it can do all the work.
    //

    return(WNetUseConnectionW (
                NULL,               // hwndOwner
                &netResource,       // lpNetResource
                lpPassword,         // lpPassword
                NULL,               // lpUserID
                CONNECT_UPDATE_PROFILE, // dwFlags
                NULL,               // lpAccessName
                NULL,               // lpBufferSize
                NULL));             // lpResult

}

DWORD
WNetAddConnection2W (
    IN  LPNETRESOURCEW   lpNetResource,
    IN  LPCWSTR          lpPassword,
    IN  LPCWSTR          lpUserName,
    IN  DWORD            dwFlags
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  It is similar to WNetAddConnection, except
    that it takes a pointer to a NETRESOURCE structure to describe the
    network resource to connect to.  It also takes the additional parameters
    lpUserName, and dwFlags.

Arguments:

    lpNetResource - This is a pointer to a network resource structure that
        specifies the network resource to connect to.  The following
        fields must be set when making a connection, the others are ignored.
            lpRemoteName
            lpLocalName
            lpProvider
            dwType

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpUserName- This specifies the username used to make the connection.
        If NULL, the default username (currently logged on user) will be
        applied.  This is used when the user wishes to connect to a
        resource, but has a different user name or account assigned to him
        for that resource.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

Return Value:



--*/
{
    //
    // Call WNetUseConnection so it can do all the work.
    // It is called with a NULL HWND.
    //

    return(WNetUseConnectionW (
                NULL,               // hwndOwner
                lpNetResource,      // lpNetResource
                lpPassword,         // lpPassword
                lpUserName,         // lpUserID
                dwFlags,            // dwFlags
                NULL,               // lpAccessName
                NULL,               // lpBufferSize
                NULL));             // lpResult

}

DWORD
WNetAddConnection3W (
    IN  HWND            hwndOwner,
    IN  LPNETRESOURCEW  lpNetResource,
    IN  LPCWSTR         lpPassword,
    IN  LPCWSTR         lpUserName,
    IN  DWORD           dwFlags
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  It is similar to WNetAddConnection2, except
    that it takes the additional parameter hwndOwner.

Arguments:

    hwndOwner - A handle to a window which should be the owner for any
        messages or dialogs that the network provider might display.

    lpNetResource - This is a pointer to a network resource structure that
        specifies the network resource to connect to.  The following
        fields must be set when making a connection, the others are ignored.
            lpRemoteName
            lpLocalName
            lpProvider
            dwType

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpUserName- This specifies the username used to make the connection.
        If NULL, the default username (currently logged on user) will be
        applied.  This is used when the user wishes to connect to a
        resource, but has a different user name or account assigned to him
        for that resource.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

Return Value:


--*/
{
    //
    // Call WNetUseConnection so it can do all the work.
    // It is called with no buffer for the access name and result flags.
    //

    return(WNetUseConnectionW (
                hwndOwner,          // hwndOwner
                lpNetResource,      // lpNetResource
                lpPassword,         // lpPassword
                lpUserName,         // lpUserID
                dwFlags,            // dwFlags
                NULL,               // lpAccessName
                NULL,               // lpBufferSize
                NULL));             // lpResult
}


/*************************************************************************

    NAME:       CAutoPickedDevice

    SYNOPSIS:   This class is meant for use by the WNetUseConnection
        function.  It iterates through all possible local device names
        and finds an unused device name to be redirected.  For efficiency,
        it does this only once in the lifetime of the object, viz. the
        first time the PickDevice() method is called.  On subsequent calls
        it returns the result of the first call.

        The results of the PickDevice() call are saved in member variables,
        rather than being copied to the caller's buffer, because we don't
        know whether to return them to the caller until later.

    INTERFACE:

    CAVEATS:  The Init method must be called before the PickDevice method.

    NOTES:

    HISTORY:
        AnirudhS  24-May-1995  Created

**************************************************************************/

class CAutoPickedDevice
{
private:
    DWORD       _bPicked;       // whether already attempted to pick a device
    DWORD       _dwError;       // result of attempt to pick a device

    DWORD       _dwDeviceType;  // saved parameter from Init()
    DWORD       _cchBufferSize; // saved parameter from Init()

    DWORD       _cchReqBufferSize;  // saved results of PickDevice()
    WCHAR       _wszPickedName[ max(sizeof("A:"), sizeof("LPT99:")) ];

public:

    DWORD   Init(
                IN  LPWSTR  lpAccessName,
                IN  LPDWORD lpcchBufferSize,
                IN  LPCWSTR pwszLocalName,
                IN  LPCWSTR pwszRemoteName,
                IN  DWORD   dwDeviceType,
                IN  DWORD   dwFlags
                );

    DWORD   PickDevice();

    DWORD   dwError()
            {   return _dwError;    }

    DWORD   cchReqBufferSize()
            {   return _cchReqBufferSize;    }

    LPWSTR  wszPickedName()
            {   return _wszPickedName;  }
} ;


/*************************************************************************

    NAME:       CAutoPickedDevice::Init

    SYNOPSIS:   This function validates the parameters related to access
        names and auto-picking of local device names, and saves away some
        of them to be used in PickDevice().
        Depending on the severity of the errors it finds, it does one of
        the following:
        - cause an access violation
        - return an error
        - return success, but save away an error to be returned from
          PickDevice()
        - return success, and save away WN_SUCCESS so that PickDevice()
          will try to pick a device

**************************************************************************/

DWORD CAutoPickedDevice::Init(
    IN      LPWSTR  lpAccessName,
    IN      LPDWORD lpcchBufferSize,
    IN      LPCWSTR pwszLocalName,
    IN      LPCWSTR pwszRemoteName,
    IN      DWORD   dwDeviceType,
    IN      DWORD   dwFlags
    )
{
    _bPicked = FALSE;
    _dwError = WN_SUCCESS;

    //
    // If out pointers are supplied, make sure they're writeable
    // (even if we don't use them)
    //
    if (ARGUMENT_PRESENT(lpcchBufferSize))
    {
        _cchBufferSize = *(volatile DWORD *)lpcchBufferSize;    // Probe
        *(volatile DWORD *)lpcchBufferSize = _cchBufferSize;    // Probe
    }
    else
    {
        _cchBufferSize = 0;
    }


    if (ARGUMENT_PRESENT(lpAccessName))
    {
        //
        // If an AccessName buffer is supplied, the size parameter must
        // be present and non-zero, else return right away
        //
        if (_cchBufferSize == 0)
        {
            return WN_BAD_VALUE;    // Win95 compatibility
        }

        if (IsBadWritePtr(lpAccessName, _cchBufferSize * sizeof(WCHAR)))
        {
            return WN_BAD_POINTER;
        }

        _cchReqBufferSize = 0;

        //
        // If an access name is requested, and a local name is
        // specified, then we know that the access name will be the
        // specified local name, so we can validate the buffer
        // length up front
        //
        if (! IS_EMPTY_STRING(pwszLocalName))
        {
            _cchReqBufferSize = wcslen(pwszLocalName)+1;
        }

        //
        // If an access name is requested, and no local name is
        // specified, and we aren't asked to auto-pick a local
        // device, then the access name is likely to be the specified
        // remote name, so we validate the buffer length up front
        //
        else if ((dwFlags & CONNECT_REDIRECT) == 0)
        {
            _cchReqBufferSize = wcslen(pwszRemoteName)+1;
        }

        if (_cchBufferSize < _cchReqBufferSize) {
            *lpcchBufferSize = _cchReqBufferSize;
            return WN_MORE_DATA;
        }

        //
        // Save other parameters for use in PickDevice()
        //
        _dwDeviceType = dwDeviceType;

        //
        // (If we auto-pick a local device, the buffer length will
        // be validated later, when we auto-pick)
        //
    }
    else
    {
        //
        // We won't be able to autopick, because no access name buffer
        // is supplied.  But don't return the error until we're asked
        // to autopick.
        //
        _bPicked = TRUE;
        _dwError = WN_BAD_POINTER;
    }

    return WN_SUCCESS;
}



/*************************************************************************

    NAME:       CAutoPickedDevice::PickDevice

**************************************************************************/

DWORD CAutoPickedDevice::PickDevice()
{
    //
    // If we've been called before then return the error we returned
    // last time
    //
    if (_bPicked)
    {
        return _dwError;
    }

    _bPicked = TRUE;


    //
    // Validate the access name buffer size depending on the device type
    //
    if (_dwDeviceType == RESOURCETYPE_DISK)
    {
        _cchReqBufferSize = sizeof( "A:" );
    }
    else if (_dwDeviceType == RESOURCETYPE_PRINT)
    {
        _cchReqBufferSize = sizeof( "LPT1" );
    }
    else  // RESOURCETYPE_ANY -- can't autopick
    {
        _dwError = WN_BAD_VALUE;
        return _dwError;
    }

    if ( _cchBufferSize < _cchReqBufferSize )
    {
        _dwError = WN_MORE_DATA;
        return _dwError;
    }

    if (_dwDeviceType == RESOURCETYPE_DISK)
    {
        DWORD  dwDrives = GetLogicalDrives();
        DWORD  dwAvail  = (1 << ('Z' - 'A'));
        WCHAR  i;

        //
        // Try each drive from z: to c: and see if it's been used.
        // Check in reverse order to reduce the risk of conflicts
        // between remote and local drive letters (e.g., if hardware
        // is added after a drive is mapped).
        //
        for (i = L'Z'; i >= L'C'; i--, dwDrives <<= 1)
        {
            if (!(dwDrives & dwAvail))
            {
                //
                // This drive is available
                //
                _wszPickedName[0] = i;
                _wszPickedName[1] = L':';
                _wszPickedName[2] = L'\0';

                _dwError = WN_SUCCESS;
                return _dwError;
            }
        }
    }
    else  // (_dwDeviceType == RESOURCETYPE_PRINT)
    {
        WCHAR wszDeviceList[128];
        DWORD cch;

        //
        // Try each device from LPT1 to LPT99 and see if it's been used
        //
        wcscpy(_wszPickedName, L"LPT");
        for (ULONG i = 1; i <= 99; i++)
        {
            wsprintf(&_wszPickedName[sizeof("LPT")-1], L"%lu", i);

            cch = QueryDosDevice(_wszPickedName,
                                 wszDeviceList,
                                 sizeof(wszDeviceList)/sizeof(WCHAR));

            if ((cch == 0) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
            {
                //
                // QueryDosDevice failed -- this device is free
                //
                _dwError = WN_SUCCESS;
                return _dwError;
            }
        }
    }

    //
    // No unused devices found
    //
    _dwError = WN_NO_MORE_DEVICES;
    return _dwError;
}



//===================================================================
// WNetUseConnectionW
//===================================================================

class CUseConnection : public CRoutedOperation
{
public:
                    CUseConnection(
                        HWND            hwndOwner,
                        LPNETRESOURCEW  lpNetResource,
                        LPCWSTR         lpPassword,
                        LPCWSTR         lpUserName,
                        DWORD           dwFlags,
                        LPWSTR          lpAccessName,
                        LPDWORD         lpBufferSize,
                        LPDWORD         lpResult
                        ) :
                            CRoutedOperation(
                                DBGPARM("UseConnection")
                                NULL,
                                ROUTE_AGGRESSIVE
                                ),
                            _hwndOwner    (hwndOwner    ),
                            _lpNetResource(lpNetResource),
                            _lpPassword   (lpPassword   ),
                            _lpUserName   (lpUserName   ),
                            _dwFlags      (dwFlags      ),
                            _lpAccessName (lpAccessName ),
                            _lpBufferSize (lpBufferSize ),
                            _lpResult     (lpResult     )
                        {
                            _ExplicitPassword = (_lpPassword != NULL);
                            _UsedDefaultCreds = FALSE;
                        }

protected:

    DWORD           GetResult();    // overrides CRoutedOperation implementation

private:
        DWORD           TestProviderWorker(                           \
                            const PROVIDER *pProvider           \
                            );

    HWND            _hwndOwner;
    LPNETRESOURCEW  _lpNetResource;
    LPCWSTR         _lpPassword;
    LPCWSTR         _lpUserName;
    DWORD           _dwFlags;
    LPWSTR          _lpAccessName;
    LPDWORD         _lpBufferSize;
    LPDWORD         _lpResult;

    BOOL              _ExplicitPassword;
    BOOL              _UsedDefaultCreds;
    CAutoPickedDevice _AutoPickedDevice;
    NETRESOURCEW      _ProviderNetResource;
    DWORD             _dwProviderFlags;

    DECLARE_CROUTED
};


DWORD
CUseConnection::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    DWORD status;

    //
    // lpRemoteName must be non-empty and readable.
    //
    if (wcslen(_lpNetResource->lpRemoteName) == 0)  // Probe
    {
        return WN_BAD_NETNAME;
    }

    if (! IS_EMPTY_STRING(_lpNetResource->lpLocalName))
    {
        //
        // If a lpLocalName is supplied, it must be a redirectable device
        // name.
        //
        if (MprDeviceType(_lpNetResource->lpLocalName) != REDIR_DEVICE)
        {
            return WN_BAD_LOCALNAME;
        }
    }

    //
    // If a result pointer is supplied, make sure it's writeable
    //
    if (ARGUMENT_PRESENT(_lpResult))
    {
        *_lpResult = 0;
    }

    if ((_lpNetResource->dwType != RESOURCETYPE_DISK)  &&
        (_lpNetResource->dwType != RESOURCETYPE_PRINT) &&
        (_lpNetResource->dwType != RESOURCETYPE_ANY))
    {
        return WN_BAD_VALUE;
    }

    if (_dwFlags &
            ~(CONNECT_TEMPORARY |
              CONNECT_INTERACTIVE |
              CONNECT_COMMANDLINE |
              CONNECT_CMD_SAVECRED |
              CONNECT_PROMPT |
              CONNECT_UPDATE_PROFILE |
              CONNECT_UPDATE_RECENT |
              CONNECT_REDIRECT |
              CONNECT_CURRENT_MEDIA))
    {
        return WN_BAD_VALUE;
    }

    //
    // Win95 compatibility: Ignore CONNECT_PROMPT if CONNECT_INTERACTIVE
    // isn't set
    //
    if (!(_dwFlags & CONNECT_INTERACTIVE))
    {
        _dwFlags &= ~CONNECT_PROMPT;

        //
        // Ditch the other prompting bits just to prevent later confusion
        //

        _dwFlags &= ~(CONNECT_COMMANDLINE|CONNECT_CMD_SAVECRED);
    }


    //
    // Validate parameters related to auto-picking of local device names.
    // Some errors are returned immediately; others are returned only
    // when we actually need to auto-pick a device.
    //
    status = _AutoPickedDevice.Init(
                    _lpAccessName,
                    _lpBufferSize,
                    _lpNetResource->lpLocalName,
                    _lpNetResource->lpRemoteName,
                    _lpNetResource->dwType,
                    _dwFlags
                    );
    if (status != WN_SUCCESS)
    {
        return status;
    }

    //
    // Set parameters used by base class.  Set the local name to NULL
    // to prevent the check for "localness" in the base class.
    //
    *ppProviderName = _lpNetResource->lpProvider;
    *ppRemoteName   = _lpNetResource->lpRemoteName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CUseConnection::TestProviderWorker(
    const PROVIDER * pProvider
    )
{
    DWORD status;

    ASSERT_INITIALIZED(NETWORK);

    if (pProvider->AddConnection3 == NULL &&
        pProvider->AddConnection == NULL)
    {
        return WN_NOT_SUPPORTED;
    }

    //
    // We will retry this provider, with an autopicked local name,
    // at most once
    //
    for (BOOL fRetried = FALSE; ; fRetried = TRUE)
    {
        //
        // Call the provider's appropriate entry point
        //

        //
        // If, in the future, there are cases when the lpRemoteName
        // is some alias understood by the provider but not by the
        // NT name space, we'll need to add a NPAddConnection4 which
        // allows the provider to return an access name.
        //
        if (pProvider->AddConnection3 != NULL)
        {
            //**************************************
            // Actual call to Provider.
            //**************************************
            status = pProvider->AddConnection3(
                        _hwndOwner,                 // hwndOwner
                        &_ProviderNetResource,      // lpNetResource
                        (LPWSTR)_lpPassword,        // lpPassword
                        (LPWSTR)_lpUserName,        // lpUserName
                        _dwProviderFlags & pProvider->ConnectFlagCaps ); // dwFlags

            if (status == WN_CONNECTED_OTHER_PASSWORD)
            {
                //
                // The user had to be prompted for a password, so don't
                // defer the connection when restoring it at the next logon.
                //
                ASSERT(_dwProviderFlags & CONNECT_INTERACTIVE);
                _ExplicitPassword = TRUE;
                status = WN_SUCCESS;
            }
            else if (status == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
            {
                //
                // The provider successfully used the default credentials
                // for this connection.
                //
                _UsedDefaultCreds = TRUE;
                status = WN_SUCCESS;
            }
        }
        else // (pProvider->AddConnection != NULL)
        {
            //**************************************
            // Actual call to Provider.
            //**************************************
            status = pProvider->AddConnection(
                        &_ProviderNetResource,      // lpNetResource
                        (LPWSTR)_lpPassword,        // lpPassword
                        (LPWSTR)_lpUserName);       // lpUserName

            ASSERT(status != WN_CONNECTED_OTHER_PASSWORD);
        }

        // The provider mustn't return this error, or it will mess us
        // up later
        ASSERT(status != WN_MORE_DATA);

        if (fRetried)
        {
            if (status != WN_SUCCESS)
            {
                // Restore the null local name
                _ProviderNetResource.lpLocalName = NULL;
            }

            break;
        }

        //
        // If this provider can't handle a NULL local name,
        // and we've been allowed to auto-pick a local name,
        // and we successfully auto-pick a local name,
        // try again with the auto-picked local name
        //
        // Note that status is updated iff we've been allowed
        // to auto-pick
        //
        if (status == WN_BAD_LOCALNAME &&
            _ProviderNetResource.lpLocalName == NULL &&
            _lpAccessName != NULL &&
            (status = _AutoPickedDevice.PickDevice()) == WN_SUCCESS)
        {
            _ProviderNetResource.lpLocalName =
                    _AutoPickedDevice.wszPickedName();
            MPR_LOG2(ROUTE, "CUseConnection: retrying %ws with device %ws ...\n",
                     pProvider->Resource.lpProvider,
                     _ProviderNetResource.lpLocalName);
        }
        else
        {
            //
            // Don't retry
            //
            break;
        }
    } // end retry loop for this provider

    return status;
}


BOOL
InitCredUI(
    IN  PWSTR pszRemoteName,
    OUT PWSTR pszServer,
    IN  ULONG ulServerLength
    )
{
    // Make sure the first 2 characters are path separators:

    if ((pszRemoteName == NULL) ||
        (pszRemoteName[0] != L'\\') ||
        (pszRemoteName[1] != L'\\'))
    {
        SetLastError(WN_BAD_NETNAME);
        return FALSE;
    }


    PWSTR pszStart = pszRemoteName + 2;
    PWSTR pszEnd = NULL;

    // send only the server name, the string up to the first slash
    pszEnd = wcschr(pszStart, L'\\');

    if (pszEnd == NULL)
    {
        pszEnd = pszStart + wcslen(pszStart);
    }

    DWORD_PTR dwLength = (DWORD_PTR)(pszEnd - pszStart);

    if ((dwLength == 0) || (dwLength >= ulServerLength))
    {
        // The server is either an empty string or more than the maximum
        // number of characters we support:

        SetLastError(WN_BAD_NETNAME);
        return FALSE;
    }

    wcsncpy(pszServer, pszStart, dwLength);
    pszServer[dwLength] = L'\0';
    return TRUE;
}


VOID
DisplayFailureReason(
    DWORD Status,
    LPCWSTR Path
    )

/*++

Routine Description:

    This routine displays the reason for the authentication failure.
    The complete path name is displayed.

    We could modify credui to display this, but credui doesn't have the full path name.

Arguments:

    Status - Status of the failure

    Path - Full path name of the failed authentication.

Return Value:

    None.

--*/
{
    DWORD MessageId;
    LPWSTR InsertionStrings[2];

    HMODULE lpSource = NULL;
    DWORD MessageLength = 0;
    LPWSTR Buffer = NULL;
    BOOL MessageFormatted = FALSE;

    //
    // Pick the message based in the failure status
    //

    MessageId = ( Status == ERROR_LOGON_FAILURE) ? APE_UseBadPassOrUser : APE_UseBadPass;
    InsertionStrings[0] = (LPWSTR) Path;


    //
    // Load the message library and format the message from it
    //

    lpSource = LoadLibraryEx(MESSAGE_FILENAME,
                             NULL,
                             LOAD_LIBRARY_AS_DATAFILE);

    if ( lpSource ) {

        //
        // Format the message
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_HMODULE,
                                        lpSource,
                                        MessageId,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,   // Limit the buffer size
                                        (va_list *) InsertionStrings);

        if ( MessageLength ) {
            MessageFormatted = TRUE;
        }
    }


    //
    // If it failed, print a generic message
    //

    if ( !MessageFormatted ) {
        WCHAR NumberString[18];

        //
        // get the message number in Unicode
        //
        _ultow(MessageId, NumberString, 16);

        //
        // setup insert strings
        //
        InsertionStrings[0] = NumberString;
        InsertionStrings[1] = MESSAGE_FILENAME;

        //
        // Use the system messge file.
        //

        MessageLength = FormatMessageW( FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                            FORMAT_MESSAGE_FROM_SYSTEM,
                                        NULL,
                                        ERROR_MR_MID_NOT_FOUND,
                                        0,       // LanguageId defaulted
                                        (LPWSTR) &Buffer,
                                        1024,
                                        (va_list *) InsertionStrings);

    }


    //
    // Avoid double newlines
    //

    if ( MessageLength >= 2) {

        if ( Buffer[MessageLength - 1] == L'\n' &&
             Buffer[MessageLength - 2] == L'\r') {

            //
            // "\r\n" shows up as two newlines when using the CRT and piping
            // output to a file.  Make it just one newline.
            //

            Buffer[MessageLength - 1] = L'\0';
            Buffer[MessageLength - 2] = L'\n';
            MessageLength --;
        }
    }


    //
    // Output the message to stdout
    //

    if ( MessageLength > 0 ) {
        HANDLE StdoutHandle = GetStdHandle( STD_OUTPUT_HANDLE );

        if ( StdoutHandle != INVALID_HANDLE_VALUE ) {
            DWORD CharsWritten;

            if ( !WriteConsoleW( StdoutHandle,
                                 Buffer,
                                 MessageLength,
                                 &CharsWritten,
                                 NULL )) {

                //
                // Convert to ANSI before doing the write file
                //


                if ( NO_ERROR == OutputStringToAnsiInPlace( Buffer ) ) {
                    CharsWritten = strlen( (LPSTR) Buffer );

                    WriteFile( StdoutHandle,
                               Buffer,
                               CharsWritten,
                               &CharsWritten,
                               NULL );

                }

            }

            //
            // Append a newline for formatting reasons
            //

            Buffer[0] = '\n';
            WriteFile( StdoutHandle,
                       Buffer,
                       1,
                       &CharsWritten,
                       NULL );
        }
    }


    //
    // Clean up before exitting
    //

    if ( lpSource != NULL ) {
        FreeLibrary( lpSource );
    }

    if ( Buffer != NULL ) {
        LocalFree( Buffer );
    }

}

DWORD
CUseConnection::TestProvider(
    const PROVIDER * pProvider
    )
{
    DWORD dwErr;
    DWORD LocalProviderFlags;
    BOOL DoCommandLinePrompting = FALSE;

    //
    // If the caller asked for CONNECT_COMMANDLINE,
    //  and the provider doesn't support it,
    //  this routine should take over responsibility for doing it.
    //

    LocalProviderFlags = _dwProviderFlags;

    if ( (_dwProviderFlags & CONNECT_COMMANDLINE) != 0 &&
         (pProvider->ConnectFlagCaps & CONNECT_COMMANDLINE) == 0 ) {

        DoCommandLinePrompting = TRUE;

        //
        // Don't let the provider do GUI prompting.
        //

        _dwProviderFlags &= ~(CONNECT_INTERACTIVE | CONNECT_PROMPT | CONNECT_COMMANDLINE | CONNECT_CMD_SAVECRED);
    }



    //
    // Try the connection once
    //  (Unless we're asked not to before prompting.)
    //

    if ( !DoCommandLinePrompting || (LocalProviderFlags & CONNECT_PROMPT) == 0 ) {
        dwErr = TestProviderWorker( pProvider );
    } else {
        dwErr = ERROR_LOGON_FAILURE;
    }

    //
    // If this routine is handling command line prompting,
    //  and the connection failed for authentication reasons,
    //  prompt for credentials here.
    //
    // Ignore COMMENT_COMMANDLINE_SAVECRED since we don't know what authentication mechanism
    //  the provider uses.
    //

    if ( DoCommandLinePrompting && CREDUI_IS_AUTHENTICATION_ERROR(dwErr) )
    {
        WCHAR szPassword[CREDUI_MAX_PASSWORD_LENGTH + 1];    // if the user needs to enter one
        WCHAR szUserName[CREDUI_MAX_USERNAME_LENGTH + 1];

        WCHAR szServer[CRED_MAX_DOMAIN_TARGET_NAME_LENGTH + 1];

        //
        // Display the reason for the failure with the full path name
        //

        DisplayFailureReason( dwErr, _ProviderNetResource.lpRemoteName );

        //
        // Default the user name to the one provided by the caller.
        //

        szUserName[0] = L'\0';
        if ( _lpUserName != NULL ) {
            if (wcslen(_lpUserName) > CREDUI_MAX_USERNAME_LENGTH) {
                return WN_BAD_USER;
            }
            wcscpy(szUserName, _lpUserName);
        }

        //
        // Prepare to use the credential manager user interface:
        //


        if (!InitCredUI(_ProviderNetResource.lpRemoteName,
                        szServer,
                        CRED_MAX_DOMAIN_TARGET_NAME_LENGTH))
        {
            dwErr = GetLastError();
        }
        else
        {
            DWORD dwCredErr;
            DWORD dwAuthErr;
            LPWSTR pszNewPassword;
            DWORD dwCredUIFlags = 0;

            //
            // Remember the original failure reason
            //
            dwAuthErr = dwErr;


            //
            // Set the appropriate flag to set the behavior of the common UI.
            //

            // Ask to not save the credential
            dwCredUIFlags |= CREDUI_FLAGS_DO_NOT_PERSIST |
                             CREDUI_FLAGS_GENERIC_CREDENTIALS;

            // We don't (yet) know how to handle certificates
            dwCredUIFlags |= CREDUI_FLAGS_EXCLUDE_CERTIFICATES;

            // Ensure that the username syntax is correct (Not in MPR)
            // dwCredUIFlags |= CREDUI_FLAGS_VALIDATE_USERNAME;

            dwCredErr = CredUICmdLinePromptForCredentials(
                                            szServer,
                                            NULL,
                                            dwAuthErr,
                                            szUserName,
                                            CREDUI_MAX_USERNAME_LENGTH,
                                            szPassword,
                                            CREDUI_MAX_PASSWORD_LENGTH,
                                            NULL,   // Creds not saved
                                            dwCredUIFlags);


            if (dwCredErr == ERROR_CANCELLED) {
                dwErr = WN_CANCEL;

            } else if ( dwCredErr == ERROR_SUCCESS ) {
                LPCWSTR OldPassword;

                //
                // Use the returned username and password
                //

                _lpUserName = szUserName;
                OldPassword = _lpPassword;
                _lpPassword = szPassword;

                //
                // Try the connection one more time
                //

                dwErr = TestProviderWorker( pProvider );

                if ( dwErr == NO_ERROR )
                {
                    //
                    // If typed password is different than the one passed in,
                    //  this is now an explicit password.
                    //

                    if ( OldPassword == NULL ||
                         wcscmp(OldPassword, _lpPassword) != 0 )
                    {
                        _ExplicitPassword = TRUE;
                    }
                }
            }

            //
            // clear any password from memory
            //
            ZeroMemory(szPassword, sizeof(szPassword)) ;
        }
    }

    //
    // Restore the flag to their initial value
    //
    _dwProviderFlags = LocalProviderFlags;

    return dwErr;
}


DWORD
CUseConnection::GetResult()
{
    DWORD status;

    //
    // If we're given a local name,
    // check the current list of remembered drives in the registry
    // to determine if the localName is already connected.
    //
    if (! IS_EMPTY_STRING(_lpNetResource->lpLocalName))
    {
        //
        // If the local drive is already in the registry, and it is
        // for a different connection than that specified in the
        // lpNetResource, then indicate an error because the device
        // is already remembered.
        //
        LPWSTR  remoteName;
        if (MprFindDriveInRegistry(_lpNetResource->lpLocalName, &remoteName))
        {
            if (remoteName != NULL)
            {
                if (STRICMP(_lpNetResource->lpRemoteName, remoteName)!=0)
                {
                    LocalFree(remoteName);
                    return WN_DEVICE_ALREADY_REMEMBERED;
                }
                LocalFree(remoteName);
            }
        }
    }

    //
    // We modify some parameters before passing them to the provider
    //
    _ProviderNetResource = *_lpNetResource;
    if (IS_EMPTY_STRING(_ProviderNetResource.lpLocalName))
    {
        _ProviderNetResource.lpLocalName = NULL;
    }
    _dwProviderFlags = _dwFlags & WNNC_CF_MAXIMUM;

    //
    // If we're not given a local name, but are explicitly asked to
    // redirect a device, we must autopick one
    //
    if ((_dwFlags & CONNECT_REDIRECT) &&
        (_ProviderNetResource.lpLocalName == NULL) )
    {
        status = _AutoPickedDevice.PickDevice();

        if (status != WN_SUCCESS)
        {
            return status;
        }

        _ProviderNetResource.lpLocalName = _AutoPickedDevice.wszPickedName();
    }

    INIT_IF_NECESSARY(NOTIFIEE_LEVEL,status);

    //
    // Notify all interested parties that a connection is being made.
    // (All providers are required to support deviceless connections, so
    // we shouldn't get a case where a notifyee might reject a connection
    // on the grounds that it has no local name, even though we would have
    // auto-picked a local name later)
    //
    NOTIFYADD           NotifyAdd;
    NOTIFYINFO          NotifyInfo;

    NotifyInfo.dwNotifyStatus   = NOTIFY_PRE;
    NotifyInfo.dwOperationStatus= 0L;
    NotifyInfo.lpContext        = MprAllocConnectContext();
    NotifyAdd.hwndOwner   = _hwndOwner;
    NotifyAdd.NetResource = *_lpNetResource;
    NotifyAdd.dwAddFlags  = _dwFlags;

    __try
    {
        status = MprAddConnectNotify(&NotifyInfo, &NotifyAdd);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"WNetUseConnectionW: ConnectNotify, Unexpected "
            "Exception %#lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }


    do  // Notification loop
    {
        //
        // Let the base class try all providers and figure out the best error
        // CRoutedOperation::GetResult calls INIT_IF_NECESSARY
        //
        status = CRoutedOperation::GetResult();

        //
        // Notify all interested parties of the status of the connection.
        //
        NotifyInfo.dwNotifyStatus    = NOTIFY_POST;
        NotifyInfo.dwOperationStatus = status;
    }
    while (MprAddConnectNotify(&NotifyInfo, &NotifyAdd) == WN_RETRY);

    MprFreeConnectContext(NotifyInfo.lpContext);

    //
    // Write info to the informational parameters
    // (lpAccessName, lpBufferSize, lpResult)
    //

    if (status == WN_MORE_DATA)
    {
        //
        // This error must have come from CAutoPickedDevice::PickDevice,
        // indicating that the access name buffer is too small
        // (unless it came from a buggy provider)
        //
        ASSERT(_AutoPickedDevice.dwError() == WN_MORE_DATA);
        if (ARGUMENT_PRESENT(_lpBufferSize))
        {
            *_lpBufferSize = _AutoPickedDevice.cchReqBufferSize();
        }
    }
    else if (status == WN_SUCCESS &&
             ARGUMENT_PRESENT(_lpAccessName))
    {
        LPWSTR pwszAccessName = _ProviderNetResource.lpLocalName;
        if (pwszAccessName == NULL)
        {
            pwszAccessName = _ProviderNetResource.lpRemoteName;
        }

        if (*_lpBufferSize < wcslen(pwszAccessName)+1)
        {
            //
            // We validated most of the cases up front, so the only way
            // this could happen is if we auto-picked and got a local
            // name that was longer than the remote name.
            //
            ASSERT(0);
            *_lpBufferSize = wcslen(pwszAccessName)+1;
            status = WN_MORE_DATA;
        }
        else
        {
            wcscpy(_lpAccessName, pwszAccessName);
            if (ARGUMENT_PRESENT(_lpResult) &&
                _ProviderNetResource.lpLocalName != NULL)
            {
                *_lpResult = CONNECT_LOCALDRIVE;
            }
        }
    }


    if (status == WN_SUCCESS)
    {
        ASSERT_INITIALIZED(NETWORK);

        //
        // If the connection was added successfully, then write the connection
        // information to the registry to make it persistent.
        // Note: Failure to write to the registry is ignored.
        //
        if ((_dwFlags & CONNECT_UPDATE_PROFILE) &&
            !IS_EMPTY_STRING(_ProviderNetResource.lpLocalName))
        {
            BYTE ProviderFlags = 0;

            //
            // Get the username for the connection if the provider didn't report
            // that default creds were used:
            //
            //    1.  If the username is explicitly given, store the
            //        username returned by the provider
            //
            //    2.  Otherwise, compare the username given by the
            //        provider with the default username.  If they're
            //        different, store it.  If they're the same, don't
            //
            //    3.  If we can't get a username for whatever reason,
            //        use the username in _lpUserName (which will be
            //        NULL if no name was explicitly given)
            //

            if (LastProvider()->GetUser != NULL)
            {
                WCHAR wszUser[MAX_PATH + 1];

                __try
                {
                    DWORD cbBuffer = LENGTH(wszUser);
                    DWORD status2 = LastProvider()->GetUser(
                                            _ProviderNetResource.lpLocalName,
                                            wszUser,
                                            &cbBuffer);

                    ASSERT(status2 != WN_MORE_DATA);

                    if (status2 == WN_SUCCESS)
                    {
                        //
                        // Step 1 -- is the username explicitly given?
                        //
                        if (ARGUMENT_PRESENT(_lpUserName))
                        {
                            MPR_LOG1(TRACE,
                                     "Explicit username being saved -- %ws\n",
                                     wszUser);
                            _lpUserName = wszUser;
                        }
                        else
                        {
                            //
                            // Step 2 -- is the user the default user?
                            //
                            PUNICODE_STRING UserName;
                            PUNICODE_STRING DomainName;
                            NTSTATUS ntStatus = LsaGetUserName(&UserName, &DomainName);

                            if (NT_SUCCESS(ntStatus))
                            {
                                if (MprUserNameMatch(DomainName, UserName, wszUser, TRUE))
                                {
                                    MPR_LOG1(TRACE,
                                             "User %ws is default user -- not saving username\n",
                                             wszUser);
                                    _lpUserName = NULL;
                                }
                                else
                                {
                                    MPR_LOG1(TRACE,
                                             "User %ws is not default user -- saving username\n",
                                             wszUser);
                                    _lpUserName = wszUser;
                                }
                            }
                        }
                    }
                    else if (status2 == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
                    {
                        //
                        // WN_CONNECTED_OTHER_PASSWORD_DEFAULT will be returned
                        // when user X mapped a drive as user Y and the credentials
                        // for user Y were stored in CredMan when the connection
                        // was made.  Treat this as the default username so we don't
                        // explicitly write user Y's username into the registry
                        // (since CredMan will be unable to reestablish the connection
                        // automatically in that case).
                        //

                        _lpUserName = NULL;
                    }
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    MPR_LOG(ERROR,
                            "WNetUseConnectionW: exception %#lx from NPGetUser\n",
                            GetExceptionCode());
                }
            }

            //
            // Get an 8-bit datum that the provider may want saved along
            // with the connection.  This will be passed back to the provider
            // in NPAddConnection3 when the connection is restored.
            // (Actually this is a hack for the NTLM provider to remember
            // whether a connection is a DFS connection or a regular LM
            // connection.)
            //
            if (LastProvider()->GetReconnectFlags != NULL)
            {
                // This is an internal entry point so we don't bother with
                // try-except
                DWORD status2 = LastProvider()->GetReconnectFlags(
                                            _ProviderNetResource.lpLocalName,
                                            &ProviderFlags
                                            );
                if (status2 != WN_SUCCESS)
                {
                    ProviderFlags = 0;
                }

                MPR_LOG3(RESTORE, "%ws wants flags %#x saved for %ws\n",
                            LastProvider()->Resource.lpProvider,
                            ProviderFlags,
                            _ProviderNetResource.lpLocalName);
            }

            I_MprSaveConn(
                    HKEY_CURRENT_USER,
                    LastProvider()->Resource.lpProvider,
                    LastProvider()->Type,
                    _lpUserName,
                    _ProviderNetResource.lpLocalName,
                    _ProviderNetResource.lpRemoteName,
                    _ProviderNetResource.dwType,
                    ProviderFlags,
                    _ExplicitPassword ? DEFER_EXPLICIT_PASSWORD : ( _UsedDefaultCreds ? DEFER_DEFAULT_CRED : 0 )
                    );
        }

        //
        // Notify the shell of the connection.
        // (This will be replaced by real Plug'n'Play)
        //
        if( (g_LUIDDeviceMapsEnabled == TRUE) &&
            (_ProviderNetResource.lpLocalName != NULL) )
        {
            // Use LUID broadcast mechanism
            MprBroadcastDriveChange(
                _ProviderNetResource.lpLocalName,
                FALSE );    // not a Delete Message
        }
        else
        {
            MprNotifyShell(_ProviderNetResource.lpLocalName);
        }
    }

    return status;
}


DWORD
WNetUseConnectionW (
    IN  HWND            hwndOwner,
    IN  LPNETRESOURCEW  lpNetResource,
    IN  LPCWSTR         lpPassword,
    IN  LPCWSTR         lpUserName,
    IN  DWORD           dwFlags,
    OUT LPWSTR          lpAccessName OPTIONAL,
    IN OUT LPDWORD      lpBufferSize OPTIONAL,
    OUT LPDWORD         lpResult OPTIONAL
    )

/*++

Routine Description:

    This function allows the caller to redirect (connect) a local device
    to a network resource.  It is similar to WNetAddConnection3, except
    that it has the ability to auto-pick a local device to redirect.
    It also returns additional information about the connection in the
    lpResult parameter.

    This API is used by the shell to make links to:
    - Objects on networks that require a local device redirection
    - Objects served by applications that require a local device redirection
      (i.e. can't handle UNC paths)

    This API must redirect a local device in any of the following conditions:
    - The API is given a local device name to redirect
    - The API is asked to redirect a local device, by the CONNECT_REDIRECT
      flag
    - The network provider requires a redirection
    In the last 2 cases, if a local device name isn't given, the API must
    auto-pick a local device name.

Arguments:

    hwndOwner - A handle to a window which should be the owner for any
        messages or dialogs that the network provider might display.

    lpNetResource - This is a pointer to a network resource structure that
        specifies the network resource to connect to.  The following
        fields must be set when making a connection, the others are ignored.
            lpRemoteName
            lpLocalName
            lpProvider
            dwType

    lpPassword - Specifies the password to be used in making the connection.
        The NULL value may be passed in to indicate use of the 'default'
        password.  An empty string may be used to indicate no password.

    lpUserName- This specifies the username used to make the connection.
        If NULL, the default username (currently logged on user) will be
        applied.  This is used when the user wishes to connect to a
        resource, but has a different user name or account assigned to him
        for that resource.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

    lpAccessName - Points to a buffer to receive the name that can be used
        to make system requests on the connection. This conversion is useful
        when lpRemoteName is understood by the provider but not by the
        system's name space, and when this API autopicks a local device.
        If lpLocalName specifies a local device, then this buffer is optional,
        and if specified will have the local device name copied into it.
        Otherwise, if the network requires a local device redirection, or
        CONNECT_REDIRECT is set, then this buffer is required and the
        redirected local device is returned here. Otherwise, the name copied
        into the buffer is that of a remote resource, and if specified, this
        buffer must be at least as large as the string pointed to by
        lpRemoteName.

    lpBufferSize - Specifies the size, in characters, of the lpAccessName
        buffer.  If the API returns WN_MORE_DATA the required size will be
        returned here.

    lpResult - Pointer to a DWORD in which is returned additional information
        about the connection.  Currently has the following bit values:
        CONNECT_LOCALDRIVE - If set, the connection was made using a local
            device redirection. If lpAccessName points to a buffer then the
            local device name is copied to the buffer.

Return Value:

--*/
{
    CUseConnection UseConnection(hwndOwner, lpNetResource, lpPassword,
                                 lpUserName, dwFlags, lpAccessName,
                                 lpBufferSize, lpResult);

    return (UseConnection.Perform(TRUE));
}


//===================================================================
// WNetCancelConnection2W
//===================================================================

class CCancelConnection2 : public CRoutedOperation
{
public:
                    CCancelConnection2(
                        LPCWSTR      lpName,
                        DWORD        dwFlags,
                        BOOL         fForce
                        ) :
                            CRoutedOperation(DBGPARM("CancelConnection2")
                                             PROVIDERFUNC(CancelConnection)),
                            _lpName (lpName),
                            _dwFlags(dwFlags),
                            _fForce (fForce)
                        { }

protected:

    DWORD           GetResult();    // overrides CRoutedOperation implementation

private:

    LPCWSTR         _lpName;
    DWORD           _dwFlags;
    BOOL            _fForce;

    DECLARE_CROUTED
};


DWORD
CCancelConnection2::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (((_dwFlags != 0) && (_dwFlags != CONNECT_UPDATE_PROFILE)) ||
        wcslen(_lpName) == 0) // probe lpName
    {
        return WN_BAD_VALUE;
    }

    //
    // Use the specified remote name as a hint to pick the provider, but not
    // if it's a local device name
    //
    if (MprDeviceType(_lpName) != REDIR_DEVICE)
    {
        *ppRemoteName = _lpName;
    }

    *ppLocalName = _lpName;

    return WN_SUCCESS;
}


DWORD
CCancelConnection2::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return (pProvider->CancelConnection((LPWSTR)_lpName, _fForce));
}


DWORD
CCancelConnection2::GetResult()
{
    DWORD status;

    NOTIFYCANCEL    NotifyCancel;
    NOTIFYINFO      NotifyInfo;

    INIT_IF_NECESSARY(NOTIFIEE_LEVEL, status);

    //
    // Notify all interested parties that a connection is being cancelled
    //
    NotifyInfo.dwNotifyStatus   = NOTIFY_PRE;
    NotifyInfo.dwOperationStatus= 0L;
    NotifyInfo.lpContext        = MprAllocConnectContext();
    NotifyCancel.lpName     = (LPWSTR)_lpName;
    NotifyCancel.lpProvider = NULL;
    NotifyCancel.dwFlags    = _dwFlags;
    NotifyCancel.fForce     = _fForce;

    __try
    {
        status = MprCancelConnectNotify(&NotifyInfo, &NotifyCancel);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"WNetCancelConnection2W: ConnectNotify, Unexpected "
            "Exception %#lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        return status;
    }

    do  // Notification loop
    {
        //
        // Let the base class try all providers and figure out the best error
        // CRoutedOperation::GetResult calls INIT_IF_NECESSARY
        //
        status = CRoutedOperation::GetResult();

        //
        // Map these errors to a friendlier one for this API
        //
        if (status == WN_BAD_NETNAME ||
            status == ERROR_BAD_NETPATH ||
            status == WN_BAD_LOCALNAME ||
            status == WN_NO_NETWORK ||
            status == WN_NO_NET_OR_BAD_PATH)
        {
            MPR_LOG2(ROUTE, "CCancelConnection2: remapping %ld to %ld\n",
                        status, WN_NOT_CONNECTED);
            status = WN_NOT_CONNECTED;
        }

        //
        // Notify all interested parties of the status of the connection.
        //
        NotifyInfo.dwNotifyStatus    = NOTIFY_POST;
        NotifyInfo.dwOperationStatus = status;  // Is this the right status??
        if (status == WN_SUCCESS)
        {
            NotifyCancel.lpProvider = LastProvider()->Resource.lpProvider;
        }
    }
    while (MprCancelConnectNotify(&NotifyInfo, &NotifyCancel) == WN_RETRY);

    MprFreeConnectContext(NotifyInfo.lpContext);

    //
    // Regardless of whether the connection was cancelled successfully,
    // we still want to remove any connection information from the
    // registry if told to do so (dwFlags has CONNECT_UPDATE_PROFILE set).
    //
    if (_dwFlags & CONNECT_UPDATE_PROFILE)
    {
        if (MprDeviceType((LPWSTR)_lpName) == REDIR_DEVICE)
        {
            if (MprFindDriveInRegistry((LPWSTR)_lpName,NULL))
            {
                //
                // If the connection was found in the registry, we want to
                // forget it and if no providers claimed responsibility,
                // return success.
                //
                MprForgetRedirConnection((LPWSTR)_lpName);
                if (status == WN_NOT_CONNECTED)
                {
                    status = WN_SUCCESS;
                }
            }
        }
    }

    if (status == WN_SUCCESS)
    {
        //
        // Notify the shell of the disconnection.
        //
        if( (g_LUIDDeviceMapsEnabled == TRUE) && (_lpName != NULL) )
        {
            // Use LUID broadcast mechanism
            MprBroadcastDriveChange(
                _lpName,
                TRUE );   // a Delete Message
        }
        else
        {
            MprNotifyShell(_lpName);
        }
    }

    return status;
}


DWORD
WNetCancelConnection2W (
    IN  LPCWSTR  lpName,
    IN  DWORD    dwFlags,
    IN  BOOL     fForce
    )

/*++

Routine Description:

    This function breaks an existing network connection.  The persistance
    of the connection is determined by the dwFlags parameter.

Arguments:

    lpName - The name of either the redirected local device, or the remote
        network resource to disconnect from.  In the former case, only the
        redirection specified is broken.  In the latter case, all
        connections to the remote network resource are broken.

    dwFlags - This is a bitmask which may have any of the following bits set:
        CONNECT_UPDATE_PROFILE

    fForce - Used to indicate if the disconnect should be done forcefully
        in the event of open files or jobs on the connection.  If FALSE is
        specified, the call will fail if there are open files or jobs.


Return Value:

    WN_SUCCESS - The call was successful.  Otherwise, GetLastError should be
        called for extended error information.  Extended error codes include
        the following:

    WN_NOT_CONNECTED - lpName is not a redirected device. or not currently
        connected to lpName.

    WN_OPEN_FILES - There are open files and fForce was FALSE.

    WN_EXTENDED_ERROR - A network specific error occured.  WNetGetLastError
        should be called to obtain a description of the error.

--*/
{
    //
    // Check the providers
    //
    return MprCancelConnection2(lpName, dwFlags, fForce, TRUE);
}


DWORD
MprCancelConnection2 (
    IN  LPCWSTR  lpName,
    IN  DWORD    dwFlags,
    IN  BOOL     fForce,
    IN  BOOL     fCheckProviders
    )
/*++

Routine Description:

    Wrapper to use the CCancelConnection2 class -- needed because otherwise,
    WNetRestoreConnectionW could call WNetCancelConnection2W, causing a
    deadlock on the provider lock.

Arguments:


Return Value:

--*/
{
    CCancelConnection2 CancelConnection2(lpName, dwFlags, fForce);

    return (CancelConnection2.Perform(fCheckProviders));
}


DWORD
WNetCancelConnectionW (
    IN  LPCWSTR  lpName,
    IN  BOOL    fForce
    )

/*++

Routine Description:

    This function breaks an existing network connection.  The connection is
    always made non-persistent.

    Note that this is a stub routine that calls WNetCancelConnection2W and
    is only provided for Win3.1 compatibility.

Arguments:

    Parameters are the same as WNetCancelConnection2W

Return Value:

    Same as WNetCancelConnection2W


--*/
{
    return MprCancelConnection2( lpName, CONNECT_UPDATE_PROFILE, fForce, TRUE ) ;
}

DWORD
WNetGetConnectionW (
    IN      LPCWSTR  lpLocalName,
    OUT     LPWSTR   lpRemoteName,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:



Arguments:



Return Value:



--*/
{
    MprCheckProviders();

    CProviderSharedLock    PLock;

    return MprGetConnection( lpLocalName, lpRemoteName, lpBufferSize, NULL ) ;
}


DWORD
MprGetConnection (
    IN      LPCWSTR  lpLocalName,
    OUT     LPTSTR   lpRemoteName,
    IN OUT  LPDWORD  lpBufferSize,
    OUT     LPDWORD  lpProviderIndex OPTIONAL
    )

/*++

Routine Description:

    Retrieves the remote name associated with a device name and optionally
    the provider index.

    Behaviour is exactly the same as WNetGetConnectionW.

Arguments:



Return Value:



--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    DWORD       statusFlag = 0; // used to indicate major error types
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i;
    DWORD       dwFirstError = WN_SUCCESS;
    DWORD       dwFirstSignificantError = WN_SUCCESS;

    //
    // Validate the LocalName
    //
    __try {
        if (MprDeviceType((LPWSTR) lpLocalName) != REDIR_DEVICE) {
            status = WN_BAD_LOCALNAME;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetGetConnection:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        SetLastError(status);
        return status;
    }

    //
    // Optimization: If the local name is a drive, load the providers
    // only if it's a remote drive.
    //
    if (lpLocalName[1] == L':')
    {
        WCHAR wszRootPath[] = L" :\\";
        UINT  uDriveType;

        wszRootPath[0] = lpLocalName[0];
        uDriveType = GetDriveType(wszRootPath);

        if (uDriveType == DRIVE_REMOVABLE ||
            uDriveType == DRIVE_FIXED     ||
            uDriveType == DRIVE_CDROM     ||
            uDriveType == DRIVE_RAMDISK)
        {
            status = WN_NOT_CONNECTED;
            SetLastError(status);
            return status;
        }
        else if (uDriveType != DRIVE_REMOTE) {

            //
            // It's not a remote drive, but it's not one in hardware
            // (either DRIVE_UNKNOWN or DRIVE_NO_ROOT_DIR).  Since it
            // might have a name associated with it in the registry
            // (e.g., remembered connections), we have to load the
            // providers and check if necessary (done in
            // MprReadConnectionInformation)
            //
            status = WN_NOT_CONNECTED;
            goto CheckRemembered;
        }
    }

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                NETWORK_TYPE);

    if (status != WN_SUCCESS) {
        SetLastError(status);
        return status;
    }

    //
    // Loop through the list of providers until one answers the request,
    // or the list is exhausted.
    //

    for (i=0; i<numProviders; i++) {

        //
        // Call the appropriate providers API entry point
        //
        provider = GlobalProviderInfo + indexArray[i];

        if (provider->GetConnection != NULL) {

            fcnSupported = TRUE;

            __try {
                //**************************************
                // Actual call to Provider.
                //**************************************
                status = provider->GetConnection(
                            (LPWSTR) lpLocalName,
                            lpRemoteName,
                            lpBufferSize);
            }

            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetGetConnection:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }

            ////////////////////////////////////////////////////////////
            //                                                        //
            //   The following code attempts to give the user the     //
            //   most sensible error message. We have 3 clasess of    //
            //   errors. On first class we stop routing. On second    //
            //   continue but ignore that error (not significant      //
            //   because the provider didnt think it was his). On     //
            //   the last the provider returned an interesting (or    //
            //   significant) error. We still route, but remember     //
            //   it so it takes precedence over the non significant   //
            //   ones.                                                //
            //                                                        //
            ////////////////////////////////////////////////////////////

            //
            // Remember the first error, if it hasn't already been set
            //
            if (dwFirstError == WN_SUCCESS)
                dwFirstError = status ;

            //
            // If the provider returns one of these errors, stop routing.
            //
            if ((status == WN_BAD_POINTER) ||
                (status == WN_MORE_DATA) ||
                (status == WN_SUCCESS))
            {
                //
                // we either succeeded or have problems that means we
                // should not continue (eg. bad input causing exception).
                // and we make sure this is the error reported.
                //
                dwFirstError = status ;
                dwFirstSignificantError = status ;
                statusFlag = 0;
                if ( lpProviderIndex != NULL ) {
                    *lpProviderIndex = indexArray[i];
                }
                break;
            }

            //
            // If the provider returns one of these errors, continue
            // trying other providers, but do not remember as a
            // significant error, because the provider is probably not
            // interested. StatusFlag is use to detect the case where
            // a provider is not started.
            //
            else if (status == WN_NO_NETWORK)
            {
                statusFlag |= NO_NET;
            }
            else if ((status == WN_NOT_CONNECTED) ||
                     (status == WN_BAD_LOCALNAME))
            {
                //
                // WN_NOT_CONNECTED means that lpLocalName is not a
                // redirected device for this provider.
                //
                statusFlag |= BAD_NAME;
            }

            //
            // If a provider returns one of these errors, we continue
            // trying, but remember the error as a significant one. We
            // report it to the user if it is the first. We do this so
            // that if the first provider returns NotConnected and last
            // returns BadPassword, we report the Password Error.
            //
            else
            {
                //
                // All other errors are considered more significant
                // than the ones above
                //
                if (!dwFirstSignificantError && status)
                    dwFirstSignificantError = status ;

                statusFlag = OTHER_ERRS;
            }
        }
    }

    //
    // If we failed, set final error, in order of importance.
    // Significant errors take precedence.  Otherwise we always
    // report the first error.
    //

    if (status != WN_SUCCESS)
    {
        status = (dwFirstSignificantError != WN_SUCCESS) ?
                    dwFirstSignificantError :
                    dwFirstError ;
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Handle special errors.
    //
    if (statusFlag == (NO_NET | BAD_NAME)) {
        //
        // Check to see if there was a mix of special errors that occured.
        // If so, pass back the combined error message.  Otherwise, let the
        // last error returned get passed back.
        //
        status = WN_NO_NET_OR_BAD_PATH;
    }

CheckRemembered:

    //
    // Handle normal errors passed back from the provider
    //
    if (status != WN_SUCCESS) {

        if (status == WN_NOT_CONNECTED) {
            //
            // If not connected, but there is an entry for the LocalName
            // in the registry, then return the remote name that was stored
            // with it.
            //
            if (MprGetRemoteName(
                    (LPWSTR) lpLocalName,
                    lpBufferSize,
                    lpRemoteName,
                    &status)) {

                if (status == WN_SUCCESS) {
                    status = WN_CONNECTION_CLOSED;
                }

            }
        }
        SetLastError(status);
    }

    return status;
}

DWORD
WNetGetConnection2W (
    IN      LPWSTR   lpLocalName,
    OUT     LPVOID   lpBuffer,
    IN OUT  LPDWORD  lpBufferSize
    )

/*++

Routine Description:

    Just like WNetGetConnectionW except this one returns the provider name
    that the device is attached through

Arguments:

    lpBuffer will contain a WNET_CONNECTIONINFO structure
    lpBufferSize is the number of bytes required for the buffer

Return Value:



--*/
{
    DWORD  status = WN_SUCCESS ;
    DWORD  iProvider = 0 ;
    DWORD  nBytesNeeded = 0 ;
    DWORD  cchBuff = 0 ;
    DWORD  nTotalSize = *lpBufferSize ;
    LPTSTR lpRemoteName= (LPTSTR) ((BYTE*) lpBuffer +
                         sizeof(WNET_CONNECTIONINFO)) ;
    WNET_CONNECTIONINFO * pconninfo = (WNET_CONNECTIONINFO *) lpBuffer ;

    //
    // If they didn't pass in a big enough buffer for even the structure,
    // then make the size zero (so the buffer isn't accessed at all) and
    // let the API figure out the buffer size
    //

    if ( *lpBufferSize < sizeof( WNET_CONNECTIONINFO) ) {
         *lpBufferSize = 0 ;
         cchBuff = 0 ;
    }
    else {
         //
         //  MprGetConnection is expecting character counts, so convert
         //  after offsetting into the structure (places remote name directly
         //  in the structure).
         //
         cchBuff = (*lpBufferSize - sizeof(WNET_CONNECTIONINFO))/sizeof(TCHAR) ;
    }

    MprCheckProviders();

    CProviderSharedLock    PLock;

    status = MprGetConnection(
                lpLocalName,
                lpRemoteName,
                &cchBuff,
                &iProvider);

    if ( status == WN_SUCCESS ||
         status == WN_CONNECTION_CLOSED ||
         status == WN_MORE_DATA  ) {
         //
         //  Now we need to determine the buffer requirements for the
         //  structure and provider name
         //
         //  (Note that if MprGetConnection returns WN_CONNECTION_CLOSED, it
         //  does not touch the value of iProvider.  So iProvider will retain
         //  its somewhat arbitrary initial value of 0, meaning the first
         //  provider in the array.)
         //

         LPTSTR lpProvider = GlobalProviderInfo[iProvider].Resource.lpProvider;

         //
         //  Calculate the required buffer size.
         //

         nBytesNeeded = sizeof( WNET_CONNECTIONINFO ) +
                        (STRLEN( lpProvider) + 1) * sizeof(TCHAR);

         if ( status == WN_MORE_DATA )
         {
             nBytesNeeded +=  cchBuff * sizeof(TCHAR);
         }
         else
         {
             nBytesNeeded +=  (STRLEN( lpRemoteName) + 1) * sizeof(TCHAR);
         }

         if ( nTotalSize < nBytesNeeded ) {
             status = WN_MORE_DATA;
             *lpBufferSize = nBytesNeeded;
             return status;
         }

         //
         //  Place the provider name in the buffer and initialize the
         //  structure to point to the strings.
         //
         pconninfo->lpRemoteName = lpRemoteName ;
         pconninfo->lpProvider = STRCPY( (LPTSTR)
                                ((BYTE*) lpBuffer + sizeof(WNET_CONNECTIONINFO) +
                                (STRLEN( lpRemoteName ) + 1) * sizeof(TCHAR)),
                                lpProvider);
    }

    return status;
}


//===================================================================
// WNetGetConnection3W
//===================================================================

class CGetConnection3 : public CRoutedOperation
{
public:
                    CGetConnection3(
                        LPCWSTR  lpLocalName,
                        LPCWSTR  lpProviderName,
                        DWORD    dwLevel,
                        LPVOID   lpBuffer,
                        LPDWORD  lpBufferSize
                        ) :
                            DBGPARM(CRoutedOperation("GetConnection3"))
                            _lpLocalName   (lpLocalName   ),
                            _lpProviderName(lpProviderName),
                            _dwLevel       (dwLevel       ),
                            _lpBuffer      (lpBuffer      ),
                            _lpBufferSize  (lpBufferSize  )
                        { }

private:

    LPCWSTR         _lpLocalName;
    LPCWSTR         _lpProviderName;
    DWORD           _dwLevel;
    LPVOID          _lpBuffer;
    LPDWORD         _lpBufferSize;

    DECLARE_CROUTED
};


DWORD
CGetConnection3::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (_dwLevel != WNGC_INFOLEVEL_DISCONNECTED)
    {
        return WN_BAD_LEVEL;
    }

    if (MprDeviceType(_lpLocalName) != REDIR_DEVICE)
    {
        return WN_BAD_LOCALNAME;
    }

    if (IS_BAD_BYTE_BUFFER(_lpBuffer, _lpBufferSize))
    {
        return WN_BAD_POINTER;
    }

    //
    // Set parameters used by base class.  Note that we set *ppLocalName
    // to NULL to prevent the base class from checking it for "localness"
    // since this is a private API called by the shell for network drives
    // only.  If we ever want to check the local name, the line below will
    // have to be changed to:
    //
    //     *ppLocalName    = _lpLocalName;
    //
    *ppProviderName = _lpProviderName;
    *ppLocalName    = NULL;

    return WN_SUCCESS;
}


DWORD
CGetConnection3::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    if (pProvider->GetConnection3 != NULL)
    {
        return ( pProvider->GetConnection3(
                                _lpLocalName,
                                _dwLevel,
                                _lpBuffer,
                                _lpBufferSize) );
    }
    else if (pProvider->GetConnection == NULL)
    {
        return WN_NOT_SUPPORTED;
    }
    else
    {
        // Just verify that the provider owns the connection, and if so,
        // assume that it's not disconnected
        WCHAR wszRemoteName[40];
        DWORD nLength = LENGTH(wszRemoteName);
        DWORD status = pProvider->GetConnection(
                                        (LPWSTR)_lpLocalName,
                                        wszRemoteName,
                                        &nLength);
        if (status == WN_SUCCESS || status == WN_MORE_DATA)
        {
            // The provider owns the connection
            if (*_lpBufferSize < sizeof(WNGC_CONNECTION_STATE))
            {
                *_lpBufferSize = sizeof(WNGC_CONNECTION_STATE);
                status = WN_MORE_DATA;
            }
            else
            {
                ((LPWNGC_CONNECTION_STATE)_lpBuffer)->dwState =
                    WNGC_CONNECTED;
                status = WN_SUCCESS;
            }
        }

        return status;
    }
}


DWORD APIENTRY
WNetGetConnection3W(
    IN  LPCWSTR  lpLocalName,
    IN  LPCWSTR  lpProviderName OPTIONAL,
    IN  DWORD    dwLevel,
    OUT LPVOID   lpBuffer,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function returns miscellaneous information about a network
    connection, as specified by the info level parameter.

Arguments:

    lpLocalName - The name of a redirected local device for which
        information is required.

    lpProviderName - The name of the provider responsible for the connection,
        if known.

    dwLevel - Level of information required.  Supported levels are:

        1 - Determine whether the connection is currently disconnected.

    lpBuffer - Buffer in which to return the information if the call is
        successful.  The format of the information returned is as follows,
        depending on dwLevel:

        Level 1 - A DWORD is returned whose value is one of the following:
            WNGETCON_CONNECTED
            WNGETCON_DISCONNECTED

    lpBufferSize - On input, size of the buffer in bytes.  If the buffer
        is too small, the required size will be written here.
        For level 1 the required size is sizeof(DWORD).

Return Value:

    WN_SUCCESS - successful.
    WN_MORE_DATA - buffer is too small.
    WN_BAD_LOCALNAME - lpLocalName is not a valid device name.
    WN_BAD_PROVIDER - lpProviderName is not a recognized provider name.
    WN_NOT_CONNECTED - the device specified by lpLocalName is not redirected.
    WN_CONNECTION_CLOSED - the device specified by lpLocalName is not
        redirected, but is a remembered (unavailable) connection.

--*/
{
    CGetConnection3 GetConnection3(lpLocalName,
                                   lpProviderName,
                                   dwLevel,
                                   lpBuffer,
                                   lpBufferSize);

    DWORD status = GetConnection3.Perform(TRUE);

    if (status == WN_NOT_CONNECTED &&
        MprFindDriveInRegistry((LPWSTR)lpLocalName,NULL))
    {
        status = WN_CONNECTION_CLOSED;
    }

    return status;
}


DWORD
WNetRestoreConnectionW(
    IN  HWND    hWnd,
    IN  LPCWSTR lpDevice
    )
{
    return WNetRestoreConnection2W(hWnd, lpDevice, 0, NULL);
}


DWORD
WNetRestoreConnection2W(
    IN  HWND    hWnd,
    IN  LPCWSTR lpDevice,
    IN  DWORD   dwFlags,
    OUT BOOL*   pfReconnectFailed
    )
/*++

Routine Description:

    This function create another thread which does the connection.
    In the main thread it create a dialog window to monitor the  state of
    the connection.

Arguments:

    hwnd - This is a window handle that may be used as owner of any
        dialog brought up by MPR (eg. password prompt).

    lpDevice - This may be NULL or may contain a device name such as
        "x:". If NULL, all remembered connections are restored.  Otherwise,
        the remembered connection for the specified device, if any are
        restored.

    dwFlags - WNRC_NOUI specifies that no UI should be shown. Connections that
              fail to restore will be reattempted at next logon.

Return Value:
--*/
{
    DWORD               status               = WN_SUCCESS;
    DWORD               print_connect_status = WN_SUCCESS;
    DWORD               numSubKeys;
    DWORD               RegMaxWait = 0;
    HANDLE              hThread              = NULL;
    HANDLE              ThreadID;
    LPCONNECTION_INFO   ConnectArray;
    PARAMETERS         *lpParams             = NULL;
    BOOL                DontDefer            = FALSE;
    LONG                fDoCleanup           = FALSE;

    if (pfReconnectFailed)
    {
        *pfReconnectFailed = FALSE;
    }

    //
    // Check the registry to see if we need to restore connections or not,
    // and whether we can defer them.
    // This is done only if lpDevice is NULL (restoring all).
    // (If a particular device is specified, it is always restored undeferred.)
    //
    // Interpretation of the RestoreConnection value is:
    // 0 - don't restore connections (and ignore the DeferConnection value)
    // default - restore connections
    //
    // Interpretation of the DeferConnection value is:
    // 0 - don't defer any connections
    // default - defer every connection that can be deferred
    //
    if ( lpDevice == NULL )
    {
        HKEY   providerKeyHandle;
        DWORD  ValueType;
        DWORD  fRestoreConnection = TRUE;
        DWORD  Temp = sizeof( fRestoreConnection );

        if( MprOpenKey(  HKEY_LOCAL_MACHINE,     // hKey
                         NET_PROVIDER_KEY,       // lpSubKey
                        &providerKeyHandle,      // Newly Opened Key Handle
                         DA_READ))               // Desired Access
        {
            if ( RegQueryValueEx(
                    providerKeyHandle,
                    RESTORE_CONNECTION_VALUE,
                    NULL,
                    &ValueType,                  // not used
                    (LPBYTE) &fRestoreConnection,
                    &Temp) == NO_ERROR )
            {
                if ( !fRestoreConnection )
                {
                    MPR_LOG0(RESTORE, "Registry says NOT to restore connections\n");
                    RegCloseKey( providerKeyHandle );
                    return WN_SUCCESS;
                }
            }

            DWORD fDeferConnection;

            if (MprGetKeyDwordValue(
                    providerKeyHandle,
                    DEFER_CONNECTION_VALUE,
                    &fDeferConnection) &&
                fDeferConnection == 0 )
            {
                MPR_LOG0(RESTORE, "Registry says NOT to defer restored connections\n");
                DontDefer = TRUE;
            }

            RegCloseKey( providerKeyHandle );
        }
    }

    __try {
        if (lpDevice != NULL)
        {
            if (MprDeviceType (lpDevice) != REDIR_DEVICE)
            {
                status = WN_BAD_LOCALNAME;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG (ERROR, "WNetRestoreConnectionW:Unexpected Exception 0x%1x\n",status);
        }
        status = WN_BAD_POINTER;
    }
    if (status != WN_SUCCESS)
    {
        SetLastError(status);
        return status;
    }

    //
    // MprCreateConnectionArray may use the providers
    //

    MprCheckProviders();

    {
        CProviderSharedLock    PLock;

        //
        // Read all the connection info from the registry.
        //
        status = MprCreateConnectionArray (&numSubKeys,
                                           lpDevice,
                                           &RegMaxWait,
                                           &ConnectArray);
        if (lpDevice == NULL)
        {
            //
            // only wory about Print if restoring all
            //
            print_connect_status = MprAddPrintersToConnArray (&numSubKeys,
                                                              &ConnectArray);
        }

        //
        // if both failed, report first error. else do the best we can.
        //
        if (status != WN_SUCCESS && print_connect_status != WN_SUCCESS)
        {
            SetLastError (status);
            return status;
        }

        if (numSubKeys == 0)
        {
            return(WN_SUCCESS);
        }

        INIT_IF_NECESSARY(NETWORK_LEVEL,status);

        //
        // If there are no providers, return NO_NETWORK
        //
        if (GlobalNumActiveProviders == 0) {
            SetLastError(WN_NO_NETWORK);
            return(WN_NO_NETWORK);
        }

        //
        // Refcount all the provider DLLs we may use since we may
        // have to call DoProfileErrorDialog, which calls outside
        // mpr.dll and can potentially loop back, causing deadlock.
        // By refcounting here, we don't have to worry about
        // releasing/reacquiring the lock or over-refcounting the
        // provider DLLs later on.
        //

        MprRefcountConnectionArray(ConnectArray, numSubKeys);
    }

    // If lpDevice is not NULL, call MprRestoreThisConnection directly.

    if (lpDevice)
    {
        status = MprRestoreThisConnection (hWnd, NULL, &ConnectArray[0], dwFlags);
        ConnectArray[0].Status = status;
        if ((status != WN_SUCCESS) &&
            (status != WN_CANCEL) &&
            (status != WN_CONTINUE))
        {
            if (!(dwFlags & WNRC_NOUI))
            {
                DoProfileErrorDialog (hWnd,
                                      ConnectArray[0].NetResource.lpLocalName,
                                      ConnectArray[0].NetResource.lpRemoteName,
                                      ConnectArray[0].NetResource.lpProvider,
                                      ConnectArray[0].Status,
                                      FALSE, //No cancel button.
                                      NULL,
                                      NULL,
                                      NULL); // no skip future errors checkbox
            }

            if (pfReconnectFailed)
            {
                *pfReconnectFailed = TRUE;
            }
        }
    }
    else do // not a loop. error break out.
    {
        //
        // Initialize lpParams.
        //
        lpParams = (PARAMETERS *) LocalAlloc (LPTR,
                                              sizeof (PARAMETERS));
        if ((lpParams == NULL) ||
            (lpParams->hDlgCreated
                = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL ||
            (lpParams->hDlgFailed
                = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL ||
            (lpParams->hDonePassword
                = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            status = GetLastError();

            if (lpParams != NULL)
            {
                if (lpParams->hDlgCreated != NULL)
                    CloseHandle(lpParams->hDlgCreated);

                if (lpParams->hDlgFailed != NULL)
                    CloseHandle(lpParams->hDlgFailed);

                if (lpParams->hDonePassword != NULL)
                    CloseHandle(lpParams->hDonePassword);
            }

            break;
        }

        lpParams->numSubKeys     = numSubKeys;
        lpParams->RegMaxWait     = RegMaxWait;
        lpParams->ConnectArray   = ConnectArray;
        lpParams->dwRestoreFlags = dwFlags;
        lpParams->fReconnectFailed = FALSE;

        //
        // Decide whether to show the "Restoring Connections" dialog.
        // In general, if a connection will be made as a user other than the
        // default logged-on user, we need to give the user a chance to enter
        // the password and have it validated, hence we need to contact the
        // server, so we should show the dialog.
        //
        BOOL NeedDialog;

        if (DontDefer)
        {
            NeedDialog = TRUE;
        }
        else
        {
            NeedDialog = FALSE;

            //
            // Get the default user and domain names to connect as
            //
            PUNICODE_STRING UserName;
            PUNICODE_STRING DomainName;
            NTSTATUS ntStatus = LsaGetUserName(&UserName, &DomainName);
            if (NT_SUCCESS(ntStatus))
            {
                MPR_LOG2(RESTORE,"Default domain name = \"%ws\", user name = \"%ws\"\n",
                         DomainName->Buffer, UserName->Buffer);
            }
            else
            {
                MPR_LOG(ERROR, "LsaGetUserName failed, %#lx\n", ntStatus);
                DomainName = NULL;
                UserName = NULL;
            }

            //
            // If the logon domain is the local machine, don't defer connections.
            // This is a NT 4.0 workaround for the most common case of bug 36827.
            // When connecting to an LM server, if the user name happens to
            // match a local user name on the target server, the server will
            // normally attempt to log on using THAT user's account; hence we
            // need to prompt for the password.  We need to do this since this
            // behavior is by design in the redirector.
            //
            WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
            DWORD nSize = LENGTH(ComputerName);
            if (DomainName == NULL ||
                GetComputerName(ComputerName, &nSize) == FALSE ||
                _wcsicmp(ComputerName, DomainName->Buffer) == 0)
            {
                MPR_LOG0(RESTORE, "Local logon, will not defer connections\n");
                NeedDialog = TRUE;
            }
            else
            {
                //
                // Prescan  the connections to determine which ones we can
                // defer and whether we need the reconnect dialog. If all
                // connections are deferred, we do not bother with the dialog.
                //
                for (DWORD i = 0; i < numSubKeys; i++)
                {
                    if (! ConnectArray[i].ContinueFlag)
                    {
                        continue;
                    }

                    //
                    // The DEFER_UNKNOWN flag means don't defer the connection
                    // on this logon, but try the default credentials and see
                    // if they work; if so, the connection can be deferred at
                    // subsequent logons.
                    //
                    // Don't defer the connection if a password was explicitly
                    // specified when the connection was made.  This covers
                    // cases in which the redir won't send the default password
                    // to the server at connect time because the server doesn't
                    // support encrypted passwords.
                    //
                    if (! (ConnectArray[i].DeferFlags & DEFER_UNKNOWN)
                         &&
                        ! (ConnectArray[i].DeferFlags & DEFER_EXPLICIT_PASSWORD)
                         &&
                        MprUserNameMatch(DomainName,
                                         UserName,
                                         ConnectArray[i].UserName,
                                         FALSE))
                    {
                        //
                        // If the user name is the default user name, we can safely
                        // replace it with a NULL.  (This is not only more optimal, but
                        // also required in order to work around a LM redir problem
                        // with the way credentials for deferred connections are stored.)
                        //
                        LocalFree(ConnectArray[i].UserName);
                        ConnectArray[i].UserName = NULL;

                        //
                        // It's OK to defer the connection iff the remembered user
                        // name matches the default user name and the provider
                        // supports deferred connections.
                        //
                        if ((ConnectArray[i].dwConnectCaps & WNNC_CON_DEFER)
                              &&
                            (ConnectArray[i].pfAddConnection3 != NULL))
                        {
                            //
                            // Defer was initialized to 0 when the array was
                            // allocated.
                            // Note that we don't defer if an lpDevice was supplied.
                            //
                            ConnectArray[i].Defer = TRUE;
                        }
                    }

                    if (! ConnectArray[i].Defer)
                    {
                        NeedDialog = TRUE;
                    }
                } // for each connection

                MprSortConnectionArray(ConnectArray, numSubKeys);
            }

            if (DomainName != NULL)
            {
                LsaFreeMemory(DomainName->Buffer);
                LsaFreeMemory(DomainName);
            }
            if (UserName != NULL)
            {
                LsaFreeMemory(UserName->Buffer);
                LsaFreeMemory(UserName);
            }
        }


        //
        // If we are:
        // USING DIALOGS WHEN RESTORING CONNECTIONS...
        //
        // This main thread will used to service a windows event loop
        // by calling ShowReconnectDialog.  Therefore, a new thread
        // must be created to actually restore the connections.  As we
        // attempt to restore each connection, a message is posted in
        // this event loop that causes it to put up a dialog that
        // describes the connection and has a "cancel" option.
        //

        if (! NeedDialog)
        {
            lpParams->hDlg = INVALID_WINDOW_HANDLE;
            // CODEWORK: We are using this INVALID_WINDOW_HANDLE to tell
            // the various routines whether there are 2 threads or not.
            // Instead we should add a new field, BOOL fSeparateThread,
            // to PARAMETERS.  This requires changing routines in mprui.dll
            // as well as mpr.dll.

            DoRestoreConnection(lpParams);
        }
        else
        {
            HANDLE hThreadToken;

            // If the main thread is impersonating, we have to copy its token to
            // the new thread that is being spawned so it runs in the correct context

            if (!OpenThreadToken (GetCurrentThread(),
                                  TOKEN_IMPERSONATE,
                                  TRUE,
                                  &hThreadToken)
                &&
                !OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_IMPERSONATE,
                                  &hThreadToken))
            {
                    //
                    // Couldn't open a token on the thread or the process
                    //
                    status = GetLastError();
            }
            else
            {
                // lpParams->hDlg was initialized to 0 by LocalAlloc
                // and will be set to an HWND by ShowReconnectDialog

                hThread = CreateThread (NULL,
                                        0,
                                        (LPTHREAD_START_ROUTINE) &DoRestoreConnection,
                                        (LPVOID) lpParams,
                                        CREATE_SUSPENDED,
                                        (LPDWORD) &ThreadID);
                if (hThread == NULL)
                {
                    status = GetLastError();
                }
                else
                {
                    //
                    // Make sure the worker thread isn't killed if
                    // this thread finishes while it's wedged in a
                    // provider call (in MprRestoreThisConnection).
                    // The DLL is unloaded by DoRestoreConnection
                    //
                    lpParams->hDll = LoadLibraryEx( L"mpr.dll",
                                                    NULL,
                                                    LOAD_WITH_ALTERED_SEARCH_PATH );

                    if (lpParams->hDll == NULL) {

                        MPR_LOG1(RESTORE,
                                 "LoadLibraryEx for mpr.dll FAILED %d\n",
                                 GetLastError());

                        //
                        // This shouldn't happen since all we're
                        // doing is upping our refcount
                        //
                        ASSERT(FALSE);
                    }

                    //
                    // Assign the impersonation token to the
                    // thread and resume/start it
                    //

                    if (!SetThreadToken(&hThread, hThreadToken))
                    {
                        status = GetLastError();
                        TerminateThread(hThread, NO_ERROR);
                        CloseHandle(hThread);
                    }
                    else
                    {
                        ResumeThread(hThread);
                        CloseHandle(hThread);

                        status = ShowReconnectDialog(hWnd, lpParams);
                    }

                    if (status == WN_SUCCESS && lpParams->status != WN_CANCEL &&
                        lpParams->status != WN_SUCCESS )
                    {
                        SetLastError (lpParams->status);
                    }

                    if (lpParams->status != WN_CANCEL)
                    {
                        status = MprNotifyErrors (hWnd, ConnectArray, numSubKeys, dwFlags);
                    }
                }

                CloseHandle(hThreadToken);
            }
        }

        //
        // Only if we make it to the end of the do-while loop do the thread
        // parameters have to be cleaned up.  Since either this thread or
        // the worker thread might exit first (if the user hits Cancel and
        // the worker thread is stuck in a provider call, this thread could
        // exit first), the InterlockedExchange calls here and at the end
        // of DoRestoreConnection ensure that the last thread leaving
        // does the cleanup.
        //
        // NOTE:  This relies on the fact that the only break out of
        //        this do-while occurs when LocalAlloc for lpParams FAILS.
        //        Adding new break statements may break this logic!
        //
        //
        // Case 1:  lpParams never gets allocated -- this bit of code
        //          never gets hit since we break out of the loop above
        //          and nobody cleans up (correctly)
        //
        // Case 2:  CreateThread fails -- hThread is NULL, so this thread
        //          needs to clean up
        //
        //          (CODEWORK -- should this thread call DoRestoreConnection
        //           directly in that case?)
        //
        // Case 3:  The worker thread exits first -- it changes fDoCleanup
        //          to TRUE before it exits and this thread cleans up
        //
        // Case 4:  This thread exits first (user cancels dialog) -- this
        //          thread changes fDoCleanup to TRUE and orphans the
        //          worker thread.  When it finishes its provider call,
        //          it reads fDoCleanup and cleans up.
        //

        // Poll the worker thread's data to see if reconnect failed.
        if (pfReconnectFailed)
        {
            *pfReconnectFailed = lpParams->fReconnectFailed;
        }

        fDoCleanup = (InterlockedExchange(&lpParams->fDoCleanup, TRUE)
                       ||
                      hThread == NULL);

    } while (FALSE);

    //
    // Is this thread supposed to clean up?
    //
    if (fDoCleanup)
    {
        MPR_LOG0(RESTORE, "Main thread will perform cleanup\n");

        ASSERT(lpParams != NULL);

        //
        // Free up resources in preparation to return.
        //
        if (!CloseHandle(lpParams->hDlgCreated))
            status = GetLastError();

        if (!CloseHandle(lpParams->hDlgFailed))
            status = GetLastError();

        if (!CloseHandle(lpParams->hDonePassword))
            status = GetLastError();

        LocalFree(lpParams);

        MprFreeConnectionArray(ConnectArray, numSubKeys);
    }

    // Send a notification about the new network drive(s).
    if( (g_LUIDDeviceMapsEnabled == TRUE) && (lpDevice != NULL))
    {
        // Use LUID broadcast mechanism
        MprBroadcastDriveChange(
            lpDevice,
            FALSE );    // not a Delete Message
    }
    else
    {
        MprNotifyShell(L" :");
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}


VOID
MprSortConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubKeys
    )
/*++

Routine Description:

    This function sorts the array of connections by placing the
    connections that can be deferred before those that can't

Arguments:

    lpcConnectArray -- The array of CONNECTION_INFO structures

    dwNumSubKeys -- The number of structures in the array

Notes:

    This sort is done to improve behavior at boot.  Deferred connections are
    faster and less error-prone than non-deferred connections and errors can
    cause popups that allow the user to stop reconnecting drives, which leaves
    the remaining drives in the annoying "Unavailable" state.  Note that most
    popups for drive reconnection at boot are for credentials, which is a popup
    associated only with non-deferred connection.  By reconnecting deferred
    connections first, we avoid this problem.

--*/
{
    INT   nLow     = 0;
    INT   nHigh    = dwNumSubKeys - 1;
    BOOL  fSwap;

    CONNECTION_INFO ciTemp;

    do {

        //
        // Find the first non-deferred connection
        //
        while (nLow < (INT)dwNumSubKeys
               &&
               lpcConnectArray[nLow].Defer) {

            nLow++;
        }

        //
        // Find the last deferred connection
        //
        while (nHigh >= 0
               &&
               !lpcConnectArray[nHigh].Defer) {

            nHigh--;
        }

        fSwap = (nLow < nHigh);

        //
        // Only swap if the pointers haven't crossed
        // (otherwise we'd be undoing the sorting)
        //
        if (fSwap) {

            ciTemp = lpcConnectArray[nLow];
            lpcConnectArray[nLow++]  = lpcConnectArray[nHigh];
            lpcConnectArray[nHigh--] = ciTemp;
        }
    }
    while (fSwap);

#if DBG

    MPR_LOG0(RESTORE, "Order of sorted connection array is as follows:\n");

    for (UINT i = 0; i < dwNumSubKeys; i++) {

        MPR_LOG3(RESTORE,
                 "\tLocal: %ws, \tRemote: %ws, \tDefer: %d\n",
                 lpcConnectArray[i].NetResource.lpLocalName,
                 lpcConnectArray[i].NetResource.lpRemoteName,
                 lpcConnectArray[i].Defer);
    }

#endif // DBG

}


VOID
MprRefcountConnectionArray(
    LPCONNECTION_INFO lpcConnectArray,
    DWORD             dwNumSubkeys
    )

/*++

Routine Description:

    This function sorts refcounts the provider DLLs in the array
    of connections in preparation for a call outside of mpr.dll
    (which requires releasing the provider lock to avoid the
    possibility of reentrancy and deadlock)

Arguments:

    lpcConnectArray -- The array of CONNECTION_INFO structures

    dwNumSubKeys -- The number of structures in the array

Notes:


--*/
{
    UINT       i;
    LPPROVIDER lpProvider;

    ASSERT_INITIALIZED(NETWORK);

    for (i = 0; i < dwNumSubkeys; i++)
    {
        //
        // If this hits, we're over-refcounting
        //
        ASSERT(lpcConnectArray[i].hProviderDll == NULL);

        lpProvider = &GlobalProviderInfo[lpcConnectArray[i].ProviderIndex];

        lpcConnectArray[i].hProviderDll = LoadLibraryEx(lpProvider->DllName,
                                                        NULL,
                                                        LOAD_WITH_ALTERED_SEARCH_PATH);

        if (lpcConnectArray[i].hProviderDll != NULL)
        {
            lpcConnectArray[i].pfGetCaps          = lpProvider->GetCaps;
            lpcConnectArray[i].pfAddConnection3   = lpProvider->AddConnection3;
            lpcConnectArray[i].pfAddConnection    = lpProvider->AddConnection;
            lpcConnectArray[i].pfCancelConnection = lpProvider->CancelConnection;
            lpcConnectArray[i].dwConnectCaps      = lpProvider->ConnectCaps;
        }
        else
        {
            MPR_LOG2(ERROR,
                     "MprRefcountConnectionArray: LoadLibraryEx on %ws failed %d\n",
                     lpProvider->DllName,
                     GetLastError());
        }
    }
}



DWORD
WNetSetConnectionW(
    IN  LPCWSTR lpName,
    IN  DWORD   dwProperty,
    IN  LPVOID  pvValue
    )

/*++

Routine Description:

    This function changes the characteristics of a network connection.

Arguments:

    lpName - The name of either the redirected local device or a remote
        network resource.

    dwProperty - Identifies the property to be changed.
        Current properties supported:
        NETPROPERTY_PERSISTENT - pvValue points to a DWORD.  If TRUE,
            the connection is made persistent.  If FALSE, the connection
            is made non-persistent.

    pvValue - Pointer to the property value.  Type depends on dwProperty.

Return Value:

    WN_SUCCESS - successful

    WN_BAD_LOCALNAME or WN_NOT_CONNECTED - lpName is not a redirected device

--*/
{
    DWORD status = WN_SUCCESS;

    if (!(ARGUMENT_PRESENT(lpName) &&
          ARGUMENT_PRESENT(pvValue)))
    {
        SetLastError(WN_BAD_POINTER);
        return(WN_BAD_POINTER);
    }

    // NPGetUser and some Mpr internal functions use lpName as a non-const
    // argument, so we have to make a copy
    WCHAR * lpNameCopy = (WCHAR *) LocalAlloc(LMEM_FIXED, WCSSIZE(lpName));
    if (lpNameCopy == NULL)
    {
        SetLastError(WN_OUT_OF_MEMORY);
        return(WN_OUT_OF_MEMORY);
    }
    wcscpy(lpNameCopy, lpName);

    switch (dwProperty)
    {
        case NETPROPERTY_PERSISTENT:
        {
            MprCheckProviders();

            CProviderSharedLock    PLock;

            __try
            {
                //
                // Value should be a boolean DWORD telling whether to
                // remember or forget the connection
                //
                BOOL bRemember = * ((DWORD *) pvValue);

                //
                // Verify that lpName is a redirected local device, and
                // identify the provider responsible
                //
                WCHAR wszRemoteName[MAX_PATH+1];
                DWORD cbBuffer = sizeof(wszRemoteName);
                DWORD iProvider;                    // provider index

                status = MprGetConnection(
                                    lpName,
                                    wszRemoteName,
                                    &cbBuffer,
                                    &iProvider);

                if (status == WN_CONNECTION_CLOSED)
                {
                    //
                    // It's already a remembered connection.  Nothing to do.
                    //
                    status = WN_SUCCESS;
                    __leave;
                }

                if (status != WN_SUCCESS)
                {
                    ASSERT(status != WN_MORE_DATA);
                    __leave;
                }

                if (bRemember)
                {
                    //
                    // Get the username for the connection from the provider
                    //
                    WCHAR wszUser[MAX_PATH+1];
                    cbBuffer = LENGTH(wszUser);
                    status = GlobalProviderInfo[iProvider].GetUser(
                                            lpNameCopy, wszUser, &cbBuffer);

                    if (status != WN_SUCCESS)
                    {
                        ASSERT(status != WN_MORE_DATA);
                        __leave;
                    }

                    //
                    // Get the provider flags, if any
                    //
                    ASSERT_INITIALIZED(NETWORK);

                    BYTE ProviderFlags = 0;
                    if (GlobalProviderInfo[iProvider].GetReconnectFlags != NULL)
                    {
                        // This is an internal entry point so we don't bother with
                        // try-except
                        DWORD status2 = GlobalProviderInfo[iProvider].GetReconnectFlags(
                                                    lpNameCopy,
                                                    &ProviderFlags
                                                    );
                        if (status2 != WN_SUCCESS)
                        {
                            ProviderFlags = 0;
                        }
                        MPR_LOG3(RESTORE, "%ws wants flags %#x saved for %ws\n",
                                    GlobalProviderInfo[iProvider].Resource.lpProvider,
                                    ProviderFlags,
                                    lpNameCopy);
                    }

                    //
                    // Make the connection persistent
                    //
                    status = I_MprSaveConn(
                                HKEY_CURRENT_USER,
                                GlobalProviderInfo[iProvider].Resource.lpProvider,
                                GlobalProviderInfo[iProvider].Type,
                                wszUser,
                                lpNameCopy,
                                wszRemoteName,
                                (wcslen(lpName) == 2 && lpName[1] == L':')
                                    ? RESOURCETYPE_DISK
                                    : RESOURCETYPE_PRINT,
                                ProviderFlags,
                                DEFER_UNKNOWN
                                );
                }
                else
                {
                    //
                    // Make the connection non-persistent
                    //
                    MprForgetRedirConnection(lpNameCopy);
                    status = WN_SUCCESS;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                status = WN_BAD_POINTER;
            }

            break;
        }

        default:
            status = WN_BAD_VALUE;
    }

    LocalFree(lpNameCopy);

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }

    return status;
}



typedef LRESULT WINAPI FN_PostMessage( HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam) ;
#ifdef UNICODE
  #define USER32_DLL_NAME L"user32.dll"
  #define POST_MSG_API_NAME "PostMessageW"
#else
  #define USER32_DLL_NAME "user32.dll"
  #define POST_MSG_API_NAME "PostMessageA"
#endif

static HMODULE _static_hUser32 = NULL;
static FN_PostMessage * _static_pfPostMsg = NULL;


VOID
DoRestoreConnection(
    PARAMETERS *Params
    )

/*++

Routine Description:

    This function is run as a separate thread from the main thread (which
    services a windows event loop).  It attempts to restore all connections
    that were saved in the registry for this user.

    For each connection that we try to restore, a message is posted to
    the main thread that causes it to put up a dialog box which describes
    the connection and allows the user the option of cancelling.

    If a longer timeout than the default is desired,  this function will
    look in the following location in the registry for a timeout value:

    \HKEY_LOCAL_MACHINE\system\CurrentControlSet\Control\NetworkProvider
        RestoreTimeout = REG_DWORD  ??
--*/
{
    DWORD               status = WN_SUCCESS;
    DWORD               providerIndex=0;
    DWORD               Temp;
    DWORD               numSubKeys = Params->numSubKeys;
    DWORD               MaxWait = 0;    // timeout interval
    DWORD               RegMaxWait = Params->RegMaxWait;   // timeout interval stored in registry.
    DWORD               ElapsedTime;    // interval between start and current time.
    DWORD               CurrentTime;    // Current ClockTick time
    DWORD               StartTime;
    DWORD               i;
    BOOL                UserCancelled = FALSE;
    BOOL                ContinueFlag;
    BOOL                fDisconnect = FALSE;
    LPCONNECTION_INFO   ConnectArray = Params->ConnectArray;
    HANDLE              lpHandles[2];
    DWORD               dwSleepTime = RECONNECT_SLEEP_INCREMENT ;
    DWORD               j;
    DWORD               numStillMustContinue;
    DWORD               dwValue;
    DWORD               RestoredDrivesMask = 0;
    DWORD               CurrDriveMask;
    LPWSTR              lpLocalName;
    WCHAR               DriveLetterName[3];    // "<drive letter>:<NULL>"
    HINSTANCE           hDll = Params->hDll;  // This needs to be checked
                                              // Params is freed

    //
    // Don't check providers here as this isn't a top-level WNet API.
    // No need to grab the shared lock here because the ConnectArray
    // already contains all the entrypoints we need and the provider
    // DLLs have all been refcounted.
    //

    lpHandles[0] = Params->hDlgCreated;
    lpHandles[1] = Params->hDlgFailed;

    StartTime = GetTickCount();

    if (RegMaxWait != 0)
    {
        MaxWait = RegMaxWait;
    }

    if ( _static_pfPostMsg == NULL )
    {
        MprEnterLoadLibCritSect();

        if (_static_hUser32 = LoadLibraryEx(USER32_DLL_NAME,
                                            NULL,
                                            LOAD_WITH_ALTERED_SEARCH_PATH))
        {
            _static_pfPostMsg = (FN_PostMessage *) GetProcAddress( _static_hUser32,
                                                                   POST_MSG_API_NAME );
        }

        MprLeaveLoadLibCritSect();

        if ( _static_pfPostMsg == NULL )
        {
            Params->status = GetLastError();
            goto CleanExit;
        }
    }

    if(Params->hDlg == INVALID_WINDOW_HANDLE)
    {
        dwValue = 0;
    }
    else
    {
        dwValue =  WaitForMultipleObjects (2, lpHandles, FALSE, INFINITE);
    }

    switch(dwValue)
    {
    case 1: // hDlgFailed signaled. Info dialog failed to construct.
        break;

    case 0: // hDlgCreated signaled. Info dialog constructed successfully.

        MPR_LOG0(RESTORE,"Enter Loop where we will attempt to restore connections\n");

        do
        {
            //
            // If HideErrors becomes TRUE, stop displaying error dialogs.
            //
            BOOL fHideErrors = (Params->dwRestoreFlags & WNRC_NOUI) ? TRUE : FALSE;

            //
            // Each time we go through all the connections, we need to
            // reset the continue flag to FALSE.
            //
            ContinueFlag = FALSE;

            //
            // Go through each connection information in the array.
            //
            for (i = 0; i < numSubKeys; i++) {

                // Let dialog thread print out the current connection.
                if(Params->hDlg != INVALID_WINDOW_HANDLE)
                {
                    (*_static_pfPostMsg) (Params->hDlg,
                                 SHOW_CONNECTION,
                                 (WPARAM) ConnectArray[i].NetResource.lpRemoteName,
                                 0);
                }

                //
                // Setting status to SUCCESS forces us down the success path
                // if we are not to continue adding this connection.
                //
                status = WN_SUCCESS;

                if (ConnectArray[i].ContinueFlag)
                {
                    status = MprRestoreThisConnection (NULL,
                                                       Params,
                                                       &(ConnectArray[i]),
                                                       Params->dwRestoreFlags);
                }

                switch (status)
                {
                    case WN_SUCCESS:
                        ConnectArray[i].Status = WN_SUCCESS;
                        ConnectArray[i].ContinueFlag = FALSE;

                        if( g_LUIDDeviceMapsEnabled == TRUE )
                        {
                            lpLocalName = ConnectArray[i].NetResource.lpLocalName;
                            if( lpLocalName != NULL &&
                                wcslen(lpLocalName) == 2 &&
                                lpLocalName[1] == L':' &&
                                iswalpha(lpLocalName[0]) )
                            {
                                DriveLetterName[0] = RtlUpcaseUnicodeChar( lpLocalName[0] );
                                RestoredDrivesMask |= 1<<(DriveLetterName[0] - L'A');
                            }
                        }
                        break;

                    case WN_CONTINUE:
                        break;

                    case WN_NO_NETWORK:
                    case WN_FUNCTION_BUSY:

                        //
                        // If this is the first pass through, we don't have
                        // the wait times figured out for each provider. Do that
                        // now.
                        //

                        if (ConnectArray[i].ProviderWait == 0)
                        {
                            MPR_LOG0(RESTORE,"Ask provider how long it will take "
                            "for the net to come up\n");

                            Temp = ConnectArray[i].pfGetCaps(WNNC_START);

                            MPR_LOG2(RESTORE,"GetCaps(START) for Provider %ws yields %d\n",
                                ConnectArray[i].NetResource.lpProvider,
                                Temp)

                            switch (Temp)
                            {
                            case PROVIDER_WILL_NOT_START:
                                MPR_LOG0(RESTORE,"Provider will not start\n");
                                ConnectArray[i].ContinueFlag = FALSE;
                                ConnectArray[i].Status = status;
                                break;

                            case NO_TIME_ESTIMATE:
                                MPR_LOG0(RESTORE,"Provider doesn't have time estimate\n");

                                if (RegMaxWait != 0) {
                                    ConnectArray[i].ProviderWait = RegMaxWait;
                                }
                                else {
                                    ConnectArray[i].ProviderWait = DEFAULT_WAIT_TIME;
                                }
                                if (MaxWait < ConnectArray[i].ProviderWait) {
                                    MaxWait = ConnectArray[i].ProviderWait;
                                }
                                break;

                            default:
                                MPR_LOG1(RESTORE,"Provider says it will take %d msec\n",
                                Temp);
                                if ((Temp <= MAX_ALLOWED_WAIT_TIME) && (Temp > MaxWait))
                                {
                                    MaxWait = Temp;
                                }
                                ConnectArray[i].ProviderWait = MaxWait;
                                break;
                            }
                        }

                        //
                        // If the status for this provider has just changed to
                        // WN_FUNCTION_BUSY from some other status, then calculate
                        // a timeout time by getting the provider's new timeout
                        // and adding that to the elapsed time since start.  This
                        // gives a total elapsed time until timeout - which can
                        // be compared with the current MaxWait.
                        //
                        if ((status == WN_FUNCTION_BUSY) &&
                            (ConnectArray[i].Status == WN_NO_NETWORK))
                        {
                            Temp = ConnectArray[i].pfGetCaps(WNNC_START);

                            MPR_LOG2(RESTORE,"Changed from NO_NET to BUSY\n"
                                "\tGetCaps(START) for Provider %ws yields %d\n",
                                ConnectArray[i].NetResource.lpProvider,
                                Temp);

                            switch (Temp)
                            {
                            case PROVIDER_WILL_NOT_START:
                                //
                                // This is bizzare to find the status = BUSY,
                                // but to have the Provider not starting.
                                //
                                ConnectArray[i].ContinueFlag = FALSE;
                                break;

                            case NO_TIME_ESTIMATE:
                                //
                                // No need to alter the timeout for this one.
                                //
                                break;

                            default:

                                //
                                // Make sure this new timeout information will take
                                // less than the maximum allowed time from providers.
                                //
                                if (Temp <= MAX_ALLOWED_WAIT_TIME)
                                {
                                    CurrentTime = GetTickCount();

                                    //
                                    // Determine how much time has elapsed since
                                    // we started.
                                    //
                                    ElapsedTime = CurrentTime - StartTime;

                                    //
                                    // Add the Elapsed time to the new timeout we
                                    // just received from the provider to come up
                                    // with a timeout value that can be compared
                                    // with MaxWait.
                                    //
                                    Temp += ElapsedTime;

                                    //
                                    // If the new timeout is larger that MaxWait,
                                    // then use the new timeout.
                                    //
                                    if (Temp > MaxWait)
                                    {
                                        MaxWait = Temp;
                                    }
                                }
                            } // End Switch(Temp)
                        } // End If (change state from NO_NET to BUSY)

                        //
                        // Store the status (either NO_NET or BUSY) with the
                        // connect info.
                        //

                        if (ConnectArray[i].ContinueFlag)
                        {
                            ConnectArray[i].Status = status;
                            break;
                        }

                    case WN_CANCEL:
                        ConnectArray[i].Status = status;
                    default:
                        //
                        // For any other error, call the Error Dialog
                        //

                        Params->fReconnectFailed = TRUE;

                        if (fHideErrors) {
                            fDisconnect = FALSE;
                        } else {
                            //
                            // Count the number of connections which have not
                            // been resolved.  If there is exactly one, do not
                            // give the user the option to cancel.
                            //
                            numStillMustContinue = 0;

                            for (j = 0; j < numSubKeys; j++) {
                                if (ConnectArray[j].ContinueFlag) {
                                    numStillMustContinue++;
                                }
                            }

                            MPR_LOG1(RESTORE,"DoProfileErrorDialog with "
                                        "%d connections remaining\n",
                                        numStillMustContinue);

                            //
                            // We need to bump up the refcount for mprui.dll
                            // here since we're in a separate thread and
                            // WNetRestoreConnectionsW could return with this
                            // UI still up.  If that happens and the process
                            // calls WNetClearConnections, we'll AV as soon as
                            // a message is sent to the UI window since
                            // WNetClearConnections unloads mprui.dll (this can
                            // happen in winlogon.exe).  Note that this function
                            // will load mprui.dll globally if it hasn't already
                            // been done so after the first LoadLibrary call here,
                            // we're merely playing around with the DLL refcount
                            // rather than loading/unloading DLLs every time.
                            //
                            HINSTANCE  hDll = LoadLibraryEx(L"mprui.dll",
                                                            NULL,
                                                            LOAD_WITH_ALTERED_SEARCH_PATH);

                            if (hDll == NULL)
                            {
                                MPR_LOG1(RESTORE,
                                         "WNetRestoreConnectionW: loading mprui.dll failed %d\n",
                                         GetLastError());

                                fDisconnect = FALSE;
                            }
                            else
                            {
                                DoProfileErrorDialog(
                                    Params->hDlg == INVALID_WINDOW_HANDLE ?
                                        NULL : Params->hDlg,
                                    ConnectArray[i].NetResource.lpLocalName,
                                    ConnectArray[i].NetResource.lpRemoteName,
                                    ConnectArray[i].NetResource.lpProvider,
                                    status,
                                    (Params->hDlg != INVALID_WINDOW_HANDLE) &&
                                        (numStillMustContinue > 1),
                                    &UserCancelled,
                                    &fDisconnect,
                                    &fHideErrors);

                                FreeLibrary(hDll);
                            }
                        }

                        if (fDisconnect)
                        {
                            if (ConnectArray[i].NetResource.lpLocalName)
                            {
                                status = ConnectArray[i].pfCancelConnection(
                                            ConnectArray[i].NetResource.lpLocalName,
                                            TRUE);
                            }
                            else
                            {
                                status =
                                    MprForgetPrintConnection(
                                        ConnectArray[i].NetResource.lpRemoteName) ;
                            }
                        }

                        ConnectArray[i].ContinueFlag = FALSE;
                        break;
                    } // end switch(status)

                ContinueFlag |= ConnectArray[i].ContinueFlag;

                //
                // If the User cancelled all further connection restoration
                // work, then leave this loop.
                //
                if (UserCancelled)
                {
                    status = WN_CANCEL;
                    ContinueFlag = FALSE;
                    break;
                }

            } // end For each connection.

            if (ContinueFlag)
            {
                //
                // Determine what the elapsed time from the start is.
                //
                CurrentTime = GetTickCount();
                ElapsedTime = CurrentTime - StartTime;

                //
                // If a timeout occured, then don't continue.  Otherwise, sleep for
                // a bit and loop again through all connections.
                //
                if (ElapsedTime > MaxWait)
                {
                    MPR_LOG0(RESTORE,"WNetRestoreConnectionW: Timed out while restoring\n");
                    ContinueFlag = FALSE;
                    status = WN_SUCCESS;
                }
                else
                {
                    Sleep(dwSleepTime);

                    //
                    // increase sleeptime as we loop, but cap at 4 times
                    // the increment (currently that is 4 * 3 secs = 12 secs)
                    //
                    if (dwSleepTime < (RECONNECT_SLEEP_INCREMENT * 4))
                    {
                        dwSleepTime += RECONNECT_SLEEP_INCREMENT ;
                    }
                }
            }

        } while (ContinueFlag);
        break;

    default:
        status = GetLastError();
    }

    Params->status = status;
    if(Params->hDlg != INVALID_WINDOW_HANDLE)
    {
        (*_static_pfPostMsg) (Params->hDlg, WM_QUIT, 0, 0);
    }


CleanExit:

    //
    // Is this thread supposed to clean up?
    //
    if (InterlockedExchange(&Params->fDoCleanup, TRUE))
    {
        MPR_LOG0(RESTORE, "Worker thread will perform cleanup\n");

        ASSERT(Params != NULL);

        //
        // Free up resources in preparation to return.
        //

        //
        // If LUID device maps are enabled and we restored drive letter
        // connections, then notify the shell about each restored drive
        // letter connection.
        //
        if( (g_LUIDDeviceMapsEnabled == TRUE) &&
            (RestoredDrivesMask != 0) )
        {
            CurrDriveMask = 1;
            DriveLetterName[1] = L':';
            DriveLetterName[2] = UNICODE_NULL;

            for( DriveLetterName[0] = L'A';
                 DriveLetterName[0] <= L'Z';
                 DriveLetterName[0]++, CurrDriveMask <<= 1 )
            {
                if( CurrDriveMask & RestoredDrivesMask )
                {
                    // Use the LUID broadcast mechanism
                    MprBroadcastDriveChange(
                        DriveLetterName,
                        FALSE );    // not a Delete Message
                }
            }
        }

        if (!CloseHandle(Params->hDlgCreated))
            status = GetLastError();

        if (!CloseHandle(Params->hDlgFailed))
            status = GetLastError();

        if (!CloseHandle(Params->hDonePassword))
            status = GetLastError();

        MprFreeConnectionArray(Params->ConnectArray, numSubKeys);

        LocalFree(Params);
    }

    if (hDll != NULL)
    {
        //
        // We have an HINSTANCE, so we're running in a
        // separate thread
        //

        FreeLibraryAndExitThread(hDll, 0);
    }

    return;
}



BOOL
MprUserNameMatch (
    IN  PUNICODE_STRING DomainName,
    IN  PUNICODE_STRING UserName,
    IN  LPCWSTR         RememberedName,
    IN  BOOL            fMustMatchCompletely
    )

/*++

Routine Description:

    This function tests whether the user name for a remembered connection
    matches the default user name.

Arguments:

    DomainName - default logon domain

    UserName - default logon user

    RememberedName - user name remembered for the connection

Return Value:

    TRUE if the name matches, FALSE otherwise.

--*/
{
    if (IS_EMPTY_STRING(RememberedName))
    {
        return TRUE;
    }

    if (DomainName == NULL || UserName == NULL)
    {
        // This can happen if the LsaGetUserName call fails
        return FALSE;
    }

    //
    // If the remembered name is in the form "domain\user", we must compare
    // against the full user name; otherwise, it's sufficient to compare
    // against the unqualified user name
    //
    WCHAR * pSlash = wcschr(RememberedName, L'\\');
    if (pSlash)
    {
        // Compare user name portion
        UNICODE_STRING RememberedUserName;
        RtlInitUnicodeString(&RememberedUserName, pSlash+1);
        if (! RtlEqualUnicodeString(&RememberedUserName, UserName, TRUE))
        {
            return FALSE;
        }

        // Compare domain name portion
        *pSlash = L'\0';
        UNICODE_STRING RememberedDomainName;
        RtlInitUnicodeString(&RememberedDomainName, RememberedName);
        BOOL fMatch = RtlEqualUnicodeString(&RememberedDomainName, DomainName, TRUE);
        *pSlash = L'\\';
        return fMatch;
    }
    else if (fMustMatchCompletely)
    {
        //
        // A complete match is required but there's no domain in RememberedName
        //
        return FALSE;
    }
    else
    {
        UNICODE_STRING RememberedUserName;
        RtlInitUnicodeString(&RememberedUserName, RememberedName);
        return (RtlEqualUnicodeString(&RememberedUserName, UserName, TRUE));
    }
}

DWORD
MprRestoreThisConnection(
    HWND                hWnd,
    PARAMETERS          *Params,
    LPCONNECTION_INFO   ConnectInfo,
    DWORD               dwFlags
    )

/*++

Routine Description:

    This function attempts to add a single connection specified in the
    ConnectInfo.

Arguments:

    Params -

    ConnectInfo - This is a pointer to a connection info structure which
        contains all the information necessary to restore a network
        connection.

Return Value:

    returns whatever the providers AddConnection function returns.

--*/
{
    DWORD           status;
    LPTSTR          password=NULL;
    HANDLE          lpHandle;
    BOOL            fDidCancel;
    TCHAR           passwordBuffer[PWLEN+1] = {0};
    LPWSTR          UserNameForProvider;
    BOOLEAN         BufferAllocated = FALSE;


    MPR_LOG3(RESTORE,
        "Doing MprRestoreThisConnection for %ws, username = %ws, defer = %lu...\n",
        ConnectInfo->NetResource.lpRemoteName,
        ConnectInfo->UserName,
        ConnectInfo->Defer);

    //
    // Pass the provider NULL as the user name on the first pass
    //  if the original connection used default creds.
    //

    if ( ConnectInfo->DeferFlags & DEFER_DEFAULT_CRED ) {
        UserNameForProvider = NULL;
    } else {
        UserNameForProvider = ConnectInfo->UserName;
    }

    //
    // Loop until we either have a successful connection, or
    // until the user stops attempting to give a proper
    // password.
    //
    do {

        if (Params && Params->status == WN_CANCEL)
        {
            //
            // User cancelled out on reconnections -- return
            // WN_SUCCESS to let DoRestoreConnection finish
            //
            return WN_SUCCESS;
        }

        //
        // Attempt to add the connection.
        // NOTE:  The initial password is NULL.
        //

#if DBG == 1
        DWORD ConnectTime = GetTickCount();
#endif

        //**************************************
        // Actual call to Provider
        //**************************************

        if (ConnectInfo->Defer)
        {
            ASSERT(ConnectInfo->pfAddConnection3 != NULL);

            status = ConnectInfo->pfAddConnection3(
                        NULL,                           // hwndOwner
                        &(ConnectInfo->NetResource),    // lpNetResource
                        password,                       // lpPassword
                        UserNameForProvider,            // lpUserName
                        CONNECT_DEFERRED | (ConnectInfo->ProviderFlags << 24)
                        );                              // dwFlags
        }
        else if (ConnectInfo->pfAddConnection != NULL)
        {
            status = ConnectInfo->pfAddConnection(
                        &(ConnectInfo->NetResource),    // lpNetResource
                        password,                       // lpPassword
                        UserNameForProvider );          // lpUserName
        }
        else
        {
            status = WN_NOT_SUPPORTED;
        }

#if DBG == 1
        ConnectTime = GetTickCount() - ConnectTime;
        MPR_LOG2(RESTORE, "...provider took %lu ms to return status %lu\n",
                     ConnectTime, status);
        if (ConnectInfo->Defer && ConnectTime > 100)
        {
            DbgPrint("[MPR] ------ %ws took %lu ms to restore a DEFERRED\n"
                     "             connection to %ws !\n",
                     ConnectInfo->NetResource.lpProvider, ConnectTime,
                     ConnectInfo->NetResource.lpRemoteName);
        }
#endif

        if (status == WN_CONNECTED_OTHER_PASSWORD_DEFAULT)
        {
            //
            // Provider reconnected using default creds
            //

            status = WN_SUCCESS;
        }

        //
        // If that fails due to a bad password, then
        // loop until we either have a successful connection, or until
        // the user stops attempting to give a proper password.
        //

        if (CREDUI_IS_AUTHENTICATION_ERROR(status))
        {
            //
            // The password needs to be cleared each time around the loop,
            // so that on subsequent add connections, we go back to the
            // logon password.
            //
            password = NULL;

            //
            // If failure was due to bad password, then attempt
            // to get a new password from the user.
            //

            // Changes made by congpay because of another thread.

            if (Params == NULL)  //lpDevice != NULL, restoring ONE
            {
                if (!(dwFlags & WNRC_NOUI))
                {
                    //
                    // We need a username buffer to prompt for a username
                    //

                    if ( ConnectInfo->UserName == NULL ) {
                        ConnectInfo->UserName = (LPTSTR)LocalAlloc(LMEM_FIXED, CRED_MAX_USERNAME_LENGTH * sizeof(WCHAR));

                        if ( ConnectInfo->UserName == NULL ) {
                            status = ERROR_NOT_ENOUGH_MEMORY;
                            SetLastError (status);
                            memset(passwordBuffer, 0, sizeof(passwordBuffer)) ;
                            return status;
                        } else {
                            ConnectInfo->UserName[0] = L'\0';
                            BufferAllocated = TRUE;
                        }
                    }

                    //
                    // Prompt for a username
                    //

                    status = DoPasswordDialog(hWnd,
                                              ConnectInfo->NetResource.lpRemoteName,
                                              ConnectInfo->UserName,
                                              passwordBuffer,
                                              sizeof (passwordBuffer),
                                              &fDidCancel,
                                              status);

                    //
                    // Convert zero length username to NULL buffer
                    //

                    if ( BufferAllocated && status == NO_ERROR ) {
                        //
                        // If there is no user name (the length is 0), then set the
                        // return pointer to NULL.
                        //
                        if (STRLEN(ConnectInfo->UserName) == 0) {
                            LocalFree(ConnectInfo->UserName);
                            ConnectInfo->UserName = NULL;
                            BufferAllocated = FALSE;
                        }
                    }
                }

                if (status != WN_SUCCESS)
                {
                    SetLastError (status);
                    memset(passwordBuffer, 0, sizeof(passwordBuffer)) ;
                    return status;
                }
                else
                {
                    if (fDidCancel)
                    {
                        status = WN_CANCEL;
                    }
                    else
                    {
                        password = passwordBuffer;
                        status = WN_ACCESS_DENIED;
                    }
                }
            }
            else   // restoring all
            {
                if (!(Params->dwRestoreFlags & WNRC_NOUI))
                {
                    if (Params->status == WN_CANCEL)
                    {
                        //
                        // User cancelled out of restoring connections.  Return
                        // WN_SUCCESS to let DoRestoreConnection finish looping
                        //

                        continue;
                    }

                    if ( _static_pfPostMsg == NULL ) {

                        MprEnterLoadLibCritSect();
                        if ( _static_hUser32 = LoadLibraryEx(
                                                    USER32_DLL_NAME,
                                                    NULL,
                                                    LOAD_WITH_ALTERED_SEARCH_PATH ) ) {
                            _static_pfPostMsg = (FN_PostMessage *) GetProcAddress( _static_hUser32,
                                                               POST_MSG_API_NAME );
                        }
                        MprLeaveLoadLibCritSect();
                        if ( _static_pfPostMsg == NULL ) {
                            memset(passwordBuffer, 0, sizeof(passwordBuffer)) ;
                            return GetLastError();
                        }

                    }
                    lpHandle = Params->hDonePassword;

                    Params->pchResource = ConnectInfo->NetResource.lpRemoteName;
                    Params->pchUserName = ConnectInfo->UserName;
                    Params->dwError     = status;

                    if ((Params->hDlg == INVALID_WINDOW_HANDLE)
                         ||
                        ((*_static_pfPostMsg)
                             (Params->hDlg,
                             DO_PASSWORD_DIALOG,
                             (WPARAM) Params,
                             0) == 0))
                    {
                        //
                        // Either we're not using a credential dialog or the
                        // PostMessage call failed -- bail.
                        //
                        MPR_LOG3(ERROR,
                                 "%ws returned %d for connection to %ws -- bailing\n",
                                 ConnectInfo->NetResource.lpProvider,
                                 status,
                                 ConnectInfo->NetResource.lpRemoteName);

                        goto CredentialError;
                    }

                    WaitForSingleObject ( lpHandle, INFINITE );

                    if (Params->status == WN_SUCCESS)
                    {
                        if (Params->fDidCancel)
                        {
                            status = WN_CANCEL;
                        }
                        else
                        {
                            password = Params->passwordBuffer;
                        }
                    }
                    else
                    {
                        status = Params->status;
                    }
                }
                else
                {
                    // Caller wants no UI - don't show any
                    status = WN_CANCEL;

                    // Remember that we had a failure to reconnect
                    Params->fReconnectFailed = TRUE;
                }
            }
        }
        else if (status == WN_SUCCESS)
        {
            DWORD  dwIgnoredStatus;

            MPR_LOG1(RESTORE,"MprRestoreThisConnection: Successful "
                "restore of connection for %ws\n",
                ConnectInfo->NetResource.lpRemoteName);

            //
            // Username for the connection might have changed via the
            // password dialog -- update it.
            //

            dwIgnoredStatus = MprSetRegValue(ConnectInfo->RegKey,
                                             USER_NAME,
                                             ConnectInfo->UserName,
                                             0);

            if (dwIgnoredStatus != ERROR_SUCCESS)
            {
                MPR_LOG(ERROR,
                        "MprSetRegValue for user name failed %lu\n",
                        dwIgnoredStatus);
            }

            //
            // If the DEFER_UNKNOWN flag was set, we can clear it now.
            // If the default password worked, we know that we can defer the
            // connection in future.  If we had to prompt for a password, we
            // can't defer the connection in future.
            // Note: This may not do the right thing for share-level
            // connections where the level of access depends on the password.
            // But we'll let users fix that by manually recreating the
            // connection.
            //
            if (ConnectInfo->DeferFlags & DEFER_UNKNOWN)
            {
                if (password == NULL)
                {
                    ConnectInfo->DeferFlags &=
                        ~(DEFER_UNKNOWN | DEFER_EXPLICIT_PASSWORD);
                    MPR_LOG1(RESTORE,"MprRestoreThisConnection: WILL defer "
                        "connection for %ws in future\n",
                        ConnectInfo->NetResource.lpRemoteName);
                }
                else
                {
                    ConnectInfo->DeferFlags &= ~DEFER_UNKNOWN;
                    ConnectInfo->DeferFlags |= DEFER_EXPLICIT_PASSWORD;
                    MPR_LOG1(RESTORE,"MprRestoreThisConnection: will NOT defer "
                        "connection for %ws in future\n",
                        ConnectInfo->NetResource.lpRemoteName);
                }

                dwIgnoredStatus = MprSaveDeferFlags(ConnectInfo->RegKey,
                                                    ConnectInfo->DeferFlags);

                if (dwIgnoredStatus != ERROR_SUCCESS)
                {
                    MPR_LOG(ERROR, "MprSaveDeferFlags failed %lu\n", dwIgnoredStatus);
                }
            }
        }
        else
        {
            //
            // An unexpected error occured.  In this case,
            // we want to leave the loop.
            //

            MPR_LOG2(ERROR,
                     "MprRestoreThisConnection: AddConnection for (%ws) Error %d \n",
                     ConnectInfo->NetResource.lpProvider,
                     status);

            break;
        }

        //
        // On subsequent iterations,
        //  pass the provider the user name typed by the caller.
        //

        UserNameForProvider = ConnectInfo->UserName;

    }
    while (CREDUI_IS_AUTHENTICATION_ERROR(status));

CredentialError:

    memset(passwordBuffer, 0, sizeof(passwordBuffer)) ;
    return status;
}


DWORD
MprCreateConnectionArray(
    LPDWORD             lpNumConnections,
    LPCTSTR             lpDevice,
    LPDWORD             lpRegMaxWait,
    LPCONNECTION_INFO   *ConnectArray
    )

/*++

Routine Description:

    This function creates an array of CONNECTION_INFO structures and fills
    each element in the array with the info that is stored in the registry
    for that connection.

    NOTE:  This function allocates memory for the array.

Arguments:

    NumConnections - This is a pointer to the place where the number of
        connections is to be placed.  This indicates how many elements
        are stored in the array.

    lpDevice - If this is NULL, information on all remembered connections
        is required.  Otherwise, information for only the lpDevice connection
        is required.

    lpRegMaxWait - This is a pointer to the location where the wait time
        read from the registry is to be placed.  If this value does not
        exist in the registry, then the returned value is 0.

    ConnectArray - This is a pointer to the location where the pointer to
        the array is to be placed.

Return Value:

    An error status code is returned only if something happens that will not
    allow us to restore even one connection.


--*/
{
    DWORD       status = WN_SUCCESS;
    HKEY        connectHandle;
    HKEY        providerKeyHandle;
    DWORD       maxSubKeyLen;
    DWORD       maxValueLen;
    DWORD       ValueType;
    DWORD       Temp;
    DWORD       i;
    BOOL        AtLeastOneSuccess = FALSE;

    //
    // init return data
    //
    *lpNumConnections = 0 ;
    *ConnectArray = NULL ;

    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            CONNECTION_KEY_NAME,
            &connectHandle,
            DA_READ)) {

        MPR_LOG(ERROR,"WNetRestoreConnection: MprOpenKey Failed\n",0);
        return(WN_CANNOT_OPEN_PROFILE);
    }

    //
    // Find out the number of connections to restore (numSubKeys) and
    // the max lengths of subkeys and values.
    //
    if(!MprGetKeyInfo(
        connectHandle,
        NULL,
        lpNumConnections,
        &maxSubKeyLen,
        NULL,
        &maxValueLen))
    {
        MPR_LOG(ERROR,"WNetRestoreConnection: MprGetKeyInfo Failed\n",0);
        *lpNumConnections = 0 ;
        RegCloseKey(connectHandle);
        return(WN_CANNOT_OPEN_PROFILE);
    }

    if (*lpNumConnections == 0) {
        RegCloseKey(connectHandle);
        return(WN_SUCCESS);
    }

    if (lpDevice != NULL) {
        *lpNumConnections = 1;
    }

    //
    // Allocate the array.
    //
    *ConnectArray = (LPCONNECTION_INFO)LocalAlloc(
                        LPTR,
                        *lpNumConnections * sizeof(CONNECTION_INFO));

    if (*ConnectArray == NULL) {
        *lpNumConnections = 0 ;
        RegCloseKey(connectHandle);
        return(GetLastError());
    }

    //
    // Level 1 initialization for the call to MprGetProviderIndex in the loop
    //
    if (!(GlobalInitLevel & FIRST_LEVEL)) {
        status = MprLevel1Init();
        if (status != WN_SUCCESS) {
           RegCloseKey(connectHandle);
           return status;
        }
    }

    for (i=0; i < *lpNumConnections; i++) {

        //
        // Read a Connection Key and accompanying information from the
        // registry.
        //
        // NOTE:  If successful, this function will allocate memory for
        //          netResource.lpRemoteName,
        //          netResource.lpProvider,
        //          netResource.lpLocalName,     and optionally....
        //          userName
        //
        if (!MprReadConnectionInfo(
                    connectHandle,
                    lpDevice,
                    i,
                    &((*ConnectArray)[i].ProviderFlags),
                    &((*ConnectArray)[i].DeferFlags),
                    &((*ConnectArray)[i].UserName),
                    &((*ConnectArray)[i].NetResource),
                    &((*ConnectArray)[i].RegKey),
                    maxSubKeyLen)) {

            //
            // The read failed even though this should be a valid index.
            //
            MPR_LOG0(ERROR,
                     "MprCreateConnectionArray: ReadConnectionInfo Failed\n");
            status = WN_CANNOT_OPEN_PROFILE;
        }
        else {

            //
            // Get the Provider Index
            //

            if (MprGetProviderIndex(
                    (*ConnectArray)[i].NetResource.lpProvider,
                    &((*ConnectArray)[i].ProviderIndex))) {

                AtLeastOneSuccess = TRUE;
                (*ConnectArray)[i].ContinueFlag = TRUE;

            }
            else {

                //
                // The provider index could not be found.  This may mean
                // that the provider information stored in the registry
                // is for a provider that is no longer in the ProviderOrder
                // list.  (The provider has been removed).  In that case,
                // we will just skip this provider.  We will leave the
                // ContinueFlag set to 0 (FALSE).
                //
                MPR_LOG0(ERROR,
                     "MprCreateConnectionArray:MprGetProviderIndex Failed\n");

                status = WN_BAD_PROVIDER;
                (*ConnectArray)[i].Status = status;
            }

        } // endif (MprReadConnectionInfo)

    } // endfor (i=0; i<numSubKeys)


    if (!AtLeastOneSuccess) {
        //
        // If we gather any connection information, return the last error
        // that occured.
        //
        MprFreeConnectionArray(*ConnectArray,*lpNumConnections);
        *ConnectArray = NULL ;
        *lpNumConnections = 0 ;
        RegCloseKey(connectHandle);
        goto CleanExit;
    }

    RegCloseKey(connectHandle);

    //
    // Read the MaxWait value that is stored in the registry.
    // If it is not there or if the value is less than our default
    // maximum value, then use the default instead.
    //

    if(!MprOpenKey(
                HKEY_LOCAL_MACHINE,     // hKey
                NET_PROVIDER_KEY,       // lpSubKey
                &providerKeyHandle,     // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprCreateConnectionArray: MprOpenKey (%ws) Error\n",
            NET_PROVIDER_KEY);

        *lpRegMaxWait = 0;
        status = WN_SUCCESS;
        goto CleanExit;
    }
    MPR_LOG(TRACE,"OpenKey %ws\n, ",NET_PROVIDER_KEY);

    Temp = sizeof(*lpRegMaxWait);

    status = RegQueryValueEx(
                providerKeyHandle,
                RESTORE_WAIT_VALUE,
                NULL,
                &ValueType,
                (LPBYTE)lpRegMaxWait,
                &Temp);

    RegCloseKey(providerKeyHandle);

    if (status != NO_ERROR) {
        *lpRegMaxWait = 0;
    }

    status = WN_SUCCESS;

CleanExit:

    return(WN_SUCCESS);

}

VOID
MprFreeConnectionArray(
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections
    )

/*++

Routine Description:

    This function frees up all the elements in the connection array, and
    finally frees the array itself.


Arguments:


Return Value:

    none

--*/
{
    DWORD           status = WN_SUCCESS;
    LPNETRESOURCEW  netResource;
    DWORD           i;

    for (i=0; i<NumConnections; i++)
    {
        netResource = &(ConnectArray[i].NetResource);

        //
        // Free the allocated memory resources.
        //
        LocalFree(netResource->lpLocalName);
        LocalFree(netResource->lpRemoteName);
        LocalFree(netResource->lpProvider);
        LocalFree(ConnectArray[i].UserName);

        if (ConnectArray[i].RegKey != NULL)
        {
            RegCloseKey(ConnectArray[i].RegKey);
        }

        if (ConnectArray[i].hProviderDll != NULL)
        {
            FreeLibrary(ConnectArray[i].hProviderDll);
        }
    }

    LocalFree(ConnectArray);
    return;
}


DWORD
MprNotifyErrors(
    HWND                hWnd,
    LPCONNECTION_INFO   ConnectArray,
    DWORD               NumConnections,
    DWORD               dwFlags
    )

/*++

Routine Description:

    This function calls the error dialog for each connection that still
    has the continue flag set, and does not have a SUCCESS status.

Arguments:

    hWnd - This is a window handle that will be used as owner of the
        error dialog.

    ConnectArray - This is the array of connection information.
        At the point when this function is called, the following fields
        are meaningful:
        ContinueFlag - If set, it means that this connection has not yet
            been established.
        StatusFlag - If this is not SUCCESS, then it contains the error
            status from the last call to the provider.

        ContinueFlag    Status
        ---------------|---------------
        | FALSE        |  NotSuccess  | Provider will not start
        | FALSE        |  Success     | Connection was successfully established
        | TRUE         |  NotSuccess  | Time-out occured
        | TRUE         |  Success     | This can never occur.
        -------------------------------

    NumConnections - This is the number of entries in the array of
        connection information.

Return Value:



--*/
{
    DWORD   i;
    BOOL fDisconnect = FALSE;
    DWORD   status = WN_SUCCESS;

    //
    // If HideErrors becomes TRUE, stop displaying error dialogs
    //
    BOOL fHideErrors = (dwFlags & WNRC_NOUI) ? TRUE : FALSE;

    for (i=0; (i<NumConnections) && (!fHideErrors); i++ )
    {
        if ((ConnectArray[i].ContinueFlag)  &&
            (ConnectArray[i].Status != WN_SUCCESS)  &&
            (ConnectArray[i].Status != WN_CANCEL)   &&
            (ConnectArray[i].Status != WN_CONTINUE))
        {
            //
            // For any other error, call the Error Dialog
            //
            DoProfileErrorDialog (
                hWnd,
                ConnectArray[i].NetResource.lpLocalName,
                ConnectArray[i].NetResource.lpRemoteName,
                ConnectArray[i].NetResource.lpProvider,
                ConnectArray[i].Status,
                FALSE,      //No cancel button.
                NULL,
                &fDisconnect,
                &fHideErrors);

            if (fDisconnect)
            {
                status = ConnectArray[i].pfCancelConnection(
                             ConnectArray[i].NetResource.lpLocalName,
                             TRUE);
            }
        }
    }
    return status;
}

DWORD
MprAddPrintersToConnArray(
    LPDWORD             lpNumConnections,
    LPCONNECTION_INFO   *ConnectArray
    )

/*++

Routine Description:

    This function augments the array of CONNECTION_INFO with print connections.

    NOTE:  This function allocates memory for the array if need.

Arguments:

    NumConnections - This is a pointer to the place where the number of
        connections is to be placed.  This indicates how many elements
        are stored in the array.

    ConnectArray - This is a pointer to the location where the pointer to
        the array is to be placed.

Return Value:

    An error status code is returned only if something happens that will not
    allow us to restore even one connection.


--*/
{
    DWORD         status = WN_SUCCESS;
    HKEY          connectHandle;
    DWORD         i,j;
    DWORD         NumValueNames ;
    DWORD         MaxValueNameLength;
    DWORD         MaxValueLen ;
    LPNETRESOURCE lpNetResource ;
    LPWSTR        lpUserName = NULL ;
    LPWSTR        lpProviderName = NULL ;
    LPWSTR        lpRemoteName = NULL ;
    LPBYTE        lpBuffer = NULL ;


    //
    // Get a handle for the connection section of the user's registry
    // space.
    //
    if (!MprOpenKey(
            HKEY_CURRENT_USER,
            PRINT_CONNECTION_KEY_NAME,
            &connectHandle,
            DA_READ))
    {
        return(WN_SUCCESS);   // ignore the restored connections.
    }

    //
    // Find out the number of connections to restore and
    // the max lengths of names and values.
    //
    status = MprGetPrintKeyInfo(connectHandle,
                                &NumValueNames,
                                &MaxValueNameLength,
                                &MaxValueLen) ;

    if (status != WN_SUCCESS || NumValueNames == 0)
    {
        //
        // ignore the restored connections, or nothing to add
        //
        RegCloseKey(connectHandle);
        return(WN_SUCCESS);
    }


    //
    // Allocate the array and copy over the info if previous pointer not null.
    //
    lpBuffer = (LPBYTE) LocalAlloc(LPTR,
                                   (*lpNumConnections + NumValueNames) *
                                   sizeof(CONNECTION_INFO)) ;
    if (lpBuffer == NULL)
    {
        RegCloseKey(connectHandle);
        return(GetLastError());
    }
    if (*ConnectArray)
    {
        memcpy(lpBuffer,
               *ConnectArray,
               (*lpNumConnections * sizeof(CONNECTION_INFO))) ;
        LocalFree (*ConnectArray) ;
    }


    //
    // set j to index from previous location, update the count and pointer.
    // then loop thru all new entries, adding to the connect array.
    //
    j = *lpNumConnections ;
    *lpNumConnections += NumValueNames ;
    *ConnectArray = (CONNECTION_INFO *) lpBuffer ;

    //
    // Level 1 initialization for the call to MprGetProviderIndex in the loop
    //
    if (!(GlobalInitLevel & FIRST_LEVEL)) {
        status = MprLevel1Init();
        if (status != WN_SUCCESS) {
           RegCloseKey(connectHandle);
           return status;
        }
    }

    for (i=0; i < NumValueNames; i++, j++)
    {

        DWORD TypeCode ;
        DWORD cbRemoteName = (MaxValueNameLength + 1) * sizeof (WCHAR) ;
        DWORD cbProviderName = MaxValueLen ;

        //
        // allocate the strings for the providername, remotename
        //
        if (!(lpProviderName = (LPWSTR) LocalAlloc(0,  cbProviderName )))
        {
             status = GetLastError() ;
             goto ErrorExit ;
        }
        if (!(lpRemoteName = (LPWSTR) LocalAlloc(0,  cbRemoteName )))
        {
             status = GetLastError() ;
             goto ErrorExit ;
        }

        //
        // Init the rest. Username currently not set by system, so always NULL
        //
        lpUserName = NULL ;
        lpNetResource = &(*ConnectArray)[j].NetResource ;
        lpNetResource->lpLocalName = NULL ;
        lpNetResource->lpRemoteName = lpRemoteName ;
        lpNetResource->lpProvider = lpProviderName ;
        lpNetResource->dwType = 0 ;

        //
        // null these so we dont free twice if error exit later
        //
        lpRemoteName = NULL ;
        lpProviderName = NULL ;

        status = RegEnumValue(connectHandle,
                           i,
                           lpNetResource->lpRemoteName,
                           &cbRemoteName,
                           0,
                           &TypeCode,
                           (LPBYTE) lpNetResource->lpProvider,
                           &cbProviderName) ;

        if (status == NO_ERROR)
        {
            (*ConnectArray)[j].UserName = lpUserName ;

            //
            // Get the Provider Index
            //
            if (MprGetProviderIndex(
                    (*ConnectArray)[j].NetResource.lpProvider,
                    &((*ConnectArray)[j].ProviderIndex)))
            {
                (*ConnectArray)[j].ContinueFlag = TRUE;
            }
            else
            {
                //
                // The provider index could not be found.  This may mean
                // that the provider information stored in the registry
                // is for a provider that is no longer in the ProviderOrder
                // list.  (The provider has been removed).  In that case,
                // we will just skip this provider.  We will leave the
                // ContinueFlag set to 0 (FALSE).
                //
                status = WN_BAD_PROVIDER;
                (*ConnectArray)[j].Status = status;
            }

        }
        else
        {
            //
            // should not happen, but if it does the array is half built,
            // and cannot be used, so ErrorExit (this will clean it up).
            //
            goto ErrorExit ;
        }
    }

    RegCloseKey(connectHandle);
    return(WN_SUCCESS);

ErrorExit:

    RegCloseKey(connectHandle);

    LocalFree(lpProviderName) ;
    LocalFree(lpRemoteName) ;

    MprFreeConnectionArray(*ConnectArray,*lpNumConnections);
    *ConnectArray = NULL ;
    *lpNumConnections = 0 ;
    return status;
}



VOID
MprNotifyShell(
    IN LPCWSTR      pwszDevice
    )
/*++

Routine Description:

    This function sets an event that asks a trusted system component
    (the service controller) to discover the changed network drives and
    asynchronously broadcast a device change message on our behalf.

    CODEWORK:  Replace this entire mechanism with real plug-n-play.

Arguments:

    pwszDevice - Name of the local device (NULL for UNC connections)

Return Value:

    None

History:

    BruceFo   19-May-1995   Created, calls BSM directly
    AnirudhS  06-Jun-1996   Set event to have another component do
        the BSM on our behalf

--*/
{
    // The shell is only interested in drive redirections
    if (pwszDevice == NULL || wcslen(pwszDevice) != 2 || pwszDevice[1] != L':')
    {
        return;
    }

    // Ask for a device change message to be broadcast
    HANDLE hBSMEvent = OpenEvent(
                            EVENT_MODIFY_STATE, // desired access
                            FALSE,              // don't inherit
                            SC_BSM_EVENT_NAME   // name
                            );
    if (hBSMEvent == NULL)
    {
        MPR_LOG(ERROR, "Couldn't open event for BSM request, %lu\n",
                GetLastError());
    }
    else
    {
        if (! SetEvent(hBSMEvent))
        {
            MPR_LOG(ERROR, "Couldn't set event for BSM request, %lu\n",
                    GetLastError());
        }

        CloseHandle(hBSMEvent);
    }
}


BOOL
MprBroadcastDriveChange(
    IN LPCWSTR          pwszDevice,
    IN BOOL             DeleteMessage
    )
/*++

Routine Description:

    This function asynchronously broadcasts a device change message on
    our behalf.

Arguments:

    pwszDevice - Name of the local device (NULL for UNC connections)

    DeleteMessage - denotes where a delete/add message is needed
                   TRUE  - send a device deleted message
                   FALSE - send a device added message

Return Value:

    TRUE - Operations completed
    FALSE - Error encountered
--*/
{
    BOOL Result;
    DWORD dwFlags = DDD_LUID_BROADCAST_DRIVE;

    // The shell is only interested in drive redirections
    if (pwszDevice == NULL || wcslen(pwszDevice) != 2 || pwszDevice[1] != L':')
    {
        return( FALSE );
    }

    if( DeleteMessage == TRUE )
    {
        dwFlags |= DDD_REMOVE_DEFINITION;
    }

    Result = DefineDosDeviceW( dwFlags, pwszDevice, NULL );

    return( Result );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\connify.h ===
#ifndef _CONNIFY_INCLUDED
#define _CONNIFY_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif

DWORD
MprConnectNotifyInit(
    VOID
    );

DWORD
MprAddConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYADD         lpAddInfo
    );

DWORD
MprCancelConnectNotify(
    LPNOTIFYINFO        lpNotifyInfo,
    LPNOTIFYCANCEL      lpCancelInfo
    );

PVOID
MprAllocConnectContext(
    VOID
    );

VOID
MprFreeConnectContext(
    PVOID   ConnectContext
    );

#ifdef __cplusplus
}
#endif

#endif // _CONNIFY_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\connperf.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    connperf.cxx

Abstract:

    Contains the entry points for the WinNet Resource Info API supported
    by the Multi-Provider Router.  The following functions are in this file:

        MultinetGetConnectionPerformanceW

Author:

    Anirudh Sahni (anirudhs) 22-Jan-1996

Environment:

    User Mode -Win32

Notes:


Revision History:

    22-Jan-1996     anirudhs
        Created

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/
//
// INCLUDES
//
#include "precomp.hxx"


//===================================================================
// CGetConnection
//
// This class retrieves the remote name and provider responsible for
// a redirected device.
// CODEWORK:  This can/should replace MprGetConnection if we can be
// sure that the error picking logic is equivalent.  Code needs to be
// added to handle remembered connections.
//===================================================================

class CGetConnection : public CRoutedOperation
{
public:
                    CGetConnection(
                        LPWSTR          lpLocalName,    // IN
                        LPWSTR          lpRemoteName,   // OUT
                        LPDWORD         lpBufferSize,   // IN OUT
                        LPWSTR          lpProviderName  // IN OPTIONAL
                        ) :
                            CRoutedOperation(DBGPARM("GetConnection")
                                             PROVIDERFUNC(GetConnection)),
                            _lpLocalName    (lpLocalName),
                            _lpRemoteName   (lpRemoteName),
                            _lpBufferSize   (lpBufferSize),
                            _lpProviderName (lpProviderName)
                        { }

    PROVIDER *      LastProvider() const  // expose the base class' method
                        { return (CRoutedOperation::LastProvider()); }

private:

    LPWSTR          _lpLocalName;
    LPWSTR          _lpRemoteName;
    LPDWORD         _lpBufferSize;
    LPWSTR          _lpProviderName;

    DECLARE_CROUTED
};


DWORD
CGetConnection::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (MprDeviceType(_lpLocalName) != REDIR_DEVICE)
    {
        return WN_BAD_LOCALNAME;
    }

    //
    // Let the base class validate the provider name, if one was supplied
    //
    *ppProviderName = _lpProviderName;
    *ppLocalName    = _lpLocalName;

    return WN_SUCCESS;
}


DWORD
CGetConnection::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    return pProvider->GetConnection(_lpLocalName, _lpRemoteName, _lpBufferSize);
}



//===================================================================
// MultinetGetConnectionPerformanceW
//===================================================================

class CGetConnectionPerformance : public CRoutedOperation
{
public:
                    CGetConnectionPerformance(
                        LPNETRESOURCEW          lpNetResource,
                        LPNETCONNECTINFOSTRUCT  lpNetConnectInfo
                        ) :
                            CRoutedOperation(DBGPARM("GetConnectionPerformance")
                                             PROVIDERFUNC(GetConnectionPerformance)),
                            _lpNetResource   (lpNetResource),
                            _lpNetConnectInfo(lpNetConnectInfo)
                        { }

private:

    LPNETRESOURCEW          _lpNetResource;
    LPNETCONNECTINFOSTRUCT  _lpNetConnectInfo;

    LPWSTR          _pRemoteName;
    WCHAR           _wszBuffer[MAX_PATH+1];

    DECLARE_CROUTED
};


DWORD
CGetConnectionPerformance::ValidateRoutedParameters(
    LPCWSTR *       ppProviderName,
    LPCWSTR *       ppRemoteName,
    LPCWSTR *       ppLocalName
    )
{
    if (!(ARGUMENT_PRESENT(_lpNetResource) &&
          ARGUMENT_PRESENT(_lpNetConnectInfo)))
    {
        return WN_BAD_POINTER;
    }

    if (_lpNetConnectInfo->cbStructure < sizeof(NETCONNECTINFOSTRUCT))
    {
        return WN_BAD_VALUE;
    }

    //
    // Zero out the output structure, except for the first field.
    //
    memset((&_lpNetConnectInfo->cbStructure) + 1,
           0,
           sizeof(*_lpNetConnectInfo) - sizeof(_lpNetConnectInfo->cbStructure));

    if (IS_EMPTY_STRING(_lpNetResource->lpLocalName))
    {
        //
        // No local name is specified, so a remote name should be specified.
        //
        _pRemoteName = _lpNetResource->lpRemoteName;
        if (IS_EMPTY_STRING(_pRemoteName))
        {
            return WN_BAD_NETNAME;
        }

        // Let the base class validate the provider name, if specified.
        *ppProviderName = _lpNetResource->lpProvider;
    }
    else
    {
        //
        // A local name is specified.  Try to identify the remote name,
        // and, as a side effect, the provider that made the connection.
        //
        DWORD cchBuffer = LENGTH(_wszBuffer);
        CGetConnection GetConn(_lpNetResource->lpLocalName,
                               _wszBuffer,
                               &cchBuffer,
                               _lpNetResource->lpProvider);
        DWORD status = GetConn.Perform(FALSE);

        if (status != WN_SUCCESS)
        {
            ASSERT(status != WN_MORE_DATA);
            return status;
        }

        _pRemoteName = _wszBuffer;

        // A somewhat roundabout way of telling the base class the real provider
        *ppProviderName = GetConn.LastProvider()->Resource.lpProvider;
    }

    // Have the base class cache the remote name (again).  Note that
    // the local name, if present, was checked by CGetConnection
    *ppRemoteName = _pRemoteName;
    *ppLocalName  = NULL;

    return WN_SUCCESS;
}


DWORD
CGetConnectionPerformance::TestProvider(
    const PROVIDER * pProvider
    )
{
    ASSERT_INITIALIZED(NETWORK);

    //
    // CODEWORK -- We should try to resolve the local name here
    //             per connection and if it succeeds, then call
    //             the provider's GetConnectionPerformance.  We
    //             could then remove the use of CGetConnection
    //             from ValidateRoutedParameters.
    //
    return (pProvider->GetConnectionPerformance(
                            _pRemoteName,
                            _lpNetConnectInfo));
}


DWORD
MultinetGetConnectionPerformanceW(
    LPNETRESOURCEW          lpNetResource,
    LPNETCONNECTINFOSTRUCT  lpNetConnectInfo
    )
/*++

Routine Description:

    This API returns information about the expected performance of a
    connection used to access a network resource.

Arguments:

    lpNetResource -

    lpNetConnectInfo -

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    Other errors -

--*/
{
    CGetConnectionPerformance GetConnPerf(lpNetResource, lpNetConnectInfo);

    return (GetConnPerf.Perform(TRUE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\fmt.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fmt.cxx

Abstract:

    Contains the entry points for the Winnet Connection API supported by the
    Multi-Provider Router.
    Contains:
        WNetFormatNetworkNameW

Author:

    Bruce Forstall (brucefo)     15-Mar-1996

Environment:

    User Mode -Win32

Notes:

Revision History:

    15-Mar-1996     brucefo
        created from old MPRUI code

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/

//
// INCLUDES
//

#include "precomp.hxx"


/*******************************************************************

    NAME:       WNetFormatNetworkNameW

    SYNOPSIS:   Private Shell API for getting the formatted network name
                Unicode version

    ENTRY:      lpProvider - Name of network provider
                lpRemoteName - Remote name to format
                lpFormattedName - Buffer to receive name
                lpnLength - size of lpFormattedName buffer
                dwFlags - Formatting flags
                dwAveCharePerLine - Avg. characters per line

    NOTES:      Since this is an unpublished API, we don't do as much
                parameter validation as we would for a published API. Also,
                since the shell calls this thousands of times to display
                things in the Network Neighborhood, we optimize for speed
                of the success case.

    HISTORY:
        Johnl   29-Dec-1992     Created
        BruceFo 19-Mar-1996     Optimized for the shell

********************************************************************/

DWORD
WNetFormatNetworkNameW(
    LPCWSTR  lpProvider,
    LPCWSTR  lpRemoteName,
    LPWSTR   lpFormattedName,
    LPDWORD  lpnLength,         // In characters!
    DWORD    dwFlags,
    DWORD    dwAveCharPerLine
    )
{
    DWORD   status = WN_SUCCESS;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(NETWORK_LEVEL,status);

    __try
    {
        LPPROVIDER provider = MprFindProviderByName(lpProvider);
        if (NULL == provider)
        {
            status = WN_BAD_PROVIDER;
        }
        else
        {
            if (NULL == provider->FormatNetworkName)
            {
                status = WN_NOT_SUPPORTED;
            }
            else
            {
                //**************************************
                // Actual call to Provider.
                //**************************************
                status = provider->FormatNetworkName(
                                    (LPWSTR) lpRemoteName,      // cast away const
                                    (LPWSTR) lpFormattedName,   // cast away const
                                    lpnLength,
                                    dwFlags,
                                    dwAveCharPerLine);
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION)
        {
            MPR_LOG(ERROR,"WNetFormatNetworkName: "
                "Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        SetLastError(status);
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\credman.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    credman.cxx

Abstract:

    WNet Credential Management API functions

Author:

    Dan Lafferty (danl) 07-Dec-1992

Environment:

    User Mode - Win32


Revision History:

    05-May-1999     jschwart
        Make provider addition/removal dynamic

    19-Apr-1994 danl
        Fix timeout logic where we would ignore the
        provider-supplied timeout if the timeout was smaller than the default.
        Now, if all the providers know their timeouts, the larger of those
        timeouts is used.  Even if smaller than the default.

    09-Jun-1993 danl
        Fixed MaxWait in MprCheckTimeout() so that now it is passed in.
        Until now, it was left uninitialized.

    07-Apr-1993 danl
        Initialize the pointer to the logon script to NULL prior to passing
        it to the provider to fill in.  We are expecting it to be NULL if
        they don't have a logon script.

    18-Jan-1993 danl
        WNetLogonNotify:  If the provider returns an error that mpr
        doesn't understand, it should discontinue calling that provider.
        This is accomplished by setting the ContinueFlag for that provider
        to FALSE.

    07-Dec-1992 danl
        Created

--*/

//
// INCLUDES
//
#include "precomp.hxx"
#include <tstr.h>       // WCSSIZE

//
// DEFINES
//

typedef struct _RETRY_INFO {
    DWORD   ProviderIndex;
    DWORD   Status;
    DWORD   ProviderWait;
    BOOL    ContinueFlag;
    LPWSTR  LogonScript;
} RETRY_INFO, *LPRETRY_INFO;

//
// LOCAL FUNCTIONS
//
DWORD
MprMakeRetryArray(
    LPCWSTR         lpPrimaryAuthenticator,
    LPDWORD         lpNumProviders,
    LPRETRY_INFO    *lpRetryArray,
    LPDWORD         lpRegMaxWait
    );

VOID
MprUpdateTimeout(
    LPRETRY_INFO    RetryArray,
    LPPROVIDER      Provider,
    DWORD           RegMaxWait,
    LPDWORD         pMaxWait,
    DWORD           StartTime,
    DWORD           CallStatus
    );

VOID
MprCheckTimeout(
    BOOL    *ContinueFlag,
    DWORD   StartTime,
    DWORD   MaxWait,
    LPDWORD lpStatus
    );


DWORD APIENTRY
WNetLogonNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,  // may be NULL
    LPVOID              lpPreviousAuthentInfo,      // may be NULL
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    LPWSTR              *lpLogonScripts
    )

/*++

Description:

    This function provides notification to provider dll's that must handle
    log-on events.

    Each Credential Manager Provider is allowed to return
    a single command line string which will execute a logon script.
    WNetLogonNotify gathers these strings into a MULTI_SZ string buffer.
    (Meaning each string is NULL terminated, and the set of strings is
    NULL terminated - thus making the last string doubly NULL terminated).

    !! IMPORTANT !!
        The caller of this function is responsible for freeing the
        buffer pointed to by *lpLogonScripts.  The windows API function
        LocalFree() should be used to do this.

Arguments:

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  The router uses this information to
        skip the credential manager identified by this string.  Since it
        is the primary, it has already handled the logon.  This string is
        obtained from the "\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\
        Services\*(keyname)\NetworkProvider\Name" registry value.

    lpLogonId - The logon ID of the session currently being logged on.

    lpAuthentInfoType - This points to a string that identifies the
        AuthentInfo structure type.

        When Microsoft is the primary authenticator, the values that may
        be expected here are the ones described for the lpAuthentInfoType
        parameter to NPLogonNotify().

    lpAuthentInfo - This points to a structure that contains the
        credentials used to successfully log the user on via the
        primary authenticator.  The structures that may be specified when
        using Micosoft's primary authenticator are:

        When Microsoft is the primary authenticator, the structures that
        may be expected here are the ones described for the lpAuthentInfo
        parameter to NPLogonNotify().

    lpPreviousAuthentInfoType - This is pointer to a string that identifies
        the PreviousAuthentInfo structure.  If this pointer is NULL, then
        no PreviousAuthentInfo is available.

        The values that may be expected here are the same as the values that
        may be expected for the lpAuthentInfoType parameter.

    lpPreviousAuthentInfo - If the user was forced to change the password
        prioir to logging on, this points to a AuthentInfo structure that
        will contain the credential information used prior to the password
        change.  If the user was not forced to change the password prior
        to logging on, then this pointer is NULL.

        The structures that may be expected here are the same as the
        structures that may be expected for the lpAuthentInfo parameter.

    lpStationName - This parameter contains the name of the station the
        user has logged onto.  This may be used to determine whether or
        not interaction with the user to obtain additional (provider-specific)
        credentials is possible.  This information will also have a bearing
        on the meaning and use of the StationHandle parameter.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationName
        parameter to NPLogonNotify().

    StationHandle - Is a 32-bit value whose meaning is dependent upon the
        name (and consequently, the type) of station being logged onto.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationHandle
        parameter to NPLogonNotify().

    lpLogonScripts - This is a pointer to a location where a pointer to
        a MULTI_SZ string may be returned.  Each null terminated
        string in the MULTI_SZ string is assumed to contain the name
        of a program to execute and parameters to pass to the program.
        The memory allocated to hold the returned string must be
        deallocatable by the calling routine.  The caller of this
        routine is responsible for freeing the memory used to house
        this string when it is no longer needed.

Return Value:


--*/
{
    DWORD           status = WN_SUCCESS;
    DWORD           numProviders;
    LPPROVIDER      provider;
    BOOL            fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD           i;
    BOOL            ContinueFlag;
    LPRETRY_INFO    RetryArray;
    DWORD           RegMaxWait=0;
    DWORD           MaxWait=0;
    DWORD           StartTime;
    DWORD           scriptSize=0;
    LPWSTR          pScript;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(CREDENTIAL_LEVEL,status);

    MPR_LOG0(TRACE,"Entered WNetLogonNotify\n");
    //
    // Now create an array of information about the providers so that we
    // can retry until timeout, or all providers are functional.
    // Note:  The Status field in each retry array element is initialized
    //        WN_NO_NETWORK.
    //
    __try {
        *lpLogonScripts = NULL;

        status = MprMakeRetryArray(
                    lpPrimaryAuthenticator,
                    &numProviders,
                    &RetryArray,
                    &RegMaxWait);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetLogonNotify:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if ((status != WN_SUCCESS) || (numProviders == 0)) {
        MPR_LOG2(TRACE,"WNetLogonNotify: Error - status=%d, numProviders=%d\n",
            status,numProviders);
        return(status);
    }

    //
    // Initialize the timer.
    //
    if (RegMaxWait != 0) {
        MaxWait = RegMaxWait;
    }
    StartTime = GetTickCount();

    //
    // Loop through the list of providers notifying each one in turn.
    // If the underlying service or driver is not available for the
    // provider such that it cannot complete this call, then we will
    // wait for it to become available.
    //

    do {

        ContinueFlag = FALSE;

        for (i=0; i<numProviders; i++) {

            //
            // Call the appropriate provider's API entry point
            //
            provider = GlobalProviderInfo + RetryArray[i].ProviderIndex;

            if ((RetryArray[i].ContinueFlag) &&
                (provider->LogonNotify != NULL))  {

                fcnSupported = TRUE;

                RetryArray[i].LogonScript = NULL;

                __try {
                    MPR_LOG(TRACE,"Calling (%ws) LogonNotify function\n",
                        provider->Resource.lpProvider);
                    status = provider->LogonNotify(
                                lpLogonId,
                                lpAuthentInfoType,
                                lpAuthentInfo,
                                lpPreviousAuthentInfoType,
                                lpPreviousAuthentInfo,
                                lpStationName,
                                StationHandle,
                                (LPWSTR *)&(RetryArray[i].LogonScript));
                }
                __except(EXCEPTION_EXECUTE_HANDLER) {
                    status = GetExceptionCode();
                    if (status != EXCEPTION_ACCESS_VIOLATION) {
                        MPR_LOG(ERROR,"WNetLogonNotify:Unexpected Exception "
                        "0x%lx\n",status);
                    }
                    status = WN_BAD_POINTER;
                }

                switch (status) {
                case WN_SUCCESS:
                    //
                    // Because this provider may have put up dialogs, and
                    // taken a long time to complete, we want to skip the
                    // timeout check and try all the providers once more.
                    // We force the index to 0 in order to assure that all
                    // providers will be tried again prior to checking for
                    // a timeout.
                    //
                    RetryArray[i].Status = WN_SUCCESS;
                    RetryArray[i].ContinueFlag = FALSE;
                    if (RetryArray[i].LogonScript != NULL) {
                        scriptSize += WCSSIZE(RetryArray[i].LogonScript);
                    }
                    ContinueFlag = FALSE;
                    i=0;
                    break;

                case WN_NO_NETWORK:
                case WN_FUNCTION_BUSY:
                    //
                    // The provider is not ready to be notified (its underlying
                    // driver or service is not running yet).  Attempt to
                    // find out how long to wait, or if it will ever start.
                    // This function will update MaxWait if the provider can
                    // give us a wait hint.
                    //
                    MprUpdateTimeout(
                        &(RetryArray[i]),
                        provider,
                        RegMaxWait,
                        &MaxWait,
                        StartTime,
                        status);
                    break;

                default:
                    RetryArray[i].Status = status;
                    RetryArray[i].ContinueFlag = FALSE;
                    break;

                } // End Switch (Get providers timeouts).

                ContinueFlag |= RetryArray[i].ContinueFlag;

            } // end check to see if function is supported.

        } // end for i<numProviders.

        //
        // Check to see if the timeout has expired.
        //
        MprCheckTimeout(&ContinueFlag, StartTime, MaxWait, &status);

    } while (ContinueFlag);

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        MPR_LOG0(TRACE,"WNetLogonNotify: Function Not Supported\n");
        status = WN_NOT_SUPPORTED;
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (status == WN_SUCCESS){
        if (scriptSize != 0) {
            //
            // There must be some logon scripts.  Allocate memory for them.
            //
            *lpLogonScripts = (LPWSTR)LocalAlloc(
                                LMEM_FIXED,
                                scriptSize+sizeof(WCHAR));

            if (*lpLogonScripts != NULL) {
                //
                // Copy the logon scripts into the new buffer.
                //
                pScript = *lpLogonScripts;

                for (i=0;i<numProviders ;i++) {
                    if ((RetryArray[i].Status == WN_SUCCESS) &&
                        (RetryArray[i].LogonScript != NULL)) {

                        wcscpy(pScript, RetryArray[i].LogonScript);
                        //
                        // Update the pointer to point beyond the last null
                        // terminator.
                        //
                        pScript += (wcslen(pScript) + 1);
                    }
                }
                //
                // Add the double NULL terminator.
                //
                *pScript = L'\0';
            }
            else {
                //
                // The allocation failed.  (ERROR LOG?)
                //
                MPR_LOG0(ERROR,"Logon scripts will be lost - could not "
                    "allocate memory\n");

            }
        }
    }
    else {
        SetLastError(status);
    }

    if (RetryArray != NULL) {
        LocalFree(RetryArray);
    }
    MPR_LOG1(TRACE,"Leaving WNetLogonNotify status = %d\n",status);
    return(status);
}

DWORD APIENTRY
WNetPasswordChangeNotify(
    LPCWSTR             lpPrimaryAuthenticator,
    LPCWSTR             lpAuthentInfoType,
    LPVOID              lpAuthentInfo,
    LPCWSTR             lpPreviousAuthentInfoType,
    LPVOID              lpPreviousAuthentInfo,
    LPWSTR              lpStationName,
    LPVOID              StationHandle,
    DWORD               dwChangeInfo
    )


/*++

Description:

    This function is used to notify credential managers of a password
    change for an account.

Arguments:

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  Credential Manager does not need the
        password notification since it already handled the change.
        This string is obtained from the "\HKEY_LOCAL_MACHINE\SYSTEM\
        CurrentControlSet\Services\*(keyname)\NetworkProvider\Name" registry
        value.

    lpAuthentInfoType - This points to a string that identifies the
        AuthentInfo structure type.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the
        lpAuthentInfoType parameter to NPLogonNotify().

    lpAuthentInfo - This points to a structure that contains the
        new credentials.

        When Microsoft is the primary authenticator, the structures that
        may be expected here are the ones described for the lpAuthentInfo
        parameter to NPLogonNotify().

    lpPreviousAuthentInfoType - This points to the string that identifies
        the PreviousAuthentInfo structure type.

        The values that may be expected here are the same as the values that
        may be expected for the lpAuthentInfoType parameter.

    lpPreviousAuthentInfo - This points to an AuthentInfo structure that
        contains the previous credential information. (old password and such).

        The structures that may be expected here are the same as the
        structures that may be expected for the lpAuthentInfo parameter.

    lpStationName - This parameter contains the name of the station the
        user performed the authentication information change from.
        This may be used to determine whether or not interaction with the
        user to obtain additional (provider-specific) information is possible.
        This information will also have a bearing on the meaning and use of
        the StationHandle parameter.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationName
        parameter to NPLogonNotify().

    StationHandle - Is a 32-bit value whose meaning is dependent upon the
        name (and consequently, the type) of station being logged onto.

        When Microsoft is the primary authenticator, the values that
        may be expected here are the ones described for the lpStationHandle
        parameter to NPLogonNotify().

    dwChangeInfo - This is a set of flags that provide information about the
        change.  Currently the following possible values are defined:

            WN_VALID_LOGON_ACCOUNT - If this flag is set, then the
                password (or, more accurately, the authentication
                information) that was changed will affect future
                logons.  Some authentication information changes
                will only affect connections made in untrusted
                domains.  These are accounts that the user cannot
                use to logon to this machine anyway.  In these
                cases, this flag will not be set.


Return Value:


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i,j;
    DWORD       primaryIndex;
    BOOL        oneSuccess=FALSE;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(CREDENTIAL_LEVEL,status);

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    //
    // If there are no active providers, MprFindCallOrder returns
    // WN_NO_NETWORK.
    //
    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                CREDENTIAL_TYPE);

    if (status != WN_SUCCESS) {
        return(status);
    }

    __try {
        //
        // Remove the primary authenticator from the list.
        //
        if (MprGetProviderIndex((LPTSTR)lpPrimaryAuthenticator,&primaryIndex)) {

            for (i=0; i<numProviders ;i++ ) {
                if (indexArray[i] == primaryIndex) {
                    numProviders--;
                    j=i;
                    i++;
                    for (; j<numProviders; i++,j++) {
                        indexArray[j] = indexArray[i];
                    }
                    break;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetChangePassword:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    //
    // If there are no credential managers aside from the primary, the
    // return with success.
    //
    if (numProviders == 0) {
        if (indexArray != localArray) {
            LocalFree(indexArray);
        }
        return(WN_SUCCESS);
    }

    //
    // Loop through the list of providers notifying each one.
    //

    for (i=0; i<numProviders; i++) {

        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + indexArray[i];

        if (provider->PasswordChangeNotify != NULL)  {

            fcnSupported = TRUE;

            __try {
                MPR_LOG(TRACE,"Calling (%ws) ChangePasswordNotify function\n",
                    provider->Resource.lpProvider);

                status = provider->PasswordChangeNotify(
                            lpAuthentInfoType,
                            lpAuthentInfo,
                            lpPreviousAuthentInfoType,
                            lpPreviousAuthentInfo,
                            lpStationName,
                            StationHandle,
                            dwChangeInfo);
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetChangePassword:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_SUCCESS) {
                //
                // If the call was successful, then we indicate that at least
                // one of the calls was successful.
                //
                oneSuccess = TRUE;
            }
        }
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (oneSuccess == TRUE) {
        status = WN_SUCCESS;
    }
    else {
        SetLastError(status);
    }

    return(status);
}
#ifdef REMOVE

DWORD APIENTRY
WNetLogoffNotify(
    HWND                hwndOwner,
    LPCWSTR             lpPrimaryAuthenticator,
    PLUID               lpLogonId,
    WN_OPERATION_TYPE   OperationType
    )

/*++

Description:

    This function provides log-off notification to credential managers.

Arguments:

    hwndOwner - Identifies the owner window.

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  Credential Manager does not need the
        password notification since it already handled the change.

    lpLogonId - The logon ID of the session currently being logged on.

    OperationType - The type of operation.  This indicates whether the
        function call is from an interactive program (winlogon), or a
        background program (service controller).  User dialogs should not
        be displayed if the call was from a background process.


Return Value:

    WN_SUCCESS - This is returned if we are able to successfully notify at
        least one of the providers which has registered an entry point for
        the Logoff event.

    WN_NO_NETWORK - This is returned if there are no providers, or if
        there is only one provider, but its supporting service/driver is
        not available.

    WN_BAD_POINTER - This is returned if one of the pointer parameters
        is bad and causes an exception.

    WN_NOT_SUPPORTED - This is returned if none of the active providers
        support this function.

    system errors such as ERROR_OUT_OF_MEMORY are also reported.


Note:


--*/
{
    DWORD       status = WN_SUCCESS;
    LPDWORD     indexArray;
    DWORD       localArray[DEFAULT_MAX_PROVIDERS];
    DWORD       numProviders;
    LPPROVIDER  provider;
    BOOL        fcnSupported = FALSE; // Is fcn supported by a provider?
    DWORD       i,j;
    DWORD       primaryIndex;
    BOOL        oneSuccess=FALSE;

    MprCheckProviders();

    CProviderSharedLock    PLock;

    INIT_IF_NECESSARY(CREDENTIAL_LEVEL,status);

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    //
    // If there are no active providers, MprFindCallOrder returns
    // WN_NO_NETWORK.
    //
    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                CREDENTIAL_TYPE);

    if (status != WN_SUCCESS) {
        return(status);
    }

    try {
        //
        // Remove the primary authenticator from the list.
        //
        if (MprGetProviderIndex((LPTSTR)lpPrimaryAuthenticator,&primaryIndex)) {

            for (i=0; i<numProviders ;i++ ) {
                if (indexArray[i] == primaryIndex) {
                    numProviders--;
                    j=i;
                    i++;
                    for (; j<numProviders; i++,j++) {
                        indexArray[j] = indexArray[i];
                    }
                    break;
                }
            }
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetChangePassword:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    //
    // If there are no credential managers aside from the primary, the
    // return with success.
    //
    if (numProviders == 0) {
        if (indexArray != localArray) {
            LocalFree(indexArray);
        }
        return(WN_SUCCESS);
    }

    //
    // Loop through the list of providers notifying each one.
    //

    for (i=0; i<numProviders; i++) {

        //
        // Call the appropriate provider's API entry point
        //
        provider = GlobalProviderInfo + indexArray[i];

        if ((provider->InitClass & CREDENTIAL_TYPE) &&
            (provider->LogoffNotify != NULL))         {

            fcnSupported = TRUE;

            try {
                status = provider->LogoffNotify(
                            hwndOwner,
                            lpLogonId,
                            OperationType);
            }
            except(EXCEPTION_EXECUTE_HANDLER) {
                status = GetExceptionCode();
                if (status != EXCEPTION_ACCESS_VIOLATION) {
                    MPR_LOG(ERROR,"WNetLogoffNotify:Unexpected Exception 0x%lx\n",status);
                }
                status = WN_BAD_POINTER;
            }
            if (status == WN_SUCCESS) {
                //
                // If the call was successful, then we indicate that at least
                // one of the calls was successful.
                //
                oneSuccess = TRUE;
            }
        }
    }

    if (fcnSupported == FALSE) {
        //
        // No providers in the list support the API function.  Therefore,
        // we assume that no networks are installed.
        //
        status = WN_NOT_SUPPORTED;
    }

    //
    // If memory was allocated by MprFindCallOrder, free it.
    //
    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Handle normal errors passed back from the provider
    //
    if (oneSuccess == TRUE) {
        status = WN_SUCCESS;
    }
    else {
        SetLastError(status);
    }

    return(status);
}
#endif // REMOVE

DWORD
MprMakeRetryArray(
    LPCWSTR         lpPrimaryAuthenticator,
    LPDWORD         lpNumProviders,
    LPRETRY_INFO    *lpRetryArray,
    LPDWORD         lpRegMaxWait
    )

/*++

Routine Description:

    This function returns with an array of RETRY_INFO structures.  There is
    one array element for each credential manager provider that is NOT
    the current primary authenticator.  The structures contain such information
    as the provider index in the global array of provider information, a
    location for the provider's timeout value, status and continue flag.

    This function will also attempt to obtain the WaitTimeout from the
    registry if it exists.

    IMPORTANT!
        This function allocates memory for lpRetryArray.  The caller is
        expected to free this memory with LocalFree().  If an error is
        returned, or if the data at lpNumProviders is 0, then memory is
        not allocated.

Arguments:

    lpPrimaryAuthenticator - This is a pointer to a string that identifies
        the primary authenticator.  The router uses this information to
        skip the credential manager identified by this string.  Since it
        is the primary, it has already handled the logon.

    lpNumProviders - This is a pointer to a location where the number of
        providers in the lpRetryArray are stored.

    lpRetryArray - This is an array of RETRY_INFO structures.  There is one
        element in the array for each Credential Manager provider that is
        not the current PrimaryAuthenticator.  The status in the array is
        initialized to WN_NO_NETWORK.

    lpRegMaxWait - This is a pointer to the location to where the Maximum
        Wait Timeout from the registry is to be placed.  If there is no
        MaxWait value in the registry, zero is returned.


Return Value:

    WN_SUCCESS is returned if we successfully created an array of
    RetryInfo structures, or if there are no credential manager providers.
    If we are unable to allocate memory for the RetryInfo structures,
    then the failure from LocalAlloc is returned.

--*/
{
    DWORD           status;
    DWORD           i,j;
    HKEY            providerKeyHandle;
    DWORD           primaryIndex;
    DWORD           ValueType;
    DWORD           Temp;
    DWORD           numProviders;
    LPDWORD         indexArray;
    DWORD           localArray[DEFAULT_MAX_PROVIDERS];

    ASSERT(MPRProviderLock.Have());

    //
    // Find the list of providers to call for this request.
    //
    indexArray = localArray;

    //
    // If there are no active providers, or none of the active providers are
    // in this InitClass MprFindCallOrder returns WN_NO_NETWORK.
    //
    status = MprFindCallOrder(
                NULL,
                &indexArray,
                &numProviders,
                CREDENTIAL_TYPE);

    if ((status != WN_SUCCESS) || (numProviders == 0)) {
        //
        // If there aren't any credential managers, then just return.
        //
        MPR_LOG0(TRACE,"MprMakeRetryArray: There aren't any Credential Managers\n");
        *lpNumProviders = 0;
        return(WN_SUCCESS);
    }

    *lpNumProviders = numProviders;

    //
    // Remove the primary authenticator from the list.
    //
    if (MprGetProviderIndex((LPTSTR)lpPrimaryAuthenticator,&primaryIndex)) {

        for (i=0; i<numProviders ;i++ ) {
            if (indexArray[i] == primaryIndex) {
                numProviders--;
                j=i;
                i++;
                for (; j<numProviders; i++,j++) {
                    indexArray[j] = indexArray[i];
                }
                break;
            }
        }
        //
        // If there are no credential managers aside from the primary, the
        // return with success.
        //
        *lpNumProviders = numProviders;
        if (numProviders == 0) {
            if (indexArray != localArray) {
                LocalFree(indexArray);
            }
            MPR_LOG0(TRACE,"MprMakeRetryArray: There aren't any "
                "Credential Managers aside from the Primary\n");
            return(WN_SUCCESS);
        }
    }

    //
    // At this point the indexArray only contains indices for Credential
    // Manager providers that are not the primary authenticator.
    //
    //
    // Now create an array of information about the providers so that we
    // can retry until timeout, or all providers are functional.  This
    // memory is expected to be initialized to  zero when allocated.
    //

    *lpRetryArray = (LPRETRY_INFO)LocalAlloc(LPTR, sizeof(RETRY_INFO) * numProviders);
    if (*lpRetryArray == NULL) {
        return(GetLastError());
    }
    for (i=0; i<numProviders; i++) {
        (*lpRetryArray)[i].Status = WN_NO_NETWORK;
        (*lpRetryArray)[i].ProviderIndex = indexArray[i];
        (*lpRetryArray)[i].ContinueFlag = TRUE;
    }

    if (indexArray != localArray) {
        LocalFree(indexArray);
    }

    //
    // Read the MaxWait value that is stored in the registry.
    // If it is not there or if the value is less than our default
    // maximum value, then use the default instead.
    //

    if(!MprOpenKey(
                HKEY_LOCAL_MACHINE,     // hKey
                NET_PROVIDER_KEY,       // lpSubKey
                &providerKeyHandle,     // Newly Opened Key Handle
                DA_READ)) {             // Desired Access

        MPR_LOG(ERROR,"MprCreateConnectionArray: MprOpenKey (%ws) Error\n",
            NET_PROVIDER_KEY);

        *lpRegMaxWait = 0;
        return(WN_SUCCESS);
    }
    MPR_LOG(TRACE,"OpenKey %ws\n",NET_PROVIDER_KEY);

    Temp = sizeof(*lpRegMaxWait);

    status = RegQueryValueEx(
                providerKeyHandle,
                RESTORE_WAIT_VALUE,
                NULL,
                &ValueType,
                (LPBYTE)lpRegMaxWait,
                &Temp);

    if (status != NO_ERROR) {
        *lpRegMaxWait = 0;
    }

    RegCloseKey(providerKeyHandle);

    return(WN_SUCCESS);
}

VOID
MprUpdateTimeout(
    LPRETRY_INFO    RetryInfo,
    LPPROVIDER      Provider,
    DWORD           RegMaxWait,
    LPDWORD         pMaxWait,
    DWORD           StartTime,
    DWORD           CallStatus
    )
/*++

Routine Description:

    This function attempts to get timeout information from the provider.
    If the provider will never start, the ContinueFlag in the RetryInfo is
    set to FALSE.  If the provider tells us how long we should wait, then
    MaxWait is updated if that time is longer than the current MaxWait.

Arguments:

    RetryInfo - This is a pointer to a structure that contains retry
        information for a particular provider.

    Provider - This is a pointer to a structure that contains dll
        entry points for a particular provider.

    RegMaxWait - This is the default timeout.  It is either the hard-coded
        timeout, or the timeout in the registry.

    pMaxWait - This is a pointer to a value that is the maximum amount of
        time that the router will wait for the provider to be ready to receive
        the function call.

    StartTime - This is the clock tick time that we started the operation with.

    CallStatus - This is the status from the most recent function call to the
        provider.

Return Value:

    none

--*/
{
    DWORD           ElapsedTime;
    DWORD           CurrentTime;
    DWORD           providerStatus;
    PF_NPGetCaps    pGetCaps;

    MPR_LOG0(TRACE,"Entering MprUpdateTimeout\n");

    ASSERT(MPRProviderLock.Have());

    //
    // First try the credential manager's GetCaps function.
    // if it doesn't exist, then use the network provider's
    // function.
    //
    pGetCaps = Provider->GetAuthentCaps;
    if (pGetCaps == NULL) {
        pGetCaps = Provider->GetCaps;
    }

    //
    // If this is the first pass through, we don't have the
    // wait times figured out for each provider.  Do that
    // now.
    //
    if (RetryInfo->ProviderWait == 0) {

        MPR_LOG1(TRACE,"Call GetCaps to get (%ws)provider start timeout\n",
                Provider->Resource.lpProvider);

        if (pGetCaps != NULL) {

            providerStatus = pGetCaps(WNNC_START);

            switch (providerStatus) {
            case PROVIDER_WILL_NOT_START:
                MPR_LOG0(TRACE,"Provider will not start\n");
                RetryInfo->ContinueFlag = FALSE;
                RetryInfo->Status = CallStatus;
                break;
            case NO_TIME_ESTIMATE:
                MPR_LOG0(TRACE,"No Time estimate for Provider start\n");
                if (RegMaxWait != 0) {
                    RetryInfo->ProviderWait = RegMaxWait;
                }
                else {
                    RetryInfo->ProviderWait = DEFAULT_WAIT_TIME;
                }
                if (*pMaxWait < RetryInfo->ProviderWait) {
                    *pMaxWait = RetryInfo->ProviderWait;
                }
                break;
            default:

                MPR_LOG1(TRACE,"Time estimate for Provider start = %d\n",
                    providerStatus);
                //
                // In this case, the providerStatus is actually
                // the amount of time we should wait for this
                // provider.  We set MaxWait to the longest of
                // the times specified by the providers.
                //
                if ((providerStatus <= MAX_ALLOWED_WAIT_TIME) &&
                    (providerStatus > *pMaxWait)) {
                        *pMaxWait = providerStatus;
                }
                RetryInfo->ProviderWait = *pMaxWait;
                break;
            }
        }
        else {
            MPR_LOG0(TRACE,"There is no GetCaps function.  So we cannot "
                "obtain the provider start timeout\n");
            RetryInfo->ContinueFlag = FALSE;
            RetryInfo->Status = CallStatus;
        }
    }
    //
    // If the status for this provider has just changed to
    // WN_FUNCTION_BUSY from some other status, then calculate
    // a timeout time by getting the provider's new timeout
    // and adding that to the elapsed time since start.  This
    // gives a total elapsed time until timeout - which can
    // be compared with the current MaxWait.
    //
    if ((CallStatus == WN_FUNCTION_BUSY) &&
        (RetryInfo->Status == WN_NO_NETWORK)) {

        MPR_LOG1(TRACE,"Provider status just changed to FUNCTION_BUSY "
            "from some other status - Call GetCaps to get (%ws)provider "
            " start timeout\n",
            Provider->Resource.lpProvider);

        if (pGetCaps != NULL) {
            providerStatus = pGetCaps(WNNC_START);
            switch (providerStatus) {
            case PROVIDER_WILL_NOT_START:
                MPR_LOG0(TRACE,"Provider will not start - bizzare case\n");
                //
                // This is bizzare to find the status = BUSY,
                // and then have the Provider not starting.
                //
                RetryInfo->ContinueFlag = FALSE;
                break;
            case NO_TIME_ESTIMATE:
                MPR_LOG0(TRACE,"No Time estimate for Provider start\n");
                //
                // No need to alter the timeout for this one.
                //
                break;
            default:
                MPR_LOG1(TRACE,"Time estimate for Provider start = %d\n",
                    providerStatus);
                //
                // Make sure this new timeout information will take
                // less than the maximum allowed time for
                // providers.
                //
                if (providerStatus <= MAX_ALLOWED_WAIT_TIME) {
                    CurrentTime = GetTickCount();
                    //
                    // Determine how much time has elapsed since
                    // we started.
                    //
                    ElapsedTime = CurrentTime - StartTime;

                    //
                    // Add the Elapsed time to the new timeout
                    // we just received from the provider to come
                    // up with a timeout value that can be
                    // compared with MaxWait.
                    //
                    providerStatus += ElapsedTime;

                    //
                    // If the new timeout is larger than MaxWait,
                    // then use the new timeout.
                    //
                    if (providerStatus > *pMaxWait) {
                        *pMaxWait = providerStatus;
                    }
                } // EndIf (Make sure time out is < max allowed).
                break;

            } // End Switch (changed status).
        }

    } // End If (change state from NO_NET to BUSY)

    //
    // Store the status (either NO_NET or BUSY) with the
    // retry info.
    //
    RetryInfo->Status = CallStatus;

    MPR_LOG0(TRACE,"Leaving MprUpdateTimeout\n");
    return;
}

VOID
MprCheckTimeout(
    BOOL    *ContinueFlag,
    DWORD   StartTime,
    DWORD   MaxWait,
    LPDWORD lpStatus
    )

/*++

Routine Description:

    This function checks to see if a timeout occured.

Arguments:

    ContinueFlag - This is a pointer to the location of the continue flag.
        This is set to FALSE if a timeout occured.

    StartTime - This is the tick count at the beginning of the operation.

    lpStatus - This is a pointer to the current status for the operation.
        This is updated only if a timeout occurs.

Return Value:

    none

--*/
{
    DWORD   CurrentTime;
    DWORD   ElapsedTime;

    MPR_LOG0(TRACE,"Entering MprCheckTimeout\n");
    if (*ContinueFlag) {
        //
        // Determine what the elapsed time from the start is.
        //
        CurrentTime = GetTickCount();
        ElapsedTime = CurrentTime - StartTime;

        //
        // If a timeout occured, then don't continue.  Otherwise, sleep
        // for a bit and loop again through all providers.
        //
        if (ElapsedTime > MaxWait) {
            MPR_LOG0(TRACE,"WNetLogonNotify:Timed out while waiting "
                "for Credential Managers\n");
            *ContinueFlag = FALSE;
            *lpStatus = ERROR_SERVICE_REQUEST_TIMEOUT;
        }
        else {
            Sleep(2000);
        }
    }
    MPR_LOG0(TRACE,"Leaving MprCheckTimeout\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\winnet\enum.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    enum.cxx

Abstract:

    Contains the entry points for the WinNet Enum API supported by the
    Multi-Provider Router.  The following functions are in this file:

        WNetOpenEnumW
        WNetEnumResourceW
        WNetCloseEnum

        MprOpenEnumConnect
        MprOpenEnumNetwork
        MprEnumConnect
        MprEnumNetwork
        MprProviderEnum
        MprCopyResource
        MprCopyProviderEnum
        MprProviderOpen
        MprOpenRemember
        MprEnumRemembered
        MprMultiStrBuffSize


Author:

    Dan Lafferty (danl)     14-Oct-1991

Environment:

    User Mode -Win32

Notes:


Revision History:

    14-Oct-1991     danl
        created

    21-Sep-1992     KeithMo
        Handle odd-sized buffers.

    02-Nov-1992     danl
        Fail with NO_NETWORK if there are no providers.

    02-Mar-1995     anirudhs
        Add support for RESOURCE_CONTEXT.

    17-Jul-1995     anirudhs
        Add recognition (but not true support) of RESOURCE_RECENT.
        Clean up code for detecting top-level enum.

    03-Aug-1995     anirudhs
        WNetEnumResourceW: Allow a *lpcCount of 0.

    15-Sep-1995     anirudhs
        MprEnumRemembered: Fail after all resources have been enumerated.

    24-Sep-1995     anirudhs
        Add support for customization of the RESOURCE_CONTEXT enumeration
        based on policy settings.

    11-Apr-1996     anirudhs
        Use CRoutedOperation in one case of WNetOpenEnumW.

    16-Mar-1999     jschwart
        Add support for RESOURCE_SHAREABLE

    05-May-1999     jschwart
        Make provider addition/removal dynamic

--*/
//
// INCLUDES
//
#include "precomp.hxx"

#include <memory.h>     // memcpy
#include <lmcons.h>     // needed for netlib.h
#include <tstring.h>    // STRLEN
#include <regstr.h>     // Registry keys and value names

//
// EXTERNALS
//

    extern  DWORD       GlobalNumActiveProviders;
    extern  HMODULE     hDLL;

//
// DATA STRUCTURES
//

//
// "Manually" align headers and put pointers first in ENUM
// structures to avoid Win64 alignment faults.  Keep Key as
// the first field in the header so MPR knows where to check
// to see what type of enum it is.
//
typedef struct  _CONNECT_HEADER
{
    DWORD       Key;
    DWORD       ReturnRoot;
    DWORD       dwNumProviders;
    DWORD       dwNumActiveProviders;
}
CONNECT_HEADER, *LPCONNECT_HEADER;

typedef struct  _CONNECT_ENUM
{
    HANDLE              ProviderEnumHandle;
    HINSTANCE           hProviderDll;        // Refcount the provider DLL
    PF_NPEnumResource   pfEnumResource;
    PF_NPCloseEnum      pfCloseEnum;
    DWORD               State;

}
CONNECT_ENUM, *LPCONNECT_ENUM;

typedef struct _NETWORK_HEADER
{
    DWORD               Key;
    DWORD               dwNumProviders;
    DWORD               dwNumActiveProviders;
    DWORD               dwPad;
}
NETWORK_HEADER, *LPNETWORK_HEADER;

typedef struct _NETWORK_ENUM
{
    HINSTANCE           hProviderDll;
    LPNETRESOURCE       lpnr;
    DWORD               State;
}
NETWORK_ENUM, *LPNETWORK_ENUM;

typedef struct  _ENUM_HANDLE
{
    DWORD               Key;
    DWORD               dwPad;
    HANDLE              EnumHandle;
    HINSTANCE           hProviderDll;
    PF_NPEnumResource   pfEnumResource;
    PF_NPCloseEnum      pfCloseEnum;
}
ENUM_HANDLE, *LPENUM_HANDLE;

typedef struct _REMEMBER_HANDLE
{
    DWORD       Key;
    DWORD       dwPad;
    HKEY        ConnectKey;
    DWORD       KeyIndex;
    DWORD       ConnectionType;
}
REMEMBER_HANDLE, *LPREMEMBER_HANDLE;

//
// CONSTANTS
//
#define DONE                1
#define MORE_ENTRIES        2
#define NOT_OPENED          3
#define CONNECT_TABLE_KEY   0x6e6e4f63  // "cOnn"
#define STATE_TABLE_KEY     0x74417473  // "stAt"
#define PROVIDER_ENUM_KEY   0x764f7270  // "prOv"
#define REMEMBER_KEY        0x626D4572  // "rEmb"
#define REGSTR_PATH_NETWORK_POLICIES    \
            REGSTR_PATH_POLICIES L"\\" REGSTR_KEY_NETWORK

//
//  Macros for rounding a value up/down to a WCHAR boundary.
//  Note:  These macros assume that sizeof(WCHAR) is a power of 2.
//

#define ROUND_DOWN(x)   ((x) & ~(sizeof(WCHAR) - 1))
#define ROUND_UP(x)     (((x) + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1))


//
// LOCAL FUNCTION PROTOTYPES
//

DWORD
MprCopyProviderEnum(
    IN      LPNETRESOURCEW  ProviderBuffer,
    IN OUT  LPDWORD         EntryCount,
    IN OUT  LPBYTE          *TempBufPtr,
    IN OUT  LPDWORD         BytesLeft
    );

DWORD
MprCopyResource(
    IN OUT  LPBYTE          *BufPtr,
    IN const NETRESOURCEW   *Resource,
    IN OUT  LPDWORD         BytesLeft
    );

DWORD
MprEnumNetwork(
    IN OUT  LPNETWORK_HEADER     StateTable,
    IN OUT  LPDWORD              NumEntries,
    IN OUT  LPVOID               lpBuffer,
    IN OUT  LPDWORD              lpBufferSize
    );

DWORD
MprEnumConnect(
    IN OUT  LPCONNECT_HEADER    ConnectEnumHeader,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPVOID              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    );

DWORD
MprOpenEnumNetwork(
    OUT LPHANDLE    lphEnum
    );

DWORD
MprOpenEnumConnect(
    IN  DWORD          dwScope,
    IN  DWORD          dwType,
    IN  DWORD          dwUsage,
    IN  LPNETRESOURCE  lpNetResource,
    OUT LPHANDLE       lphEnum
    );

DWORD
MprProviderEnum(
    IN      LPENUM_HANDLE   EnumHandlePtr,
    IN OUT  LPDWORD         lpcCount,
    IN      LPVOID          lpBuffer,
    IN OUT  LPDWORD         lpBufferSize
    );

DWORD
MprOpenRemember(
    IN  DWORD       dwType,
    OUT LPHANDLE    lphRemember
    );

DWORD
MprEnumRemembered(
    IN OUT  LPREMEMBER_HANDLE   RememberInfo,
    IN OUT  LPDWORD             NumEntries,
    IN OUT  LPBYTE              lpBuffer,
    IN OUT  LPDWORD             lpBufferSize
    );

DWORD
MprMultiStrBuffSize(
    IN      LPTSTR      lpString1,
    IN      LPTSTR      lpString2,
    IN      LPTSTR      lpString3,
    IN      LPTSTR      lpString4,
    IN      LPTSTR      lpString5
    ) ;

class CProviderOpenEnum : public CRoutedOperation
{
public:
                    CProviderOpenEnum(
                        DWORD           dwScope,
                        DWORD           dwType,
                        DWORD           dwUsage,
                        LPNETRESOURCEW  lpNetResource,
                        LPHANDLE        lphEnum
                        ) :
                            CRoutedOperation(DBGPARM("ProviderOpenEnum")
                                             PROVIDERFUNC(OpenEnum)),
                            _dwScope      (dwScope      ),
                            _dwType       (dwType       ),
                            _dwUsage      (dwUsage      ),
                            _lpNetResource(lpNetResource),
                            _lphEnum      (lphEnum      )
                        { }

protected:

    DWORD           GetResult();    // overrides CRoutedOperation implementation

private:

    DWORD           _dwScope;
    DWORD           _dwType;
    DWORD           _dwUsage;
    LPNETRESOURCEW  _lpNetResource;
    LPHANDLE        _lphEnum;

    HANDLE          _ProviderEnumHandle; // Enum handle returned by provider

    DECLARE_CROUTED
};


DWORD
WNetOpenEnumW (
    IN  DWORD           dwScope,
    IN  DWORD           dwType,
    IN  DWORD           dwUsage,
    IN  LPNETRESOURCEW  lpNetResource,
    OUT LPHANDLE        lphEnum
    )
/*++

Routine Description:

    This API is used to open an enumeration of network resources or existing
    connections.  It must be called to obtain a valid handle for enumeration.

    NOTE:
    For GlobalNet Enum, the caller must get a new handle for each level that
    is desired.  For the other scopes, the caller gets a single handle and
    with that can enumerate all resources.


Arguments:

    dwScope - Determines the scope of the enumeration.  This can be one of:
        RESOURCE_CONNECTED - All Currently connected resources.
        RESOURCE_GLOBALNET - All resources on the network.
        RESOURCE_REMEMBERED - All persistent connections.
        RESOURCE_RECENT - Same as RESOURCE_REMEMBERED (supported for Win95
            semi-compatibility)
        RESOURCE_CONTEXT - The resources associated with the user's current
            and default network context (as defined by the providers).
        RESOURCE_SHAREABLE - All shareable resources on the given server

    dwType - Used to specify the type of resources on interest.  This is a
        bitmask which may be any combination of:
            RESOURCETYPE_DISK - All disk resources
            RESOURCETYPE_PRINT - All print resources
        If this is 0. all types of resources are returned.  If a provider does
        not have the capability to distinguish between print and disk
        resources at a level, it may return all resources.

    dwUsage - Used to specify the usage of resources of interest.  This is a
        bitmask which may be any combination of:
            RESOURCEUSAGE_CONNECTABLE - all connectable resources.
            RESOURCEUSAGE_CONTAINER - all container resources.
        The bitmask may be 0 to match all.

    lpNetResource - This specifies the container to perform the enumeration.
        If it is NULL, the logical root of the network is assumed, and the
        router is responsible for obtaining the information for return.

    lphEnum - If the Open was successful, this will contain a handle that
        can be used for future calls to WNetEnumResource.

Return Value:

    WN_SUCCESS - Indicates the operation was successful.

    WN_NOT_CONTAINER - Indicates that lpNetResource does not point to a
        container.

    WN_BAD_VALUE - Invalid dwScope or dwType, or bad combination of parameters
        is specified.

    WN_NO_NETWORK - network is not present.

--*/
{
    DWORD   status = WN_SUCCESS;

    //
    // dwScope MUST be set to either GLOBALNET or CONNECTED or REMEMBERED
    // or RECENT or CONTEXT or SHAREABLE.
    // This is verified in the switch statement below.
    //

    //
    // dwType is a bit mask that can have any combination of the DISK
    // or PRINT bits set.  Or it can be the value 0.
    //
    if (dwType & ~(RESOURCETYPE_DISK | RESOURCETYPE_PRINT)) {
        status = WN_BAD_VALUE;
        goto CleanExit;
    }

    //
    // dwUsage is a bit mask that can have any combination of the CONNECTABLE
    // or CONTAINER bits set.  Or it can be the value 0.  This field is
    // ignored if dwScope is not RESOURCE_GLOBALNET.
    //
    if (dwScope == RESOURCE_GLOBALNET) {
        if (dwUsage & ~(RESOURCEUSAGE_ALL)) {
            status = WN_BAD_VALUE;
            goto CleanExit;
        }
    }

    //
    // Make sure the user passed in a valid OUT parameter
    //
    __try
    {
        PROBE_FOR_WRITE((LPDWORD)lphEnum);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS)
    {
        goto CleanExit;
    }

    //
    // Check to see if it is a top-level enum request.
    //
    if (lpNetResource == NULL
         ||
        (IS_EMPTY_STRING(lpNetResource->lpProvider) &&
         IS_EMPTY_STRING(lpNetResource->lpRemoteName))
         ||
        dwScope == RESOURCE_SHAREABLE)
    {
        //
        // lpNetResource is NULL or represents no resource or this is
        // a request for shareable resources.
        // This is a top-level enum request, therefore, the MPR must provide
        // the information.
        //
        switch(dwScope) {

        case RESOURCE_CONNECTED:
        case RESOURCE_CONTEXT:
        case RESOURCE_SHAREABLE:
        {
            MprCheckProviders();

            CProviderSharedLock    PLock;

            INIT_IF_NECESSARY(NETWORK_LEVEL,status);

            if (MprNetIsAvailable()) {
                status = MprOpenEnumConnect(dwScope,
                                            dwType,
                                            dwUsage,
                                            lpNetResource,
                                            lphEnum);
            }
            else
                status = WN_NO_NETWORK ;
            break;
        }

        case RESOURCE_GLOBALNET:
        {
            MprCheckProviders();

            CProviderSharedLock    PLock;

            INIT_IF_NECESSARY(NETWORK_LEVEL,status);

            if (MprNetIsAvailable()) {
                status = MprOpenEnumNetwork(lphEnum);
            }
            else
                status = WN_NO_NETWORK ;
            break;
        }

        case RESOURCE_REMEMBERED:
        case RESOURCE_RECENT:
            MPR_LOG(TRACE,"OpenEnum RESOURCE_REMEMBERED\n",0);
            status = MprOpenRemember(dwType, lphEnum);
            break;

        default:
            status = WN_BAD_VALUE;
            break;
        }
    }
    else {
        //
        // Request is for one of the providers.  It should be for a
        // GLOBALNET enumeration.  It is not allowed to request any
        // other type of enumeration with a pointer to a resource
        // buffer.
        //
        if (dwScope != RESOURCE_GLOBALNET) {
            status = WN_BAD_VALUE;
            goto CleanExit;
        }

        CProviderOpenEnum ProviderOpenEnum(
                        dwScope,
                        dwType,
                        dwUsage,
                        lpNetResource,
                        lphEnum);

        status = ProviderOpenEnum.Perform(TRUE);
    }

CleanExit:
    if (status != WN_SUCCESS) {
        SetLastError(status);
    }
    return(status);
}

DWORD
WNetEnumResourceW (
    IN      HANDLE  hEnum,
    IN OUT  LPDWORD lpcCount,
    OUT     LPVOID  lpBuffer,
    IN OUT  LPDWORD lpBufferSize
    )

/*++

Routine Description:

    This function is used to obtain an array of NETRESOURCE structures each
    of which describes a network resource.

Arguments:

    hEnum - This is a handle that was obtained from an WNetOpenEnum call.

    lpcCount - Specifies the number of entries requested.  -1 indicates
        as many entries as possible are requested.  If the operation is
        successful, this location will receive the number of entries
        actually read.

    lpBuffer - A pointer to the buffer to receive the enumeration result,
        which are returned as an array of NETRESOURCE entries.  The buffer
        is valid until the next call using hEnum.

    lpBufferSize - This specifies the size of the buffer passed to the function
        call.  It will contain the required buffer size if WN_MORE_DATA is
        returned.

Return Value:

    WN_SUCCESS - Indicates that the call is successful, and that the caller
        should continue to call WNetEnumResource to continue the enumeration.

    WN_NO_MORE_ENTRIES - Indicates that the enumeration completed successfully.

    The following return codes indicate an error occured and GetLastError
    may be used to obtain another copy of the error code:

    WN_MORE_DATA - Indicates that the buffer is too small for even one
        entry.

    WN_BAD_HANDLE - hEnum is not a valid handle.

    WN_NO_NETWORK - The Network is not present.  This condition is checked
        for before hEnum is tested for validity.

History:
    12-Feb-1992     Johnl   Removed requirement that buffersize must be at
                least as large as NETRESOURCEW (bug 5790)


--*/
{
    DWORD   status = WN_SUCCESS;

    //
    // Screen the parameters as best we can.
    //

    //
    // Probe the handle
    //
    __try {
        *(volatile DWORD *)hEnum;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetEnumResource:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_HANDLE;
    }

    __try {
        PROBE_FOR_WRITE(lpcCount);

        if (IS_BAD_BYTE_BUFFER(lpBuffer, lpBufferSize)) {
            status = WN_BAD_POINTER;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        status = GetExceptionCode();
        if (status != EXCEPTION_ACCESS_VIOLATION) {
            MPR_LOG(ERROR,"WNetEnumResource:Unexpected Exception 0x%lx\n",status);
        }
        status = WN_BAD_POINTER;
    }

    if (status != WN_SUCCESS) {
        goto CleanExit;
    }

    switch(*(LPDWORD)hEnum){

    case CONNECT_TABLE_KEY:
        //
        // Call on Providers to enumerate connections.
        //

        status = MprEnumConnect(
                    (LPCONNECT_HEADER)hEnum,    // key is part of structure
                    lpcCount,
                    lpBuffer,
                    lpBufferSize);
        break;

    case STATE_TABLE_KEY:
        //
        // Enumerate the top level NetResource structure maintained by
        // the router.
        //

        status = MprEnumNetwork(
                    (LPNETWORK_HEADER)hEnum,
                    lpcCount,
                    lpBuffer,
                    lpBufferSize);
        break;

    case PROVIDER_ENUM_KEY:
        //
        // Call on providers to enumerate resources on the network.
        //

        status = MprProviderEnum(
                    (LPENUM_HANDLE)hEnum,       // key is part of structure
                    lpcCount,
                    lpBuffer,
                    lpBufferSize);
        break;
    case REMEMBER_KEY:

        //
        // Enumerate the connections in the current user section of the
        // registry.
        //

        status = MprEnumRemembered(
                    (LPREMEMBER_HANDLE)hEnum,
                    lpcCount,
                    (LPBYTE)lpBuffer,
                    lpBufferSize);
        break;
    default:
        status = WN_BAD_HANDLE;
    }

CleanExit:
    if(status != WN_SUCCESS) {
        SetLastError(status);
    }
    return(status);
}


DWORD
WNetCloseEnum (
    IN HANDLE   hEnum
    )

/*++

Routine Description:

    Closes an enumeration handle that is owned by the router.
    In cases where the router is acting as a proxy for a single provider,
    an attempt is made to return any error information from this provider
    back to the user.  This makes the router as transparent as possible.

Arguments:

    hEnum - This must be a handle obtained from a call to WNetOpenEnum.

Return Value:

    WN_SUCCESS - The operation was successful.

    WN_NO_NETWORK - The Network is not present.  T