me(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay2_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)

#else /* C++ */

#define IDirectPlay2_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay2_AddRef(p)                      (p)->AddRef()
#define IDirectPlay2_Release(p)                     (p)->Release()
#define IDirectPlay2_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay2_Close(p)                       (p)->Close()
#define IDirectPlay2_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay2_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay2_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay2_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay2_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay2_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay2_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay2_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay2_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay2_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay2_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay2_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay2_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay2_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay2_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay2_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay2_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay2_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay2_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay2_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay2_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay2_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay2_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay2_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay2_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay2_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay2_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay3 (and IDirectPlay3A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay3
DECLARE_INTERFACE_( IDirectPlay3, IDirectPlay2 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
	STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
	STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
	STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
	STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
	STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
	STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
	STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlay3 interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay3_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlay3_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay3_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay3_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)

#else /* C++ */

#define IDirectPlay3_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlay3_AddRef(p)                      (p)->AddRef()
#define IDirectPlay3_Release(p)                     (p)->Release()
#define IDirectPlay3_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlay3_Close(p)                       (p)->Close()
#define IDirectPlay3_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlay3_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlay3_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay3_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlay3_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlay3_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlay3_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlay3_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay3_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay3_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlay3_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlay3_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlay3_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlay3_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlay3_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlay3_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlay3_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlay3_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlay3_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlay3_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlay3_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlay3_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlay3_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlay3_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlay3_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlay3_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlay3_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlay3_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlay3_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlay3_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlay3_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlay3_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlay3_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlay3_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlay3_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlay3_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlay3_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlay3_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlay3_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlay3_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlay3_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlay3_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)

#endif

/****************************************************************************
 *
 * IDirectPlay4 (and IDirectPlay4A) Interface
 *
 ****************************************************************************/

#undef INTERFACE
#define INTERFACE IDirectPlay4
DECLARE_INTERFACE_( IDirectPlay4, IDirectPlay3 )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay2 methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPDPNAME,HANDLE,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC2,DWORD,LPDPENUMSESSIONSCALLBACK2,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetGroupData)         (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetGroupName)         (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerAddress)     (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID,LPDPCAPS,DWORD) PURE;
    STDMETHOD(GetPlayerData)        (THIS_ DPID,LPVOID,LPDWORD,DWORD) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSessionDesc)       (THIS_ LPVOID,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetGroupData)         (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetGroupName)         (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetPlayerData)        (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPDPNAME,DWORD) PURE;
    STDMETHOD(SetSessionDesc)       (THIS_ LPDPSESSIONDESC2,DWORD) PURE;
    /*** IDirectPlay3 methods ***/
    STDMETHOD(AddGroupToGroup)      (THIS_ DPID, DPID) PURE;
    STDMETHOD(CreateGroupInGroup)   (THIS_ DPID,LPDPID,LPDPNAME,LPVOID,DWORD,DWORD) PURE;
    STDMETHOD(DeleteGroupFromGroup)	(THIS_ DPID,DPID) PURE;	
    STDMETHOD(EnumConnections)     	(THIS_ LPCGUID,LPDPENUMCONNECTIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroupsInGroup)	(THIS_ DPID,LPGUID,LPDPENUMPLAYERSCALLBACK2,LPVOID,DWORD) PURE;
	STDMETHOD(GetGroupConnectionSettings)(THIS_ DWORD, DPID, LPVOID, LPDWORD) PURE;
	STDMETHOD(InitializeConnection) (THIS_ LPVOID,DWORD) PURE;
    STDMETHOD(SecureOpen)           (THIS_ LPCDPSESSIONDESC2,DWORD,LPCDPSECURITYDESC,LPCDPCREDENTIALS) PURE;
    STDMETHOD(SendChatMessage)      (THIS_ DPID,DPID,DWORD,LPDPCHAT) PURE;
    STDMETHOD(SetGroupConnectionSettings)(THIS_ DWORD,DPID,LPDPLCONNECTION) PURE;
    STDMETHOD(StartSession)         (THIS_ DWORD,DPID) PURE;
    STDMETHOD(GetGroupFlags)        (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetGroupParent)       (THIS_ DPID,LPDPID) PURE;
    STDMETHOD(GetPlayerAccount)     (THIS_ DPID, DWORD, LPVOID, LPDWORD) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    /*** IDirectPlay4 methods ***/
    STDMETHOD(GetGroupOwner)        (THIS_ DPID, LPDPID) PURE;
    STDMETHOD(SetGroupOwner)        (THIS_ DPID, DPID) PURE;
    STDMETHOD(SendEx)               (THIS_ DPID, DPID, DWORD, LPVOID, DWORD, DWORD, DWORD, LPVOID, DWORD_PTR *) PURE;
    STDMETHOD(GetMessageQueue)      (THIS_ DPID, DPID, DWORD, LPDWORD, LPDWORD) PURE;
    STDMETHOD(CancelMessage)        (THIS_ DWORD, DWORD) PURE;
    STDMETHOD(CancelPriority)       (THIS_ DWORD, DWORD, DWORD) PURE;
};

/****************************************************************************
 *
 * IDirectPlayX interface macros (for IDirectPlay4 and beyond)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlayX_AddRef(p)                      (p)->lpVtbl->AddRef(p)
#define IDirectPlayX_Release(p)                     (p)->lpVtbl->Release(p)
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->lpVtbl->CancelMessage(p,a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->lpVtbl->CancelPriority(p,a,b,c)
#define IDirectPlayX_Close(p)                       (p)->lpVtbl->Close(p)
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->lpVtbl->CreateGroup(p,a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->lpVtbl->CreatePlayer(p,a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->lpVtbl->GetCaps(p,a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->lpVtbl->GetMessageQueue(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->lpVtbl->GetGroupData(p,a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->lpVtbl->GetGroupName(p,a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->lpVtbl->GetPlayerAddress(p,a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->lpVtbl->GetPlayerCaps(p,a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->lpVtbl->GetPlayerData(p,a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->lpVtbl->GetPlayerName(p,a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->lpVtbl->GetSessionDesc(p,a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->lpVtbl->Initialize(p,a)
#define IDirectPlayX_Open(p,a,b)                    (p)->lpVtbl->Open(p,a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->lpVtbl->SendEx(p,a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->lpVtbl->SetGroupData(p,a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->lpVtbl->SetGroupName(p,a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->lpVtbl->SetPlayerData(p,a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->lpVtbl->SetPlayerName(p,a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->lpVtbl->SetSessionDesc(p,a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->lpVtbl->AddGroupToGroup(p,a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->lpVtbl->CreateGroupInGroup(p,a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->lpVtbl->DeleteGroupFromGroup(p,a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d) 	(p)->lpVtbl->EnumConnections(p,a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->lpVtbl->EnumGroupsInGroup(p,a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->lpVtbl->GetGroupConnectionSettings(p,a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b) 	(p)->lpVtbl->InitializeConnection(p,a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->lpVtbl->SecureOpen(p,a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->lpVtbl->SendChatMessage(p,a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->lpVtbl->SetGroupConnectionSettings(p,a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->lpVtbl->StartSession(p,a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->lpVtbl->GetGroupFlags(p,a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->lpVtbl->GetGroupParent(p,a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->lpVtbl->GetPlayerAccount(p,a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->lpVtbl->GetPlayerFlags(p,a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->lpVtbl->GetGroupOwner(p,a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->lpVtbl->SetGroupOwner(p,a,b)

#else /* C++ */

#define IDirectPlayX_QueryInterface(p,a,b)          (p)->QueryInterface(a,b)
#define IDirectPlayX_AddRef(p)                      (p)->AddRef()
#define IDirectPlayX_Release(p)                     (p)->Release()
#define IDirectPlayX_AddPlayerToGroup(p,a,b)        (p)->AddPlayerToGroup(a,b)
#define IDirectPlayX_CancelMessage(p,a,b)           (p)->CancelMessage(a,b)
#define IDirectPlayX_CancelPriority(p,a,b,c)        (p)->CancelPriority(a,b,c)
#define IDirectPlayX_Close(p)                       (p)->Close()
#define IDirectPlayX_CreateGroup(p,a,b,c,d,e)       (p)->CreateGroup(a,b,c,d,e)
#define IDirectPlayX_CreatePlayer(p,a,b,c,d,e,f)    (p)->CreatePlayer(a,b,c,d,e,f)
#define IDirectPlayX_DeletePlayerFromGroup(p,a,b)   (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlayX_DestroyGroup(p,a)              (p)->DestroyGroup(a)
#define IDirectPlayX_DestroyPlayer(p,a)             (p)->DestroyPlayer(a)
#define IDirectPlayX_EnumGroupPlayers(p,a,b,c,d,e)  (p)->EnumGroupPlayers(a,b,c,d,e)
#define IDirectPlayX_EnumGroups(p,a,b,c,d)          (p)->EnumGroups(a,b,c,d)
#define IDirectPlayX_EnumPlayers(p,a,b,c,d)         (p)->EnumPlayers(a,b,c,d)
#define IDirectPlayX_EnumSessions(p,a,b,c,d,e)      (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlayX_GetCaps(p,a,b)                 (p)->GetCaps(a,b)
#define IDirectPlayX_GetMessageCount(p,a,b)         (p)->GetMessageCount(a,b)
#define IDirectPlayX_GetMessageQueue(p,a,b,c,d,e)   (p)->GetMessageQueue(a,b,c,d,e)
#define IDirectPlayX_GetGroupData(p,a,b,c,d)        (p)->GetGroupData(a,b,c,d)
#define IDirectPlayX_GetGroupName(p,a,b,c)          (p)->GetGroupName(a,b,c)
#define IDirectPlayX_GetPlayerAddress(p,a,b,c)      (p)->GetPlayerAddress(a,b,c)
#define IDirectPlayX_GetPlayerCaps(p,a,b,c)         (p)->GetPlayerCaps(a,b,c)
#define IDirectPlayX_GetPlayerData(p,a,b,c,d)       (p)->GetPlayerData(a,b,c,d)
#define IDirectPlayX_GetPlayerName(p,a,b,c)         (p)->GetPlayerName(a,b,c)
#define IDirectPlayX_GetSessionDesc(p,a,b)          (p)->GetSessionDesc(a,b)
#define IDirectPlayX_Initialize(p,a)                (p)->Initialize(a)
#define IDirectPlayX_Open(p,a,b)                    (p)->Open(a,b)
#define IDirectPlayX_Receive(p,a,b,c,d,e)           (p)->Receive(a,b,c,d,e)
#define IDirectPlayX_Send(p,a,b,c,d,e)              (p)->Send(a,b,c,d,e)
#define IDirectPlayX_SendEx(p,a,b,c,d,e,f,g,h,i)    (p)->SendEx(a,b,c,d,e,f,g,h,i)
#define IDirectPlayX_SetGroupData(p,a,b,c,d)        (p)->SetGroupData(a,b,c,d)
#define IDirectPlayX_SetGroupName(p,a,b,c)          (p)->SetGroupName(a,b,c)
#define IDirectPlayX_SetPlayerData(p,a,b,c,d)       (p)->SetPlayerData(a,b,c,d)
#define IDirectPlayX_SetPlayerName(p,a,b,c)         (p)->SetPlayerName(a,b,c)
#define IDirectPlayX_SetSessionDesc(p,a,b)          (p)->SetSessionDesc(a,b)
#define IDirectPlayX_AddGroupToGroup(p,a,b) 		(p)->AddGroupToGroup(a,b)
#define IDirectPlayX_CreateGroupInGroup(p,a,b,c,d,e,f) (p)->CreateGroupInGroup(a,b,c,d,e,f)
#define IDirectPlayX_DeleteGroupFromGroup(p,a,b)   	(p)->DeleteGroupFromGroup(a,b)
#define IDirectPlayX_EnumConnections(p,a,b,c,d)     (p)->EnumConnections(a,b,c,d)
#define IDirectPlayX_EnumGroupsInGroup(p,a,b,c,d,e) (p)->EnumGroupsInGroup(a,b,c,d,e)
#define IDirectPlayX_GetGroupConnectionSettings(p,a,b,c,d) (p)->GetGroupConnectionSettings(a,b,c,d)
#define IDirectPlayX_InitializeConnection(p,a,b)    (p)->InitializeConnection(a,b)
#define IDirectPlayX_SecureOpen(p,a,b,c,d)          (p)->SecureOpen(a,b,c,d)
#define IDirectPlayX_SendChatMessage(p,a,b,c,d)     (p)->SendChatMessage(a,b,c,d)
#define IDirectPlayX_SetGroupConnectionSettings(p,a,b,c) (p)->SetGroupConnectionSettings(a,b,c)
#define IDirectPlayX_StartSession(p,a,b)            (p)->StartSession(a,b)
#define IDirectPlayX_GetGroupFlags(p,a,b)           (p)->GetGroupFlags(a,b)
#define IDirectPlayX_GetGroupParent(p,a,b)          (p)->GetGroupParent(a,b)
#define IDirectPlayX_GetPlayerAccount(p,a,b,c,d)    (p)->GetPlayerAccount(a,b,c,d)
#define IDirectPlayX_GetPlayerFlags(p,a,b)          (p)->GetPlayerFlags(a,b)
#define IDirectPlayX_GetGroupOwner(p,a,b)           (p)->GetGroupOwner(a,b)
#define IDirectPlayX_SetGroupOwner(p,a,b)           (p)->SetGroupOwner(a,b)

#endif

/****************************************************************************
 *
 * EnumConnections API flags
 *
 ****************************************************************************/

/*
 * Enumerate Service Providers
 */
#define DPCONNECTION_DIRECTPLAY      0x00000001

/*
 * Enumerate Lobby Providers
 */
#define DPCONNECTION_DIRECTPLAYLOBBY 0x00000002


/****************************************************************************
 *
 * EnumPlayers API flags
 *
 ****************************************************************************/

/*
 * Enumerate all players in the current session
 */
#define DPENUMPLAYERS_ALL           0x00000000
#define DPENUMGROUPS_ALL            DPENUMPLAYERS_ALL

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPENUMPLAYERS_PREVIOUS   0x00000004
 */
//@@END_MSINTERNAL

/*
 * Enumerate only local (created by this application) players
 * or groups
 */
#define DPENUMPLAYERS_LOCAL         0x00000008
#define DPENUMGROUPS_LOCAL			DPENUMPLAYERS_LOCAL

/*
 * Enumerate only remote (non-local) players
 * or groups
 */
#define DPENUMPLAYERS_REMOTE        0x00000010
#define DPENUMGROUPS_REMOTE			DPENUMPLAYERS_REMOTE

/*
 * Enumerate groups along with the players
 */
#define DPENUMPLAYERS_GROUP         0x00000020

/*
 * Enumerate players or groups in another session 
 * (must supply lpguidInstance)
 */
#define DPENUMPLAYERS_SESSION       0x00000080
#define DPENUMGROUPS_SESSION		DPENUMPLAYERS_SESSION

/*
 * Enumerate server players
 */
#define DPENUMPLAYERS_SERVERPLAYER  0x00000100

/*
 * Enumerate spectator players
 */
#define DPENUMPLAYERS_SPECTATOR     0x00000200

/*
 * Enumerate shortcut groups
 */
#define DPENUMGROUPS_SHORTCUT       0x00000400

/*
 * Enumerate staging area groups
 */
#define DPENUMGROUPS_STAGINGAREA    0x00000800

/*
 * Enumerate hidden groups
 */
#define DPENUMGROUPS_HIDDEN         0x00001000

/*
 * Enumerate the group's owner
 */
#define DPENUMPLAYERS_OWNER			0x00002000


/****************************************************************************
 *
 * CreatePlayer API flags
 *
 ****************************************************************************/

/*
 * This flag indicates that this player should be designated
 * the server player. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SERVERPLAYER           DPENUMPLAYERS_SERVERPLAYER

/*
 * This flag indicates that this player should be designated
 * a spectator. The app should specify this at CreatePlayer.
 */
#define DPPLAYER_SPECTATOR              DPENUMPLAYERS_SPECTATOR

/*
 * This flag indicates that this player was created locally.
 * (returned from GetPlayerFlags)
 */
#define DPPLAYER_LOCAL                  DPENUMPLAYERS_LOCAL

/*
 * This flag indicates that this player is the group's owner
 * (Only returned in EnumGroupPlayers)
 */
#define DPPLAYER_OWNER                   DPENUMPLAYERS_OWNER

/****************************************************************************
 *
 * CreateGroup API flags
 *
 ****************************************************************************/

//@@BEGIN_MSINTERNAL
/*
 * This flag indicates that the subgroup was added to the group
 * instead of created in it.
 */
#define DPGROUP_SHORTCUT                DPENUMGROUPS_SHORTCUT
//@@END_MSINTERNAL

/*
 * This flag indicates that the StartSession can be called on the group.
 * The app should specify this at CreateGroup, or CreateGroupInGroup.
 */
#define DPGROUP_STAGINGAREA             DPENUMGROUPS_STAGINGAREA

/*
 * This flag indicates that this group was created locally.
 * (returned from GetGroupFlags)
 */
#define DPGROUP_LOCAL                   DPENUMGROUPS_LOCAL

/*
 * This flag indicates that this group was created hidden.
 */
#define DPGROUP_HIDDEN                   DPENUMGROUPS_HIDDEN


/****************************************************************************
 *
 * EnumSessions API flags
 *
 ****************************************************************************/

/*
 * Enumerate sessions which can be joined
 */
#define DPENUMSESSIONS_AVAILABLE    0x00000001 

/*
 * Enumerate all sessions even if they can't be joined.
 */
#define DPENUMSESSIONS_ALL          0x00000002

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPENUMSESSIONS_PREVIOUS     0x00000004
 */
//@@END_MSINTERNAL


//@@BEGIN_MSINTERNAL
/*
 * Private for dplay use only.  Used by DPConnect.
 * Don't free the responses from previous enums
 */
 #define DPENUMSESSIONS_NOREFRESH	0x00000008
//@@END_MSINTERNAL

/*
 * Start an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_ASYNC		0x00000010

/*
 * Stop an asynchronous enum sessions
 */
 #define DPENUMSESSIONS_STOPASYNC	0x00000020
 
/*
 * Enumerate sessions even if they require a password
 */
 #define DPENUMSESSIONS_PASSWORDREQUIRED	0x00000040

/*
 * Return status about progress of enumeration instead of
 * showing any status dialogs.
 */
 #define DPENUMSESSIONS_RETURNSTATUS 0x00000080

/****************************************************************************
 *
 * GetCaps and GetPlayerCaps API flags
 *
 ****************************************************************************/

/*
 * The latency returned should be for guaranteed message sending.
 * Default is non-guaranteed messaging.
 */
#define DPGETCAPS_GUARANTEED        0x00000001 

 
/****************************************************************************
 *
 * GetGroupData, GetPlayerData API flags
 * Remote and local Group/Player data is maintained separately. 
 * Default is DPGET_REMOTE.
 *
 ****************************************************************************/

/*
 * Get the remote data (set by any DirectPlay object in
 * the session using DPSET_REMOTE)
 */
#define DPGET_REMOTE                0x00000000
	
/*
 * Get the local data (set by this DirectPlay object 
 * using DPSET_LOCAL)
 */
#define DPGET_LOCAL                 0x00000001


/****************************************************************************
 *
 * Open API flags
 *
 ****************************************************************************/

/*
 * Join the session that is described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_JOIN                 0x00000001

/*
 * Create a new session as described by the DPSESSIONDESC2 structure
 */
#define DPOPEN_CREATE               0x00000002

/*
 * Return status about progress of open instead of showing
 * any status dialogs.
 */
 #define DPOPEN_RETURNSTATUS		DPENUMSESSIONS_RETURNSTATUS

//  @@BEGIN_MSINTERNAL 
// this is here so you don't pound the flag! -andy
// #define DPENUMSESSIONS_RETURNSTATUS 0x00000080 
//  @@END_MSINTERNAL


/****************************************************************************
 *
 * DPLCONNECTION flags
 *
 ****************************************************************************/

/*
 * This application should create a new session as
 * described by the DPSESIONDESC structure
 */
#define DPLCONNECTION_CREATESESSION					DPOPEN_CREATE

/*
 * This application should join the session described by 
 * the DPSESIONDESC structure with the lpAddress data
 */
#define DPLCONNECTION_JOINSESSION					DPOPEN_JOIN

/****************************************************************************
 *
 * Receive API flags
 * Default is DPRECEIVE_ALL
 *
 ****************************************************************************/

/*
 * Get the first message in the queue
 */
#define DPRECEIVE_ALL               0x00000001

/*
 * Get the first message in the queue directed to a specific player 
 */
#define DPRECEIVE_TOPLAYER          0x00000002

/*
 * Get the first message in the queue from a specific player
 */
#define DPRECEIVE_FROMPLAYER        0x00000004

/*
 * Get the message but don't remove it from the queue
 */
#define DPRECEIVE_PEEK              0x00000008


/****************************************************************************
 *
 * Send API flags
 *
 ****************************************************************************/

/*
 * Send the message using a guaranteed send method.
 * Default is non-guaranteed.
 */
#define DPSEND_GUARANTEED           0x00000001

//@@BEGIN_MSINTERNAL
/*
 * Do not delete the DPSEND_HIGHPRIORITY, DPSEND_OPENSTREAM or
 * DPSEND_CLOSESTREAM flags so we don't cause compile errors
 * in apps written for DX3 that use them.
 */
//@@END_MSINTERNAL

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_HIGHPRIORITY         0x00000002

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_OPENSTREAM           0x00000008

/*
 * This flag is obsolete. It is ignored by DirectPlay
 */
#define DPSEND_CLOSESTREAM          0x00000010

/*
 * Send the message digitally signed to ensure authenticity.
 */
#define DPSEND_SIGNED               0x00000020

/*
 * Send the message with encryption to ensure privacy.
 */
#define DPSEND_ENCRYPTED            0x00000040

/*
 * The message is a lobby system message
 */
#define DPSEND_LOBBYSYSTEMMESSAGE	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * Indicates that the message was on the pending queue
 */
#define DPSEND_PENDING              0x00000100
//@@END_MSINTERNAL

/*
 * Send message asynchronously, must check caps
 * before using this flag.  It is always provided
 * if the protocol flag is set.
 */
#define DPSEND_ASYNC				0x00000200

/*
 * When an message is completed, don't tell me. 
 * by default the application is notified with a system message.
 */
#define DPSEND_NOSENDCOMPLETEMSG    0x00000400

//@@BEGIN_MSINTERNAL
/*
 * To make some system messages proceed asynchronously
 */
#define DPSEND_SYSMESS              (DPSEND_GUARANTEE|DPSEND_ASYNC)
//@@END_MSINTERNAL

/*
 * Maximum priority for sends available to applications
 */
#define DPSEND_MAX_PRI              0x0000FFFF
#define DPSEND_MAX_PRIORITY         DPSEND_MAX_PRI

//@@BEGIN_MSINTERNAL
/*
 * Obsolete flags. Do not use.
 *
 * #define DPSEND_GUARANTEE            DPSEND_GUARANTEED
 * #define DPSEND_HIGHPRIORITY         0x00000002
 * #define DPSEND_TRYONCE              0x00000004
 */
 
/* This flag is used only for testing DPlay.
 *
 * When doing an async send, indicates that ownership of the
 * message buffers is passed to directplay.  Otherwise
 * DirectPlay must copy the buffer for an async send.
 */
#define DPSEND_NOCOPY               0x00000800

//@@END_MSINTERNAL

/****************************************************************************
 *
 * SetGroupData, SetGroupName, SetPlayerData, SetPlayerName,
 * SetSessionDesc API flags.
 * Default is DPSET_REMOTE.
 *
 ****************************************************************************/

/* 
 * Propagate the data to all players in the session
 */
#define DPSET_REMOTE                0x00000000

/*
 * Do not propagate the data to other players
 */
#define DPSET_LOCAL                 0x00000001

/*
 * Used with DPSET_REMOTE, use guaranteed message send to
 * propagate the data
 */
#define DPSET_GUARANTEED            0x00000002

/****************************************************************************
 *
 * GetMessageQueue API flags.
 * Default is DPMESSAGEQUEUE_SEND
 *
 ****************************************************************************/

/* 
 * Get Send Queue - requires Service Provider Support
 */
#define DPMESSAGEQUEUE_SEND        	0x00000001

/*
 * Get Receive Queue
 */
#define DPMESSAGEQUEUE_RECEIVE      0x00000002


/****************************************************************************
 *
 * Connect API flags
 *
 ****************************************************************************/

//  @@BEGIN_MSINTERNAL 
// this is here so you don't pound the flag! -andy
// #define DPENUMSESSIONS_RETURNSTATUS 0x00000080 
//  @@END_MSINTERNAL
 
/*
 * Start an asynchronous connect which returns status codes
 */
#define DPCONNECT_RETURNSTATUS      (DPENUMSESSIONS_RETURNSTATUS)


/****************************************************************************
 *
 * DirectPlay system messages and message data structures
 *
 * All system message come 'From' player DPID_SYSMSG.  To determine what type 
 * of message it is, cast the lpData from Receive to DPMSG_GENERIC and check
 * the dwType member against one of the following DPSYS_xxx constants. Once
 * a match is found, cast the lpData to the corresponding of the DPMSG_xxx
 * structures to access the data of the message.
 *
 ****************************************************************************/

/*
 * A new player or group has been created in the session
 * Use DPMSG_CREATEPLAYERORGROUP.  Check dwPlayerType to see if it
 * is a player or a group.
 */
#define DPSYS_CREATEPLAYERORGROUP   0x0003  

/*
 * A player has been deleted from the session
 * Use DPMSG_DESTROYPLAYERORGROUP
 */
#define DPSYS_DESTROYPLAYERORGROUP  0x0005  

/*
 * A player has been added to a group
 * Use DPMSG_ADDPLAYERTOGROUP
 */
#define DPSYS_ADDPLAYERTOGROUP      0x0007  

/*
 * A player has been removed from a group
 * Use DPMSG_DELETEPLAYERFROMGROUP
 */
#define DPSYS_DELETEPLAYERFROMGROUP 0x0021  

/*
 * This DirectPlay object lost its connection with all the
 * other players in the session.
 * Use DPMSG_SESSIONLOST.
 */
#define DPSYS_SESSIONLOST           0x0031

/*
 * The current host has left the session.
 * This DirectPlay object is now the host.
 * Use DPMSG_HOST.
 */
#define DPSYS_HOST                  0x0101

/*
 * The remote data associated with a player or
 * group has changed. Check dwPlayerType to see
 * if it is a player or a group
 * Use DPMSG_SETPLAYERORGROUPDATA
 */
#define DPSYS_SETPLAYERORGROUPDATA  0x0102

/*
 * The name of a player or group has changed.
 * Check dwPlayerType to see if it is a player
 * or a group.
 * Use DPMSG_SETPLAYERORGROUPNAME
 */
#define DPSYS_SETPLAYERORGROUPNAME  0x0103

/*
 * The session description has changed.
 * Use DPMSG_SETSESSIONDESC
 */
#define DPSYS_SETSESSIONDESC        0x0104

/*
 * A group has been added to a group
 * Use DPMSG_ADDGROUPTOGROUP
 */
#define DPSYS_ADDGROUPTOGROUP      	0x0105  

/*
 * A group has been removed from a group
 * Use DPMSG_DELETEGROUPFROMGROUP
 */
#define DPSYS_DELETEGROUPFROMGROUP 	0x0106

/*
 * A secure player-player message has arrived.
 * Use DPMSG_SECUREMESSAGE
 */
#define DPSYS_SECUREMESSAGE         0x0107

/*
 * Start a new session.
 * Use DPMSG_STARTSESSION
 */
#define DPSYS_STARTSESSION          0x0108

/*
 * A chat message has arrived
 * Use DPMSG_CHAT
 */
#define DPSYS_CHAT                  0x0109

/*
 * The owner of a group has changed
 * Use DPMSG_SETGROUPOWNER
 */
#define DPSYS_SETGROUPOWNER         0x010A

/*
 * An async send has finished, failed or been cancelled
 * Use DPMSG_SENDCOMPLETE
 */
#define DPSYS_SENDCOMPLETE          0x010d


/*
 * Used in the dwPlayerType field to indicate if it applies to a group
 * or a player
 */
#define DPPLAYERTYPE_GROUP          0x00000000
#define DPPLAYERTYPE_PLAYER         0x00000001


/*
 * DPMSG_GENERIC
 * Generic message structure used to identify the message type.
 */
typedef struct
{
    DWORD       dwType;         // Message type
} DPMSG_GENERIC, FAR *LPDPMSG_GENERIC;

/*
 * DPMSG_CREATEPLAYERORGROUP
 * System message generated when a new player or group
 * created in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of the player or group
    DWORD       dwCurrentPlayers;   // current # players & groups in session
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
    DPNAME      dpnName;        // structure with name info
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPID	    dpIdParent;     // id of parent group
	DWORD		dwFlags;		// player or group flags
} DPMSG_CREATEPLAYERORGROUP, FAR *LPDPMSG_CREATEPLAYERORGROUP;

/*
 * DPMSG_DESTROYPLAYERORGROUP
 * System message generated when a player or group is being
 * destroyed in the session with information about it.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // player ID being deleted
    LPVOID      lpLocalData;    // copy of players local data
    DWORD       dwLocalDataSize; // sizeof local data
    LPVOID      lpRemoteData;   // copy of players remote data
    DWORD       dwRemoteDataSize; // sizeof remote data
	// the following fields are only available when using
	// the IDirectPlay3 interface or greater
    DPNAME      dpnName;        // structure with name info
    DPID	    dpIdParent;     // id of parent group	
	DWORD		dwFlags;		// player or group flags
} DPMSG_DESTROYPLAYERORGROUP, FAR *LPDPMSG_DESTROYPLAYERORGROUP;

/*
 * DPMSG_ADDPLAYERTOGROUP
 * System message generated when a player is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdGroup;      // group ID being added to
    DPID        dpIdPlayer;     // player ID being added
} DPMSG_ADDPLAYERTOGROUP, FAR *LPDPMSG_ADDPLAYERTOGROUP;

/*
 * DPMSG_DELETEPLAYERFROMGROUP
 * System message generated when a player is being
 * removed from a group
 */
typedef DPMSG_ADDPLAYERTOGROUP          DPMSG_DELETEPLAYERFROMGROUP;
typedef DPMSG_DELETEPLAYERFROMGROUP     FAR *LPDPMSG_DELETEPLAYERFROMGROUP;

/*
 * DPMSG_ADDGROUPTOGROUP
 * System message generated when a group is being added
 * to a group.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        dpIdParentGroup; // group ID being added to
    DPID        dpIdGroup;     // group ID being added
} DPMSG_ADDGROUPTOGROUP, FAR *LPDPMSG_ADDGROUPTOGROUP;

/*
 * DPMSG_DELETEGROUPFROMGROUP
 * System message generated when a GROUP is being
 * removed from a group
 */
typedef DPMSG_ADDGROUPTOGROUP          DPMSG_DELETEGROUPFROMGROUP;
typedef DPMSG_DELETEGROUPFROMGROUP     FAR *LPDPMSG_DELETEGROUPFROMGROUP;

/*
 * DPMSG_SETPLAYERORGROUPDATA
 * System message generated when remote data for a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    LPVOID      lpData;         // pointer to remote data
    DWORD       dwDataSize;     // size of remote data
} DPMSG_SETPLAYERORGROUPDATA, FAR *LPDPMSG_SETPLAYERORGROUPDATA;

/*
 * DPMSG_SETPLAYERORGROUPNAME
 * System message generated when the name of a player or
 * group has changed.
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DWORD       dwPlayerType;   // Is it a player or group
    DPID        dpId;           // ID of player or group
    DPNAME      dpnName;        // structure with new name info
} DPMSG_SETPLAYERORGROUPNAME, FAR *LPDPMSG_SETPLAYERORGROUPNAME;

/*
 * DPMSG_SETSESSIONDESC
 * System message generated when session desc has changed
 */
typedef struct
{
    DWORD           dwType;     // Message type
    DPSESSIONDESC2  dpDesc;     // Session desc
} DPMSG_SETSESSIONDESC, FAR *LPDPMSG_SETSESSIONDESC;

/*
 * DPMSG_HOST
 * System message generated when the host has migrated to this
 * DirectPlay object.
 *
 */
typedef DPMSG_GENERIC       DPMSG_HOST;
typedef DPMSG_HOST          FAR *LPDPMSG_HOST;

/*
 * DPMSG_SESSIONLOST
 * System message generated when the connection to the session is lost.
 *
 */
typedef DPMSG_GENERIC       DPMSG_SESSIONLOST;
typedef DPMSG_SESSIONLOST   FAR *LPDPMSG_SESSIONLOST;

/*
 * DPMSG_SECUREMESSAGE
 * System message generated when a player requests a secure send
 */
typedef struct 
{
    DWORD		dwType;         // Message Type
    DWORD		dwFlags;        // Signed/Encrypted
    DPID        dpIdFrom;       // ID of Sending Player
    LPVOID		lpData;         // Player message
    DWORD		dwDataSize;     // Size of player message
} DPMSG_SECUREMESSAGE, FAR *LPDPMSG_SECUREMESSAGE;

/*
 * DPMSG_STARTSESSION
 * System message containing all information required to 
 * start a new session
 */
typedef struct
{
    DWORD              dwType;     // Message type
    LPDPLCONNECTION    lpConn;     // DPLCONNECTION structure
} DPMSG_STARTSESSION, FAR *LPDPMSG_STARTSESSION;

/*
 * DPMSG_CHAT
 * System message containing a chat message
 */
typedef struct
{
    DWORD              	dwType;       	// Message type
    DWORD              	dwFlags;      	// Message flags
    DPID               	idFromPlayer; 	// ID of the Sending Player
    DPID               	idToPlayer;   	// ID of the To Player
    DPID               	idToGroup;    	// ID of the To Group
	LPDPCHAT 			lpChat;			// Pointer to a structure containing the chat message
} DPMSG_CHAT, FAR *LPDPMSG_CHAT;

/*
 * DPMSG_SETGROUPOWNER
 * System message generated when the owner of a group has changed
 */
typedef struct
{
    DWORD       dwType;         // Message type
    DPID        idGroup;        // ID of the group
    DPID        idNewOwner;     // ID of the player that is the new owner
    DPID        idOldOwner;     // ID of the player that used to be the owner
} DPMSG_SETGROUPOWNER, FAR *LPDPMSG_SETGROUPOWNER;

/*
 * DPMSG_SENDCOMPLETE
 * System message generated when finished with an Async Send message
 *
 * NOTE SENDPARMS has an overlay for DPMSG_SENDCOMPLETE, don't
 *                change this message w/o changing SENDPARMS.
 */
typedef struct
{
	DWORD 		dwType;
	DPID		idFrom;
	DPID		idTo;
	DWORD		dwFlags;
	DWORD		dwPriority;
	DWORD		dwTimeout;
	LPVOID		lpvContext;
	DWORD		dwMsgID;
	HRESULT     hr;
	DWORD       dwSendTime;
} DPMSG_SENDCOMPLETE, *LPDPMSG_SENDCOMPLETE;

/****************************************************************************
 *
 * DIRECTPLAY ERRORS
 *
 * Errors are represented by negative values and cannot be combined.
 *
 ****************************************************************************/
#define DP_OK                           S_OK
#define DPERR_ALREADYINITIALIZED        MAKE_DPHRESULT(   5 )
#define DPERR_ACCESSDENIED              MAKE_DPHRESULT(  10 )
#define DPERR_ACTIVEPLAYERS             MAKE_DPHRESULT(  20 )
#define DPERR_BUFFERTOOSMALL            MAKE_DPHRESULT(  30 )
#define DPERR_CANTADDPLAYER             MAKE_DPHRESULT(  40 )
#define DPERR_CANTCREATEGROUP           MAKE_DPHRESULT(  50 )
#define DPERR_CANTCREATEPLAYER          MAKE_DPHRESULT(  60 )
#define DPERR_CANTCREATESESSION         MAKE_DPHRESULT(  70 )
#define DPERR_CAPSNOTAVAILABLEYET       MAKE_DPHRESULT(  80 )
#define DPERR_EXCEPTION                 MAKE_DPHRESULT(  90 )
#define DPERR_GENERIC                   E_FAIL
#define DPERR_INVALIDFLAGS              MAKE_DPHRESULT( 120 )
#define DPERR_INVALIDOBJECT             MAKE_DPHRESULT( 130 )
#define DPERR_INVALIDPARAM              E_INVALIDARG
#define DPERR_INVALIDPARAMS             DPERR_INVALIDPARAM
#define DPERR_INVALIDPLAYER             MAKE_DPHRESULT( 150 )
#define DPERR_INVALIDGROUP             	MAKE_DPHRESULT( 155 )
#define DPERR_NOCAPS                    MAKE_DPHRESULT( 160 )
#define DPERR_NOCONNECTION              MAKE_DPHRESULT( 170 )
#define DPERR_NOMEMORY                  E_OUTOFMEMORY
#define DPERR_OUTOFMEMORY               DPERR_NOMEMORY
#define DPERR_NOMESSAGES                MAKE_DPHRESULT( 190 )
#define DPERR_NONAMESERVERFOUND         MAKE_DPHRESULT( 200 )
#define DPERR_NOPLAYERS                 MAKE_DPHRESULT( 210 )
#define DPERR_NOSESSIONS                MAKE_DPHRESULT( 220 )
#define DPERR_PENDING					E_PENDING
#define DPERR_SENDTOOBIG				MAKE_DPHRESULT( 230 )
#define DPERR_TIMEOUT                   MAKE_DPHRESULT( 240 )
#define DPERR_UNAVAILABLE               MAKE_DPHRESULT( 250 )
#define DPERR_UNSUPPORTED               E_NOTIMPL
#define DPERR_BUSY                      MAKE_DPHRESULT( 270 )
#define DPERR_USERCANCEL                MAKE_DPHRESULT( 280 ) 
#define DPERR_NOINTERFACE               E_NOINTERFACE
#define DPERR_CANNOTCREATESERVER        MAKE_DPHRESULT( 290 )
#define DPERR_PLAYERLOST                MAKE_DPHRESULT( 300 )
#define DPERR_SESSIONLOST               MAKE_DPHRESULT( 310 )
#define DPERR_UNINITIALIZED             MAKE_DPHRESULT( 320 )
#define DPERR_NONEWPLAYERS              MAKE_DPHRESULT( 330 )
#define DPERR_INVALIDPASSWORD           MAKE_DPHRESULT( 340 )
#define DPERR_CONNECTING                MAKE_DPHRESULT( 350 )
#define DPERR_CONNECTIONLOST            MAKE_DPHRESULT( 360 )
#define DPERR_UNKNOWNMESSAGE            MAKE_DPHRESULT( 370 )
#define DPERR_CANCELFAILED              MAKE_DPHRESULT( 380 )
#define DPERR_INVALIDPRIORITY           MAKE_DPHRESULT( 390 )
#define DPERR_NOTHANDLED                MAKE_DPHRESULT( 400 )
#define DPERR_CANCELLED                 MAKE_DPHRESULT( 410 )
#define DPERR_ABORTED                   MAKE_DPHRESULT( 420 )


#define DPERR_BUFFERTOOLARGE            MAKE_DPHRESULT( 1000 )
#define DPERR_CANTCREATEPROCESS         MAKE_DPHRESULT( 1010 )
#define DPERR_APPNOTSTARTED             MAKE_DPHRESULT( 1020 )
#define DPERR_INVALIDINTERFACE          MAKE_DPHRESULT( 1030 )
#define DPERR_NOSERVICEPROVIDER         MAKE_DPHRESULT( 1040 )
#define DPERR_UNKNOWNAPPLICATION        MAKE_DPHRESULT( 1050 )
#define DPERR_NOTLOBBIED                MAKE_DPHRESULT( 1070 )
#define DPERR_SERVICEPROVIDERLOADED		MAKE_DPHRESULT( 1080 )
#define DPERR_ALREADYREGISTERED			MAKE_DPHRESULT( 1090 )
#define DPERR_NOTREGISTERED				MAKE_DPHRESULT( 1100 )

//
// Security related errors
//
#define DPERR_AUTHENTICATIONFAILED      MAKE_DPHRESULT(  2000 )
#define DPERR_CANTLOADSSPI              MAKE_DPHRESULT(  2010 )
#define DPERR_ENCRYPTIONFAILED          MAKE_DPHRESULT(  2020 )
#define DPERR_SIGNFAILED                MAKE_DPHRESULT(  2030 )
#define DPERR_CANTLOADSECURITYPACKAGE   MAKE_DPHRESULT(  2040 )
#define DPERR_ENCRYPTIONNOTSUPPORTED    MAKE_DPHRESULT(  2050 )
#define DPERR_CANTLOADCAPI              MAKE_DPHRESULT(  2060 )
#define DPERR_NOTLOGGEDIN               MAKE_DPHRESULT(  2070 )
#define DPERR_LOGONDENIED               MAKE_DPHRESULT(  2080 )


/****************************************************************************
 *
 * 	dplay 1.0 obsolete structures + interfaces
 *	Included for compatibility only. New apps should
 *	use IDirectPlay2
 *
 ****************************************************************************/

// define this to ignore obsolete interfaces and constants
#ifndef IDIRECTPLAY2_OR_GREATER

#define DPOPEN_OPENSESSION          DPOPEN_JOIN
#define DPOPEN_CREATESESSION        DPOPEN_CREATE

#define DPENUMSESSIONS_PREVIOUS     0x00000004

#define DPENUMPLAYERS_PREVIOUS      0x00000004

//@@BEGIN_MSINTERNAL
/*
 * Defined in DPlay 1 header file but appear to have no effect 
 * in the code
 */
//@@END_MSINTERNAL
#define DPSEND_GUARANTEE            DPSEND_GUARANTEED
#define DPSEND_TRYONCE              0x00000004

//@@BEGIN_MSINTERNAL
/*
 * Defined in DPlay 1 header file but appear to have no effect
 * in the code
 */
//@@END_MSINTERNAL
#define DPCAPS_NAMESERVICE          0x00000001
#define DPCAPS_NAMESERVER           DPCAPS_ISHOST
#define DPCAPS_GUARANTEED           0x00000004

#define DPLONGNAMELEN               52
#define DPSHORTNAMELEN              20
#define DPSESSIONNAMELEN            32
#define DPPASSWORDLEN               16
#define DPUSERRESERVED              16

#define DPSYS_ADDPLAYER             0x0003
#define DPSYS_DELETEPLAYER          0x0005

#define DPSYS_DELETEGROUP           0x0020
#define DPSYS_DELETEPLAYERFROMGRP   0x0021
#define DPSYS_CONNECT               0x484b

typedef struct
{
    DWORD       dwType;
    DWORD       dwPlayerType;
    DPID        dpId;
    char        szLongName[DPLONGNAMELEN];
    char        szShortName[DPSHORTNAMELEN];
    DWORD       dwCurrentPlayers;
}   DPMSG_ADDPLAYER;

typedef DPMSG_ADDPLAYER DPMSG_ADDGROUP;

typedef struct
{
    DWORD       dwType;
    DPID        dpIdGroup;
    DPID        dpIdPlayer;
} DPMSG_GROUPADD;

typedef DPMSG_GROUPADD DPMSG_GROUPDELETE;
typedef struct
{
    DWORD       dwType;
    DPID        dpId;
} DPMSG_DELETEPLAYER;

typedef BOOL (PASCAL *LPDPENUMPLAYERSCALLBACK)(
    DPID    dpId,
    LPSTR   lpFriendlyName,
    LPSTR   lpFormalName,
    DWORD   dwFlags,
    LPVOID  lpContext );

typedef struct
{
    DWORD   dwSize;
    GUID    guidSession;                  
    DWORD_PTR dwSession;                    
    DWORD   dwMaxPlayers;                 
    DWORD   dwCurrentPlayers;             
    DWORD   dwFlags;                      
    char    szSessionName[DPSESSIONNAMELEN];
    char    szUserField[DPUSERRESERVED];
    DWORD_PTR   dwReserved1;                  
    char    szPassword[DPPASSWORDLEN];    
    DWORD_PTR   dwReserved2;                  
    DWORD_PTR   dwUser1;
    DWORD_PTR   dwUser2;
    DWORD_PTR   dwUser3;
    DWORD_PTR   dwUser4;
} DPSESSIONDESC,*LPDPSESSIONDESC;

typedef BOOL (PASCAL * LPDPENUMSESSIONSCALLBACK)(
    LPDPSESSIONDESC lpDPSessionDesc,
    LPVOID      lpContext,
    LPDWORD     lpdwTimeOut,
    DWORD       dwFlags);

/*
 * IDirectPlay
 */
#undef INTERFACE
#define INTERFACE IDirectPlay
DECLARE_INTERFACE_( IDirectPlay, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS)  PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlay methods ***/
    STDMETHOD(AddPlayerToGroup)     (THIS_ DPID, DPID) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(CreatePlayer)         (THIS_ LPDPID,LPSTR,LPSTR,LPHANDLE) PURE;
    STDMETHOD(CreateGroup)          (THIS_ LPDPID,LPSTR,LPSTR) PURE;
    STDMETHOD(DeletePlayerFromGroup)(THIS_ DPID,DPID) PURE;
    STDMETHOD(DestroyPlayer)        (THIS_ DPID) PURE;
    STDMETHOD(DestroyGroup)         (THIS_ DPID) PURE;
    STDMETHOD(EnableNewPlayers)     (THIS_ BOOL) PURE;
    STDMETHOD(EnumGroupPlayers)     (THIS_ DPID, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumGroups)           (THIS_ DWORD_PTR, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumPlayers)          (THIS_ DWORD_PTR, LPDPENUMPLAYERSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(EnumSessions)         (THIS_ LPDPSESSIONDESC,DWORD,LPDPENUMSESSIONSCALLBACK,LPVOID,DWORD) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDPCAPS) PURE;
    STDMETHOD(GetMessageCount)      (THIS_ DPID, LPDWORD) PURE;
    STDMETHOD(GetPlayerCaps)        (THIS_ DPID, LPDPCAPS) PURE;
    STDMETHOD(GetPlayerName)        (THIS_ DPID,LPSTR,LPDWORD,LPSTR,LPDWORD) PURE;
    STDMETHOD(Initialize)           (THIS_ LPGUID) PURE;
    STDMETHOD(Open)                 (THIS_ LPDPSESSIONDESC) PURE;
    STDMETHOD(Receive)              (THIS_ LPDPID,LPDPID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(SaveSession)          (THIS_ LPSTR) PURE;
    STDMETHOD(Send)                 (THIS_ DPID, DPID, DWORD, LPVOID, DWORD) PURE;
    STDMETHOD(SetPlayerName)        (THIS_ DPID,LPSTR,LPSTR) PURE;
};

/****************************************************************************
 *
 * IDirectPlay interface macros
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->lpVtbl->AddPlayerToGroup(p,a,b)
#define IDirectPlay_Close(p)                        (p)->lpVtbl->Close(p)
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->lpVtbl->CreateGroup(p,a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->lpVtbl->CreatePlayer(p,a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->lpVtbl->DeletePlayerFromGroup(p,a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->lpVtbl->DestroyGroup(p,a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->lpVtbl->DestroyPlayer(p,a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->lpVtbl->EnableNewPlayers(p,a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->lpVtbl->EnumGroupPlayers(p,a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->lpVtbl->EnumGroups(p,a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->lpVtbl->EnumPlayers(p,a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->lpVtbl->EnumSessions(p,a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->lpVtbl->GetCaps(p,a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->lpVtbl->GetMessageCount(p,a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->lpVtbl->GetPlayerCaps(p,a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->lpVtbl->GetPlayerName(p,a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->lpVtbl->Initialize(p,a)
#define IDirectPlay_Open(p,a)                       (p)->lpVtbl->Open(p,a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->lpVtbl->Receive(p,a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->lpVtbl->SaveSession(p,a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->lpVtbl->Send(p,a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->lpVtbl->SetPlayerName(p,a,b,c)

#else /* C++ */

#define IDirectPlay_AddPlayerToGroup(p,a,b)         (p)->AddPlayerToGroup(a,b)
#define IDirectPlay_Close(p)                        (p)->Close()
#define IDirectPlay_CreateGroup(p,a,b,c)            (p)->CreateGroup(a,b,c)
#define IDirectPlay_CreatePlayer(p,a,b,c,d)         (p)->CreatePlayer(a,b,c,d)
#define IDirectPlay_DeletePlayerFromGroup(p,a,b)    (p)->DeletePlayerFromGroup(a,b)
#define IDirectPlay_DestroyGroup(p,a)               (p)->DestroyGroup(a)
#define IDirectPlay_DestroyPlayer(p,a)              (p)->DestroyPlayer(a)
#define IDirectPlay_EnableNewPlayers(p,a)           (p)->EnableNewPlayers(a)
#define IDirectPlay_EnumGroupPlayers(p,a,b,c,d)     (p)->EnumGroupPlayers(a,b,c,d)
#define IDirectPlay_EnumGroups(p,a,b,c,d)           (p)->EnumGroups(a,b,c,d)
#define IDirectPlay_EnumPlayers(p,a,b,c,d)          (p)->EnumPlayers(a,b,c,d)
#define IDirectPlay_EnumSessions(p,a,b,c,d,e)       (p)->EnumSessions(a,b,c,d,e)
#define IDirectPlay_GetCaps(p,a)                    (p)->GetCaps(a)
#define IDirectPlay_GetMessageCount(p,a,b)          (p)->GetMessageCount(a,b)
#define IDirectPlay_GetPlayerCaps(p,a,b)            (p)->GetPlayerCaps(a,b)
#define IDirectPlay_GetPlayerName(p,a,b,c,d,e)      (p)->GetPlayerName(a,b,c,d,e)
#define IDirectPlay_Initialize(p,a)                 (p)->Initialize(a)
#define IDirectPlay_Open(p,a)                       (p)->Open(a)
#define IDirectPlay_Receive(p,a,b,c,d,e)            (p)->Receive(a,b,c,d,e)
#define IDirectPlay_SaveSession(p,a)                (p)->SaveSession(a)
#define IDirectPlay_Send(p,a,b,c,d,e)               (p)->Send(a,b,c,d,e)
#define IDirectPlay_SetPlayerName(p,a,b,c)          (p)->SetPlayerName(a,b,c)

#endif

DEFINE_GUID(IID_IDirectPlay, 0x5454e9a0, 0xdb65, 0x11ce, 0x92, 0x1c, 0x00, 0xaa, 0x00, 0x6c, 0x49, 0x72);

#endif // IDIRECTPLAY2_OR_GREATER

/****************************************************************************
 *
 * IDirectPlay macros (included regardless of IDIRECTPLAY2_OR_GREATER flag)
 *
 ****************************************************************************/

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IDirectPlay_QueryInterface(p,a,b)           (p)->lpVtbl->QueryInterface(p,a,b)
#define IDirectPlay_AddRef(p)                       (p)->lpVtbl->AddRef(p)
#define IDirectPlay_Release(p)                      (p)->lpVtbl->Release(p)

#else

#define IDirectPlay_QueryInterface(p,a,b)           (p)->QueryInterface(a,b)
#define IDirectPlay_AddRef(p)                       (p)->AddRef()
#define IDirectPlay_Release(p)                      (p)->Release()

#endif // IDirectPlay interface macros 

#ifdef __cplusplus
};
#endif

#pragma warning(default:4201)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpcpl.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpcpl.h
 *  Content:	DirectX CPL include file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-nov-96	andyco	created it
 *
 ***************************************************************************/

#ifndef __DPCPL_INCLUDED__
#define __DPCPL_INCLUDED__


#define MAX_NAME 256

typedef struct _DP_PERFDATA
{
    DWORD dwProcessID;
    UINT nSendBPS; // BPS = bytes per second
    UINT nReceiveBPS;
    UINT nSendPPS; // PPS = packets per second
    UINT nReceivePPS;
    UINT nSendErrors;
    BOOL bHost; // hosting?    
	UINT nPlayers;
    char pszSessionName[MAX_NAME];
    char pszFileName[MAX_NAME];
    char pszSPName[MAX_NAME];    
} DP_PERFDATA, * LPDP_PERFDATA;

#define FILE_MAP_SIZE sizeof(DP_PERFDATA)
#define FILE_MAP_NAME "__DPCPLMAP__"
#define EVENT_NAME  "__DPCPLEVENT__"
#define MUTEX_NAME "__DPCPLMUTEX__"
#define ACK_EVENT_NAME "__DPCPLACKEVENT__"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dplaysp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysp.h
 *  Content:    DirectPlay Service Provider header
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  1/96    	andyco  created it
 *  1/26/96   	andyco  list data structures
 *	2/15/96		andyco	packed structures (for net xport)
 *	3/16/96		andyco	added shutdown callback
 *	3/25/96		andyco	added sp nodes for sp enum
 *	3/28/96		andyco	added free receive buffer callback
 *	4/9/96		andyco	moved dplayi_dplay, packed player, spnode, etc. to dplaypr.h
 *	4/10/96		andyco	added getmessagesize,isvalidmessage fn's
 *  4/11/96		andyco	added spdata instead of reserving a bunch of dwords
 *	4/12/96		andyco	added dplay_xxx methods to get rid of dpmess.h macros
 *	4/18/96		andyco	added remote players to createplayer, getplayer + group
 *						list fn's
 *	4/25/96		andyco	got rid of dwreservedx. added dwSPHeaderSize. spblob  
 *						follows message
 *	5/2/96		andyco	replaced idirectplay * with iunknown *
 *	5/9/96		andyco	idirectplay2
 *	6/8/96		andyco	moved dplayi_player/group to dplaypr.h. ported from 
 *						(now defunct) dplayi.h.
 *	6/19/96		andyco	changed names, etc. for consistency
 *	6/22/96		andyco	tossed dwCookies. removed pUnk from callbacks.  removed sessiondesc
 *	 					from callbacks.  alphapathetical order.
 *	6/22/96		andyco	made DPlay_xxx functions a COM interface (IDirectPlaySP)
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/23/96		andyco	updated comments. removed bLocal from Create fn's (look 
 *						at flags).
 *	6/23/96		kipo	cleanup for service provider lab.
 *	6/24/96		kipo	added version number
 *	6/24/96		andyco	added getaddress
 *	6/25/96		kipo	added WINAPI prototypes and updated for DPADDRESS
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/10/96		andyco	added dwflags to createaddress.  changed guid * to
 *						refguid in createaddress call.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *  7/30/96     kipo    added DPLAYI_PLAYER_CREATEDPLAYEREVENT
 *  8/23/96     kipo    incremented major version number
 *	10/10/96	andyco	added optimized groups
 *	2/7/97		andyco	added idpsp to each callback
 *	3/04/97		kipo	updated gdwDPlaySPRefCount definition
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *	5/8/97		myronth	added DPLAYI_GROUP_STAGINGAREA (internal)
 *	5/18/97		kipo	added DPLAYI_PLAYER_SPECTATOR
 *	5/23/97		kipo	Added support for return status codes
 *	10/21/97	myronth	Added DPLAYI_GROUP_HIDDEN
 *	10/29/97	myronth	Added DPLAYI_PLAYER_OWNER (internal)
 *	10/31/97	andyco	added voice call
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/28/98		sohailm	Added dwSessionFlags to DPSP_OPENDATA
 *  4/1/98      aarono  Added DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE
 *  6/2/98		aarono  Added DPLAYI_PLAYER_BEING_DESTROYED to avoid
 *                       deleting more than once.
 *  8/02/99		aarono  removed old voice support
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DPLAYSP_INCLUDED__
#define __DPLAYSP_INCLUDED__

#include "dplay.h"
#include "dplobby.h"

#ifdef __cplusplus
extern "C" {
#endif

/*============================================================================
 *
 * DirectPlay Service Provider Structures
 *
 * Various structures used to invoke DirectPlay Service Providers.
 *
 *==========================================================================*/

/*
 * Callback for EnumMRU()
 */
typedef BOOL (PASCAL *LPENUMMRUCALLBACK)(
    LPCVOID         lpData,
    DWORD           dwDataSize,
    LPVOID          lpContext);

/*
 * Major version number for service provider.
 *
 * The most-significant 16 bits are reserved for the DirectPlay
 * major version number. The least-significant 16 bits are for
 * use by the service provider.
 */
#define DPSP_MAJORVERSION               0x00060000

/*
 * This is the major version number that DirectX 3 (DX3) shipped with
 */
#define DPSP_DX3VERSION               	0x00040000

/*
 * This is the major version number that DirectX 5 (DX5) shipped with
 */
#define DPSP_DX5VERSION               	0x00050000

/*
 * Masks to help check the version info
 */
#define DPSP_MAJORVERSIONMASK			0xFFFF0000

#define DPSP_MINORVERSIONMASK			0x0000FFFF

/*
 * DPLAYI_PLAYER_FLAGS
 *
 * These flags may be used with players or groups, as appropriate.
 * The service provider can get these by calling IDirectPlaySP->GetFlags()
 * as defined below.  The flags are also available in the dwFlags field
 * for most of the callback data structures.
 * 
 * These flags are set by DirectPlay - they are read only for the 
 * service provider
 *
 */

/*
 * Player is the system player (player only).
 */
#define DPLAYI_PLAYER_SYSPLAYER         0x00000001

/* 
 * Player is the name server (player only). Only valid when 
 * DPLAYI_PLAYER_SYSPLAYER is also set.
 */
#define DPLAYI_PLAYER_NAMESRVR          0x00000002

/*
 * Player belongs to a group (player only).
 */
#define DPLAYI_PLAYER_PLAYERINGROUP     0x00000004

/*
 * Player allocated on this IDirectPlay (player or group).
 */
#define DPLAYI_PLAYER_PLAYERLOCAL       0x00000008

//@@BEGIN_MSINTERNAL
/*
 * Player event allocated by DirectPlay (player only).
 * Used for compatability with the IDirectPlay1 API.
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_CREATEDPLAYEREVENT 0x00000010
//@@END_MSINTERNAL

/*
 * This group is the system group.  If the service provider returns
 * DPCAPS_GROUPOPTIMIZED on a GetCaps call, then DirectPlay will create
 * a system group containing all players in the game.  Sends by the application
 * to DPID_ALLPLAYERS will be sent to this group.  (group only).
 *												   
 */
#define DPLAYI_GROUP_SYSGROUP			0x00000020

/*
 * DirectPlay "owns" this group.  Sends to this group will be emulated by DirectPlay
 * (sends go to each individual member).  This flag  is set on a group if the
 * Service Provider returns failure to the CreateGroup or AddPlayerToGroup
 * callback. (group only).
 *
 */
#define DPLAYI_GROUP_DPLAYOWNS			0x00000040

/*
 * This player is the app's server player
 */
#define DPLAYI_PLAYER_APPSERVER       	0x00000080

//@@BEGIN_MSINTERNAL
/*
 * This group is a staging area
 */
#define DPLAYI_GROUP_STAGINGAREA       	0x00000100
//@@END_MSINTERNAL

/*
 * This player is a spectator
 */
#define DPLAYI_PLAYER_SPECTATOR       	0x00000200

/*
 * This group is hidden
 */
#define DPLAYI_GROUP_HIDDEN		       	0x00000400

//@@BEGIN_MSINTERNAL
/*
 * Player is the owner of a group.  (Only used
 * internally, and only used during EnumGroupPlayers).
 * INTERNAL USE ONLY
 */
#define DPLAYI_PLAYER_OWNER             0x00000800

// a-josbor: Internal flag that gets set when the Keepalive has
//	determined that this player should be killed
#define DPLAYI_PLAYER_ON_DEATH_ROW		0x00001000

// aarono: use this flag to mark players waiting for nametable.
// any sends to these players just return DPERR_UNAVAILABLE
// this bit is cleared when we transmit the nametable.
#define DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE 0x00002000

// a-josbor: set when we get an error back on a reliable
// send.  We don't kill them right away because there might
// be messages pending from them
#define DPLAYI_PLAYER_CONNECTION_LOST		0x00004000
/*
 * Used to stop re-entering destory player
 */
#define DPLAYI_PLAYER_BEING_DESTROYED 0x00010000

#define DPLAYI_PLAYER_NONPROP_FLAGS ( DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE | \
									  DPLAYI_PLAYER_BEING_DESTROYED | \
									  DPLAYI_PLAYER_ON_DEATH_ROW |\
									  DPLAYI_PLAYER_CONNECTION_LOST )

//@@END_MSINTERNAL


/*
 *	IDirectPlaySP
 *
 *	Service providers are passed an IDirectPlaySP interface
 *	in the SPInit method. This interface is used to call DirectPlay.
 */

struct IDirectPlaySP;

typedef struct IDirectPlaySP FAR* LPDIRECTPLAYSP;

#undef INTERFACE
#define INTERFACE IDirectPlaySP
DECLARE_INTERFACE_( IDirectPlaySP, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface)       (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    /*** IDirectPlaySP methods ***/
    STDMETHOD(AddMRUEntry)          (THIS_ LPCWSTR, LPCWSTR, LPCVOID, DWORD, DWORD) PURE;
    STDMETHOD(CreateAddress)        (THIS_ REFGUID,REFGUID,LPCVOID,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(EnumAddress)          (THIS_ LPDPENUMADDRESSCALLBACK,LPCVOID,DWORD,LPVOID) PURE;
    STDMETHOD(EnumMRUEntries)       (THIS_ LPCWSTR, LPCWSTR, LPENUMMRUCALLBACK, LPVOID) PURE;
    STDMETHOD(GetPlayerFlags)       (THIS_ DPID,LPDWORD) PURE;
    STDMETHOD(GetSPPlayerData)      (THIS_ DPID,LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(HandleMessage)        (THIS_ LPVOID,DWORD,LPVOID) PURE;
    STDMETHOD(SetSPPlayerData)      (THIS_ DPID,LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 5 ***/
    STDMETHOD(CreateCompoundAddress)(THIS_ LPCDPCOMPOUNDADDRESSELEMENT,DWORD,LPVOID,LPDWORD) PURE;
    STDMETHOD(GetSPData)      		(THIS_ LPVOID *,LPDWORD,DWORD) PURE;
    STDMETHOD(SetSPData)      		(THIS_ LPVOID,DWORD,DWORD) PURE;
    /*** IDirectPlaySP methods added for DX 6 ***/
    STDMETHOD_(VOID,SendComplete)   (THIS_ LPVOID,DWORD) PURE;
};

/*
 * GUID for IDirectPlaySP
 */
// {0C9F6360-CC61-11cf-ACEC-00AA006886E3}
DEFINE_GUID(IID_IDirectPlaySP, 0xc9f6360, 0xcc61, 0x11cf, 0xac, 0xec, 0x0, 0xaa, 0x0, 0x68, 0x86, 0xe3);

/* CALLBACK DATA STRUCTURES
 *
 * These are passed by DirectPlay to the service provider when
 * the callback is invoked.
 */

/*
 * DPSP_ADDPLAYERTOGROUPDATA
 */
typedef struct _DPSP_ADDPLAYERTOGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_ADDPLAYERTOGROUPDATA;

typedef DPSP_ADDPLAYERTOGROUPDATA FAR* LPDPSP_ADDPLAYERTOGROUPDATA;

/*
 * DPSP_CLOSEDATA - used with CloseEx
 */
typedef struct _DPSP_CLOSEDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CLOSEDATA;

typedef DPSP_CLOSEDATA FAR* LPDPSP_CLOSEDATA;

/*
 * DPSP_CREATEGROUPDATA
 */
typedef struct _DPSP_CREATEGROUPDATA 
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CREATEGROUPDATA;

typedef DPSP_CREATEGROUPDATA FAR* LPDPSP_CREATEGROUPDATA;

/*
 * DPSP_CREATEPLAYERDATA
 */
typedef struct _DPSP_CREATEPLAYERDATA
{
    DPID        idPlayer;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    LPVOID      lpSPMessageHeader;  // For local groups, lpSPMessageHeader will be 
                                    // NULL. For remote groups, lpSPMessageHeader 
                                    // will be the header that was received with 
                                    // the AddPlayer message.
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_CREATEPLAYERDATA;

typedef DPSP_CREATEPLAYERDATA FAR* LPDPSP_CREATEPLAYERDATA;

/*
 * DPSP_DELETEGROUPDATA
 */
typedef struct _DPSP_DELETEGROUPDATA
{
    DPID        idGroup;
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEGROUPDATA;

typedef DPSP_DELETEGROUPDATA FAR* LPDPSP_DELETEGROUPDATA;

/*
 * DPSP_DELETEPLAYERDATA
 */
typedef struct _DPSP_DELETEPLAYERDATA
{
    DPID        idPlayer;           //  player being deleted 
    DWORD       dwFlags;            //  DPLAYI_PLAYER_xxx flags 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_DELETEPLAYERDATA;

typedef DPSP_DELETEPLAYERDATA FAR* LPDPSP_DELETEPLAYERDATA;

/*
 * DPSP_ENUMSESSIONSDATA
 */
typedef struct _DPSP_ENUMSESSIONSDATA
{
    LPVOID      lpMessage;          //  enum message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      //  TRUE to return status on progress of enum
} DPSP_ENUMSESSIONSDATA;                

typedef DPSP_ENUMSESSIONSDATA FAR* LPDPSP_ENUMSESSIONSDATA;

/*
 * DPSP_GETADDRESSDATA
 */
typedef struct _DPSP_GETADDRESSDATA
{ 
    DPID        idPlayer;           // player (or group) to get ADDRESS for 
    DWORD       dwFlags;            // DPLAYI_PLAYER_xxx flags for idPlayer
    LPDPADDRESS lpAddress;          // return buffer for address of idPlayer
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSDATA;

typedef DPSP_GETADDRESSDATA FAR* LPDPSP_GETADDRESSDATA;

/*
 * DPSP_GETADDRESSCHOICESDATA
 */
typedef struct _DPSP_GETADDRESSCHOICESDATA
{ 
    LPDPADDRESS lpAddress;          // return buffer for address choices
    LPDWORD     lpdwAddressSize;    // pointer to size of address buffer. If 
                                    // this is less than the required size 
                                    // (or is 0) the service provider should
                                    // set *lpdwAddressSize to the required
                                    // size and return DPERR_BUFFERTOOSMALL
	IDirectPlaySP * lpISP;
} DPSP_GETADDRESSCHOICESDATA;

typedef DPSP_GETADDRESSCHOICESDATA FAR* LPDPSP_GETADDRESSCHOICESDATA;

/*
 * DPSP_GETCAPSDATA
 */
typedef struct _DPSP_GETCAPSDATA
{ 
    DPID        idPlayer;           //  player to get caps for 
    LPDPCAPS    lpCaps;
    DWORD       dwFlags;            //  DPGETCAPS_xxx 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_GETCAPSDATA;

typedef DPSP_GETCAPSDATA FAR* LPDPSP_GETCAPSDATA;

/*
 * DPSP_OPENDATA
 */
typedef struct _DPSP_OPENDATA
{ 
    BOOL        bCreate;            // TRUE if creating, FALSE if joining 
    LPVOID      lpSPMessageHeader;  // If we are joining a session, lpSPMessageData 
                                    // is the message data received with the 
                                    // EnumSessionsReply message. If we are creating 
                                    // a session, it will be set to NULL. 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
    BOOL		bReturnStatus;      // TRUE to return status on progress of open
    /*** fields added for DX 6 ***/    
    DWORD		dwOpenFlags;		// flags passed by app to IDirectPlayX->Open(...)
    DWORD		dwSessionFlags;		// flags passed by app in the session desc
} DPSP_OPENDATA;

typedef DPSP_OPENDATA FAR* LPDPSP_OPENDATA;

/*
 * DPSP_REMOVEPLAYERFROMGROUPDATA
 */
typedef struct _DPSP_REMOVEPLAYERFROMGROUPDATA
{
    DPID        idPlayer;
    DPID        idGroup;
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REMOVEPLAYERFROMGROUPDATA;

typedef DPSP_REMOVEPLAYERFROMGROUPDATA FAR* LPDPSP_REMOVEPLAYERFROMGROUPDATA;

/*
 * DPSP_REPLYDATA
 */
typedef struct _DPSP_REPLYDATA
{			  
    LPVOID      lpSPMessageHeader;  //  header that was received by dplay 
                                    // (with the message we're replying to) 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    DPID        idNameServer;       //  player id of nameserver 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_REPLYDATA;               

typedef DPSP_REPLYDATA FAR* LPDPSP_REPLYDATA;

/*
 * DPSP_SENDDATA
 */
typedef struct _DPSP_SENDDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDDATA;

typedef DPSP_SENDDATA FAR* LPDPSP_SENDDATA;

/*
 * DPSP_SENDTOGROUPDATA
 */
typedef struct _DPSP_SENDTOGROUPDATA
{
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPVOID      lpMessage;          //  message to send 
    DWORD       dwMessageSize;      //  size of message to send (including sp header) 
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SENDTOGROUPDATA;

typedef DPSP_SENDTOGROUPDATA FAR* LPDPSP_SENDTOGROUPDATA;

/*
 * DPSP_SENDEXDATA
 */
typedef struct _DPSP_SENDEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idPlayerTo;         //  player we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.
    BOOL        bSystemMessage;     //  TRUE if this is a system message 
    
} DPSP_SENDEXDATA;

typedef DPSP_SENDEXDATA FAR* LPDPSP_SENDEXDATA;


/*
 * DPSP_SENDTOGROUPEXDATA
 */
typedef struct _DPSP_SENDTOGROUPEXDATA
{
	IDirectPlaySP * lpISP;			//  indication interface
	
    DWORD       dwFlags;            //  e.g. DPSEND_GUARANTEE 
    DPID        idGroupTo;          //  group we're sending to 
    DPID        idPlayerFrom;       //  player we're sending from 
    LPSGBUFFER  lpSendBuffers;      //  scatter gather array of send data
    DWORD       cBuffers;           //  count of buffers
    DWORD       dwMessageSize;      //  total size of message
    DWORD       dwPriority;         //  message priority
    DWORD       dwTimeout;          //  timeout for message in ms (don't send after t/o)
    LPVOID      lpDPContext;        //  async only: context value to use when notifying completion
    LPDWORD     lpdwSPMsgID;        //  async only: message id to be assigned by SP for use in other apis.

} DPSP_SENDTOGROUPEXDATA;

typedef DPSP_SENDTOGROUPEXDATA FAR* LPDPSP_SENDTOGROUPEXDATA;

/*
 * DPSP_GETMESSAGEQUEUE
 */
typedef struct _DPSP_GETMESSAGEQUEUEDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;
	DPID            idFrom;			
	DPID            idTo;
	LPDWORD         lpdwNumMsgs;
	LPDWORD         lpdwNumBytes;

} DPSP_GETMESSAGEQUEUEDATA;

typedef DPSP_GETMESSAGEQUEUEDATA FAR* LPDPSP_GETMESSAGEQUEUEDATA;

/*
 * DPSP_CANCELSEND
 */
 
#define DPCANCELSEND_PRIORITY		0x00000001
#define DPCANCELSEND_ALL            0x00000002

typedef struct _DPSP_CANCELDATA
{
	IDirectPlaySP * lpISP;			//  indication interface

	DWORD           dwFlags;        // 0,DPCANCELSEND_PRIORITY,DPCANCELSEND_ALL,etc.
	LPRGLPVOID      lprglpvSPMsgID; // cancel just these messages      (dwFlags == 0)
	DWORD           cSPMsgID;       // number of message id's in array (dwFlags == 0)
	DWORD           dwMinPriority;  // cancel all sends at this priority (dwFlags==DPCANCELSEND_PRIORITY)
	DWORD           dwMaxPriority;  // cancel all sends between Min and Max.
	
} DPSP_CANCELDATA;

typedef DPSP_CANCELDATA FAR* LPDPSP_CANCELDATA;

/*
 * DPSP_SHUTDOWNDATA - used with ShutdownEx
 */
typedef struct _DPSP_SHUTDOWNDATA
{
    /*** fields added for DX 5 ***/
	IDirectPlaySP * lpISP;
} DPSP_SHUTDOWNDATA;

typedef DPSP_SHUTDOWNDATA FAR* LPDPSP_SHUTDOWNDATA;

/*
 * Prototypes for callbacks returned by SPInit.
 */
typedef HRESULT   (WINAPI *LPDPSP_CREATEPLAYER)(LPDPSP_CREATEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEPLAYER)(LPDPSP_DELETEPLAYERDATA);
typedef HRESULT   (WINAPI *LPDPSP_SEND)(LPDPSP_SENDDATA);
typedef HRESULT   (WINAPI *LPDPSP_ENUMSESSIONS)(LPDPSP_ENUMSESSIONSDATA);
typedef HRESULT   (WINAPI *LPDPSP_REPLY)(LPDPSP_REPLYDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWN)(void);
typedef HRESULT   (WINAPI *LPDPSP_CREATEGROUP)(LPDPSP_CREATEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_DELETEGROUP)(LPDPSP_DELETEGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_ADDPLAYERTOGROUP)(LPDPSP_ADDPLAYERTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_REMOVEPLAYERFROMGROUP)(LPDPSP_REMOVEPLAYERFROMGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETCAPS)(LPDPSP_GETCAPSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESS)(LPDPSP_GETADDRESSDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETADDRESSCHOICES)(LPDPSP_GETADDRESSCHOICESDATA);
typedef HRESULT   (WINAPI *LPDPSP_OPEN)(LPDPSP_OPENDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSE)(void);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUP)(LPDPSP_SENDTOGROUPDATA);
typedef HRESULT   (WINAPI *LPDPSP_SHUTDOWNEX)(LPDPSP_SHUTDOWNDATA);
typedef HRESULT   (WINAPI *LPDPSP_CLOSEEX)(LPDPSP_CLOSEDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDEX)(LPDPSP_SENDEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_SENDTOGROUPEX)(LPDPSP_SENDTOGROUPEXDATA);
typedef HRESULT   (WINAPI *LPDPSP_CANCEL)(LPDPSP_CANCELDATA);
typedef HRESULT   (WINAPI *LPDPSP_GETMESSAGEQUEUE)(LPDPSP_GETMESSAGEQUEUEDATA);

/*
 * DPSP_SPCALLBACKS
 *
 * Table of callback pointers passed to SPInit. The service provider should fill
 * in the functions it implements. If the service provider does not implement
 * a callback, it should not set the table value for the unimplemented callback.
 */
typedef struct _DPSP_SPCALLBACKS
{
    DWORD                       dwSize;             //  size of table 
    DWORD                       dwVersion;			// 	the DPSP_MAJORVERSION of this DPLAY object
													// 	for DX3, this was 0. 
    LPDPSP_ENUMSESSIONS         EnumSessions;       //  required 
    LPDPSP_REPLY                Reply;              //  required 
    LPDPSP_SEND                 Send;               //  required 
    LPDPSP_ADDPLAYERTOGROUP     AddPlayerToGroup;   //  optional 
    LPDPSP_CLOSE                Close;              //  optional - for DX3 compat only
    LPDPSP_CREATEGROUP          CreateGroup;        //  optional 
    LPDPSP_CREATEPLAYER         CreatePlayer;       //  optional 
    LPDPSP_DELETEGROUP          DeleteGroup;        //  optional 
    LPDPSP_DELETEPLAYER         DeletePlayer;       //  optional 
    LPDPSP_GETADDRESS           GetAddress;         //  optional 
    LPDPSP_GETCAPS              GetCaps;            //  required 
    LPDPSP_OPEN                 Open;               //  optional 
    LPDPSP_REMOVEPLAYERFROMGROUP RemovePlayerFromGroup; //  optional 
    LPDPSP_SENDTOGROUP          SendToGroup;        //  optional 
    LPDPSP_SHUTDOWN             Shutdown;           //  optional - for DX3 compat only
    /*** fields added for DX 5 ***/
    LPDPSP_CLOSEEX	            CloseEx;			//  optional 
    LPDPSP_SHUTDOWNEX			ShutdownEx;			//  optional 
    LPDPSP_GETADDRESSCHOICES	GetAddressChoices;	//  optional 
	/*** fields added for DX 6 ***/
    /*** for async ***/
    LPDPSP_SENDEX               SendEx;             //  optional - required for async
    LPDPSP_SENDTOGROUPEX        SendToGroupEx;      //  optional - optional for async
    LPDPSP_CANCEL               Cancel;             //  optional - optional for async, highly recommended
    LPDPSP_GETMESSAGEQUEUE      GetMessageQueue;    //  optional - optional for async, highly recommended
} DPSP_SPCALLBACKS;             

typedef DPSP_SPCALLBACKS FAR *LPDPSP_SPCALLBACKS;

/*
 * SPINITDATA
 *
 * Data structure passed to the service provider at SPInit.
 */
typedef struct _SPINITDATA 
{
    LPDPSP_SPCALLBACKS  lpCB;               //  service provider fills in entry points 
    IDirectPlaySP      	* lpISP;            //  used to call back into DirectPlay 
                                            // (e.g. when message is received) 
    LPWSTR              lpszName;           //  service provider name from registry 
    LPGUID              lpGuid;             //  service provider GUID from registry 
    DWORD               dwReserved1;        //  service provider-specific data from registry 
    DWORD               dwReserved2;        //  service provider-specific data from registry 
    DWORD               dwSPHeaderSize;     //  dwSPHeaderSize is the size of the 
                                            //  data the sp wants stored with each message.
                                            //  DirectPlay will allocate dwSPHeaderSize 
                                            //  bytes at the beginning of each message.
                                            //  The service provider can then do what 
                                            //  they want with these. 
    LPDPADDRESS         lpAddress;          //  address to use for connection
    DWORD               dwAddressSize;      //  size of address data
    DWORD               dwSPVersion;        //  version number 16 | 16 , major | minor version 
} SPINITDATA;

typedef SPINITDATA FAR* LPSPINITDATA;

/*
 * SPInit
 *
 * DirectPlay calls this function to initialize the service provider.
 * All service providers must export this entry point from their DLL.
 */
typedef HRESULT (WINAPI *LPDPSP_SPINIT)(LPSPINITDATA);

HRESULT WINAPI SPInit(LPSPINITDATA);

/*
 * gdwDPlaySPRefCount
 *
 * To ensure that the DPLAYX.DLL will not be unloaded before the service
 * provider, the server provider should statically link to DPLAYX.LIB and
 * increment this global during the SPINIT call and decrement this global
 * during Shutdown.
 */
extern __declspec(dllimport) DWORD gdwDPlaySPRefCount;


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	DPlay.DLL initialization
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *   1/16		andyco	ported from dplay to dp2
 *	11/04/96	myronth	added DPAsyncData crit section initialization
 *	2/26/97		myronth	removed DPAsyncData stuff
 *	3/1/97		andyco	added print verison string
 *	3/12/97		myronth	added LobbyProvider list cleanup
 *  3/12/97     sohailm added declarations for ghConnectionEvent,gpFuncTbl,gpFuncTblA,ghSecLib
 *                      replaced session desc string cleanup code with a call to FreeDesc()
 *	3/15/97		andyco	moved freesessionlist() -> freesessionlist(this) into dpunk.c
 *  5/12/97     sohailm renamed gpFuncTbl to gpSSPIFuncTbl and ghSecLib to ghSSPI.
 *                      added declarations for gpCAPIFuncTbl, ghCAPI.
 *                      added support to free CAPI function table and unload the library.
 *	6/4/97		kipo	bug #9453: added CloseHandle(ghReplyProcessed)
 *	8/22/97		myronth	Made a function out of the SPNode cleanup code
 *	11/20/97	myronth	Made EnumConnections & DirectPlayEnumerate 
 *						drop the lock before calling the callback (#15208)
 *   3/9/98     aarono  added init and delete of critical section for
 *                      packetize timeout list.
 * 04/11/00     rodtoll     Added code for redirection for custom builds if registry bit is set 
 * 07/26/00     aarono 	make application key r/w for everyone so dplay lobbied apps can be
 *                   	registered by non-admins.
 * 06/19/01     RichGr  DX8.0 added special security rights for "everyone" - remove them if they exist.
 ***************************************************************************/

#include "dplaypr.h"
#include "dpneed.h"
#include "dpmem.h"
#include "..\..\bldcfg\dpvcfg.h"
#include "accctrl.h"
#include "dplobpr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DLLMain"

DWORD dwRefCnt=0;// the # of attached processes
BOOL bFirstTime=TRUE;
LPCRITICAL_SECTION	gpcsDPlayCritSection,
					gpcsServiceCritSection,
					gpcsDPLCritSection,
					gpcsDPLQueueCritSection,
					gpcsDPLGameNodeCritSection;
BOOL gbWin95 = TRUE;
extern LPSPNODE gSPNodes;// from api.c
extern CRITICAL_SECTION g_SendTimeOutListLock; // from paketize.c

// global event handles. these are set in handler.c when the 
// namesrvr responds to our request.
HANDLE ghEnumPlayersReplyEvent,ghRequestPlayerEvent,ghReplyProcessed, ghConnectionEvent;
#ifdef DEBUG
// count of dplay crit section
int gnDPCSCount; // count of dplay lock
#endif 
// global pointers to sspi function tables
PSecurityFunctionTableA	gpSSPIFuncTblA = NULL;  // Ansi
PSecurityFunctionTable	gpSSPIFuncTbl = NULL;   // Unicode
// global pointe to capi function table
LPCAPIFUNCTIONTABLE gpCAPIFuncTbl = NULL;

// sspi libaray handle, set when sspi is initialized
HINSTANCE ghSSPI=NULL;
// capi libaray handle, set when capi is initialized
HINSTANCE ghCAPI=NULL;


// free up the list of sp's built by directplayenum
HRESULT FreeSPList(LPSPNODE pspHead)
{
	LPSPNODE pspNext;

	while (pspHead)
	{
		// get the next node
		pspNext = pspHead->pNextSPNode;
		// free the current node
		FreeSPNode(pspHead);
		// repeat
		pspHead = pspNext;
	}
	
	return DP_OK;

} // FreeSPList

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MONOLITHIC BUILD REDIRECT FUNCTIONS
//

typedef HRESULT (WINAPI *PFN_DIRECTPLAYCREATE)(LPGUID lpGUIDSP, LPDIRECTPLAY *lplpDP, IUnknown *lpUnk );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUM)(LPDPENUMDPCALLBACK lpEnumCallback,LPVOID lpContext);
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUMA)(LPDPENUMDPCALLBACKA lpEnumCallback,LPVOID lpContext );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_A)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_W)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

HMODULE ghRedirect = NULL;
PFN_DIRECTPLAYCREATE pfnDirectPlayCreate = NULL;
PFN_DIRECTPLAYENUMA pfnDirectPlayEnum = NULL;
PFN_DIRECTPLAYLOBBYCREATE_A pfnDirectPlayLobbyCreateA = NULL;
PFN_DIRECTPLAYLOBBYCREATE_W pfnDirectPlayLobbyCreateW = NULL;
PFN_DIRECTPLAYENUMA pfnDirectPlayEnumA = NULL;
PFN_DIRECTPLAYENUM pfnDirectPlayEnumW = NULL;
PFN_DLLGETCLASSOBJECT pfnGetClassObject = NULL;
PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow = NULL;

#ifdef DPLAY_LOADANDCHECKTRUE 

BOOL CheckForDPPrivateBit( DWORD dwBit )
{
    HKEY    hKey;
    LONG    lErr;
    DWORD	type;
    DWORD	cb;
    DWORD	id;
    DWORD	flags;
    BOOL    fResult;

    fResult = FALSE;
        
    lErr = OS_RegOpenKeyEx( DPLAY_LOADTREE_REGTREE, DPLAY_LOADTRUE_REGPATH,0,KEY_READ, &hKey );

    if( lErr != ERROR_SUCCESS )
    {
        return FALSE;
    }

    cb = sizeof(flags);

    lErr = RegQueryValueExA( hKey, DPLAY_LOADTRUE_REGKEY_A, NULL, &type, (LPSTR) &flags, &cb );

    if( type != REG_DWORD )
    {
        fResult = FALSE;
    }
    else if( flags & dwBit )
    {
        fResult = TRUE;
    }
    else
    {
        fResult = FALSE;
    }

    RegCloseKey( hKey );

    return fResult;
}

HRESULT InitializeRedirectFunctionTable()
{
    LONG lLastError;
    
    if( CheckForDPPrivateBit( DPLAY_LOADTRUE_BIT ) )
    {
        ghRedirect = OS_LoadLibrary( L"dplayx.dll" );

        if( ghRedirect == NULL )
        {
            lLastError = GetLastError();
            
            DPF( 0, "Could not load dplayx.dll error = 0x%x", lLastError );
			return DPERR_GENERIC;

        }

        pfnDirectPlayCreate = (PFN_DIRECTPLAYCREATE) GetProcAddress( ghRedirect, "DirectPlayCreate" );
        pfnDirectPlayEnum = (PFN_DIRECTPLAYENUMA) GetProcAddress( ghRedirect, "DirectPlayEnumerate" );
        pfnDirectPlayLobbyCreateA = (PFN_DIRECTPLAYLOBBYCREATE_A) GetProcAddress( ghRedirect, "DirectPlayLobbyCreateA" );
        pfnDirectPlayLobbyCreateW = (PFN_DIRECTPLAYLOBBYCREATE_W) GetProcAddress( ghRedirect, "DirectPlayLobbyCreateW" );
        pfnDirectPlayEnumA = (PFN_DIRECTPLAYENUMA) GetProcAddress( ghRedirect, "DirectPlayEnumerateA" );
        pfnDirectPlayEnumW = (PFN_DIRECTPLAYENUM) GetProcAddress( ghRedirect, "DirectPlayEnumerateW" );
		pfnGetClassObject = (PFN_DLLGETCLASSOBJECT) GetProcAddress( ghRedirect, "DllGetClassObject" );
		pfnDllCanUnLoadNow = (PFN_DLLCANUNLOADNOW) GetProcAddress( ghRedirect, "DllCanUnloadNow" );
    }

    return DP_OK;    
}

HRESULT FreeRedirectFunctionTable()
{
    if( ghRedirect != NULL )
        FreeLibrary( ghRedirect );

    return DP_OK;
}
#endif

#if 0
// walk the list of dplay objects, and shut 'em down!
HRESULT CleanUpObjectList()
{
#ifdef DEBUG	
	HRESULT hr;
#endif 	
	
	DPF_ERRVAL("cleaning up %d unreleased objects",gnObjects);
	while (gpObjectList)
	{
#ifdef DEBUG	
		hr = VALID_DPLAY_PTR(gpObjectList);
		// DPERR_UNINITIALIZED is a valid failure here...
		if (FAILED(hr) && (hr != DPERR_UNINITIALIZED))
		{
			DPF_ERR("bogus dplay in object list");
			ASSERT(FALSE);
		}
#endif 
		//		
		// when this returns 0, gpObjectList will be released
		// 
		while (DP_Release((LPDIRECTPLAY)gpObjectList->pInterfaces)) ;
	}

	return DP_OK;
		
} // CleanUpObjectList

#endif 

#ifdef DEBUG
void PrintVersionString(HINSTANCE hmod)
{
	LPBYTE 				pbVersion;
 	DWORD 				dwVersionSize;
	DWORD 				dwBogus; // for some reason, GetFileVersionInfoSize wants to set something
								// to 0.  go figure.
    DWORD				dwLength=0;
	LPSTR				pszVersion=NULL;

			
	dwVersionSize = GetFileVersionInfoSizeA(DPLAY_FILENAME_DPLAYX_A,&dwBogus);
	if (0 == dwVersionSize )
	{
		DPF_ERR(" could not get version size");
		return ;
	}
	
	pbVersion = DPMEM_ALLOC(dwVersionSize);
	if (!pbVersion)
	{
		DPF_ERR("could not get version ! out of memory");
		return ;
	}
	
	if (!GetFileVersionInfoA(DPLAY_FILENAME_DPLAYX_A,0,dwVersionSize,pbVersion))
	{
		DPF_ERR("could not get version info!");
		goto CLEANUP_EXIT;
	}

    if( !VerQueryValueA( pbVersion, "\\StringFileInfo\\040904E4\\FileVersion", (LPVOID *)&pszVersion, &dwLength ) )
    {
		DPF_ERR("could not query version");
		goto CLEANUP_EXIT;
    }

	OutputDebugStringA("\n");

    if( NULL != pszVersion )
    {
 		DPF(0," " DPLAY_FILENAME_DPLAYX_A " - version = %s",pszVersion);
    }
	else 
	{
 		DPF(0," " DPLAY_FILENAME_DPLAYX_A " - version unknown");
	}

	OutputDebugStringA("\n");	

	// fall through
		
CLEANUP_EXIT:
	DPMEM_FREE(pbVersion);
	return ;			

} // PrintVersionString

#endif  // DEBUG

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        #if 0
        _asm 
        {
        	 int 3
        };
		#endif 
        DisableThreadLibraryCalls( hmod );
        DPFINIT(); 

		
        /*
         * is this the first time?
         */
        if( InterlockedExchange( &bFirstTime, FALSE ) )
        {
            
            ASSERT( dwRefCnt == 0 );

	        /*
	         * initialize memory
	         */
			// Init this CSect first since the memory routines use it
			INIT_DPMEM_CSECT();

            if( !DPMEM_INIT() )
            {
                DPF( 1, "LEAVING, COULD NOT MemInit" );
                return FALSE;
            }
	
			#ifdef DEBUG
			PrintVersionString(hmod);
			#endif 
			
	        DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
                        GetCurrentProcessId(), GetCurrentThreadId() );
#ifdef DPLAY_LOADANDCHECKTRUE       
            InitializeRedirectFunctionTable();
#endif            

			// alloc the crit section
			gpcsDPlayCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPlayCritSection) 
			{
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the service crit section
			gpcsServiceCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsServiceCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby crit section
			gpcsDPLCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby Message Queue crit section
			gpcsDPLQueueCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLQueueCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPMEM_FREE(gpcsDPLCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// alloc the DPLobby game node crit section
			gpcsDPLGameNodeCritSection = DPMEM_ALLOC(sizeof(CRITICAL_SECTION));
			if (!gpcsDPLGameNodeCritSection) 
			{
				DPMEM_FREE(gpcsDPlayCritSection);
				DPMEM_FREE(gpcsServiceCritSection);
				DPMEM_FREE(gpcsDPLCritSection);
				DPMEM_FREE(gpcsDPLQueueCritSection);
				DPF(0,"DLL COULD NOT LOAD - MEM ALLOC FAILED");
				return(FALSE);
			}

			// set up the events
			ghEnumPlayersReplyEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
			ghRequestPlayerEvent = CreateEventA(NULL,TRUE,FALSE,NULL);
          	ghReplyProcessed = CreateEventA(NULL,TRUE,FALSE,NULL);
          	ghConnectionEvent = CreateEventA(NULL,TRUE,FALSE,NULL);

 	

			// Initialize CriticalSection for Packetize Timeout list
			InitializeCriticalSection(&g_PacketizeTimeoutListLock);

          	INIT_DPLAY_CSECT();
			INIT_SERVICE_CSECT();
          	INIT_DPLOBBY_CSECT();
			INIT_DPLQUEUE_CSECT();
			INIT_DPLGAMENODE_CSECT();
        }

        ENTER_DPLAY();

		// Set the platform flag
		if(OS_IsPlatformUnicode())
			gbWin95 = FALSE;

        dwRefCnt++;

        LEAVE_DPLAY();
        break;

    case DLL_PROCESS_DETACH:
        
        ENTER_DPLAY();

        DPF( 2, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
                DllMain, GetCurrentProcessId(), GetCurrentThreadId() );

        dwRefCnt--;        
       	if (0==dwRefCnt) 
       	{		  
			DPF(0,"dplay going away!");

			if (0 != gnObjects)
			{
				DPF_ERR(" PROCESS UNLOADING WITH DPLAY OBJECTS UNRELEASED");			
				DPF_ERRVAL("%d unreleased objects",gnObjects);
			}
			
			FreeSPList(gSPNodes);
			gSPNodes = NULL;		// Just to be safe
			PRV_FreeLSPList(glpLSPHead);
			glpLSPHead = NULL;		// Just to be safe

			if (ghEnumPlayersReplyEvent) CloseHandle(ghEnumPlayersReplyEvent);
			if (ghRequestPlayerEvent) CloseHandle(ghRequestPlayerEvent);
			if (ghReplyProcessed) CloseHandle(ghReplyProcessed);
			if (ghConnectionEvent) CloseHandle(ghConnectionEvent);
            
			LEAVE_DPLAY();      	
       	    
       	    FINI_DPLAY_CSECT();	
			FINI_SERVICE_CSECT();
           	FINI_DPLOBBY_CSECT();
			FINI_DPLQUEUE_CSECT();
			FINI_DPLGAMENODE_CSECT();

			// Delete CriticalSection for Packetize Timeout list
			DeleteCriticalSection(&g_PacketizeTimeoutListLock); 

			DPMEM_FREE(gpcsDPlayCritSection);
			DPMEM_FREE(gpcsServiceCritSection);
			DPMEM_FREE(gpcsDPLCritSection);
			DPMEM_FREE(gpcsDPLQueueCritSection);
			DPMEM_FREE(gpcsDPLGameNodeCritSection);

            if (ghSSPI)
            {
                FreeLibrary(ghSSPI);
                ghSSPI = NULL;
            }
#ifdef DPLAY_LOADANDCHECKTRUE       
            FreeRedirectFunctionTable();
#endif            

            OS_ReleaseCAPIFunctionTable();

            if (ghCAPI)
            {
                FreeLibrary(ghCAPI);
                ghCAPI = NULL;
            }

			// Free this last since the memory routines use it
			FINI_DPMEM_CSECT();

        #ifdef DEBUG
			DPMEM_STATE();
        #endif // debug
			DPMEM_FINI(); 
       	} 
        else
        {
            LEAVE_DPLAY();		
        }

        break;

    default:
        break;
    }

    return TRUE;

} /* DllMain */

typedef BOOL (*PALLOCATEANDINITIALIZESID)(
  PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, // authority
  BYTE nSubAuthorityCount,                        // count of subauthorities
  DWORD dwSubAuthority0,                          // subauthority 0
  DWORD dwSubAuthority1,                          // subauthority 1
  DWORD dwSubAuthority2,                          // subauthority 2
  DWORD dwSubAuthority3,                          // subauthority 3
  DWORD dwSubAuthority4,                          // subauthority 4
  DWORD dwSubAuthority5,                          // subauthority 5
  DWORD dwSubAuthority6,                          // subauthority 6
  DWORD dwSubAuthority7,                          // subauthority 7
  PSID *pSid                                      // SID
);

typedef VOID (*PBUILDTRUSTEEWITHSID)(
  PTRUSTEE pTrustee,  // structure
  PSID pSid           // trustee name
);

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);

typedef DWORD (*PSETSECURITYINFO)(
  HANDLE handle,                     // handle to object
  SE_OBJECT_TYPE ObjectType,         // object type
  SECURITY_INFORMATION SecurityInfo, // buffer
  PSID psidOwner,                    // new owner SID
  PSID psidGroup,                    // new primary group SID
  PACL pDacl,                        // new DACL
  PACL pSacl                         // new SACL
);

typedef PVOID (*PFREESID)(
  PSID pSid   // SID to free
);



#undef DPF_MODNAME
#define DPF_MODNAME "NTRemoveAnyExcessiveSecurityPermissions"

// NTRemoveAnyExcessiveSecurityPermissions
//
// Removes "all access for everyone" rights from the specified key.
// This is identical to the old NTSetSecurityPermissions(), except that
// now we REVOKE_ACCESS instead of SET_ACCESS, and we don't have to fill
// out the rest of the EXPLICIT_ACCESS struct.
//
HRESULT NTRemoveAnyExcessiveSecurityPermissions( HKEY hKey )
{
	HRESULT						hr=DPERR_GENERIC;
    EXPLICIT_ACCESS				ExplicitAccess;
    PACL						pACL = NULL;
	PSID						pSid = NULL;
	HMODULE						hModuleADVAPI32 = NULL;
	SID_IDENTIFIER_AUTHORITY	authority = SECURITY_WORLD_SID_AUTHORITY;
	PALLOCATEANDINITIALIZESID	pAllocateAndInitializeSid = NULL;
	PBUILDTRUSTEEWITHSID		pBuildTrusteeWithSid = NULL;
	PSETENTRIESINACL			pSetEntriesInAcl = NULL;
	PSETSECURITYINFO			pSetSecurityInfo = NULL;
	PFREESID					pFreeSid = NULL;

	hModuleADVAPI32 = LoadLibraryA( "advapi32.dll" );

	if( !hModuleADVAPI32 )
	{
		DPF( 0, "Failed loading advapi32.dll" );
		goto EXIT;
	}

	pFreeSid = (PFREESID)( GetProcAddress( hModuleADVAPI32, "FreeSid" ) );
	pSetSecurityInfo = (PSETSECURITYINFO)( GetProcAddress( hModuleADVAPI32, "SetSecurityInfo" ) );
	pSetEntriesInAcl = (PSETENTRIESINACL)( GetProcAddress( hModuleADVAPI32, "SetEntriesInAclA" ) );
	pBuildTrusteeWithSid = (PBUILDTRUSTEEWITHSID)( GetProcAddress( hModuleADVAPI32, "BuildTrusteeWithSidA" ) );
	pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID)( GetProcAddress( hModuleADVAPI32, "AllocateAndInitializeSid" ) );

	if( !pFreeSid || !pSetSecurityInfo || !pSetEntriesInAcl || !pBuildTrusteeWithSid || !pAllocateAndInitializeSid )
	{
		DPF( 0, "Failed loading entry points" );
		hr = DPERR_GENERIC;
		goto EXIT;
	}

    ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
	ExplicitAccess.grfAccessMode = REVOKE_ACCESS;		//Remove any existing ACEs for the specified trustee

	if (pAllocateAndInitializeSid(
				&authority,
				1, 
				SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,	// trustee is "Everyone"
				&pSid
				))
	{
		pBuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

		hr = pSetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );

		if( hr == ERROR_SUCCESS )
		{
			hr = pSetSecurityInfo( hKey, SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL, pACL, NULL ); 

			if( FAILED( hr ) )
			{
				DPF( 0, "Unable to set security for key.  Error! hr=0x%x", hr );
			}
		} 
		else
		{
			DPF( 0, "SetEntriesInACL failed, hr=0x%x", hr );
		}
	}
	else
	{
		hr = GetLastError();
		DPF( 0, "AllocateAndInitializeSid failed lastError=0x%x", hr );
	}

EXIT:

	if( pACL )
	{
		LocalFree( pACL );
	}

	//Cleanup pSid
	if (pSid != NULL)
	{
		(pFreeSid)(pSid);
	}

	if( hModuleADVAPI32 )
	{
		FreeLibrary( hModuleADVAPI32 );
	}

	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "RegisterDefaultSettings"
//
// RegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
//
HRESULT RegisterDefaultSettings()
{
	HKEY hKey;
	LONG lReturn;

    lReturn=OS_RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_DPLAY_APPS_KEY,0 ,NULL,0,KEY_ALL_ACCESS,NULL,&hKey,NULL);
   	if( lReturn != ERROR_SUCCESS )
   	{
   		DPF(0,"Couldn't create registry key?\n");
   		return DPERR_GENERIC;
   	}

	if( OS_IsPlatformUnicode() )
	{
		HRESULT hr;

		// 6/19/01: DX8.0 added special security rights for "everyone" - remove them.
		hr = NTRemoveAnyExcessiveSecurityPermissions( hKey );

		if( FAILED( hr ) )
		{
			DPF( 0, "Error removing security permissions for app key hr=0x%x", hr );
		}
	} 

	RegCloseKey(hKey);

	return DP_OK;
	
}

#undef DPF_MODNAME
#define DPF_MODNAME "UnRegisterDefaultSettings"
//
// UnRegisterDefaultSettings
//
// This function registers the default settings for this module.  
//
//
HRESULT UnRegisterDefaultSettings()
{
	return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllRegisterServer"
HRESULT WINAPI DllRegisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( FAILED( hr = RegisterDefaultSettings() ) )
	{
		DPF( 0, "Could not register default settings hr = 0x%x", hr );
		fFailed = TRUE;
	}
	
	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME "DllUnregisterServer"
HRESULT WINAPI DllUnregisterServer()
{
	HRESULT hr = S_OK;
	BOOL fFailed = FALSE;

	if( FAILED( hr = UnRegisterDefaultSettings() ) )
	{
		DPF( 0, "Failed to remove default settings hr=0x%x", hr );
	}

	if( fFailed )
	{
		return E_FAIL;
	}
	else
	{
		return S_OK;
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dplaypr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaypr.h
 *  Content:	DirectPlay private header file
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	1/96	andyco	created it
 *	4/9/96	andyco	moved dplay private data structures here from dplayi.h 
 *	5/2/96	andyco	added dplayi_dplay_int interface pointer
 *	5/29/96	andyco	idplay2!
 *	6/8/96	andyco	moved player + group structs here from dplayi.h.
 *					replaced dplayi.h w/ dplaysp.h
 *	6/20/96	andyco	added WSTRLEN_BYTES
 *	6/22/96	kipo	added EnumConnectionData() method.
 *	6/25/96	kipo	added support for DPADDRESS.
 *	6/29/96 andyco	added localdata to player + group
 *	6/30/96	kipo	added support for CreateAddress() method.
 *  7/8/96  AjayJ   removed declaration for DP_SaveSession and DP_A_SaveSession
 *	7/24/96 andyco	changed nametable timeout to be 60 seconds
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *  8/1/96	andyco	added keep alive files, sysplayer id to player struct
 *	8/6/96	andyco	added version to players + groups
 * 	8/8/96	andyco	changed around default timeout values - we now base 
 *					(or try to) off of sp's timeout
 *  8/9/96  sohailm added hSPModule member to DPLAYI_DPLAY structure
 *	8/16/96 andyco	added pNameServer to DPLAYI_DPLAY
 *  10/1/96 sohailm added CopySessionDesc2() and DoSessionCallbacks() prototypes
 *  10/2/96 sohailm added VALID_READ_*_PTR() macros
 *                  renamed GUID validation macros to use the term GUID instead of UUID
 *                  modified VALID_READ_GUID_PTR() macro to not check for null ptr
 * 10/9/96	andyco	added gbWaitingForReply so we know when we get a (player id,enumplayers)
 *					reply from the nameserver whether anyone is waiting.
 * 10/11/96 sohailm added InternalSetSessionDesc() and SendSessionDescChanged() prototypes
 * 10/12/96	andyco	added pSysGroup to DPLAYI_DPLAY
 * 10/28/96	andyco	added update list constants, pvUpdateList, dwUpdateListSize to 
 *					group / players
 *	1/1/97	andyco	added support for system players w/ groups
 *	2/1/97	andyco	changed dplayi_dplay_nametablepending to fdplayi_dplay_pending,
 *					since we now go into pending mode for guaranteed sends (since
 *					we drop the lock.
 *	2/25/97	andyco	added dll list of dplay objects
 *	3/6/97	myronth	added support for lobby object within dplay object
 *  3/12/97 sohailm added LOGINSTATE(enum type), NAMETABLE_PHCONTEXT(constant), pvData field
 *                  to nametable, security related fields to DPLAYI_PLAYER and DPLAYI_DPLAY, 
 *                  VALID_READ_DPCREDENTIALS() and VALID_READ_DPSECURITYDESC() macros, internal
 *                  error definitions, and some function prototypes.
 *	3/15/97	andyco	hung session list off of dplayi_dplay instead of being global
 *	3/17/97	kipo	added support for CreateCompoundAddress()
 *	3/20/97	myronth	Added IS_LOBBYOWNED macro
 *	3/24/97	andyco	dec debug lock counter b4 dropping lock!
 *  3/24/97 sohailm Added dwVersion field to session node and updated prototype for 
 *                  SendCreateMessage to take a session password
 *	3/25/97	kipo	EnumConnections takes a const *GUID now;
 *					added VALID_DPSESSIONDESC2_FLAGS macro
 *  3/28/97 sohailm allow DPOPEN_CREATE in the VALID_DPSESSIONDESC2_FLAGS macro so we don't break
 *                  monster truck.
 *	4/3/97	myronth	Added a few function prototypes needed by the lobby
 *					Also added dependency in dplobpr.h on this file so the
 *					lobby now pulls in all dplay internals
 *  3/31/97 sohailm Added a more descriptive comment about the reason for making DPOPEN_CREATE a valid
 *                  session desc flag.
 *  4/09/97 sohailm Added security related members (ulMaxSignatureSize and ulMaxContextBufferSize)
 *                  to DPLAYI_DPLAY structure.
 *	4/20/97	andyco	groups in groups
 *  4/23/97 sohailm Added flags DPLAYI_DPLAY_SIGNINGSUPPORTED and DPLAYI_DPLAY_ENCRYPTIONSUPPORTED.
 *  5/05/97 kipo	Added interface for CallAppEnumSessionsCallback()
 *	5/8/97	andyco	removed update list, added handy macros
 *	5/8/97	myronth	Exposed RemoveGroupFromGroup & DistributeGroupMessage to lobby
 *	5/12/97	kipo	Fixed bug #5406
 *	5/13/97	myronth	Added DPLAYI_DPLAY_SPSECURITY to override dplay handling security
 *  5/17/97 sohailm Added DPLOGIN_KEYEXCHANGE state to LOGINSTATE.
 *                  Added hCSP,hPublicKey,hEncryptionKey,hDecryptionKey,pPublicKey, 
 *                   and dwPublicKeySize to LPDPLAYI_DPLAY.
 *                  Added extern definitions for gpSSPIFuncTbl,gpSSPIFuncTblA,ghSSPI,ghCAPI.
 *                  Added macros VALID_DPSECURITYDESC_FLAGS() and VALID_DPCREDENTIALS_FLAGS() 
 *                  Added prototypes for DP_GetAccountDesc, DP_A_GetAccountDesc, and InternalGetAccountDesc().
 *	5/17/97	myronth	SendChatMessage function prototypes, structure validation macros
 *	5/18/97	kipo	added validation macros for EnumPlayers/Groups, CreatePlayer/Groups
 *  5/19/97 sohailm Added a new login state DPLOGIN_SUCCESS.
 *  5/21/97 sohailm Added VALID_SIGNING_STATE() macro and prototype for InternalHandleMessage().
 *	5/23/97	andyco	added DPLAYI_DPLAY_HANDLEMULTICAST
 *	5/23/97	kipo	Added support for return status codes
 *	5/30/97	myronth	Added GetGroupParent
 *  5/30/97 sohailm Added VALID_DPACCOUNTDESC_FLAGS() macro. Renamed GetAccountDesc and related
 *                  prototypes to GetPlayerAccount().
 *	5/30/97	kipo	Added GetPlayerFlags() and GetGroupFlags()
 *  6/09/97 sohailm Renamed DPLOGIN_ACCESSDENIED to DPERR_LOGONDENIED
 *  6/22/97 sohailm Added CLIENTINFO structure and removed NAMETABLE_PHCONTEXT.
 *                  Moved phCredential and phContext from DPLAYI_PLAYER to DPLAYI_DPLAY.
 *                  Added pClientInfo to DPALAYI_PLAYER.
 *  6/23/97 sohailm Added hServerPublicKey to DPLAYI_DPLAY and hPublicKey to CLIENTINFO.
 *	8/5/97	andyco	async addforward
 *	8/19/97	myronth	Added pointer to lobby object that launched us
 *	8/19/97	myronth	Changed the object pointer to a lobby interface pointer
 *	8/29/97	sohailm	Added VALID_SPHEADER() macro
 *	8/22/97	myronth	Added Descriptions & flags to SPNODE structure
 *	10/21/97myronth	Added IDirectPlay4 structure definitions, added hidden
 *					and owner flags to macros, added owner method prototypes
 *	10/29/97myronth	Added group owner node structure, added node pointer to
 *					player struct, added owner ID to group struct
 *	11/5/97	myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/13/97myronth	Added VALID_CONNECT_FLAGS macro (#12541)
 *	11/19/97myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	11/24/97myronth	Fixed SetSessionDesc message for client/server (#15226)
 *	12/3/97	myronth	Changed DPCONNECT flag to DPCONNECT_RETURNSTATUS (#15451)
 *	1/21/98	myronth	Moved <mmsystem.h> include into this file for NT build
 *	1/27/98	myronth	Added prototype for NukeNameTableItem (#15255)
 *	1/28/98	sohailm	Added DP_MIN_KEEPALIVE_TIMEOUT and updated VALID_DPSESSIONDESC2_FLAGS()
 *  2/3/98  aarono  updated VALID_DPSESSIONDESC2_FLAGS()
 *  2/13/98 aarono  async support, added nPendingSends to player struct
 *  2/18/98 aarono  prototype of ConvertSendExDataToSendData for protocol
 *	2/18/98	a-peterz removed DPSESSION_OPTIMIZEBANDWIDTH.
 *  3/13/98 aarono  rearchitected packetizeandsendreliable
 *	5/11/98	a-peterz Add DPLAYI_DPLAY_ENUMACTIVE (#22920)
 *  6/6/98  aarono Fix for handling large loopback messages with protocol
 *  6/8/98  aarono Mark volatile fields
 *  6/10/98 aarono add PendingList to PLAYER and SENDPARM so we can track
 *                  pending sends and complete them on close.
 *  6/18/98 aarono fix group SendEx ASYNC to use unique Header
 *  6/19/98 aarono add last ptr for message queues, makes insert
 *                 constant time instead of O(n) where n is number
 *                 of messages in queue.
 *  8/02/99	aarono removed old voice support
 *  8/02/99	rodtoll voice support
 *  8/04/99 aarono more voice support work
 *  8/18/99	rodtoll Added apphack flag for voice retrofit support
 *	8/20/99	rodtoll	Added members for out of process retrofit and removed old members
 *  9/02/99	rodtoll	Modified dplay interface validation macros to accept new interface
 *  9/09/99	rodtoll	Added members to support new retrofit launch procedure
 * 11/02/99	rodtoll	Fixes to support Bug #116677 - Can't use lobby clients that don't hang around
 *  04/07/00 rodtoll Fixed Bug #32179 - Registering > 1 interface
 *           rodtoll Added support for nocopy sends (for voice)
 * 06/26/00 aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                    added re-notification during simultaneous join CREATEPLAYERVERIFY
 * 07/22/00	rodtoll	Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				Now for a thread to make an indication into voice they addref the interface
 *					so that the voice core can tell when all indications have returned.    
 *
 ***************************************************************************/

#ifndef __DPLAYPR_INCLUDED__
#define __DPLAYPR_INCLUDED__

#include <windows.h>
#include <stddef.h> // for offsetof
#include <sspi.h>   // for security info

#ifdef _WIN32_WINNT
#include <wincrypt.h>
#else
#define _WIN32_WINNT 0x400
#include <wincrypt.h> // for Crypto API
#undef _WIN32_WINNT
#endif

#include "dpf.h"
#include "dputils.h"
#include "dplaysp.h"
#include "dpmess.h"
#include "dpos.h"
#include "dpmem.h"
#include "dpcpl.h"
#include "dplobbyi.h"
#include "dpsecos.h"
#include "mcontext.h"
#include "fpm.h"
#include "bilink.h"
#include <mmsystem.h>
#include "dvoice.h"

typedef struct IDirectPlayVtbl DIRECTPLAYCALLBACKS;
typedef DIRECTPLAYCALLBACKS FAR * LPDIRECTPLAYCALLBACKS;

typedef struct IDirectPlay2Vtbl DIRECTPLAYCALLBACKS2;
typedef DIRECTPLAYCALLBACKS2 FAR * LPDIRECTPLAYCALLBACKS2;

typedef struct IDirectPlay2Vtbl DIRECTPLAYCALLBACKS2A;
typedef DIRECTPLAYCALLBACKS2A FAR * LPDIRECTPLAYCALLBACKS2A;

typedef struct IDirectPlay3Vtbl DIRECTPLAYCALLBACKS3;
typedef DIRECTPLAYCALLBACKS3 FAR * LPDIRECTPLAYCALLBACKS3;

typedef struct IDirectPlay3Vtbl DIRECTPLAYCALLBACKS3A;
typedef DIRECTPLAYCALLBACKS3A FAR * LPDIRECTPLAYCALLBACKS3A;

typedef struct IDirectPlay4Vtbl DIRECTPLAYCALLBACKS4;
typedef DIRECTPLAYCALLBACKS4 FAR * LPDIRECTPLAYCALLBACKS4;

typedef struct IDirectPlay4Vtbl DIRECTPLAYCALLBACKS4A;
typedef DIRECTPLAYCALLBACKS4A FAR * LPDIRECTPLAYCALLBACKS4A;


typedef struct IDirectPlaySPVtbl DIRECTPLAYCALLBACKSSP;
typedef DIRECTPLAYCALLBACKSSP FAR * LPDIRECTPLAYCALLBACKSSP;

typedef struct IDirectPlayVoiceTransportVtbl DIRECTPLAYVOICETRANSPORTCALLBACKS;
typedef DIRECTPLAYVOICETRANSPORTCALLBACKS FAR *LPDIRECTPLAYVOICETRANSPORTCALLBACKS;

// these guids are from dpwsock\dpsp.h
// we use them since golf shipped a bogus service provider
// when they ask for that service provider, we force it
// to the regular tcp/ip service provider

// the regular tcp/ip service provider
// 36E95EE0-8577-11cf-960C-0080C7534E82
DEFINE_GUID(GUID_TCP,
0x36E95EE0, 0x8577, 0x11cf, 0x96, 0xc, 0x0, 0x80, 0xc7, 0x53, 0x4e, 0x82);

// the bogus service provider (bogus 'cause it still links w/ ddhelp.exe
// which is no longer dplay's friend
// {3A826E00-31DF-11d0-9CF9-00A0C90A43CB}
DEFINE_GUID(GUID_LOCAL_TCP, 
0x3a826e00, 0x31df, 0x11d0, 0x9c, 0xf9, 0x0, 0xa0, 0xc9, 0xa, 0x43, 0xcb);


/********************************************************************
*                                                                    
* data structures moved from dplayi.h.  private dplay data structure 
*                                                                    
********************************************************************/

/*                      */
/* ADDRESSHEADER 		*/
/*                      */
// header for dp address.  used by InternalEnumConnections and createaddress.
typedef struct 
{
	DPADDRESS	dpaSizeChunk; // the size header
	DWORD		dwTotalSize; // the size
	DPADDRESS	dpaSPChunk; // the sp guid header
	GUID		guidSP; // the sp guid
	DPADDRESS	dpaAddressChunk; // the app's address header
	// address data follows
} ADDRESSHEADER, *LPADDRESSHEADER;



/*                      */
/* PACKET LIST	 		*/
/*                      */

#define INVALID_TIMER               0xFFFFFFFF

// each of this is a mesage that is being reconstructed on
// receive or a message that is being sent reliably using a
// simple ping-pong protocol.

typedef struct _PACKETNODE * LPPACKETNODE, *VOL LPPACKETNODE_V;
typedef struct _PACKETNODE
{
	union{
		LPPACKETNODE_V pNextPacketnode; // next packetnode in list-must be first element.		
		LPPACKETNODE_V pNext;		
	};	
	DWORD Signature;
	GUID guidMessage;     // id for this message
	LPBYTE pBuffer;       // pointer to message with extra space for SPHeader and MSG_PACKET for xmit.
	LPBYTE pMessage;      // message (excluding sp header)
	DWORD dwMessageSize;  // total size of message (excluding sp header)
	LPVOID pvSPHeader;    // header that came w/ 1st received packet, when not set, use dwIDTo/dwIDFrom and Send.
VOL	DWORD dwTotalPackets; 
VOL	DWORD dwSoFarPackets; // packets received/sent so far
	// new fields for reliability (ping-pong)
	BILINK RetryList;     // list of sends needing a retry.
	BILINK TimeoutList;   // list of sends timing out for retry.
	BOOL  bReliable;      // if set, we are doing the reliablity.
	BOOL  bReceive;       // set on all receives.
	LPDPLAYI_DPLAY lpDPlay;// dplay I/F ptr for use in TimeOuts
	DWORD dwLatency;      // assumed or observed round trip latency (ms).
	
VOL	UINT_PTR uRetryTimer;    // multi-media timer handle for re-xmit.
	DWORD Unique;
	
	UINT  tmTransmitTime; // Time of transmission of 1st try of packet.
	UINT  dwRetryCount;   // Number of times we retransmitted.
	UINT  tmLastReceive;  // Tick count we last got a receive on.
	// Fields used for Send (as opposed to Reply)
	DWORD dwIDTo;		  // To ID 
	DWORD dwIDFrom;       // From ID
	DWORD dwSendFlags;    // SendFlags
	
} PACKETNODE;


// client authentication states
typedef enum {
    DPLOGIN_NEGOTIATE,
    DPLOGIN_PROGRESS,
    DPLOGIN_ACCESSGRANTED,
    DPLOGIN_LOGONDENIED,
    DPLOGIN_ERROR,
	DPLOGIN_KEYEXCHANGE,
    DPLOGIN_SUCCESS
} LOGINSTATE;

// data structure used to store client specific information on 
// the server
typedef struct _CLIENTINFO
{
    CtxtHandle hContext;
    HCRYPTKEY hEncryptionKey;	// used for sending encrypted messages to client
    HCRYPTKEY hDecryptionKey;	// used for decrypting messages from client
    HCRYPTKEY hPublicKey;		// used for verification of signed messages from client
} CLIENTINFO, *LPCLIENTINFO;

/*                           */
/* SESSION DESCRIPTION LIST	 */
/*                           */
typedef struct _SESSIONLIST * LPSESSIONLIST, *VOL LPSESSIONLIST_V;
typedef struct _SESSIONLIST 
{
	DPSESSIONDESC2	dpDesc;
	LPVOID			pvSPMessageData;    // message data received w/ enumsessions reply
	LPSESSIONLIST_V	pNextSession;       // pointer to next session node
	DWORD			dwLastReply; // tick count when we last heard from this session
    DWORD           dwVersion;          // version of the sender
} SESSIONLIST;



/*                       */
/* PENDING LIST 		 */
/*                       */
typedef struct _PENDINGNODE * LPPENDINGNODE, *VOL LPPENDINGNODE_V;
typedef struct _PENDINGNODE 
{
	LPVOID	pMessage;
	DWORD 	dwMessageSize;
	LPVOID  pHeader;
	DPID 	idFrom,idTo;
	LPPENDINGNODE_V pNextNode;
	DWORD 	dwSendFlags;
} PENDINGNODE;

/*                       */
/* MESSAGE LIST 		 */
/*                       */
typedef struct _MESSAGENODE * LPMESSAGENODE, *VOL LPMESSAGENODE_V;
typedef struct _MESSAGENODE 
{
	LPVOID	pMessage;
	DWORD 	dwMessageSize;
	DPID 	idFrom,idTo;
	LPMESSAGENODE_V pNextMessage;
} MESSAGENODE;


/*                       */
/* NAME TABLE STUFF		 */
/*                       */

// each player id is defined as follows:
//      bits 0-15 : name table index
//      bits 16-31: uniqueness index
// the uniqueness index is used to make sure that if a location in the
// name table is reused, the user doesn't get the wrong contents
// index_mask masks off the uniqueness index from the name table index
#define INDEX_MASK 0x0000FFFF
// the initial size of the name table. when its full, we grow it by 2x.
#define NAMETABLE_INITSIZE 16
// used by nameserver to "hold" a slot for a client
#define NAMETABLE_PENDING ((DWORD_PTR)-1)

// max players is 2^16 (16 bits of index available in nametable)
#define DPLAY_MAX_PLAYERS  65536
// max buffer size is the max DWORD size
#define DPLAY_MAX_BUFFER_SIZE ((DWORD)-1)


/*                	       	*/
/* PLAYER + GROUP STUFF		*/
/*                       	*/

typedef struct _DPLAYI_PLAYER * LPDPLAYI_PLAYER,*VOL LPDPLAYI_PLAYER_V; 
typedef struct _DPLAYI_GROUP * LPDPLAYI_GROUP,*VOL LPDPLAYI_GROUP_V;
typedef struct _DPLAYI_DPLAY * LPDPLAYI_DPLAY, *VOL LPDPLAYI_DPLAY_V;
typedef struct _DPLAYI_GROUPNODE * LPDPLAYI_GROUPNODE, *VOL LPDPLAYI_GROUPNODE_V;
typedef struct _DPLAYI_SUBGROUP * LPDPLAYI_SUBGROUP, *VOL LPDPLAYI_SUBGROUP_V;
typedef struct _DPLAYI_GROUPOWNER * LPDPLAYI_GROUPOWNER, *VOL LPDPLAYI_GROUPOWNER_V;

/*                      */
/* DPLAYI_GROUPNODES    */
/*                      */
// this is a node in the list of all system players in a group, 
// each system player has a list of all local players in the group hanging
// off it
typedef struct _DPLAYI_GROUPNODE
{
        LPDPLAYI_GROUPNODE_V    pNextGroupnode; // the next groupnode in the list
        LPDPLAYI_PLAYER_V       pPlayer;
		UINT					nPlayers; // if pPlayer is a system player, nPlayers is the #
										  // of players that sysplayer has in this group
} DPLAYI_GROUPNODE;


/*                      */
/* DPLAYI_SUBGROUP    */
/*                      */
// this is a node in the list of all groups contained by a group
typedef struct _DPLAYI_SUBGROUP
{
        LPDPLAYI_SUBGROUP_V    	pNextSubgroup; // the next SUBGROUP in the list
		LPDPLAYI_GROUP_V		pGroup;
		DWORD 					dwFlags; // DPGROUP_STAGINGAREA, DPGROUP_SHORTCUT
} DPLAYI_SUBGROUP;

/*                      */
/* DPLAYI_GROUPOWNER    */
/*                      */
// this is a node in the list of groups a player is the owner of
typedef struct _DPLAYI_GROUPOWNER
{
		LPDPLAYI_GROUPOWNER_V	pNext;	// the next GROUPOWNER node in the list
		LPDPLAYI_GROUP_V		pGroup; // pointer to the group this player is the owner of
} DPLAYI_GROUPOWNER, *VOL DPLAYI_GROUPOWNER_V;

/*              */
/* DPLAYI_GROUP */
/*              */
// IMPORTANT - all fields up to dwSPDataSize must be kept the same in
// _DPLAYI_PLAYER + _DPLAYI_GROUP structs!!
typedef struct _DPLAYI_GROUP
{
    DWORD                       dwSize;
	DWORD						dwFlags;
    DPID                        dwID; // DPID for this group
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOIDV						pvPlayerData;
VOL	DWORD						dwPlayerDataSize;
	LPVOIDV						pvPlayerLocalData;
VOL	DWORD						dwPlayerLocalDataSize;
	// fields for service provider
	// service provider can store any info w/ spdata. whenever a player is created, spdata will be sent
	// w/ the rest of the player info to all remote machines.  
	LPVOID						pvSPData;   
	DWORD						dwSPDataSize; // SP sets this! 
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	DWORD						dwIDSysPlayer; // player id of this groups sys player
	DWORD						dwVersion;  // command version for system that created us
    LPDPLAYI_DPLAY              lpDP; // the dplay which created us
    DWORD                       nGroups; // # of groups to which a group belongs
	DPID						dwIDParent;	
	// fields above MUST BE kept common to player and group
    LPDPLAYI_GROUPNODE_V        pGroupnodes; // a list of the (non-system) players in the group
	LPDPLAYI_GROUPNODE_V 	    pSysPlayerGroupnodes; // a list of the system players to 
													  // whom group messages should be sent
    LPDPLAYI_GROUP_V            pNextGroup; // the list of all groups
VOL	UINT 						nPlayers; // # of players in the group
	LPDPLAYI_SUBGROUP_V			pSubgroups; // list of contained groups
VOL	UINT						nSubgroups;
	DWORD						dwOwnerID; // player id of the owner of this group (non-system player)
} DPLAYI_GROUP;

/*                      */
/* DPLAYI_PLAYER        */
/*                      */
// this is a node in the list of all players
// IMPORTANT - all fields up to dwSPDataSize must be kept the same in
// _DPLAYI_PLAYER + _DPLAYI_GROUP structs!!
typedef struct _DPLAYI_PLAYER
{
    DWORD                       dwSize;
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
    LPWSTR						lpszShortName;
    LPWSTR						lpszLongName;
	LPVOIDV						pvPlayerData;
VOL	DWORD						dwPlayerDataSize;
	LPVOIDV						pvPlayerLocalData;
VOL	DWORD						dwPlayerLocalDataSize;
	// fields for service provider
	// service provider can store any info w/ spdata. whenever a player is created, spdata will be sent
	// w/ the rest of the player info to all remote machines.  
	LPVOID						pvSPData;   
	DWORD						dwSPDataSize; // SP sets this!
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	DWORD						dwIDSysPlayer; // player id of this players sys player
	DWORD						dwVersion;  // command version for system that created us
    LPDPLAYI_DPLAY              lpDP; // the dplay which created us
    DWORD                       nGroups; // # of groups to which a player belongs
	DPID						dwIDParent;		
	// fields above MUST BE kept common to player and group
    LPDPLAYI_PLAYER_V           pNextPlayer; // the list of all players
    HANDLE						hEvent; // handle to player event
	// the fields below are used w/ keep alives + player latencies
	DWORD						dwLatencyLastPing; // observed latency on last ping -used when nothing else avail.
	DWORD						dwNPings; // how many latency data points do we have
	// async
	DWORD                       nPendingSends; // count async sends that haven't completed.
	// better keepalive	- a-josbor
VOL	DWORD						dwChatterCount;	// how many times have we heard/reliably talked to player?
VOL	DWORD						dwUnansweredPings;	// how many continguous unanswered pings have there been?
VOL DWORD						dwProtLastSendBytes;	// how many bytes had we sent last time keepalives checked?
VOL	DWORD						dwProtLastRcvdBytes;	// how many bytes had we received last time keepalives checked?

	DWORD						dwTimeToDie;		// when the player should be killed due to connlost
    // security related
    LPCLIENTINFO                pClientInfo;  // pointer to client specific info
	// group owner list -- list of groups this player is the owner of
	LPDPLAYI_GROUPOWNER_V		pOwnerGroupList;
	BILINK                      PendingList;	// list of pending async sends.
	DWORD						dwCreateTime;	// time we created this player (if local)
} DPLAYI_PLAYER;

typedef struct _NAMETABLE 
{
    DWORD_PTR dwItem; // the data stored here
    // dwUnique is used to verify that this 
    // is a valid entry - it must match the unique index in
    // the users dpid
    DWORD dwUnique; // 0-2^16, incremented every time a new id is given out for this slot
    LPVOID pvData;  // data stored here depends on the type specified by dwItem
} NAMETABLE;

typedef struct _NAMETABLE * LPNAMETABLE, *VOL LPNAMETABLE_V;

typedef void (*FREE_ROUTINE)(LPVOID context, LPVOID pMem);

typedef struct _BufferFree {
	FREE_ROUTINE fnFree;
	LPVOID       lpvContext;
} BUFFERFREE, *LPBUFFERFREE, *PBUFFERFREE;

typedef struct _GroupHeader {
	MSG_PLAYERMESSAGE Msg;		// MUST BE AT FRONT
	struct _GroupHeader *pNext;
} GROUPHEADER, *LPGROUPHEADER, *PGROUPHEADER;

#define MAX_SG	8		// Maximum Scatter Gather Entries for a send - internal only.

// Send Paramters structure, used to lower the stack load in send path.
typedef struct _SENDPARMS {

	LPVOID           pPoolLink; // reserve void pointer at front 
								// so cs not overwritten by pool manager

	CRITICAL_SECTION cs;

	BILINK  PendingList;		// pending list on Group or Player

	UINT    RefCount;

	LPVOID  lpData;				// user buffer pointer
	DWORD   dwDataSize;			// user buffer length

	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_PLAYER pPlayerTo;
	LPDPLAYI_GROUP  pGroupTo;

	MESSAGENODE     msn;		// for linking this struct on receiveQ

	// ++ don't reorder +++++++++++++++++++++++++++++++++++++++++++
	// The following part of the structure is exactly the same
	// content as a DPMSG_SENDCOMPLETE - don't re-order
		
	DWORD   dwType;
	DPID	idFrom;
	DPID	idTo;
	DWORD   dwFlags;
	DWORD   dwPriority;			// 0-65535, SendEx Only
	DWORD   dwTimeout;			// in milliseconds, SendEx Only
	LPVOID  lpUserContext;  	// SendEx, ASYNC only.
	PVOID   hContext;           // handle to context list
	HRESULT hr;
	DWORD   dwSendCompletionTime;
	// -- order dependancy ends here -------------------------------

	DWORD_PTR dwMsgID;            // to store ID if user not provided.
	DWORD_PTR *lpdwMsgID;			// SendEx, ASYNC only.

	DWORD   dwSendTime;         // Time we were called in SendEx

	// parallel arrays for scatter gather, kept separate so we don't
	// have to transcribet the buffers to call the SP_SendEx i/f
	UINT       cBuffers;		// Number of filled in buffers.
	DWORD      dwTotalSize;     // total size of send data.
	SGBUFFER   Buffers[MAX_SG];	// the buffers 
	BUFFERFREE BufFree[MAX_SG]; // their free routines

	// support context mappings, also hContext above...
	UINT       iContext;		// next avail context in list
	UINT       nContext;        // number of contexts in list
	
	UINT       nComplete;		// number of completions

	PGROUPHEADER pGroupHeaders;	// when sending to group we may need many headers.
	
} SENDPARMS, *PSENDPARMS, *LPSENDPARMS;


/*                      */
/* DPLAYI_FLAGS         */
/*                      */
// this dplay object is in pending mode. we're either waiting for the nametable,
// or we've dropped our lock for a guaranteed send. either way - any incoming messages get
// pushed onto the pending q
#define DPLAYI_DPLAY_PENDING 			0x00000001
// we've lost the session. bummer.
#define DPLAYI_DPLAY_SESSIONLOST		0x00000002
// dplay is closed for bidness. set when we get a close or shutdown
#define DPLAYI_DPLAY_CLOSED				0x00000004
// there is (at least one) DX3 client in the game
#define DPLAYI_DPLAY_DX3INGAME			0x00000008
// indicates we're currently flushing the pending q. means player messages don't 
// need to be copied again
#define DPLAYI_DPLAY_EXECUTINGPENDING 	0x00000010
// our sp is a dx3 sp 
#define DPLAYI_DPLAY_DX3SP			   	0x00000020
// we were created by CoCreateInstance, but no SP has been loaded yet 
// (initialize hasn't been called)
#define DPLAYI_DPLAY_UNINITIALIZED	   	0x00000040
// the service thread is doing async enums
#define DPLAYI_DPLAY_ENUM			   	0x00000080
// the service thread is doing keepalives
#define DPLAYI_DPLAY_KEEPALIVE		   	0x00000100
// the lobby owns this dplay object
#define DPLAYI_DPLAY_LOBBYOWNS			0x00000200
// dplay is providing security 
#define DPLAYI_DPLAY_SECURITY           0x00000400
// an async enum is in process
#define DPLAYI_DPLAY_ENUMACTIVE		   	0x00000800
// encryption support is available
#define DPLAYI_DPLAY_ENCRYPTION         0x00001000
// the SP is handling security
#define DPLAYI_DPLAY_SPSECURITY			0x00002000
// we're processing a multicast message
#define DPLAYI_DPLAY_HANDLEMULTICAST	0x00004000
// sp isn't reliable - startup system messages use new packetize
#define DPLAYI_DPLAY_SPUNRELIABLE       0x00008000
// running protocol exclusively for datagram and reliable
#define DPLAYI_DPLAY_PROTOCOL           0x00020000
// if set protocol need not maintain reliable receive order
#define DPLAYI_DPLAY_PROTOCOLNOORDER    0x00040000

// We are in the transitory period between a nameserver dropping out
// and a new nameserver being elected.
#define DPLAYI_DPLAY_NONAMESERVER       0x00100000

#define DPLAYI_PROTOCOL DPLAYI_DPLAY_PROTOCOL

// flags that get reset on DP_CLOSE
// note that we don't reset enum  - this is because if we enumplayers in a remote session,
// we leave the enum thread alone on close
#define DPLAYI_DPLAY_SESSIONFLAGS (DPLAYI_DPLAY_PENDING | DPLAYI_DPLAY_SESSIONLOST | DPLAYI_DPLAY_CLOSED \
	|  DPLAYI_DPLAY_DX3INGAME | DPLAYI_DPLAY_EXECUTINGPENDING | DPLAYI_DPLAY_KEEPALIVE \
    |  DPLAYI_DPLAY_ENCRYPTION | DPLAYI_DPLAY_SECURITY | DPLAYI_DPLAY_SPSECURITY \
    |  DPLAYI_DPLAY_PROTOCOL | DPLAYI_DPLAY_SPUNRELIABLE | DPLAYI_DPLAY_PROTOCOLNOORDER \
    |  DPLAYI_DPLAY_NONAMESERVER )

/*            */
/* APP HACKS  */
/*            */

// Japanese FORMULA1 crashes when we start our periodic multimedia timer
// since they were written for DirectPlay 5.0 we turn off the timer so
// we can't support the protocol OR reliable delivery.
#define DPLAY_APPHACK_NOTIMER		0x00000001

/*                      */
/* DPLAYI_SUPERPACKEDPLAYER  */
/*                      */
// this is the structure we use to xmit player data over the net - new for dx5
// see superpac.c
typedef struct _DPLAYI_SUPERPACKEDPLAYER
{
    DWORD             		    dwFixedSize; // size of this struct
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
	DWORD						dwMask;  // bitfield indicating which optional fields are present
} DPLAYI_SUPERPACKEDPLAYER,*LPDPLAYI_SUPERPACKEDPLAYER;
	
/*                      */
/* DPLAYI_PACKEDPLAYER  */
/*                      */
// this is the structure we use to xmit player data over the net
typedef struct _DPLAYI_PACKEDPLAYER
{
    DWORD                       dwSize; // packedplayer size + short name + long name
    DWORD                       dwFlags;   // DPLAYI_PLAYER_xxx
    DPID                        dwID; // DPID for this player.
    UINT                        iShortNameLength;
    UINT                        iLongNameLength; 
    DWORD                       dwSPDataSize;// sp data follows strings
	DWORD 						dwPlayerDataSize;
	DWORD						dwNumPlayers; // number of players in group. only used w/ groups.
	DWORD						dwIDSysPlayer; // id of this players sys player. player only
	DWORD						dwFixedSize; // size of packed player. we put this in struct
											//  so we can change it in future versions
	DWORD 						dwVersion; // version of this player or group
    // short name and then long name follow structure, then spdata, then playerdata
	// then, (for groups) list of player id's.
	//
	// ** added for DX5 **
	//
	DWORD						dwIDParent; // if it was creategroupingroup

} DPLAYI_PACKEDPLAYER, *LPDPLAYI_PACKEDPLAYER;

/*                      */
/* SP Node stuff		*/
/*                      */
// this is where the service provider info read from
// the registry is kept

typedef struct _SPNODE
{
	LPTSTR		lpszName;
	LPTSTR		lpszPath;
	GUID		guid;
	DWORD		dwID;
	DWORD		dwReserved1;
	DWORD		dwReserved2;
	DWORD		dwNodeFlags;
	LPSTR		lpszDescA;
	LPWSTR		lpszDescW;
	struct _SPNODE * VOL pNextSPNode;
} SPNODE,*LPSPNODE;

// flags for SP Nodes
#define		SPNODE_DESCRIPTION		(0x00000001)
#define		SPNODE_PRIVATE			(0x00000002)

// an iunknown, idirectplay or idirectplay2 interface
typedef struct _DPLAYI_DPLAY_INT * LPDPLAYI_DPLAY_INT, *VOL LPDPLAYI_DPLAY_INT_V;
typedef struct _DPLAYI_DPLAY_INT
{
	LPVOID 				lpVtbl;
	LPDPLAYI_DPLAY		lpDPlay;
VOL	LPDPLAYI_DPLAY_INT 	pNextInt;	  // next interface on the dplay object
	DWORD 				dwIntRefCnt; // reference count for this interface

} DPLAYI_DPLAY_INT;

// a list of the addforward requests sent by a host, waiting for ack
typedef struct _ADDFORWARDNODE  * LPADDFORWARDNODE, *VOL LPADDFORWARDNODE_V;
typedef struct _ADDFORWARDNODE
{
	LPADDFORWARDNODE_V 	pNextNode; // next element in list
	DPID				dwIDSysPlayer; // system player who generated the addforward
	DWORD				nAcksRecv;  // # acks so far
	DWORD				nAcksReq;  // # of acks required
	DWORD				dwGiveUpTickCount; // tick count after we give up on acks, 
											// and just send nametable
	LPVOID				pvSPHeader; // header from dwIDSysPlayer - used to reply to	
									// when we finally get the nametable
 	DPID				dpidFrom; // if it was sent secure, id for returning nametable
	DWORD				dwVersion; // version of requestor
} ADDFORWARDNODE;

// Note protocol structure is actually much larger (see protocol\arpdint.h) this is
// just the bit that the DPLAY core needs to access.
typedef struct _PROTOCOL_PART {
		//
		// Service Provider info - at top so DPLAY can access easily through protocol ptr.
		//
		IDirectPlaySP   * m_lpISP;      	       	 	//  used by SP to call back into DirectPlay 

		DWORD             m_dwSPMaxFrame;
		DWORD             m_dwSPMaxGuaranteed;
		DWORD             m_dwSPHeaderSize;

		CRITICAL_SECTION  m_SPLock;						// lock calls to SP on our own, avoids deadlocks.

} PROTOCOL_PART, *LPPROTOCOL_PART;

// this is the number of clients of IDirectXVoice in this process
// this is actually a ridiculously large number of client slots.
#define MAX_VOICE_CLIENTS	32							

// this is the "class" that implements idirectplay
typedef struct _DPLAYI_DPLAY
{
	DWORD 						dwSize;
	LPDPLAYI_DPLAY_INT_V		pInterfaces; // list of interface objects pointing to this dplay object
    DWORD                       dwRefCnt; // ref cnt for the dplay object
    DWORD                       dwFlags;  // dplayi_xxx (see dplayi.h)
    DWORD                       dwSPFlags; // Flags from last call to GetCaps on SP.
    LPDPSP_SPCALLBACKS          pcbSPCallbacks; // sp entry points
    LPDPLAYI_PLAYER_V           pPlayers; // list of all players 
    LPDPLAYI_GROUP_V            pGroups;  // list of all groups
    LPDPLAYI_PLAYER             pSysPlayer; // pointer to our system player
    LPNAMETABLE_V               pNameTable; // player id <--> player
VOL UINT						nGroups;  // total # of groups
VOL	UINT						nPlayers; // total # of players
VOL UINT                        uiNameTableSize; // current alloc'ed size of nametable
VOL UINT                        uiNameTableLastUsed; // mru name table index
    LPDPSESSIONDESC2_V          lpsdDesc; // session desc for the current session
	LPMESSAGENODE_V				pMessageList; // list of all messages for local users
	LPMESSAGENODE_V             pLastMessage; // last element in MessageList
VOL	UINT						nMessages; // # of messages in message list
	DWORD						dwSPHeaderSize; // size of sp blob
	
	LPPENDINGNODE_V				pMessagesPending; // List of commands waiting for nametable
	LPPENDINGNODE_V             pLastPendingMessage; // Last element in PendingList
	UINT						nMessagesPending; //count of commands waiting for nametable
	
	DWORD						dwSPMaxMessage; // max unreliable send size for SP
	DWORD						dwSPMaxMessageGuaranteed; // max reliable send size for SP

	// PacketizeAndSend vars.
	LPPACKETNODE_V				pPacketList;
VOL	UINT_PTR                    uPacketTickEvent;	// MM timer handle for 15 second ticker
VOL	UINT                        nPacketsTimingOut;	// number of receives we are timing out
	
	// Retry sup for FacketizeAndSendReliable
VOL	HANDLE                      hRetryThread;
VOL	HANDLE                      hRetry;			
	BILINK                      RetryList;
	
VOL	HANDLE						hDPlayThread;
    HINSTANCE                   hSPModule; // SP module instance
VOL	HANDLE						hDPlayThreadEvent;
	LPDPLAYI_PLAYER_V			pNameServer; // pointer to the player that is the 
											 // nameserver.  null if we are the nameserver
											// or if we  don't have a nameserver yet.
    LPDPLAYI_GROUP_V			pSysGroup;
	LPDPLAYI_PLAYER_V			pServerPlayer; // the apps server player

	// dwServerPlayerVersion is used to track the server's version between when we enumsessions
	// and enumplayers in a session.  It is extremely transient.  Set in GetNameTable, cleared on Send.
	UINT                        dwServerPlayerVersion; 
	
	// control panel support
	LPDP_PERFDATA 				pPerfData;
	HANDLE						hPerfThread;
	HANDLE						hPerfEvent;
    // security related (valid on server and client)
    LPDPSECURITYDESC            pSecurityDesc;      // security description
    ULONG                       ulMaxContextBufferSize; // max size of opaque buffers
    ULONG                       ulMaxSignatureSize; // max size of digital signature
    HCRYPTPROV                  hCSP;               // handle to crypto service provider
    HCRYPTKEY                   hPublicKey;         // handle to system player's public key
    LPBYTE                      pPublicKey;         // public key buffer
    DWORD                       dwPublicKeySize;    // size of public key buffer
	// security related (valid only on client)
    LPDPCREDENTIALS             pUserCredentials;   // user provided credentials
    LOGINSTATE                  LoginState;         // tells the state of authentication
    PCredHandle                 phCredential;       // pointer to player's credential handle (given by package)
    PCtxtHandle                 phContext;          // pointer to security context (client only)
    HCRYPTKEY                   hEncryptionKey;     // session key used for encryption (client only)
    HCRYPTKEY                   hDecryptionKey;     // session key used for decryption (client only)
    HCRYPTKEY                   hServerPublicKey;   // handle to system player's public key

	// pointer to the sp node for the current sp
	LPSPNODE 					pspNode;
	// data the sp can stash w/ each IDirectPlaySP	
	LPVOID						pvSPLocalData;
	DWORD						dwSPLocalDataSize;
	IDirectPlaySP * 			pISP;
	LPDPLAYI_DPLAY_V			pNextObject; // pointer in our dll list of dplay objects
											// list is anchored at gpObjectList;
	DWORD						dwLastEnum;
	DWORD						dwLastPing;
	DWORD						dwEnumTimeout;
	LPBYTE						pbAsyncEnumBuffer;
	DWORD						dwEnumBufferSize;
	// Lobby stuff
	LPDPLOBBYI_DPLOBJECT		lpLobbyObject;	// pointer to our aggregated lobby object
	LPDIRECTPLAYLOBBY			lpLaunchingLobbyObject; // the lobby interface we were launched on

	// list of enumsessions responses
	// new sessions are added to this when handler.c receives enum responses
	LPSESSIONLIST_V				pSessionList; 
	DWORD						dwMinVersion; // the lowest version of a player in our session
	LPADDFORWARDNODE_V			pAddForwardList; // the list of addforward notifications waiting
	 											// for ack's
	LPPROTOCOL_PART             pProtocol;      // reliable protocol object

	LPFPOOL                     lpPlayerMsgPool;  // pool of player message headers.
	LPFPOOL                     lpSendParmsPool;  // pool of send parameter blocks.
	LPFPOOL                     lpMsgNodePool;

	// Pool of contexts for async send.
	PMSGCONTEXTTABLE            pMsgContexts;   // for async interface, context mapping table.
	LPVOID                      GrpMsgContextPool[MSG_FAST_CONTEXT_POOL_SIZE+1];
	CRITICAL_SECTION            ContextTableCS;

	// Support for waiting for and accepting Reply's
	CRITICAL_SECTION            ReplyCS;		// controls access to all vars in this section
VOL	HANDLE                      hReply;			// Autoreset event to wait for replies.
VOL	DWORD                       dwReplyCommand; // command reply we are waiting for 0xFFFF == ANY
												// if this is non-zero someone is already waiting.
	LPVOIDV                     pvReplySPHeader;// if reply has SPHeader, we store it here											
	PCHAR                       pReplyBuffer;   // Reply buffer goes here until accepted.

	// a-josbor: helper for making sure we don't let more than MaxPlayers in the game
	//	only used by the NameServer
	DWORD						dwPlayerReservations;	// how many unclaimed Player ids have we given out
	DWORD						dwLastReservationTime;	// when did we give out the most recent reservation?

	// a-josbor: the version number of the sp was not previously being remembered.  Remember it.
	DWORD               		dwSPVersion;        //  version number 16 | 16 , major | minor version 

	DWORD						dwZombieCount;		// how many zombie players (conn lost)
	DWORD                       dwAppHacks;

	CRITICAL_SECTION			csNotify;
	// voice specific information.---------------------------------------------
	// Parallel arrays of VoiceNotify and context values.
	LPDIRECTPLAYVOICENOTIFY		lpDxVoiceNotifyClient;
	LPDIRECTPLAYVOICENOTIFY		lpDxVoiceNotifyServer;	

	// Send Target Cache for voice targets on DV_SendSpeechEx
	DWORD						nTargets;			     // number of used entries in the target list
	DWORD						nTargetListLen;          // max number of target list entries list can hold
	LPDPID						pTargetList;	  	   // ptr to target list array
	DWORD						nExpandedTargets;        // simplified list of targets, removes dup's
	DWORD						nExpandedTargetListLen;  // max number of target list entries list can hold
	LPDPID						pExpandedTargetList;	// ptr to array of simplified list of targets
	
	// Retrofit specific information
	BOOL						bCoInitializeCalled; // Was CoInitialize called by retrofit
	BYTE						bRetroActive;		 // 0 = inactive, 1 = active
	HANDLE						hRetroMessage;		 // Handle for retrofit lobby message receive notifications
	DWORD						dwRetroID;			 // Application ID for retrofit when lobby launched
	LPDIRECTPLAYLOBBY3A			lpdplRetro;			 // Lobby for communicating with retro app.
	HANDLE						hRetroWatcherStop;	 // Signal to stop watcher thread
	HANDLE						hRetroWatcherDone;	 // The watcher is now complete
VOL	BOOL						bHost;			     // Is this dplay the host?
	DPID					    dpidVoiceHost;		 // Cached host ID
	DPID						dpidLocalID;		 // Cached local ID
VOL	BOOL						fLoadRetrofit;		 // Load retrofit?
VOL	BOOL						fDidVoiceClose;
	// voice specifc information ends------------------------------------------
} DPLAYI_DPLAY;

/************************************************************
*                                                            
* global variables											 
*                                                            
************************************************************/

// gpObjectList is the list of all dplay objects that exist in
// this dll.  used in dllmain and classfactory->canunloadnow
extern LPDPLAYI_DPLAY gpObjectList;
extern UINT gnObjects; // the # of dplay objects in the gpObjectList

// global event handles. these are set in handler.c when the 
// namesrvr responds to our request. 
// alloc'ed and init'ed in dllmain.c
extern HANDLE ghEnumPlayersReplyEvent,ghRequestPlayerEvent,ghReplyProcessed;

// globals to hold buffer for enum players and new player id replies
// declared in handler.c
extern LPBYTE gpRequestPlayerBuffer, gpEnumPlayersReplyBuffer;

extern LPVOID gpvEnumPlayersHeader;

// set to TRUE when someone is waiting for our reply
// set to FALSE when they give up waiting, or when the reply shows up
extern BOOL gbWaitingForReply;
extern BOOL gbWaitingForEnumReply;

// set if we have a dx3 SP loaded. see api.c
extern BOOL gbDX3SP;											

// the vtable!
extern DIRECTPLAYCALLBACKS dpCallbacks;
extern DIRECTPLAYCALLBACKS2 dpCallbacks2;
extern DIRECTPLAYCALLBACKS2A dpCallbacks2A;
extern DIRECTPLAYCALLBACKS3 dpCallbacks3;
extern DIRECTPLAYCALLBACKS3A dpCallbacks3A;
extern DIRECTPLAYCALLBACKS4 dpCallbacks4;
extern DIRECTPLAYCALLBACKS4A dpCallbacks4A;
extern DIRECTPLAYCALLBACKSSP dpCallbacksSP;
extern DIRECTPLAYVOICETRANSPORTCALLBACKS dvtCallbacks;

// we're running mech. hack.
extern BOOL gbMech;

// set in dllmain.c if we're running on win95 (since win95 doesn't do 
// unicode)
extern BOOL gbWin95;

// pointers to sspi function tables
extern PSecurityFunctionTableA	gpSSPIFuncTblA;
extern PSecurityFunctionTable	gpSSPIFuncTbl;
extern LPCAPIFUNCTIONTABLE      gpCAPIFuncTbl;

// global event handle, used in dpsecure.c for synchronous authentication
extern HANDLE           ghConnectionEvent;

// global module handle to SSPI DLL
extern HINSTANCE ghSSPI;

// global module handle to CAPI DLL
extern HINSTANCE ghCAPI;

/********************************************************************************
*                                                                                
* macros and other cool stuff													 
*                                                                                
********************************************************************************/

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT
// ansi strlength + 1 for the terminating null
#define STRLEN(ptr) ((NULL==ptr) ? 0 : strlen(ptr) + 1)
//
// WSTRxxx defined in dpos.c.  
// we have our own strlen and strcmp for unicode since they're not in libc.lib
// and we don't want to link to msvcrt.dll
//
// unicode strlength + 1 for terminating nulls
#define WSTRLEN OS_StrLen
#define WSTRLEN_BYTES(ptr) (OS_StrLen(ptr) * sizeof(WCHAR))
#define WSTRCMP(ptr1,ptr2) ( memcmp(ptr1,ptr2,WSTRLEN_BYTES(ptr1)) )

// get the ansi length of a unicode string
#define WSTR_ANSILENGTH(psz) ( (psz == NULL) ? 0 : WideToAnsi(NULL,psz,0) )

// registry stuff - used in api.c
#define DPLAY_REGISTRY_PATH (TEXT("Software\\Microsoft\\DirectPlay\\Service Providers"))
#define DPLAY_REGISTRY_NAMELEN 512
#define DPLAY_MAX_FILENAMELEN 512

// number of sp timeouts we wait for a reply from a namesrvr for the nametable
// for the default this is ~ 2+ minutes (125 seconds).
#define DP_NAMETABLE_SCALE 25
// number of sp timeouts we wait for a reply from the namesrvr for a player id
// for the default, this is ~ 15 seconds
#define DP_GETID_SCALE 3
// generic timeout default
#define DP_DEFAULT_TIMEOUT (5*1000)
// max timeout we will wait for connect
#define DP_MAX_CONNECT_TIME	(60*1000)

// minimum time out between keep alives
#define DP_MIN_KEEPALIVE_TIMEOUT 1000

// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

//
// !!! NOTE: when taking SERVICE_LOCK and DPLAY_LOCK, you must always take the SERVICE_LOCK FIRST !!!
//

// crit section
extern LPCRITICAL_SECTION gpcsDPlayCritSection;	// defined in dllmain.c
#define INIT_DPLAY_CSECT() InitializeCriticalSection(gpcsDPlayCritSection);
#define FINI_DPLAY_CSECT() DeleteCriticalSection(gpcsDPlayCritSection);
#ifdef DEBUG
extern int gnDPCSCount; // count of dplay lock
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;
#define LEAVE_DPLAY() gnDPCSCount--;ASSERT(gnDPCSCount>=0);LeaveCriticalSection(gpcsDPlayCritSection);
//#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection),gnDPCSCount++;DPF(9,"++>ENTER_DPLAY() %d file: %s line: %d\n",gnDPCSCount,__FILE__,__LINE__);
//#define LEAVE_DPLAY() gnDPCSCount--;ASSERT(gnDPCSCount>=0);DPF(9,"<--LEAVE_DPLAY() %d file: %s line: %d\n",gnDPCSCount,__FILE__,__LINE__);LeaveCriticalSection(gpcsDPlayCritSection);
#else 
#define ENTER_DPLAY() EnterCriticalSection(gpcsDPlayCritSection);
#define LEAVE_DPLAY() LeaveCriticalSection(gpcsDPlayCritSection);
#endif

#define PACKETIZE_LOCK() EnterCriticalSection(&g_PacketizeTimeoutListLock);
#define PACKETIZE_UNLOCK() LeaveCriticalSection(&g_PacketizeTimeoutListLock);


// service crit section
extern LPCRITICAL_SECTION gpcsServiceCritSection;	// defined in dllmain.c
#define INIT_SERVICE_CSECT() InitializeCriticalSection(gpcsServiceCritSection);
#define FINI_SERVICE_CSECT() DeleteCriticalSection(gpcsServiceCritSection);

#ifdef DEBUG
#define ENTER_SERVICE() EnterCriticalSection(gpcsServiceCritSection);
#define LEAVE_SERVICE() LeaveCriticalSection(gpcsServiceCritSection);
#else
#define ENTER_SERVICE() EnterCriticalSection(gpcsServiceCritSection);
#define LEAVE_SERVICE() LeaveCriticalSection(gpcsServiceCritSection);
#endif

// macros to make sure we take the locks together in the correct order.
#define ENTER_ALL() ENTER_SERVICE();ENTER_DPLAY();
#define LEAVE_ALL() LEAVE_DPLAY();LEAVE_SERVICE();

#ifdef DEBUG
	#define DPF_ERRVAL(a, b)  DPF( 0, DPF_MODNAME ": " a, b );
#else
	#define DPF_ERRVAL(a, b)
#endif

#define DPLAY_FROM_INT(ptr) \
	( ptr ? ((LPDPLAYI_DPLAY_INT)ptr)->lpDPlay  : NULL)

// handy macros
#define CLIENT_SERVER(this) ( (this) && (this->lpsdDesc) \
	&& (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) )
	
// secure server is when the session desc is marked dpsession_secureserver
#define SECURE_SERVER(this)  ( (this->lpsdDesc \
	&& (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER)) )
	
// is this the nameserver?
#define IAM_NAMESERVER(this) ( this->pSysPlayer \
	&& (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
	
// validation macros

#define VALID_SIGNING_STATE(this) (                     \
        (DPLOGIN_ACCESSGRANTED == this->LoginState) ||  \
        (DPLOGIN_KEYEXCHANGE == this->LoginState) ||    \
        (DPLOGIN_SUCCESS == this->LoginState) )          

#define VALID_SPHEADER(ptr) (ptr && (DPSP_HEADER_LOCALMSG != ptr))

#define VALID_DPLAY_PLAYER( ptr ) \
        ( ptr && (ptr != (LPDPLAYI_PLAYER)NAMETABLE_PENDING) &&\
		!IsBadWritePtr( ptr, sizeof( DPLAYI_PLAYER )) && \
        ((ptr)->dwSize == sizeof(DPLAYI_PLAYER)))

#define VALID_DPLAY_GROUP( ptr ) \
        ( ptr && (ptr != (LPDPLAYI_GROUP)NAMETABLE_PENDING) &&\
		!IsBadWritePtr( ptr, sizeof( DPLAYI_GROUP )) && \
        ((ptr)->dwSize == sizeof(DPLAYI_GROUP)))

#define VALID_PLAYER_DATA( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( PLAYERDATA )) && \
        ((ptr)->dwSize == sizeof(PLAYERDATA)))

#define VALID_GROUP_DATA( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( GROUPDATA )) && \
        ((ptr)->dwSize == sizeof(GROUPDATA)))
		
#define VALID_DPLAY_INT( ptr ) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPLAYI_DPLAY_INT )) && \
        ((ptr->lpVtbl == &dpCallbacks) || (ptr->lpVtbl == &dpCallbacks2) \
        || (ptr->lpVtbl == &dpCallbacks2A) || (ptr->lpVtbl == &dpCallbacksSP) \
		|| (ptr->lpVtbl == &dpCallbacks3) || (ptr->lpVtbl == &dpCallbacks3A) \
		|| (ptr->lpVtbl == &dpCallbacks4) || (ptr->lpVtbl == &dpCallbacks4A) \
		|| (ptr->lpVtbl == &dvtCallbacks) \
		) )

#define VALID_DPLAY_PTR( ptr ) \
	( (!ptr || IsBadWritePtr( ptr, sizeof( DPLAYI_DPLAY )) ) ? DPERR_INVALIDOBJECT : \
    (ptr->dwSize != sizeof(DPLAYI_DPLAY))  ? DPERR_INVALIDOBJECT : \
   	(ptr->dwFlags & DPLAYI_DPLAY_UNINITIALIZED) ? DPERR_UNINITIALIZED : DP_OK )

#define VALID_STRING_PTR(ptr,cnt) \
        (!IsBadWritePtr( ptr, cnt))

#define VALID_READ_STRING_PTR(ptr,cnt) \
        (!IsBadReadPtr( ptr, cnt))

#define VALID_WRITE_PTR(ptr,cnt) \
        (!IsBadWritePtr( ptr, cnt))

#define VALID_READ_PTR(ptr,cnt) \
        (!IsBadReadPtr( ptr, cnt))

#define VALID_ID_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(DPID)))

#define VALID_GUID_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(GUID)))

#define VALID_READ_GUID_PTR(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof(GUID)))

#define VALID_DWORD_PTR(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof(DWORD)))

#define VALID_READ_DWORD_PTR(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof(DWORD)))

#define VALID_DPSESSIONDESC(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPSESSIONDESC )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC)))

#define VALID_READ_DPSESSIONDESC(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSESSIONDESC )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC)))

#define VALID_DPSESSIONDESC2(ptr) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPSESSIONDESC2 )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC2)))

#define VALID_READ_DPSESSIONDESC2(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSESSIONDESC2 )) && \
        (ptr->dwSize == sizeof(DPSESSIONDESC2)))

// DPOPEN_CREATE and DPOPEN_JOIN are valid session desc flags for Open on IDirectPlay, 
// but not for later interfaces. However, some apps (monster truc) that didn't upgrade well, 
// are passing these flags to later interfaces as well. We can't catch this error now as we'll 
// break these apps. The following macro treats these two flags as valid. Treating DPOPEN_CREATE
// as a valid flag is safe because it has not been reused. However, DPSESSION_NEWPLAYERSDISABLED
// has taken DPOPEN_JOIN's slot. Reusing this flag doesn't cause any problems because session 
// flags passed in during join are ignored in IDirectPlay2 and greater interfaces.
#define VALID_DPSESSIONDESC2_FLAGS(dwFlags) \
		(!((dwFlags) & \
				  ~(DPSESSION_NEWPLAYERSDISABLED | \
                    DPOPEN_CREATE | \
					DPSESSION_MIGRATEHOST | \
					DPSESSION_NOMESSAGEID | \
					DPSESSION_NOPLAYERMGMT | \
					DPSESSION_JOINDISABLED | \
					DPSESSION_KEEPALIVE | \
					DPSESSION_NODATAMESSAGES | \
					DPSESSION_SECURESERVER | \
					DPSESSION_PRIVATE | \
					DPSESSION_PASSWORDREQUIRED | \
					DPSESSION_CLIENTSERVER | \
					DPSESSION_MULTICASTSERVER | \
					DPSESSION_OPTIMIZELATENCY | \
					DPSESSION_DIRECTPLAYPROTOCOL | \
					DPSESSION_ALLOWVOICERETRO | \
					DPSESSION_NOSESSIONDESCMESSAGES | \
					DPSESSION_NOPRESERVEORDER ) \
		) )

#define VALIDEX_CODE_PTR( ptr ) \
		( ptr && !IsBadCodePtr( (LPVOID) ptr ) )

#define VALID_DPLAY_CAPS( ptr) \
		( ptr && !IsBadWritePtr( ptr, sizeof( DPCAPS )) && \
        (ptr->dwSize == sizeof(DPCAPS)))

#define VALID_DPNAME_PTR( ptr ) \
        ( ptr && !IsBadWritePtr( ptr, sizeof( DPNAME )) && \
        (ptr->dwSize == sizeof(DPNAME)))

#define VALID_READ_DPNAME_PTR( ptr ) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPNAME )) && \
        (ptr->dwSize == sizeof(DPNAME)))

#define VALID_READ_DPSECURITYDESC(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPSECURITYDESC )) && \
        (ptr->dwSize == sizeof(DPSECURITYDESC)))

#define VALID_DPSECURITYDESC_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_READ_DPCREDENTIALS(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPCREDENTIALS )) && \
        (ptr->dwSize == sizeof(DPCREDENTIALS)))

#define VALID_DPCREDENTIALS_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_DPACCOUNTDESC_FLAGS(dwFlags) (0 == (dwFlags))

#define VALID_READ_DPCHAT(ptr) \
        ( ptr && !IsBadReadPtr( ptr, sizeof( DPCHAT )) && \
        (ptr->dwSize == sizeof(DPCHAT)))

#define VALID_SEND_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPSEND_GUARANTEED | \
                    DPSEND_HIGHPRIORITY | \
                    DPSEND_TRYONCE | \
                    DPSEND_OPENSTREAM | \
                    DPSEND_CLOSESTREAM | \
                    DPSEND_SIGNED | \
                    DPSEND_ENCRYPTED | \
                    DPSEND_NOSENDCOMPLETEMSG | \
                    DPSEND_NOCOPY | \
                    DPSEND_ASYNC) \
		) )

#define VALID_RECEIVE_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPRECEIVE_ALL | \
                    DPRECEIVE_TOPLAYER | \
                    DPRECEIVE_FROMPLAYER | \
                    DPRECEIVE_PEEK) \
		) )

#define VALID_CHAT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPSEND_GUARANTEED) \
		) )

#define VALID_CREATEPLAYER_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPPLAYER_SERVERPLAYER | \
                    DPPLAYER_SPECTATOR) \
		) )

#define VALID_CREATEGROUP_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPGROUP_STAGINGAREA | \
					DPGROUP_HIDDEN) \
		) )

#define VALID_ENUMPLAYERS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_GROUP | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMPLAYERS_SERVERPLAYER | \
                    DPENUMPLAYERS_SPECTATOR) \
		) )

#define VALID_ENUMGROUPPLAYERS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMPLAYERS_SERVERPLAYER | \
                    DPENUMPLAYERS_SPECTATOR) \
		) )

#define VALID_ENUMGROUPS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMPLAYERS_LOCAL | \
                    DPENUMPLAYERS_REMOTE | \
                    DPENUMPLAYERS_SESSION | \
                    DPENUMGROUPS_HIDDEN | \
					DPENUMGROUPS_SHORTCUT | \
                    DPENUMGROUPS_STAGINGAREA) \
		) )

// Note: allow DPENUMSESSIONS_PREVIOUS here even though its bogus...for compat
#define VALID_ENUMSESSIONS_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPENUMSESSIONS_AVAILABLE | \
                    DPENUMSESSIONS_ALL  | \
                    DPENUMSESSIONS_PREVIOUS  | \
                    DPENUMSESSIONS_NOREFRESH  | \
                    DPENUMSESSIONS_ASYNC  | \
                    DPENUMSESSIONS_STOPASYNC  | \
                    DPENUMSESSIONS_PASSWORDREQUIRED  | \
                    DPENUMSESSIONS_RETURNSTATUS) \
		) )

#define VALID_CONNECT_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPCONNECT_RETURNSTATUS) \
		) )

#define VALID_OPEN_FLAGS(dwFlags) \
		(!((dwFlags) & \
                  ~(DPOPEN_JOIN | \
                    DPOPEN_CREATE  | \
                    DPOPEN_RETURNSTATUS ) \
		) )

#define DPCAPS1_SIZE (offsetof(DPCAPS,dwLatency))
#define VALID_DPLAY1_CAPS( ptr) \
		( ptr && !IsBadWritePtr( ptr, DPCAPS1_SIZE) && \
        (ptr->dwSize == DPCAPS1_SIZE))
	
#define IS_LOBBY_OWNED(ptr) \
		(ptr->dwFlags & DPLAYI_DPLAY_LOBBYOWNS)

#define CALLSP(fn,pdata) (fn(pdata))	
#define CALLSPVOID(fn) (fn())	

#define GetPlayerMessageHeader() (LPMSG_PLAYERMESSAGE)(this->lpPlayerMsgPool->Get(this->lpPlayerMsgPool))
#define PlayerMessageFreeFn this->lpPlayerMsgPool->Release
#define PlayerMessageFreeContext this->lpPlayerMsgPool

// For SENDPARM blocks
#define GetSendParms() (LPSENDPARMS)(this->lpSendParmsPool->Get(this->lpSendParmsPool))
#define FreeSendParms(_psp) (this->lpSendParmsPool->Release(this->lpSendParmsPool,(_psp)))

// For MessageNodes
//#define GetMessageNode() (LPMESSAGENODE)(this->lpMsgNodePool->Get(this->lpMsgNodePool))
//#define FreeMessageNode(_pmsn) (this->lpMsgNodePool->Release(this->lpMsgNodePool,(_pmsn))) 

#define TRY 		_try
#define EXCEPT(a)	_except( a )

typedef struct IDirectPlayVtbl DIRECTPLAYCALLBACKS;
#define DPAPI WINAPI

// constants for passing to inernalenumxxxx
enum 
{
	ENUM_2,
	ENUM_2A,
	ENUM_1
};

// constants for passing to internalreceive
enum 
{
	RECEIVE_2,
	RECEIVE_2A,
	RECEIVE_1
};

/********************************************************************
*                                                                    
* internal errors														 
*                                                                    
********************************************************************/
#define _FACDPI  0x786
#define MAKE_DPIHRESULT( code )    MAKE_HRESULT( 1, _FACDPI, code )

#define DPERR_VERIFYSIGNFAILED                MAKE_DPIHRESULT(  1000 )
#define DPERR_DECRYPTIONFAILED                MAKE_DPIHRESULT(  1010 )


/********************************************************************
*                                                                    
* prototypes														 
*                                                                    
********************************************************************/

// dpunk.c
extern HRESULT 	DPAPI DP_QueryInterface(LPDIRECTPLAY,REFIID riid, LPVOID * ppvObj); 
extern ULONG	DPAPI DP_AddRef(LPDIRECTPLAY);  
extern ULONG 	DPAPI DP_Release(LPDIRECTPLAY); 
extern HRESULT 	GetInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT * ppInt,LPVOID pCallbacks);
extern HRESULT 	FreeSessionList(LPDPLAYI_DPLAY this);

// iplay.c

extern HRESULT DPAPI DP_AddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer); 
extern HRESULT DPAPI DP_CancelMessage(LPDIRECTPLAY lpDP, DWORD dwMsgID, DWORD dwFlags);
extern HRESULT DPAPI DP_CancelPriority(LPDIRECTPLAY lpDP, DWORD dwMinPriority, DWORD dwMaxPriority,DWORD dwFlags);
extern HRESULT DPAPI DP_Close(LPDIRECTPLAY lpDP); 
extern HRESULT DPAPI DP_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_DeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer); 
extern HRESULT DPAPI DP_DestroyPlayer(LPDIRECTPLAY lpDP, DPID idPlayer); 
extern HRESULT DPAPI DP_DestroyGroup(LPDIRECTPLAY lpDP, DPID idGroup); 
extern HRESULT DPAPI DP_EnableNewPlayers(LPDIRECTPLAY lpDP, BOOL bEnable); 
extern HRESULT DPAPI DP_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps,DWORD dwFlags); 
extern HRESULT DPAPI DP_GetGroupParent(LPDIRECTPLAY lpDP, DPID idGroup, LPDPID pidParent);
extern HRESULT DPAPI DP_GetMessageCount(LPDIRECTPLAY lpDP, DPID idPlayer, LPDWORD pdwCount); 
extern HRESULT DPAPI DP_GetMessageQueue(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes); 
extern HRESULT DPAPI DP_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,DWORD dwFlags); 
extern HRESULT DPAPI DP_GetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_GetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_GetPlayerAddress(LPDIRECTPLAY lpDP,DPID idPlayer, LPVOID pvAddress,
	LPDWORD pdwAddressSize) ;
extern HRESULT DPAPI DP_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_Initialize(LPDIRECTPLAY lpDP, LPGUID lpGuid); 
extern HRESULT DPAPI DP_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,DWORD dwFlags ); 
extern HRESULT DPAPI DP_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
    LPVOID pvBuffer,LPDWORD pdwSize	); 
extern HRESULT DPAPI DP_Send(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
    LPVOID pvBuffer,DWORD dwBufSize	); 
extern HRESULT DPAPI DP_SendEx(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPVOID lpData, DWORD dwDataSize, DWORD dwPriority, DWORD dwTimeout, LPVOID lpContext,
	DWORD_PTR *lpdwMsgID);
extern HRESULT DPAPI DP_SetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpSDesc, DWORD dwFlags,
    LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials); 
extern HRESULT DPAPI DP_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg);
extern HRESULT InternalSetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags, 
                                      BOOL fPropagate);
extern HRESULT DPAPI DP_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags);
extern HRESULT DeallocPlayer(LPDPLAYI_PLAYER);
extern HRESULT InternalOpenSession(LPDPLAYI_DPLAY this,LPCDPSESSIONDESC2 lpSDesc,BOOL fEnumOnly,
	DWORD dwFlags,BOOL fStuffInstanceGUID,LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials);
extern HRESULT InternalGetSessionDesc(LPDIRECTPLAY lpDP,LPVOID pvBuffer,
	LPDWORD pdwSize, BOOL fAnsi);  
extern HRESULT GetPlayer(LPDPLAYI_DPLAY this,  LPDPLAYI_PLAYER * ppPlayer,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags, LPWSTR lpSessionPassword, DWORD dwLobbyID);
extern HRESULT GetGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP * ppGroup,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,DPID idParent,DWORD dwLobbyID);
extern HRESULT InternalSetData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags,BOOL fPlayer,BOOL fPropagate);
extern HRESULT InternalSetName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,BOOL fPlayer,
	DWORD dwFlags,BOOL fPropagate);
extern HRESULT CallSPCreatePlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL bLocal,
	LPVOID pvSPMessageData, BOOL bNotifyProtocol);
extern HRESULT CallSPCreateGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,BOOL bLocal,
	LPVOID pvSPMessageData);
extern HRESULT InternalGetName(LPDIRECTPLAY lpDP, DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fPlayer,BOOL fAnsi);
extern HRESULT  InternalGetData(LPDIRECTPLAY lpDP,DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags,BOOL fPlayer);
extern HRESULT InternalDestroyPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,
	BOOL fPropagate, BOOL fLookForNewNS) ;
extern HRESULT InternalDestroyGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,
	BOOL fPropagate);
extern HRESULT InternalDeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer,
	BOOL fPropagate); 
extern HRESULT InternalAddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer,
	BOOL fPropagate) ;
extern HRESULT InternalReceive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize,DWORD dwCaller	);
extern LPDPLAYI_GROUPNODE FindPlayerInGroupList(LPDPLAYI_GROUPNODE pGroupnode,DPID id);
extern HRESULT RemovePlayerFromGroup(LPDPLAYI_GROUP, LPDPLAYI_PLAYER);
extern HRESULT DPAPI DP_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) ;
extern HRESULT DPAPI DP_AddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup) ;	
extern HRESULT DPAPI DP_DeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer) ;
extern HRESULT InternalAddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup,DWORD dwFlags,
	BOOL fPropagate) ;
extern HRESULT InternalDeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,
	DPID idGroup,BOOL fPropagate);
extern HRESULT RemoveGroupFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_GROUP lpGroupRemove);
extern HRESULT DPAPI DP_GetPlayerFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_GetGroupFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_GetGroupOwner(LPDIRECTPLAY lpDP, DPID id,LPDPID idOwner);
extern HRESULT DPAPI DP_SetGroupOwner(LPDIRECTPLAY lpDP, DPID id,DPID idNewOwner);
extern HRESULT GetMaxMessageSize(LPDPLAYI_DPLAY this);
extern void FreePacketList(LPDPLAYI_DPLAY this);
extern HRESULT InternalGetCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,BOOL fPlayer,DWORD dwFlags);


// enum.c
extern HRESULT DPAPI DP_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pContext,
    DWORD dwFlags) ;
extern HRESULT DPAPI InternalEnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPVOID lpEnumCallback,DWORD dwFlags);
extern HRESULT CheckSessionDesc(LPDPSESSIONDESC2 lpsdUser,LPDPSESSIONDESC2 lpsdSession,
	DWORD dwFlags,BOOL fAnsi); 
extern HRESULT DPAPI InternalEnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
extern HRESULT DPAPI InternalEnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
extern HRESULT DPAPI InternalEnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) ;
DWORD GetDefaultTimeout(LPDPLAYI_DPLAY this,BOOL fGuaranteed);
extern HRESULT CopySessionDesc2(LPDPSESSIONDESC2 pSessionDescDest, 
                         LPDPSESSIONDESC2 pSessionDescSrc, BOOL bAnsi);
extern HRESULT DoSessionCallbacks(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc,
	LPDWORD lpdwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags, LPBOOL lpbContinue, BOOL bAnsi);
extern HRESULT InternalEnumerate();
extern HRESULT CallSPEnumSessions(LPDPLAYI_DPLAY this,LPVOID pBuffer,DWORD dwMessageSize,
	DWORD dwTimeout, BOOL bReturnStatus);
extern HRESULT StartDPlayThread(LPDPLAYI_DPLAY this,BOOL bKeepAlive);
extern void KillThread(HANDLE hThread,HANDLE hEvent);
extern HRESULT StopEnumThread(LPDPLAYI_DPLAY this);
extern BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
				DWORD dwFlags, LPVOID lpContext);
extern HRESULT DPAPI DP_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) ;
extern HRESULT DPAPI DP_A_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) ;
extern HRESULT DPAPI InternalEnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) ;	

// namesrv.c
extern LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY,DWORD);
extern LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY,DWORD);
extern HRESULT AddItemToNameTable(LPDPLAYI_DPLAY,DWORD_PTR,DWORD *,BOOL,DWORD);
extern HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY ,DWORD );
extern HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this);
extern BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id);
extern LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD id);
extern DWORD_PTR NameFromID(LPDPLAYI_DPLAY, DWORD);
extern HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID);
extern HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, LPVOID pvSPHeader);
extern HRESULT GrowTable(LPDPLAYI_DPLAY this);
extern void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer);
extern void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer);
extern DPID PlayerIDFromSysPlayerID(LPDPLAYI_DPLAY this,DPID dpidSysPlayer);

// pack.c
extern HRESULT UnpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,LPVOID pvSPHeader);
extern HRESULT PackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,DWORD *pdwBufferSize) ;
extern DWORD PackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) ;
extern HRESULT UnpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PACKEDPLAYER pPacked,
	LPVOID pvSPHeader,BOOL bPlayer);


// sysmess.c
extern HRESULT InternalSendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock);
extern HRESULT InternalSendDPMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bDropLock);
extern HRESULT SendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock);
extern HRESULT SendCreateMessage(LPDPLAYI_DPLAY this,void * pPlayerOrGroup,BOOL fPlayer, 
    LPWSTR lpszSessionPassword);
extern HRESULT SendPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize);
extern HRESULT SendPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp);
extern HRESULT SendSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,
	DWORD dwMessageSize,DWORD dwFlags, BOOL bIsPlyrMgmtMsg);
extern HRESULT SendGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage);
extern HRESULT SendGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp, BOOL fPlayerMessage);
extern HRESULT SendPlayerManagementMessage(LPDPLAYI_DPLAY this,DWORD dwCmd,DPID idPlayer,
	DPID idGroup);
extern HRESULT SendPlayerData(LPDPLAYI_DPLAY this,DPID idChanged,LPVOID pData,
	DWORD dwDataSize);
extern HRESULT SendDataChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags);
extern HRESULT SendNameChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags);
extern HRESULT SendIAmNameServer(LPDPLAYI_DPLAY this);
extern HRESULT SendMeNameServer(LPDPLAYI_DPLAY this);
extern HRESULT SendSessionDescChanged(LPDPLAYI_DPLAY this, DWORD dwFlags);
extern HRESULT SendChatMessage(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags, LPDPCHAT lpMsg, BOOL fPlayer);
extern HRESULT SendAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,
	LPADDFORWARDNODE pnode);
extern HRESULT ConvertSendExDataToSendData(LPDPLAYI_DPLAY this, LPDPSP_SENDEXDATA psed, LPDPSP_SENDDATA psd) ;
extern HRESULT DoCreateVerify(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize, LPVOID pvSPHeader) ;
	
// dllmain.c
extern HRESULT FreeSPList();

// iplay1.c
extern HRESULT DPAPI DP_1_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPSTR lpszShortName,LPSTR lpszLongName,LPHANDLE phEvent);
extern HRESULT DPAPI DP_1_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPSTR lpszShortName,LPSTR lpszLongName); 
extern HRESULT DPAPI DP_1_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags); 
extern HRESULT DPAPI DP_1_EnumGroups(LPDIRECTPLAY lpDP,DWORD_PTR dwSessionID,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags); 
extern HRESULT DPAPI DP_1_EnumPlayers(LPDIRECTPLAY lpDP, DWORD_PTR dwSessionID, 
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pContext,DWORD dwFlags);
extern HRESULT DPAPI DP_1_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK lpEnumCallback,LPVOID pContext,
	DWORD dwFlags); 
extern HRESULT DPAPI DP_1_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps); 
extern HRESULT DPAPI DP_1_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps); 
extern HRESULT DPAPI DP_1_GetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPDWORD pdwShortNameLength,LPSTR lpszLongName,LPDWORD pdwLongNameLength);
extern HRESULT DPAPI DP_1_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpSDesc ); 
extern HRESULT DPAPI DP_1_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize);
extern HRESULT DPAPI DP_1_SaveSession(LPDIRECTPLAY lpDP, LPSTR lpszNotInSpec); 
extern HRESULT DPAPI DP_1_SetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,
	LPSTR lpszShortName,LPSTR lpszLongName);       	
	

// iplaya.c						 
extern HRESULT DPAPI DP_A_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_A_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumGroupPlayers(LPDIRECTPLAY lpDP, DPID id,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumGroups(LPDIRECTPLAY lpDP, LPGUID pGuid,
	 LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpSDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
    LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) ;
extern HRESULT DPAPI DP_A_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,
	DWORD dwFlags,LPVOID pvBuffer,LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 pDesc,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags);
extern HRESULT DPAPI DP_A_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc,
    DWORD dwFlags, LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials) ;
extern HRESULT DPAPI DP_A_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg);
extern HRESULT GetWideStringFromAnsi(LPWSTR * ppszWStr,LPSTR lpszStr);
extern HRESULT GetWideDesc(LPDPSESSIONDESC2 pDesc,LPCDPSESSIONDESC2 pDescA);
extern HRESULT GetAnsiDesc(LPDPSESSIONDESC2 pDescA,LPDPSESSIONDESC2 pDesc);
extern void FreeDesc(LPDPSESSIONDESC2 pDesc,BOOL fAnsi);
extern HRESULT FreeCredentials(LPDPCREDENTIALS lpCredentials,BOOL fAnsi);
extern HRESULT GetWideCredentials(LPDPCREDENTIALS lpCredentialsW, 
    LPCDPCREDENTIALS lpCredentialsA);
extern HRESULT FreeSecurityDesc(LPDPSECURITYDESC lpSecDesc, BOOL fAnsi);
extern HRESULT GetWideSecurityDesc(LPDPSECURITYDESC lpSecDescW, 
    LPCDPSECURITYDESC lpSecDescA);
extern HRESULT DPAPI DP_A_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) ;
extern HRESULT InternalGetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi);
extern HRESULT DPAPI DP_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize);
extern HRESULT DPAPI DP_A_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize);

// pending.c
extern HRESULT ExecutePendingCommands(LPDPLAYI_DPLAY this);
extern HRESULT PushPendingCommand(LPDPLAYI_DPLAY this,LPVOID pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader,DWORD dwSendFlags);


// handler.c
extern HRESULT DPAPI InternalHandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader, DWORD dwMessageFlags);
extern HRESULT DPAPI DP_SP_HandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern HRESULT DPAPI DP_SP_HandleNonProtocolMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern VOID DPAPI DP_SP_SendComplete(IDirectPlaySP * pISP, LPVOID lpDPContext, HRESULT CompletionStatus);
extern HRESULT DoReply(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	LPVOID pvMessageHeader, DWORD dwReplyToVersion);
extern HRESULT HandleSessionLost(LPDPLAYI_DPLAY this);
extern HRESULT HandlePlayerMessage(LPDPLAYI_PLAYER, LPBYTE, DWORD, BOOL, DWORD);
extern HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY, LPBYTE, LPVOID);
extern HRESULT SP_HandleDataChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer);
extern HRESULT SP_HandleSessionDescChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer);
extern HRESULT  DistributeSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize);
extern HRESULT GetMessageCommand(LPDPLAYI_DPLAY this, LPVOID pReceiveBuffer, DWORD dwMessageSize, 
    LPDWORD pdwCommand, LPDWORD pdwVersion);
extern HRESULT DistributeGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroupTo,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage,DWORD dwMessageFlags);
extern DWORD GetPlayerFlags(LPDPLAYI_PLAYER pPlayer);
extern HRESULT SP_HandlePlayerMgmt(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader) ;
extern HRESULT FreeAddForwardNode(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind);
extern HRESULT NS_HandleEnumPlayers(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DPID dpidFrom,DWORD dwVersion);
extern LPDPLAYI_PLAYER GetRandomLocalPlayer(LPDPLAYI_DPLAY this);
extern VOID QueueSendCompletion(LPDPLAYI_DPLAY this, PSENDPARMS psp);
extern VOID UpdateChatterCount(LPDPLAYI_DPLAY this, DPID dwIDFrom);
 
// sphelp.c
extern HRESULT DPAPI DP_SP_AddMRUEntry(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPCVOID lpvData, DWORD dwDataSize, DWORD dwMaxEntries);
extern HRESULT DPAPI DP_SP_CreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPAPI DP_SP_CreateCompoundAddress(IDirectPlaySP * pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT DPAPI DP_SP_EnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize, 
	LPVOID lpContext);
extern HRESULT DPAPI DP_SP_EnumMRUEntries(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPENUMMRUCALLBACK fnCallback,
					LPVOID lpvContext);
extern HRESULT DPAPI DP_SP_GetPlayerFlags(IDirectPlaySP * pISP,DPID id,LPDWORD pdwFlags);
extern HRESULT DPAPI DP_SP_GetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID * ppvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SP_SetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID pvData,
	DWORD dwDataSize,DWORD dwFlags	);
extern HRESULT DPAPI DP_SP_GetSPData(IDirectPlaySP * pISP,LPVOID * ppvData,
	LPDWORD pdwDataSize,DWORD dwFlags);
extern HRESULT DPAPI DP_SP_SetSPData(IDirectPlaySP * pISP,LPVOID pvData,
	DWORD dwDataSize,DWORD dwFlags	);

extern HRESULT InternalEnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext);
extern HRESULT InternalCreateAddress(LPDIRECTPLAYSP pISP,
					REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
					LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);
extern HRESULT InternalCreateCompoundAddress(
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize);

// do.c
extern HRESULT DoPlayerData(LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,DWORD dwSourceSize,
	DWORD dwFlags);
extern HRESULT DoPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName);

// paketize.c
extern HRESULT PacketizeAndSend(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader,BOOL bReply);
HRESULT PacketizeAndSendReliable(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader, BOOL bReply);
extern HRESULT HandlePacket(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader);
extern void FreePacketNode(LPPACKETNODE pNode);
BOOL NeedsReliablePacketize(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, 
	DWORD dwFlags);
HRESULT InitPacketize(LPDPLAYI_DPLAY this);
VOID FiniPacketize(LPDPLAYI_DPLAY this);
VOID FreePacketizeRetryList(LPDPLAYI_DPLAY this);
DWORD WINAPI PacketizeRetryThread(LPDPLAYI_DPLAY this);
extern CRITICAL_SECTION g_PacketizeTimeoutListLock;

// dpthread.c
extern DWORD WINAPI DPlayThreadProc(LPDPLAYI_DPLAY this);
extern HRESULT HandlePing(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	LPVOID pvMessageHeader);
extern HRESULT  KillPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pSysPlayer, BOOL fPropagate);
	

// api.c
extern void LowerCase(char * lpsz);
extern HRESULT ConnectFindSession(LPDPLAYI_DPLAY this,LPDPLCONNECTION lpConnect);
extern LPSESSIONLIST FindSessionInSessionList(LPDPLAYI_DPLAY this,
	GUID const *pGuid);
extern HRESULT LoadSP(LPDPLAYI_DPLAY this,LPGUID lpGUID,LPDPADDRESS lpAddress,
	DWORD dwAddressSize);	
extern void FreeSPNode(LPSPNODE pspNode);
VOID FreeMemoryPools(LPDPLAYI_DPLAY this);
VOID FiniReply(LPDPLAYI_DPLAY this);
HRESULT InitReply(LPDPLAYI_DPLAY this);
VOID SetupForReply(LPDPLAYI_DPLAY this, DWORD dwReplyCommand);
VOID UnSetupForReply(LPDPLAYI_DPLAY this);
HRESULT WaitForReply(LPDPLAYI_DPLAY this, PCHAR *ppReply, LPVOID *ppvSPHeader, DWORD dwTimeout);
VOID FreeReplyBuffer(PCHAR pReplyBuffer);
HRESULT HandleReply(LPDPLAYI_DPLAY this, PCHAR pReplyBuffer, DWORD cbReplyBuffer, DWORD dwReplyCommand, LPVOID pvSPHeader);

// perf.c
extern DWORD WINAPI PerfThreadProc(LPDPLAYI_DPLAY this);
extern HRESULT InitMappingStuff(LPDPLAYI_DPLAY this);

//connect.c
extern HRESULT DPAPI DP_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumConnections(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_A_EnumConnectionsPreDP4(LPDIRECTPLAY lpDP,LPCGUID pGuid,
	LPDPENUMCONNECTIONSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags);
extern HRESULT DPAPI DP_InitializeConnection(LPDIRECTPLAY lpDP,LPVOID pvAddress,
	DWORD dwFlags);

// superpac.c
extern HRESULT SuperPackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) ;
extern HRESULT UnSuperpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,UINT nShortcuts,LPVOID pvSPHeader);

//sgl.c
void InsertSendBufferAtFront(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext);
void InsertSendBufferAtEnd(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext);
void FreeMessageBuffers(LPSENDPARMS psp);

//msgmem.c
void * MsgAlloc( int size );
void   MsgFree (void *context, void *pmem);

//sendparm.c
extern BOOL SendInitAlloc(void *pvsp);
extern VOID SendInit(void *pvsp);
extern VOID SendFini(void *pvsp);
extern VOID FreeSend(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL fFreeParms);

extern HRESULT InitContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nInitSize);
extern UINT AddContext(LPDPLAYI_DPLAY this, PSENDPARMS psp, PVOID pvContext);
extern UINT pspAddRef(PSENDPARMS psp);
extern UINT pspAddRefNZ(PSENDPARMS psp);
extern UINT pspDecRef(LPDPLAYI_DPLAY this, PSENDPARMS psp);

//apphack.c
extern HRESULT GetAppHacks(LPDPLAYI_DPLAY this);

// dpdvtran.c
extern VOID DVoiceNotify(LPDPLAYI_DPLAY this, DWORD dw1, DWORD_PTR dw2, DWORD_PTR dw3, DWORD dwObjectType );
extern VOID DVoiceReceiveSpeechMessage(LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, LPVOID lpvBuffer, DWORD cbBuffer);
extern HRESULT DV_Advise(LPDIRECTPLAY lpDP, LPUNKNOWN lpUnk, DWORD dwObjectType);
extern HRESULT DV_UnAdvise(LPDIRECTPLAY this, DWORD dwObjectType);
extern HRESULT DV_IsGroupMember(LPDIRECTPLAY lpDP, DVID dvidGroup, DVID dvidPlayer);
extern HRESULT DV_SendSpeech(LPDIRECTPLAY lpDP, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags);
extern HRESULT DV_SendSpeechEx(LPDIRECTPLAY lpDP, DVID dvidFrom, DWORD nTargets, PDVID pdvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, LPVOID pvUserContext, DWORD dwFlags);
extern HRESULT DV_GetSessionInfo(LPDIRECTPLAY lpDP, LPDVTRANSPORTINFO lpdvTransportInfo );
extern HRESULT DV_IsValidEntity (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb);
extern HRESULT HandleVoiceMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize, DWORD dwSendFlags);
extern HRESULT DV_IsValidGroup (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb);
extern HRESULT DV_IsValidPlayer (LPDIRECTPLAY lpDP, DPID dpid, LPBOOL lpb);

typedef HRESULT (WINAPI *PFN_DIRECTPLAYCREATE)(LPGUID lpGUIDSP, LPDIRECTPLAY *lplpDP, IUnknown *lpUnk );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUM)(LPDPENUMDPCALLBACK lpEnumCallback,LPVOID lpContext);
typedef HRESULT (WINAPI *PFN_DIRECTPLAYENUMA)(LPDPENUMDPCALLBACKA lpEnumCallback, LPVOID lpContext );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_A)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DIRECTPLAYLOBBYCREATE_W)(LPGUID lpGUIDSP, LPDIRECTPLAYLOBBY *lplpDPL, IUnknown *lpUnk, LPVOID lpData, DWORD dwDataSize );
typedef HRESULT (WINAPI *PFN_DLLGETCLASSOBJECT)(REFCLSID rclsid,REFIID riid,LPVOID *ppvObj );
typedef HRESULT (WINAPI *PFN_DLLCANUNLOADNOW)(void);

extern PFN_DIRECTPLAYCREATE pfnDirectPlayCreate;
extern PFN_DIRECTPLAYENUMA pfnDirectPlayEnum;
extern PFN_DIRECTPLAYLOBBYCREATE_A pfnDirectPlayLobbyCreateA;
extern PFN_DIRECTPLAYLOBBYCREATE_W pfnDirectPlayLobbyCreateW;
extern PFN_DIRECTPLAYENUMA pfnDirectPlayEnumA;
extern PFN_DIRECTPLAYENUM pfnDirectPlayEnumW;
extern PFN_DLLCANUNLOADNOW pfnDllCanUnLoadNow;
extern PFN_DLLGETCLASSOBJECT pfnGetClassObject;

extern HMODULE ghRedirect;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpmem.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:	dpmem.c
*  Content:	Memory function wrappers for DirectPlay
*  History:
*   Date		By		Reason
*   ====		==		======
*	9/26/96		myronth	created it
***************************************************************************/
#include "dplaypr.h"
#include "memalloc.h"
  
#ifdef MEMFAIL
#pragma message ("NOTE: Building with the MEMFAIL option")

//
// Typedefs for memory failure functions
//
typedef enum {NONE, RANDOM, BYTES, ALLOCS, OVERSIZED, TIME} FAILKEY;

FAILKEY	g_FailKey;
DWORD	g_dwSeed=0;
DWORD	g_dwStartTime=0;
DWORD	g_dwFailAfter=0;
BOOL	g_bKeepTally=FALSE;
DWORD	g_dwAllocTally=0;
DWORD	g_dwByteTally=0;

DWORD	g_dwAllocsBeforeFail=0;
DWORD	g_dwAllocsSinceFail=0;

BOOL	DPMEM_ForceFail( UINT uSize );
void	WriteMemFailRegTally( DWORD dwAllocs, DWORD dwBytes );
void	ReadMemFailRegKeys( void );

#endif


//
// Globals
//
CRITICAL_SECTION	gcsMemoryCritSection;


//
// Definitions
//

#define ENTER_DPMEM() EnterCriticalSection(&gcsMemoryCritSection);
#define LEAVE_DPMEM() LeaveCriticalSection(&gcsMemoryCritSection);


//
// Functions
//
#undef DPF_MODNAME
#define DPF_MODNAME	"MemoryFunctions"


LPVOID DPMEM_Alloc(UINT size)
{
	LPVOID	lpv;

#ifdef MEMFAIL
	if (DPMEM_ForceFail( size ))
		return NULL;
#endif

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	lpv = MemAlloc(size);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return lpv;
}


LPVOID DPMEM_ReAlloc(LPVOID ptr, UINT size)
{
	LPVOID	lpv;

#ifdef MEMFAIL
	if (DPMEM_ForceFail( size ))
		return NULL;
#endif

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	lpv = MemReAlloc(ptr, size);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return lpv;
}


void DPMEM_Free(LPVOID ptr)
{

	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	MemFree(ptr);	

	// Exit the memory critical section
	LEAVE_DPMEM();
}


BOOL DPMEM_Init()
{
	BOOL	bReturn;


	// Call the heap routine
	bReturn = MemInit();	

	return bReturn;
}


void DPMEM_Fini()
{

	// Call the heap routine
	MemFini();	

}


void DPMEM_State()
{

	// NOTE: This function is only defined for debug
#ifdef DEBUG

	// Call the heap routine
	MemState();	

#endif // DEBUG

}


UINT_PTR DPMEM_Size(LPVOID ptr)
{
	UINT_PTR	uReturn;


	// Take the memory critical section
	ENTER_DPMEM();
	
	// Call the heap routine
	uReturn = MemSize(ptr);	

	// Exit the memory critical section
	LEAVE_DPMEM();

	return uReturn;
}


/////////////////////
#ifdef MEMFAIL
////////////////////

void ReadMemFailRegKeys( void )
{
    HKEY	hKey	= NULL;
    HRESULT hr		= DP_OK;
	char	szFailKey[256];

    // Open the reg key
    hr  = RegOpenKeyExA( HKEY_LOCAL_MACHINE, 
						"Software\\Microsoft\\DirectPlay\\MemFail", 0, 
						KEY_READ, 
						&hKey);

	if(ERROR_SUCCESS == hr)
	{
		DWORD	dwKeyType;
		DWORD	dwBufferSize;

		dwBufferSize = 256;
		hr=RegQueryValueExA(hKey, "FailKey", NULL, &dwKeyType,
							(BYTE *)szFailKey, &dwBufferSize  );
		if (FAILED(hr))
			goto FAILURE;

		// Set the g_FailKey based on the string we got from the registry
		if (!strcmp(szFailKey, "NONE"))
			g_FailKey	= NONE;

		if (!strcmp(szFailKey, "RANDOM"))
			g_FailKey	= RANDOM;
		
		if (!strcmp(szFailKey, "BYTES"))
			g_FailKey	= BYTES;
		
		if (!strcmp(szFailKey, "ALLOCS"))
			g_FailKey	= ALLOCS;
		
		if (!strcmp(szFailKey, "OVERSIZED"))
			g_FailKey	= OVERSIZED;
		
		if (!strcmp(szFailKey, "TIME"))
			g_FailKey	= TIME;

		dwBufferSize = sizeof(DWORD);
		hr=RegQueryValueExA(hKey, "FailAfter", NULL, &dwKeyType, (BYTE *) &g_dwFailAfter, &dwBufferSize );
		if (FAILED(hr))
			goto FAILURE;

		dwBufferSize = sizeof(BOOL);
		hr=RegQueryValueExA(hKey, "KeepTally", NULL, &dwKeyType, (BYTE *) &g_bKeepTally, &dwBufferSize );
		if (FAILED(hr))
			goto FAILURE;
    }

FAILURE:
	// Close the registry key
	hr=RegCloseKey(hKey);
	return;
}



void WriteMemFailRegTally( DWORD dwAllocs, DWORD dwBytes )
{
	HRESULT		hr				= E_FAIL;
	HKEY		hKey			= NULL;

    // Open the reg key
    hr  = RegOpenKeyExA(	HKEY_LOCAL_MACHINE, 
							"Software\\Microsoft\\DirectPlay\\MemFail", 
							0,
							KEY_ALL_ACCESS, 
							&hKey );

	if (ERROR_SUCCESS != hr)
	{
		HKEY hKeyTop = NULL;
		hr  = RegOpenKeyExA(	HKEY_LOCAL_MACHINE, 
								"Software\\Microsoft\\DirectPlay", 
								0,
								KEY_ALL_ACCESS, 
								&hKeyTop);

		hr = RegCreateKeyA( hKeyTop,  "MemFail", &hKey );

		if (FAILED(hr))
			 goto FAILURE;

		RegCloseKey(hKeyTop);
	}

    hr=RegSetValueExA(hKey, "AllocTally",	0, REG_DWORD, (CONST BYTE *) &dwAllocs, sizeof(DWORD) );
    hr=RegSetValueExA(hKey, "ByteTally",	0, REG_DWORD, (CONST BYTE *) &dwBytes, sizeof(DWORD) );

FAILURE:
    // Close the registry key
    hr=RegCloseKey(hKey);
    return;
}


//
// Called with each memory allocation or reallocation
//
// Based on criteria from the registry, and the status of previous allocs
// this will either make the allocation succeed or fail.
//
BOOL DPMEM_ForceFail( UINT uSize )
{
	BOOL	bFail=FALSE;

	// If this is the first call, initialize the seed
	if (!g_dwSeed)
	{
		g_dwSeed	= GetTickCount();
		srand( g_dwSeed );
	}

	// Store the time of the first memory allocation
	if (!g_dwStartTime)
		g_dwStartTime	= GetTickCount();
	 
	// See what values are in the registry
	ReadMemFailRegKeys();

	//
	// Depending on what value the FailKey reg entry holds, fail, or pass
	//
	switch (g_FailKey)
	{
		case ALLOCS:
			if (g_dwAllocTally == g_dwFailAfter)
				return TRUE;
		break;

		case BYTES:
			if ((g_dwByteTally + uSize) > g_dwFailAfter)
				return TRUE;
		break;

		case OVERSIZED:
			if ( uSize > g_dwFailAfter )
				return TRUE;
		break;

		case RANDOM:
			if (!g_dwAllocsBeforeFail && g_dwFailAfter)
				g_dwAllocsBeforeFail	= rand() % g_dwFailAfter;

			if (g_dwAllocsSinceFail == g_dwAllocsBeforeFail)
			{
				g_dwAllocsSinceFail		= 0;
				g_dwAllocsBeforeFail	= 0;
				return TRUE;
			}
			else
				g_dwAllocsSinceFail++;
		break;

		case TIME:
			if ((GetTickCount() - g_dwStartTime) > (g_dwFailAfter * 1000))
				return TRUE;
		break;
	}

	// Increment our tallys
	g_dwAllocTally++;
	g_dwByteTally += uSize;

	// Write them back to the registry, if requested
	if (g_bKeepTally)
		WriteMemFailRegTally( g_dwAllocTally, g_dwByteTally );

	return bFail;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpos.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpos.h
 *  Content:	Function prototypes for OS wrapper functions
 *  History:
 *	Date	By		Reason
 *	====	==		======
 *	6/19/96	myronth	created it
 *	6/19/96	kipo	changed the interface to GetString() to return an HRESULT
 *	6/20/96 andyco	changed the interface to GetAnsiString() to return an HRESULT
 *	12/2/97	myronth	Added OS_RegDeleteKey function
 *	1/20/98	myronth	Moved PRV_SendStandardSystemMessage to dplobbyi.h
***************************************************************************/
#ifndef __DPOS_INCLUDED__
#define __DPOS_INCLUDED__

BOOL OS_IsPlatformUnicode(void);
BOOL OS_IsValidHandle(HANDLE handle);
HRESULT OS_CreateGuid(LPGUID pGuid);
int OS_StrLen(LPCWSTR lpwStr);
int OS_StrCmp(LPCWSTR lpwStr1, LPCWSTR lpwStr2);
int WideToAnsi(LPSTR lpStr,LPWSTR lpWStr,int cchStr);
int AnsiToWide(LPWSTR lpWStr,LPSTR lpStr,int cchWStr);
HRESULT GetWideStringFromAnsi(LPWSTR * ppszWide,LPSTR pszAnsi);
HRESULT GetAnsiString(LPSTR * ppszAnsi,LPWSTR pszWide);
HRESULT GetString(LPWSTR * ppszDest,LPWSTR pszSrc);
HINSTANCE OS_LoadLibrary(LPWSTR pszWFileName);
FARPROC OS_GetProcAddress(HMODULE  hModule,LPSTR lpProcName);
HANDLE OS_CreateEvent(LPSECURITY_ATTRIBUTES lpSA, BOOL bManualReset,
						BOOL InitialState, LPWSTR lpName);
HANDLE OS_CreateMutex(LPSECURITY_ATTRIBUTES lpSA, BOOL bInitialOwner,
						LPWSTR lpName);
HANDLE OS_OpenEvent(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
HANDLE OS_OpenMutex(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
HANDLE OS_CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpSA,
							DWORD dwProtect, DWORD dwMaxSizeHigh,
							DWORD dwMaxSizeLow, LPWSTR lpName);
HANDLE OS_OpenFileMapping(DWORD dwAccess, BOOL bInherit, LPWSTR lpName);
BOOL OS_CreateProcess(LPWSTR lpwszAppName, LPWSTR lpwszCmdLine,
		LPSECURITY_ATTRIBUTES lpSAProcess, LPSECURITY_ATTRIBUTES lpSAThread,
		BOOL bInheritFlags, DWORD dwCreationFlags, LPVOID lpEnv,
		LPWSTR lpwszCurDir, LPSTARTUPINFO lpSI, LPPROCESS_INFORMATION lpPI);
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid);
HRESULT StringFromGUID(LPGUID lpGuid, LPWSTR lpwszGuid, DWORD dwBufferSize);
HRESULT AnsiStringFromGUID(LPGUID lpg, LPSTR lpszGuid, DWORD dwBufferSize);
LONG OS_RegOpenKeyEx(HKEY hKey,LPWSTR pvKeyStr,DWORD dwReserved,REGSAM samDesired,PHKEY phkResult);	
LONG OS_RegQueryValueEx(HKEY hKey,LPWSTR lpszValueName,LPDWORD lpdwReserved,
	LPDWORD lpdwType,LPBYTE lpbData,LPDWORD lpcbData);	
LONG OS_RegEnumKeyEx( HKEY hKey,DWORD iSubkey,LPWSTR lpszName,LPDWORD lpcchName,LPDWORD lpdwReserved,
	LPTSTR lpszClass, LPDWORD lpcchClass, PFILETIME lpftLastWrite );
long OS_RegSetValueEx(HKEY hKey, LPWSTR lpszValueName, DWORD dwReserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
long OS_RegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData);
long OS_RegDeleteValue(HKEY hKey, LPWSTR lpszValueName);
long OS_RegCreateKeyEx(HKEY hKey, LPWSTR lpszSubKey, DWORD dwReserved, LPWSTR lpszClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
long OS_RegDeleteKey(HKEY hKey, LPWSTR lpszKeyName);
DWORD OS_GetCurrentDirectory(DWORD dwSize, LPWSTR lpBuffer);
int OS_CompareString(LCID Locale, DWORD dwCmpFlags, LPWSTR lpwsz1,
		int cchCount1, LPWSTR lpwsz2, int cchCount2);
LPWSTR OS_StrStr(LPWSTR lpwsz1, LPWSTR lpwsz2);


#endif // __DPOS_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpprot.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpprot.h
 *  Content:	DirectPlay reliable protocol header for dplay.
 *
 *  Notes:      code backing this up in protocol.lib
 *
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 * 5/11/97 aarono   created
 * 2/18/98 aarono   added protos of Protocol* functions 
 * 2/19/98 aarono   eliminated ProtocolShutdown, ProtocolShutdownEx.
 *                  added FiniProtocol. Shuts down on DP_Close now.
 * 3/19/98 aarono   added ProtocolPreNotifyDeletePlayer
 ***************************************************************************/

#ifndef _DPPROT_H_
#define _DPPROT_H_

extern HRESULT WINAPI InitProtocol(LPDPLAYI_DPLAY this);
extern VOID    WINAPI FiniProtocol(LPVOID pProtocol);
extern HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData);
extern HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData);
extern HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData);
extern HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData);

// New APIs for DX6
extern HRESULT WINAPI ProtocolGetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pGetMessageQueueData);
extern HRESULT WINAPI ProtocolSendEx(LPDPSP_SENDEXDATA pSendData);
extern HRESULT WINAPI ProtocolCancel(LPDPSP_CANCELDATA pGetMessageQueueData);

// Notify protocol when a DELETEPLAYER message is pended, so it can stop any ongoing sends.
extern HRESULT WINAPI ProtocolPreNotifyDeletePlayer(LPDPLAYI_DPLAY this, DPID idPlayer);

extern DWORD bForceDGAsync;

HRESULT 
DPAPI DP_SP_ProtocolHandleMessage(
	IDirectPlaySP * pISP,
	LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,
	LPVOID pvSPHeader
	);

extern
VOID 
DPAPI DP_SP_ProtocolSendComplete(
	IDirectPlaySP * pISP,
	LPVOID          lpvContext,
	HRESULT         CompletionStatus
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpos.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpos.c
 *  Content:	DirectPlay OS functions, and misc utils.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  5/7/96	andyco	created it
 *	6/19/96	kipo	changed the interface to GetString() to return an HRESULT
 *	6/20/96	andyco	changed the interface to GetAnsiString() to return an HRESULT
 *  6/30/96 dereks  Added OS_RegSetValueEx(), OS_RegEnumValue(),
 *                  OS_RegDeleteValue(), OS_RegCreateKeyEx()
 *  7/3/96	andyco	GetAnsiString puts terminating NULL on string
 *	8/16/96	andyco	check for null strings on ansitowide and widetoansi
 *	12/11/96myronth	Fixed bug #4993
 *	3/31/97	myronth	Fixed DPF spew for getting shared buffer -- set it to 8
 *	8/22/97	myronth	Fixed OS_CreateGuid to use SUCCEEDED macro & return a
 *					valid hresult in the failure case (#10949)
 *	12/2/97	myronth	Added OS_RegDeleteKey function
 *	1/26/98	myronth	Added OS_CompareString function
 *  6/25/99 aarono  B#24853 Unregister application not working because GUID
 *                  matching not working for GUID that don't have msb set
 *                  in the first GUID component.  Added padding before check.
 *  7/9/99  aarono  Cleaning up GetLastError misuse, must call right away,
 *                  before calling anything else, including DPF.
 *  5/16/01 RichGr  B#50737 Lobby-launched apps with a NULL current directory 
 *                  were failing on Win9x as the required buffer size was not being
 *                  returned from OS_GetCurrentDirectory().  Now fixed. 
 ****************************************************************************/
// note - these are not general purpose routines.  they are designed specifically
// for use with the file api.c, and they may not support all functionality of the
// function they are abstracting!

#include "dplaypr.h"
#include "rpc.h"

#undef DPF_MODNAME
#define DPF_MODNAME "OS_"

BOOL OS_IsPlatformUnicode()
{
	OSVERSIONINFOA	ver;
	BOOL			bReturn = FALSE;


	// Clear our structure since it's on the stack
	memset(&ver, 0, sizeof(OSVERSIONINFOA));
	ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);

	// Just always call the ANSI function
	if(!GetVersionExA(&ver))
	{
		DPF_ERR("Unable to determinte platform -- setting flag to ANSI");
		bReturn = FALSE;
	}
	else
	{
		switch(ver.dwPlatformId)
		{
			case VER_PLATFORM_WIN32_WINDOWS:
				DPF(9, "Platform detected as non-NT -- setting flag to ANSI");
				bReturn = FALSE;
				break;

			case VER_PLATFORM_WIN32_NT:
				DPF(9, "Platform detected as NT -- setting flag to Unicode");
				bReturn = TRUE;
				break;

			default:
				DPF_ERR("Unable to determine platform -- setting flag to ANSI");
				bReturn = FALSE;
				break;
		}
	}

	// Keep the compiler happy
	return bReturn;

}  // OS_IsUnicodePlatform


BOOL OS_IsValidHandle(HANDLE handle)
{
	HANDLE	hTemp;
	DWORD	dwError;


	// Validate the handle by calling DuplicateHandle.  This function
	// shouldn't change the state of the handle at all (except some
	// internal ref count or something).  So if it succeeds, then we
	// know we have a valid handle, otherwise, we will call it invalid.
	if(!DuplicateHandle(GetCurrentProcess(), handle,
						GetCurrentProcess(), &hTemp,
						DUPLICATE_SAME_ACCESS, FALSE,
						DUPLICATE_SAME_ACCESS))
	{
		dwError = GetLastError();
		DPF(0, "Duplicate Handle failed -- dwError = %lu",dwError);
		return FALSE;
	}

	// Now close our duplicate handle
	CloseHandle(hTemp);
	return TRUE;


} // OS_IsValidHandle


HRESULT OS_CreateGuid(LPGUID pGuid)
{
	RPC_STATUS rval;

	rval = UuidCreate(pGuid);

	// myronth -- changed this to use the succeeded macro so that in the
	// case where we are on a machine that doesn't have a network card,
	// this function will return a warning, but the pGuid will still be
	// unique enough for our purposes (only unique to the local machine).
	// Therefore, we will return a success in this case...
	if (SUCCEEDED(rval))
	{
		return DP_OK;
	}
	else
	{
		ASSERT(FALSE);
		DPF(0,"create guid failed - error = %d\n",rval);
		return rval;
	}

} // OS_CreateGuid

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;

    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++;
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		else
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPWSTR lpWStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	char lpTemp[GUID_STRING_SIZE];
	char *lpStr = lpTemp;

	memset(lpTemp,0,GUID_STRING_SIZE); // initialize
	
	WideToAnsi(lpStr,lpWStr,GUID_STRING_SIZE);

	lpTemp[GUID_STRING_SIZE-1]='\0';	// force NULL termination
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;

	// Fix for B#24853 GUIDs that don't have full significance fail
	// to be extracted properly.  This is because there aren't any
	// leading zeros stored in the GUID in the registry.  So we need
	// to zero pad the start of the GUID string before doing the
	// rest of the conversion.
	{
		int guidStrLen;
		char *lpScanStr=lpStr;

		guidStrLen=strlen(lpTemp);
		
		lpTemp[guidStrLen]='-'; //sentinel over terminating NULL

		while(*lpScanStr != '-'){ // find guid component separator
			lpScanStr++;
		}

		lpTemp[guidStrLen]='\0'; //eliminate sentinel

		// if this GUID's first component is not fully significant, then pad it.
		if(lpScanStr-lpStr < 8){
			int nPadBytes;
			nPadBytes = (int)(8-(lpScanStr-lpStr));
			if(guidStrLen + nPadBytes < GUID_STRING_SIZE-1){
				// there is room to pad it, so shift it.
				memmove(lpStr+nPadBytes, lpStr, GUID_STRING_SIZE-nPadBytes-1);
				// now write the pad bytes
				lpScanStr = lpStr;
				while(nPadBytes--){
					*(lpScanStr++)='0';
				}
			}
		}
	}
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr)
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString


// convert passed in guid to a string and place it in the buffer passed in
HRESULT StringFromGUID(LPGUID lpg, LPWSTR lpwszGuid, DWORD dwBufferSize)
{
	CHAR	szGuid[GUID_STRING_SIZE];


	// First check the size of the buffer
	if(dwBufferSize < GUID_STRING_SIZE)
		return DPERR_GENERIC;

	if(gbWin95)
	{
		wsprintfA(szGuid, "{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
			lpg->Data1, lpg->Data2, lpg->Data3, lpg->Data4[0], lpg->Data4[1],
			lpg->Data4[2], lpg->Data4[3], lpg->Data4[4], lpg->Data4[5],
			lpg->Data4[6], lpg->Data4[7]);

		AnsiToWide(lpwszGuid, szGuid, lstrlenA(szGuid)+1);
	}
	else
	{
		wsprintf(lpwszGuid, TEXT("{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), lpg->Data1, lpg->Data2,
			lpg->Data3, lpg->Data4[0], lpg->Data4[1], lpg->Data4[2], lpg->Data4[3],
			lpg->Data4[4], lpg->Data4[5], lpg->Data4[6], lpg->Data4[7]);
	}

	return DP_OK;
}

// convert passed in guid to a string and place it in the buffer passed in
HRESULT AnsiStringFromGUID(LPGUID lpg, LPSTR lpszGuid, DWORD dwBufferSize)
{
	ASSERT(lpszGuid);
	
	// First check the size of the buffer
	if(dwBufferSize < GUID_STRING_SIZE)
		return DPERR_GENERIC;

	wsprintfA(lpszGuid, "{%x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
			lpg->Data1, lpg->Data2, lpg->Data3, lpg->Data4[0], lpg->Data4[1],
			lpg->Data4[2], lpg->Data4[3], lpg->Data4[4], lpg->Data4[5],
			lpg->Data4[6], lpg->Data4[7]);

	return DP_OK;
}

// compute a wide string length.
// use this instead of crt fn. so we don't have
// to link to msvcrt.lib (and there's no wstrlen in libc.lib)
// called by WSTRLEN macro
int OS_StrLen(LPCWSTR lpwStr)
{
	int i=1; // 1 for null terminator...

	if (!lpwStr) return 0;

	while (*lpwStr++) i++;

	return i;
} //OS_StrLen

// compare two wide strings
int OS_StrCmp(LPCWSTR lpwStr1, LPCWSTR lpwStr2)
{
    if(!lpwStr1 || !lpwStr2)
    {
        if(!lpwStr1 && !lpwStr2) return 0;
        else return -1;
    }

    while(*lpwStr1 && *lpwStr2)
    {
        if(*lpwStr1 != *lpwStr2) return *lpwStr1 - *lpwStr2;

        lpwStr1++;
        lpwStr2++;
    }

    return 0;
} //OS_StrCmp

/*
 ** GetAnsiString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszAnsi - pointer to string
 *				lpszWide - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and converts lpszWide to ansi
 *
 *  RETURNS: string length
 *
 */
HRESULT GetAnsiString(LPSTR * ppszAnsi,LPWSTR lpszWide)
{
	int iStrLen;
	
	ASSERT(ppszAnsi);

	if (!lpszWide)
	{
		*ppszAnsi = NULL;
		return DP_OK;
	}

	// call wide to ansi to find out how big +1 for terminating NULL
	iStrLen = WideToAnsi(NULL,lpszWide,0) + 1;
	ASSERT(iStrLen > 0);

	*ppszAnsi = DPMEM_ALLOC(iStrLen);
	if (!*ppszAnsi)	
	{
		DPF_ERR("could not get ansi string -- out of memory");
		return E_OUTOFMEMORY;
	}
	WideToAnsi(*ppszAnsi,lpszWide,iStrLen);

	return DP_OK;
} // GetAnsiString

/*
 ** GetString
 *
 *  CALLED BY: Everywhere
 *
 *  PARAMETERS: *ppszDest - pointer to string
 *				lpszSrc - string to copy
 *
 *  DESCRIPTION:	  handy utility function
 *				allocs space for and copies lpszSrc to lpszDest
 *
 *  RETURNS: strlength
 *
 */
HRESULT GetString(LPWSTR * ppszDest,LPWSTR lpszSrc)
{
	int iStrLen;

	ASSERT(ppszDest);

	if (!lpszSrc)
	{
		*ppszDest = NULL;
		return DP_OK;
	}

    // alloc dest string
    iStrLen=WSTRLEN_BYTES(lpszSrc) ;
    *ppszDest = DPMEM_ALLOC(iStrLen);
    if (!*ppszDest)
    {
            DPF_ERR("could not get string -- out of memory!");
            return E_OUTOFMEMORY;
    }
    // copy strings
	memcpy(*ppszDest,lpszSrc,iStrLen);
	
	return DP_OK;
} // GetString

HINSTANCE OS_LoadLibrary(LPWSTR lpszWFileName)
{
	if (gbWin95)
	{
		char FileName[DPLAY_MAX_FILENAMELEN];
		
		WideToAnsi(FileName,lpszWFileName,DPLAY_MAX_FILENAMELEN);
		
		return LoadLibraryA(FileName);
	}
	// nt, use unicode call
	return LoadLibrary(lpszWFileName);
} // OS_LoadLibrary

// we're always looking for "SPInit" name, so we can just use ansi
FARPROC OS_GetProcAddress(HMODULE  hModule,LPSTR lpProcName)
{
	// hmmm, no getprocaddressa, seems to be always ansi...
	return GetProcAddress(hModule,lpProcName);

} // OS_GetProcAddress

LONG OS_RegOpenKeyEx(HKEY hKey,LPWSTR lpszWKeyStr,DWORD dwReserved,REGSAM samDesired,PHKEY phkResult)
{
	if (gbWin95)
	{
		char lpszKeyStr[DPLAY_REGISTRY_NAMELEN];

		WideToAnsi(lpszKeyStr,lpszWKeyStr,DPLAY_REGISTRY_NAMELEN);

		return RegOpenKeyExA(hKey,lpszKeyStr,dwReserved,samDesired,phkResult);
	}
	else return RegOpenKeyEx(hKey,lpszWKeyStr,dwReserved,samDesired,phkResult);

} // OS_RegOpenKeyEx

LONG OS_RegQueryValueEx(HKEY hKey,LPWSTR lpszWValueName,LPDWORD lpdwReserved,
	LPDWORD lpdwType,LPBYTE lpbData,LPDWORD lpcbData)
{

	ASSERT(lpcbData);

	if (gbWin95)
	{
		char lpszValueName[DPLAY_REGISTRY_NAMELEN];
		int iStrLen;
		LONG rval;
		DWORD dwSize = 0;
								
		ASSERT(lpcbData);
		ASSERT(lpdwType);

		WideToAnsi(lpszValueName,lpszWValueName,DPLAY_REGISTRY_NAMELEN);

		if(lpcbData)
			dwSize = *lpcbData;

		rval = RegQueryValueExA(hKey,lpszValueName,lpdwReserved,
			lpdwType,lpbData,&dwSize);

		// convert back to wchar
		// take into account the case where lpbData is NULL
		if ((ERROR_SUCCESS == rval) && (REG_SZ == *lpdwType) && (lpbData))
		{
			char * lpszTemp;

			DPF(9,"reg - converting string");
			
			//
			// dwSize is the size of the ansi string
			// iStrLen is the size of the unicode string
			// lpcbData is the size of the buffer
			// lpbData is an ansi version of the (unicode) string we want...
			//
			// make sure buffer will hold unicode string
			iStrLen = AnsiToWide(NULL,lpbData,0);
			if (*lpcbData < (DWORD) iStrLen)
			{
				DPF_ERR("buffer too small!");
				return ERROR_INSUFFICIENT_BUFFER;
			}
			lpszTemp = DPMEM_ALLOC(dwSize);
			if (!lpszTemp)
			{
				DPF_ERR("could not alloc buffer for string conversion");
				return ERROR_NOT_ENOUGH_MEMORY;
			}
			memcpy(lpszTemp,lpbData,dwSize);
			// lpszTemp now holds the ansi string
			iStrLen = AnsiToWide((WCHAR *)lpbData,lpszTemp,*lpcbData);
			// finally, the unicode string is in lpbData
			*lpcbData = iStrLen;
			DPMEM_FREE(lpszTemp);
		}
		else
		{
			// This function returns the number of bytes (not WCHARs)
			*lpcbData = dwSize * sizeof(WCHAR);
		}
		return rval;
	}
	else return RegQueryValueEx(hKey,lpszWValueName,lpdwReserved,
			lpdwType,lpbData,lpcbData);

}// OS_RegQueryValueEx


LONG OS_RegEnumKeyEx( HKEY hKey,DWORD iSubkey,LPWSTR lpszWName,LPDWORD lpcchName,
	LPDWORD lpdwReserved,LPWSTR lpszClass, LPDWORD lpcchClass,
	PFILETIME lpftLastWrite )
{

	ASSERT(!lpdwReserved);
	ASSERT(!lpszClass);
	ASSERT(!lpcchClass);
	ASSERT(!lpftLastWrite);

	if (gbWin95)
	{
		char lpszName[DPLAY_REGISTRY_NAMELEN];
		LONG rval;
		DWORD dwNameLen = DPLAY_REGISTRY_NAMELEN;
								
		rval = RegEnumKeyExA(hKey,iSubkey,lpszName,&dwNameLen,NULL,
			NULL, NULL, NULL );

		// convert back to wchar
		if (ERROR_SUCCESS == rval)
		{
			*lpcchName = AnsiToWide(lpszWName,lpszName,DPLAY_REGISTRY_NAMELEN);
		}

		return rval;
	}
	else return RegEnumKeyEx(hKey,iSubkey,lpszWName,lpcchName,NULL,
			NULL, NULL, NULL );
} // OS_RegEnumKeyEx

//
// Additions from dplos.c in the dplobby project
//
HANDLE OS_CreateEvent(LPSECURITY_ATTRIBUTES lpSA, BOOL bManualReset,
						BOOL bInitialState, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hEvent;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hEvent = CreateEventA(lpSA, bManualReset, bInitialState, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hEvent = CreateEvent(lpSA, bManualReset, bInitialState, lpName);
	}	

	return hEvent;
}


HANDLE OS_CreateMutex(LPSECURITY_ATTRIBUTES lpSA, BOOL bInitialOwner,
						LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMutex;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMutex = CreateMutexA(lpSA, bInitialOwner, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMutex = CreateMutex(lpSA, bInitialOwner, lpName);
	}	

	return hMutex;
}


HANDLE OS_OpenEvent(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hEvent;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hEvent = OpenEventA(dwAccess, bInherit, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hEvent = OpenEvent(dwAccess, bInherit, lpName);
	}	

	return hEvent;
}


HANDLE OS_OpenMutex(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMutex;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMutex = OpenMutexA(dwAccess, bInherit, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMutex = OpenMutex(dwAccess, bInherit, lpName);
	}	

	return hMutex;
}


HANDLE OS_CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpSA,
							DWORD dwProtect, DWORD dwMaxSizeHigh,
							DWORD dwMaxSizeLow, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMapping;
	LPSTR	lpszTemp = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMapping = CreateFileMappingA(hFile, lpSA, dwProtect, dwMaxSizeHigh,
										dwMaxSizeLow, lpszTemp);

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMapping = CreateFileMapping(hFile, lpSA, dwProtect, dwMaxSizeHigh,
										dwMaxSizeLow, lpName);
	}	

	return hMapping;
}


HANDLE OS_OpenFileMapping(DWORD dwAccess, BOOL bInherit, LPWSTR lpName)
{
	HRESULT	hr;
	HANDLE	hMapping = NULL;
	LPSTR	lpszTemp = NULL;
	DWORD	dwError;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszTemp, lpName);
		if(FAILED(hr))
		{
			DPF_ERR("Couldn't allocate memory for temp string!");
			return NULL;
		}

		hMapping = OpenFileMappingA(dwAccess, bInherit, lpszTemp);
		if(!hMapping)
		{
			dwError = GetLastError();
			DPF(8, "Error getting shared memory file handle");
			DPF(8, "dwError = 0x%08x", dwError);
		}

		DPMEM_FREE(lpszTemp);
	}
	else
	{
		hMapping = OpenFileMapping(dwAccess, bInherit, lpName);
	}	

	return hMapping;
}


BOOL OS_CreateProcess(LPWSTR lpwszAppName, LPWSTR lpwszCmdLine,
		LPSECURITY_ATTRIBUTES lpSAProcess, LPSECURITY_ATTRIBUTES lpSAThread,
		BOOL bInheritFlags, DWORD dwCreationFlags, LPVOID lpEnv,
		LPWSTR lpwszCurDir, LPSTARTUPINFO lpSI, LPPROCESS_INFORMATION lpPI)
{
	HRESULT	hr;
	BOOL	bResult;
	STARTUPINFOA	sia;
	LPSTR	lpszAppName = NULL,
			lpszCmdLine = NULL,
			lpszCurDir = NULL;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		hr = GetAnsiString(&lpszAppName, lpwszAppName);
		if(SUCCEEDED(hr))
		{
			hr = GetAnsiString(&lpszCmdLine, lpwszCmdLine);
			if(SUCCEEDED(hr))
			{
				hr = GetAnsiString(&lpszCurDir, lpwszCurDir);
				if(FAILED(hr))
				{
					DPMEM_FREE(lpszAppName);
					DPMEM_FREE(lpszCmdLine);
					DPF_ERR("Couldn't allocate memory for temp CurDir string!");
					return FALSE;
				}
			}
			else
			{
				DPMEM_FREE(lpszAppName);
				DPF_ERR("Couldn't allocate memory for temp CmdLine string!");
				return FALSE;
			}
		}
		else
		{
			DPF_ERR("Couldn't allocate memory for temp AppName string!");
			return FALSE;
		}

		// Set up the ANSI STARTUPINFO structure, assuming we are not setting
		// any of the strings in the structures.  (This should be true since
		// the only place we call this is in dplgame.c and it doesn't send anything
		// in this structure).
		memcpy(&sia, lpSI, sizeof(STARTUPINFO));

		bResult = CreateProcessA(lpszAppName, lpszCmdLine, lpSAProcess,
					lpSAThread, bInheritFlags, dwCreationFlags, lpEnv,
					lpszCurDir, &sia, lpPI);

		if(lpszAppName)
			DPMEM_FREE(lpszAppName);
		if(lpszCmdLine)
			DPMEM_FREE(lpszCmdLine);
		if(lpszCurDir)
			DPMEM_FREE(lpszCurDir);
	}
	else
	{
		bResult = CreateProcess(lpwszAppName, lpwszCmdLine, lpSAProcess,
					lpSAThread, bInheritFlags, dwCreationFlags, lpEnv,
					lpwszCurDir, lpSI, lpPI);
	}	

	return bResult;
}


long OS_RegSetValueEx(HKEY hKey, LPWSTR lpszValueName, DWORD dwReserved, DWORD dwType,
	const BYTE *lpData, DWORD cbData)
{
    LPSTR                   lpszValueNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszValueNameA, lpszValueName)))
        {
            return (long)hr;
        }

        lResult = RegSetValueExA(hKey, lpszValueNameA, dwReserved, dwType, lpData, cbData);

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegSetValueEx(hKey, lpszValueName, dwReserved, dwType, lpData, cbData);
    }

    return lResult;
}


long OS_RegEnumValue(HKEY hKey, DWORD dwIndex, LPWSTR lpszValueName, LPDWORD lpcbValueName,
	LPDWORD lpReserved, LPDWORD lpdwType, LPBYTE lpbData, LPDWORD lpcbData)
{
    LPSTR                   lpszValueNameA = NULL;
    long                    lResult=E_FAIL;

    if(gbWin95)
    {
        if(lpszValueName && lpcbValueName && *lpcbValueName)
        {
            if(!(lpszValueNameA = (LPSTR)DPMEM_ALLOC(*lpcbValueName)))
            {
                return ERROR_OUTOFMEMORY;
            }

	        lResult = RegEnumValueA(hKey, dwIndex, lpszValueNameA, lpcbValueName, lpReserved,
	        	lpdwType, lpbData, lpcbData);

	        if(lpszValueName && lpcbValueName && *lpcbValueName)
	        {
	            AnsiToWide(lpszValueName, lpszValueNameA, *lpcbValueName);
	        }

			if(lpszValueNameA)
		        DPMEM_FREE(lpszValueNameA);
        }
    }
    else
    {
        lResult = RegEnumValue(hKey, dwIndex, lpszValueName, lpcbValueName, lpReserved,
        	lpdwType, lpbData, lpcbData);
    }

    return lResult;
}


long OS_RegDeleteValue(HKEY hKey, LPWSTR lpszValueName)
{
    LPSTR                   lpszValueNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszValueNameA, lpszValueName)))
        {
            return (long)hr;
        }

        lResult = RegDeleteValueA(hKey, lpszValueNameA);

        DPMEM_FREE(lpszValueNameA);
    }
    else
    {
        lResult = RegDeleteValue(hKey, lpszValueName);
    }

    return lResult;
}


long OS_RegCreateKeyEx(HKEY hKey, LPWSTR lpszSubKey, DWORD dwReserved, LPWSTR lpszClass,
	DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	PHKEY phkResult, LPDWORD lpdwDisposition)
{
    LPSTR                   lpszSubKeyA = NULL;
    LPSTR                   lpszClassA = NULL;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
    	if(!lpszSubKey){
    		return DPERR_GENERIC;
    	}
    	
    	if(FAILED(hr = GetAnsiString(&lpszSubKeyA, lpszSubKey)))
        {
            return (long)hr;
        }

        if(lpszClass && FAILED(hr = GetAnsiString(&lpszClassA, lpszClass)))
        {
            if(lpszSubKeyA)
            {
                DPMEM_FREE(lpszSubKeyA);
                return (long)hr;
            }
        }

        lResult = RegCreateKeyExA(hKey, lpszSubKeyA, dwReserved, lpszClassA, dwOptions,
        	samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

        if(lpszSubKeyA)
        {
            DPMEM_FREE(lpszSubKeyA);
        }

        if(lpszClassA)
        {
            DPMEM_FREE(lpszClassA);
        }
    }
    else
    {
        lResult = RegCreateKeyEx(hKey, lpszSubKey, dwReserved, lpszClass, dwOptions, samDesired,
        	lpSecurityAttributes, phkResult, lpdwDisposition);
    }

    return lResult;
}


long OS_RegDeleteKey(HKEY hKey, LPWSTR lpszKeyName)
{
    LPSTR                   lpszKeyNameA;
    HRESULT                 hr;
    long                    lResult;

    if(gbWin95)
    {
        if(FAILED(hr = GetAnsiString(&lpszKeyNameA, lpszKeyName)))
        {
            return (long)hr;
        }

        lResult = RegDeleteKeyA(hKey, lpszKeyNameA);

        DPMEM_FREE(lpszKeyNameA);
    }
    else
    {
        lResult = RegDeleteKey(hKey, lpszKeyName);
    }

    return lResult;
}


DWORD OS_GetCurrentDirectory(DWORD dwSize, LPWSTR lpBuffer)
{
	LPSTR	lpszTemp = NULL;
	DWORD	dwResult = 0;
	
	
	// If we're on Win95, alloc an ANSI string and call the ANSI API,
	// otherwise, just call the Unicode API.
	if(gbWin95)
	{
		if(lpBuffer)
		{
			lpszTemp = DPMEM_ALLOC(dwSize);
			if(!lpszTemp)
			{
				DPF_ERR("Unable to allocate memory for temporary CurrentDir string");
				return 0;
			}

			dwResult = GetCurrentDirectoryA(dwSize, lpszTemp);

			// Convert the string back to Unicode
			if(dwResult)
			{
				// NOTE: This min call is really unnecessary, but
				// just in case someone passes in a dwSize value which
				// is really a count of bytes instead of a count of
				// characters, we will make sure we don't
				// run off the end of our buffer (but the resulting
				// string will probably not be exactly what the caller
				// expects).
				AnsiToWide(lpBuffer, lpszTemp, min(dwResult, dwSize));
			}

			if(lpszTemp)
				DPMEM_FREE(lpszTemp);

		}
        else
        {
            // Get the size in bytes.
            dwResult = GetCurrentDirectoryA(0, NULL);
            dwResult *= 2;  // But allow for UNICODE.
        }
    }
    else
    {
        dwResult = GetCurrentDirectory(dwSize, lpBuffer);
    }	              

	return dwResult;
}


int OS_CompareString(LCID Locale, DWORD dwCmpFlags, LPWSTR lpwsz1,
		int cchCount1, LPWSTR lpwsz2, int cchCount2)
{
	LPSTR	lpsz1 = NULL;
	LPSTR	lpsz2 = NULL;
	int		iReturn;
	HRESULT	hr;

	if(!lpwsz1 || !lpwsz2){
		// make prefix happy.
		return 0;
	}
	// If we're on Win95, alloc ANSI strings and call the ANSI API,
	// otherwise, just call the Unicode API.  If we fail allocating
	// memory, return zero which indicates the strings are not equal.
	if(gbWin95)
	{
		// Allocate ANSI strings
		hr = GetAnsiString(&lpsz1, lpwsz1);
		if(FAILED(hr))
		{
			DPF_ERR("Unable to allocate memory for temporary string");
			return 0;
		}

		hr = GetAnsiString(&lpsz2, lpwsz2);
		if(FAILED(hr))
		{
			DPMEM_FREE(lpsz1);
			DPF_ERR("Unable to allocate memory for temporary string");
			return 0;
		}

		// Now call the ANSI API
		iReturn = CompareStringA(Locale, dwCmpFlags, lpsz1, cchCount1,
					lpsz2, cchCount2);

		// Free the strings
		DPMEM_FREE(lpsz1);
		DPMEM_FREE(lpsz2);

	}
	else
	{
		iReturn = CompareString(Locale, dwCmpFlags, lpwsz1, cchCount1,
					lpwsz2, cchCount2);
	}

	return iReturn;

} // OS_CompareString

LPWSTR OS_StrStr(LPWSTR lpwsz1, LPWSTR lpwsz2)
{
	DWORD i;
	// returns a pointer to the first occurance of lpwsz2 in lpwsz1
	while(*lpwsz1){
	
		i=0;
		while( (*(lpwsz2+i) && *(lpwsz1+i)) && (*(lpwsz1+i) == *(lpwsz2+i))){
			i++;
		}
		if(*(lpwsz2+i)==L'\0'){
			return lpwsz1;
		}
		lpwsz1++;
	}
	return NULL;	
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpmem.h ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:	dpmem.h
*  Content:	Header file for memory function wrappers for DirectPlay
*  History:
*   Date		By		Reason
*   ====		==		======
*	9/26/96		myronth	created it
***************************************************************************/

extern CRITICAL_SECTION gcsMemoryCritSection; // From dpmem.c


LPVOID DPMEM_Alloc(UINT);
LPVOID DPMEM_ReAlloc(LPVOID, UINT);
void DPMEM_Free(LPVOID);
void DPMEM_Fini(void);
void DPMEM_State(void);
BOOL DPMEM_Init(void);
UINT_PTR DPMEM_Size(LPVOID);


#define INIT_DPMEM_CSECT() InitializeCriticalSection(&gcsMemoryCritSection);
#define FINI_DPMEM_CSECT() DeleteCriticalSection(&gcsMemoryCritSection);

#define DPMEM_ALLOC(size) DPMEM_Alloc(size)
#define DPMEM_REALLOC(ptr, size) DPMEM_ReAlloc(ptr, size)
#define DPMEM_FREE(ptr) DPMEM_Free(ptr)
// These can be used so bounds checker can find leaks
//#define DPMEM_ALLOC(size) GlobalAlloc(GPTR, (size))
//#define DPMEM_REALLOC(ptr,size) GlobalReAlloc(ptr, size, 0)
//#define DPMEM_FREE(ptr) GlobalFree(ptr)

#define DPMEM_FINI() DPMEM_Fini()
#define DPMEM_STATE() DPMEM_State()
#define DPMEM_INIT() DPMEM_Init()
#define DPMEM_SIZE() DPMEM_Size()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpmess.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpmessage.h
 *  Content:	DirectPlay message structures
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	2/10/96	andyco	created it
 *	3/15/96	andyco	added macros for manipulating messages (e.g. GET_MESSAGE_SIZE)
 *	4/21/96	andyco	added dwresreved3
 *	4/25/96	andyco	got rid of dwreservedx. spblob follows message. blobsize
 *					is lpdplayi_dplay->dwSPHeaderSize
 *	5/29/96 andyco	added playerdata
 *	6/22/96 andyco	added enumrequest,enumreply structs
 *	6/22/96	andyco	added groupidrequest, so server can refuse new players
 *	6/24/96	kipo	changed guidGame to guidApplication.
 *	7/31/96	andyco	added ping,pingreply
 *	8/6/96	andyco	added version stuff.  dwCmd->dwCmdToken. added offset
 *					to all packed fields (so we can change struct size w/o
 *					breaking compat).
 *	8/22/96	andyco	added playerwrapper
 * 10/11/96 sohailm added struct _MSG_SESSIONDESC and constant DPSP_MSG_SESSIONDESCCHANGED
 * 01/17/97 sohailm added struct _MSG_REQUESTPLAYERID.
 * 03/12/97 sohailm added new security related messages, MSG_SIGNED and MSG_AUTHENTICATION 
 *                  structs, DPSP_HEADER_LOCALMSG(constant), and dwSecurityPackageNameOffset 
 *                  field to PLAYERIDREPLY.
 * 03/24/97 sohailm added DPSP_MSG_DX5VERSION, DPSP_MSG_ADDFORWARDREPLY, and struct MSG_ADDFORWARDREPLY
 * 03/25/97 sohailm DPSP_MSG_DX5VERSION and DPSP_MSG_VERSION set to 4
 * 4/11/97	andyco	ask4multicast
 * 04/14/97 sohailm renamed structure MSG_SIGNED to MSG_SECURE, as we use the same structure for
 *                  both signing and encryption.
 *	4/20/97	andyco	group in group
 *	5/8/97	andyco	removed update list message
 *	5/8/97	myronth	StartSession
 * 05/12/97 sohailm Added DPSP_MSG_KEYEXCHANGE and DPSP_MSG_KEYEXCHANGEREPLY.
 *                  Added securitydesc, dwSSPIProviderOffset, and dwCAPIProviderOffset members
 *                   to MSG_PLAYERIDREPLY structure.
 *                  Added MSG_ACCESSGRANTED and MSG_KEYEXCHANGE structures.
 * 05/12/97 sohailm Bumped DPSP_MSG_DX5VERSION and DPSP_MSG_VERSION to 6
 *	5/17/97	myronth	SendChatMessage
 * 06/09/97 sohailm Renamed DPSP_MSG_ACCESSDENIED to DPSP_MSG_LOGONDENIED.
 * 06/16/97 sohailm Added struct MSG_AUTHERROR.
 * 06/23/97 sohailm Added dwFlags to DPMSG_SECURE. Removed DPSP_MSG_ENCRYPTED.
 * 8/5/97	andyco	async addforward
 *	10/29/97myronth	Added MSG_GROUPOWNERCHANGED
 *	1/5/97	myronth	Added DX5A and DX6 message versions and added an hresult
 *					to MSG_PLAYERIDREPLY (#15891)
 *	1/20/98	myronth	#ifdef'd out voice support
 *  8/02/99	aarono  removed old voice support
 *  8/05/99 aarono  Added DPMSG_VOICE
 *  10/8/99 aarono  Added DPSP_MSG_DX8VERSION
 * 10/15/99 aarono  added DPSP_MSG_MULTICASTDELIVERY to fix multicast on 
 *                      the Direct Play Protocol.
 * 06/26/00 aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 *
 ***************************************************************************/


#ifndef __DPMESS_INCLUDED__
#define __DPMESS_INCLUDED__

// DPMESSAGES are send across the wire like other messages, their identifying mark is 
// that they begin with a special signature ('p','l','a','y') followed by a 2 byte
// little endian message id and then a 2 byte version number.

// The dplay reliable protocol violates this rule to save header bytes.  After the
// 'play' is a single 0xff byte which identifies the protocol.  In order to avoid
// ambiguity, no regular protocol message number may end in 0xff, i.e. 255,511, etc... 

// NOTE: NO MESSAGE NUMBER IS ALLOWED TO HAVE 0xFF IN THE LOW BYTE <<<LOOK HERE!!!!>>>
// this # goes in the top 16 bits of every dplay command
#define DPSP_MSG_DX3VERSION				1 // dx3
#define DPSP_MSG_AUTONAMETABLE          4 // the version in which client expects nametable
										  // to be sent on addforward	
#define DPSP_MSG_GROUPINGROUP           5 // the version we added group in group
#define DPSP_MSG_SESSIONNAMETABLE		7 // the version we send the session desc w/ enumplayersreply
#define DPSP_MSG_DX5VERSION             7 // dx5

#define DPSP_MSG_ASYNCADDFORWARD        8 // addforward requires an ack 
#define DPSP_MSG_DX5AVERSION			8 // dx5a
#define DPSP_MSG_RELIABLEVERSION        9 // introduced the reliable protocol
#define DPSP_MSG_DX6VERSION				9 // dx6
#define DPSP_MSG_DX61VERSION           10 // dx6.1
#define DPSP_MSG_DX61AVERSION          11 // dx6.1a
#define DPSP_MSG_DX8VERSION            12 // dx8, dxvoice - millenium ship
#define DPSP_MSG_DX8VERSION2			  13 // nametable fix - real DX8 
#define DPSP_MSG_VERSION			   13 // current

// these are the headers that go in the dwCmd field of the message
#define DPSP_MSG_ENUMSESSIONSREPLY 		1
#define DPSP_MSG_ENUMSESSIONS 			2
#define DPSP_MSG_ENUMPLAYERSREPLY 		3
#define DPSP_MSG_ENUMPLAYER 			4
#define DPSP_MSG_REQUESTPLAYERID		5
// there's a requestgroupid, since the server can turn down new players
// (based on dwmaxplayers) but not groups
#define DPSP_MSG_REQUESTGROUPID			6
// used for group + player
#define DPSP_MSG_REQUESTPLAYERREPLY		7
#define DPSP_MSG_CREATEPLAYER			8
#define DPSP_MSG_CREATEGROUP			9
#define DPSP_MSG_PLAYERMESSAGE			10
#define DPSP_MSG_DELETEPLAYER			11
#define DPSP_MSG_DELETEGROUP			12
#define DPSP_MSG_ADDPLAYERTOGROUP		13
#define DPSP_MSG_DELETEPLAYERFROMGROUP	14
#define DPSP_MSG_PLAYERDATACHANGED		15
#define DPSP_MSG_PLAYERNAMECHANGED		16
#define DPSP_MSG_GROUPDATACHANGED		17
#define DPSP_MSG_GROUPNAMECHANGED		18
#define DPSP_MSG_ADDFORWARDREQUEST		19
#define DPSP_MSG_NAMESERVER				20
#define DPSP_MSG_PACKET					21
#define DPSP_MSG_PING					22
#define DPSP_MSG_PINGREPLY				23
#define DPSP_MSG_YOUAREDEAD				24
#define DPSP_MSG_PLAYERWRAPPER			25
#define DPSP_MSG_SESSIONDESCCHANGED     26
#define DPSP_MSG_UPDATELIST				27
#define DPSP_MSG_CHALLENGE              28 
#define DPSP_MSG_ACCESSGRANTED          29
#define DPSP_MSG_LOGONDENIED            30
#define DPSP_MSG_AUTHERROR              31
#define DPSP_MSG_NEGOTIATE              32
#define DPSP_MSG_CHALLENGERESPONSE      33
#define DPSP_MSG_SIGNED                 34
#define DPSP_MSG_UNUSED1                35
#define DPSP_MSG_ADDFORWARDREPLY        36 
#define DPSP_MSG_ASK4MULTICAST			37
#define DPSP_MSG_ASK4MULTICASTGUARANTEED 38
#define DPSP_MSG_ADDSHORTCUTTOGROUP 	39
#define DPSP_MSG_DELETEGROUPFROMGROUP	40
#define DPSP_MSG_SUPERENUMPLAYERSREPLY 	41
#define DPSP_MSG_STARTSESSION			42
#define DPSP_MSG_KEYEXCHANGE            43
#define DPSP_MSG_KEYEXCHANGEREPLY       44
#define DPSP_MSG_CHAT					45
#define DPSP_MSG_ADDFORWARD				46
#define DPSP_MSG_ADDFORWARDACK			47
#define DPSP_MSG_PACKET2_DATA           48
#define DPSP_MSG_PACKET2_ACK            49
#define DPSP_MSG_GROUPOWNERCHANGED		50

#define DPSP_MSG_IAMNAMESERVER          53
#define DPSP_MSG_VOICE                  54
#define DPSP_MSG_MULTICASTDELIVERY      55
#define DPSP_MSG_CREATEPLAYERVERIFY			56

#define DPSP_MSG_DIEPIGGY				0x666
#define DPSP_MSG_PROTOCOL               0xFF		// See note above (LOOK HERE).

// flag for requesting async send on SendPlayerManagement Messages
#define DPSP_MSG_ASYNC					0x80000000

// if you are adding a new message that can be sent unsigned,
// add it to PermitMessage() in dpsecure.c

// MSG_HDR indicates a dplay system message
#define MSG_HDR 0x79616c70

#define IS_VALID_DPLAY_MESSAGE(pMsg) (MSG_HDR == (*((DWORD *)(pMsg))) )
#define SET_MESSAGE_HDR(pMsg)  (*((DWORD *)(pMsg)) = MSG_HDR )

#define IS_PLAYER_MESSAGE(pMsg) (!IS_VALID_DPLAY_MESSAGE(pMsg))

// calculate size for message + header
#define GET_MESSAGE_SIZE(this,MSG) (this->dwSPHeaderSize + sizeof(MSG))

#define COMMAND_MASK 0X0000FFFF
#define GET_MESSAGE_COMMAND(pMsg) ( (pMsg)->dwCmdToken & COMMAND_MASK)
#define GET_MESSAGE_VERSION(pMsg) ( ((pMsg)->dwCmdToken & ~COMMAND_MASK) >> 16 )

#define SET_MESSAGE_COMMAND(pMsg,dwCmd) ((pMsg)->dwCmdToken = ((dwCmd & COMMAND_MASK) \
	| (DPSP_MSG_VERSION<<16)) )

#define SET_MESSAGE_COMMAND_ONLY(pMsg,dwCmd) ((pMsg)->dwCmdToken =  \
			(((pMsg)->dwCmdToken & ~COMMAND_MASK)|(dwCmd & COMMAND_MASK)))

// This constant is used to indicate that a message is for a local player
#define DPSP_HEADER_LOCALMSG ((LPVOID)-1)

// dplay internal messages below. 
typedef struct _MSG_SYSMESSAGE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;	
} MSG_SYSMESSAGE,*LPMSG_SYSMESSAGE;

// for sending out the player blob
typedef struct _MSG_PLAYERDATA
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo;		// id of destination player
    DWORD dwPlayerID; 	// id of player whose data is being set
    DWORD dwDataSize;
	DWORD dwDataOffset; // offset (in bytes) of data (so we don't hardcode struct size) 
						// from beginning of message
	// data follows    	
} MSG_PLAYERDATA,*LPMSG_PLAYERDATA;

// sent when player name changes
typedef struct _MSG_PLAYERNAME
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo;		// id of destination player
    DWORD dwPlayerID; 	// id of player whose data is being set
	DWORD dwShortOffset; // offset (in bytes) of short name from beginning of message.  
						// 0 means null short name.
	DWORD dwLongOffset;	// offset (in bytes) of long name from beginning of message.
						// 0 means null long name.
	// strings follow 
} MSG_PLAYERNAME,*LPMSG_PLAYERNAME;

// create player / group, delete player/group
typedef struct _MSG_PLAYERMGMTMESSAGE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDTo; // player message is being sent to
    DWORD dwPlayerID; // player id effected
	DWORD dwGroupID; // group id effected
	DWORD dwCreateOffset; 	// offset of player / group creation stuff from beginning 
							// of message
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwPasswordOffset; // offset of session password
	// if it's an addplayer, the player data will follow this message
    // if it's an addforward, session password will follow the player data
} MSG_PLAYERMGMTMESSAGE,*LPMSG_PLAYERMGMTMESSAGE;

// sent by name srvr w/ session desc
typedef struct _MSG_ENUMSESSIONS
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	GUID  guidApplication;
	DWORD dwPasswordOffset;	// offset (in bytes) of password from beginning of message.
							// 0 means null password.
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwFlags;          // enum session flags passed in by the app
} MSG_ENUMSESSIONS,*LPMSG_ENUMSESSIONS;

// sent to nameserver
typedef struct _MSG_ENUMSESSIONSREPLY
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DPSESSIONDESC2 dpDesc; 
	DWORD dwNameOffset;	// offset (in bytes) of session name from beginning of message.
					   	// 0 means null session name.
} MSG_ENUMSESSIONSREPLY,*LPMSG_ENUMSESSIONSREPLY;


// sent by namesrvr w/ list of all players and groups in session
typedef struct _MSG_ENUMPLAYERREPLY
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD nPlayers; //  # players we actually got
	DWORD nGroups; // # of groups we got
	DWORD dwPackedOffset; // offset (in bytes) of packed player structs from beginning of message
	// added for DX5
	DWORD nShortcuts; // # of groups w/ shortcuts
	DWORD dwDescOffset; // offset (in bytes) of session desc from beginning of message
						// always > 0
	DWORD dwNameOffset;	// offset (in bytes) of session name from beginning of message.
					   	// 0 means null session name.
	DWORD dwPasswordOffset; // offset (in bytes) of session password from beginning of message.
					   	// 0 means null session name.
	// session name + password follow
    // player data will follow session name + password in reply buffer
	// group data follows players. see pack.c
} MSG_ENUMPLAYERSREPLY,*LPMSG_ENUMPLAYERSREPLY;

// sent to nameserver to request a player id
typedef struct _MSG_REQUESTPLAYERID
{
    DWORD dwHeader; 
    DWORD dwCmdToken;	
	// the following fields are only available in
	// DX5 or later versions
    DWORD dwFlags;      // player flags (system/applicaton player)
} MSG_REQUESTPLAYERID,*LPMSG_REQUESTPLAYERID;

// sent by name srvr w/ new player id
typedef struct _MSG_PLAYERIDREPLY
{
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwID; //  the new id
	// the following fields are only available in
	// DX5 or later versions
	DPSECURITYDESC dpSecDesc;   // security description - populated only if server is secure.
    DWORD dwSSPIProviderOffset; // offset (in bytes) of sspi provider name from beginning of message.
					   			// 0 means null provider name.
    DWORD dwCAPIProviderOffset; // offset (in bytes) of capi provider name from beginning of message.
					   			// 0 means null provider name.
    HRESULT hr; // return code used in DX6 and after
	// provider name strings follow
}MSG_PLAYERIDREPLY,*LPMSG_PLAYERIDREPLY;

// a player to player message
typedef struct _MSG_PLAYERMESSAGE
{
	DPID idFrom,idTo;
} MSG_PLAYERMESSAGE,*LPMSG_PLAYERMESSAGE;

typedef struct _MSG_PACKET
{
	DWORD dwHeader;
	DWORD dwCmdToken;
	GUID  guidMessage; // id of the message this packet belongs to
	DWORD dwPacketID; // this packet is # x of N
	DWORD dwDataSize; // total size of the data in this packet
					  // data follows MSG_PACKET struct
	DWORD dwOffset; // offset into reconstructed buffer for this packet
	DWORD dwTotalPackets; // total # of packets (N)
	DWORD dwMessageSize; // size of buffer to alloc at other end
	DWORD dwPackedOffset; // offset into this message of the actual packet data
						  // so we don't hardcode for struct sizes
} MSG_PACKET,*LPMSG_PACKET;	

typedef struct _MSG_PACKET_ACK
{
	DWORD dwHeader;
	DWORD dwCmdToken;
	GUID  guidMessage; // id of the message this packet belongs to
	DWORD dwPacketID;  // ACK packet is # x of N
} MSG_PACKET_ACK,*LPMSG_PACKET_ACK;	

typedef struct _MSG_PACKET     MSG_PACKET2,     *LPMSG_PACKET2;
typedef struct _MSG_PACKET_ACK MSG_PACKET2_ACK, *LPMSG_PACKET2_ACK;

// sent by name srvr w/ new player id
typedef struct _MSG_PING
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDFrom; //  the player who sent the ping
	DWORD dwTickCount; // tick count on message sending ping	
} MSG_PING,*LPMSG_PING;

// for sending out the session desc
typedef struct _MSG_SESSIONDESC
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDTo;
    DWORD dwSessionNameOffset;  // offsets of strings in the message
    DWORD dwPasswordOffset;     // so we don't hardcode for struct sizes
    DPSESSIONDESC2 dpDesc;
    // session name and password strings follow
} MSG_SESSIONDESC,*LPMSG_SESSIONDESC;


#define DPSECURE_SIGNEDBYSSPI			0x00000001
#define DPSECURE_SIGNEDBYCAPI			0x00000002
#define DPSECURE_ENCRYPTEDBYCAPI		0x00000004

// for sending signed messages
typedef struct _MSG_SECURE {
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDFrom;             // sender's system player id
    DWORD dwDataOffset;         // offset of dplay message
    DWORD dwDataSize;           // size of message
    DWORD dwSignatureSize;      // size of signature
	DWORD dwFlags;              // describes the contents
    // data and signature follow
} MSG_SECURE, *LPMSG_SECURE;

// authentication messages (negotiate, challenge, response, etc)
typedef struct _MSG_AUTHENTICATION {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwIDFrom;             // sender's system player id
    DWORD dwDataSize;           // size of opaque buffer
    DWORD dwDataOffset;         // offset of buffer
    // opaque buffer follows
} MSG_AUTHENTICATION, *LPMSG_AUTHENTICATION;

// for sending an error response to addforward (DX5)
// this message is sent by the nameserver to a client when addforward fails
typedef struct _MSG_ADDFORWARDREPLY {
    DWORD dwHeader;
    DWORD dwCmdToken;
    HRESULT hResult;            // indicates why addforward failed
} MSG_ADDFORWARDREPLY, *LPMSG_ADDFORWARDREPLY;

// message sent to the server when we want him to multicast for us
typedef struct _MSG_ASK4MULTICAST {
    DWORD dwHeader;
    DWORD dwCmdToken;
	DPID  idGroupTo;
	DPID  idPlayerFrom;
	DWORD dwMessageOffset;
} MSG_ASK4MULTICAST, *LPMSG_ASK4MULTICAST;

// when running the protocol, you can't send from a player except players
// on the system you are sending from, so for delivering through a multicast
// server we need to keep the message wrapped and crack it on deliver to get
// the addressing information correct on delivery.
typedef struct _MSG_ASK4MULTICAST MSG_MULTICASTDELIVERY, *LPMSG_MULTICASTDELIVERY;

typedef struct _MSG_STARTSESSION {
    DWORD dwHeader;
    DWORD dwCmdToken;
	DWORD dwConnOffset;
} MSG_STARTSESSION, *LPMSG_STARTSESSION;

typedef struct _MSG_ACCESSGRANTED {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwPublicKeySize;      // sender's public key blob size
    DWORD dwPublicKeyOffset;    // sender's public key
} MSG_ACCESSGRANTED, *LPMSG_ACCESSGRANTED;

typedef struct _MSG_KEYEXCHANGE {
    DWORD dwHeader;
    DWORD dwCmdToken;
    DWORD dwSessionKeySize;
    DWORD dwSessionKeyOffset;
    DWORD dwPublicKeySize;
    DWORD dwPublicKeyOffset;
} MSG_KEYEXCHANGE, *LPMSG_KEYEXCHANGE;

// chat message
typedef struct _MSG_CHAT
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDFrom;		// id of sending player
	DWORD dwIDTo;		// id of destination player
	DWORD dwFlags;		// DPCHAT flags
	DWORD dwMessageOffset; // offset (in bytes) of chat message from beginning of message.  
						// 0 means null message.
	// strings follow 
} MSG_CHAT,*LPMSG_CHAT;

// for sending an error response to an authentication message (DX5)
// this message is sent by the nameserver to a client when an authentication error occurs
typedef struct _MSG_AUTHERROR {
    DWORD dwHeader;
    DWORD dwCmdToken;
    HRESULT hResult;            // indicates why authentication failed
} MSG_AUTHERROR, *LPMSG_AUTHERROR;

// acks an addforward message
typedef struct _MSG_ADDFORWARDACK{
    DWORD dwHeader;
    DWORD dwCmdToken;
	DWORD dwID; // id that the addforward was sent for
} MSG_ADDFORWARDACK, *LPMSG_ADDFORWARDACK;

// group owner changed message
typedef struct _MSG_GROUPOWNERCHANGED
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDGroup;
	DWORD dwIDNewOwner;
	DWORD dwIDOldOwner;
} MSG_GROUPOWNERCHANGED,*LPMSG_GROUPOWNERCHANGED;

// Notification from the new name server to flip the
// necessary bits to make the nameserver bit true on 
// that player.
typedef struct _MSG_IAMNAMESERVER
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
    DWORD dwIDTo; 		// req'd field for system messages.
	DWORD dwIDHost;     // id of the host
	DWORD dwFlags;		// new host flags 
	DWORD dwSPDataSize; // length of contiguous following SP data field.
	CHAR  SPData[];
} MSG_IAMNAMESERVER,*LPMSG_IAMNAMESERVER;

typedef struct _MSG_VOICE
{
    DWORD dwHeader; 
    DWORD dwCmdToken;
	DWORD dwIDFrom;		// id of sending player
	DWORD dwIDTo;		// id of destination player or group
	// voice data follows
} MSG_VOICE,*LPMSG_VOICE;

// NOTE: we really only need the "To" address on the first packet of a message.
//       since most messages though are 1 packet, this is easier. On large messages
//       the extra 2 bytes per packet doesn't hurt.

#pragma pack(push,1)

// Message protocol header is variable using bit extension.  The first field
// is the from id, the second is the to id.  They can each be up to 3 bytes.
// This prototype allows allocators to calculate the worst case.
typedef struct _MSG_PROTOCOL {
	UCHAR   ToFromIds[6];		
} MSG_PROTOCOL, *LPMSG_PROTOCOL;

#pragma pack(pop)
// see protocol.h for the rest of the protocol header


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpsecos.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecos.c
 *  Content:	Windows SSPI calls.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through
 *                      Windows Security Support Provider Interface (SSPI)
 *  04/14/97    sohailm Added definitions for OS_FreeContextBuffer(), OS_QueryContextAttributes(), 
 *                      and OS_QueryContextBufferSize().
 *  05/12/97    sohailm Updated code to use gpSSPIFuncTbl instead of gpFuncTbl.
 *                      Added functions to access Crypto API.  
 *  05/29/97    sohailm Now we don't include null char in the size of credentials strings passed to sp.
 *                      Added QueryContextUserName(). Updated QueryContextBufferSize to return HRESULT.
 *  06/22/97    sohailm We return SSPI errors instead of DPERR_GENERIC now.
 *  06/23/97    sohailm Added support for signing messages using CAPI.
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *                      
 *
 ***************************************************************************/
#include <wtypes.h>
#include <newdpf.h>
#include <sspi.h>
#include "dplaypr.h"
#include "dpsecure.h"

/***************************************************************************
 * SSPI
 ***************************************************************************/

/*
 * Description: Checks to see if sspi function table has already been initialized
 */
BOOL OS_IsSSPIInitialized(void)
{
    if (gbWin95)
    {
        if (gpSSPIFuncTblA) return TRUE;
    }
    else 
    {
        if (gpSSPIFuncTbl) return TRUE;
    }

    return FALSE;
}

/*
 * Description: Initializes the security interface based on the operating system.
 */
BOOL OS_GetSSPIFunctionTable(HMODULE hModule)
{
    INIT_SECURITY_INTERFACE_A	addrProcISIA = NULL;
    INIT_SECURITY_INTERFACE 	addrProcISI = NULL;

    if (gbWin95)
    {
        addrProcISIA = (INIT_SECURITY_INTERFACE_A) GetProcAddress( hModule, 
            "InitSecurityInterfaceA");       

        if (addrProcISIA == NULL)
        {
            DPF(0,
               "GetProcAddress() of InitSecurityInterfaceA failed [%d]\n",
                GetLastError());
            return FALSE;
        }
        //
        // Get the SSPI function table
        //
        gpSSPIFuncTblA = (*addrProcISIA)();
        if (gpSSPIFuncTblA == NULL)
        {
            DPF(0,"InitSecurityInterfaceA() failed [0x%08x]\n", GetLastError());
            return FALSE;
        }
    }
    else
    {
        addrProcISI = (INIT_SECURITY_INTERFACE_W) GetProcAddress(hModule, 
            "InitSecurityInterfaceW");       

        if (addrProcISI == NULL)
        {
            DPF(0, 
                "GetProcAddress() of InitSecurityInterface failed [%d]\n",
                GetLastError());
            return FALSE;
        }
        //
        // Get the SSPI function table
        //
        gpSSPIFuncTbl = (*addrProcISI)();
        if (gpSSPIFuncTbl == NULL)
        {
            DPF(0,"InitSecurityInterface() failed [%d]\n", 
                GetLastError());
            return FALSE;
        }
    }
    
    // SUCCESS
    return TRUE;
}


SECURITY_STATUS OS_AcceptSecurityContext(
    PCredHandle         phCredential,
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCtxtHandle         phNewContext,
    PSecBufferDesc      pOutSecDesc,
    PULONG              pfContextAttributes,
    PTimeStamp          ptsTimeStamp
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->AcceptSecurityContext)) (
           phCredential, 
           phContext, 
           pInSecDesc,
           fContextReq, 
           TargetDataRep, 
           phNewContext,
           pOutSecDesc, 
           pfContextAttributes, 
           ptsTimeStamp
           );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->AcceptSecurityContext)) (
           phCredential, 
           phContext, 
           pInSecDesc,
           fContextReq, 
           TargetDataRep, 
           phNewContext,
           pOutSecDesc, 
           pfContextAttributes, 
           ptsTimeStamp
           );
    }
}

SECURITY_STATUS OS_AcquireCredentialsHandle(
    SEC_WCHAR *pwszPrincipal, 
    SEC_WCHAR *pwszPackageName,
    ULONG   fCredentialUse,
    PLUID   pLogonId,
    PSEC_WINNT_AUTH_IDENTITY_W pAuthDataW,
    PVOID   pGetKeyFn,
    PVOID   pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp  ptsLifeTime
    )
{
    ASSERT(pwszPackageName);

    if (gbWin95)
    {
        SEC_WINNT_AUTH_IDENTITY_A *pAuthDataA=NULL;
        SEC_WINNT_AUTH_IDENTITY_A AuthDataA;
        SECURITY_STATUS status;
        HRESULT hr;
        LPSTR pszPackageName = NULL;

        ASSERT(gpSSPIFuncTblA);
        ZeroMemory(&AuthDataA, sizeof(AuthDataA));

        // get an ansi package name
        hr = GetAnsiString(&pszPackageName,pwszPackageName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to get an ansi version of package name");
            status = E_FAIL;
            goto CLEANUP_EXIT;
        }

        if (pAuthDataW)
        {
            AuthDataA.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            // note - don't include null character in string size for credential strings
            if (pAuthDataW->User)
            {
                // get an ansi username
                hr = GetAnsiString(&AuthDataA.User,pAuthDataW->User);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of username");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.UserLength = STRLEN(AuthDataA.User)-1;
            }
            if (pAuthDataW->Password)
            {
                // get an ansi password
                hr = GetAnsiString(&AuthDataA.Password,pAuthDataW->Password);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of password");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.PasswordLength = STRLEN(AuthDataA.Password)-1;
            }
            if (pAuthDataW->Domain)
            {
                // get an ansi username
                hr = GetAnsiString(&AuthDataA.Domain,pAuthDataW->Domain);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get an ansi version of domain");
                    status = E_FAIL;
                    goto CLEANUP_EXIT;
                }
    	        AuthDataA.DomainLength = STRLEN(AuthDataA.Domain)-1;
            }
            pAuthDataA = &AuthDataA;
        }

        status = (*(gpSSPIFuncTblA->AcquireCredentialsHandleA)) (
            NULL, 
            pszPackageName, 
            fCredentialUse,  
            NULL, 
            pAuthDataA, 
            NULL, 
            NULL, 
            phCredential, 
            ptsLifeTime
            );

            // fall through

        CLEANUP_EXIT:
            // cleanup all local allocations
            if (AuthDataA.User) DPMEM_FREE(AuthDataA.User);
            if (AuthDataA.Password) DPMEM_FREE(AuthDataA.Password);
            if (AuthDataA.Domain) DPMEM_FREE(AuthDataA.Domain);
            if (pszPackageName) DPMEM_FREE(pszPackageName);
            return status;
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->AcquireCredentialsHandle)) (
            NULL, 
            pwszPackageName, 
            fCredentialUse,  
            NULL, 
            pAuthDataW, 
            NULL, 
            NULL, 
            phCredential, 
            ptsLifeTime
            );
    }
}


SECURITY_STATUS OS_DeleteSecurityContext(
    PCtxtHandle phContext
    )
{
	CtxtHandle hNullContext;

    DPF(6,"Deleting security context handle 0x%08x",phContext);

    // Passing unitialized handles (0) is causing first chance exceptions in the 
    // following calls. Therefore we are making these calls only if the handle is non-null.
	ZeroMemory(&hNullContext, sizeof(CtxtHandle));
	if (0 == memcmp(&hNullContext, phContext, sizeof(CtxtHandle)))
	{
		return SEC_E_OK;
	}

    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->DeleteSecurityContext)) (phContext);
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->DeleteSecurityContext)) (phContext);
    }
}

SECURITY_STATUS OS_FreeCredentialHandle(
    PCredHandle     phCredential
    )
{
	CredHandle hNullCredential;

    DPF(6,"Freeing credential handle 0x%08x",phCredential);

    // Passing unitialized handles (0) is causing first chance exceptions in the 
    // following calls. Therefore we are making these calls only if the handle is non-null.
	ZeroMemory(&hNullCredential, sizeof(CredHandle));
	if (0 == memcmp(&hNullCredential, phCredential, sizeof(CredHandle)))
	{
		return SEC_E_OK;
	}

    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->FreeCredentialHandle)) (phCredential);        
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->FreeCredentialHandle)) (phCredential);        
    }
}

SECURITY_STATUS OS_FreeContextBuffer(
    PVOID   pBuffer
    )
{
    DPF(6,"Freeing context buffer 0x%08x",pBuffer);
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->FreeContextBuffer)) (pBuffer);        
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->FreeContextBuffer)) (pBuffer);        
    }
}

SECURITY_STATUS OS_InitializeSecurityContext(
    PCredHandle     phCredential,
    PCtxtHandle     phContext,
    SEC_WCHAR       *pwszTargetName,
    ULONG           fContextReq,
    ULONG           Reserved1,
    ULONG           TargetDataRep,
    PSecBufferDesc  pInput,
    ULONG           Reserved2,
    PCtxtHandle     phNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttributes,
    PTimeStamp      ptsExpiry
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->InitializeSecurityContextA)) (
            phCredential,
            phContext,   
            NULL,        
            fContextReq, 
            0L,          
            SECURITY_NATIVE_DREP, 
            pInput,
            0L,    
            phNewContext,
            pOutput,     
            pfContextAttributes,
            ptsExpiry           
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->InitializeSecurityContext)) (
            phCredential,       
            phContext,          
            NULL,               
            fContextReq,        
            0L,                 
            SECURITY_NATIVE_DREP,
            pInput,             
            0L,                 
            phNewContext,       
            pOutput,            
            pfContextAttributes,
            ptsExpiry           
            );
    }
}


SECURITY_STATUS OS_MakeSignature(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->MakeSignature)) (
            phContext,
            fQOP,        
            pOutSecDesc,
            MessageSeqNo           
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->MakeSignature)) (
            phContext,
            fQOP,        
            pOutSecDesc,
            MessageSeqNo           
            );
    }
}


SECURITY_STATUS OS_QueryContextAttributes(
    PCtxtHandle     phContext,
    ULONG           ulAttribute,
    LPVOID          pBuffer
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->QueryContextAttributesA)) (
            phContext,
            ulAttribute,
            pBuffer
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->QueryContextAttributes)) (
            phContext,
            ulAttribute,
            pBuffer
            );
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME	"OS_QueryContextBufferSize"

HRESULT OS_QueryContextBufferSize(
    SEC_WCHAR       *pwszPackageName,
    ULONG           *pulBufferSize
    )
{
    SECURITY_STATUS status;
    HRESULT hr;

    ASSERT(pwszPackageName);
    ASSERT(pulBufferSize);

    if (gbWin95)
    {
	    LPSTR pszPackageName=NULL;
        PSecPkgInfoA pspInfoA=NULL;
        HRESULT hr;

        ASSERT(gpSSPIFuncTblA);

        // get ansi version of security package name
        hr = GetAnsiString(&pszPackageName, pwszPackageName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to get ansi version of package name");
            goto CLEANUP_EXIT_A;
        }
        // query package for info
        status = (*(gpSSPIFuncTblA->QuerySecurityPackageInfoA)) (
            pszPackageName,
            &pspInfoA
            );

        if (!SEC_SUCCESS(status))
        {
            DPF_ERRVAL("QuerySecurityPackageInfo failed: Error=0x%08x",status);
            hr = status;
            goto CLEANUP_EXIT_A;
        }
        // update the size
        if (pspInfoA)
        {
            *pulBufferSize = pspInfoA->cbMaxToken;
        }

        // success
        hr = DP_OK;

        // fall through
    CLEANUP_EXIT_A:
        // cleanup local allocations
        if (pszPackageName) DPMEM_FREE(pszPackageName);
        if (pspInfoA) OS_FreeContextBuffer(pspInfoA);
        return hr;
    }
    else
    {
        PSecPkgInfoW pspInfoW=NULL;

        ASSERT(gpSSPIFuncTbl);

        status = (*(gpSSPIFuncTbl->QuerySecurityPackageInfo)) (
            pwszPackageName,
            &pspInfoW
            );
        if (!SEC_SUCCESS(status))
        {
            DPF_ERRVAL("QuerySecurityPackageInfo failed: Error=0x%08x",status);
            hr = status;
            goto CLEANUP_EXIT_W;
        }

        if (pspInfoW)
        {
            *pulBufferSize = pspInfoW->cbMaxToken;
        }

        // success
        hr = DP_OK;

        // fall through
    CLEANUP_EXIT_W:
        // cleanup
        if (pspInfoW) OS_FreeContextBuffer(pspInfoW);
        return hr;
    }
}


#undef DPF_MODNAME
#define DPF_MODNAME	"OS_QueryContextUserName"

HRESULT OS_QueryContextUserName(
    PCtxtHandle     phContext,
    LPWSTR          *ppwszUserName
    )
{
    SECURITY_STATUS status;
   	SecPkgContext_Names contextAttribs;
    HRESULT hr;

    ASSERT(phContext);
    ASSERT(ppwszUserName);

    // query the security package
    ZeroMemory(&contextAttribs,sizeof(contextAttribs));
	status = OS_QueryContextAttributes(phContext, SECPKG_ATTR_NAMES, &contextAttribs);
	if (!SEC_SUCCESS(status))
	{
        DPF_ERRVAL("QueryContextAttributes failed: Error=0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
	}

    if (gbWin95)
    {
        // convert username to unicode and copy it into caller's buffer
        hr = GetWideStringFromAnsi(ppwszUserName, (LPSTR)contextAttribs.sUserName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to convert username to wide format");
            goto CLEANUP_EXIT;
        }
    }
    else
    {
        // copy unicode username as is into caller's buffer
        hr = GetString(ppwszUserName, contextAttribs.sUserName);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to copy username");
            goto CLEANUP_EXIT;
        }
    }

    // success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:
    OS_FreeContextBuffer(contextAttribs.sUserName);
    return hr;
}

SECURITY_STATUS OS_VerifySignature(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    )
{
    if (gbWin95)
    {
        ASSERT(gpSSPIFuncTblA);
        return (*(gpSSPIFuncTblA->VerifySignature)) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
    else
    {
        ASSERT(gpSSPIFuncTbl);
        return (*(gpSSPIFuncTbl->VerifySignature)) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
}


SECURITY_STATUS OS_SealMessage(
    PCtxtHandle         phContext,
    ULONG               fQOP,
    PSecBufferDesc      pOutSecDesc,
    ULONG               MessageSeqNo
    )
{
    if (gbWin95)
    {
        SECURITY_STATUS (*pFuncSealMessage)() = gpSSPIFuncTblA->SEALMESSAGE;

        ASSERT(gpSSPIFuncTblA);
        return (*pFuncSealMessage) (
            phContext, 
            fQOP,
            pOutSecDesc, 
            MessageSeqNo
            );
    }
    else
    {
        SECURITY_STATUS (*pFuncSealMessage)() = gpSSPIFuncTbl->SEALMESSAGE;

        ASSERT(gpSSPIFuncTbl);
        return (*pFuncSealMessage) (
            phContext, 
            fQOP,
            pOutSecDesc, 
            MessageSeqNo
            );
   }
}


SECURITY_STATUS OS_UnSealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP
    )
{
    if (gbWin95)
    {
        SECURITY_STATUS (*pFuncUnSealMessage)() = gpSSPIFuncTblA->UNSEALMESSAGE;

        ASSERT(gpSSPIFuncTblA);
        return (*pFuncUnSealMessage) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
    else
    {
        SECURITY_STATUS (*pFuncUnSealMessage)() = gpSSPIFuncTbl->UNSEALMESSAGE;

        ASSERT(gpSSPIFuncTbl);
        return (*pFuncUnSealMessage) (
            phContext, 
            pInSecDesc, 
            MessageSeqNo, 
            pfQOP
            );
    }
}


/***************************************************************************
 * CAPI
 ***************************************************************************/
extern BOOL
OS_IsCAPIInitialized(
    void
    )
{
    return (gpCAPIFuncTbl ? TRUE : FALSE);
}

BOOL
OS_GetCAPIFunctionTable(
    HMODULE hModule
    )
{
    ASSERT(hModule);
 
    // allocate memory for CAPI function table
    gpCAPIFuncTbl = DPMEM_ALLOC(sizeof(CAPIFUNCTIONTABLE));
    if (!gpCAPIFuncTbl)
    {
        DPF_ERR("Failed to create CAPI function table - out of memory");
        return FALSE;
    }

    // initialize function table
    if (gbWin95)
    {
        gpCAPIFuncTbl->CryptAcquireContextA = (PFN_CRYPTACQUIRECONTEXT_A)GetProcAddress(hModule,"CryptAcquireContextA");
        if (NULL == gpCAPIFuncTbl->CryptAcquireContextA)
        {
            DPF_ERR("Failed to get pointer to CryptAcquireContextA");
            goto ERROR_EXIT;
        }
    }
    else
    {
        gpCAPIFuncTbl->CryptAcquireContextW = (PFN_CRYPTACQUIRECONTEXT_W)GetProcAddress(hModule,"CryptAcquireContextW");
        if (NULL == gpCAPIFuncTbl->CryptAcquireContextW)
        {
            DPF_ERR("Failed to get pointer to CryptAcquireContextW");
            goto ERROR_EXIT;
        }
    }

    gpCAPIFuncTbl->CryptReleaseContext = (PFN_CRYPTRELEASECONTEXT) GetProcAddress(hModule,"CryptReleaseContext");
    if (NULL == gpCAPIFuncTbl->CryptReleaseContext)
    {
        DPF_ERR("Failed to get pointer to CryptReleaseContext");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptGenKey = (PFN_CRYPTGENKEY) GetProcAddress(hModule,"CryptGenKey");
    if (NULL == gpCAPIFuncTbl->CryptGenKey)
    {
        DPF_ERR("Failed to get pointer to CryptGenKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDestroyKey = (PFN_CRYPTDESTROYKEY) GetProcAddress(hModule,"CryptDestroyKey");
    if (NULL == gpCAPIFuncTbl->CryptDestroyKey)
    {
        DPF_ERR("Failed to get pointer to CryptDestroyKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptExportKey = (PFN_CRYPTEXPORTKEY) GetProcAddress(hModule,"CryptExportKey");
    if (NULL == gpCAPIFuncTbl->CryptExportKey)
    {
        DPF_ERR("Failed to get pointer to CryptExportKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptImportKey = (PFN_CRYPTIMPORTKEY) GetProcAddress(hModule,"CryptImportKey");
    if (NULL == gpCAPIFuncTbl->CryptImportKey)
    {
        DPF_ERR("Failed to get pointer to CryptImportKey");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptEncrypt = (PFN_CRYPTENCRYPT) GetProcAddress(hModule,"CryptEncrypt");
    if (NULL == gpCAPIFuncTbl->CryptEncrypt)
    {
        DPF_ERR("Failed to get pointer to CryptEncrypt");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDecrypt = (PFN_CRYPTDECRYPT) GetProcAddress(hModule,"CryptDecrypt");
    if (NULL == gpCAPIFuncTbl->CryptDecrypt)
    {
        DPF_ERR("Failed to get pointer to CryptDecrypt");
        goto ERROR_EXIT;
    }
    
    gpCAPIFuncTbl->CryptCreateHash = (PFN_CRYPTCREATEHASH) GetProcAddress(hModule,"CryptCreateHash");
    if (NULL == gpCAPIFuncTbl->CryptCreateHash)
    {
        DPF_ERR("Failed to get pointer to CryptCreateHash");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptDestroyHash = (PFN_CRYPTDESTROYHASH) GetProcAddress(hModule,"CryptDestroyHash");
    if (NULL == gpCAPIFuncTbl->CryptDestroyHash)
    {
        DPF_ERR("Failed to get pointer to CryptDestroyHash");
        goto ERROR_EXIT;
    }

    gpCAPIFuncTbl->CryptHashData = (PFN_CRYPTHASHDATA) GetProcAddress(hModule,"CryptHashData");
    if (NULL == gpCAPIFuncTbl->CryptHashData)
    {
        DPF_ERR("Failed to get pointer to CryptHashData");
        goto ERROR_EXIT;
    }

	if (gbWin95)
	{
		gpCAPIFuncTbl->CryptSignHashA = (PFN_CRYPTSIGNHASH_A) GetProcAddress(hModule,"CryptSignHashA");
		if (NULL == gpCAPIFuncTbl->CryptSignHashA)
		{
			DPF_ERR("Failed to get pointer to CryptSignHashA");
			goto ERROR_EXIT;
		}
	}
	else
	{
		gpCAPIFuncTbl->CryptSignHashW = (PFN_CRYPTSIGNHASH_W) GetProcAddress(hModule,"CryptSignHashW");
		if (NULL == gpCAPIFuncTbl->CryptSignHashW)
		{
			DPF_ERR("Failed to get pointer to CryptSignHashW");
			goto ERROR_EXIT;
		}
	}

	if (gbWin95)
	{
		gpCAPIFuncTbl->CryptVerifySignatureA = (PFN_CRYPTVERIFYSIGNATURE_A) GetProcAddress(hModule,"CryptVerifySignatureA");
		if (NULL == gpCAPIFuncTbl->CryptVerifySignatureA)
		{
			DPF_ERR("Failed to get pointer to CryptVerifySignatureA");
			goto ERROR_EXIT;
		}
	}
	else
	{
		gpCAPIFuncTbl->CryptVerifySignatureW = (PFN_CRYPTVERIFYSIGNATURE_W) GetProcAddress(hModule,"CryptVerifySignatureW");
		if (NULL == gpCAPIFuncTbl->CryptVerifySignatureW)
		{
			DPF_ERR("Failed to get pointer to CryptVerifySignatureW");
			goto ERROR_EXIT;
		}
	}

    // success
    return TRUE;

ERROR_EXIT:
    OS_ReleaseCAPIFunctionTable();
    return FALSE;
}

void
OS_ReleaseCAPIFunctionTable(
    void
    )
{
    if (gpCAPIFuncTbl)
    {
        DPMEM_FREE(gpCAPIFuncTbl);
        gpCAPIFuncTbl = NULL;
    }
}

BOOL 
OS_CryptAcquireContext(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvider,
    DWORD       dwProvType,
    DWORD       dwFlags,
    LPDWORD     lpdwLastError
    )
{
    BOOL fResult=0;

    ASSERT(gpCAPIFuncTbl);

	*lpdwLastError=0;

    if (gbWin95)
    {
        LPSTR pszContainer=NULL, pszProvider=NULL;
        HRESULT hr;

        if (pwszContainer)
        {
            hr = GetAnsiString(&pszContainer,pwszContainer);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi container name: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        if (pwszProvider)
        {
            hr = GetAnsiString(&pszProvider,pwszProvider);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi provider name: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        fResult = gpCAPIFuncTbl->CryptAcquireContextA(phProv,pszContainer,pszProvider,dwProvType,dwFlags);

		if(!fResult)*lpdwLastError = GetLastError();

        // fall through
    CLEANUP_EXIT:
        if (pszContainer) DPMEM_FREE(pszContainer);
        if (pszProvider) DPMEM_FREE(pszProvider);
    }
    else
    {
        fResult = gpCAPIFuncTbl->CryptAcquireContext(phProv,pwszContainer,pwszProvider,dwProvType,dwFlags);

		if(!fResult)*lpdwLastError = GetLastError();
    }

    return fResult;
}

BOOL
OS_CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    )
{
	// don't pass null handles as it might crash the following call
	if (0 == hProv)
	{
		return TRUE;
	}
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptReleaseContext(hProv,dwFlags);
}

BOOL
OS_CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptGenKey(hProv,Algid,dwFlags,phKey);
}

BOOL
OS_CryptDestroyKey(
    HCRYPTKEY hKey
    )
{
    // Passing unitialized handles (0) is causing a first chance exception in the 
    // following call. Therefore we are making the call only if the handle is non-null.
	if (0 == hKey)
	{
		return TRUE;
	}

    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDestroyKey(hKey);
}

BOOL
OS_CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptExportKey(hKey,hExpKey,dwBlobType,dwFlags,pbData,pdwDataLen);
}

BOOL
OS_CryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptImportKey(hProv,pbData,dwDataLen,hPubKey,dwFlags,phKey);
}

BOOL
OS_CryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptEncrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen,dwBufLen);
}

BOOL
OS_CryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDecrypt(hKey,hHash,Final,dwFlags,pbData,pdwDataLen);
}


BOOL 
OS_CryptCreateHash( 
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	)
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptCreateHash(hProv,Algid,hKey,dwFlags,phHash);
}

BOOL 
OS_CryptDestroyHash( 
	HCRYPTHASH hHash
	)
{
    // Passing unitialized handles (0) is causing a first chance exception in the 
    // following call. Therefore we are making the call only if the handle is non-null.
	if (0 == hHash)
	{
		return TRUE;
	}

    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptDestroyHash(hHash);
}

BOOL 
OS_CryptHashData( 
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	)
{
    ASSERT(gpCAPIFuncTbl);
    return gpCAPIFuncTbl->CryptHashData(hHash,pbData,dwDataLen,dwFlags);
}

BOOL 
OS_CryptSignHash( 
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPWSTR pwszDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	)
{
	BOOL fResult=FALSE;

    ASSERT(gpCAPIFuncTbl);

    if (gbWin95)
    {
        LPSTR pszDescription=NULL;
        HRESULT hr;

        if (pwszDescription)
        {
            hr = GetAnsiString(&pszDescription,pwszDescription);
            if (FAILED(hr))
            {
                DPF(0,"Failed to get ansi description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

		fResult = gpCAPIFuncTbl->CryptSignHashA(hHash,dwKeySpec,pszDescription,dwFlags,pbSignature,pdwSigLen);

        // fall through
    CLEANUP_EXIT:
        if (pszDescription) DPMEM_FREE(pszDescription);
    }
    else
    {
	    fResult = gpCAPIFuncTbl->CryptSignHash(hHash,dwKeySpec,pwszDescription,dwFlags,pbSignature,pdwSigLen);
    }

    return fResult;
}

BOOL 
OS_CryptVerifySignature( 
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPWSTR pwszDescription,
	DWORD dwFlags
	)
{
	BOOL fResult=FALSE;

    ASSERT(gpCAPIFuncTbl);

    if (gbWin95)
    {
        LPSTR pszDescription=NULL;
        HRESULT hr;

        if (pwszDescription)
        {
            hr = GetAnsiString(&pszDescription,pwszDescription);
            if (FAILED(hr))
            {
            	//Can't DPF here, since we don't want to step on LastError.
                //DPF(0,"Failed to get ansi description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

        fResult = gpCAPIFuncTbl->CryptVerifySignatureA(hHash,pbSignature,dwSigLen,hPubKey,pszDescription,dwFlags);

        // fall through
    CLEANUP_EXIT:
        if (pszDescription) DPMEM_FREE(pszDescription);
    }
    else
    {
        fResult = gpCAPIFuncTbl->CryptVerifySignature(hHash,pbSignature,dwSigLen,hPubKey,pwszDescription,dwFlags);
    }

	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpsecos.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecos.h
 *  Content:	DirectPlay's interface to SSPI.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through 
 *                      Windows Security Support Provider Interface (SSPI).
 *  04/14/97    sohailm Added prototypes for OS_FreeContextBuffer(), OS_QueryContextAttributes(), 
 *                      and OS_QueryContextBufferSize().
 *  05/12/97    sohailm Added prototypes for CAPI function calls.
 *  05/29/97    sohailm Added prototype for QueryContextUserName. Updated QueryContextBufferSize
 *                      prototype to return HRESULT.
 *  06/23/97    sohailm Added prototypes for CAPI message signing function calls.
 *
 ***************************************************************************/
#ifndef __DPSECOS_H__
#define __DPSECOS_H__

#include <sspi.h>

extern BOOL 
OS_IsSSPIInitialized(
    void
    );

extern BOOL 
OS_GetSSPIFunctionTable(
    HMODULE hModule
    );

extern BOOL
OS_IsCAPIInitialized(
    void
    );

extern BOOL 
OS_GetCAPIFunctionTable(
    HMODULE hModule
    );

extern void
OS_ReleaseCAPIFunctionTable(
    void
    );

/***************************************************************************
 * Security Support Provider Interface
 ***************************************************************************/

extern SECURITY_STATUS 
OS_AcceptSecurityContext(
    PCredHandle         phCredential,
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PCtxtHandle         phNewContext,
    PSecBufferDesc      pOutSecDesc,
    PULONG              pfContextAttributes,
    PTimeStamp          ptsTimeStamp
    );

extern SECURITY_STATUS 
OS_AcquireCredentialsHandle(
    SEC_WCHAR *pwszPrincipal, 
    SEC_WCHAR *pwszPackageName,
    ULONG   fCredentialUse,
    PLUID   pLogonId,
    PSEC_WINNT_AUTH_IDENTITY_W pAuthData,
    PVOID   pGetKeyFn,
    PVOID   pvGetKeyArgument,
    PCredHandle phCredential,
    PTimeStamp  ptsLifeTime
    );

extern SECURITY_STATUS 
OS_DeleteSecurityContext(
    CtxtHandle *phContext
    );

extern SECURITY_STATUS 
OS_FreeCredentialHandle(
    PCredHandle     phCredential
    );

extern SECURITY_STATUS 
OS_FreeContextBuffer(
    PVOID   pBuffer
    );

extern SECURITY_STATUS 
OS_InitializeSecurityContext(
    PCredHandle     phCredential,
    PCtxtHandle     phContext,
    SEC_WCHAR       *pwszTargetName,
    ULONG           fContextReq,
    ULONG           Reserved1,
    ULONG           TargetDataRep,
    PSecBufferDesc  pInput,
    ULONG           Reserved2,
    PCtxtHandle     phNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttributes,
    PTimeStamp      ptsExpiry
    );

extern SECURITY_STATUS 
OS_MakeSignature(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    );

extern SECURITY_STATUS 
OS_QueryContextAttributes(
    PCtxtHandle     phContext,
    ULONG           ulAttribute,
    LPVOID          pBuffer
    );

extern HRESULT
OS_QueryContextBufferSize(
    SEC_WCHAR       *pwszPackageName,
    ULONG           *pulBufferSize
    );

extern HRESULT 
OS_QueryContextUserName(
    PCtxtHandle     phContext,
    LPWSTR          *ppwszUserName
    );

extern SECURITY_STATUS 
OS_VerifySignature(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    );

extern SECURITY_STATUS 
OS_SealMessage(
    PCtxtHandle     phContext,
    ULONG           fQOP,
    PSecBufferDesc  pOutSecDesc,
    ULONG           MessageSeqNo
    );

extern SECURITY_STATUS 
OS_UnSealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pInSecDesc,
    ULONG               MessageSeqNo,
    PULONG              pfQOP 
    );


/***************************************************************************
 * Crypto Application Programming Interface
 ***************************************************************************/

typedef BOOL (WINAPI *PFN_CRYPTACQUIRECONTEXT_A)(
    HCRYPTPROV  *phProv,
    LPSTR       pszContainer,
    LPSTR       pszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTACQUIRECONTEXT_W)(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTRELEASECONTEXT)(
    HCRYPTPROV hProv,
    DWORD dwFlags);

typedef BOOL (WINAPI *PFN_CRYPTGENKEY)(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef BOOL (WINAPI *PFN_CRYPTDESTROYKEY)(
    HCRYPTKEY hKey);

typedef BOOL (WINAPI *PFN_CRYPTEXPORTKEY)(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef BOOL (WINAPI *PFN_CRYPTIMPORTKEY)(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey);

typedef BOOL (WINAPI *PFN_CRYPTENCRYPT)(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen);

typedef BOOL (WINAPI *PFN_CRYPTDECRYPT)(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen);

typedef BOOL (WINAPI *PFN_CRYPTCREATEHASH)(
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	);

typedef BOOL (WINAPI *PFN_CRYPTDESTROYHASH)(
	HCRYPTHASH hHash
	);

typedef BOOL (WINAPI *PFN_CRYPTHASHDATA)(
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	);

typedef BOOL (WINAPI *PFN_CRYPTSIGNHASH_A)(
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPCSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

typedef BOOL (WINAPI *PFN_CRYPTSIGNHASH_W)(
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPCWSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

typedef BOOL (WINAPI *PFN_CRYPTVERIFYSIGNATURE_A)(
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPCSTR sDescription,
	DWORD dwFlags
	);

typedef BOOL (WINAPI *PFN_CRYPTVERIFYSIGNATURE_W)(
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPCWSTR sDescription,
	DWORD dwFlags
	);

/*
 * CAPI Function table
 */
typedef struct _CAPIFUNCTIONTABLE{
    PFN_CRYPTACQUIRECONTEXT_A	CryptAcquireContextA;
    PFN_CRYPTACQUIRECONTEXT_W	CryptAcquireContextW;
    PFN_CRYPTRELEASECONTEXT		CryptReleaseContext;
    PFN_CRYPTGENKEY				CryptGenKey;
    PFN_CRYPTDESTROYKEY			CryptDestroyKey;
    PFN_CRYPTEXPORTKEY			CryptExportKey;
    PFN_CRYPTIMPORTKEY			CryptImportKey;
    PFN_CRYPTENCRYPT			CryptEncrypt;
    PFN_CRYPTDECRYPT			CryptDecrypt;
	PFN_CRYPTCREATEHASH			CryptCreateHash;
	PFN_CRYPTDESTROYHASH		CryptDestroyHash;
	PFN_CRYPTHASHDATA			CryptHashData;
	PFN_CRYPTSIGNHASH_A			CryptSignHashA;
	PFN_CRYPTSIGNHASH_W			CryptSignHashW;
	PFN_CRYPTVERIFYSIGNATURE_A	CryptVerifySignatureA;
	PFN_CRYPTVERIFYSIGNATURE_W	CryptVerifySignatureW;
} CAPIFUNCTIONTABLE, *LPCAPIFUNCTIONTABLE;

/*
 * Prototypes
 */
extern BOOL 
OS_CryptAcquireContext(
    HCRYPTPROV  *phProv,
    LPWSTR      pwszContainer,
    LPWSTR      pwszProvder,
    DWORD       dwProvType,
    DWORD       dwFlags,
    LPDWORD     lpdwLastError
    );

extern BOOL
OS_CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    );

extern BOOL
OS_CryptGenKey(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

extern BOOL
OS_CryptDestroyKey(
    HCRYPTKEY hKey
    );

extern BOOL
OS_CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    );

extern BOOL
OS_CryptImportKey(
    HCRYPTPROV hProv,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    HCRYPTKEY hPubKey,
    DWORD dwFlags,
    HCRYPTKEY *phKey
    );

extern BOOL
OS_CryptEncrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwBufLen
    );

extern BOOL
OS_CryptDecrypt(
    HCRYPTKEY hKey,
    HCRYPTHASH hHash,
    BOOL Final,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    );

extern BOOL 
OS_CryptCreateHash( 
	HCRYPTPROV hProv,
	ALG_ID Algid,
	HCRYPTKEY hKey,
	DWORD dwFlags,
	HCRYPTHASH * phHash
	);

extern BOOL 
OS_CryptDestroyHash( 
	HCRYPTHASH hHash
	);

extern BOOL 
OS_CryptHashData( 
	HCRYPTHASH hHash,
	BYTE * pbData,
	DWORD dwDataLen,
	DWORD dwFlags
	);

extern BOOL 
OS_CryptSignHash( 
	HCRYPTHASH hHash,
	DWORD dwKeySpec,
	LPWSTR sDescription,
	DWORD dwFlags,
	BYTE * pbSignature,
	DWORD * pdwSigLen
	);

extern BOOL 
OS_CryptVerifySignature( 
	HCRYPTHASH hHash,
	BYTE * pbSignature,
	DWORD dwSigLen,
	HCRYPTKEY hPubKey,
	LPWSTR sDescription,
	DWORD dwFlags
	);

#endif // __DPSECOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dvretro.h ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:        dvretro.h
*  Content:	 	Retrofit functions
*  History:
*
*   Date		By		Reason
*   ====		==		======
*   08/05/99	rodtoll	created it
*   08/20/99	rodtoll	Updated for new out of process retrofit
*   09/09/99	rodtoll	Added new function prototype
*
***************************************************************************/

#ifndef __DVRETRO_H
#define __DVRETRO_H

#define DVMSGID_IAMVOICEHOST	0

typedef struct _DVPROTOCOLMSG_IAMVOICEHOST
{
	BYTE	bType;
	DPID	dpidHostID;
} DVPROTOCOLMSG_IAMVOICEHOST, *LPDVPROTOCOLMSG_IAMVOICEHOST;

extern HRESULT DV_Retro_Start( LPDPLAYI_DPLAY This );
extern HRESULT DV_Retro_Stop( LPDPLAYI_DPLAY This );
extern HRESULT DV_RunHelper( LPDPLAYI_DPLAY this, DPID dpidHost, BOOL fLocalHost );
extern HRESULT DV_GetIDS( LPDPLAYI_DPLAY This, DPID *lpdpidHost, DPID *lpdpidLocalID, LPBOOL lpfLocalHost );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "dplaypr.h"
#include "windows.h"
#include "fpm.h"

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = DPMEM_ALLOC(this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			DPMEM_FREE(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	ASSERT(0);

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			DPMEM_FREE(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		DPMEM_FREE(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		ASSERT(0);
	}
	DeleteCriticalSection(&this->cs);
	DPMEM_FREE(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)DPMEM_ALLOC(sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpunk.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpunk.c
 *  Content:	IUnknown implementation for dplay
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	1/96	andyco	created it
 *	5/20	andyco	idirectplay2
 *	6/26/96	kipo	use the CALLSPVOID macro
 *	7/10/96	andyco	#2282 - addref addrefs int ref cnt, not obj ref cnt.  
 *					changed dp_close(this) to dp_close(this->pInterfaces...) DUH!
 *	7/16/96	kipo	include dplaysp.h so we declare our GUID once in dplay.dll
 *  8/9/96  sohailm free the sp when dplay goes away
 *	9/1/96	andyco	take service lock + drop dplay on sp_shutdown
 *  10/3/96 sohailm renamed GUID validation macros to use the term GUID instead of UUID
 *                  added a check for null lpGuid in QueryInterface parameter validation
 *	1/24/97	andyco	call freelibrary on the sp 
 *	3/12/97	myronth	added lobby object cleanup code
 *	3/15/97	andyco	destroy dplay b4 interface, so apps using the interface off a timer
 *					don't get hosed.
 *	5/13/97	myronth	Drop the locks before calling the lobby cleanup otherwise
 *					the dplay worker thread in the lower object can't take them
 *					and we hang.  (Bug #8414)
 *	8/19/97	myronth	Release copy of the lobby interface we were launched on
 *	10/21/97myronth	Added IDirectPlay4 and 4A interfaces to QI
 *  12/18/97 aarono Free memory pools
 *   2/18/98 aarono dispatch HandleMessage to protocol when active
 *   2/19/98 aarono don't call protocol for Shutdown, done in DP_Close now.
 *   3/16/98 aarono moved FreePacketList to Release from DP_Close
 *  8/02/99	rodtoll voice support - added Voice object to QueryInterface
 *  07/22/00 rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
 *   				 Now for a thread to make an indication into voice they addref the interface
 *					 so that the voice core can tell when all indications have returned.    
 ***************************************************************************/

#define INITGUID
#include "dplaypr.h"
#include "dplobby.h"	// Needed to get the DEFINE_GUID's to work
#include "dplaysp.h"	// Same here
#include "dpprot.h"
#include <initguid.h>
#include "..\protocol\mytimer.h"

#undef DPF_MODNAME
#define DPF_MODNAME "GetInterface"

// find an interface with the pCallbacks vtbl on this object.
// if one doesn't exist, create it
// ref count and return the interface
HRESULT GetInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT * ppInt,LPVOID pCallbacks)
{
	LPDPLAYI_DPLAY_INT pCurrentInts = this->pInterfaces;
	BOOL bFound = FALSE;

	ASSERT(ppInt);

	// see if there is already an interface
	while (pCurrentInts && !bFound)
	{
		if (pCurrentInts->lpVtbl == pCallbacks)
		{
			bFound = TRUE;
		}
		else pCurrentInts = pCurrentInts->pNextInt;
	}
	// if there is, return it
	if (bFound)
	{
		*ppInt = pCurrentInts;
		(*ppInt)->dwIntRefCnt++;
		// we don't increment this->dwRefCnt, since it's one / interface object
		return DP_OK;
	}
	// else, 
	// create one
	*ppInt = DPMEM_ALLOC(sizeof(DPLAYI_DPLAY_INT));
	if (!*ppInt) 
	{
		DPF_ERR("could not alloc interface - out of memory");
		return E_OUTOFMEMORY;
	}

	(*ppInt)->dwIntRefCnt = 1;
	(*ppInt)->lpDPlay = this;
	(*ppInt)->pNextInt = this->pInterfaces;
	(*ppInt)->lpVtbl = pCallbacks;
	this->pInterfaces = *ppInt;
	this->dwRefCnt++; // one this->dwRefCnt for each interface object...
	return DP_OK;
	
} // GetInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DP_QueryInterface"
HRESULT DPAPI DP_QueryInterface(LPDIRECTPLAY lpDP, REFIID riid, LPVOID * ppvObj) 
{
    
    LPDPLAYI_DPLAY this;
    HRESULT hr;

  	DPF(7,"Entering DP_QueryInterface");
	ENTER_DPLAY();
    
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			// we allow uninited dplays to QI
			if (hr != DPERR_UNINITIALIZED)
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
				return hr;
			}
		}

		if ( !riid || (!VALID_READ_GUID_PTR(riid)) )
		{
			LEAVE_DPLAY();
			return DPERR_INVALIDPARAMS;
		}
		
		if (!ppvObj || (!VALID_GUID_PTR(ppvObj)) )
		{
			LEAVE_DPLAY();
			DPF_ERR("invalid object pointer");
			return DPERR_INVALIDPARAMS;
		}
		*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

     *ppvObj=NULL;

	// hmmm, switch would be cleaner...        
    if( IsEqualIID(riid, &IID_IUnknown) || 
        IsEqualIID(riid, &IID_IDirectPlay) )
    {
		// get an idirectplay
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks );
    }
    else if( IsEqualIID(riid, &IID_IDirectPlay2) )
	{
		// get an idirectplay2
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks2 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay2A) )
	{
		// get an idirectplay2A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks2A );
	}
    else if( IsEqualIID(riid, &IID_IDirectPlay3) )
	{
		// get an idirectplay3
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks3 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay3A) )
	{
		// get an idirectplay3A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks3A );
	}
    else if( IsEqualIID(riid, &IID_IDirectPlay4) )
	{
		// get an idirectplay4
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks4 );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlay4A) )
	{
		// get an idirectplay4A
	    hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj, 
	    	(LPVOID)&dpCallbacks4A );
	}
	else if( IsEqualIID(riid, &IID_IDirectPlayVoiceTransport) )
	{
		hr = GetInterface( this,(LPDPLAYI_DPLAY_INT *)ppvObj,
			(LPVOID)&dvtCallbacks );
	}
	else 
	{
	    hr =  E_NOINTERFACE;		
	}
        
    LEAVE_DPLAY();
    return hr;

}//DP_QueryInterface

#undef DPF_MODNAME
#define DPF_MODNAME "DP_AddRef"
ULONG DPAPI DP_AddRef(LPDIRECTPLAY lpDP) 
{
	DWORD dwRefCnt;
    LPDPLAYI_DPLAY_INT pInt;

	DPF(7,"Entering DP_AddRef");

    ENTER_DPLAY();
    
    TRY
    {
		pInt = (LPDPLAYI_DPLAY_INT)	lpDP;
		if (!VALID_DPLAY_INT(pInt))
		{
            LEAVE_DPLAY();
            return 0;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return 0;
    }

    pInt->dwIntRefCnt++;
    dwRefCnt = pInt->dwIntRefCnt;

    LEAVE_DPLAY();
    return dwRefCnt;		

}//DP_AddRef

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Release"

// remove pInt from the list of interfaces, and the free it
HRESULT  DestroyDPlayInterface(LPDPLAYI_DPLAY this,LPDPLAYI_DPLAY_INT pInt) 
{
	LPDPLAYI_DPLAY_INT pIntPrev; // the interface preceeding pInt in the list
	BOOL bFound=FALSE;

	if (NULL == this->pInterfaces) return DP_OK;

	// remove pInt from the list of interfaces
	if (this->pInterfaces == pInt) 
	{
		// it's the 1st one, just remove it
		this->pInterfaces = pInt->pNextInt;
	}
	else 
	{
		pIntPrev = this->pInterfaces;
		while (pIntPrev && !bFound)
		{
			if (pIntPrev->pNextInt == pInt)
			{
				bFound = TRUE;
			}
			else pIntPrev = pIntPrev->pNextInt;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			return E_UNEXPECTED;
		}
		// take pint out of the list
		pIntPrev->pNextInt = pInt->pNextInt;
		
	}

	DPMEM_FREE(pInt);

	return DP_OK;
} // DestroyDPlayInterface

// take this dplay object out of the list of dplay objects (gpObjectList)
HRESULT RemoveThisFromList(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_DPLAY search,prev;
	
	ASSERT(gpObjectList); // better have at least this in list
	
	DPF(3,"removing this = 0x%08lx from object list", this);
	
	// is it the head?
	if (this == gpObjectList)
	{
		// remove from the front
		gpObjectList = gpObjectList->pNextObject;
		return DP_OK;
	}
	
	// else 
	prev = gpObjectList;
	search = gpObjectList->pNextObject;
	
	while ( (search) && (search != this))
	{
		prev = search;
		search = search->pNextObject;
	}

	if (search != this)
	{
		DPF_ERR("could not find this ptr in object list - badbadbad");
		ASSERT(FALSE);
		return E_FAIL;
	}
	
	// else
	ASSERT(prev);	
	prev->pNextObject = this->pNextObject;

	return DP_OK;
	
} // RemoveThisFromList

// free the list of session nodes attached to this pointer
HRESULT FreeSessionList(LPDPLAYI_DPLAY this)
{
	LPSESSIONLIST pNext,pCurrent;

	pCurrent = this->pSessionList;
	while (pCurrent)
	{
		//
		// pCurrent is the current node to destroy
		// pNext is the next node in the list  - get it before we destroy pCurrent...
		//
		pNext = pCurrent->pNextSession;
		// 
		// now, destroy pCurrent
		//
		// free up the sp blob stored w/ the desc
		if (pCurrent->pvSPMessageData) DPMEM_FREE(pCurrent->pvSPMessageData);
		
        FreeDesc(&(pCurrent->dpDesc), FALSE);
		// free the session node
		DPMEM_FREE(pCurrent);
		// move onto next node
		pCurrent = pNext;
	}

	this->pSessionList = NULL;

	return DP_OK;
}// FreeSessionList

// Called from Release
HRESULT DestroyDPlay(LPDPLAYI_DPLAY this)
{
	HRESULT hr=DP_OK;
    DWORD dwError;

	if (this->lpsdDesc) // session open?
	{
		DPF(9,"Closing session %x this->dwFlags %x \n",this->lpsdDesc,this->dwFlags);
	   	// leave dplay, so if sp has threads waiting to get in, they can...
		LEAVE_ALL();

		hr=DP_Close((LPDIRECTPLAY)this->pInterfaces);

		ENTER_ALL();
	} else {
		DPF(0,"Closing with no open sessions\n");
	}

	if(hr==DP_OK){

		// Shutdown extended Timers
		FiniTimerWorkaround();

		// free up the session list
		FreeSessionList(this);
		
	   	// mark dplay as closed
		this->dwFlags |= DPLAYI_DPLAY_CLOSED;

		ASSERT(1 == gnDPCSCount); // when we drop locks - this needs to go to 0!

		// free any packets we're holding
		// drops and reacquires locks, shouldn't hurt here since we drop again.
		FreePacketList(this); 

		FiniReply(this);

		LEAVE_ALL();
		
		// kill the worker thread
		if(this->hDPlayThread){
			KillThread(this->hDPlayThread,this->hDPlayThreadEvent);
			this->hDPlayThread = 0;
			this->hDPlayThreadEvent = 0;
		}	

		ENTER_SERVICE();

	    if (this->pcbSPCallbacks->ShutdownEx)  
	    {
			DPSP_SHUTDOWNDATA shutdata;		
		
			shutdata.lpISP = this->pISP;
	   		hr = CALLSP(this->pcbSPCallbacks->ShutdownEx,&shutdata);
	    }
		else if (this->pcbSPCallbacks->Shutdown) 
		{
	   		hr = CALLSPVOID( this->pcbSPCallbacks->Shutdown );
		}
		else 
		{
			// shutdown is optional
			hr = DP_OK;
		}
	    
		ENTER_DPLAY();
		
		if (FAILED(hr)) 
		{
			DPF_ERR("could not invoke shutdown");
		}

		if (this->dwFlags & DPLAYI_DPLAY_DX3SP)	
		{
			// if there's one loaded, this must be it -
			// since we're destroying the dx3 sp - reset our global flag
			gbDX3SP = FALSE;
		}
		
		// free the sp Data
		if (this->pvSPLocalData)	
		{
			DPMEM_FREE(this->pvSPLocalData);
			this->pvSPLocalData = NULL;
			this->dwSPLocalDataSize = 0;
		}

		// Free memory pools
		FreeMemoryPools(this);

		// free all interfaces
		while (this->pInterfaces)
		{
			hr = DestroyDPlayInterface(this,this->pInterfaces);	
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay interface! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
				// keep trying...
			}
		}

		ASSERT(NULL == this->pInterfaces);

		// callbacks should be set in directplaycreate
		ASSERT(this->pcbSPCallbacks);
		DPMEM_FREE(this->pcbSPCallbacks);

	    // unload sp module
	    if (this->hSPModule)
	    {
	        if (!FreeLibrary(this->hSPModule))
	        {
	            ASSERT(FALSE);
				dwError = GetLastError();
				DPF_ERR("could not free sp module");
				DPF(0, "dwError = %d", dwError);
	        }
	    }
		
		if (this->pbAsyncEnumBuffer) DPMEM_FREE(this->pbAsyncEnumBuffer);
		// remove this from the dll object list
		RemoveThisFromList(this);
		gnObjects--;
		
		// just to be safe
		this->dwSize = 0xdeadbeef;

		// Drop the locks so that the lower dplay object in dpldplay can
		// get back in.  If we don't drop these, the worker thread in
		// dplay will hang trying to get these when it goes to shutdown
		LEAVE_ALL();
		
		// If we were lobby launched, release the interface we used to
		// communicate with the lobby server
		if(this->lpLaunchingLobbyObject)
		{
			IDirectPlayLobby_Release(this->lpLaunchingLobbyObject);
			this->lpLaunchingLobbyObject = NULL;	// just to be safe
		}

		// destroy the lobby object
		PRV_FreeAllLobbyObjects(this->lpLobbyObject);
		this->lpLobbyObject = NULL;		// just to be safe

		DeleteCriticalSection( &this->csNotify );			

		// Take the locks back
		ENTER_ALL();	
		
		DPMEM_FREE(this);	
		return DP_OK;
	}	else {
		DPF(0,"Someone called close after last release?\n");
		ASSERT(0);
		return DP_OK; // don't rock the boat.
	}
} // DestroyDPlay

ULONG DPAPI DP_Release(LPDIRECTPLAY lpDP)
{
    LPDPLAYI_DPLAY this;
    LPDPLAYI_DPLAY_INT pInt;
    HRESULT hr=DP_OK;
	DWORD dwReleaseCnt=1;	// if we've been init'ed, we release at 1, otherwise we 
							// release at 0, unless it is a lobby-owned object in
							// which case we still release at 1
	ULONG rc;
								
	DPF(7,"Entering DP_Release");
	
	ENTER_ALL();    
	
    TRY
    {
		pInt = (LPDPLAYI_DPLAY_INT)	lpDP;
		if (!VALID_DPLAY_INT(pInt))
		{
			LEAVE_ALL();
            return 0;
		}
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			// we allow uninited dplays to release
			if (hr != DPERR_UNINITIALIZED)
			{
				LEAVE_ALL();
				DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
				return 0;
			}
			else 
			{
				// we were unitialized - no IDirectPlaySP to account for
				dwReleaseCnt = 0; 
			}
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return 0;
    }

	// dec the interface count
	rc=--pInt->dwIntRefCnt;
	if (0 == rc)
	{
		// since we've destroyed an interface, dec the object count
	    this->dwRefCnt--;
		
	    if (dwReleaseCnt == this->dwRefCnt) // destroy @ ref = 1, 1 for IDirectPlaySP
	    {
			// nuke the dplay object
			if (1 == dwReleaseCnt) DPF(1,"direct play object - ref cnt = 1 (1 for IDirectPlaySP)!");
			else DPF(1,"direct play object - ref cnt = 0 (SP not initialized)!");
			
			hr = DestroyDPlay(this);
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
			}
	    } // 0 == this->dwRefCnt
		else
		{
			// if we destroyed dplay, it nuked all interfaces for us
			// otherwise, we do it here
			DPF(1,"destroying interface - int ref cnt = 0");
			// take interface out of the table
			hr = DestroyDPlayInterface(this,pInt);
			if (FAILED(hr)) 
			{
				DPF(0,"could not destroy dplay interface! hr = 0x%08lx\n",hr);
				ASSERT(FALSE);
				// keep trying...
			}

			// Destroy critical section for protecting voice interfaces
		}
		
		LEAVE_ALL();
		return 0;

	} //0 == pInt->dwIntRefCnt 
	   	
	LEAVE_ALL();
    return rc;
	
}//DP_Release
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpsecure.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecure.c
 *  Content:	implements directplay security routines.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Added client-server security to directplay
 *  03/19/97    sohailm Wait for challenge to be processed before unblocking receive thread
 *  03/30/97    sohailm Send dwReserved1 field from session desc in enumsessions reply
 *  04/09/97    sohailm Return DPERR_CANTLOADSECURITYPACKAGE when package not found.
 *  04/23/97    sohailm Added support to query buffer sizes from the security package (.
 *                      Updated SignAndSendDPMessage() and VerifyMessage() to support
 *                      encryption in addition to signing. Now Addforward and SetSessionDesc 
 *                      messages are being encrypted for privacy.
 *  05/12/97    sohailm Added support to provide message privacy through Crypto API. 
 *                      Encryption code can be contionally compiled to use SSPI or CAPI.
 *  05/18/97    sohailm SecureSendDPMessage() was not getting the correct security context
 *                      if destination player was a user player.
 *  05/21/97    sohailm Now we toggle the flags DPSEND_SIGNED and DPSEND_ENCRYPTED off in
 *                      SecureSendDPMessage().
 *  05/22/97    sohailm Now we use a dplay key container with CAPI. Using the default key 
 *                      container was failing when the user wasn't logged on. 
 *  05/29/97    sohailm Now we don't include null char in size of credential strings.
 *                      ISC_REQ_SUPPLIED_CREDS flag is now obsolete - removed it
 *                      (thanks to NTLM).
 *  06/09/97    sohailm Added better error handling for SSPI and CAPI provider initialization.
 *  06/16/97    sohailm Now we return server authentication errors to the client.
 *                      Mapped SEC_E_UNKNOWN_CREDENTIALS sspi error to DPERR_LOGONDENIED on
 *                       the client because DPA returns this when passed blank credentials.
 *  06/22/97    sohailm Since QuerySecurityPackageInfo() is not supported on all platforms 
 *                      (NTLM,Win'95 Gold) added a work around to get this info from the context.
 *                      We were not keeping track of separate encryption/decryption keys for each client.                      
 *  06/23/97    sohailm Added support for signing messages using CAPI.
 *  06/24/97    sohailm Code cleanup to prevent leaks etc.
 *  06/26/97    sohailm Don't modify the original message by encrypting in place. Make a local copy.
 *  06/27/97    sohailm Only sign the data portion of a signed message (bug:10373)
 *	12/29/97	myronth	TRUE != DPSEND_GUARANTEED (#15887)
 *  7/9/99      aarono  Cleaning up GetLastError misuse, must call right away,
 *                      before calling anything else, including DPF.
 *
 ***************************************************************************/
#include "dplaypr.h"
#include "dpos.h"
#include "dpsecure.h"

// Encryption/Decryption is done using symmetric keys or session keys, meaning
// the same key will be used for both encryption and decryption. Encryption support
// is provided using SSPI or CAPI depending on the SSPI_ENCRYPTION flag. CAPI is default.

// The process of exchanging session keys is as follows:
// 1. Server and Client each generate a public/private key pair. 
// 2. They exchange their pubic keys (through digitally signed messages).
// 3. Server and Client each generate a session key.
// 4. Each encrypts the session key with the receivers public key
// 5. They exchange the encrypted session keys.
// 6. Receiver will import the encrypted session key blobs into the CSP
//    thus completing the exchange.

// Implementation
//
// Client and Server generate public/private key pair in LoadServiceProvider() 
// Client generates session (encryption) key in SendKeysToServer()
// Server generates session (encryption) key in SendKeyExchangeReply()
// Server sends its public key to the client in the DPSP_MSG_ACCESSGRANTED message (signed)
// Client encrypts its session key using the server's public key and sends
//  it to the server along with the clients public key in DPSP_MSG_KEYEXCHANGE (signed).
// Server encrypts its session key using the client's public key and sends 
//  it to the client in DPSP_MSG_KEYEXCHANGEREPLY (signed).
// Exchange is done - now the server and client can send each other private messages.


//
// Globals
//
LPBYTE                  gpReceiveBuffer;
DWORD                   gdwReceiveBufferSize;

#undef DPF_MODNAME
#define DPF_MODNAME	"InitSecurity"
//+----------------------------------------------------------------------------
//
//  Function:   InitSecurity
//
//  Description: This function initializes CAPI and SSPI.
//
//  Arguments:  this - dplay object
//
//  Returns:    DP_OK, DPERR_CANTLOADCAPI, DPERR_CANTLOADSSPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitSecurity(
    LPDPLAYI_DPLAY this
    )
{
    HRESULT hr;

    // check if we already initialized CAPI
    if (!OS_IsCAPIInitialized()) 
    {
        hr = InitCAPI();
        if (FAILED(hr))
        {
            DPF_ERRVAL("CAPI initialization failed: hr=0x%08x",hr);
            return hr;
        }
    }

    // check if we already initialized SSPI
    if (!OS_IsSSPIInitialized()) 
    {
        hr = InitSSPI();
        if (FAILED(hr))
        {
            DPF_ERRVAL("SSPI initialization failed: hr=0x%08x",hr);
            return hr;
        }
    }

    // success
    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"InitCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   InitCAPI
//
//  Description: This function initializes CAPI and gets a pointer to the function 
//               table
//
//  Arguments:  none
//
//  Returns:    DP_OK, DPERR_CANTLOADCAPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitCAPI(
    void
    )
{
    HRESULT hr;

    //
    // Load CAPI DLL. We unload it only when dplay goes away.
    //
    ghCAPI = OS_LoadLibrary(CAPI_DLL);
    if (!ghCAPI)
    {
        DPF_ERRVAL("Can't load CAPI: Error=0x%08x",GetLastError());
        return DPERR_CANTLOADCAPI;
    }

    //
    // Get the Cryptographic Application Programming Interface
    //
    if (!OS_GetCAPIFunctionTable(ghCAPI))
    {
        DPF_ERR("Can't get the CAPI function table");
        hr = DPERR_CANTLOADCAPI;
        goto ERROR_EXIT;
    }

    // Success
    return DP_OK;

ERROR_EXIT:
    if (ghCAPI)
    {
        FreeLibrary(ghCAPI);
        ghCAPI = NULL;
    }
    return hr;

} // InitCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"InitSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   InitSSPI
//
//  Description: This function initializes SSPI and gets a pointer to the function 
//               table
//
//  Arguments:  none
//
//  Returns:    DP_OK, DPERR_CANTLOADSSPI
//
//-----------------------------------------------------------------------------
HRESULT 
InitSSPI(
    void
    )
{
    HRESULT hr;

    //
    // Load SSPI DLL. We unload it only when dplay goes away.
    //
    if (gbWin95)
    {
        ghSSPI = OS_LoadLibrary (SSP_WIN95_DLL);
    }
    else
    {
        ghSSPI = OS_LoadLibrary (SSP_NT_DLL);
    }
    if (!ghSSPI)
    {
        DPF_ERRVAL("Cannot load SSPI: Error=0x%08x", GetLastError());
        return DPERR_CANTLOADSSPI;
    }

    //
    // Get the Security Service Provider Interface
    //
    if (!OS_GetSSPIFunctionTable(ghSSPI))
    {
        DPF_ERR("Can't get the SSPI function table");
        hr = DPERR_CANTLOADSSPI;
        goto ERROR_EXIT;
    }

    //
    // Initialize seed for random numbers used during encryption
    //
    srand(GetTickCount());

    // Success
    return DP_OK;

ERROR_EXIT:
    if (ghSSPI)
    {
        FreeLibrary(ghSSPI);
        ghSSPI = NULL;
    }
    return hr;

} // InitSSPI


#undef DPF_MODNAME
#define DPF_MODNAME	"LoadSecurityProviders"

//+----------------------------------------------------------------------------
//
//  Function:   LoadSecurityProviders
//
//  Description: This function loads the specified security providers (SSPI and CAPI) and
//               initializes the credentials handle and the necessary keys.
//
//  Arguments:  this - dplay object
//              dwFlags - server or client
//
//  Returns:    DP_OK, DPERR_UNSUPPORTED, DPERR_INVALIDPARAMS, DPERR_CANTLOADSECURITYPACKAGE, or
//              DPERR_OUTOFMEMORY, DPERR_GENERIC.
//
//-----------------------------------------------------------------------------
HRESULT 
LoadSecurityProviders(
    LPDPLAYI_DPLAY this,
    DWORD dwFlags
    )
{
    TimeStamp tsLifeTime;
    PSEC_WINNT_AUTH_IDENTITY_W pAuthData = NULL;
    SEC_WINNT_AUTH_IDENTITY_W AuthData;
    SECURITY_STATUS SecStatus;
    ULONG ulCredType;
    PCredHandle phCredential=NULL;
    HCRYPTPROV hCSP=0;
    HCRYPTKEY hEncryptionKey=0;
    HCRYPTKEY hPublicKey=0;
    LPBYTE pPublicKeyBuffer=NULL;
    DWORD dwPublicKeyBufferSize = 0;
    HRESULT hr;
	BOOL fResult;
    DWORD dwError;
    ULONG ulMaxContextBufferSize=0;

    // lpszSSPIProvider is always initialized
    // lpszCAPIProvider could be NULL in which case CAPI will load Microsoft's RSA Base Provider
    ASSERT(this->pSecurityDesc->lpszSSPIProvider);
    // we shouldn't have a credential handle yet
    ASSERT(!(this->phCredential));

    //
    // SSPI
    //

    ZeroMemory(&AuthData,sizeof(AuthData));
    if (this->pUserCredentials)
    {
        // build a SEC_WINNT_AUTH_IDENTITY structure to pass credentials to 
        // SSPI package - this prevents the package from popping the login dialog

        // ************************************************************************
        // However, this data is package dependent. Passing credentials in this 
        // format will only work for packages that support the SEC_WINNT_AUTH_IDENTITY 
        // format for credentials.
        // ************************************************************************

        // note - do not include null character in the size of the strings
        if (this->pUserCredentials->lpszUsername)
        {
            AuthData.User = this->pUserCredentials->lpszUsername;
            AuthData.UserLength = WSTRLEN(AuthData.User)-1;
        }
        if (this->pUserCredentials->lpszPassword)
        {
            AuthData.Password = this->pUserCredentials->lpszPassword;
            AuthData.PasswordLength = WSTRLEN(AuthData.Password)-1;
        }
        if (this->pUserCredentials->lpszDomain)
        {
            AuthData.Domain = this->pUserCredentials->lpszDomain;
            AuthData.DomainLength = WSTRLEN(AuthData.Domain)-1;
        }

        AuthData.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        pAuthData = &AuthData;
    }

    // allocate memory for the credential handle
    phCredential = DPMEM_ALLOC(sizeof(CredHandle));
    if (!phCredential)
    {
        DPF_ERR("Failed to allocate memory for credentials handle");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Select the appropriate credentials type
    //
    if (SSPI_SERVER == dwFlags)
    {
        DPF(9, "Setting server credentials");

        ulCredType = SECPKG_CRED_INBOUND;
    }
    else
    {
        DPF(9, "Setting client credentials");

        ulCredType = SECPKG_CRED_OUTBOUND;
    }

	// Calling acquire credentials loads the SSPI provider
    SecStatus = OS_AcquireCredentialsHandle(
        NULL, 
        this->pSecurityDesc->lpszSSPIProvider,
        ulCredType,
        NULL,
        pAuthData,
        NULL,
        NULL,
        phCredential,
        &tsLifeTime);
    if (!SEC_SUCCESS(SecStatus))
    {
        switch (SecStatus) {

        case SEC_E_SECPKG_NOT_FOUND:
            DPF_ERRVAL("SSPI provider %ls was not found\n",this->pSecurityDesc->lpszSSPIProvider);
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            break;

        case SEC_E_UNSUPPORTED_FUNCTION:
            DPF_ERR("This operation is not supported");
            hr = DPERR_UNSUPPORTED;
            break;

        case SEC_E_INVALID_TOKEN:
            DPF_ERRVAL("Credentials were passed in invalid format - check the format for %ls",\
                this->pSecurityDesc->lpszSSPIProvider);
            hr = DPERR_INVALIDPARAMS;
            break;
            
        case SEC_E_UNKNOWN_CREDENTIALS:
            DPF_ERR("SSPI Provider returned unknown credentials error - mapping to logon denied");
            hr = DPERR_LOGONDENIED;
            break;

        default:
            DPF(0,"Acquire Credential handle failed [0x%x]\n", SecStatus);
            hr = SecStatus;
        }

        goto CLEANUP_EXIT;
    }

    // get the max buffer size used for opaque buffers during authentication
    hr = GetMaxContextBufferSize(this->pSecurityDesc, &ulMaxContextBufferSize);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to get context buffer size: hr=0x%08x",hr);
        goto CLEANUP_EXIT;
    }

    //
	// CAPI
    //

    // delete any existing key containers 
    fResult = OS_CryptAcquireContext(
        &hCSP,                                  // handle to CSP
        DPLAY_KEY_CONTAINER,                    // key container name
        this->pSecurityDesc->lpszCAPIProvider,  // specifies which CSP to use
        this->pSecurityDesc->dwCAPIProviderType,// provider type (PROV_RSA_FULL, PROV_FORTEZZA)
        CRYPT_DELETEKEYSET,                     // delete any existing key container
        &dwError
        );

    if (!fResult)
    {

        switch (dwError) {

        case NTE_BAD_KEYSET_PARAM:
            DPF_ERRVAL("The CAPI provider name [%ls] is invalid",this->pSecurityDesc->lpszCAPIProvider);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_BAD_PROV_TYPE:
            DPF_ERRVAL("The CAPI provider type [%d] is invalid", this->pSecurityDesc->dwCAPIProviderType);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROV_TYPE_NOT_DEF:
            DPF_ERRVAL("No registry entry exists for the CAPI provider type %d", \
                this->pSecurityDesc->dwCAPIProviderType);
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case ERROR_INVALID_PARAMETER:
            DPF_ERR("Invalid provider passed to the Crypto provider");
            hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROV_DLL_NOT_FOUND:
            DPF_ERR("The CAPI provider DLL doesn't exist or is not in the current path");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        case NTE_PROVIDER_DLL_FAIL:
            DPF_ERR("The CAPI provider DLL file could not be loaded, and may not exist \
                If it exists, then the file is not a valid DLL");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        case NTE_BAD_SIGNATURE:
            DPF_ERR("Warning!!! - CAPI provider DLL signature could not be verified. Either the DLL \
                or the signature has been tampered with");
            hr = DPERR_CANTLOADSECURITYPACKAGE;
            goto CLEANUP_EXIT;
            break;

        default:
            DPF(6,"Failed to delete key container: Error=0x%08x (ok)", dwError);
            // it's ok if we can't delete the container - don't fail yet
        }
    }


    // create a new key container 
    fResult = OS_CryptAcquireContext(
        &hCSP,       							// handle to CSP
        DPLAY_KEY_CONTAINER,                    // key container name
        this->pSecurityDesc->lpszCAPIProvider,  // specifies which CSP to use
        this->pSecurityDesc->dwCAPIProviderType,// provider type (PROV_RSA_FULL, PROV_FORTEZZA)
        CRYPT_NEWKEYSET,							// create a new key container
        &dwError
        );
    if (!fResult)
    {
        DPF_ERRVAL("Failed to create a key container: Error=0x%08x",dwError);
        hr = DPERR_CANTLOADSECURITYPACKAGE;
        goto CLEANUP_EXIT;
    }

	// create a public/private key pair
	hr = GetPublicKey(hCSP, &hPublicKey, &pPublicKeyBuffer, &dwPublicKeyBufferSize);
	if (FAILED(hr))
	{
        DPF_ERRVAL("Failed to create public/private key pair: hr=0x%08x", hr);
        goto CLEANUP_EXIT;
	}
	
    // success 

    // now remember everything in the dplay object
    this->phCredential = phCredential;
    this->ulMaxContextBufferSize = ulMaxContextBufferSize;
    this->hCSP = hCSP;
    this->hEncryptionKey = hEncryptionKey;
    this->hPublicKey = hPublicKey;
    this->pPublicKey = pPublicKeyBuffer;
    this->dwPublicKeySize = dwPublicKeyBufferSize;

    // mark that dplay is providing security
    this->dwFlags |= DPLAYI_DPLAY_SECURITY;
	this->dwFlags |= DPLAYI_DPLAY_ENCRYPTION;

    return DP_OK;

	// not a fall through

CLEANUP_EXIT:

	OS_CryptDestroyKey(hEncryptionKey);
	OS_CryptDestroyKey(hPublicKey);
    OS_CryptReleaseContext(hCSP,0);
    if (phCredential) 
	{
		OS_FreeCredentialHandle(phCredential);
		DPMEM_FREE(phCredential);
	}

    if (pPublicKeyBuffer) DPMEM_FREE(pPublicKeyBuffer);
    return hr;

} // LoadSecurityProviders


#undef DPF_MODNAME
#define DPF_MODNAME	"GenerateAuthenticationMessage"

//+----------------------------------------------------------------------------
//
//  Function:   GenerateAuthenticateMessage
//
//  Description:   This function calls InitializeSecurityContext to generate 
//              an authentication message and sends it to the server.  
//              It generates different authentication messages depending on 
//              whether there's security token from the server to be used 
//              as input message or not (i.e. whether pInMsg is NULL).
//
//  Arguments:  this - pointer to dplay object
//              pInMsg - pointer to the server's authentication message '
//                       containing the security token.
//              fContextReq - security context flags
//
//  Returns:    DP_OK, DPERR_OUTOFMEMORY, DPERR_AUTHENTICATIONFAILED, DPERR_LOGONDENIED
//
//-----------------------------------------------------------------------------
HRESULT
GenerateAuthenticationMessage (
    LPDPLAYI_DPLAY          this,
    LPMSG_AUTHENTICATION    pInMsg,
    ULONG                   fContextReq
    )
{
    PCtxtHandle phCurrContext;
    DWORD dwOutMsgType, dwHeaderSize;
    SECURITY_STATUS status;
    SecBufferDesc inSecDesc, outSecDesc;
    SecBuffer     inSecBuffer, outSecBuffer;
    PSecBufferDesc pInSecDesc;
    ULONG     fContextAttrib;
    TimeStamp tsExpireTime;
    DWORD dwMessageSize;
    LPBYTE pSendBuffer=NULL;
    LPMSG_AUTHENTICATION pOutMsg=NULL;
    HRESULT hr;

    ASSERT(this->pSysPlayer);
    ASSERT(this->phCredential);

    if (pInMsg == NULL)
    {
        DPF(6, "Generating a negotiate message");
        //
        // This is the first time this function has been called, so the
        // message generated will be a MSG_NEGOTIATE.
        //
        phCurrContext = NULL;
        dwOutMsgType = DPSP_MSG_NEGOTIATE;
        pInSecDesc = NULL;

        // do we already have a security context ?
        if (this->phContext)
        {
            // get rid of it - we are re-negotiating
            DPF(5, "Removing existing security context");

            OS_DeleteSecurityContext(this->phContext);
            DPMEM_FREE(this->phContext);
            this->phContext = NULL;
        }

        //
        // Allocate memory to hold client's security context handle
        //
        this->phContext = DPMEM_ALLOC(sizeof(CtxtHandle));
        if (!this->phContext)
        {
            DPF_ERR("Failed to allocate security context handle - out of memory");
            return DPERR_OUTOFMEMORY;
        }
		DPF(6,"System player phContext=0x%08x", this->phContext);
    }
    else
    {
		DPF(6,"Using phContext=0x%08x for authentication",this->phContext);
        phCurrContext = this->phContext;
        dwOutMsgType = DPSP_MSG_CHALLENGERESPONSE;

        //
        // Setup API's input security buffer to pass the client's negotiate
        // message to the SSPI.
        //
        inSecDesc.ulVersion = SECBUFFER_VERSION;
        inSecDesc.cBuffers = 1;
        inSecDesc.pBuffers = &inSecBuffer;

        inSecBuffer.cbBuffer = pInMsg->dwDataSize;
        inSecBuffer.BufferType = SECBUFFER_TOKEN;
        inSecBuffer.pvBuffer = (LPBYTE)pInMsg + pInMsg->dwDataOffset;

        pInSecDesc = &inSecDesc;
    }

    dwHeaderSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION);

    //
    // Allocate memory for send buffer. 
    //
    pSendBuffer = DPMEM_ALLOC( dwHeaderSize + this->ulMaxContextBufferSize);

    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate authenticate message - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Setup API's output security buffer for receiving challenge message
    // from the SSPI.
    // Pass the client message buffer to SSPI via pvBuffer.
    //

    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.cbBuffer = this->ulMaxContextBufferSize;
    outSecBuffer.BufferType = SECBUFFER_TOKEN;
    outSecBuffer.pvBuffer = pSendBuffer + dwHeaderSize;

    // determine the security context requirements
    fContextReq |= DPLAY_SECURITY_CONTEXT_REQ;

    //
    //  If user credential has been supplied, and if 'prompt user' flag has not 
    //  been set, SSPI will use the supplied credential
    //
    if (this->pUserCredentials)
    {
		DPF(6, "Using supplied credentials");
    }

    ASSERT(this->phContext);

    //
    // Generate a negotiate/challenge response message to be sent to the server.
    //    
    status = OS_InitializeSecurityContext(
        this->phCredential,                     // phCredential
        phCurrContext,                          // phContext
        NULL,                                   // pszTargetName
        fContextReq,                            // fContextReq
        0L,                                     // reserved1
        SECURITY_NATIVE_DREP,                   // TargetDataRep
        pInSecDesc,                             // pInput
        0L,                                     // reserved2
        this->phContext,                        // phNewContext
        &outSecDesc,                            // pOutput negotiate msg
        &fContextAttrib,                        // pfContextAttribute
        &tsExpireTime                           // ptsLifeTime
        );

    if (!SEC_SUCCESS(status))
    {
        //
        // Failure
        //
        if (SEC_E_NO_CREDENTIALS == status)           
        {
            //
            // If SSPI does not have user credentials, let the app collect them and try again
            // Note that we never allow the package to collect credentials. This is because of
            // two reasons:
            // 1. Apps don't like windows' dialogs popping up while they are page
            //    flipping.
            // 2. Not all security packages collect credentials (NTLM for one).
            //
            DPF(6, "No credentials specified. Ask user.");
            hr = DPERR_LOGONDENIED;
            goto CLEANUP_EXIT;
        }
        else
        {
            DPF(0,"Authentication message generation failed [0x%08x]\n", status);
            hr = status;
            goto CLEANUP_EXIT;
        }
    }
    else
    {
        //
        // Success
        //
        if ((SEC_I_CONTINUE_NEEDED != status) &&
            (SEC_E_OK != status)) 
        {
            DPF_ERRVAL("SSPI provider requested unsupported functionality [0x%08x]",status);
            ASSERT(FALSE);
            hr = status;
            goto CLEANUP_EXIT;
        }

        // fall through will send the message
    }

    //
    // Setup pointer to the security message portion of the buffer
    //
    pOutMsg = (LPMSG_AUTHENTICATION)(pSendBuffer + this->dwSPHeaderSize);

    //
    // Setup directplay system message header 
    //
	SET_MESSAGE_HDR(pOutMsg);
    SET_MESSAGE_COMMAND(pOutMsg, dwOutMsgType);
    pOutMsg->dwIDFrom = this->pSysPlayer->dwID;
    pOutMsg->dwDataSize = outSecBuffer.cbBuffer;
    pOutMsg->dwDataOffset = sizeof(MSG_AUTHENTICATION);

    //
    // Calculate actual message size to be sent
    //
    dwMessageSize = dwHeaderSize + outSecBuffer.cbBuffer;
    
    DPF(9,"Sending type = %d, length = %d\n", dwOutMsgType, dwMessageSize);

    //
    // Send message to the server
    //
    hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
    					dwMessageSize,DPSEND_GUARANTEED,FALSE);
	if (FAILED(hr))
    {
        DPF(0,"Send Msg (type:%d) Failed: ret = %8x\n", dwOutMsgType, hr);
        goto CLEANUP_EXIT;
    }

    // Success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:

	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
    return hr;

}   // GenerateAuthenticationMessage


#undef DPF_MODNAME
#define DPF_MODNAME "SendAuthenticationResponse"

HRESULT SetupLogonDeniedMsg(LPDPLAYI_DPLAY this, LPMSG_AUTHENTICATION pMsg, LPDWORD pdwMsgSize, DPID dpidClient)
{
    HRESULT hr;

    ASSERT(pMsg);
    ASSERT(pdwMsgSize);

    SET_MESSAGE_COMMAND(pMsg, DPSP_MSG_LOGONDENIED);
    *pdwMsgSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
    //
    // We don't need the client information anymore, get rid of it.
    //
    hr = RemoveClientFromNameTable(this, dpidClient);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove security context for player %d", dpidClient);
    }

    return hr;
}

HRESULT SetupAuthErrorMsg(LPDPLAYI_DPLAY this, LPMSG_AUTHENTICATION pMsg, HRESULT hResult, LPDWORD pdwMsgSize, DPID dpidClient)
{
    HRESULT hr;
    LPMSG_AUTHERROR pAuthError = (LPMSG_AUTHERROR)pMsg;

    ASSERT(pMsg);
    ASSERT(pdwMsgSize);

    //
    // setup an authentication error message
    //
    SET_MESSAGE_COMMAND(pAuthError, DPSP_MSG_AUTHERROR);
    pAuthError->hResult = hResult;
    *pdwMsgSize = GET_MESSAGE_SIZE(this,MSG_AUTHERROR);
    //
    // We don't need the client information anymore, get rid of it.
    //
    hr = RemoveClientFromNameTable(this, dpidClient);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove security context for player %d", dpidClient);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SendAuthenticationResponse
//
//  Description:   This function generates and sends an authentication response 
//              to the client.  It will generate and send either a challenge 
//              or the final authentication result to client depending on 
//              the type of client message (pointed to by pInMsg) passed 
//              to this function.
//
//  Arguments:  this - pointer to dplay object
//              pInMsg - Points to the authentication message received from
//                       the server
//              pvSPHeader - pointer to reply sp header
//
//  Returns:    DPERR_OUTOFMEMORY or result form DoReply
//
//-----------------------------------------------------------------------------
HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    LPVOID pvSPHeader
    )
{
    PCtxtHandle    phInContext=NULL, phOutContext=NULL;
    LPBYTE pSendBuffer=NULL;
    LPMSG_AUTHENTICATION pOutMsg;
    SecBufferDesc inSecDesc, outSecDesc;
    SecBuffer     inSecBuffer, outSecBuffer;
    ULONG         fContextReq;
    ULONG         fAttribute;
    TimeStamp     tsExpireTime;
    SECURITY_STATUS status;
    DWORD dwHeaderSize=0, dwMessageSize=0, dwCommand, dwBufferSize;
    HRESULT hr;
    LPCLIENTINFO pClientInfo=NULL;
    DWORD_PTR dwItem;

    ASSERT(this->pSysPlayer);
    ASSERT(this->phCredential);
    ASSERT(pInMsg);

    // retrieve client info stored in nametable
    dwItem = NameFromID(this, pInMsg->dwIDFrom);
    pClientInfo = (LPCLIENTINFO) DataFromID(this, pInMsg->dwIDFrom);

    //
    // Which message did we get 
    //
    dwCommand = GET_MESSAGE_COMMAND(pInMsg);
    
    if (DPSP_MSG_NEGOTIATE == dwCommand)
    {
		DPF(6, "Received a negotiate message from player %d", pInMsg->dwIDFrom);

        phInContext = NULL;

        if (NAMETABLE_PENDING == dwItem)
		{
            if (pClientInfo)
            {
                // client has sent us another negotiate message instead of responding to our 
                // challenge. This can happen if communication link breaks down after the server 
                // responds to a negotiate.
			    DPF(6,"Removing existing information about client");

			    hr = RemoveClientInfo(pClientInfo);
                DPMEM_FREE(pClientInfo);
            }
		}
        else
        {
            // it's a duplicate id, we shouldn't be in this state
            DPF_ERRVAL("Player %d already exists in the nametable", pInMsg->dwIDFrom);
            ASSERT(FALSE);
            // don't respond for now 
            return DPERR_INVALIDPLAYER;
            // todo - we might want to send an error message.
        }

        //
        // Allocate memory to hold client information
        //
        pClientInfo = DPMEM_ALLOC(sizeof(CLIENTINFO));
        if (!pClientInfo)
        {
            DPF_ERR("Failed to allocate memory for client information - out of memory");
            return DPERR_OUTOFMEMORY;
        }
        //
        // Remember the pointer in the nametable temporarily
        //
        hr = SetClientInfo(this, pClientInfo, pInMsg->dwIDFrom);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to add client info to nametable for player %d", pInMsg->dwIDFrom);
            RemoveClientInfo(pClientInfo);
            DPMEM_FREE(pClientInfo);
            return hr;
        }

        phOutContext = &(pClientInfo->hContext);
    }
    else
    {
		DPF(6, "Received a challenge response from player %d", pInMsg->dwIDFrom);

        ASSERT(NAMETABLE_PENDING == dwItem);
        ASSERT(pClientInfo);

        //
        // Get the player context from name table
        //
        phInContext = phOutContext = &(pClientInfo->hContext);
    }

    DPF(6, "Using phInContext=0x%08x and phOutContext=0x%08x", phInContext, phOutContext);
    // 
    // Calculate buffer size needed for response. We are always allocating enough room 
    // for an authentication message. We use the same buffer to send access granted,
    // denied, or error system messages.
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION) + this->ulMaxContextBufferSize;

    //
    // Allocate memory for the buffer.
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for response - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    //
    // Setup pointer to the message portion of the buffer
    //
    pOutMsg = (LPMSG_AUTHENTICATION) (pSendBuffer + this->dwSPHeaderSize);

    //
    // Fill directplay system message header in the outgoing message buffer
    //
	SET_MESSAGE_HDR(pOutMsg);
    pOutMsg->dwDataOffset = sizeof(MSG_AUTHENTICATION);
    pOutMsg->dwIDFrom = this->pSysPlayer->dwID;

    //
    // Setup API's input security buffer to pass the client's negotiate
    // message to the SSPI.
    //
    inSecDesc.ulVersion = SECBUFFER_VERSION;
    inSecDesc.cBuffers = 1;
    inSecDesc.pBuffers = &inSecBuffer;

    inSecBuffer.cbBuffer = pInMsg->dwDataSize;
    inSecBuffer.BufferType = SECBUFFER_TOKEN;
    inSecBuffer.pvBuffer = (LPBYTE)pInMsg + pInMsg->dwDataOffset;

    //
    // Setup API's output security buffer for receiving challenge message
    // from the SSPI.
    //
    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.cbBuffer = this->ulMaxContextBufferSize;
    outSecBuffer.BufferType = SECBUFFER_TOKEN;
    outSecBuffer.pvBuffer = (LPBYTE)pOutMsg + sizeof(MSG_AUTHENTICATION);

    // enfore the following requirements on the context 
    fContextReq = DPLAY_SECURITY_CONTEXT_REQ;

    ASSERT(phOutContext);

    //
    // pass it to the security package
    //
    status = OS_AcceptSecurityContext(
        this->phCredential, 
        phInContext, 
        &inSecDesc,
        fContextReq, 
        SECURITY_NATIVE_DREP, 
        phOutContext,
        &outSecDesc, 
        &fAttribute, 
        &tsExpireTime
        );

    if (!SEC_SUCCESS(status))
    {
        //
        // Failure
        //
        if ((SEC_E_LOGON_DENIED == status) ||
            (SEC_E_TARGET_UNKNOWN == status))
        {
            hr = SetupLogonDeniedMsg(this, pOutMsg, &dwMessageSize, pInMsg->dwIDFrom);
        }
        else
        {
            // Some other error occured - send an auth error message

            DPF_ERRVAL("Process authenticate request failed [0x%8x]\n", status);

            hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
        }
    }
    else
    {
        //
        // Success
        //
        if (SEC_E_OK == status)
        {
            //
            // Set up the max signature size for this package here. Although, 
            // the signature size is independent of the context, the only way to get it
            // in SSPI is through QueryContextAttributes (tied to a context). This
            // is why we setup this member here when the first client logs in.
            //
            if (0 == this->ulMaxSignatureSize)
            {
                hr = SetupMaxSignatureSize(this,phOutContext);
                if (FAILED(hr))
                {
                    DPF_ERR("Failed to get signature size - not sending access granted message");

                    hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
                }
            }

            if (this->ulMaxSignatureSize)
            {
                // send an access granted message to the client
                DPF(6, "Sending access granted message");
                // 
                // Send an access granted message
                //
                hr = SendAccessGrantedMessage(this, pInMsg->dwIDFrom, pvSPHeader);
                if (FAILED(hr))
                {
                    DPF_ERRVAL("Failed to send access granted message: hr=0x%08x",hr);
                }
                // exit as we have already sent the message
                goto CLEANUP_EXIT;
            }

        }
        else if (SEC_I_CONTINUE_NEEDED == status)
        {
            DPF(6, "Sending challenge message");
            //
            // setup a challenge message
            //
            SET_MESSAGE_COMMAND(pOutMsg, DPSP_MSG_CHALLENGE);
            pOutMsg->dwDataSize = outSecBuffer.cbBuffer;
            dwMessageSize = GET_MESSAGE_SIZE(this,MSG_AUTHENTICATION) + outSecBuffer.cbBuffer;
        }
        else
        {
            // todo - we do not support complete auth token at this time
            DPF_ERRVAL("SSPI provider requested unsupported functionality [0x%8x]", status);

            hr = SetupAuthErrorMsg(this, pOutMsg, status, &dwMessageSize, pInMsg->dwIDFrom);
        }
    }

    // fall through will send the message

    //
    // Send reply to the client. We are using DoReply instead of SendDPMessage 
    // because we don't have a system player yet.
    //
    hr = DoReply(this, pSendBuffer, dwMessageSize, pvSPHeader, 0);
    if (FAILED(hr))
    {
        DPF(0, 
            "Send Authentication response failed for client[%d]\n",
            pInMsg->dwIDFrom);
    }

    // fall through

CLEANUP_EXIT:
    // cleanup allocations
    if (pSendBuffer) DPMEM_FREE(pSendBuffer);

    return hr;

}   // SendAuthenticationResponse

VOID CopyScatterGatherToContiguous(PUCHAR pBuffer, LPSGBUFFER lpSGBuffers, UINT cBuffers, DWORD dwTotalSize)
{
	DWORD offset=0;
	UINT i;
	// copy the SG buffers into the single buffer. 
	for(i=0;i<cBuffers;i++){
		memcpy(pBuffer+offset,lpSGBuffers[i].pData,lpSGBuffers[i].len);
		offset+=lpSGBuffers[i].len;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageEx"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageEx
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. Signing
//              is done with SSPI and encryption with CAPI.
//
//  Arguments:  this - pointer to dplay object
//              psp  - pointer to send parameter structure
//              bDropLock - flag whether to drop DPLAY_LOCK when calling SP
//              
//  Returns:    DPERR_OUTOFMEMORY, result from SignBuffer, EncryptBufferCAPI,
//              or SendDPMessage().
//
// NOTE: see SecureSendDPMessageCAPIEx
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize, dwMsgSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;


    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(psp->dwFlags & DPSEND_GUARANTEED);

    //
    // Get the signing security context handle
    //
    if (IAM_NAMESERVER(this))
    {
		// if destination player is a system player, use the info stored in it
		if (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
		{
	        phContext = &(psp->pPlayerTo->pClientInfo->hContext);
	        phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
		}
		else
		{
			// if destination player is a user player
            // use the security context of the corresponding system player
			psp->pPlayerTo = PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
			if (!psp->pPlayerTo)
			{
				DPF_ERR("Invalid player id - can't get security context handle");
				return DPERR_INVALIDPLAYER;
			}
			phContext = &(psp->pPlayerTo->pClientInfo->hContext);
			phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client

        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + this->dwSPHeaderSize/*workaround*/ + psp->dwTotalSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        hr=E_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);

    //
    // Setup message information on the send buffer
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    // Copy message data
    CopyScatterGatherToContiguous((LPBYTE)pSecureMsg+sizeof(MSG_SECURE)+this->dwSPHeaderSize/*workaround*/, 
    								psp->Buffers, psp->cBuffers, psp->dwTotalSize);

    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    dwMsgSize=pSecureMsg->dwDataSize = psp->dwTotalSize+this->dwSPHeaderSize/*workaround*/;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (psp->dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;

        //
        // Encrypt the message. 
        //
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		(psp->pPlayerFrom) ? psp->pPlayerFrom->dwID : 0, 
		(psp->pPlayerTo) ? psp->pPlayerTo->dwID : 0,
		phContext);

    // 
    // Sign the entire message in the buffer (including the wrapper) . 
    // Signature follows the message.
    //
    hr = SignBuffer(phContext,                          // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize, 	                    // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

	ASSERT(dwSigSize <= this->ulMaxSignatureSize);
	#if 0
		if(dwSigSize > this->ulMaxSignatureSize){
			DEBUG_BREAK();
		}
	#endif	

    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    //
    // Send the message
    //
    hr=InternalSendDPMessage(this, psp->pPlayerFrom, psp->pPlayerTo, 
    						 pSendBuffer, GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize+dwSigSize,
    						 psp->dwFlags & ~(DPSEND_ENCRYPTED | DPSEND_SIGNED),
    						 bDropLock);
	
CLEANUP_EXIT:    

	if(pSendBuffer){
		DPMEM_FREE(pSendBuffer);
	}

	return hr;	// since all alloc is on psp, it will get freed with the psp.

} // SecureSendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessage"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessage
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. Signing
//              is done with SSPI and encryption with CAPI.
//
//  Arguments:  this - pointer to dplay object
//              pPlayerFrom - pointer to sending player
//              pPlayerTo - pointer to receiving player
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (guaranteed,encrypted,signed,etc.)
//              
//  Returns:    DPERR_OUTOFMEMORY, result from SignBuffer, EncryptBufferCAPI,
//              or SendDPMessage().
//
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessage(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(dwFlags & DPSEND_GUARANTEED);

    //
    // Get the signing security context handle
    //
    if (IAM_NAMESERVER(this))
    {
		// if destination player is a system player, use the info stored in it
		if (pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
		{
	        phContext = &(pPlayerTo->pClientInfo->hContext);
	        phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
		}
		else
		{
			// if destination player is a user player
            // use the security context of the corresponding system player
			pPlayerTo = PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
			if (!pPlayerTo)
			{
				DPF_ERR("Invalid player id - can't get security context handle");
				return DPERR_INVALIDPLAYER;
			}
			phContext = &(pPlayerTo->pClientInfo->hContext);
			phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client

        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        return E_OUTOFMEMORY;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);

    //
    // Setup message information on the send buffer
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    // Copy message data
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);
    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;

        //
        // Encrypt the message. 
        //
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                    // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		(pPlayerFrom) ? pPlayerFrom->dwID : 0, 
		(pPlayerTo) ? pPlayerTo->dwID : 0,
		phContext);

    // 
    // Sign the entire message in the buffer (including the wrapper) . 
    // Signature follows the message.
    //
    hr = SignBuffer(phContext,                          // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize, 	                    // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    
    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    // since dplay is providing security, toggle the flags off
    dwFlags &= ~(DPSEND_ENCRYPTED | DPSEND_SIGNED);

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, pPlayerFrom, pPlayerTo, pSendBuffer, 
        GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize, dwFlags, bDropLock);
    //
    // Fall through
    //
CLEANUP_EXIT:    
    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);

	return hr;

} // SecureSendDPMessage

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageCAPIEx"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageCAPIEx
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. 
//              Signing and encryption both are done using CAPI.
//
//  Arguments:  this - pointer to dplay object
//				psp  - pointer to send parameters
//              bDropLock - whether to drop DPLAY_LOCK() when calling SP
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_GENERIC, result from EncryptBufferCAPI,
//              or SendDPMessage().
//
//
// NOTE: we have to add in a dummy SP header to be encrypted with the message
//       because that's how the old version did it, and we must be compatible.
//       So as not to confuse all workarounds from what it would have been 
//       are marked with "workaround".
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageCAPIEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock) 
{

	LPBYTE pMsg;
	DWORD  dwMsgSize;
	DWORD  dwMsgSizeMax;

	DWORD dwSigSize;
	HRESULT hr = DPERR_GENERIC;
    HCRYPTKEY *phEncryptionKey=NULL;
	HCRYPTHASH hHash=0;
	DWORD MaxSign=100;
	LPMSG_SECURE pSecureMsg;


    ASSERT(this->pSysPlayer);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(psp->dwFlags & DPSEND_GUARANTEED);


	dwMsgSize = psp->dwTotalSize+this->dwSPHeaderSize/*workaround*/;
	dwMsgSizeMax = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + MaxSign;
	
	pMsg = DPMEM_ALLOC(dwMsgSizeMax);

	if(!pMsg){
		DPF_ERR("Failed to allocate contiguous encryption buffer - out of memory\n");
		return DPERR_OUTOFMEMORY;
	}

	pSecureMsg=(LPMSG_SECURE)(pMsg+this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pSecureMsg);
	SET_MESSAGE_COMMAND(pSecureMsg, DPSP_MSG_SIGNED);

	CopyScatterGatherToContiguous(pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE)+this->dwSPHeaderSize/*workaround*/,
								  psp->Buffers,psp->cBuffers,psp->dwTotalSize);

    pSecureMsg->dwIDFrom     = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize   = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags      = DPSECURE_SIGNEDBYCAPI;
	//pSecureMsg->dwSignatureSize =			(filled in below when we know it)

	if (psp->dwFlags & DPSEND_ENCRYPTED)
	{
		// Encrypt the BODY of the message only
	
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
		//
		// Get the encryption key
		//
		if (IAM_NAMESERVER(this))
		{
			// if destination player is a system player, use the info stored in it
			if (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
			}
			else
			{
				// if destination player is a user player
				// use the security context of the corresponding system player
				psp->pPlayerTo = PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
				if (!psp->pPlayerTo)
				{
					DPF_ERR("Invalid player id - can't get security context handle");
					hr = DPERR_INVALIDPLAYER;
					goto CLEANUP_EXIT;
				}
				phEncryptionKey = &(psp->pPlayerTo->pClientInfo->hEncryptionKey);
			}
		}
		else
		{
			// client
			phEncryptionKey = &(this->hEncryptionKey);
		}

		ASSERT(phEncryptionKey);

		//
		// Encrypt the buffer in place. Since we only allow stream ciphers, the size of 
		// the decrypted data will be equal to the original size.
		//
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE),		    // pointer to data
            &dwMsgSize                                      // size of data
			);
			
		if (FAILED(hr))
		{
			DPF_ERRVAL("Failed to encrypt the buffer: Error=0x%08x",hr);
			goto CLEANUP_EXIT;
		}
	}

	DPF(6,"Using CAPI for signing");

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE), dwMsgSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		hr=DPERR_GENERIC;
		goto CLEANUP_EXIT;
	}

	// Determine size of signature
	dwSigSize = 0;
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigSize)) 
	{
		DWORD dwError=GetLastError();
		DPF_ERRVAL("Error %x during CryptSignHash!\n", dwError);
		if(dwError!=NTE_BAD_LEN) 
		{
			hr=DPERR_GENERIC;
			goto CLEANUP_EXIT;
		}
	}

	#ifdef DEBUG
	if(dwSigSize > MaxSign){
		DPF(0,"Buffer too Small, requested signature of size %d only allocated %d\n",dwSigSize, MaxSign);
		DEBUG_BREAK();
	}
	#endif

	pSecureMsg->dwSignatureSize = dwSigSize;

	// Sign hash object.
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, 
		pMsg+GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize, &dwSigSize)) 
	{
		// Warning, error may be incorrect since OS_CryptSignHash may call out and
		// cause the LastError to be changed.
		DPF_ERRVAL("Error 0x%x during CryptSignHash! (error may be incorrect)\n", GetLastError());
		goto CLEANUP_EXIT;
	}

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, psp->pPlayerFrom, psp->pPlayerTo, 
							   pMsg, GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize+dwSigSize,
							   psp->dwFlags & ~(DPSEND_ENCRYPTED | DPSEND_SIGNED),
							   bDropLock);

    //
    // Fall through
    //
CLEANUP_EXIT:    

	if(pMsg){
		DPMEM_FREE(pMsg);
	}

	// clean up allocated objects
	OS_CryptDestroyHash(hHash);

	return hr;
	
} // SecureSendDPMessageCAPIEx

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureSendDPMessageCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   SecureSendDPMessageCAPI
//
//  Description:This function is used to send messages securely. Based on the flags
//              this function will either digitally sign a message or encrypt it. 
//              Signing and encryption both are done using CAPI.
//
//  Arguments:  this - pointer to dplay object
//              pPlayerFrom - pointer to sending player
//              pPlayerTo - pointer to receiving player
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (guaranteed,encrypted,signed,etc.)
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_GENERIC, result from EncryptBufferCAPI,
//              or SendDPMessage().
//
//-----------------------------------------------------------------------------
HRESULT 
SecureSendDPMessageCAPI(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock) 
{
	LPBYTE pSendBuffer=NULL, pLocalCopy=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr = DPERR_GENERIC;
    HCRYPTKEY *phEncryptionKey=NULL;
	HCRYPTHASH hHash=0;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->dwFlags & DPLAYI_DPLAY_SECURITY);
    ASSERT(dwFlags & DPSEND_GUARANTEED);

	if (dwFlags & DPSEND_ENCRYPTED)
	{
		//
		// Make a copy of the message, so we don't destroy the original message.
		// Sending messages to groups will not work otherwise.
		//
		// todo - update code to avoid the extra copy
		//
		pLocalCopy = DPMEM_ALLOC(dwMsgSize);
		if (!pLocalCopy)
		{
			DPF_ERR("Failed to make a local copy of message for encryption - out of memory");
			return DPERR_OUTOFMEMORY;
		}

		// copy the message into the buffer
		memcpy(pLocalCopy, pMsg, dwMsgSize);

		// now point to the local copy of the message
		pMsg = pLocalCopy;

		//
		// Get the encryption key
		//
		if (IAM_NAMESERVER(this))
		{
			// if destination player is a system player, use the info stored in it
			if (pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
			}
			else
			{
				// if destination player is a user player
				// use the security context of the corresponding system player
				pPlayerTo = PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
				if (!pPlayerTo)
				{
					DPF_ERR("Invalid player id - can't get security context handle");
					hr = DPERR_INVALIDPLAYER;
					goto CLEANUP_EXIT;
				}
				phEncryptionKey = &(pPlayerTo->pClientInfo->hEncryptionKey);
			}
		}
		else
		{
			// client
			phEncryptionKey = &(this->hEncryptionKey);
		}

		ASSERT(phEncryptionKey);

		//
		// Encrypt the buffer in place. Since we only allow stream ciphers, the size of 
		// the decrypted data will be equal to the original size.
		//
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            pMsg,										    // pointer to data
            &dwMsgSize                                      // size of data
			);
		if (FAILED(hr))
		{
			DPF_ERRVAL("Failed to encrypt the buffer: Error=0x%08x",hr);
			goto CLEANUP_EXIT;
		}
	}

	DPF(6,"Using CAPI for signing");

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, pMsg, dwMsgSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Determine size of signature
	dwSigSize = 0;
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, NULL, &dwSigSize)) 
	{
		DWORD dwError=GetLastError();
		DPF_ERRVAL("Error %x during CryptSignHash!\n", dwError);
		if(dwError!=NTE_BAD_LEN) 
		{
			goto CLEANUP_EXIT;
		}
	}

	// Allocate memory for the signature
	// We allocate the send buffer and just put the signature directly into it

	dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize;

	pSendBuffer = DPMEM_ALLOC(dwBufferSize);
	if (!pSendBuffer)
	{
		DPF_ERR("Failed to allocate send buffer - out of memory");
		goto CLEANUP_EXIT;
	}

    // Copy message data into the send buffer
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);

    //
    // Setup message information
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYCAPI;
	if (dwFlags & DPSEND_ENCRYPTED)
	{
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
	}
    pSecureMsg->dwIDFrom = this->pSysPlayer->dwID;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
    pSecureMsg->dwSignatureSize = dwSigSize;

	// todo - do we want to add a description to the signature ?

	// Sign hash object.
	if(!OS_CryptSignHash(hHash, AT_KEYEXCHANGE, NULL, 0, 
		pSendBuffer+GET_MESSAGE_SIZE(this,MSG_SECURE)+dwMsgSize, &dwSigSize)) 
	{
		// WARNING The LastError may be incorrect since OS_CryptSignHash may call out
		// to DPF which can change the LastError value.
		DPF_ERRVAL("Error %x during CryptSignHash! (WARNING, error may be incorrect)\n", GetLastError());
		goto CLEANUP_EXIT;
	}
    
    // since dplay is providing security, toggle the flags off
    dwFlags &= ~(DPSEND_ENCRYPTED | DPSEND_SIGNED);

    //
    // Send the message
    //
	hr = InternalSendDPMessage(this, pPlayerFrom, pPlayerTo, pSendBuffer, dwBufferSize, dwFlags,bDropLock);

    //
    // Fall through
    //
CLEANUP_EXIT:    

	// clean up allocated objects
	OS_CryptDestroyHash(hHash);

    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pLocalCopy) DPMEM_FREE(pLocalCopy);

	return hr;

} // SecureSendDPMessageCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"SecureDoReply"
//+----------------------------------------------------------------------------
//
//  Function:   SecureDoReply
//
//  Description:This function is used to send a signed or encrypted reply message. 
//              It is only used by the server to send secure messages to the client
//              during client logon.
//
//  Arguments:  this - pointer to dplay object
//              dpidFrom - sending player id
//              dpidTo - receiving player id
//              pMsg - message being sent
//              dwMsgSize - size of the message
//              dwFlags - message attributes (encrypted or signed)
//              pvSPHeader - sp header used for replying
//              
//  Returns:    DPERR_OUTOFMEMORY, DPERR_INVALIDPLAYER, result from SignBuffer, 
//              EncryptBufferSSPI, or DoReply
//
//-----------------------------------------------------------------------------
HRESULT 
SecureDoReply(
    LPDPLAYI_DPLAY this,
	DPID dpidFrom,
	DPID dpidTo,
	LPBYTE pMsg,
	DWORD dwMsgSize,
	DWORD dwFlags,
	LPVOID pvSPHeader
	)
{
	LPBYTE pSendBuffer=NULL;
    LPMSG_SECURE pSecureMsg=NULL;
	DWORD dwBufferSize, dwSigSize;
	HRESULT hr;
    PCtxtHandle phContext;
    HCRYPTKEY *phEncryptionKey=NULL;

    ASSERT(pMsg);
    ASSERT(this->pSysPlayer);
    ASSERT(this->ulMaxSignatureSize);

    //
    // Get security context handle to use
    //
    if (IAM_NAMESERVER(this))
    {
		DWORD_PTR dwItem;

		dwItem = NameFromID(this,dpidTo);
		if (!dwItem)
		{
			DPF_ERR("Failed to send secure reply - invalid destination player");
			return DPERR_INVALIDPLAYER;
		}
		// we have a valid dest player id
		if (NAMETABLE_PENDING == dwItem)
		{
    	    // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = DataFromID(this, dpidTo);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

		    phContext = &(pClientInfo->hContext);
		    phEncryptionKey = &(pClientInfo->hEncryptionKey);
		}
		else 
		{
			// player has logged in
	        phContext = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hContext);
	        phEncryptionKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hEncryptionKey);
		}
    }
    else
    {
        // client side
        phContext = this->phContext;
        phEncryptionKey = &(this->hEncryptionKey);
    }

    ASSERT(phContext);
	ASSERT(phEncryptionKey);

    //
    // Calculate size of the send buffer
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + this->ulMaxSignatureSize;
    dwSigSize = this->ulMaxSignatureSize;

    //
    // Allocate memory for it
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not allocate memory for signed message");
        return E_OUTOFMEMORY;
    }

    //
    // Point to the message in the buffer
    //
    pSecureMsg = (LPMSG_SECURE) (pSendBuffer+this->dwSPHeaderSize);
    // Copy message data
	memcpy((LPBYTE)pSecureMsg+sizeof(MSG_SECURE), pMsg, dwMsgSize);

    //
    // Setup message information
    //
	SET_MESSAGE_HDR(pSecureMsg);
    SET_MESSAGE_COMMAND(pSecureMsg,DPSP_MSG_SIGNED);
    pSecureMsg->dwIDFrom = dpidFrom;
    pSecureMsg->dwDataSize = dwMsgSize;
    pSecureMsg->dwDataOffset = sizeof(MSG_SECURE);
	pSecureMsg->dwFlags = DPSECURE_SIGNEDBYSSPI;

    if (dwFlags & DPSEND_ENCRYPTED)
    {
		pSecureMsg->dwFlags |= DPSECURE_ENCRYPTEDBYCAPI;
		hr = EncryptBufferCAPI(
            this,
            phEncryptionKey,                                // handle to encryption key
            (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,    // pointer to data
            &dwMsgSize);                                    // size of data
    } 

	DPF(6,"Using SSPI for signing");

	DPF(6,"Signing message from player %d to player %d using phContext=0x%08x", 
		dpidFrom, dpidTo, phContext);

    // 
    // Sign the entire message (including the wrapper) in the buffer. 
    // Signature follows the message.
    //
    hr = SignBuffer(
		phContext,			                            // handle to security context
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset,  // pointer to embedded message
        pSecureMsg->dwDataSize,                         // size of embedded message
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+dwMsgSize,// pointer to signature    
        &dwSigSize);                                    // size of signature

    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    
    // use the signature size returned from the package so we don't send more
    // bytes than we absolutely need to.
    pSecureMsg->dwSignatureSize = dwSigSize;

    //
    // Send the message
    //
	hr = DoReply(this, pSendBuffer, GET_MESSAGE_SIZE(this,MSG_SECURE) + dwMsgSize + dwSigSize, 
		pvSPHeader, 0);
    //
    // Fall through
    //
CLEANUP_EXIT:    
    //
    // Cleanup allocations
    //
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);

	return hr;

} // SecureDoReply

#undef DPF_MODNAME
#define DPF_MODNAME	"SignBuffer"
//+----------------------------------------------------------------------------
//
//  Function:   SignBuffer
//
//  Description:This function signs a data buffer and puts the signature in it.
//
//  Arguments:  phContext - pointer to signing security context handle
//              pBuffer - data buffer
//              dwBufferSize - size of the buffer
//              pSig - signature buffer
//              pdwSigSize - pointer to signature size
//
//  Returns:    DP_OK if success, otherwise DPERR_SIGNFAILED.
//
//-----------------------------------------------------------------------------
HRESULT 
SignBuffer(
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    DWORD dwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc outSecDesc;
    SecBuffer outSecBuffer[2];
    SECURITY_STATUS status;

    ASSERT(pBuffer && pSig && pdwSigSize);

    DPF(6,"Signing buffer: data: %d",dwBufferSize);
    DPF(6,"Signing buffer: sig: %d",*pdwSigSize);

    // 
    // Setup message buffer to be signed
    //
    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 2;
    outSecDesc.pBuffers = &outSecBuffer[0];

    outSecBuffer[0].cbBuffer = dwBufferSize;
    outSecBuffer[0].BufferType = SECBUFFER_DATA;
    outSecBuffer[0].pvBuffer = pBuffer;

    outSecBuffer[1].cbBuffer = *pdwSigSize;
    outSecBuffer[1].BufferType = SECBUFFER_TOKEN;
    outSecBuffer[1].pvBuffer = pSig;

    //
    // Sign the message
    //
    status = OS_MakeSignature(
        phContext,         // phContext
        0,                  // fQOP (Quality of Protection)
        &outSecDesc,        // pMessage
        0                   // MessageSeqNo
        );

    if (!SEC_SUCCESS(status))
    {
        DPF(0,"Buffer couldn't be signed: 0x%08x", status);
        return DPERR_SIGNFAILED;
    }

    //
    // Return the actual signature size
    //
    *pdwSigSize = outSecBuffer[1].cbBuffer;

    // 
    // Success
    //
	return DP_OK;

} // SignBuffer


#undef DPF_MODNAME
#define DPF_MODNAME "VerifyBuffer"
//+----------------------------------------------------------------------------
//
//  Function:   VerifyBuffer
//
//  Description:This function verifies the digital signature of a data buffer, given
//              the signature
//
//  Arguments:  hContext - Handle to client's security context
//              pBuffer - Points to signed message 
//              dwBufferSize - Size of the message
//              pSig - Points to the signature
//              dwSigSize - Size of the signature
// 
//  Returns:    DP_OK if signature verifies OK. Otherwise, DPERR_VERIFYFAILED is returned.
//
//-----------------------------------------------------------------------------
HRESULT 
VerifyBuffer(
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    DWORD dwBufferSize, 
    LPBYTE pSig, 
    DWORD dwSigSize
    )
{
    SECURITY_STATUS status;
    SecBufferDesc inSecDesc;
    SecBuffer inSecBuffer[2];

    DPF(6,"Verifying buffer: data: %d",dwBufferSize);
    DPF(6,"Verifying buffer: sig: %d",dwSigSize);

    inSecDesc.ulVersion = SECBUFFER_VERSION;
    inSecDesc.cBuffers = 2;
    inSecDesc.pBuffers = &inSecBuffer[0];

    inSecBuffer[0].cbBuffer = dwBufferSize;
    inSecBuffer[0].BufferType = SECBUFFER_DATA;
    inSecBuffer[0].pvBuffer = pBuffer;
    inSecBuffer[1].cbBuffer = dwSigSize;
    inSecBuffer[1].BufferType = SECBUFFER_TOKEN;
    inSecBuffer[1].pvBuffer = pSig;

    status = OS_VerifySignature(phContext, &inSecDesc, 0, 0);

    if (!SEC_SUCCESS(status))
    {
        DPF(0,"******** Buffer verification failed: 0x%08x ********", status);
        return DPERR_VERIFYSIGNFAILED;
    }

    //
    // Success
    //
    return DP_OK;

}   // VerifyBuffer

#undef DPF_MODNAME
#define DPF_MODNAME "VerifySignatureSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   VerifySignatureSSPI
//
//  Description:This function verifies the digital signature on a secure message using
//              the Security Support Provider Interface (SSPI).
//
//  Arguments:  this - pointer to dplay object
//              phContext - pointer to verification security context handle
//              pReceiveBuffer - signed message received from transport sp
//              dwMessageSize - size of the message
// 
//  Returns:    DP_OK, result from VerifyBuffer() or DecryptBuffer()
//
//-----------------------------------------------------------------------------
HRESULT 
VerifySignatureSSPI(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    )
{
    PCtxtHandle phContext=NULL;
    DWORD_PTR dwItem;
    HRESULT hr;
    LPMSG_SECURE pSecureMsg = (LPMSG_SECURE) pReceiveBuffer;

	DPF(6,"Using SSPI for Signature verification");
    //
    // Retrieve security context handle to verify the message
    //
    if (IAM_NAMESERVER(this))
    {
        dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
        if (0==dwItem)
        {
            DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
            return DPERR_INVALIDPLAYER;
        }
        if (NAMETABLE_PENDING == dwItem)
        {
            // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = (LPCLIENTINFO) DataFromID(this,pSecureMsg->dwIDFrom);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

            phContext = &(pClientInfo->hContext);
        }
        else
        {
            // player has logged in
            phContext = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hContext);
        }
    }
    else
    {
        // client
        phContext = this->phContext;
    }

	//
	// Verify signature
	//
    hr = VerifyBuffer( 
        phContext,                                       // sec context handle
		(LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,	 // pointer to embedded message
		pSecureMsg->dwDataSize,							 // size of embedded message
        (LPBYTE)pSecureMsg + pSecureMsg->dwDataOffset + pSecureMsg->dwDataSize,
														 // pointer to signature
        pSecureMsg->dwSignatureSize                      // size of signature
        );

    return hr;

}   // VerifySignatureSSPI

#undef DPF_MODNAME
#define DPF_MODNAME "VerifySignatureCAPI"
//+----------------------------------------------------------------------------
//
//  Function:   VerifySignatureCAPI
//
//  Description:This function verifies the digital signature on a message using the
//              Crypto API.
//
//  Arguments:  this - pointer to dplay object
//              pSecureMsg - secure message that came off the wire
// 
//  Returns:    DP_OK, DPERR_GENERIC, DPERR_INVALIDPLAYER, DPERR_VERIFYSIGNFAILED,
//
//-----------------------------------------------------------------------------
HRESULT 
VerifySignatureCAPI(
    LPDPLAYI_DPLAY this,
    LPMSG_SECURE pSecureMsg
    )
{
    DWORD_PTR dwItem;
    HRESULT hr = DPERR_GENERIC;
	HCRYPTHASH hHash=0;
	HCRYPTKEY *phPublicKey;

	DPF(6,"Using CAPI for Signature verification");

    //
    // Retrieve sender's public key
    //
    if (IAM_NAMESERVER(this))
    {
        dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
        if (0==dwItem)
        {
            DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
            return DPERR_INVALIDPLAYER;
        }
        if (NAMETABLE_PENDING == dwItem)
        {
            // player hasn't logged in yet
            LPCLIENTINFO pClientInfo;

            pClientInfo = (LPCLIENTINFO) DataFromID(this,pSecureMsg->dwIDFrom);
            if (!pClientInfo)
            {
                DPF_ERR("No client info available for this player");
                return DPERR_GENERIC;
            }

            phPublicKey = &(pClientInfo->hPublicKey);
        }
        else
        {
            // player has logged in
            phPublicKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hPublicKey);
        }
    }
    else
    {
        // client
        phPublicKey = &(this->hServerPublicKey);
    }

	ASSERT(phPublicKey);

	// Create hash object.
	if(!OS_CryptCreateHash(this->hCSP, CALG_MD5, 0, 0, &hHash)) 
	{
		DPF_ERRVAL("Error %x during CryptCreateHash!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Hash buffer.
	if(!OS_CryptHashData(hHash, (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset, pSecureMsg->dwDataSize, 0)) 
	{
		DPF_ERRVAL("Error %x during CryptHashData!\n", GetLastError());
		goto CLEANUP_EXIT;
	}

	// Validate digital signature.
	if(!OS_CryptVerifySignature(hHash, (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset+pSecureMsg->dwDataSize, 
		pSecureMsg->dwSignatureSize, *phPublicKey, NULL, 0)) 
	{
		if(GetLastError() == NTE_BAD_SIGNATURE) 
		{
			DPF_ERR("********** Signature verification failed *********");
			hr = DPERR_VERIFYSIGNFAILED;
		} 
		else 
		{
			DPF_ERRVAL("Error %x during CryptVerifySignature!\n", GetLastError());
		}
		goto CLEANUP_EXIT;
	} 

	hr = DP_OK;
	//
	// Fall through
	//

CLEANUP_EXIT:

	OS_CryptDestroyHash(hHash);
    return hr;

}   // VerifySignatureCAPI

#undef DPF_MODNAME
#define DPF_MODNAME "VerifyMessage"
//+----------------------------------------------------------------------------
//
//  Function:   VerifyMessage
//
//  Description:This function verifies a secure message. If the message is signed,
//              it will verify the digital signature on it. If the message is encrypted,
//              it will verify the digital signature on the message to make sure it has
//              not been tampered with and then decrypt it.
//
//  Arguments:  this - pointer to dplay object
//              phContext - pointer to verification security context handle
//              pReceiveBuffer - signed message received from transport sp
//              dwMessageSize - size of the message
// 
//  Returns:    DP_OK, result from VerifyBuffer() or DecryptBuffer()
//
//-----------------------------------------------------------------------------
HRESULT 
VerifyMessage(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    )
{
    HRESULT hr;
    LPMSG_SECURE pSecureMsg = (LPMSG_SECURE) pReceiveBuffer;

    if (!this->pSysPlayer)
    {
        DPF_ERR("Can't verify message - no system player yet");
        return DPERR_GENERIC;
    }

	DPF(6,"Verifying signature for message 0x%08x from player %d", pSecureMsg->dwCmdToken, \
		pSecureMsg->dwIDFrom);
	//
	// Verify the digital signature on the message
	//

	if (pSecureMsg->dwFlags & DPSECURE_SIGNEDBYCAPI)
	{
		hr = VerifySignatureCAPI(this, pSecureMsg);
	}
	else if (pSecureMsg->dwFlags & DPSECURE_SIGNEDBYSSPI)
	{
		// sspi signature includes the secure message not just the contents
		// (this is how it was coded)
		hr = VerifySignatureSSPI(this, pReceiveBuffer, dwMessageSize);
	}
	else
	{
		// flags were not set
		return DPERR_INVALIDPARAMS;
	}

	if (FAILED(hr))
	{
		return hr;
	}

	//
	// Decrypt the message, if it was encrypted
	//

	if (pSecureMsg->dwFlags & DPSECURE_ENCRYPTEDBYCAPI)
	{
		hr = DecryptMessageCAPI(this, pSecureMsg);
	}

    return hr;

}   // VerifyMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"EncryptBufferSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   EncryptBufferSSPI
//
//  Description:This function encrypts the Buffer passed in the buffer in place.
//              It also setups up the checksum in the structure.              
//
//  Arguments:  this - dplay object
//              phContext - pointer to security context used for encryption
//              pBuffer - Buffer to be encrypted
//              pdwBufferSize - pointer to Buffer size. If encryption succeeds, this will be
//                              be updated to the encrypted Buffer size
//              pSig - buffer for the signature
//              pdwSigSize - pointer to sig size. If encryption succeeds, this will be
//                           updated to the size of generated signature.
// 
//  Returns:    DP_OK if success, otherwise DPERR_ENCRYPTIONFAILED.
//
//-----------------------------------------------------------------------------
HRESULT 
EncryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer,
    LPDWORD pdwBufferSize,
    LPBYTE pSig,
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc   SecDesc;
    SecBuffer       SecBuffer[2]; // 1 for the checksum & 1 for the actual msg
    SECURITY_STATUS status;

    ASSERT(pSig);
    ASSERT(pdwSigSize);
	ASSERT(pdwBufferSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    //
    // Setup security buffer to pass the outgoing message to SealMessage()
    //
    SecDesc.ulVersion = SECBUFFER_VERSION;
    SecDesc.cBuffers = 2;
    SecDesc.pBuffers = &SecBuffer[0];

    SecBuffer[0].cbBuffer = *pdwSigSize;
    SecBuffer[0].BufferType = SECBUFFER_TOKEN;
    SecBuffer[0].pvBuffer = pSig;

    SecBuffer[1].cbBuffer = *pdwBufferSize;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pBuffer;

    //
    // Encrypt the outgoing message
    //
    status = OS_SealMessage(phContext, 0L, &SecDesc, 0L);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Encryption failed: %8x", status);
        return DPERR_ENCRYPTIONFAILED;
    }

    //
    // Return the actual signature size
    //
    *pdwSigSize = SecBuffer[0].cbBuffer;
	*pdwBufferSize = SecBuffer[1].cbBuffer;

    //
    // Success
    //
    return DP_OK;

}   // EncryptBufferSSPI


#undef DPF_MODNAME
#define DPF_MODNAME	"DecryptBufferSSPI"
//+----------------------------------------------------------------------------
//
//  Function:   DecryptBufferSSPI
//
//  Description:This function decrypts the Buffer passed in the buffer in place.
//
//  Arguments:  this - dplay object
//              phContext - pointer to security context used for encryption
//              pBuffer - Buffer to be decrypted
//              dwBufferSize - Buffer buffer size
//              pSig - signature buffer
//              dwSigSize - signature buffer size
// 
//  Returns:    DP_OK if success, otherwise DPERR_DECRYPTIONFAILED, DPERR_ENCRYPTIONNOTSUPPORTED.
//
//-----------------------------------------------------------------------------
HRESULT 
DecryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    LPDWORD pdwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    )
{
    SecBufferDesc SecDesc;
    SecBuffer     SecBuffer[2]; // 1 for the checksum & 1 for the actual msg
    SECURITY_STATUS status;

	ASSERT(pdwBufferSize);
	ASSERT(pdwSigSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    //
    // Setup API's input security buffer to pass the client's encrypted 
    // message to UnsealMessage().
    //
    SecDesc.ulVersion = SECBUFFER_VERSION;
    SecDesc.cBuffers = 2;
    SecDesc.pBuffers = &SecBuffer[0];

    SecBuffer[0].cbBuffer = *pdwSigSize;
    SecBuffer[0].BufferType = SECBUFFER_TOKEN;
    SecBuffer[0].pvBuffer = pSig;

    SecBuffer[1].cbBuffer = *pdwBufferSize;
    SecBuffer[1].BufferType = SECBUFFER_DATA;
    SecBuffer[1].pvBuffer = pBuffer;

    status = OS_UnSealMessage(phContext, &SecDesc, 0L, 0L);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Decryption failed: %8x\n", GetLastError());
        return DPERR_DECRYPTIONFAILED;
    }

	*pdwSigSize = SecBuffer[0].cbBuffer;
	*pdwBufferSize = SecBuffer[1].cbBuffer;

    //
    // Success
    //
    return DP_OK;

} // DecryptBufferSSPI

#undef DPF_MODNAME
#define DPF_MODNAME "EncryptBufferCAPI"

HRESULT EncryptBufferCAPI(LPDPLAYI_DPLAY this, HCRYPTKEY *phEncryptionKey, LPBYTE pBuffer, LPDWORD pdwBufferSize)
{
	BOOL fResult;
	DWORD dwEncryptedSize, dwError;

    ASSERT(phEncryptionKey);
	ASSERT(pdwBufferSize);

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

    DPF(6,"Encrypt buffer using CAPI: size=%d",*pdwBufferSize);

	dwEncryptedSize = *pdwBufferSize;

	// encrypt buffer using CAPI
    fResult = OS_CryptEncrypt(
        *phEncryptionKey,           // session key for encryption
        0,                          // no hash needed - we are singing using SSPI
        TRUE,                       // final block
        0,                          // reserved
        pBuffer,                    // buffer to be encrypted
        &dwEncryptedSize,           // size of encrypted data
        *pdwBufferSize				// size of buffer
        );

    if (!fResult)
    {
        dwError = GetLastError();
        if (ERROR_MORE_DATA == dwError)
        {
            DPF_ERR("Block encryption is not supported in this release");
        }
        else
        {
            DPF_ERR("Failed to encrypt buffer: Error=%d",);
        }
        return DPERR_ENCRYPTIONFAILED;
    }

	// initialize the number of bytes encrypted
	*pdwBufferSize = dwEncryptedSize;

	// success
	return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DecryptMessageCAPI"

HRESULT DecryptMessageCAPI(LPDPLAYI_DPLAY this, LPMSG_SECURE pSecureMsg)
{
	BOOL fResult;
	DWORD_PTR dwItem;
	HCRYPTKEY *phDecryptionKey;

	if (!(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
	{
		DPF_ERR("Message privacy is not supported");
		return DPERR_ENCRYPTIONNOTSUPPORTED;
	}

	DPF(6,"Decrypting message 0x%08x from player %d using CAPI", pSecureMsg->dwCmdToken, \
		pSecureMsg->dwIDFrom);

	//
	// Retrieve sender's decryption key
	//
	if (IAM_NAMESERVER(this))
	{
		dwItem = NameFromID(this, pSecureMsg->dwIDFrom);
		if (0==dwItem)
		{
			DPF_ERRVAL("Message from unknown player %d", pSecureMsg->dwIDFrom);
			return DPERR_INVALIDPLAYER;
		}
		if (NAMETABLE_PENDING == dwItem)
		{
			// player hasn't logged in yet
			LPCLIENTINFO pClientInfo;

			pClientInfo = (LPCLIENTINFO) DataFromID(this, pSecureMsg->dwIDFrom);
			if (!pClientInfo)
			{
				DPF_ERR("No client info available for this player");
				return DPERR_GENERIC;
			}

			phDecryptionKey = &(pClientInfo->hDecryptionKey);
		}
		else
		{
			// player has logged in
			phDecryptionKey = &(((LPDPLAYI_PLAYER)dwItem)->pClientInfo->hDecryptionKey);
		}
	}
	else
	{
		// client
		phDecryptionKey = &(this->hDecryptionKey);
	}

	ASSERT(phDecryptionKey);

	// decrypt buffer using CAPI
    fResult = OS_CryptDecrypt(
        *phDecryptionKey,								// session key for decryption
        0,												// no hash used
        TRUE,											// final block
        0,												// reserved
        (LPBYTE)pSecureMsg+pSecureMsg->dwDataOffset,	// buffer to be decrypted
        &(pSecureMsg->dwDataSize)						// size of buffer
        );
	if (!fResult)
	{
		DPF_ERRVAL("Buffer decryption failed: Error=0x%08x",GetLastError());
		return DPERR_GENERIC;
	}

	// success
	return DP_OK;

} // DecryptMessageCAPI

#undef DPF_MODNAME
#define DPF_MODNAME	"Login"
//+----------------------------------------------------------------------------
//
//  Function:   Login
//
//  Description:This function does the user authentication synchronously.
//
//  Arguments:  this - pointer to dplay object
// 
//  Returns:    
//
//-----------------------------------------------------------------------------
HRESULT 
Login(
    LPDPLAYI_DPLAY this
    )
{
    HRESULT hr;
    DWORD dwRet, dwTimeout;

    ASSERT(this->pSysPlayer);

    // check if we are already logged in
    if (DPLOGIN_SUCCESS == this->LoginState) return DP_OK;

    dwTimeout = DP_LOGIN_SCALE*GetDefaultTimeout(this, TRUE);

    // always start in negotiate mode
    this->LoginState = DPLOGIN_NEGOTIATE;

    while (TRUE)
    {
        switch (this->LoginState) {

        case DPLOGIN_NEGOTIATE:
            // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	        // until we finish processing it.
            gbWaitingForReply = TRUE;
            //
            // Send a Negotiate message to the server.
            //
            hr = GenerateAuthenticationMessage(this, NULL, 0);
            if (FAILED(hr))
            {
                DPF_ERR("Generate Negotiate message failed");
                // we are not waiting for a reply anymore
                gbWaitingForReply = FALSE;
                goto CLEANUP_EXIT;
            }
            break;

        case DPLOGIN_ACCESSGRANTED:
			{
				LPMSG_ACCESSGRANTED pMsg = (LPMSG_ACCESSGRANTED) gpReceiveBuffer;
				HCRYPTKEY hServerPublicKey;

				ASSERT(this->phContext);
				// we are initializing the signature buffer size here because SSPI 
				// requires a context to query for this information.
				hr = SetupMaxSignatureSize(this,this->phContext);
				if (FAILED(hr))
				{
					DPF_ERR("Failed to get max signature size");
                    // unblock sp thread on our way out
					goto UNBLOCK_EXIT;
				}
				// We successfully logged into the server. Now we need to setup session
				// keys for encryption/decryption. 

				// import server's public key which is contained in the access granted message 
				hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwPublicKeyOffset, pMsg->dwPublicKeySize, &hServerPublicKey);
				if (FAILED(hr))
				{
					DPF_ERRVAL("Failed to import server's public key: hr = 0x%08x",hr);
					hr = DPERR_AUTHENTICATIONFAILED;
                    // unblock receive thread on our way out
					goto UNBLOCK_EXIT;
				}

	            // we are done with the receive buffer, now unblock the receive thread
		        SetEvent(ghReplyProcessed);

				// remember server's public key
				this->hServerPublicKey = hServerPublicKey;

                // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	            // until we finish processing it.
                gbWaitingForReply = TRUE;

				// send our session and public keys to server
				hr = SendKeysToServer(this, hServerPublicKey);
				if (FAILED(hr))
				{
					DPF_ERRVAL("Failed to send keys to server: hr = 0x%08x",hr);
					hr = DPERR_AUTHENTICATIONFAILED;
                    // we are not waiting for a reply anymore
                    gbWaitingForReply = FALSE;
					goto CLEANUP_EXIT;
				}
			}
			break;
      
        case DPLOGIN_LOGONDENIED:
            DPF_ERR("Log in failed: Access denied");
            hr = DPERR_LOGONDENIED;
            // reset login state
            this->LoginState = DPLOGIN_NEGOTIATE;
            // let the app handle now so it can collect credentials from user and try again
            goto CLEANUP_EXIT;
            break;

        case DPLOGIN_ERROR:
            // we are not looking at version here because this change is being made
            // for DirectPlay 5.0 post beta2. We don't want to bump the version this late.
            // todo - remove this check after DirectPlay 5.0 ships.
            if (gdwReceiveBufferSize > sizeof(MSG_SYSMESSAGE))
            {
                LPMSG_AUTHERROR pAuthErrorMsg = (LPMSG_AUTHERROR) gpReceiveBuffer;
                DPF_ERRVAL("An authentication error occured on the server: Error=0x%08x",pAuthErrorMsg->hResult);
                hr = pAuthErrorMsg->hResult;
            }
            else
            {
                DPF_ERR("Login failed: Authentication error");    
                hr = DPERR_AUTHENTICATIONFAILED;
            }
            goto CLEANUP_EXIT;
            break;

        case DPLOGIN_PROGRESS:
            // mark us as waiting for a reply.  so, if one arrives, handler.c knows to wait
	        // until we finish processing it.
            gbWaitingForReply = TRUE;
            //
            // Send response to challenge
            //
            hr = GenerateAuthenticationMessage(this, (LPMSG_AUTHENTICATION)gpReceiveBuffer, 0);
            if (FAILED(hr))
            {
                DPF_ERRVAL("Generate challenge response failed",hr);
                // not waiting for a reply anymore
                gbWaitingForReply = FALSE;
                // unblock receive thread on our way out
                goto UNBLOCK_EXIT;
            }
            // we are done with the receive buffer, now unblock the receive thread
            SetEvent(ghReplyProcessed);
            break;

		case DPLOGIN_KEYEXCHANGE:
            // we received server's session key
			hr = ProcessKeyExchangeReply(this,(LPMSG_KEYEXCHANGE)gpReceiveBuffer);
			if (FAILED(hr))
			{
                DPF_ERRVAL("Failed to process key exchage reply from server: hr = 0x%08x",hr);
                hr = DPERR_AUTHENTICATIONFAILED;
                // unblock receive thread on our way out
                goto UNBLOCK_EXIT;
			}
            // we are done with the receive buffer, now unblock the receive thread
            SetEvent(ghReplyProcessed);

            // keys were exchanged successfully. we are done.
            this->LoginState = DPLOGIN_SUCCESS;
			hr = DP_OK;

    		DPF(5, "Log in successful");
			goto CLEANUP_EXIT;
			break;

        default:
            // make sure we notice 
            ASSERT(FALSE);
            DPF_ERR("Invalid login status\n");
            hr = DPERR_AUTHENTICATIONFAILED;
            goto CLEANUP_EXIT;
            break;
        }
        //
        // Block if we sent a message until we get a response
        //
        if (gbWaitingForReply)
        {
	        // we're protected by the service crit section here, so we can leave dplay
	        // (for reply to be processed)
	        LEAVE_DPLAY();

            // wait for the answer
            dwRet = WaitForSingleObject(ghConnectionEvent,dwTimeout);

	        ENTER_DPLAY();
	        
	        // notice that we look at gbWaitingForReply here instead of dwRet.
	        // this is because we may have timed out just as the reply arrived.
	        // since the reply had the dplay lock, dwRet would be WAIT_TIMEOUT, but
	        // we would have actually received the reply.
	        if (gbWaitingForReply)	
	        {
                DPF_ERR("Waiting for authentication message...Time out");
		        // gbWaitingForReply would have been set to FALSE when the reply arrived
		        // if it's not FALSE, no reply arrived...
		        gbWaitingForReply = FALSE; // reset this for next time
		        hr = DPERR_TIMEOUT;
                goto CLEANUP_EXIT;
	        }

            // we got a response, clear the event
            ResetEvent(ghConnectionEvent);

            // don't unblock the receive thread if we need to process the contents of
            // the receive buffer. We'll unblock the thread after we are done.
            if ((DPLOGIN_PROGRESS != this->LoginState) &&
				(DPLOGIN_KEYEXCHANGE != this->LoginState) &&
                (DPLOGIN_ACCESSGRANTED != this->LoginState))
            {
                // unblock the receive thread
                SetEvent(ghReplyProcessed);
            }

        }   // if (gbWaitingForReply)

    } //  while (TRUE)

    // we never fall through here

// unblock receive thread on our way out
UNBLOCK_EXIT:
    SetEvent(ghReplyProcessed);

// cleanup and bail
CLEANUP_EXIT:
	gpReceiveBuffer = NULL;
    gdwReceiveBufferSize = 0;
    return hr;

} // Login


#undef DPF_MODNAME
#define DPF_MODNAME	"HandleAuthenticationReply"
//+----------------------------------------------------------------------------
//
//  Function:   HandleAuthenticationReply
//
//  Description:This function wakes up the requesting thread, and waits for them 
//              to finish w/ the response buffer
//
//  Arguments:  pReceiveBuffer - buffer received from the sp
//              dwSize - buffer size
// 
//  Returns:    DP_OK or E_FAIL
//
//-----------------------------------------------------------------------------
HRESULT 
HandleAuthenticationReply(
    LPBYTE pReceiveBuffer,
    DWORD dwSize
    ) 
{
	DWORD dwRet;

	// 1st, see if anyone is waiting
	if (!gbWaitingForReply)
	{
		DPF(1,"reply arrived - no one waiting, returning");
		LEAVE_DPLAY();
		return DP_OK;
	}
	// reply is here, reset flag. we do this inside dplay, so whoever is waiting
	// can timeout while we're here, but if they look at gbWaitingForReply they'll
	// see reply actually arrived.
	gbWaitingForReply = FALSE;

    DPF(1,"got authentication reply");
    gpReceiveBuffer = pReceiveBuffer;
    gdwReceiveBufferSize = dwSize;

	// we leave dplay, since the thread in dpsecure.c will need 
	// to enter dplay to process response
	LEAVE_DPLAY();
	
	// let login() party on the buffer
	SetEvent(ghConnectionEvent);

	//
	// wait for Reply to be processed
    dwRet = WaitForSingleObject(ghReplyProcessed,INFINITE);
	if (dwRet != WAIT_OBJECT_0)
	{
		// this should *NEVER* happen
		ASSERT(FALSE);
		return E_FAIL;
	}

	// success!
	ResetEvent(ghReplyProcessed);		

	// note we leave w/ the dplay lock dropped.
	// our caller will just exit (not dropping the lock again).
	return DP_OK;

} // HandleAuthenticationReply


#undef DPF_MODNAME
#define DPF_MODNAME	"SetClientInfo"
//+----------------------------------------------------------------------------
//
//  Function:   SetClientInfo
//
//  Description:This function stores client informaton in the nametable
//              given a player id.
//
//  Arguments:  this - pointer to dplay object
//              pClientInfo - pointer to client info.
//              id - player id
// 
//  Returns:    DP_OK or DPERR_INVALIDPLAYER
//
//-----------------------------------------------------------------------------
HRESULT 
SetClientInfo(
    LPDPLAYI_DPLAY this, 
    LPCLIENTINFO pClientInfo,
    DPID id
    )
{
	DWORD dwUnmangledID;
    DWORD index,unique;

    // check if we got a valid id
    if (!IsValidID(this,id))
    {
        DPF_ERRVAL("Invalid player id %d - can't set security context", id);
        return DPERR_INVALIDPLAYER;
    }

    // decrypt the id
	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index > this->uiNameTableSize ) 
    {
        DPF_ERRVAL("Invalid player id %d - can't set security context", id);
        return DPERR_INVALIDPLAYER;
    }

    ASSERT(this->pNameTable[index].dwItem == NAMETABLE_PENDING);

	DPF(5,"Setting pClientInfo=0x%08x in nametable for player %d",pClientInfo,id);

	this->pNameTable[index].pvData = pClientInfo;

	return DP_OK;
} // SetClientInfo


#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveClientInfo"

HRESULT RemoveClientInfo(LPCLIENTINFO pClientInfo)
{
    HRESULT hr;

    hr = OS_DeleteSecurityContext(&(pClientInfo->hContext));
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's security context",hr);
    }

    hr = OS_CryptDestroyKey(pClientInfo->hEncryptionKey);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's encryption key",hr);
    }

    hr = OS_CryptDestroyKey(pClientInfo->hDecryptionKey);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's decryption key",hr);
    }

    hr = OS_CryptDestroyKey(pClientInfo->hPublicKey);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to remove client's public key",hr);
    }

    return DP_OK;
} // RemoveClientInfo

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveClientFromNameTable"
//+----------------------------------------------------------------------------
//
//  Function:   RemoveClientFromNameTable
//
//  Description:This function removes a player and the client info associated with 
//              it from the nametable.
//
//  Arguments:  this - pointer to dplay object
//              id - player id
// 
//  Returns:    DP_OK or DPERR_INVALIDPLAYER, or result from FreeNameTableEntry
//
//-----------------------------------------------------------------------------
HRESULT 
RemoveClientFromNameTable(
    LPDPLAYI_DPLAY this, 
    DPID dpID
    )
{
    HRESULT hr;
    LPCLIENTINFO pClientInfo=NULL;
    DWORD_PTR dwItem;

    dwItem = NameFromID(this, dpID);
    if (!dwItem)
    {
        DPF(1, "Player %d doesn't exist", dpID);
        return DPERR_INVALIDPLAYER;
    }

    ASSERT(NAMETABLE_PENDING == dwItem);

    // 
    // Cleanup client info
    //
    pClientInfo = (LPCLIENTINFO) DataFromID(this,dpID);
    if (pClientInfo)
    {
        RemoveClientInfo(pClientInfo);
        // FreeNameTableEntry below will free up the memory
    }

    //
    // Remove client from name table
    //
    hr = FreeNameTableEntry(this, dpID);
    if (FAILED(hr))
    {
        DPF(0,"Couldn't remove client %d from name table: error [0x%8x]", dpID, hr);
        return hr;
    }

    //
    // Success
    //
    return DP_OK;
} // RemoveClientFromNameTable


#undef DPF_MODNAME
#define DPF_MODNAME	"PermitMessage"
//+----------------------------------------------------------------------------
//
//  Function:   PermitMessage
//
//  Description:This function verifies if a message is safe to process
//              when the session is secure.
//
//  Arguments:  dwCommand - message type
//              dwVersion - dplay version of the sender
// 
//  Returns:    TRUE if unsigned message is ok to process, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL 
PermitMessage(
    DWORD dwCommand, 
    DWORD dwVersion
    )
{
    // don't allow any dx3 messages
    if (DPSP_MSG_DX3VERSION == dwVersion)
    {
        return FALSE;
    }

    // only allow the following messages through
    if ((dwCommand == DPSP_MSG_ENUMSESSIONS) ||
         (dwCommand == DPSP_MSG_REQUESTPLAYERID) ||
         (dwCommand == DPSP_MSG_REQUESTPLAYERREPLY) ||
         (dwCommand == DPSP_MSG_PLAYERWRAPPER) ||
         (dwCommand == DPSP_MSG_PLAYERMESSAGE) ||
         (dwCommand == DPSP_MSG_NEGOTIATE) ||
         (dwCommand == DPSP_MSG_CHALLENGE) ||
         (dwCommand == DPSP_MSG_AUTHERROR) ||        
         (dwCommand == DPSP_MSG_LOGONDENIED) ||        
         (dwCommand == DPSP_MSG_CHALLENGERESPONSE) ||
         (dwCommand == DPSP_MSG_SIGNED) ||
         (dwCommand == DPSP_MSG_PING) ||
         (dwCommand == DPSP_MSG_PINGREPLY))
    {
        return TRUE;
    }

    return FALSE;
} // PermitMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"GetMaxContextBufferSize"
//+----------------------------------------------------------------------------
//
//  Function:   GetMaxContextBufferSize
//
//  Description:This function returns the max buffer size used by the specified provider
//              for authentication tokens. First we try to get this information using
//              QuerySecurityPackageInfo() function. If it is not supported (NTLM on Win'95 Gold)
//              we query the information from a temporary context.
//
//  Arguments:  pSecDesc - pointer to security description
//              pulMaxContextBufferSize - pointer to max context buffer size 

// 
//  Returns:    DP_OK or sspi error
//
//-----------------------------------------------------------------------------
HRESULT GetMaxContextBufferSize(LPDPSECURITYDESC pSecDesc, ULONG *pulMaxContextBufferSize)
{
    SecPkgContext_Sizes spContextSizes;
    SECURITY_STATUS status;
    SecBufferDesc outSecDesc;
    SecBuffer     outSecBuffer;
    LPBYTE pBuffer=NULL;
    ULONG     fContextAttrib=0;
    TimeStamp tsExpireTime;
    CtxtHandle hContext;
    CredHandle hCredential;
    HRESULT hr;
    DWORD dwMaxBufferSize=100*1024; // we are assuming that the max size will be atmost 100K
    DWORD dwCurBufferSize=0;

    ASSERT(pulMaxContextBufferSize);

    // try to get it in the normal way
    hr = OS_QueryContextBufferSize(pSecDesc->lpszSSPIProvider, pulMaxContextBufferSize);
    if (SUCCEEDED(hr))
    {
        DPF(6,"Got a max context buffer size of %d using QuerySecurityPackageInfo",*pulMaxContextBufferSize);
        return hr;
    }

	ZeroMemory(&hContext, sizeof(CtxtHandle));
	ZeroMemory(&hCredential, sizeof(CredHandle));

    // ok, looks like we need to try harder

    // acquire an outbound credential handle so we can create a temporary context
    // on both the server as well as the client
    status = OS_AcquireCredentialsHandle(
        NULL, 
        pSecDesc->lpszSSPIProvider,
        SECPKG_CRED_OUTBOUND,
        NULL,
        NULL,
        NULL,
        NULL,
        &hCredential,
        &tsExpireTime);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Failed to get temporary credential handle: Error = 0x%08x",status);
		hr = status;
        goto CLEANUP_EXIT;
    }

    outSecDesc.ulVersion = SECBUFFER_VERSION;
    outSecDesc.cBuffers = 1;
    outSecDesc.pBuffers = &outSecBuffer;

    outSecBuffer.BufferType = SECBUFFER_TOKEN;

    DPF_ERR("Trying to create a temporary security context");

    do 
    {
        dwCurBufferSize += 1024;    // increase the buffer size in 1K increments

        DPF(6,"Trying with context buffer size %d", dwCurBufferSize);

        pBuffer = DPMEM_ALLOC(dwCurBufferSize);
        if (!pBuffer)
        {
            hr = DPERR_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }

        outSecBuffer.cbBuffer = dwCurBufferSize;
        outSecBuffer.pvBuffer = pBuffer;

        // create a temporary context so we can get the buffer sizes
        status = OS_InitializeSecurityContext(
            &hCredential,                           // phCredential
            NULL,                                   // phInContext
            NULL,                                   // pszTargetName
            DPLAY_SECURITY_CONTEXT_REQ,             // fContextReq
            0L,                                     // reserved1
            SECURITY_NATIVE_DREP,                   // TargetDataRep
            NULL,                                   // pInput
            0L,                                     // reserved2
            &hContext,                              // phNewContext
            &outSecDesc,                            // pOutput negotiate msg
            &fContextAttrib,                        // pfContextAttribute
            &tsExpireTime                           // ptsLifeTime
            );

        // get rid of the buffer
        DPMEM_FREE(pBuffer);

    } while ((SEC_E_INSUFFICIENT_MEMORY == status) && (dwCurBufferSize <= dwMaxBufferSize));

    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Failed to create temporary security context: Error = 0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
    }

    //
    // We have a security context, now query for the correct buffer size
    //
    ZeroMemory(&spContextSizes, sizeof(SecPkgContext_Sizes));

    status = OS_QueryContextAttributes(&hContext,SECPKG_ATTR_SIZES,&spContextSizes);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Could not get size attributes from package 0x%08x",status);
        hr = status;
        goto CLEANUP_EXIT;
    }

    *pulMaxContextBufferSize = spContextSizes.cbMaxToken;

    DPF(6,"Max context buffer size = %d", spContextSizes.cbMaxToken);

    // success
    hr = DP_OK;

CLEANUP_EXIT:
	OS_FreeCredentialHandle(&hCredential);
	OS_DeleteSecurityContext(&hContext);
    return hr;

} // GetMaxContextBufferSize

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupMaxSignatureSize"
//+----------------------------------------------------------------------------
//
//  Function:   SetupMaxSignatureSize
//
//  Description:This function queries the security package for max signature size
//              and stores it in the dplay object.
//
//  Arguments:  this - dplay object
// 
//  Returns:    DP_OK or DPERR_GENERIC
//
//-----------------------------------------------------------------------------
HRESULT SetupMaxSignatureSize(LPDPLAYI_DPLAY this, PCtxtHandle phContext)
{
    SecPkgContext_Sizes spContextSizes;
    SECURITY_STATUS status;

    memset(&spContextSizes, 0, sizeof(SecPkgContext_Sizes));

    //
    // query for the buffer sizes
    //
    status = OS_QueryContextAttributes(phContext,SECPKG_ATTR_SIZES,&spContextSizes);
    if (!SEC_SUCCESS(status))
    {
        DPF_ERRVAL("Could not get size attributes from package 0x%08x",status);
        return status;
    }

    this->ulMaxSignatureSize = spContextSizes.cbMaxSignature;

    // success
    return DP_OK;
} // SetupMaxSignatureSize


#undef DPF_MODNAME
#define DPF_MODNAME	"SendAccessGrantedMessage"
//+----------------------------------------------------------------------------
//
//  Function:   SendAccessGrantedMessage
//
//  Description:This function sends a signed access granted message to a client. 
//              We also piggy back the server's public key on this message.
//
//  Arguments:  this - dplay object
// 
//  Returns:    
//
//-----------------------------------------------------------------------------
HRESULT SendAccessGrantedMessage(LPDPLAYI_DPLAY this, DPID dpidTo, LPVOID pvSPHeader)
{
	LPMSG_ACCESSGRANTED pMsg=NULL;
	LPBYTE pSendBuffer=NULL;
	DWORD dwMessageSize;
	HRESULT hr;

    ASSERT(this->pSysPlayer);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ACCESSGRANTED) + this->dwPublicKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send access granted message - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pMsg = (LPMSG_ACCESSGRANTED) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pMsg);
    SET_MESSAGE_COMMAND(pMsg,DPSP_MSG_ACCESSGRANTED);
	
    pMsg->dwPublicKeyOffset = sizeof(MSG_ACCESSGRANTED);
    pMsg->dwPublicKeySize = this->dwPublicKeySize;
	
	// copy the public key data into the send buffer
	memcpy((LPBYTE)pMsg + sizeof(MSG_ACCESSGRANTED), this->pPublicKey, this->dwPublicKeySize);

	hr = SecureDoReply(this,this->pSysPlayer->dwID,dpidTo,pSendBuffer,dwMessageSize, 
		DPSEND_SIGNED|DPSEND_GUARANTEED,pvSPHeader);
	
	DPMEM_FREE(pSendBuffer);

	return hr;
} // SendAccessGrantedMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendKeysToServer"

HRESULT SendKeysToServer(LPDPLAYI_DPLAY this, HCRYPTKEY hServerPublicKey)
{
	LPMSG_KEYEXCHANGE pMsg=NULL;
	LPBYTE pSendBuffer=NULL, pEncryptionKey=NULL;
	DWORD dwMessageSize, dwEncryptionKeySize=0;
    BOOL fResult;
    DWORD dwError;
    HCRYPTKEY hEncryptionKey=0;
	HRESULT hr=DPERR_GENERIC;

    ASSERT(this->pSysPlayer);

	// create a new session key for encrypting messages to the server
	// and store its handle in the dplay object
	fResult = OS_CryptGenKey(
		this->hCSP,                                 // handle to CSP
		this->pSecurityDesc->dwEncryptionAlgorithm, // encryption algorithm
		CRYPT_EXPORTABLE/*| CRYPT_CREATE_SALT*/,    // use a random salt value
		&hEncryptionKey                             // pointer to key handle 
		);
	if (!fResult)
	{
        dwError = GetLastError();
        if (NTE_BAD_ALGID == dwError)
        {
		    DPF_ERR("Bad encryption algorithm id");
            hr = DPERR_INVALIDPARAMS;
        }
        else
        {
		    DPF_ERRVAL("Failed to create encryption key: Error=0x%08x", dwError);
        }
		goto CLEANUP_EXIT;
	}

	// export client's encryption key 
	// note - pEncryptionKey will be filled after the call - we need to free it
	hr = ExportEncryptionKey(&hEncryptionKey, hServerPublicKey, &pEncryptionKey, 
        &dwEncryptionKeySize);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to export encryption key");
		goto CLEANUP_EXIT;
	}

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_KEYEXCHANGE) + this->dwPublicKeySize + dwEncryptionKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send keys to server - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    pMsg = (LPMSG_KEYEXCHANGE) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pMsg);
    SET_MESSAGE_COMMAND(pMsg,DPSP_MSG_KEYEXCHANGE);
	
    pMsg->dwPublicKeyOffset = sizeof(MSG_KEYEXCHANGE);
    pMsg->dwPublicKeySize = this->dwPublicKeySize;
	pMsg->dwSessionKeyOffset = pMsg->dwPublicKeyOffset + pMsg->dwPublicKeySize;
	pMsg->dwSessionKeySize = dwEncryptionKeySize;
	
	// copy the key data into the send buffer
	memcpy((LPBYTE)pMsg + pMsg->dwPublicKeyOffset, this->pPublicKey, this->dwPublicKeySize);
	memcpy((LPBYTE)pMsg + pMsg->dwSessionKeyOffset, pEncryptionKey, dwEncryptionKeySize);

	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
			dwMessageSize,DPSEND_GUARANTEED,FALSE); 	
			
	if (FAILED(hr))
	{
		DPF_ERR("Message send failed");
		goto CLEANUP_EXIT;
	}

	// Success

    // remember our key
    this->hEncryptionKey = hEncryptionKey;

	// cleanup allocations
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	// free the buffer allocated by ExportEncryptionKey()
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return DP_OK;

	// not a fall through

CLEANUP_EXIT:	
	OS_CryptDestroyKey(hEncryptionKey);
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return hr;
} // SendKeysToServer


#undef DPF_MODNAME
#define DPF_MODNAME "SendKeyExchangeReply"

HRESULT SendKeyExchangeReply(LPDPLAYI_DPLAY this, LPMSG_KEYEXCHANGE pMsg, DPID dpidTo,
	LPVOID pvSPHeader)
{
	HCRYPTKEY hClientPublicKey=0, hEncryptionKey=0, hDecryptionKey=0;
	LPBYTE pEncryptionKey=NULL;
	LPBYTE pSendBuffer=NULL;
	LPMSG_KEYEXCHANGE pReply=NULL;
	DWORD dwEncryptionKeySize, dwMessageSize;
    LPCLIENTINFO pClientInfo;
    BOOL fResult;
    DWORD dwError;
	HRESULT hr=DPERR_GENERIC;

    pClientInfo = (LPCLIENTINFO)DataFromID(this,dpidTo);
    if (!pClientInfo)
    {
        DPF_ERRVAL("No client info available for %d",dpidTo);
        return hr;
    }

	// import client's public key
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwPublicKeyOffset,pMsg->dwPublicKeySize,&hClientPublicKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import client's public key\n");
		goto CLEANUP_EXIT;
	}

	// import client's encryption key (server will use this for decrypting client messages)
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwSessionKeyOffset,pMsg->dwSessionKeySize,&hDecryptionKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import client's encryption key\n");
		goto CLEANUP_EXIT;
	}


	// create a new session key for encrypting messages to this client
	fResult = OS_CryptGenKey(
		this->hCSP,                                 // handle to CSP
		this->pSecurityDesc->dwEncryptionAlgorithm, // encryption algorithm
		CRYPT_EXPORTABLE/*| CRYPT_CREATE_SALT*/,    // use a random salt value
		&hEncryptionKey                             // pointer to key handle 
		);
	if (!fResult)
	{
        dwError = GetLastError();
        if (NTE_BAD_ALGID == dwError)
        {
		    DPF_ERR("Bad encryption algorithm id");
            hr = DPERR_INVALIDPARAMS;
        }
        else
        {
		    DPF_ERRVAL("Failed to create session key: Error=0x%08x", dwError);
        }
        goto CLEANUP_EXIT;
	}

	// export server's encryption key
	hr = ExportEncryptionKey(&hEncryptionKey, hClientPublicKey, &pEncryptionKey, 
        &dwEncryptionKeySize);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to export encryption key");
		goto CLEANUP_EXIT;
	}

	// now send reply

	// message size + encryption key size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_KEYEXCHANGE) + dwEncryptionKeySize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send session key to client - out of memory");
		hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    pReply = (LPMSG_KEYEXCHANGE) (pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pReply);
    SET_MESSAGE_COMMAND(pReply,DPSP_MSG_KEYEXCHANGEREPLY);
	
	// only encryption key is sent - public key was already sent with access granted message
	pReply->dwSessionKeyOffset = sizeof(MSG_KEYEXCHANGE);
	pReply->dwSessionKeySize = dwEncryptionKeySize;
	
	// copy the key data into the send buffer
	memcpy((LPBYTE)pReply + pReply->dwSessionKeyOffset, pEncryptionKey, dwEncryptionKeySize);

	hr = SecureDoReply(this,this->pSysPlayer->dwID,dpidTo,pSendBuffer,dwMessageSize,
		DPSEND_SIGNED,pvSPHeader); 	
	if (FAILED(hr))
	{
		goto CLEANUP_EXIT;
	}

	// success

	// remember the keys
    pClientInfo->hEncryptionKey = hEncryptionKey;
    pClientInfo->hDecryptionKey = hDecryptionKey;
	pClientInfo->hPublicKey     = hClientPublicKey;

	// cleanup allocations
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hEncryptionKey);
	OS_CryptDestroyKey(hDecryptionKey);
	OS_CryptDestroyKey(hClientPublicKey);
	if (pSendBuffer) DPMEM_FREE(pSendBuffer);
	if (pEncryptionKey)	DPMEM_FREE(pEncryptionKey);

	return hr;
} // SendKeyExchangeReply


#undef DPF_MODNAME
#define DPF_MODNAME "ProcessKeyExchangeReply"

HRESULT ProcessKeyExchangeReply(LPDPLAYI_DPLAY this, LPMSG_KEYEXCHANGE pMsg)
{
	HRESULT hr;
    HCRYPTKEY hDecryptionKey=0;

	// import server's encryption key (client will use this for decrypting server messages)
	hr = ImportKey(this, (LPBYTE)pMsg+pMsg->dwSessionKeyOffset,pMsg->dwSessionKeySize,&hDecryptionKey);
	if (FAILED(hr))
	{
		DPF_ERR("Failed to import server's encryption key\n");
		goto CLEANUP_EXIT;
	}

	// we have successfully established session keys on either side. now we can start sending
	// encrypted messages.
    this->hDecryptionKey = hDecryptionKey;

	// success
	return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hDecryptionKey);

	return hr;
} // ProcessKeyExchangeReply

#undef DPF_MODNAME
#define DPF_MODNAME "GetPublicKey"

HRESULT GetPublicKey(HCRYPTPROV hCSP, HCRYPTKEY *phPublicKey, LPBYTE *ppBuffer, LPDWORD pdwBufferSize)
{
    BOOL fResult;
    LPBYTE pPublicKeyBuffer=NULL;
    HCRYPTKEY hPublicKey=0;
    DWORD dwPublicKeySize=0;
    HRESULT hr=DPERR_GENERIC;

    ASSERT(hCSP);
    ASSERT(phPublicKey);
    ASSERT(ppBuffer);
    ASSERT(pdwBufferSize);

    // create a new public/private key pair
    fResult = OS_CryptGenKey(
        hCSP,                                   // handle to CSP
        AT_KEYEXCHANGE,                         // used for key exchange
        CRYPT_CREATE_SALT,                      // use a random salt value
        &hPublicKey                             // key handle
        );

    if (!fResult)
    {
        DPF_ERRVAL("Failed to create public/private keys: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // query for the size of the buffer required
    fResult = OS_CryptExportKey(
        hPublicKey,                             // handle to the public key
        0,                                      // no destination user key
        PUBLICKEYBLOB,                          // public key type
        0,                                      // reserved field
        NULL,                                   // no buffer
        &dwPublicKeySize                        // size of the buffer
        );

    if (0 == dwPublicKeySize)
    {
        DPF_ERRVAL("Failed to get the size of the key buffer: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // allocate buffer to hold the public key
    pPublicKeyBuffer = DPMEM_ALLOC(dwPublicKeySize);
    if (!pPublicKeyBuffer)
    {
        DPF_ERR("Failed to setup public key - out of memory");
        hr = DPERR_OUTOFMEMORY;
		goto CLEANUP_EXIT;
    }

    // export key into the buffer
    fResult = OS_CryptExportKey(
        hPublicKey,                             // handle to the public key
        0,                                      // no destination user key
        PUBLICKEYBLOB,                          // public key type
        0,                                      // reserved field
        pPublicKeyBuffer,                       // buffer to store the key
        &dwPublicKeySize                        // size of the data exported
        );

    if (!fResult || !dwPublicKeySize)
    {
        DPF_ERRVAL("Failed to export the public key: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // now return the correct info
    *phPublicKey = hPublicKey;
    *ppBuffer = pPublicKeyBuffer;
    *pdwBufferSize = dwPublicKeySize;

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hPublicKey);
    if (pPublicKeyBuffer) DPMEM_FREE(pPublicKeyBuffer);
    return hr;

} // GetPublicKey

#undef DPF_MODNAME
#define DPF_MODNAME "ExportEncryptionKey"

HRESULT ExportEncryptionKey(HCRYPTKEY *phEncryptionKey, HCRYPTKEY hDestUserPubKey, 
    LPBYTE *ppBuffer, LPDWORD pdwSize)
{
    BOOL fResult;
    LPBYTE pBuffer = NULL;
    DWORD dwSize=0;
    HRESULT hr=DPERR_GENERIC;

    ASSERT(phEncryptionKey);
    ASSERT(ppBuffer);
    ASSERT(pdwSize);

    // query for the size of the buffer required
    fResult = OS_CryptExportKey(
        *phEncryptionKey,                       // handle to key being exported
        hDestUserPubKey,                        // destination user key
        SIMPLEBLOB,                             // key exchange blob
        0,                                      // reserved field
        NULL,                                   // no buffer
        &dwSize                                 // size of the buffer
        );

    if (0 == dwSize)
    {
        DPF_ERRVAL("Failed to get the size of the key buffer: Error=0x%08x",GetLastError());
        return DPERR_GENERIC;
    }

    // allocate buffer
    pBuffer = DPMEM_ALLOC(dwSize);
    if (!pBuffer)
    {
        DPF_ERR("Failed to allocate memory for key");
        return DPERR_OUTOFMEMORY;
    }

    // export key into the buffer
    fResult = OS_CryptExportKey(
        *phEncryptionKey,                       // handle to the public key
        hDestUserPubKey,                        // destination user key
        SIMPLEBLOB,                             // key exchange blob
        0,                                      // reserved field
        pBuffer,                                // buffer to store key
        &dwSize                                 // size of the buffer
        );

    if (!fResult || !dwSize)
    {
        DPF_ERRVAL("Failed to export the public key: Error=0x%08x",GetLastError());
        goto CLEANUP_EXIT;
    }

    // return the buffer and its size
    *ppBuffer = pBuffer;
    *pdwSize = dwSize;

	// don't free the encryption key buffer - caller will free it.

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
    if (pBuffer) DPMEM_FREE(pBuffer);
    return hr;

} // ExportEncryptionKey


#undef DPF_MODNAME
#define DPF_MODNAME "ImportKey"

HRESULT ImportKey(LPDPLAYI_DPLAY this, LPBYTE pBuffer, DWORD dwSize, HCRYPTKEY *phKey)
{
    BOOL fResult;
	HRESULT hr=DPERR_GENERIC;
	HCRYPTKEY hKey=0;

    ASSERT(pBuffer);
    ASSERT(phKey);

    fResult = OS_CryptImportKey(
        this->hCSP,         // handle to crypto service provider
        pBuffer,            // buffer containing exported key
        dwSize,             // size of buffer
        0,                  // sender's key
        0,                  // flags
        &hKey				// store handle the new key here
        );

    if (!fResult)
    {
        DPF_ERRVAL("Failed to import key: Error=0x%08x",GetLastError());
		goto CLEANUP_EXIT;
    }

	*phKey = hKey;

    // success
    return DP_OK;

	// not a fall through

CLEANUP_EXIT:
	OS_CryptDestroyKey(hKey);

	return hr;

} // ImportKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpthread.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       dpthread.c
*  Content:		dplay worker thread.  sends pings / enum sessions requests,
*				looks for dead players
*
*  History:
*   Date		By		Reason
*   ====		==		======
*	8/1/96		andyco	created it 
*	8/8/96		andyco	changed to call getdefaulttimeout
*	9/3/96		andyco	take an extra lock in killplayer	  
*	9/4/96		andyco	DON'T take extra locks - it's dangerous - 
*						don't need 'em
*	11/12/96	andyco	check if we're nameserver every time we go through
*						the player list.  and, when we delete someone,
*						restart at the beginning of the list.
* 	3/5/97		andyco	renamed from ping.c
*	5/23/97		kipo	Added support for return status codes
*	7/30/97		andyco	removed youaredead on getting ping from invalid player
*   8/4/97		andyco	dpthread watches add forward list on this ptr, watching
*						for add forward requests that haven't been fully ack'ed, 
*						and sending out the nametable to them.
*	1/28/98		sohailm	Added a minimum threshold to keep alive timeout.
*   2/13/98     aarono  Added flag to internal destroy player calls for async
*   4/6/98      aarono  changed killplayer to send player delete messages
*                       and do host migration if necessary.
*   5/08/98    a-peterz #22920 Reset Async EnumSession on failure and
*						always use ReturnStatus to prevent dialogs in thread
*   6/6/98      aarono  avoid protocol deadlock by sending pings async
*
***************************************************************************/

#include "dplaypr.h"
#include "..\protocol\arpstruc.h"
#include "..\protocol\arpdint.h"

// KEEPALIVE_SCALE * dwTimeout is how often we  ping
#define KEEPALIVE_SCALE 12

// reservation timeout scale
#define RESERVATION_TIMEOUT_SCALE	12

// how many consecutive unanswered pings before we nuke the player
#define UNANSWERED_PINGS_BEFORE_EXECUTION	8

// KILL_SCALE * dwTimeout is how long we wait before we nuke if we've got 
// < MINIMUM_PINGS.  Otherwise is the number of standard deviations
// off the mean that we wait before nuking
#define KILL_SCALE 25

#undef DPF_MODNAME
#define DPF_MODNAME	"... ping -- "

HRESULT SendPing(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerTo,BOOL bReply,
	DWORD dwTickCount)
{
	HRESULT hr = DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	LPMSG_PING pPing;
	DWORD dwFlags;

	ASSERT(this->pSysPlayer);
	
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PING); 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send ping - out of memory");
        return E_OUTOFMEMORY;
    }
	
	pPing = (LPMSG_PING)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pPing);

	if (bReply)
	{
		// we're sending them a ping reply
		SET_MESSAGE_COMMAND(pPing,DPSP_MSG_PINGREPLY);
		// pass them back the tick count from the ping message
		// so they can figure latency
		pPing->dwTickCount = dwTickCount;
	}
	else 
	{
		// we're generating a ping request
		// store the tick count so we can compute latency when 
		// we get reply
		// Note, in sending case, we don't have dwTickCount is 
		// not passed in.
		ASSERT(dwTickCount==0);
		SET_MESSAGE_COMMAND(pPing,DPSP_MSG_PING);
		pPing->dwTickCount = GetTickCount();
	}
	pPing->dwIDFrom = this->pSysPlayer->dwID;
   
    // send reply back to whoever sent ping
    if(this->pProtocol){
    	dwFlags = DPSEND_ASYNC|DPSEND_HIGHPRIORITY;
    } else {
    	dwFlags = 0;
    }

	hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwMessageSize,dwFlags,FALSE);
	
	if (FAILED(hr) && (hr!=DPERR_PENDING))
	{
		DPF(5, "In SendPing, SendDPMessage returned %d", hr);
	}

	DPMEM_FREE(pSendBuffer);
	
	return hr;
	
} // SendPing

// when we get a ping from someone we don't recognize, we tell that someone
// to go away and leave us alone
HRESULT  SendYouAreDead(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvMessageHeader)
{
	HRESULT hr = DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	LPMSG_SYSMESSAGE pmsg;

	ASSERT(IAM_NAMESERVER(this));
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE); 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send ping - out of memory");
        return E_OUTOFMEMORY;
    }
	
	pmsg = (LPMSG_SYSMESSAGE)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(pmsg);
	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_YOUAREDEAD);
	
	hr = DoReply(this,pSendBuffer,dwMessageSize,pvMessageHeader, 0);
	
	DPMEM_FREE(pSendBuffer);
	
	return hr;
} // SendYouAreDead

// got a ping request or reply
HRESULT HandlePing(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvMessageHeader)
{
	LPMSG_PING pPing = (LPMSG_PING)pReceiveBuffer;
	LPDPLAYI_PLAYER pPlayerFrom;
	BOOL bReply;
	HRESULT hr=DP_OK;
	DWORD dwCmd = GET_MESSAGE_COMMAND(pPing);
	
	bReply = (DPSP_MSG_PINGREPLY == dwCmd) ? TRUE : FALSE;
	
	pPlayerFrom = PlayerFromID(this,pPing->dwIDFrom);
    if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
    {
		DPF_ERR(" ACK !!! RECEIVED PING FROM INVALID (DEAD) PLAYER");
		if (IAM_NAMESERVER(this))
		{
			hr = SendYouAreDead(this,pReceiveBuffer,pvMessageHeader);
		}
		return DPERR_INVALIDPLAYER ;
    }

	if (bReply)
	{		
		// they are responding to our ping request
		DWORD dwTicks = abs(GetTickCount() - pPing->dwTickCount);
		if(dwTicks==0){
			dwTicks=5;	// resolution worst case 10ms, assume half if we can't observe.
		}
		pPlayerFrom->dwLatencyLastPing = (dwTicks/2)+1;
		DPF(4,"got ping reply from player id %d dwTicks = %d \n",pPlayerFrom->dwID,dwTicks);
		pPlayerFrom->dwUnansweredPings = 0;	// we're not really counting, just setting a threshold

	}
	else 
	{
		// they sent us a ping request
		hr = SendPing(this,pPlayerFrom,TRUE,pPing->dwTickCount);
		if (FAILED(hr))
		{
			DPF(7, "SendPing returned %d", hr);
		}
	} // reply
	
	return hr;
} // HandlePing


#undef DPF_MODNAME
#define DPF_MODNAME	"DirectPlay Worker Thread"

//
// called by KeepAliveThreadProc
// when we detect pSysPlayer is gone, we nuke him, and all of his local 
// players from the global name table
HRESULT  KillPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pSysPlayer, BOOL fPropagate)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;
	DWORD dwIDSysPlayer; // cache this for after we destroy sysplayer

	ASSERT(pSysPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);

	DPF(9,"->KillPlayer(0x%x,0x%x,%d)\n", this, pSysPlayer, fPropagate);
	DPF(1,"KillPlayer :: Killing system player id = %d\n",pSysPlayer->dwID);

	dwIDSysPlayer = pSysPlayer->dwID;
	
	// 1st destroy the sysplayer
	// we don't want to try to tell a dead sysplayer that one of their local players
	// is gone...
	DPF(9, "in KillPlayer, calling InternalDestroyPlayer (pSysPlayer = 0x%x)\n", pSysPlayer);
	hr = InternalDestroyPlayer(this,pSysPlayer,fPropagate,TRUE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	// next, destroy any players created w/ that sysplayer
	pPlayer = this->pPlayers;

	// for the record, this code is horked, not to mention broken. 
	while (pPlayer)
	{
		pPlayerNext = pPlayer->pNextPlayer;

		DPF(9, "in KillPlayer, checking player %d\n", pPlayer->dwID); 
		if (pPlayer->dwIDSysPlayer == dwIDSysPlayer)
		{
			DPF(1,"in KillPlayer, Killing player id = %d\n",pPlayer->dwID);		
			// kill player
			if(!fPropagate){
				DPF(9,"Calling QDeleteAndDestroyMessagesForPlayer\n");
				QDeleteAndDestroyMessagesForPlayer(this, pPlayer);
			}
			
			DPF(9, "in KillPlayer, calling InternalDestroyPlayer (pPlayer = 0x%x)\n", pPlayer);
			hr = InternalDestroyPlayer(this,pPlayer,fPropagate,FALSE);
			if (FAILED(hr))
			{
				DPF(0,"InternalDestroyPlayer returned err: 0x%x\n", hr);
				ASSERT(FALSE);
			}
			
			// we deleted a player, so the list may be changed go back to beginning
			pPlayerNext=this->pPlayers; 
		} 
		
		pPlayer = pPlayerNext;
	}
	
	return DP_OK;
} // KillPlayer


// when we get a session lost, the handlesessionlost routine (handler.c)
// sets a flag telling the keep alive thread to delete all remote players
HRESULT DeleteRemotePlayers(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;

	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pPlayerNext = pPlayer->pNextPlayer;
		 
		// if it's a remote player, make it go bye bye
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			hr = InternalDestroyPlayer(this,pPlayer,FALSE,TRUE);	
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		
		pPlayer = pPlayerNext;
	}

	// since we've killed all remote players, it's safe to turn 
	// of this flag (e.g. so new people could now join our game)
	this->dwFlags &= ~DPLAYI_DPLAY_SESSIONLOST;	
	return DP_OK;
	
} // DeleteRemotePlayers

// check the player list, looking for dead players, and sending pings
// if necessary
HRESULT DoPingThing(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	HRESULT hr;
	BOOL bNameServer,bCheck,bKill;
	BOOL bWeHaveCasualties = FALSE;

	if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
		return E_FAIL;
		
	if (!this->pSysPlayer)	
	{
		ASSERT(FALSE);
		return E_FAIL;
	}
		
	pPlayer = this->pPlayers;

	while (pPlayer)
	{
		ASSERT(VALID_DPLAY_PLAYER(pPlayer));
		
		bNameServer = (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) ? TRUE : FALSE;
		pPlayerNext = pPlayer->pNextPlayer;
		
		if (bNameServer || this->dwFlags & DPLAYI_DPLAY_NONAMESERVER)
		{
			bCheck = (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) 
					&& (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
					&& !(pPlayer->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)) ? TRUE : FALSE;
		}
		else 
		{
			bCheck = (pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) ? TRUE : FALSE;
		}

		if (bCheck)
		{
			BOOL	bProtocolHasChatter = FALSE;
			bKill = FALSE;			

			DPF(9, "in DoPingThing: Checking player %d\n", pPlayer->dwID);
			// a-josbor:  check chatter on the Protocol, if it's on
			if (this->pProtocol)
			{
				ASSERT(this->dwFlags & DPLAYI_DPLAY_PROTOCOL);
			}

			if (this->dwFlags & DPLAYI_DPLAY_PROTOCOL)
			{
				PSESSION     pSession = NULL;

				if (pPlayer)
				{
					pSession= GetSession((PPROTOCOL) this->pProtocol,pPlayer->dwID);

					if (pSession)
					{
						if ((pSession->RemoteBytesReceived != pPlayer->dwProtLastSendBytes) || 
							(pSession->LocalBytesReceived != pPlayer->dwProtLastRcvdBytes))
						{
							DPF(9,"Player %d not pinged because Protocol says there was traffic (%d in/%d out) since last\n",pPlayer->dwID,
								pSession->LocalBytesReceived - pPlayer->dwProtLastRcvdBytes,
								pSession->RemoteBytesReceived - pPlayer->dwProtLastSendBytes);
							pPlayer->dwProtLastSendBytes = pSession->RemoteBytesReceived;
							pPlayer->dwProtLastRcvdBytes = pSession->LocalBytesReceived;
							bProtocolHasChatter = TRUE;	
							pPlayer->dwUnansweredPings=0;
						}
						else
						{
							DPF(9,"Protocol says Player %d had no traffic\n",pPlayer->dwID);
						}
						
						DecSessionRef(pSession);	// release our reference to the session
					}
					else
					{
						DPF(7, "Unable to get Protocol Session ptr for Player %d!\n", pPlayer->dwID);
					}
				}
			}

			if (!bProtocolHasChatter) // if Protocol thinks the player hasn't sent or recvd, we should ping...
			{
				// a-josbor: Bug 15252- be more conservative about pinging.  Only do
				// 	it if we haven't heard from them since the last time we pinged
				if (pPlayer->dwChatterCount == 0)
				{
					DPF(9,"Player %d had %d unanswered pings\n", pPlayer->dwID, pPlayer->dwUnansweredPings);
					// no chatter has occurred since last time we pinged.
					bKill = (pPlayer->dwUnansweredPings >= UNANSWERED_PINGS_BEFORE_EXECUTION);

					if (bKill)
					{
						DPF(9,"Setting DEATHROW on %d because of unanswered pings!\n", pPlayer->dwID);
					
						// a-josbor: we can't kill them yet because it could
						// mess up our chatter count for other players.
						// we therefore just mark them for death, and run through
						// the list when we exit this loop
						pPlayer->dwFlags |= DPLAYI_PLAYER_ON_DEATH_ROW;
						bWeHaveCasualties = TRUE;
					}
					else 
					{
						DPF(9, "Pinging player %d\n", pPlayer->dwID);
						hr = SendPing(this,pPlayer,FALSE,0);
						if (FAILED(hr)&&hr!=DPERR_PENDING)
						{
							DPF(4, "In DoPingThing, SendPing returned %d", hr);
						}
    					DPF(6,"Player %d pinged. (%d Unanswered)\n",pPlayer->dwID, pPlayer->dwUnansweredPings);
						pPlayer->dwUnansweredPings++;
					}
				}
				else	// chatter has occurred since last ping
				{
					DPF(9,"Player %d not pinged.  Chatter == %d\n",pPlayer->dwID, pPlayer->dwChatterCount);
					pPlayer->dwChatterCount = 0;
					pPlayer->dwUnansweredPings = 0;
				}
			}
		} // bCheck
		
		pPlayer = pPlayerNext;
	}

//	a-josbor: we didn't delete in the loop above, so do it here
	if (bWeHaveCasualties)  //	we now have to service any dead players.  
	{
//		go back through the whole list, looking for the victims
		pPlayer = this->pPlayers;
		while (pPlayer)
		{
			ASSERT(VALID_DPLAY_PLAYER(pPlayer));
			pPlayerNext = pPlayer->pNextPlayer;
			if (pPlayer->dwFlags & DPLAYI_PLAYER_ON_DEATH_ROW)
			{
				DPF(9, "in DoPingThing: calling KillPlayer on %d\n", pPlayer->dwID);
				hr = KillPlayer(this,pPlayer,TRUE);
				if (FAILED(hr))
				{
					// if we had a problem killing them, unset the bit
					// so we don't keep trying
					pPlayer->dwFlags &= ~DPLAYI_PLAYER_ON_DEATH_ROW;
					ASSERT(FALSE);
				}
				// we deleted pPlayer, and all of its local players.
				// so - pNextPlayer could have been deleted.  to be safe, we restart at 
				// the beginning of the list
				pPlayerNext = this->pPlayers;
			}
			pPlayer = pPlayerNext;
		}
	}
	
	return DP_OK;
		
} // DoPingThings
							   
// figure out when to schedule next event, based on current time, last event,
// and event spacing.  (returns timeout in milliseconds suitable for passing
// to waitforsingleobject).
// called by GetDPlayThreadTimeout
DWORD GetEventTimeout(DWORD dwLastEvent,DWORD dwEventSpacing)
{
	DWORD dwCurrentTime = GetTickCount();
	
	// is it already over due?
	if ( (dwCurrentTime - dwLastEvent) > dwEventSpacing ) return 0;
	// else	return the event spacing relative to the current time
	return dwEventSpacing - (dwCurrentTime - dwLastEvent);
	
} // GetEventTimeout	

// figure out which timeout to use
DWORD GetDPlayThreadTimeout(LPDPLAYI_DPLAY this,DWORD dwKeepAliveTimeout)
{
	DWORD dwTimeout,dwAddForwardTime;
	LPADDFORWARDNODE pAddForward;
	
	if (this->dwFlags & DPLAYI_DPLAY_KEEPALIVE) 
	{
		// is there an enum too?
		if (this->dwFlags & DPLAYI_DPLAY_ENUM) 
		{
			DWORD dwKillEvent,dwEnumEvent;
			
			dwKillEvent = GetEventTimeout(this->dwLastPing,dwKeepAliveTimeout);
			dwEnumEvent = GetEventTimeout(this->dwLastEnum,this->dwEnumTimeout);
			
			dwTimeout = (dwKillEvent < dwEnumEvent) ? dwKillEvent : dwEnumEvent;
		}												
		else 
		{
			// only keep alive is running, use that
			dwTimeout = GetEventTimeout(this->dwLastPing,dwKeepAliveTimeout);
		}
	}
	else if (this->dwFlags & DPLAYI_DPLAY_ENUM) 
	{
		// only enum is running, use that 
		dwTimeout = GetEventTimeout(this->dwLastEnum,this->dwEnumTimeout);
	}
	else if(this->dwZombieCount)
	{
		dwTimeout = dwKeepAliveTimeout;
	} 
	else
	{
		// hmmm, neither enum nor keepalive is happening.
		// we'll just go to sleep until something changes
		dwTimeout = INFINITE;
	}
	
	// now, see if there's an add forward that needs handling before dwTimeout
	pAddForward = this->pAddForwardList;
	while (pAddForward)
	{
		// see how long till we give up waiting for ack's on this node and just send
		// the nametable
		dwAddForwardTime = pAddForward->dwGiveUpTickCount - GetTickCount();
		// if that's smaller than our current timeout, then we have a winner
		if ( dwAddForwardTime < dwTimeout) dwTimeout = dwAddForwardTime;
		pAddForward = pAddForward->pNextNode;
	}

	return dwTimeout;
	
} // GetDPlayThreadTimeout

void CheckAddForwardList(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer;
	LPADDFORWARDNODE pAddForward,pAddForwardNext;
	HRESULT hr;
	
	// now, see if there's an add forward that needs handling before dwTimeout
	pAddForward = this->pAddForwardList;
	while (pAddForward)
	{
		// save next node now, in case FreeAddForwardNode blows it away
		pAddForwardNext = pAddForward->pNextNode;
		if (GetTickCount() > pAddForward->dwGiveUpTickCount)
		{
			// clear doesn't have nametable from requesting player.
			pPlayer=PlayerFromID(this, pAddForward->dwIDSysPlayer);
			if(pPlayer){
				pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
			}
			DPF(0,"giving up waiting for an add forward response - sending nametable to joining client!");
		    hr = NS_HandleEnumPlayers(this, pAddForward->pvSPHeader, pAddForward->dpidFrom,
				pAddForward->dwVersion);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			
			hr = FreeAddForwardNode(this,pAddForward);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		pAddForward = pAddForwardNext;
	} 
	
} // CheckAddForwardList

//
// worker thread for dplay
// sleep for a while.  wake up and see 1.  if we need to send an enumsession request, 2. if we 
// need to send a ping and 3. if anyone has died
//
DWORD WINAPI DPlayThreadProc(LPDPLAYI_DPLAY this)
{
    HRESULT hr;
	DWORD dwKeepAliveTimeout;
	DWORD dwTimeout; // smaller of enum / keep alive timeout
	DWORD dwCurrentTime;
				
#ifdef DEBUG
	// makes for nice startup spew...
	dwKeepAliveTimeout = (KEEPALIVE_SCALE * GetDefaultTimeout( this, FALSE))/ UNANSWERED_PINGS_BEFORE_EXECUTION;
	if (dwKeepAliveTimeout < DP_MIN_KEEPALIVE_TIMEOUT) 
		dwKeepAliveTimeout = DP_MIN_KEEPALIVE_TIMEOUT;
	dwTimeout = GetDPlayThreadTimeout(this,dwKeepAliveTimeout);
	DPF(1,"starting DirectPlay Worker Thread - initial timeout = %d\n",dwTimeout);
#endif // DEBUG

 	while (1)
 	{
		// grab the latest timeouts...
		dwKeepAliveTimeout = (KEEPALIVE_SCALE * GetDefaultTimeout( this, FALSE))/ UNANSWERED_PINGS_BEFORE_EXECUTION;
		if (dwKeepAliveTimeout < DP_MIN_KEEPALIVE_TIMEOUT) 
			dwKeepAliveTimeout = DP_MIN_KEEPALIVE_TIMEOUT;
		dwTimeout = GetDPlayThreadTimeout(this,dwKeepAliveTimeout);

		WaitForSingleObject(this->hDPlayThreadEvent,dwTimeout);

		ENTER_ALL();
		
		dwCurrentTime = GetTickCount();		
		DPF(9,"DPLAY Thread woke up at t=%d", dwCurrentTime);

		// are we closed? is 'this' bogus?
		hr = VALID_DPLAY_PTR(this);
		if ( FAILED(hr) || (this->dwFlags & DPLAYI_DPLAY_CLOSED))
		{
			LEAVE_ALL();
			goto ERROR_EXIT;
		}
		
		
		// session lost?				
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			// session was lost, we need to clean up
			hr = DeleteRemotePlayers(this);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			// keep going
		}
		
		// time to send ping?
		if ((this->dwFlags & DPLAYI_DPLAY_KEEPALIVE) 
			&& (dwCurrentTime - this->dwLastPing >= dwKeepAliveTimeout))
		{
			DoPingThing(this);
			this->dwLastPing = GetTickCount();
		}

		// if we have zombies, walk the player list looking for them
		if (this->dwZombieCount > 0)
		{
			LPDPLAYI_PLAYER pPlayer,pPlayerNext;
			BOOL 			bWeHaveCasualties = FALSE;
			BOOL			bFoundZombies = FALSE;
			
			DPF(9, "We have zombies!  Walking the player list...");
			
			dwCurrentTime = GetTickCount();
			
			pPlayer = this->pPlayers;
			while (pPlayer)
			{
				ASSERT(VALID_DPLAY_PLAYER(pPlayer));
				pPlayerNext = pPlayer->pNextPlayer;
				if ((pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
					&& (pPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST))
				{
					bFoundZombies = TRUE;
					if (pPlayer->dwTimeToDie < dwCurrentTime)
					{
						pPlayer->dwFlags |= DPLAYI_PLAYER_ON_DEATH_ROW;
						bWeHaveCasualties = TRUE;
					}
				}			
				pPlayer = pPlayerNext;
			}

			// sanity
			if (!bFoundZombies)
				this->dwZombieCount = 0;
				
		//	a-josbor: we didn't delete in the loop above, so do it here
			if (bWeHaveCasualties)  //	we now have to service any dead players.  
			{
		//		go back through the whole list, looking for the victims
				pPlayer = this->pPlayers;
				while (pPlayer)
				{
					ASSERT(VALID_DPLAY_PLAYER(pPlayer));
					pPlayerNext = pPlayer->pNextPlayer;
					if (pPlayer->dwFlags & DPLAYI_PLAYER_ON_DEATH_ROW)
					{
						DPF(3, "Killing Zombie player %d", pPlayer->dwID);
						hr = KillPlayer(this,pPlayer,TRUE);
						if (FAILED(hr))
						{
							// if we had a problem killing them, unset the bit
							// so we don't keep trying
							pPlayer->dwFlags &= ~DPLAYI_PLAYER_ON_DEATH_ROW;
							ASSERT(FALSE);
						}
						else
						{
							this->dwZombieCount--;
						}
						// we deleted pPlayer, and all of its local players.
						// so - pNextPlayer could have been deleted.  to be safe, we restart at 
						// the beginning of the list
						pPlayerNext = this->pPlayers;
					}
					pPlayer = pPlayerNext;
				}
			}

		}

		// time to send an enum?		
		dwCurrentTime = GetTickCount();
		if ((this->dwFlags & DPLAYI_DPLAY_ENUM) 
			&& (dwCurrentTime - this->dwLastEnum >= this->dwEnumTimeout))
		{
			// send enum request
			// Set bReturnStatus because we can't allow dialogs from this thread - no msg pump.
			hr = CallSPEnumSessions(this,this->pbAsyncEnumBuffer,this->dwEnumBufferSize,0, TRUE);
			if (FAILED(hr) && hr != DPERR_CONNECTING) 
			{
				DPF_ERRVAL("CallSPEnumSessions failed - hr = %08lx\n",hr);

				// No more async Enum's by this service thread until the app thread
				// restarts the process.  If the connection was lost, the SP can
				// dialogs from the app thread.

				// reset the flag
				this->dwFlags &= ~DPLAYI_DPLAY_ENUM;
				// make sure we don't send an enum request when we wake up
				this->dwEnumTimeout = INFINITE;
				// free up the buffer
				DPMEM_FREE(this->pbAsyncEnumBuffer);
				this->pbAsyncEnumBuffer = NULL;
			}
			
			this->dwLastEnum = GetTickCount();	
		}
		
		// time to give up waiting for acks on an add forward, and just send the client the 
		// nametable?
		CheckAddForwardList(this);		

		// a-josbor: time to clear out the reservation count?
		if (IAM_NAMESERVER(this))
		{
			if (dwCurrentTime > this->dwLastReservationTime + 
					(GetDefaultTimeout(this, FALSE) * RESERVATION_TIMEOUT_SCALE))
			{
				this->dwPlayerReservations = 0;
				this->dwLastReservationTime = dwCurrentTime;
			}	
		}
		
		LEAVE_ALL();
	}	

ERROR_EXIT:
	DPF(1,"DPlay thread exiting");
	return 0;

}  // DPlayThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dpsecure.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpsecure.h
 *  Content:	DirectPlay security definitions.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  03/12/97    sohailm Enabled client-server security in directplay through
 *                      Windows Security Support Provider Interface (SSPI).
 *  04/14/97    sohailm Removed definitions for buffer sizes and DPLAYI_SEALED struct.
 *  05/12/97    sohailm Added prototypes for CAPI (encryption/decryption) related functions.
 *  05/22/97    sohailm Added dplay key container name.
 *  06/09/97    sohailm Made NTLM the default security package instead of DPA.
 *  06/23/97    sohailm Added function prototypes related to signing support through CAPI.
 *
 ***************************************************************************/
#ifndef __DPSECURE_H__
#define __DPSECURE_H__

#include <windows.h>
#include <sspi.h>
#include "dpsecos.h" 

// 
// Definitions
//
#define DPLAY_DEFAULT_SECURITY_PACKAGE L"NTLM" // Default security package used by directplay
#define DPLAY_KEY_CONTAINER L"DPLAY"          // key container name for use with CAPI
#define DPLAY_SECURITY_CONTEXT_REQ (ISC_REQ_CONFIDENTIALITY | \
                                    ISC_REQ_USE_SESSION_KEY | \
                                    ISC_REQ_REPLAY_DETECT)

#define SSPI_CLIENT 0
#define SSPI_SERVER 1
#define DP_LOGIN_SCALE                  5     

#define SEALMESSAGE     Reserved3             // Entry which points to SealMessage
#define UNSEALMESSAGE   Reserved4             // Entry which points to UnsealMessage

//
//  Names of secruity DLL
//

#define SSP_NT_DLL          L"security.dll"
#define SSP_WIN95_DLL       L"secur32.dll"
#define SSP_SSPC_DLL        L"msapsspc.dll"
#define SSP_SSPS_DLL        L"msapssps.dll"
#define CAPI_DLL            L"advapi32.dll"

#define SEC_SUCCESS(Status) ((Status) >= 0)

// 
// Function Prototypes
//

// dpsecure.c
extern HRESULT 
InitSecurity(
    LPDPLAYI_DPLAY
    );

extern HRESULT 
InitCAPI(
    void
    );

extern HINSTANCE
LoadSSPI (
    void
    );

extern HRESULT 
InitSSPI(
    void
    );

extern HRESULT 
LoadSecurityProviders(
    LPDPLAYI_DPLAY this,
    DWORD dwFlags
    );

extern HRESULT
GenerateAuthenticationMessage (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    ULONG       fContextReq
    );

extern HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    LPVOID pvSPHeader
    );

extern HRESULT 
SecureSendDPMessage(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock
    );

extern HRESULT 
SecureSendDPMessageEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock
    );

extern HRESULT 
SecureSendDPMessageCAPI(
    LPDPLAYI_DPLAY this,
    LPDPLAYI_PLAYER pPlayerFrom,
    LPDPLAYI_PLAYER pPlayerTo,
    LPBYTE pMsg,
    DWORD dwMsgSize,
    DWORD dwFlags,
    BOOL  bDropLock
	);

extern HRESULT 
SecureSendDPMessageCAPIEx(
    LPDPLAYI_DPLAY this,
	PSENDPARMS psp,
    BOOL  bDropLock
    );

extern HRESULT 
SecureDoReply(
    LPDPLAYI_DPLAY this,
	DPID dpidFrom,
	DPID dpidTo,
	LPBYTE pMsg,
	DWORD dwMsgSize,
	DWORD dwFlags,
	LPVOID pvSPHeader
	);

extern HRESULT
SendAuthenticationResponse (
    LPDPLAYI_DPLAY this,
    LPMSG_AUTHENTICATION pInMsg,
    LPVOID pvSPHeader
    );

extern HRESULT 
SignBuffer(
    PCtxtHandle phContext, 
    LPBYTE pMsg, 
    DWORD dwMsgSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
VerifyBuffer(
    PCtxtHandle phContext, 
    LPBYTE pMsg, 
    DWORD dwMsgSize, 
    LPBYTE pSig, 
    DWORD dwSigSize
    );

extern HRESULT 
VerifySignatureSSPI(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    );

extern HRESULT 
VerifySignatureCAPI(
    LPDPLAYI_DPLAY this,
    LPMSG_SECURE pSecureMsg
    );

extern HRESULT 
VerifyMessage(
    LPDPLAYI_DPLAY this,
    LPBYTE pReceiveBuffer,
    DWORD dwMessageSize
    );

extern HRESULT 
EncryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pBuffer, 
    LPDWORD dwBufferSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
DecryptBufferSSPI(
	LPDPLAYI_DPLAY this,
    PCtxtHandle phContext, 
    LPBYTE pData, 
    LPDWORD pdwDataSize, 
    LPBYTE pSig, 
    LPDWORD pdwSigSize
    );

extern HRESULT 
EncryptBufferCAPI(
	LPDPLAYI_DPLAY this, 
    HCRYPTKEY *phEncryptionKey,
	LPBYTE pBuffer, 
	LPDWORD pdwBufferSize
	);

extern HRESULT 
DecryptMessageCAPI(
	LPDPLAYI_DPLAY this, 
	LPMSG_SECURE pSecureMsg
	);

extern HRESULT 
Login(
    LPDPLAYI_DPLAY this
    );

extern HRESULT 
HandleAuthenticationReply(
    LPBYTE pReceiveBuffer,
    DWORD dwCmd
    );

extern HRESULT 
SetClientInfo(
    LPDPLAYI_DPLAY this, 
    LPCLIENTINFO pClientInfo,
    DPID id
    );

extern HRESULT 
RemoveClientInfo(
    LPCLIENTINFO pClientInfo
    );

extern HRESULT 
RemoveClientFromNameTable(
   LPDPLAYI_DPLAY this, 
   DWORD dwID
   );

extern BOOL 
PermitMessage(
    DWORD dwCommand, 
    DWORD dwVersion
    );

extern HRESULT 
GetMaxContextBufferSize(
    LPDPSECURITYDESC pSecDesc,
    ULONG *pulMaxContextBufferSize
    );

extern HRESULT 
SetupMaxSignatureSize(
    LPDPLAYI_DPLAY this,
    PCtxtHandle phContext
    );

extern HRESULT 
SendAccessGrantedMessage(
    LPDPLAYI_DPLAY this, 
    DPID dpidTo,
	LPVOID pvSPHeader
    );


extern HRESULT 
SendKeysToServer(
	LPDPLAYI_DPLAY this, 
	HCRYPTKEY hServerPublicKey
	);

extern HRESULT 
SendKeyExchangeReply(
	LPDPLAYI_DPLAY this, 
	LPMSG_KEYEXCHANGE pMsg, 
	DPID dpidTo,
	LPVOID pvSPHeader
	);

extern HRESULT 
ProcessKeyExchangeReply(
	LPDPLAYI_DPLAY this, 
	LPMSG_KEYEXCHANGE pMsg
	);

extern HRESULT 
GetPublicKey(
    HCRYPTPROV hCSP, 
    HCRYPTKEY *phPublicKey, 
    LPBYTE *ppBuffer, 
    LPDWORD pdwBufferSize
    );

extern HRESULT 
ExportEncryptionKey(
    HCRYPTKEY *phEncryptionKey,
	HCRYPTKEY hDestUserPubKey, 
	LPBYTE *ppBuffer, 
	LPDWORD pdwSize
	);

extern HRESULT
ImportKey(
	LPDPLAYI_DPLAY this, 
	LPBYTE pBuffer, 
	DWORD dwSize, 
	HCRYPTKEY *phKey
	);

#endif // __DPSECURE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\dvretro.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:        dvretro.c
*  Content:	 	Retrofit functions
*  History:
*
*   Date		By		Reason
*   ====		==		======
*   08/05/99	rodtoll	created it
*	08/20/99	rodtoll	Replaced in-process retrofit with lobby launch
*					    of dxvhelp.exe.
*						Added call to CoInitialize
*	08/23/99	rodtoll	Modified to match retrofit names to game session names
*   09/09/99	rodtoll	Updated with new retro launch procedure
*   09/10/99	rodtoll	Created DV_GetIDS to handle lookup of IDs.  Fixes bug with new 
*                       retrofit launch.
*               rodtoll	Adjusted guards to prevent multiple lobby launches
*				rodtoll	Added iamnameserver broadcast to catch clients that
*                       we missed notifications for after migration
*				rodtoll	Adjusted timeout in wait for thread shutdown to INFINITE
* 	10/25/99	rodtoll	Fix: Bug #114223 - Debug messages being printed at error level when inappropriate
*   11/04/99	rodtoll Fix: Calling CoUninitialize destroying dplay object too early in retrofit apps.
*						Plus closed a memory leak		
*   11/17/99	rodtoll	Fix: Bug #119585 - Connect failure cases return incorrect error codes
*   11/22/99	rodtoll	Updated case where no local player present to return DVERR_TRANSPORTNOPLAYER
 *  12/16/99	rodtoll Fix: Bug #122629 Fixed crash exposed by new host migration
*   02/15/2000	rodtoll	Fix: Bug #132715 Voice is not workin after rejoining session - Thread
*                       create was failing
*   05/01/2000  rodtoll Fix: Bug #33747 - Problems w/host migration w/old dplay.
*   06/03/2000  rodtoll Reverse integrating fixes in hawk branch for voice host migration issues
*
***************************************************************************/

#define DVF_DEBUGLEVEL_RETROFIT				2

#include <windows.h>
#include <objbase.h>
#include "dplaypr.h"
#include "dvretro.h"
#include "newdpf.h"
#include "memalloc.h"

#define GUID_STRLEN		37

#include <initguid.h>
// {D08922EF-59C1-48c8-90DA-E6BC275D5C8D}
DEFINE_GUID(APPID_DXVHELP, 0xd08922ef, 0x59c1, 0x48c8, 0x90, 0xda, 0xe6, 0xbc, 0x27, 0x5d, 0x5c, 0x8d);

extern HRESULT DV_InternalSend( LPDPLAYI_DPLAY this, DVID dvidFrom, DVID dvidTo, PDVTRANSPORT_BUFFERDESC pBufferDesc, PVOID pvUserContext, DWORD dwFlags );

// Retrieve the local IDs
//
HRESULT DV_GetIDS( LPDPLAYI_DPLAY This, DPID *lpdpidHost, DPID *lpdpidLocalID, LPBOOL lpfLocalHost )
{
	LPDPLAYI_PLAYER pPlayerWalker;
	BYTE bCount;	
	HRESULT hr = DPERR_INVALIDPLAYER;

	*lpdpidHost = DPID_UNKNOWN;
	*lpdpidLocalID = DPID_UNKNOWN;
	
	pPlayerWalker=This->pPlayers;

	bCount = 0;

	if( This->pNameServer == This->pSysPlayer )
	{
		(*lpfLocalHost) = TRUE;
	}
	else
	{
		(*lpfLocalHost) = FALSE;
	}

	while(pPlayerWalker)
	{
		if( !(bCount & 1) && ((pPlayerWalker->dwFlags & (DPLAYI_PLAYER_PLAYERLOCAL|DPLAYI_PLAYER_SYSPLAYER))==DPLAYI_PLAYER_PLAYERLOCAL))
		{
			if( pPlayerWalker->dwID == pPlayerWalker->dwIDSysPlayer )
			{
				DPF( 0, "Picking wrong ID" );			
				DebugBreak();
			}
			
			DPF( 0, "FOUND: dwID=0x%x dwSysPlayer=0x%x dwFlags=0x%x", 
				 pPlayerWalker->dwID, pPlayerWalker->dwIDSysPlayer,  pPlayerWalker->dwFlags );
				 
			*lpdpidLocalID = pPlayerWalker->dwID;
			bCount |= 1;
		}

	
		if( !(bCount & 2) && ((pPlayerWalker->dwFlags & DPLAYI_PLAYER_SYSPLAYER)==0))
		{
			if( This->pNameServer != NULL && pPlayerWalker->dwIDSysPlayer == This->pNameServer->dwID )
			{
				*lpdpidHost = pPlayerWalker->dwID;
				bCount |= 2;
			}
		}

		pPlayerWalker = pPlayerWalker->pNextPlayer;

		if( bCount == 3 )
		{
			hr = DP_OK;
			break;
		}
	}

	if( *lpdpidLocalID == DPID_UNKNOWN )
	{
		DPF( 0, "Could not find local player to bind to" );
		return DVERR_TRANSPORTNOPLAYER;
	}

	return DV_OK;
}

HRESULT DV_Retro_Start( LPDPLAYI_DPLAY This )
{
	HRESULT hr;
	BOOL fLocalHost;

	// This variable set MUST be here, otherwise optimizing 
	// compiler screws up handling of This/fLocalHost
	fLocalHost = FALSE;

	This->bCoInitializeCalled = FALSE;
	This->bHost = FALSE;	

   	hr = DV_GetIDS( This, &This->dpidVoiceHost, &This->dpidLocalID, &fLocalHost );

	if( FAILED( hr ) )
   	{
   		DDASSERT( FALSE );
   		return DPERR_INVALIDPLAYER;
   	}

	if( fLocalHost )
	{
	   	DPF( DVF_DEBUGLEVEL_RETROFIT, "DV_Retro_Start: This player is the host, launching immediately" );
		DV_RunHelper( This, This->dpidVoiceHost, fLocalHost );
	}
	else
	{
		DPF( DVF_DEBUGLEVEL_RETROFIT, "DV_Retro_Start: This player is not the host, waiting for notification" );
	}

	return DV_OK;
}

// This thread is responsible for watching the retrofit
LONG DV_Retro_WatchThread( LPVOID lpParam ) 
{
	LPDPLAYI_DPLAY This = (LPDPLAYI_DPLAY) lpParam;
	HANDLE hEventArray[2];
	LPDPLMSG_GENERIC lpdplGeneric;
	DWORD dwBufferSize;
	LPBYTE lpbBuffer;
	DWORD dwReceiveSize;
	DWORD dwMessageFlags;
	HRESULT hr;
	DVPROTOCOLMSG_IAMVOICEHOST dvMsg;
	DWORD dwResult;
	DVTRANSPORT_BUFFERDESC dvBufferDesc;	
	
	hEventArray[0] = This->hRetroMessage;
	hEventArray[1] = This->hRetroWatcherStop;

	lpbBuffer = MemAlloc( 3000 );
	dwBufferSize = 3000;

	if(!lpbBuffer){
	DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: No Memory, NOT Launching retrofit thread\n" );	
		goto THREAD_LOOP_BREAK;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Launching retrofit thread\n" );	

	while( 1 )
	{
		dwResult = WaitForMultipleObjects( 2, hEventArray, FALSE, INFINITE );
		
		if( dwResult == WAIT_TIMEOUT )
		{
			hr = GetLastError();

			DPF( 0, "RetroThread; Wait failed hr=0x%x", hr );

			break;
		}
		else if( dwResult == WAIT_FAILED ) 
		{
			hr = GetLastError();

			DPF( 0, "RetroThread; Wait failed hr=0x%x", hr );

			break;
		}
		else if( dwResult != WAIT_OBJECT_0 )
		{
			DPF( 0, "RetroThread: Exiting thread!" );

			break;
		}

		hr = DP_OK;

		DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Waking up\n" );

		while( 1 ) 
		{
			dwReceiveSize = dwBufferSize;

			hr = This->lpdplRetro->lpVtbl->ReceiveLobbyMessage( This->lpdplRetro, 0, This->dwRetroID, &dwMessageFlags, lpbBuffer, &dwReceiveSize );

			if( hr == DPERR_NOMESSAGES || hr == DPERR_APPNOTSTARTED )
			{
				DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Waking up\n" );			
				break;
			}
			else if( hr == DPERR_BUFFERTOOSMALL  )
			{
				free( lpbBuffer );
				lpbBuffer = malloc( dwReceiveSize );
				dwBufferSize = dwReceiveSize;
				continue;
			}
			else if( hr == DP_OK )
			{
				DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Got a message\n" );
				
				if( dwMessageFlags & DPLMSG_SYSTEM )
				{
					lpdplGeneric = (LPDPLMSG_GENERIC) lpbBuffer;

					DPF( DVF_DEBUGLEVEL_RETROFIT, "RetroThread: Was a system message\n" );					

					if( lpdplGeneric->dwType == DPLSYS_DPLAYCONNECTSUCCEEDED )
					{
						DPF( DVF_DEBUGLEVEL_RETROFIT, "Connection of retrofit app suceeded" );
					}
					else if( lpdplGeneric->dwType == DPLSYS_DPLAYCONNECTFAILED )
					{
						DPF( DVF_DEBUGLEVEL_RETROFIT, "Connection of retrofit failed.." );
						goto THREAD_LOOP_BREAK;
					}
					else if( lpdplGeneric->dwType == DPLSYS_NEWSESSIONHOST )
					{
						DPF( DVF_DEBUGLEVEL_RETROFIT, "This client just became the host!" );
						This->bHost = TRUE;
						This->dpidVoiceHost = This->dpidLocalID;

						dvMsg.bType = DVMSGID_IAMVOICEHOST;
						dvMsg.dpidHostID = This->dpidLocalID;
						
                        memset( &dvBufferDesc, 0x00, sizeof( DVTRANSPORT_BUFFERDESC ) );
                		dvBufferDesc.dwBufferSize = sizeof( dvMsg );
            		    dvBufferDesc.pBufferData = (PBYTE) &dvMsg;
            	    	dvBufferDesc.dwObjectType = 0;
                		dvBufferDesc.lRefCount = 1;						

						// Notify all hosts in case I missed a new player join notification
						hr = DV_InternalSend( This, This->dpidLocalID, DPID_ALLPLAYERS, &dvBufferDesc, NULL, DVTRANSPORT_SEND_GUARANTEED );

						if( hr != DPERR_PENDING && FAILED( hr ) )
						{
							DPF( DVF_DEBUGLEVEL_RETROFIT, "Failed to send notification of host migration hr=0x%x", hr );
						}
					}
				}
			}
			else
			{
				DPF( 0, "Error calling ReceiveLobbyMessage() hr = 0x%x", hr );
				goto THREAD_LOOP_BREAK;
			}
		}
	}

THREAD_LOOP_BREAK:

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit Watcher: Thread shutdown" );

	if(lpbBuffer) 
	{
		MemFree( lpbBuffer );
	}	

	SetEvent( This->hRetroWatcherDone );	

	return 0;
}

HRESULT DV_RunHelper( LPDPLAYI_DPLAY This, DPID dpidHost, BOOL fLocalHost )
{
	DPLCONNECTION dplConnection;
    LPDIRECTPLAYLOBBY lpdpLobby;	
	DPSESSIONDESC2 dpSessionDesc;
	DVTRANSPORTINFO dvTransportInfo;
	LPBYTE lpbAddress = NULL;
	DWORD dwAddressSize, dwOriginalSize;
	LPDIRECTPLAY4A lpDirectPlay4A;
	HRESULT hr;
	DWORD dwMessageFlags;
	DPNAME dpName;
	LPBYTE lpbNameBuffer = NULL;
	DWORD dwNameSize;
	HANDLE hThread;
	DWORD dwThreadID;

	if( This->bRetroActive != 0 )
	{
		DPF( 0, "Retrofit started, not restarting.." );
		return DPERR_GENERIC;
	}

	This->bRetroActive = 1;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Starting launch procedure" );

	dplConnection.dwFlags= 0;
    dplConnection.dwSize = sizeof( DPLCONNECTION );	

	if( fLocalHost )
	{
		dplConnection.dwFlags |= DPLCONNECTION_CREATESESSION;
		This->bHost = TRUE;
	}
	else
	{
		dplConnection.dwFlags |= DPLCONNECTION_JOINSESSION;
    }

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Retrieving dplay interface" );    

	// get an IDirectPlay4A interface to use
	hr = GetInterface(This,(LPDPLAYI_DPLAY_INT *) &lpDirectPlay4A,&dpCallbacks4A);
	if (FAILED(hr)) 
	{
		DPF(0,"could not get interface to directplay object. hr = 0x%08lx\n",hr);
        goto EXIT_CLEANUP;
	}

	dwAddressSize = 0;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Retrieving player address" );    	
    
	hr = lpDirectPlay4A->lpVtbl->GetPlayerAddress( lpDirectPlay4A, dpidHost, NULL, &dwAddressSize );

	if( hr != DPERR_BUFFERTOOSMALL && hr != DPERR_UNSUPPORTED )
	{
		DPF( 0, "Unable to retrieve size of host address hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Got address size" );    		

	lpbAddress = MemAlloc( dwAddressSize );

	if( lpbAddress == NULL )
	{
		DPF( 0, "Unable to allocate memory -- retrofit failure" );
		return DPERR_OUTOFMEMORY;
	}

	hr = lpDirectPlay4A->lpVtbl->GetPlayerAddress( lpDirectPlay4A, dpidHost, lpbAddress, &dwAddressSize );

	if( hr == DPERR_UNSUPPORTED )
	{
		DPF( 0, "Unable to get host's address, not supported. Sending NULL" );
		MemFree( lpbAddress );
		lpbAddress = NULL;
		dwAddressSize = 0;
	}
	else if( FAILED( hr ) )
	{
		DPF( 0, "Unable to retrieve host's address (0x%x)-- retrofit failure hr=0x%08lx", dpidHost, hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Got address" );    			

	memset( &dpSessionDesc, 0, sizeof( DPSESSIONDESC2 ) );

    dpSessionDesc.dwFlags = DPSESSION_DIRECTPLAYPROTOCOL | DPSESSION_KEEPALIVE | DPSESSION_MIGRATEHOST;
    memcpy( &dpSessionDesc.guidInstance, &GUID_NULL, sizeof( GUID ) );
    memcpy( &dpSessionDesc.guidApplication, &APPID_DXVHELP, sizeof( GUID ) );
    dpSessionDesc.dwSize = sizeof( DPSESSIONDESC2 );
    dpSessionDesc.dwMaxPlayers = 0;
    dpSessionDesc.dwCurrentPlayers = 0;
    dpSessionDesc.lpszSessionName = NULL;
    dpSessionDesc.lpszSessionNameA = NULL;
    dpSessionDesc.lpszPassword = NULL;
    dpSessionDesc.lpszPasswordA = NULL;

    dplConnection.lpSessionDesc = &dpSessionDesc;

	dwNameSize = 0;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Getting player name" );    				

	hr = lpDirectPlay4A->lpVtbl->GetPlayerName( lpDirectPlay4A, dpidHost, NULL, &dwNameSize );

	if( hr == DPERR_BUFFERTOOSMALL )
	{
		lpbNameBuffer = MemAlloc( dwNameSize );
		
		hr = lpDirectPlay4A->lpVtbl->GetPlayerName( lpDirectPlay4A, dpidHost, lpbNameBuffer, &dwNameSize );

		if( hr == DP_OK )	
		{
			DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Got player name" );    						
			dplConnection.lpPlayerName = (LPDPNAME) lpbNameBuffer;
		}
	}

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to retrieve player name.  Defaulting to none. hr=0x%x", hr );
		
		dpName.dwSize = sizeof( DPNAME );
		dpName.dwFlags = 0;
		dpName.lpszShortNameA = NULL;
		dpName.lpszLongNameA = NULL;

		dplConnection.lpPlayerName = &dpName;	
	}

    memcpy( &dplConnection.guidSP, &This->pspNode->guid, sizeof( GUID ) );

    dplConnection.lpAddress = lpbAddress;
    dplConnection.dwAddressSize = dwAddressSize;

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Creating lobby" );    						

	hr = DirectPlayLobbyCreateA( NULL, &lpdpLobby, NULL, NULL, 0);

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to create the lobby object hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Lobby created" );    							

	hr = lpdpLobby->lpVtbl->QueryInterface( lpdpLobby, &IID_IDirectPlayLobby3A, (void **) &This->lpdplRetro );

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Interface queried" );    								

	lpdpLobby->lpVtbl->Release(lpdpLobby);

	if( FAILED( hr ) )
	{
		DPF( 0, "Unable to create the lobby object hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Retrieved interface and released old" );    									

	This->hRetroMessage = CreateEventA( NULL, FALSE, FALSE, NULL );

	if( This->hRetroMessage == NULL )
	{
		hr = GetLastError();
		DPF( 0, "Retrofit: Failed to create retrofit event hr =0x%x",hr );
		goto EXIT_CLEANUP;
	}

	This->hRetroWatcherDone = CreateEventA( NULL, FALSE, FALSE, NULL );

	if( This->hRetroWatcherDone == NULL )
	{
		hr = GetLastError();
		DPF( 0, "Retrofit: Failed to create retrofit event hr =0x%x",hr );
		goto EXIT_CLEANUP;
	}

	This->hRetroWatcherStop = CreateEventA( NULL, FALSE, FALSE, NULL );

	if( This->hRetroWatcherStop == NULL )
	{
		hr = GetLastError();
		DPF( 0, "Retrofit: Failed to create retrofit event hr =0x%x",hr  );
		goto EXIT_CLEANUP;
	}


	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Running application" );	
	
	hr = This->lpdplRetro->lpVtbl->RunApplication( This->lpdplRetro, 0, &This->dwRetroID, &dplConnection, This->hRetroMessage );

	if( FAILED( hr ) )
	{
		DPF( DVF_DEBUGLEVEL_RETROFIT, "Unable to RunApplication() hr=0x%x", hr );
		goto EXIT_CLEANUP;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Application has been run!" );			


	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Launching thread!" );			

	// Start retro thread watcher.  Handles lobby communications 
	hThread = CreateThread( NULL, 0, DV_Retro_WatchThread, This, 0, &dwThreadID );

	if( !hThread )
	{
		DPF( 0, "ERROR Could not launch retrofit thread!" );
		hr = DVERR_GENERIC;
		goto EXIT_CLEANUP;
	}		

	MemFree( lpbAddress );

	DPF( DVF_DEBUGLEVEL_RETROFIT, "Retrofit: Done Launching thread!" );				

	MemFree( lpbNameBuffer );
	lpbAddress = NULL;

	lpDirectPlay4A->lpVtbl->Release(lpDirectPlay4A);	

	return DP_OK;
	
EXIT_CLEANUP:

	if( This->hRetroWatcherStop != NULL )
	{
		// Shutdown the watcher thread
		SetEvent( This->hRetroWatcherStop );
		WaitForSingleObject( This->hRetroWatcherDone, 3000 );

		CloseHandle( This->hRetroWatcherStop );
		CloseHandle( This->hRetroWatcherDone );

		This->hRetroWatcherStop = NULL;
		This->hRetroWatcherDone = NULL;
	}

	if( lpbAddress != NULL )
	{
		MemFree( lpbAddress );
	}

	if( lpbNameBuffer != NULL )
	{
		MemFree( lpbNameBuffer );
	}

	if( This->lpdplRetro != NULL )
	{
		This->lpdplRetro->lpVtbl->Release(This->lpdplRetro);
		This->lpdplRetro = NULL;
	}

	if( lpDirectPlay4A != NULL )
		lpDirectPlay4A->lpVtbl->Release(lpDirectPlay4A);

	This->bRetroActive = 0;		


	return hr;

}
	

HRESULT DV_Retro_Stop( LPDPLAYI_DPLAY This )
{
	DWORD dwTerminate = 0xFFFF;

	if( This->bRetroActive == 0 )
	{
		DPF( 0, "Retrofit not started, not stopping.." );
		return DPERR_GENERIC;
	}

	DPF( DVF_DEBUGLEVEL_RETROFIT, "RETROFIT SHUTDOWN!!" );

	if( This->lpdplRetro != NULL )
	{
		//This->lpdplRetro->lpVtbl->SendLobbyMessage( This->lpdplRetro, 0, This->dwRetroID, &dwTerminate, sizeof( DWORD ) );

		// Shutdown the watcher thread
		SetEvent( This->hRetroWatcherStop );
		WaitForSingleObject( This->hRetroWatcherDone, INFINITE );

		This->lpdplRetro->lpVtbl->Release( This->lpdplRetro );
		This->lpdplRetro = NULL;

		CloseHandle( This->hRetroWatcherStop );
		CloseHandle( This->hRetroWatcherDone );

		This->hRetroWatcherStop = NULL;
		This->hRetroWatcherDone = NULL;
	}

	if( This->bCoInitializeCalled )
		//CoUninitialize();

	This->bCoInitializeCalled = FALSE;

	This->bRetroActive = 0;

	return DP_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\enum.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       enum.c
 *  Content:	DirectPlay callbacks
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  1/96	andyco	created it
 *	3/1/96	andyco	added enum players + groups
 *	4/8/96	andyco	moved leave_dplay past callsp in enumsessions. now, only
 *					one thread at a time inside sp.
 *	5/16/96	andyco	dplay2 - internal xxx
 *	6/19/96	kipo	Bug #1960. DebugFillStringA() and DebugFillString()
 *					were not checking for NULL string parameters, which are
 *					allowed if you pass in NULL for the short or long names in
 *					a PlayerName structure.
 *					Bug #2047. Changed DP_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Bug #2013. CheckSessionDesc() was not checking for valid password
 *					pointers before doing string operations on the passwords.
 *	6/20/96	andyco	added WSTRLEN_BYTES
 *	6/22/96	andyco	added guid + password to enumsessions request
 *	6/23/96	kipo	updated for latest service provider interfaces.
 *	6/24/96	kipo	changed guidGame to guidApplication.
 *  7/8/96  ajayj   fixed up parameter ordering in callback function calls for
 *                  LPDPENUMPLAYERSCALLBACK2 and LPDPENUMSESSIONSCALLBACK2
 *  7/11/96 ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
 *  7/27/96 kipo	Bug #2682. InternalEnumPlayers() with the DPENUMPLAYERS_GROUP flag
 *					set was calling DP_EnumGroups() instead of InternalEnumGroups().
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *	8/6/96	andyco	version in commands.  extensible on the wire support.
 *	8/8/96	andyco	changed docallback to check enum flags (ENUM_LOCAL, etc.) and
 *					to check for sysplayers (moved from enumplayers).  changed
 *					internalenumxxx to check bResult from docallback.  bug 2874.
 *					modified getdefaulttimeout to be the method called by all dplay
 *					functions needing a timeout.  bug 2235,2329.
 *  8/21/96	andyco	check flags passed to enum. bug 3289
 *	8/22/96	andyco	oops.  reset dwflags when calling enumgroups from enumplayers.
 *  9/30/96 sohailm bug #3060: drop dplay lock(s) during enum callbacks
 *                  added CopySessionDesc2() and DoSessionCallbacks() functions
 *                  modified GetPlayerName() to get new strings for UNICODE instead of copying ptrs
 *  10/2/96 sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
 *                  where appropriate.
 * 10/12/96 sohailm renamed goto labels for consistency
 *                  added error checking to CopySessionDesc2()
 * 10/12/96	andyco 	don't enum sysgroup.
 * 	1/16/97 sohailm if flags are not specified to EnumSessions, now we return
 *                  only the available sessions (4491).
 *	1/15/97	andyco	added dperr_invalidgroup
 *	3/7/97	andyco	async enumsessions
 *	3/4/97	kipo	pulled nPlayers and nGroups into local variables instead of
 *					using the this pointer in InternalEnumGroups/Player/GroupPlayers
 *					so reentrancy when we drop the lock doesn't hose us.
 *	3/10/97	andyco	drop dplay + service locks b4 calling dp_close on enumplayers(session)
 *	3/12/97	myronth	lobby support for EnumSessions                  
 *	3/13/97	myronth	flagged unsupported lobby methods as such
 *  3/13/97 sohailm updated call to InternalOpenSession() to reflect changes in params.
 *	3/17/97	myronth	Removed check for lobby in EnumGroups/EnumPlayers
 *	3/20/97	myronth	Removed check for lobby in EnumGroupPlayers, use macro
 *  3/24/97 sohailm Updated DoSessionsCallback to skip filtering sessions on the client
 *                  if they are DX5 or greater
 *  3/27/97 sohailm Return an error, if players or groups in current session are enumerated
 *                  before opening the session (4973)
 *	4/2/97	myronth	EnumPlayers always returns DPERR_ACCESSDENIED for lobby connections
 *	4/7/97	myronth	EnumGroupPlayers now returns DPERR_ACESSDENIED for
 *					lobby connections with an idGroup of DPID_ALLPLAYERS, and
 *					also for EnumGroups and EnumGroupPlayers in remote sessions
 *	4/20/97	andyco	group in group 
 *	5/05/97	kipo	Added CallAppEnumSessionsCallback() to work around Outlaws bug.
 *	5/06/97	kipo	Fixed stack save/restore for non-optimized builds
 *	5/8/97	andyco	Fixed fix stack save/restore
 *	5/18/97	kipo	Updated for new flags for EnumPlayer/Groups; do better filtering
 *					for players and groups in DoCallback().
 *	5/23/97	kipo	Added support for return status codes
 *	10/21/97myronth	Added support for hidden groups
 *	10/29/97myronth	Added support for owner flag on EnumGroupPlayers
 *	11/5/97	myronth	Expose lobby ID's as DPID's in lobby sessions
 *  3/26/98 aarono  Fix InternalEnumGroupPlayers assumptions about when pPlayer
 *                  can become invalid.
 *  5/11/98 a-peterz Don't reenter async CallSPEnumSessions() (#22920)
 ***************************************************************************/

 // todo - docallback should pass copy of pvPlayerData
 // todo - do we use bContinue w/ EnumGroups / EnumPlayers?
#include "dplaypr.h"
#include <memalloc.h>

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Enum"

#ifdef DEBUG 
#define DEBUGFILLSTRINGA DebugFillStringA
#define DEBUGFILLSTRING DebugFillString
#else
#define DEBUGFILLSTRING(lpsz)
#define DEBUGFILLSTRINGA(lpsz)
#endif 

#ifdef DEBUG

void DebugFillStringA(LPSTR psz)
{
	UINT iStrLen;

	if (psz == NULL)		// null pointers are allowed
		return;

	iStrLen = STRLEN(psz);
	memset(psz,0xfe,iStrLen);
	
	return ;	
} // DebugFillStringA

void DebugFillString(LPWSTR psz)
{
	UINT iStrLen;

	if (psz == NULL)		// null pointers are allowed
		return;
	
	iStrLen = WSTRLEN_BYTES(psz);
	memset(psz,0xfe,iStrLen);
	
	return ;	
} // DebugFillString

#endif // DEBUG


// 
// fill in a playername struct for the player (or group).
// if ansi strings haven't been created yet for this player, create 'em!
// 
void GetPlayerName(LPDPLAYI_PLAYER pPlayer,LPDPNAME pName,BOOL fAnsi)
{
	memset(pName,0,sizeof(DPNAME));
	pName->dwSize = sizeof(DPNAME);

	if (fAnsi)
	{
	    GetAnsiString(&(pName->lpszShortNameA),pPlayer->lpszShortName);
		GetAnsiString(&(pName->lpszLongNameA),pPlayer->lpszLongName);
	}
	else 
	{
		GetString(&(pName->lpszShortName), pPlayer->lpszShortName);
		GetString(&(pName->lpszLongName), pPlayer->lpszLongName);
	}

	return ;
} // GetPlayerName

BOOL GetCallbackFlags(LPDPLAYI_PLAYER pPlayer, DWORD dwFlags,
					  LPDWORD lpdwCallbackFlags)
{
	DWORD	dwCallbackFlags;

	//
	// first determine if this player matches the filter criteria
	//

	// never enum system players
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		return (FALSE);
	}
	
	// they want local players
	if (dwFlags & DPENUMPLAYERS_LOCAL)
	{
		// not a local player
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			return (FALSE);
		}
	}
	
	// they want remote players
	if (dwFlags & DPENUMPLAYERS_REMOTE)
	{
		// not a remote player
		if (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			return (FALSE);
		}
	}
	
	// they want server players
	if (dwFlags & DPENUMPLAYERS_SERVERPLAYER)
	{
		// not a server player
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))
		{
			return (FALSE);
		}
	}

	// they want spectators
	if (dwFlags & DPENUMPLAYERS_SPECTATOR)
	{
		// not a spectator
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR))
		{
			return (FALSE);
		}
	}

	// they want the group owner
	if (dwFlags & DPENUMPLAYERS_OWNER)
	{
		// not the group owner
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_OWNER))
		{
			return (FALSE);
		}
	}

	// they want staging areas
	if (dwFlags & DPENUMGROUPS_STAGINGAREA)
	{
		// not a staging area
		if (!(pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA))
		{
			return (FALSE);
		}
	}

	// they want hidden groups
	if (dwFlags & DPENUMGROUPS_HIDDEN)
	{
		// not a hidden group
		if (!(pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN))
		{
			return (FALSE);
		}
	}

	//
	// now build the flags to be passed to the callback
	//

	// flags start out set to the flags passed to Enum_xxx
	dwCallbackFlags = dwFlags;

	// player is a server player
	if (pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
		dwCallbackFlags |= DPENUMPLAYERS_SERVERPLAYER;

	// player is a spectator
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR)
		dwCallbackFlags |= DPENUMPLAYERS_SPECTATOR;

	// player is the group owner
	if (pPlayer->dwFlags & DPLAYI_PLAYER_OWNER)
		dwCallbackFlags |= DPENUMPLAYERS_OWNER;

	// group is a staging area
	if (pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA)
		dwCallbackFlags |= DPENUMGROUPS_STAGINGAREA;

	// group is hidden
	if (pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN)
		dwCallbackFlags |= DPENUMGROUPS_HIDDEN;

	// return the flags to pass to the callback
	*lpdwCallbackFlags = dwCallbackFlags;
	return (TRUE);
}

/*
 ** DoCallback
 *
 *  CALLED BY:	InternalEnumPlayers,InternalEnumGroups,InternalEnumGroupPlayers
 *
 *  PARAMETERS:
 *			pPlayerOrGroup - a LPDPLAYI_GROUP or LPDPLAYI_PLAYER struct.
 *			dwFlags - flags passed to enum
 *			pvContext - app supplied context
 *			lpEnumCallback - callback fn, either LPDPENUMPLAYERSCALLBACK or
 *				LPDPENUMPLAYERSCALLBACK2.
 *			dwEnumFlags - set by caller. ENUM_2A, or ENUM_2, or ENUM_1.
 *				indicates what type of callback fn we have (which interface 
 *				we were called from).
 *			fPlayer - whether pPlayerOrGroup is a player (TRUE) or a group.
 *
 *  DESCRIPTION:
 *			figures out what type of callback we're calling. sets up the 
 *			data structs, and calls it.
 *
 *  RETURNS:
 *			BOOL - the result of the callback.
 *
 */
BOOL DoCallback(LPDPLAYI_PLAYER pPlayer,DWORD dwFlags,LPVOID pvContext,
	LPVOID lpEnumCallback,DWORD dwEnumFlags,BOOL fPlayer)
{
	HRESULT hr = DP_OK;
	BOOL bResult;
	DWORD dwCallbackFlags;

	// get flags to pass to callback. If this fails we don't
	// need to do the callback for this player
	if (!GetCallbackFlags(pPlayer, dwFlags, &dwCallbackFlags))
	{
		// don't need to call the calback
		return TRUE;
	}
	
	switch (dwEnumFlags)
	{
		case ENUM_1:
		{
			// a dplay 10 callback
			// just get the strings and call
			LPSTR lpszShortName=NULL,lpszLongName=NULL;
            DPID idPlayer;

            // make local copies of player info to pass to the app
            idPlayer = pPlayer->dwID;
			GetAnsiString(&(lpszShortName),pPlayer->lpszShortName);
			GetAnsiString(&(lpszLongName),pPlayer->lpszLongName);

            // drop the locks 
			LEAVE_ALL();

            // call the app
			bResult = ((LPDPENUMPLAYERSCALLBACK)lpEnumCallback)(idPlayer,lpszShortName,
					lpszLongName,dwCallbackFlags,pvContext);

            // reacquire locks
			ENTER_ALL();

			DEBUGFILLSTRINGA(lpszShortName);
			DEBUGFILLSTRINGA(lpszLongName);

			if (lpszShortName) DPMEM_FREE(lpszShortName);
			if (lpszLongName) DPMEM_FREE(lpszLongName);
			
			// we're done here...
			return bResult;
		}
		
		case ENUM_2:
		case ENUM_2A:
        {
        	DPNAME PlayerName;
	        BOOL fAnsi;
            DPID idPlayer;

			// need to get a player (or group) data 
			fAnsi = (ENUM_2A == dwEnumFlags) ? TRUE : FALSE;

            // make local copies of player info to pass to the app
            idPlayer = pPlayer->dwID;
			GetPlayerName(pPlayer,&PlayerName,fAnsi);

            // drop the locks
			LEAVE_ALL();

			// call the app
			bResult = ((LPDPENUMPLAYERSCALLBACK2)lpEnumCallback)(idPlayer,fPlayer,
				&PlayerName,dwCallbackFlags,pvContext);

            // reacquire locks
			ENTER_ALL();

			// free the strings
			if (PlayerName.lpszShortNameA) DPMEM_FREE(PlayerName.lpszShortNameA);
			if (PlayerName.lpszLongNameA) DPMEM_FREE(PlayerName.lpszLongNameA);

			break;
        }

		default:
			bResult=FALSE; // never happens, but lets make prefix happy.
			ASSERT(FALSE);
			break;
	}
	
	return bResult;

} //DoCallback

/*
 ** EnumJoinSession
 *
 *  CALLED BY: InternalEnumPlayers,InternalEnumGroups
 *
 *  PARAMETERS:
 *			this - this ptr
 *			pGuid - instance guid of session to join
 *
 *  DESCRIPTION:
 *			finds a session, calls open on it.
 * 			called before enuming w/ DPENUMPLAYERS_SESSION
 * 			while we're trying to enum the players in a different session
 * 					*** ASSUMES SERVICE LOCK + DPLAY LOCK TAKEN ***
 * 			 		*** ASSUMES DPLAY LOCK COUNT IS @ 1 ***
 *
 *  RETURNS:   OpenSession hr, or  DPERR_NOSESSIONS if no matching
 *			session is available
 *
 */
HRESULT EnumJoinSession(LPDPLAYI_DPLAY this,LPGUID pGuid)
{
	LPSESSIONLIST pSession;
	HRESULT hr=DP_OK;

	if (this->lpsdDesc) 
	{
		DPF_ERR("DPENUMPLAYERS_SESSION flag set when session already open!");
		return E_FAIL;
	}

	pSession = FindSessionInSessionList(this,pGuid);	
	if (!pSession) 
	{
		DPF_ERR("could not find matching session to open");
		return DPERR_NOSESSIONS;
	}

	hr = InternalOpenSession(this,&(pSession->dpDesc),TRUE,DPOPEN_JOIN,FALSE,NULL,NULL);

	if (FAILED(hr)) 
	{	
		DPF(0,"enum sessions - could not open session - hr = 0x%08lx\n",hr);
		return hr;
	}

	return DP_OK;
}  // EnumJoinSession

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroupsInGroup"

// struct used to store group id's + flags while we drop locks
typedef struct 
{
	DPID 	id;
	DWORD	dwFlags;
} DPIDANDFLAGS,*LPDPIDANDFLAGS;

HRESULT DPAPI InternalEnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_SUBGROUP pSubgroup;
	BOOL bResult=TRUE;
    LPDPIDANDFLAGS pIDArray;
	DWORD nSubgroups;
	LPDPLAYI_GROUP pGroupEnum; // group passed to docallback
    UINT i;
	DWORD dwCallbackFlags; // flags we pass to callback
	
	DPF(5,"got enum GroupsInGroups ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		// If this is a lobby object, we don't allow DPID_ALLPLAYERS
		if(IS_LOBBY_OWNED(this) && (idGroup == DPID_ALLPLAYERS))
		{
			DPF_ERR("Enumerating all players is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// If this is a lobby object, we don't allow enumeration
		// of group players in the remote session
		if(IS_LOBBY_OWNED(this) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating group players in a remote session is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// system group not allowed
		if (0 == idGroup)
		{
			DPF_ERR( "Invalid group ID" );
			return DPERR_INVALIDGROUP;
		}

		// verify group ID if we're not enuming a remote session
		if (!(DPENUMPLAYERS_SESSION & dwFlags))
		{
			pGroup = GroupFromID(this,idGroup);
			if (!VALID_DPLAY_GROUP(pGroup)) 
			{
				DPF_ERR( "Invalid group ID" );
				return DPERR_INVALIDGROUP;
			}
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags 
		if (!VALID_ENUMGROUPS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDFLAGS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// enuming a remote session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
		pGroup = GroupFromID(this,idGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			hr = DPERR_INVALIDGROUP;
			goto CLEANUP_EXIT;
		}
	} // sessions

    // any players to enumerate ?
    if (!pGroup->pSubgroups || (0 == pGroup->nSubgroups))
    {
        // no players to enumerate
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(pGroup->nSubgroups * sizeof(DPIDANDFLAGS));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pSubgroup = pGroup->pSubgroups;
	nSubgroups = pGroup->nSubgroups;
    for (i=0; i < nSubgroups; i++)
    {
        ASSERT(pSubgroup);
        pIDArray[i].id = pSubgroup->pGroup->dwID;
		pIDArray[i].dwFlags = pSubgroup->dwFlags; // e.g.  DPGROUP_SHORTCUT
        pSubgroup = pSubgroup->pNextSubgroup;
    }

    // walk through the group calling by player
    for (i=0; (i < nSubgroups ) && bResult; i++)
    {        
        pGroupEnum = GroupFromID(this, pIDArray[i].id);
        // player could have been deleted while we dropped the locks
        if (VALID_DPLAY_GROUP(pGroupEnum))
        {
			// they want shortcuts
			if (dwFlags & DPENUMGROUPS_SHORTCUT)
			{
				// this is not a shortcut, so skip calling them back
				if (!(pIDArray[i].dwFlags & DPGROUP_SHORTCUT))
					continue;
			}

			// start with flags passed in
			dwCallbackFlags = dwFlags;

			// set shortcuts flag
			if (pIDArray[i].dwFlags & DPGROUP_SHORTCUT)
				dwCallbackFlags |= DPENUMGROUPS_SHORTCUT;

			bResult = DoCallback((LPDPLAYI_PLAYER)pGroupEnum, dwCallbackFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,FALSE);
        }
    }

    // free the list of player ids
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through
CLEANUP_EXIT:

    if (DPENUMPLAYERS_SESSION & dwFlags)  
	{
		LEAVE_ALL();		
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

} // InternalEnumGroupsInGroup

HRESULT DPAPI DP_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();
	
	hr = InternalEnumGroupsInGroup(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupsInGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroupPlayers"

HRESULT DPAPI InternalEnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags, DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	LPDPLAYI_GROUPNODE pGroupnode;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nPlayers;
    LPDPLAYI_PLAYER pPlayer;
    UINT i;
	DPID dwGroupOwnerID;
	
	DPF(5,"got enum groupplayerss ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		// If this is a lobby object, we don't allow DPID_ALLPLAYERS
		if(IS_LOBBY_OWNED(this) && (idGroup == DPID_ALLPLAYERS))
		{
			DPF_ERR("Enumerating all players is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// If this is a lobby object, we don't allow enumeration
		// of group players in the remote session
		if(IS_LOBBY_OWNED(this) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating group players in a remote session is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		// system group not allowed
		if (0 == idGroup)
		{
			DPF_ERR( "Invalid group ID" );
			return DPERR_INVALIDGROUP;
		}

		// verify group ID if we're not enuming a remote session
		if (!(DPENUMPLAYERS_SESSION & dwFlags))
		{
			pGroup = GroupFromID(this,idGroup);
			if (!VALID_DPLAY_GROUP(pGroup)) 
			{
				DPF_ERR( "Invalid group ID" );
				return DPERR_INVALIDGROUP;
			}
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags 
		if (!VALID_ENUMGROUPPLAYERS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// enuming a remote session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
		pGroup = GroupFromID(this,idGroup);
		if (!VALID_DPLAY_GROUP(pGroup)) 
		{
			DPF_ERR( "Invalid group ID" );
			hr = DPERR_INVALIDGROUP;
			goto CLEANUP_EXIT;
		}
	} // sessions

    // any players to enumerate ?
    if (!pGroup->pGroupnodes || (0 == pGroup->nPlayers))
    {
        // no players to enumerate
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(pGroup->nPlayers * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pGroupnode = pGroup->pGroupnodes;
	nPlayers = pGroup->nPlayers;
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pGroupnode);
        pIDArray[i] = pGroupnode->pPlayer->dwID;
        pGroupnode=pGroupnode->pNextGroupnode;
    }

	// we snapshot the owner here, because it could go away during the callbacks.
	dwGroupOwnerID = pGroup->dwOwnerID;

    // walk through the group calling by player
    for (i=0; (i < nPlayers ) && bResult; i++)
    {        
		// player could have been deleted while we dropped the locks
        pPlayer = PlayerFromID(this, pIDArray[i]);

		if(pPlayer){

			// We need to see if this player is the group's owner, if it is,
			// temporarily set the internal owner flag so the external one
			// gets set correctly in the callback
			if(pPlayer->dwID == dwGroupOwnerID)
				pPlayer->dwFlags |= DPLAYI_PLAYER_OWNER;
			
		    bResult = DoCallback(pPlayer, dwFlags, pvContext, lpEnumCallback, 
				                    dwEnumFlags,TRUE);

			// need to reacquire the pointer since we dropped the locks on callback.
			pPlayer = PlayerFromID(this, pIDArray[i]);
			if(pPlayer){
				// Clear the temporary owner flag (which will never be set
				// unless we did it above)
				pPlayer->dwFlags &= ~(DPLAYI_PLAYER_OWNER);
			}	
		}
    }

    // free the list of player ids
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through
CLEANUP_EXIT:

    if (DPENUMPLAYERS_SESSION & dwFlags)  
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

}//DP_EnumGroupPlayers

HRESULT DPAPI DP_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();	
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumGroups"
HRESULT DPAPI InternalEnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_GROUP pGroup;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nGroups;
    UINT i;
	
	DPF(5,"got enum groups ***");
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}
		// EnumGroups in a remote session is not allowed for lobby connections
		if((IS_LOBBY_OWNED(this)) && (DPENUMPLAYERS_SESSION & dwFlags))
		{
			DPF_ERR("Enumerating groups in a remote lobby session is not supported");
			return DPERR_ACCESSDENIED;
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags
		if (!VALID_ENUMGROUPS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// do we need to open a session
	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
	} // sessions
    else
    {   // they are trying to enumerate groups in current sesion. 
        if (!this->lpsdDesc) return DPERR_NOSESSIONS;
    }
	
	// how many top-level groups}
	nGroups =0;
	pGroup = this->pGroups;
	while (pGroup)
	{
		if (0 == pGroup->dwIDParent) nGroups++;
		pGroup = pGroup->pNextGroup;
	}
	
    // are there any groups to enumerate ?
    if (0 == nGroups)
    {
        // no groups
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for the array of group ids
    pIDArray = DPMEM_ALLOC(nGroups * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current group ids
    pGroup = this->pGroups;
	i = 0;
	while (pGroup && (i < nGroups))
	{
        if (0 == pGroup->dwIDParent) 
        {
        	pIDArray[i] = pGroup->dwID;
			i++;
        }
        pGroup=pGroup->pNextGroup;
    }

    // call user for every valid group
    for (i=0; (i < nGroups) && bResult; i++)
    {        
        pGroup = GroupFromID(this, pIDArray[i]);
        // group could have been deleted while we dropped the locks
        if (pGroup && !(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
        {
		    bResult = DoCallback((LPDPLAYI_PLAYER)pGroup, dwFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,FALSE);
        }
    }

    // free the list
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

    // fall through

CLEANUP_EXIT:

	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;

}//InternalEnumGroups


HRESULT DPAPI DP_EnumGroups(LPDIRECTPLAY lpDP,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();

	hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2);

	LEAVE_ALL();
	
	return hr;

}  // DP_EnumGroups

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumPlayers"
HRESULT DPAPI InternalEnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid,
	LPVOID lpEnumCallback,LPVOID pvContext,DWORD dwFlags,DWORD dwEnumFlags) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_PLAYER pPlayer;
	BOOL bResult=TRUE;
    LPDPID pIDArray;
	DWORD nPlayers;
    UINT i;
		
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		// This call should always return DPERR_ACCESSDENIED for
		// lobby connections
		if(IS_LOBBY_OWNED(this))
		{
			DPF_ERR("EnumPlayers is not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}

		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}
		if (pGuid && !VALID_READ_GUID_PTR(pGuid))
		{
		    DPF_ERR( "Invalid session id" );
		    return DPERR_INVALIDPARAMS;
		}
		// make sure they don't pass us a bogus guid
		if ( (DPENUMPLAYERS_SESSION & dwFlags ) && !pGuid )
		{
			DPF_ERR("passed bogus guid w/ DPENUMPLAYERS_SESSION");
			return DPERR_INVALIDPARAMS;
		}

		// check flags
		if (!VALID_ENUMPLAYERS_FLAGS(dwFlags))
		{
			DPF_ERR("passed invalid flags");
			return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	if ( DPENUMPLAYERS_SESSION & dwFlags )
	{
		if (this->lpsdDesc) 
		{
			DPF_ERR("can't enumplayers_session - session already open");
			return E_FAIL;
		}
		hr = EnumJoinSession(this,pGuid);
		if (FAILED(hr)) 
		{
			DPF_ERR("could not join remote session");
			return hr;
		}
	} // sessions
    else
    {   // they are trying to enumerate players in current sesion. 
        if (!this->lpsdDesc) return DPERR_NOSESSIONS;
    }

    // any players to enumerate ?
    if (!this->pPlayers || (0==this->lpsdDesc->dwCurrentPlayers))
    {
        hr = DP_OK;
        goto CLEANUP_EXIT;
    }

    // allocate memory for array of player ids
    pIDArray = DPMEM_ALLOC(this->nPlayers * sizeof(DPID));
    if (!pIDArray)
    {
        hr = DPERR_OUTOFMEMORY;
        goto CLEANUP_EXIT;
    }

    // fill in current player ids
    pPlayer = this->pPlayers;
	nPlayers = this->nPlayers;
    for (i=0; i < nPlayers; i++)
    {
        ASSERT(pPlayer);
        pIDArray[i] = pPlayer->dwID;
        pPlayer=pPlayer->pNextPlayer;
    }

    // iterate over the player id array, calling the app for every valid player
    for (i=0; (i < nPlayers) && bResult; i++)
    {        
        pPlayer = PlayerFromID(this, pIDArray[i]);
        // player could have been deleted while we dropped the locks
        if (pPlayer)
        {
		    bResult = DoCallback(pPlayer, dwFlags, pvContext, lpEnumCallback, 
			                    dwEnumFlags,TRUE);
        }
    }

    // free the list
    if (pIDArray) 
    {
        DPMEM_FREE(pIDArray);
    }

	if (dwFlags & DPENUMPLAYERS_GROUP) 
	{
		DWORD dwStrippedFlags; // flags to pass to internalenumgroups
	
		// reset flags - DPENUMPLAYERS_GROUP, DPENUMPLAYERS_SERVERPLAYER, DPENUMPLAYERS_SPECTATOR
		// is illegal to pass to InternalEnumGroups, and if DPENUMPLAYERS_SESSION is set,
		// we've already joined the session
		dwStrippedFlags = dwFlags & ~(DPENUMPLAYERS_GROUP |
									  DPENUMPLAYERS_SESSION |
									  DPENUMPLAYERS_SERVERPLAYER |
									  DPENUMPLAYERS_SPECTATOR);
		hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,
			dwStrippedFlags, dwEnumFlags);
	}

    // fall through
CLEANUP_EXIT:

	if (DPENUMPLAYERS_SESSION & dwFlags )  
	{
		LEAVE_ALL();
		
		DP_Close(lpDP);
		
		ENTER_ALL();
	}

    return hr;
        
}//InternalEnumPlayers


HRESULT DPAPI DP_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2);

	LEAVE_ALL();

	return hr;

}//DP_EnumPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnumSessions"
// make sure the user desc, and the desc found by enum, match 
// if fEnumAll is set, don't check passwords or player counts
HRESULT CheckSessionDesc(LPDPSESSIONDESC2 lpsdUser,LPDPSESSIONDESC2 lpsdSession,
	DWORD dwFlags,BOOL fAnsi)
{
	int iStrLen;

	// if we don't care about guids, passwords, open slots and enable new players, we're done
	if (dwFlags & DPENUMSESSIONS_ALL) return DP_OK;

	// 1st, check the guids
	if (!IsEqualGUID(&(lpsdUser->guidApplication),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(lpsdUser->guidApplication),&(lpsdSession->guidApplication))) 
		{
			return E_FAIL;
		}
	}

	// if we don't care about passwords, open slots and enable new players, we're done
	if (!(dwFlags & DPENUMSESSIONS_AVAILABLE)) return DP_OK;
	
	// next, check current users
	if (lpsdSession->dwMaxPlayers) 
	{
		if (lpsdSession->dwCurrentPlayers >= lpsdSession->dwMaxPlayers)  
		{
			return E_FAIL;
		}
	}
	
	// check the password if the session has one
	if (lpsdSession->lpszPassword)
	{
		iStrLen = fAnsi ? STRLEN(lpsdSession->lpszPasswordA) : 
						  WSTRLEN(lpsdSession->lpszPassword);
		if (iStrLen)
		{
			int iCmp;

			if (lpsdUser->lpszPassword)	// make sure there is a password
			{
				iCmp = fAnsi ? strcmp(lpsdSession->lpszPasswordA,lpsdUser->lpszPasswordA) :
							   WSTRCMP(lpsdSession->lpszPassword,lpsdUser->lpszPassword);
				if (0 != iCmp) return E_FAIL;
			}
			else
				return E_FAIL;			// no password in description, so bail
		}
	}

	// finally, check players enabled
	if (lpsdSession->dwFlags & DPSESSION_NEWPLAYERSDISABLED) return E_FAIL;
	
	if (lpsdSession->dwFlags & DPSESSION_JOINDISABLED) return E_FAIL;

	
	return DP_OK;
} // CheckSessionDesc

// called by InternalEnumSessions, KeepAliveThreadProc, GetNameTable 
// and GetNewPlayerID.  Calls GetCaps get the latency.
// tries for guaranteed, falls back to unreliable or default as necessary.
DWORD GetDefaultTimeout(LPDPLAYI_DPLAY this,BOOL fGuaranteed)
{
	DPCAPS caps;
	HRESULT hr;

	memset(&caps,0,sizeof(caps));
	caps.dwSize = sizeof(caps);

	if (fGuaranteed)
	{
		// call idirectplay::getcaps.  see what it has to say...
		hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,DPGETCAPS_GUARANTEED);
		if (SUCCEEDED(hr))
		{
			if (caps.dwTimeout) return caps.dwTimeout;
			// else 
			goto RETURN_DEFAULT; 
		}
		// else, fall through and try not guaranteed		
	}

	hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return DP_DEFAULT_TIMEOUT;
	}
	
	if (caps.dwTimeout){
		if(caps.dwTimeout >= 1000) {
			return caps.dwTimeout;
		} else {
			return 1000;
		}	
	}	

	// else 
RETURN_DEFAULT:

	// they returned success, but didn't set the caps
	DPF(0,"error - SP not returning valid timeout. Using DPlay default = %d\n",DP_DEFAULT_TIMEOUT);
	return DP_DEFAULT_TIMEOUT;

} // GetDefaultTimeout

// called by internalenumsessions, and by dplaythreadproc
HRESULT CallSPEnumSessions(LPDPLAYI_DPLAY this,LPVOID pBuffer,DWORD dwMessageSize,
	DWORD dwTimeout, BOOL bReturnStatus)
{
	DPSP_ENUMSESSIONSDATA ed;
	HRESULT hr;
	   
	if (!this->pcbSPCallbacks->EnumSessions) 
	{
		DPF_ERR("SP NOT IMPLEMENTING REQUIRED ENUMSESSIONS ENTRY");
		ASSERT(FALSE);
		return E_NOTIMPL;
	}
   
   	ASSERT(pBuffer);
	
   	ed.lpMessage = pBuffer;
	ed.dwMessageSize = dwMessageSize;
	ed.lpISP = this->pISP;
	ed.bReturnStatus = bReturnStatus;
	hr = CALLSP(this->pcbSPCallbacks->EnumSessions,&ed); 
	if (FAILED(hr)) 
	{
		if (hr != DPERR_CONNECTING)
			DPF(0,"enum failed - hr = %08lx\n",hr);
		return hr;
	}

	if (!dwTimeout) return DP_OK; // all done
	
	// we leave dplay so that the sp can get inside dp (in handler.c) w/
	// any responses    
	
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	
	LEAVE_DPLAY();
	Sleep(dwTimeout);
	ENTER_DPLAY();
	
	return DP_OK;
	
} // CallSPEnumSessions
	
HRESULT StopEnumThread(LPDPLAYI_DPLAY this)
{
	if (!(this->dwFlags & DPLAYI_DPLAY_ENUM))
	{
		DPF_ERR("COULD NOT STOP ASYNC ENUM - IT'S NOT RUNNING");
		return E_FAIL;
	}
	
	// stop the async thread.
	// mark dplay as being not enum'ing
	this->dwFlags &= ~DPLAYI_DPLAY_ENUM;
	// make sure it doesn't send an enum request when we wake it up
	this->dwEnumTimeout = INFINITE;
	
	// free up the buffer
	ASSERT(this->pbAsyncEnumBuffer);
	DPMEM_FREE(this->pbAsyncEnumBuffer);
	this->pbAsyncEnumBuffer = NULL;

	// set the worker threads event, so it picks up the new timeout
	SetEvent(this->hDPlayThreadEvent);

	// we're done
	return DP_OK;

}  // StopEnumThread	

/*
 ** InternalEnumSessions
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions and DP_1_EnumSessions
 *
 *  PARAMETERS: lpDP - idirectplay(2,2a) interface pointer
 *				lpsdDesc - session desc - validated only
 *				dwTimeout - how long to wait for responses
 *				lpEnumCallback - callback pointer - validate only
 *				dwFlags - flags passed to DP_X_EnumSessions - unused so far...
 *				dwEnumFlags - set by caller. ENUM_2A, or ENUM_2, or ENUM_1.
 *					indicates what type of session desc we have
 *
 *  DESCRIPTION:  calls service provider for enum sessions, and waits for responses
 *					*** ASSUMES SERVICE + DPLAY LOCKS TAKEN ***
 *					*** ASSUMES DPLAY LOCK COUNT IS AT 1 ***
 *
 *  RETURNS: E_OUTOFMEMORY, or SP hresult from sp_enumsessions
 *
 */
HRESULT DPAPI InternalEnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,
	DWORD dwTimeout,LPVOID lpEnumCallback,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    BOOL bContinue=TRUE;
	LPBYTE pBuffer; // buffer we're going to send
    LPMSG_ENUMSESSIONS pmsg; // cast from pBuffer
	DWORD dwMessageSize;
	UINT nPasswordLen; // password length, in bytes
	BOOL bReturnStatus; // true to override dialogs and return status

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc)) 
		{
		    DPF_ERR( "Invalid session description" );
		    return DPERR_INVALIDPARAMS;
		}
		// check strings
		if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
			WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
			WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		// check callback
		if( !VALIDEX_CODE_PTR( lpEnumCallback ) )
		{
		    DPF_ERR( "Invalid callback routine" );
		    return DPERR_INVALIDPARAMS;
		}

		if (!VALID_ENUMSESSIONS_FLAGS(dwFlags))
		{
		    DPF_ERR( "Invalid flags" );
		    return DPERR_INVALIDPARAMS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// note - andyco - we may want to lift this restriction...
	if (this->lpsdDesc)
	{
		DPF_ERR("can't enum sessions - session already open");
		return E_FAIL;
	}

	if ( !(dwFlags & (DPENUMSESSIONS_NOREFRESH | DPENUMSESSIONS_ASYNC)) ) 
	{
		FreeSessionList(this);		
	}

	// if this is a lobby-owned object, call the lobby code
	if(IS_LOBBY_OWNED(this))
	{
		ASSERT(1 == gnDPCSCount); // when we drop locks - this needs to go to 0!

		// REVIEW!!!! -- Is there a way we can keep from having to drop the lock
		// here??? What are the ramifications of doing so???  Can we potentially
		// cause a crash when the user comes back in???

		// We need to drop the lock for the lobby since it may call
		// EnumSessions on another DPlay object (like dpldplay does).
		LEAVE_DPLAY();
		hr = PRV_EnumSessions(this->lpLobbyObject, lpsdDesc, dwTimeout, dwFlags);
		ENTER_DPLAY();
		return hr;
	}

	// if app wants async, and our async thread is already running, we're done
	if  ( (dwFlags & DPENUMSESSIONS_ASYNC ) && (this->dwFlags & DPLAYI_DPLAY_ENUM) )
	{
		// we'll let whatever interface they called on just walk the list
		return DP_OK;
	}
	
	if (dwFlags & DPENUMSESSIONS_STOPASYNC)
	{
		hr = StopEnumThread(this);
		return hr;
	}
	
	// Are we already in a call to the SP's EnumSession?
	if  (this->dwFlags & DPLAYI_DPLAY_ENUMACTIVE)
	{
		// App must be doing async and SP may have a connection dialog up
		return DPERR_CONNECTING;
	}
	
	nPasswordLen = WSTRLEN_BYTES(lpsdDesc->lpszPassword);
													
	// message size + blob size + password size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ENUMSESSIONS);
	dwMessageSize += nPasswordLen;

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_ENUMSESSIONS)(pBuffer + this->dwSPHeaderSize);
	// set up msg
    SET_MESSAGE_HDR(pmsg);
    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ENUMSESSIONS);
	pmsg->guidApplication = lpsdDesc->guidApplication;
    pmsg->dwFlags = dwFlags;
	
	if (nPasswordLen)
	{
		pmsg->dwPasswordOffset = sizeof(MSG_ENUMSESSIONS);
		// copy over password
		memcpy((LPBYTE)pmsg+sizeof(MSG_ENUMSESSIONS),lpsdDesc->lpszPassword,nPasswordLen);
	} 
	else
	{
		pmsg->dwPasswordOffset = 0;
	}

	// if the app doesn't want to guess on a timeout, we'll "do
	// the right thing"
	if (0 == dwTimeout) dwTimeout = GetDefaultTimeout(this,TRUE);

	// app can request that the SP not display any status
	// dialogs while enumerating by setting this flag. The SP
	// will return status codes while enumeration is in progress

	bReturnStatus = (dwFlags & DPENUMSESSIONS_RETURNSTATUS) ? TRUE : FALSE; 

	// if it's an async all, startup the async thread
	if (dwFlags & DPENUMSESSIONS_ASYNC)
	{
		// it's async
		// call the sp, so it can do its dialog thing syncro, but don't block waiting
		// on replies
		this->dwFlags |= DPLAYI_DPLAY_ENUMACTIVE;
		hr = CallSPEnumSessions(this,pBuffer,dwMessageSize,0, bReturnStatus);
		this->dwFlags &= ~DPLAYI_DPLAY_ENUMACTIVE;
		if (FAILED(hr)) 
		{
			goto ERROR_EXIT;
		}

		// set up the worker thread
		this->dwEnumTimeout = dwTimeout;
		this->dwLastEnum = GetTickCount(); // just sent one above
		this->dwFlags |= DPLAYI_DPLAY_ENUM;
		this->pbAsyncEnumBuffer = pBuffer;
		this->dwEnumBufferSize = dwMessageSize;
		// StartDPlayThread will either start the thread, or signal it
		// that something new is afoot
		StartDPlayThread(this,FALSE);
	}
	else 
	{
		// it's not async
		// call the sp and block waiting for a response
		this->dwFlags |= DPLAYI_DPLAY_ENUMACTIVE;
		hr = CallSPEnumSessions(this,pBuffer,dwMessageSize,dwTimeout, bReturnStatus);
		this->dwFlags &= ~DPLAYI_DPLAY_ENUMACTIVE;
		if (FAILED(hr)) 
		{
			goto ERROR_EXIT;
		}
		// we're not starting an async - we're done w/ the buffer		
		DPMEM_FREE(pBuffer);		
	}
	
	// normal exit
	return hr;
	
ERROR_EXIT:
	if (hr != DPERR_CONNECTING)
		DPF_ERRVAL("SP Enum Sessions Failed - hr = 0x%08lx\n",hr);	
	if (pBuffer) DPMEM_FREE(pBuffer);
	return hr;
	
} // InternalEnumSessions

// calls internal enum sessions, then does callback
HRESULT DPAPI DP_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
    DWORD dwFlags) 
{
    LPDPLAYI_DPLAY this;
	HRESULT hr=DP_OK;
	BOOL bContinue = TRUE;

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
	        goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }

	while (bContinue)
	{
		//  do the enum
		hr = InternalEnumSessions(lpDP,lpsdDesc,dwTimeout,(LPVOID)lpEnumCallback,
			dwFlags);
		if (FAILED(hr)) 
		{
			if (hr != DPERR_CONNECTING)
				DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
		}

        hr = DoSessionCallbacks(this, lpsdDesc, &dwTimeout, lpEnumCallback, 
                                pvContext, dwFlags, &bContinue, FALSE);
        if (FAILED(hr))
        {
            goto CLEANUP_EXIT;
        }
	    
		// done...
	    if (bContinue) bContinue = CallAppEnumSessionsCallback(lpEnumCallback,NULL,&dwTimeout,
	    	DPESC_TIMEDOUT,pvContext);

	} // while bContinue

    // fall through
CLEANUP_EXIT:

	LEAVE_ALL();
	
    return hr;

}//DP_EnumSessions


/*
 ** CopySessionDesc2
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions and DP_1_EnumSessions
 *
 *  PARAMETERS: pSessionDescDest - session description ptr (destination)
 *				pSessionDescSrc - session description ptr (source)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies session description while allocating memory for name and password strings.
 *                These strings need to be freed by the calling function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySessionDesc2(LPDPSESSIONDESC2 pSessionDescDest, 
                         LPDPSESSIONDESC2 pSessionDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSessionDescDest && pSessionDescSrc);

    memcpy(pSessionDescDest, pSessionDescSrc, sizeof(DPSESSIONDESC2));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSessionDescDest->lpszSessionNameA), pSessionDescSrc->lpszSessionName);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSessionDescDest->lpszPasswordA), pSessionDescSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSessionDescDest->lpszSessionName), pSessionDescSrc->lpszSessionName);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSessionDescDest->lpszPassword), pSessionDescSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeDesc(pSessionDescDest, bAnsi);
    return hr;
}
 
void FreeSessionNode(LPSESSIONLIST pNode)
{
	// free up the sp blob stored w/ the desc
	if (pNode->pvSPMessageData) DPMEM_FREE(pNode->pvSPMessageData);
	// free the strings	store w/ the desc
	if (pNode->dpDesc.lpszSessionName) DPMEM_FREE(pNode->dpDesc.lpszSessionName);
	if (pNode->dpDesc.lpszPassword) DPMEM_FREE(pNode->dpDesc.lpszPassword);
	// free the session node
	DPMEM_FREE(pNode);
	
	return ;
	
} // FreeSessionNode


 // if we don't hear from a session after this many this->dwEnumTimeouts, we 
// "expire" it
#define DPSESSION_EXPIRE_SCALE 5
/*
 ** DoSessionCallbacks
 *
 *  CALLED BY: DP_EnumSessions,DP_A_EnumSessions
 *
 *  PARAMETERS: this pointer
 *				lpsdDesc - session desc (always UNICODE) - validated only
 *				lpdwTimeout - how long to wait for responses
 *				lpEnumCallback - callback pointer - validate only
 *              pvContext - app supplied context 
 *				dwFlags - flags passed to DP_X_EnumSessions - unused so far...
 *              lpbContinue - place holder for callback result
 *              bAnsi - ANSI or UNICODE
 *
 *  DESCRIPTION:  Does protected session callbacks while dropping the dplay locks
 *
 *  RETURNS: DP_OK, DPERR_OUTOFMEMORY
 *
 */
HRESULT DoSessionCallbacks(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc,
	LPDWORD lpdwTimeout, LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags, LPBOOL lpbContinue, BOOL bAnsi)
{
    LPSESSIONLIST lpSessionNode,lpSessionNodePrev;
    UINT i, nSessions=0;
    LPGUID pGuidArray;
    HRESULT hr;
    DPSESSIONDESC2 sdesc;

    // default behavior when flags are not specified
    if (!dwFlags) dwFlags = DPENUMSESSIONS_AVAILABLE;

    // count the number of matching sessions
    lpSessionNode = this->pSessionList;
	lpSessionNodePrev = NULL;
    while (lpSessionNode) 
    {
		// is this session expired?
		if ( (this->dwFlags & DPLAYI_DPLAY_ENUM) && (GetTickCount() - lpSessionNode->dwLastReply > 
			this->dwEnumTimeout*DPSESSION_EXPIRE_SCALE ) )
		{
			// expire session
			if (lpSessionNodePrev)
			{
				// remove this session node from the middle of the list
				lpSessionNodePrev->pNextSession = lpSessionNode->pNextSession;
				FreeSessionNode(lpSessionNode);
				lpSessionNode = lpSessionNodePrev->pNextSession;
			}
			else 
			{
				// take it off the front
				this->pSessionList = lpSessionNode->pNextSession;
				FreeSessionNode(lpSessionNode);
				lpSessionNode = this->pSessionList;
			}
		}
		else 
		{
            // Filtering is done on the server for DX5 or greater
            if (lpSessionNode->dwVersion >= DPSP_MSG_DX5VERSION)
            {
                nSessions++;
            }
            else  // for previous versions, filtering is done on the client
            {
	            // make sure this session matches what the user asked for...
			    hr = CheckSessionDesc(lpsdDesc,&(lpSessionNode->dpDesc),dwFlags,FALSE);
		        if (SUCCEEDED(hr)) 
		        {
	                // increment the count
	                nSessions++;
	            }
            }

	        lpSessionNode = lpSessionNode->pNextSession;
		}
    }

    // are there any sessions to enumerate ?
    if (0 == nSessions)
    {
        return DP_OK;
    }

    // allocate memory for the session guids array
    pGuidArray = DPMEM_ALLOC(nSessions * sizeof(GUID));
    if (!pGuidArray)
	    {
        DPF_ERR("Could not allocate array for session guids");
        return DPERR_OUTOFMEMORY;
    }

    // fill the session guid and session desc arrays
    i=0;
    lpSessionNode = this->pSessionList;
    while (lpSessionNode)
    {
        // Filtering is done on the server for DX5 or greater
        if (lpSessionNode->dwVersion >= DPSP_MSG_DX5VERSION)
        {
            pGuidArray[i] = lpSessionNode->dpDesc.guidInstance;
            i++;
        }
        else  // for previous versions, filtering is done on the client
        {
            // make sure this session matches what the user asked for...
		    hr = CheckSessionDesc(lpsdDesc,&(lpSessionNode->dpDesc),dwFlags,FALSE);
            if (SUCCEEDED(hr)) 
	        {
                pGuidArray[i] = lpSessionNode->dpDesc.guidInstance;
                i++;
            }
        }
        lpSessionNode = lpSessionNode->pNextSession;
    }

	// iterate over the guid list and callback w/ results	
    for (i=0; i < nSessions && *lpbContinue; i++)
    {        
        // check if the session is still valid 'cause session list could get 
        // deleted if EnumSessions is called while we dropped the locks
        lpSessionNode = FindSessionInSessionList(this,&pGuidArray[i]);	
        if (lpSessionNode)
        {
            // make a local copy of the session desc
            hr = CopySessionDesc2(&sdesc, &(lpSessionNode->dpDesc), bAnsi);
		    if (FAILED(hr))
		    {
			    DPF(0,"could not copy session desc hr = 0x%08lx\n",hr);
			    goto CLEANUP_EXIT;
		    }

            // drop the locks
			LEAVE_ALL();

            // call the app
		    *lpbContinue = CallAppEnumSessionsCallback(lpEnumCallback,&sdesc,lpdwTimeout,0,pvContext);	

            // reacquire locks
			ENTER_ALL();

            // free the strings allocated in CopySessionDesc2
            FreeDesc(&sdesc, bAnsi);
        }
    }

    // setting this explicitly here 'cause CheckSessionDesc could fail which is OK
    hr = DP_OK;

CLEANUP_EXIT:
    // cleanup allocations
    if (pGuidArray) 
    {
        DPMEM_FREE(pGuidArray);
    }

    return hr;
}


// Some apps (ok, "Outlaws" from LucasArts) were declaring their callbacks to
// be _cdecl instead of _stdcall and were relying on DPlay to generate stack frames to
// clean up after them. To keep them running we have to reset the stack pointer
// after returning from their callback, which will pop the parameters they were supposed to.
//
// Unfortunately, we can't use that nifty "#pragma optimize ("y", off)" here to turn on
// stack frames to fix this problem. This is because we don't have any local stack variables,
// so the compiler doesn't need to restore the stack pointer. I tried adding stack varibles
// but this ended up popping the wrong parameters and generally did not work 100%. So, an
// assembly language version seemed the safest way to go. This way it will always be correct,
// no matter what the compiler or how things change in the original functions.

// This fix won't affect applications that actually do clean up their parameters, since
// ESP == EBP when we return from calling them, so doing the "mov esp,ebp" won't change
// anything.

#if defined(_M_IX86)

BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeout,
				DWORD dwFlags, LPVOID lpContext)
{
	// why we declare lpStackPtr :
	// 1. we use it as a return value (hence its type of 'bool')
	// 2. we use it as a temporary place to stash esp, so we don't confuse the compiler 
	BOOL lpStackPtr = FALSE;

	_asm {
		// Save stack pointer
		mov		dword ptr [lpStackPtr],esp
		
		mov		eax,dword ptr [lpContext]
		push	eax
		mov		eax,dword ptr [dwFlags]
		push	eax
		mov		eax,dword ptr [lpdwTimeout]
		push	eax
		mov		eax,dword ptr [lpSessionDesc]
		push	eax
		call	dword ptr [lpEnumCallback]
		
		// Restore stack pointer
		mov		esp,dword ptr [lpStackPtr]
		// immediately below, the compiler will generate a 'mov eax,dword ptr [lpStackPtr]'
		// we make sure lpStackPtr has the real return value we want.  this gets rid of 
		// a compiler warning (need to return something explicitly), plus force the compiler
		// to actually alloc space for lpStackPtr.
		mov		dword ptr [lpStackPtr],eax
	}
	
	return lpStackPtr;
}

#else

BOOL CallAppEnumSessionsCallback(LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,
				LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeout,
				DWORD dwFlags, LPVOID lpContext)
{
	return (lpEnumCallback(lpSessionDesc, lpdwTimeout, dwFlags, lpContext));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\iplay1.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iplay1.c
 *  Content:	entry points for idirectplay1. entry points common to
 *				idirectplay1 and idirectplay2 are in iplay.c
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	5/8/96	andyco	created it
 *	6/19/96	kipo	Bug #2047. Changed DP_1_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Derek bug. CopyName() was not checking the application buffer
 *					size correctly before copying the buffer.
 *	6/20/96	andyco	added WSTRLEN_BYTES so we get the right strlength in copy string
 *	6/22/96	andyco	pass unicode sessiondesc2 to internalenumsessions so 
 *					we can send the password w/ the request
 *	6/26/96	andyco	pass DP_Open only DPOPEN_OPEN or DPOPEN_JOIN.  Also, 
 *					made sure we get service lock b4 getting dplay lock on enums.
 *	6/26/96	kipo	changed guidGame to guidApplication.
 *  7/8/96  ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                  to 'dpnName' to match DPLAY.H
 *	7/10/96	kipo	converter DPSYS_DELETEPLAYERORGROUP message to a DPSYS_DELETEPLAYER
 *					or DPSYS_DELETEGROUP message for DP1.0 compatability.
 *  7/11/96 ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
 *	7/11/96	andyco	wrapped receive param check in try / except
 * 7/30/96 	kipo    player event is a handle now
 *	8/10/96	andyco 	check DPSESSION_JOINDISABLED in checksessiondesc
 *  8/12/96	andyco	call internalreceive so we can get addplayer 10 size correct.
 *  8/13/96	kipo	bug #3186: return currentPlayers in DP 1.0 session description.
 *  8/13/96 kipo	bug #3203: DP_1_GetPlayerName() should allow player and groups.
 *  10/2/96 sohailm bug #2847: replaced VALID_DPSESSIONDESC_PTR() macros with 
 *                  VALID_READ_DPSESSIONDESC_PTR() macros where appropriate.
 * 10/14/96 sohailm bug #3526: not validating session id before dereferencing as guid pointer
 *	11/19/97myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 ***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_CreatePlayer"

HRESULT DPAPI DP_1_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPSTR lpszShortName,LPSTR lpszLongName,LPHANDLE phEvent)
{
    LPDPLAYI_DPLAY this;
    LPDPLAYI_PLAYER lpPlayer;
	DPNAME Name;
	HANDLE hEvent = NULL;	// assume we won't use events for this player
	HRESULT	hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check event
		if (phEvent && !VALID_DWORD_PTR(phEvent))
		{
	        DPF_ERR( "bad event pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if (phEvent && *phEvent)
		{
			DPF(3,"warning, *phEvent is non-null - dplay will be stomping this data!");
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// caller wants to use events
	if (phEvent)
	{
		ENTER_DPLAY();

		// create a manual-reset event
		hEvent = CreateEventA(NULL,TRUE,FALSE,NULL);

		LEAVE_DPLAY();

		if (!hEvent)
		{
	        DPF_ERR( "could not create event" );
	        hr = DPERR_NOMEMORY;
			goto Failure;
		}
	}

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);
	
	// call the ansi entry w/ the new struct
	hr = DP_A_CreatePlayer(lpDP, pidPlayerID,&Name,hEvent,NULL,0,0);
	if FAILED(hr)
		goto Failure;

	if (hEvent)
	{
		ENTER_DPLAY();

		// get pointer to player structure
        lpPlayer = PlayerFromID(this,*pidPlayerID);

        if (!VALID_DPLAY_PLAYER(lpPlayer))
		{
	        DPF_ERR( "invalid player ID" );
			hr = DPERR_INVALIDPLAYER;
			LEAVE_DPLAY();
			goto Failure;
		}

		// remember to delete this event when player is deleted
		lpPlayer->dwFlags |= DPLAYI_PLAYER_CREATEDPLAYEREVENT;

		// return event we created
		*phEvent = hEvent;
		LEAVE_DPLAY();
	}

	return (DP_OK);

Failure:
	if (hEvent)
		CloseHandle(hEvent);
		
	return (hr);

} // DP_1_CreatePlayer
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_CreateGroup"

HRESULT DPAPI DP_1_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPSTR lpszShortName,LPSTR lpszLongName) 
{
	DPNAME Name;

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);

	// call the ansi entry w/ the new struct
	return 	DP_A_CreateGroup(lpDP, pidGroupID,&Name,NULL,0,0);

} // DP_1_CreateGroup
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumGroupPlayers"

HRESULT DPAPI DP_1_EnumGroupPlayers(LPDIRECTPLAY lpDP,DPID idGroup,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,NULL,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_1);


	LEAVE_ALL();
	
	return hr;

} // DP_1_EnumGroupPlayers
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumGroups"

HRESULT DPAPI DP_1_EnumGroups(LPDIRECTPLAY lpDP,DWORD_PTR dwSessionID,
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroups(lpDP,(LPGUID)dwSessionID,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_1);


	LEAVE_ALL();
	
	return hr;

} // DP_1_EnumGroups
#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumPlayers"

HRESULT DPAPI DP_1_EnumPlayers(LPDIRECTPLAY lpDP, DWORD_PTR dwSessionID, 
	LPDPENUMPLAYERSCALLBACK lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,(LPGUID)dwSessionID,(LPVOID) lpEnumCallback,pvContext,dwFlags,ENUM_1);


	LEAVE_ALL();

	return hr;

} // DP_1_EnumPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_EnumSessions"

// convert a unicode dpsessiondesc2 to (ansi) dpsessiondesc
// note we can't memcpy, since fields are not lined up
void Get10Desc(LPDPSESSIONDESC pDesc1,LPDPSESSIONDESC2 pDesc)
{
	memset(pDesc1,0,sizeof(DPSESSIONDESC));
	// copy over fields
	pDesc1->dwSize = sizeof(DPSESSIONDESC);
	pDesc1->guidSession = pDesc->guidApplication;
	pDesc1->dwMaxPlayers = pDesc->dwMaxPlayers;
	pDesc1->dwCurrentPlayers = pDesc->dwCurrentPlayers;
	pDesc1->dwFlags = pDesc->dwFlags;
	pDesc1->dwReserved1 = pDesc->dwReserved1;
	pDesc1->dwReserved2 = pDesc->dwReserved2;
	pDesc1->dwUser1 = pDesc->dwUser1;
	pDesc1->dwUser2 = pDesc->dwUser2;
	pDesc1->dwUser3 = pDesc->dwUser3;
	pDesc1->dwUser4 = pDesc->dwUser4;
	
	if (pDesc->lpszSessionName)
	{
		WideToAnsi(pDesc1->szSessionName,pDesc->lpszSessionName,DPSESSIONNAMELEN);
	}
	if (pDesc->lpszPassword)
	{
		WideToAnsi(pDesc1->szPassword,pDesc->lpszPassword,DPPASSWORDLEN);		
	}

	// use the pointer to the guid as the dwSession
	pDesc1->dwSession = (DWORD_PTR) &(pDesc->guidInstance);

} // Get10Desc

// same code as CheckSessionDesc, but for old desc.
// we need different code path here, since fields in  LPDPSESSIONDESC
// and LPDPSESSIONDESC2 don't line up
HRESULT CheckSessionDesc1(LPDPSESSIONDESC lpsdUser,LPDPSESSIONDESC lpsdSession,
	DWORD dwFlags)
{
	int iStrLen;


	// if we don't care about guids, passwords, open slots and enable new players, we're done
	if (dwFlags & DPENUMSESSIONS_ALL) return DP_OK;

	// 1st, check the guids
	if (!IsEqualGUID(&(lpsdUser->guidSession),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(lpsdUser->guidSession),&(lpsdSession->guidSession))) 
		{
			return E_FAIL;
		}
	}

	// if we don't care about passwords, open slots and enable new players, we're done
	if (!(dwFlags & DPENUMSESSIONS_AVAILABLE)) return DP_OK;
	
	// next, check current users
	if (lpsdSession->dwMaxPlayers) 
	{
		if (lpsdSession->dwCurrentPlayers >= lpsdSession->dwMaxPlayers)  
		{
			return E_FAIL;
		}
	}
	
	// check the password
	iStrLen = STRLEN(lpsdSession->szPassword);
	if (iStrLen)
	{
		int iCmp;

		iCmp = strcmp(lpsdSession->szPassword,lpsdUser->szPassword);
		if (0 != iCmp) return E_FAIL;
	}

	// finally, check players enabled
	if (lpsdSession->dwFlags & DPSESSION_NEWPLAYERSDISABLED) return E_FAIL;
	if (lpsdSession->dwFlags & DPSESSION_JOINDISABLED) return E_FAIL;
	
	return DP_OK;
} // CheckSessionDesc1

void Desc2FromDesc1(LPDPSESSIONDESC2 lpsdDesc2,LPDPSESSIONDESC lpsdDesc1)
{
	memset(lpsdDesc2,0,sizeof(DPSESSIONDESC2));
	lpsdDesc2->dwSize = sizeof(DPSESSIONDESC2);
	lpsdDesc2->dwFlags = lpsdDesc1->dwFlags;
	lpsdDesc2->guidApplication = lpsdDesc1->guidSession;// in sessiondesc1, session = game
	lpsdDesc2->dwMaxPlayers = lpsdDesc1->dwMaxPlayers;
	lpsdDesc2->dwUser1 = lpsdDesc1->dwUser1;
	lpsdDesc2->dwUser2 = lpsdDesc1->dwUser2;
	lpsdDesc2->dwUser3 = lpsdDesc1->dwUser3;
	lpsdDesc2->dwUser4 = lpsdDesc1->dwUser4;

	lpsdDesc2->lpszSessionNameA = lpsdDesc1->szSessionName;
	lpsdDesc2->lpszPasswordA = lpsdDesc1->szPassword;

	return ;
} // Desc2FromDesc1

HRESULT DPAPI DP_1_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpsdDesc,
	DWORD dwTimeout,LPDPENUMSESSIONSCALLBACK lpEnumCallback,LPVOID pvContext,
	DWORD dwFlags) 
{
	HRESULT hr;
	BOOL bContinue = TRUE;
	LPSESSIONLIST pSessionList;
	DPSESSIONDESC2 desc2,descW;
	DPSESSIONDESC desc1;
	GUID guidInstance;
	LPDPLAYI_DPLAY this;
	
	ENTER_ALL();

    TRY
    {		
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
			 
		if (!VALID_READ_DPSESSIONDESC(lpsdDesc))
		{
			LEAVE_ALL();
			DPF_ERR("Bad session desc");	
	        return DPERR_INVALIDPARAMS;
		}
		if (lpsdDesc->dwSession) guidInstance = *((LPGUID)lpsdDesc->dwSession);
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	Desc2FromDesc1(&desc2,lpsdDesc);
	desc2.guidInstance = guidInstance;

	hr = GetWideDesc(&descW,&desc2);
	if (FAILED(hr))
	{
		LEAVE_ALL();
		return hr;
	}

	while (bContinue)
	{
		//  do the enum. 
		hr = InternalEnumSessions(lpDP,&descW,dwTimeout,(LPVOID)lpEnumCallback,dwFlags);
		if (FAILED(hr)) 
		{
			FreeDesc( &descW,FALSE);
			LEAVE_ALL();
			DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			return hr;
		}

		// callback w/ results	
		pSessionList = this->pSessionList;
	    while (pSessionList && bContinue)
	    {
			Get10Desc(&desc1,&(pSessionList->dpDesc));

			// make sure this session matches what the user asked for...
			hr = CheckSessionDesc1(lpsdDesc,&desc1,dwFlags);
			if (SUCCEEDED(hr)) 
			{
		        bContinue = lpEnumCallback( &desc1,pvContext,&dwTimeout,0);				
			}
			pSessionList = pSessionList->pNextSession;
	    } 
	    
		// done...
	    if (bContinue) bContinue = lpEnumCallback(NULL,pvContext,&dwTimeout,DPESC_TIMEDOUT);

	} // while bContinue

	FreeDesc( &descW,FALSE);
	
	LEAVE_ALL();

    return DP_OK;

} // DP_1_EnumSessions

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetCaps"

HRESULT Internal_1_GetCaps(LPDIRECTPLAY lpDP,LPDPCAPS lpDPCaps,DPID idPlayer,BOOL fPlayer) 
{
	DPCAPS dpcaps; // pass this to iplay2 when we get passed an old caps
	BOOL bOldCaps;
	HRESULT hr;
	DWORD dwFlags;

	TRY
	{
		if (VALID_DPLAY_CAPS(lpDPCaps))	
		{
			bOldCaps = FALSE;
		}
		else 
		{
			if (VALID_DPLAY1_CAPS(lpDPCaps))	
			{
				bOldCaps = TRUE;
				
				// take lock so we don't hose crt
				ENTER_DPLAY();
				memset(&dpcaps,0,sizeof(DPCAPS));
				memcpy(&dpcaps,lpDPCaps,lpDPCaps->dwSize);
				dpcaps.dwSize = sizeof(DPCAPS);
				LEAVE_DPLAY();
				
			}
			else 
			{
		        DPF_ERR( "BAD CAPS POINTER" );
		        return DPERR_INVALIDPARAMS;
			}
		}
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
	}

	dwFlags = lpDPCaps->dwFlags;
	dpcaps.dwFlags = 0;

	if (bOldCaps)
	{
		if (fPlayer) 
		{
			hr = DP_GetPlayerCaps(lpDP,idPlayer,&dpcaps,dwFlags);
		}
		else 
		{
			hr = DP_GetCaps(lpDP,&dpcaps,dwFlags);
		}
		if (FAILED(hr)) return hr;

		// take lock so we don't hose crt
		ENTER_DPLAY();
		memcpy(lpDPCaps,&dpcaps,lpDPCaps->dwSize);
		LEAVE_DPLAY();
		
		return hr;
	}
	else 
	{
		if (fPlayer) 
		{
			hr = DP_GetPlayerCaps(lpDP,idPlayer,lpDPCaps,dwFlags);
		}
		else 
		{
			hr = DP_GetCaps(lpDP,lpDPCaps,dwFlags);
		}
	}
	
	return hr;
} // Internal_1_GetCaps

HRESULT DPAPI DP_1_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps) 
{

	return Internal_1_GetCaps(lpDP,lpDPCaps,0,FALSE);

} // DP_1_GetCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetPlayerCaps"

HRESULT DPAPI DP_1_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps) 
{
	
	return Internal_1_GetCaps(lpDP,lpDPCaps,idPlayer,TRUE);

} // DP_1_GetPlayerCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_GetPlayerName"

// called by getplayer name. copies lpszSrc (as much as will fit) to lpszDest
// set pdwDestLength to the size of lpszDest 
// returns DPERR_BUFFERTOOSMALL or DP_OK
HRESULT CopyName(LPSTR lpszDest,LPWSTR lpszSrc,DWORD * pdwDestLength) 
{
    UINT iStrLen; // str length, in bytes of what we're copying

	// ask wide to ansi how long
	iStrLen = WSTR_ANSILENGTH(lpszSrc);

	if (iStrLen > *pdwDestLength)
	{
		*pdwDestLength = iStrLen;
		return DPERR_BUFFERTOOSMALL;
	}

	*pdwDestLength = iStrLen;
	if (lpszSrc) 
	{
		WideToAnsi(lpszDest,lpszSrc,iStrLen);
	}
	
    return DP_OK;

} // CopyName

HRESULT DPAPI DP_1_GetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPDWORD pdwShortNameLength,LPSTR lpszLongName,LPDWORD pdwLongNameLength) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		lpPlayer = PlayerFromID(this,idPlayer);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,idPlayer);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERR("SP - passed bad player / group id");
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }

        // check the strings - (this is redundant, since the SEH will catch the bd pdw below,
		// but nothing wrong w/ belt + suspenders)
		if ( (!VALID_DWORD_PTR(pdwShortNameLength)) || (!VALID_DWORD_PTR(pdwLongNameLength)) )
		{
            LEAVE_DPLAY();
			DPF_ERR("bad length pointer");
            return DPERR_INVALIDPARAMS;
		}

		// if the string is null, they just get the length
		if (!lpszShortName)*pdwShortNameLength = 0;
		if (!lpszLongName) *pdwLongNameLength = 0;

        if ((*pdwShortNameLength) && (!VALID_STRING_PTR(lpszShortName,*pdwShortNameLength)) ) 
        {
            LEAVE_DPLAY();
            return DPERR_INVALIDPARAMS;
        }
        if ((*pdwLongNameLength) && (!VALID_STRING_PTR(lpszLongName,*pdwLongNameLength)) ) 
        {
            LEAVE_DPLAY();
            return DPERR_INVALIDPARAMS;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }
    
    hr = CopyName(lpszShortName,lpPlayer->lpszShortName,pdwShortNameLength);

    hr |= CopyName(lpszLongName,lpPlayer->lpszLongName,pdwLongNameLength);

    LEAVE_DPLAY();
    return hr;

}//DP_1_GetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_Open"

HRESULT DPAPI DP_1_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC lpsdDesc ) 
{
	DPSESSIONDESC2 desc2;
	GUID guidInstance;
	DWORD dwFlags;

	ENTER_DPLAY();

    TRY
    {
		if (!VALID_READ_DPSESSIONDESC(lpsdDesc))
		{
        	LEAVE_DPLAY();
			DPF_ERR("Bad session desc");	
	        return DPERR_INVALIDPARAMS;
		}
		if (lpsdDesc->dwFlags & DPOPEN_JOIN)
		{
            if (!VALID_READ_GUID_PTR((LPGUID)lpsdDesc->dwSession))
            {
        	    LEAVE_DPLAY();
			    DPF_ERR("Bad session id");	
	            return DPERR_INVALIDPARAMS;
            }
			// get the guid
			guidInstance = *((LPGUID)lpsdDesc->dwSession);
			dwFlags = DPOPEN_JOIN;
		}
		else 
		{
			dwFlags = DPOPEN_CREATE;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }			        

	Desc2FromDesc1(&desc2,lpsdDesc);
	desc2.guidInstance = guidInstance;

	LEAVE_DPLAY();

	return DP_A_Open(lpDP, &desc2,dwFlags ) ;
		
} // DP_1_Open

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_Receive"

// pvBuffer points to an DPMSG_CREATEPLAYERORGROUP mess
// convert it to an DPMSG_ADDPLAYER mess
HRESULT BuildAddPlayer1(LPVOID pvBuffer,LPDWORD pdwSize)
{
	DPMSG_ADDPLAYER msg;
	LPDPMSG_CREATEPLAYERORGROUP pmsg2 = (LPDPMSG_CREATEPLAYERORGROUP) pvBuffer;

	memset(&msg,0,sizeof(DPMSG_ADDPLAYER));
	
	msg.dwType = DPSYS_ADDPLAYER;
	msg.dwPlayerType = pmsg2->dwPlayerType;
	msg.dpId = pmsg2->dpId;
	msg.dwCurrentPlayers = pmsg2->dwCurrentPlayers;
	
	if (pmsg2->dpnName.lpszShortName)
	{
		WideToAnsi(msg.szShortName,pmsg2->dpnName.lpszShortName,DPSHORTNAMELEN);				
	}

	if (pmsg2->dpnName.lpszLongName)
	{
		WideToAnsi(msg.szLongName,pmsg2->dpnName.lpszLongName,DPLONGNAMELEN);		
	}
	
	*pdwSize = sizeof(msg);
	memcpy(pvBuffer,&msg,*pdwSize);
	return DP_OK;

} // BuildAddPlayer1

// pvBuffer points to an DPMSG_DESTROYPLAYERORGROUP mess
// convert it to a DPMSG_DELETEPLAYER
HRESULT BuildDeletePlayerOrDeleteGroup1(LPVOID pvBuffer,LPDWORD pdwSize)
{
	DPMSG_DELETEPLAYER msg;
	LPDPMSG_DESTROYPLAYERORGROUP pmsg2 = (LPDPMSG_DESTROYPLAYERORGROUP) pvBuffer;

	if (pmsg2->dwPlayerType == DPPLAYERTYPE_PLAYER)
	{
		msg.dwType = DPSYS_DELETEPLAYER;
		msg.dpId = pmsg2->dpId;
	}
	else
	{
		msg.dwType = DPSYS_DELETEGROUP;
		msg.dpId = pmsg2->dpId;
	}

	*pdwSize = sizeof(msg);
	memcpy(pvBuffer,&msg,*pdwSize);
	return DP_OK;

} // BuildDeletePlayerOrDeleteGroup1


HRESULT DPAPI DP_1_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize)
{
	HRESULT hr;
	DWORD dwOrigSize=0; 

	ENTER_DPLAY();
	
    TRY
    {						 
		if (pdwSize) dwOrigSize = *pdwSize;    
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating pdwSize" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }			        

	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_1);

	if (FAILED(hr)) 
	{
		LEAVE_DPLAY();
		return hr;
	}

	// see if its a addplayer mess
	if (0 == *pidFrom )
	{
		switch (((DPMSG_GENERIC *)pvBuffer)->dwType)
		{
		case DPSYS_CREATEPLAYERORGROUP:
			if (sizeof(DPMSG_ADDPLAYER) > dwOrigSize ) 
			{
				ASSERT(FALSE); // should never happen!
			}
			else 
			{
				// convert the iplay 20 add player to a 10 add player
				BuildAddPlayer1(pvBuffer,pdwSize);
			}
			break;

		case DPSYS_DESTROYPLAYERORGROUP:
			if (sizeof(DPMSG_DELETEPLAYER) > dwOrigSize ) 
			{
				*pdwSize = 	sizeof(DPMSG_DELETEPLAYER);
				hr = DPERR_BUFFERTOOSMALL;
			}
			else 
			{
				// convert the iplay 2.0 delete player/group to a 1.0 delete player or delete group
				BuildDeletePlayerOrDeleteGroup1(pvBuffer,pdwSize);
			}
			break;
		}
		
	} // 0 == pidFrom
	
	LEAVE_DPLAY();
	
	return hr;

} // DP_1_Receive

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_SaveSession"

HRESULT DPAPI DP_1_SaveSession(LPDIRECTPLAY lpDP, LPSTR lpszNotInSpec) 
{
	return E_NOTIMPL;
} // DP_1_SaveSession

#undef DPF_MODNAME
#define DPF_MODNAME "DP_1_SetPlayerName"

/*
 ** AnsiSetString
 *
 *  CALLED BY: DP_SetPlayerName
 *
 *  PARAMETERS: ppszDest - string to set, lpszSrc - string to copy
 *
 *  DESCRIPTION: frees *ppszDest. alloc's a new ppszDest to hold lpszSrc
 *
 *  RETURNS: DP_OK or E_OUTOFMEMORY
 *
 */
HRESULT AnsiSetString(LPWSTR * ppszDest,LPSTR lpszSrc)
{
    if (!ppszDest) return E_UNEXPECTED;
    if (*ppszDest) DPMEM_FREE(*ppszDest);
	
	GetWideStringFromAnsi(ppszDest,lpszSrc);

	return DP_OK;

} // AnsiSetString

HRESULT DPAPI DP_1_SetPlayerName(LPDIRECTPLAY lpDP, DPID idPlayer,LPSTR lpszShortName,
	LPSTR lpszLongName) 
{
	DPNAME Name;

	memset(&Name,0,sizeof(Name));
	Name.lpszShortNameA = lpszShortName;
	Name.lpszLongNameA = lpszLongName;
	Name.dwSize = sizeof(DPNAME);

	// call the ansi entry w/ the new struct
	return 	DP_A_SetPlayerName(lpDP, idPlayer,&Name,0);

}//DP_1_SetPlayerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\iplaya.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       iplaya.c
 *  Content:	ansi entry points for idirectplay2A. entry points common to
 *				idirectplay2A and idirectplay2 are in iplay.c
 *  History:
 *   Date	By		Reason
 *   ====	==		======
 *	5/8/96	andyco	created it
 *	5/21/96	andyco	added internal_a_createplayer, dp_a_creategroup
 *	6/19/96	kipo	Bug #2047. Changed DP_A_EnumSessions() to return DP_OK
 *					if the session was found. Was returning a stale HR that
 *					would cause it to fail if there was more than one response
 *					to the EnumSessions broadcast.
 *					Derek bug. DP_A_GetGroupName() and DP_A_GetPlayerName()
 *					had the player boolean was swapped so that it always
 *					returned an error.
 *	6/21/96	kipo	Deal with a null DPNAME in GetWideNameFromAnsiName().
 *	6/22/96	andyco	we were leaking a session desc in enumsessions
 *  7/8/96  ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                  to 'dpnName' to match DPLAY.H
 *                  Deleted function DP_A_SaveSession
 *	7/10/96	kipo	changed system message names
 *  7/27/96 kipo	Added GUID to EnumGroupPlayers().
 *  10/1/96 sohailm updated DP_A_EnumSessions() to do protected callbacks
 *  10/2/96 sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
 *                  where appropriate.
 *  10/2/96 sohailm added code to validate user's DPNAME ptrs before accessing them
 * 10/11/96 sohailm Implemented DP_A_SetSessionDesc. Renamed labels for consistency.
 *	12/5/96	andyco	set the wide name to 0 in GetWideNameFromAnsiName before we
 *					validate params - this prevents freeing bogus pointer 
 *					if there's an error. Bug 4924.
 *  2/11/97	kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 *  3/12/97 sohailm added functions SecureOpenA, GetWideCredentials, FreeCredentials,
 *                  GetSecurityDesc, FreeSecurityDesc, ValidateOpenParamsA.
 *                  modified DP_Open to use ValidateOpenParamsA.
 *	4/20/97	andyco	group in group 
 *	5/05/97	kipo	Added CallAppEnumSessionsCallback() to work around Outlaws bug.
 *	5/8/97	myronth	Fixed memory leak, added StartSession ANSI conversion
 *  5/12/97 sohailm Update DP_A_SecureOpen(), FreeSecurityDesc() and GetWideSecurityDesc() 
 *                  to handle CAPIProvider name.
 *                  Fix for deadlock problem seen when SecureOpen fails (8386).
 *                  Added DP_A_GetAccountDesc().
 *	5/17/97	myronth	ANSI SendChatMessage
 *	5/17/97	myronth	Bug #8649 -- Forgot to drop lock on failed Open
 *	5/18/97	kipo	Adjust size of messages correctly.
 *  5/29/97 sohaim  Updated FreeCredentials(), GetWideCredentials(), DP_A_SecureOpen() to 
 *                  handle domain name.
 *	6/4/97	kip		Bug #9311 don't param check DPNAME structure (regression with DX3)
 *  6/09/97 sohailm More parameter validation in DP_A_SecureOpen()
 *	9/29/97	myronth	Fixed DPLCONNECTION package size bug (#12475)
 *	11/19/97myronth	Fixed error paths in DP_A_Open (#9757)
 ***************************************************************************/


// note - we always LEAVE_DPLAY(); before calling idirectplay2 fn's. this is 
// because some idirectplay2 fn's (ones that create a player ( take service lock)) 
// require the dplay lock to be completely dropped.


// todo - build messages!!!

#include "dplaypr.h"
#include "dpsecure.h" // !! Review - move headers into dplaypr !!

#undef DPF_MODNAME
#define DPF_MODNAME "GetWideStringFromAnsi"
			   
// utility function to convert the ansi string lpszStr to a wide string.  also, allocs space
// for the wide string
HRESULT GetWideStringFromAnsi(LPWSTR * ppszWStr,LPSTR lpszStr)
{
	int iStrLen;

	ASSERT(ppszWStr);

	if (!lpszStr) 
	{
		*ppszWStr = NULL;
		return DP_OK;
	}

	// alloc space for the wstr
	iStrLen = STRLEN(lpszStr);
	*ppszWStr = DPMEM_ALLOC(iStrLen * sizeof(WCHAR));
	if (!*ppszWStr)
	{
		DPF_ERR("could not get unicode string - out of memory");
		return E_OUTOFMEMORY;
	}

	// get the wstr
   	AnsiToWide(*ppszWStr,lpszStr,iStrLen);

	return DP_OK;
} // GetWideStringFromAnsi

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_CreatePlayer"


// get a wide playername struct from an ansi one
// assumes dplay lock taken
HRESULT GetWideNameFromAnsiName(LPDPNAME pWide,LPDPNAME pAnsi)
{
	LPSTR lpszShortName,lpszLongName;
	HRESULT hr;

	TRY 
	{
		// we assume pWide is valid - it's off our stack
		// init it here.  so, if we fail, it won't have garbage
		// which we try to free up...
		memset(pWide,0,sizeof(DPNAME));
		
        if (pAnsi && !VALID_READ_DPNAME_PTR(pAnsi))
        {
			DPF_ERR("invalid dpname pointer");
			ASSERT(FALSE);

			// returning an error here causes a regression with DX3, since
			// we did not do parameter checks on the name previously
//			return DPERR_INVALIDPARAMS;
        }

        if (pAnsi)
			lpszShortName = pAnsi->lpszShortNameA;
		else
			lpszShortName = NULL;

		if (pAnsi)
			lpszLongName = pAnsi->lpszLongNameA;
		else
			lpszLongName = NULL;

		if ( lpszShortName && !VALID_READ_STRING_PTR(lpszShortName,STRLEN(lpszShortName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpszLongName && !VALID_READ_STRING_PTR(lpszLongName,STRLEN(lpszLongName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }			      

    // get wchar versions of the strings
	hr = GetWideStringFromAnsi(&(pWide->lpszShortName),lpszShortName);
	if (FAILED(hr)) 
	{
		return hr;
	}
	hr = GetWideStringFromAnsi(&(pWide->lpszLongName),lpszLongName);
	if (FAILED(hr)) 
	{
		return hr;
	}

	// success - mark name as valid
	pWide->dwSize = sizeof(DPNAME);
	
	return DP_OK;	

} // GetWideNameFromAnsiName

// checks string params - then allocs unicode strings and calls DP_CreatePlayer
HRESULT DPAPI DP_A_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_CreatePlayer(lpDP, pID,&WName,hEvent,pvData,dwDataSize,dwFlags);
	}
	
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_CreatePlayer         

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_CreateGroup"

// gets an ansi groupdata, and then calls DP_A_CreateGroup
HRESULT DPAPI DP_A_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pID,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_CreateGroup(lpDP, pID,&WName,pvData,dwDataSize,dwFlags);

	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_CreateGroup         

HRESULT DPAPI DP_A_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_CreateGroupInGroup(lpDP,idParentGroup, pidGroupID,&WName,pvData,dwDataSize,dwFlags);

	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} //DP_A_CreateGroup


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumGroupPlayers"

HRESULT DPAPI DP_A_EnumGroupsInGroup(LPDIRECTPLAY lpDP,DPID idGroup,LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags) 
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupsInGroup(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2A);


	LEAVE_ALL();
	
	return hr;

} // DP_EnumGroupsInGroup

HRESULT DPAPI DP_A_EnumGroupPlayers(LPDIRECTPLAY lpDP, DPID idGroup, LPGUID pGuid,
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroupPlayers(lpDP,idGroup,pGuid,(LPVOID) lpEnumCallback,
		pvContext,dwFlags,ENUM_2A);


	LEAVE_ALL();
	
	return hr;

} // DP_A_EnumGroupPlayers     
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumGroups"

HRESULT DPAPI DP_A_EnumGroups(LPDIRECTPLAY lpDP, LPGUID pGuid,
	 LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumGroups(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,
		ENUM_2A);


	LEAVE_ALL();

	return hr;

} // DP_A_EnumGroups           
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumPlayers"

HRESULT DPAPI DP_A_EnumPlayers(LPDIRECTPLAY lpDP, LPGUID pGuid, 
	LPDPENUMPLAYERSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    HRESULT hr;

 	ENTER_ALL();
	
	hr = InternalEnumPlayers(lpDP,pGuid,(LPVOID) lpEnumCallback,pvContext,dwFlags,ENUM_2A);

	LEAVE_ALL();

	return hr;

} // DP_A_EnumPlayers          
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_EnumSessions"
// convert a unicode session desc to ansi
HRESULT GetAnsiDesc(LPDPSESSIONDESC2 pDescA,LPDPSESSIONDESC2 pDesc)
{
	
	memcpy(pDescA,pDesc,sizeof(DPSESSIONDESC2));
	
	// convert session name
	if (pDesc->lpszSessionName)
	{
		// alloc a new session name
		GetAnsiString(&(pDescA->lpszSessionNameA),pDesc->lpszSessionName);
	}
	
	// convert password
	if (pDesc->lpszPassword)
	{
		// alloc a new session name
		GetAnsiString(&(pDescA->lpszPasswordA),pDesc->lpszPassword);
	}

	return DP_OK;

} // GetAnsiDesc

// frees the strings in a session desc
void FreeDesc(LPDPSESSIONDESC2 pDesc,BOOL fAnsi)
{
	if (fAnsi)
	{
		if (pDesc->lpszPasswordA) DPMEM_FREE(pDesc->lpszPasswordA); 
		if (pDesc->lpszSessionNameA) DPMEM_FREE(pDesc->lpszSessionNameA);
		pDesc->lpszPasswordA = NULL;
		pDesc->lpszSessionNameA = NULL;
	}
	else 
	{
		if (pDesc->lpszPassword) DPMEM_FREE(pDesc->lpszPassword); 
		if (pDesc->lpszSessionName) DPMEM_FREE(pDesc->lpszSessionName);
		pDesc->lpszPassword = NULL;
		pDesc->lpszSessionName =NULL;
	}

} // FreeDesc

// convert an ansi session desc to unicode
HRESULT GetWideDesc(LPDPSESSIONDESC2 pDesc,LPCDPSESSIONDESC2 pDescA)
{
	LPWSTR lpsz;
	HRESULT hr;

	memcpy(pDesc,pDescA,sizeof(DPSESSIONDESC2));
	// convert session name
	// alloc a new session name
	hr = GetWideStringFromAnsi(&lpsz,pDescA->lpszSessionNameA);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert SessionName string to Unicode, hr = 0x%08x", hr);
		return hr;
	}
	// store the new one
	pDesc->lpszSessionName = lpsz;

	// convert password
	hr = GetWideStringFromAnsi(&lpsz,pDescA->lpszPasswordA);
	if (FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert Password string to Unicode, hr = 0x%08x", hr);
		return hr;
	}

	// store the new one
	pDesc->lpszPassword = lpsz;

	return DP_OK;

} // GetWideDesc

// calls internal enum sessions, then does callback
HRESULT DPAPI DP_A_EnumSessions(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwTimeout,
	LPDPENUMSESSIONSCALLBACK2 lpEnumCallback,LPVOID pvContext,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;
	BOOL bContinue = TRUE;
	DPSESSIONDESC2 descW;

 	ENTER_ALL();

	// validate strings and the this ptr
	TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		// check strings
		if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
			STRLEN(lpsdDesc->lpszSessionNameA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
			STRLEN(lpsdDesc->lpszPasswordA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }
	
	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
        goto CLEANUP_EXIT;
	}

	while (bContinue)
	{
		//  do the enum
		hr = InternalEnumSessions(lpDP,&descW,dwTimeout,(LPVOID)lpEnumCallback,dwFlags);
		if (FAILED(hr)) 
		{
			DPF(0,"enum sessions failed!! hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT1;
		}

        hr = DoSessionCallbacks(this, &descW, &dwTimeout, lpEnumCallback, 
                                pvContext, dwFlags, &bContinue, TRUE);
        if (FAILED(hr))
        {
            goto CLEANUP_EXIT1;
        }
	    
		// done...
	    if (bContinue) bContinue = CallAppEnumSessionsCallback(lpEnumCallback,NULL,&dwTimeout,DPESC_TIMEDOUT,pvContext);

	} // while bContinue

    // fall through

CLEANUP_EXIT1:
	FreeDesc( &descW,FALSE);

CLEANUP_EXIT:
	LEAVE_ALL();
    return hr;

} // DP_A_EnumSessions         

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetGroupName"

HRESULT DPAPI DP_A_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, FALSE, TRUE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_A_GetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetPlayerName"

HRESULT DPAPI DP_A_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, TRUE, TRUE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_A_GetPlayerName
 
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetSessionDesc"

HRESULT DPAPI DP_A_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetSessionDesc(lpDP,pvBuffer,pdwSize,TRUE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_GetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateOpenParamsA"
HRESULT ValidateOpenParamsA(LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags)
{
	if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
	{
		DPF_ERR("invalid session desc");
		return DPERR_INVALIDPARAMS;
	}
	// check strings
	if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
		STRLEN(lpsdDesc->lpszSessionNameA)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}
	if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
		STRLEN(lpsdDesc->lpszPasswordA)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}

    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_Open"

HRESULT DPAPI DP_A_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) 
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
							
	ENTER_DPLAY();

	// validate strings
	TRY
    {
        hr = ValidateOpenParamsA(lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();
		return hr;
	}
	
	LEAVE_DPLAY();
	
	hr = DP_Open(lpDP,&descW,dwFlags);

	ENTER_DPLAY();
	
	FreeDesc(&descW,FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_Open
#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_Receive"

// convert a unicode system message to an ansi one
// called by DP_A_Receive
//
// for namechanged and addplayer (only two sysmessages w/ strings),
// we're going to extract the strings from the uniciode message,
// and rebuild the message w/ ansi versions
HRESULT BuildAnsiMessage(LPDIRECTPLAY lpDP,LPVOID pvBuffer,LPDWORD pdwSize)
{
	DWORD dwType;
	LPSTR pszShortName=NULL,pszLongName=NULL; // our new ansi strings
	UINT nShortLen=0,nLongLen=0;
	DWORD dwAnsiSize;  // size for ansi msg
	LPBYTE pBufferIndex; // scratch pointer used to repack


	dwType = ((LPDPMSG_GENERIC)pvBuffer)->dwType;
	
	switch (dwType)
	{
		case DPSYS_CREATEPLAYERORGROUP:
		{
			LPDPMSG_CREATEPLAYERORGROUP pmsg;
		
			pmsg = (LPDPMSG_CREATEPLAYERORGROUP)pvBuffer;
			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}

			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_CREATEPLAYERORGROUP) + pmsg->dwDataSize
				 + nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;

			// we'll repack the message, w/ msg, then playerdata, then strings
			// 1st, repack the playerdata 
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CREATEPLAYERORGROUP);

			if (pmsg->lpData)
			{
				memcpy(pBufferIndex,pmsg->lpData,pmsg->dwDataSize);
				pmsg->lpData = pBufferIndex;
				pBufferIndex += pmsg->dwDataSize;
			}
			// next, pack the strings
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}

			// all done
			break;
			
		} // ADDPLAYER

		case DPSYS_DESTROYPLAYERORGROUP:
		{
			LPDPMSG_DESTROYPLAYERORGROUP pmsg;
		
			pmsg = (LPDPMSG_DESTROYPLAYERORGROUP)pvBuffer;
			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}

			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_DESTROYPLAYERORGROUP)
						+ pmsg->dwLocalDataSize + pmsg->dwRemoteDataSize
						+ nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;

			// we'll repack the message, w/ msg, then playerdata, then strings
			// 1st, repack the playerdata 
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_DESTROYPLAYERORGROUP);

			if (pmsg->lpLocalData)
			{
				memcpy(pBufferIndex,pmsg->lpLocalData,pmsg->dwLocalDataSize);
				pmsg->lpLocalData = pBufferIndex;
				pBufferIndex += pmsg->dwLocalDataSize;
			}

			if (pmsg->lpRemoteData)
			{
				memcpy(pBufferIndex,pmsg->lpRemoteData,pmsg->dwRemoteDataSize);
				pmsg->lpRemoteData = pBufferIndex;
				pBufferIndex += pmsg->dwRemoteDataSize;
			}

			// next, pack the strings
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
				pBufferIndex += nLongLen;
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}

			// all done
			
			break;
		} // DESTROYPLAYER

		case DPSYS_SETPLAYERORGROUPNAME:
		{
			// we're going to extract the strings from the uniciode message,
			// and rebuild the message w/ ansi versions
			LPDPMSG_SETPLAYERORGROUPNAME pmsg;

			pmsg = (LPDPMSG_SETPLAYERORGROUPNAME)pvBuffer;

			if (pmsg->dpnName.lpszShortName)
			{
				GetAnsiString(&pszShortName,pmsg->dpnName.lpszShortName);
				nShortLen = STRLEN(pszShortName);
			}
			if (pmsg->dpnName.lpszLongName)
			{
				GetAnsiString(&pszLongName,pmsg->dpnName.lpszLongName);
				nLongLen = STRLEN(pszLongName);
			}
			
			dwAnsiSize = sizeof(DPMSG_SETPLAYERORGROUPNAME) + nShortLen + nLongLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszShortName)
					DPMEM_FREE(pszShortName);
				if (pszLongName)
					DPMEM_FREE(pszLongName);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPNAME);
			if (pszShortName) 
			{
				memcpy(pBufferIndex,pszShortName,nShortLen);
				pmsg->dpnName.lpszShortNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszShortName);
				pBufferIndex += nShortLen;
			}
			else 
			{
				pmsg->dpnName.lpszShortNameA = (LPSTR)NULL;				
			}

			if (pszLongName) 
			{
				memcpy(pBufferIndex,pszLongName,nLongLen);
				pmsg->dpnName.lpszLongNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszLongName);
			}
			else 
			{
				pmsg->dpnName.lpszLongNameA = (LPSTR)NULL;				
			}
			// all done
			break;

		} // DPSYS_SETPLAYERORGROUPNAME:

		case DPSYS_SETSESSIONDESC:
		{
			// we're going to extract the strings from the uniciode message,
			// and rebuild the message w/ ansi versions
            UINT nSessionNameLen=0, nPasswordLen=0;
            LPSTR pszSessionName=NULL, pszPassword=NULL;
			LPDPMSG_SETSESSIONDESC pmsg;

			pmsg = (LPDPMSG_SETSESSIONDESC)pvBuffer;

			if (pmsg->dpDesc.lpszSessionName)
			{
				GetAnsiString(&pszSessionName,pmsg->dpDesc.lpszSessionName);
				nSessionNameLen = STRLEN(pszSessionName);
			}
			if (pmsg->dpDesc.lpszPassword)
			{
				GetAnsiString(&pszPassword,pmsg->dpDesc.lpszPassword);
				nPasswordLen = STRLEN(pszPassword);
			}
			
			dwAnsiSize = sizeof(DPMSG_SETSESSIONDESC) + nSessionNameLen + nPasswordLen; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszSessionName)
					DPMEM_FREE(pszSessionName);
				if (pszPassword)
					DPMEM_FREE(pszPassword);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETSESSIONDESC);
			if (pszSessionName) 
			{
				memcpy(pBufferIndex,pszSessionName,nSessionNameLen);
				pmsg->dpDesc.lpszSessionNameA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszSessionName);
				pBufferIndex += nSessionNameLen;
			}
			else 
			{
				pmsg->dpDesc.lpszSessionNameA = (LPSTR)NULL;				
			}

			if (pszPassword) 
			{
				memcpy(pBufferIndex,pszPassword,nPasswordLen);
				pmsg->dpDesc.lpszPasswordA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszPassword);
			}
			else 
			{
				pmsg->dpDesc.lpszPasswordA = (LPSTR)NULL;				
			}
			// all done
			break;

		} // DPSYS_SETSESSIONDESC:

		case DPSYS_STARTSESSION:
		{
			LPDPMSG_STARTSESSION	pmsg = (LPDPMSG_STARTSESSION)pvBuffer;
			HRESULT					hr;
		
			hr = PRV_ConvertDPLCONNECTIONToAnsiInPlace(pmsg->lpConn, pdwSize,
					sizeof(DPMSG_STARTSESSION));
			if(FAILED(hr))
			{
				DPF_ERRVAL("Unable to convert DPLCONNECTION structure to ANSI, hr = 0x%08x", hr);
				return hr;
			}
			break;
		}

		case DPSYS_CHAT:
		{
			LPDPMSG_CHAT	pmsg = (LPDPMSG_CHAT)pvBuffer;
			LPSTR			pszMessage = NULL;
			UINT			nStringSize = 0;
			
			if (pmsg->lpChat->lpszMessage)
			{
				GetAnsiString(&pszMessage,pmsg->lpChat->lpszMessage);
				nStringSize = STRLEN(pszMessage);
			}
			
			dwAnsiSize = sizeof(DPMSG_CHAT) + sizeof(DPCHAT) + nStringSize; 

			if (dwAnsiSize > *pdwSize)
			{
				if (pszMessage)
					DPMEM_FREE(pszMessage);
				*pdwSize = dwAnsiSize;
				return DPERR_BUFFERTOOSMALL;
			}

			// store return size
			*pdwSize = dwAnsiSize;
	
			// repack the strings into the buffer
			pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CHAT) + sizeof(DPCHAT);
			if (pszMessage) 
			{
				memcpy(pBufferIndex, pszMessage, nStringSize);
				pmsg->lpChat->lpszMessageA = (LPSTR)pBufferIndex;
				DPMEM_FREE(pszMessage);
			}
			// all done
			break;
		}

		default:
			// do nothing
			break;
	}

	return DP_OK;

} // BuildAnsiMessage

HRESULT DPAPI DP_A_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
	LPVOID pvBuffer,LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_2A);

	if (FAILED(hr)) 
	{
		goto CLEANUP_EXIT;
	}
	
	// if it's a system message, we may need to convert strings to ansi
	if (0 == *pidFrom )
	{
		// it's a system message
		hr = BuildAnsiMessage(lpDP,pvBuffer,pdwSize);
	}

CLEANUP_EXIT:
	LEAVE_DPLAY();
	
	return hr;

} // DP_A_Receive        

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetGroupName"
HRESULT DPAPI DP_A_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_SetGroupName(lpDP, id,&WName,dwFlags);
	}								 
		
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetPlayerName"
HRESULT DPAPI DP_A_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;
	DPNAME WName; // unicode playerdata

	ENTER_DPLAY();
	
	hr = GetWideNameFromAnsiName(&WName,pName);	

	LEAVE_DPLAY();

	if SUCCEEDED(hr) 
	{
		// call the unicode entry	
		hr = DP_SetPlayerName(lpDP,id,&WName,dwFlags);
	}
	
	ENTER_DPLAY();
	
	if (WName.lpszShortName) DPMEM_FREE(WName.lpszShortName);
	if (WName.lpszLongName) DPMEM_FREE(WName.lpszLongName);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SetSessionDesc"
HRESULT DPAPI DP_A_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags)
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
    BOOL bPropogate;
	LPDPLAYI_DPLAY this;
							
	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			hr = DPERR_NOSESSIONS;
			goto CLEANUP_EXIT;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		// check strings
		if ( lpsdDesc->lpszSessionNameA && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionNameA,
			STRLEN(lpsdDesc->lpszSessionNameA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
		if ( lpsdDesc->lpszPasswordA && !VALID_READ_STRING_PTR(lpsdDesc->lpszPasswordA,
			STRLEN(lpsdDesc->lpszPasswordA)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        hr = DPERR_INVALIDPARAMS;
            goto CLEANUP_EXIT;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
        goto CLEANUP_EXIT;
	}

	if(this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES){
		bPropogate=FALSE;
	} else {
		bPropogate=TRUE;
	}
		
	hr = InternalSetSessionDesc(lpDP,&descW,dwFlags,bPropogate);
	
	FreeDesc(&descW,FALSE);

    // fall through

CLEANUP_EXIT:

	LEAVE_DPLAY();	
	return hr;

} // DP_A_SetSessionDesc  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SecureOpen"

// frees the strings in a credentials structure
HRESULT FreeCredentials(LPDPCREDENTIALS lpCredentials, BOOL fAnsi)
{
    if (fAnsi)
    {
        if (lpCredentials->lpszUsernameA)
        {
            DPMEM_FREE(lpCredentials->lpszUsernameA);
            lpCredentials->lpszUsernameA = NULL;
        }
        if (lpCredentials->lpszPasswordA)
        {
            DPMEM_FREE(lpCredentials->lpszPasswordA);
            lpCredentials->lpszPasswordA = NULL;
        }
        if (lpCredentials->lpszDomainA)
        {
            DPMEM_FREE(lpCredentials->lpszDomainA);
            lpCredentials->lpszDomainA = NULL;
        }
    }
    else
    {
        if (lpCredentials->lpszUsername)
        {
            DPMEM_FREE(lpCredentials->lpszUsername);
            lpCredentials->lpszUsername = NULL;
        }
        if (lpCredentials->lpszPassword)
        {
            DPMEM_FREE(lpCredentials->lpszPassword);
            lpCredentials->lpszPassword = NULL;
        }
        if (lpCredentials->lpszDomain)
        {
            DPMEM_FREE(lpCredentials->lpszDomain);
            lpCredentials->lpszDomain = NULL;
        }
    }

    return DP_OK;
} // FreeCredentials


// create a unicode credentials struct from an ansi one
HRESULT GetWideCredentials(LPDPCREDENTIALS lpCredentialsW, LPCDPCREDENTIALS lpCredentialsA)
{
    HRESULT hr;

    ASSERT(lpCredentialsW && lpCredentialsA);

    memcpy(lpCredentialsW, lpCredentialsA, sizeof(DPCREDENTIALS));

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszUsername), lpCredentialsA->lpszUsernameA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszPassword), lpCredentialsA->lpszPasswordA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    hr = GetWideStringFromAnsi(&(lpCredentialsW->lpszDomain), lpCredentialsA->lpszDomainA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // success
    return DP_OK;

CLEANUP_EXIT:
    FreeCredentials(lpCredentialsW,FALSE);
    return hr;
} // GetWideCredentials

// frees the strings in a security desc structure
HRESULT FreeSecurityDesc(LPDPSECURITYDESC lpSecDesc, BOOL fAnsi)
{
    if (fAnsi)
    {
        if (lpSecDesc->lpszSSPIProviderA)
        {
            DPMEM_FREE(lpSecDesc->lpszSSPIProviderA);
            lpSecDesc->lpszSSPIProviderA = NULL;
        }
        if (lpSecDesc->lpszCAPIProviderA)
        {
            DPMEM_FREE(lpSecDesc->lpszCAPIProviderA);
            lpSecDesc->lpszCAPIProviderA = NULL;
        }
    }
    else
    {
        if (lpSecDesc->lpszSSPIProvider)
        {
            DPMEM_FREE(lpSecDesc->lpszSSPIProvider);
            lpSecDesc->lpszSSPIProvider = NULL;
        }
        if (lpSecDesc->lpszCAPIProvider)
        {
            DPMEM_FREE(lpSecDesc->lpszCAPIProvider);
            lpSecDesc->lpszCAPIProvider = NULL;
        }
    }

    return DP_OK;
} // FreeSecurityDesc

// create a unicode security description struct from an ansi one
HRESULT GetWideSecurityDesc(LPDPSECURITYDESC lpSecDescW, LPCDPSECURITYDESC lpSecDescA)
{
    HRESULT hr;

    ASSERT(lpSecDescW && lpSecDescA);

	memcpy(lpSecDescW,lpSecDescA,sizeof(DPSECURITYDESC));

    hr = GetWideStringFromAnsi(&(lpSecDescW->lpszSSPIProvider), 
        lpSecDescA->lpszSSPIProviderA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }
    hr = GetWideStringFromAnsi(&(lpSecDescW->lpszCAPIProvider), 
        lpSecDescA->lpszCAPIProviderA);
    if (FAILED(hr))
    {
        goto CLEANUP_EXIT;
    }

    // success
    return DP_OK;

CLEANUP_EXIT:
    FreeSecurityDesc(lpSecDescW,FALSE);
    return hr;
} // GetWideSecurityDesc

HRESULT DPAPI DP_A_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags,
    LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials)
{
	HRESULT hr;
	DPSESSIONDESC2 descW;
    DPCREDENTIALS credW;
    DPSECURITYDESC secDescW;
    LPDPCREDENTIALS pIntCreds=NULL;
    LPDPSECURITYDESC pIntSecDesc=NULL;
							
	ENTER_DPLAY();

	// validate strings
	TRY
    {
        // validate regular open params
        hr = ValidateOpenParamsA(lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
        // validate additional params

        // null lpSecDesc is ok, will use default
        if (lpSecDesc)            
        {
            // can't pass security desc to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed a security description while creating an unsecure session");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }
            // join case will be checked after we find the session in our list

            // need to be hosting
            if (dwFlags & DPOPEN_JOIN)
            {
                DPF_ERR("Can't pass a security description while joining");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }

            if (!VALID_READ_DPSECURITYDESC(lpSecDesc)) 
            {
                LEAVE_DPLAY();
    			DPF_ERR("invalid security desc");
                return DPERR_INVALIDPARAMS;
            }
	        if (!VALID_DPSECURITYDESC_FLAGS(lpSecDesc->dwFlags))
	        {
                LEAVE_DPLAY();
  		        DPF_ERRVAL("invalid flags (0x%08x) in security desc!",lpSecDesc->dwFlags);
                return DPERR_INVALIDFLAGS;
	        }
		    if ( lpSecDesc->lpszSSPIProviderA && !VALID_READ_STRING_PTR(lpSecDesc->lpszSSPIProviderA,
			    STRLEN(lpSecDesc->lpszSSPIProviderA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad SSPI provider string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpSecDesc->lpszCAPIProviderA && !VALID_READ_STRING_PTR(lpSecDesc->lpszCAPIProviderA,
			    STRLEN(lpSecDesc->lpszCAPIProviderA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad CAPI provider string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
        }
        // null lpCredentials is ok, sspi will pop the dialg
        if (lpCredentials)            
        {
            // can't pass credentials to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed credentials while creating an unsecure session");                
                LEAVE_DPLAY();
                return DPERR_INVALIDPARAMS;
            }
            // join case will be checked after we find the session in our list

            if (!VALID_READ_DPCREDENTIALS(lpCredentials)) 
            {
                LEAVE_DPLAY();
    			DPF_ERR("invalid credentials structure");
                return DPERR_INVALIDPARAMS;
            }
	        if (!VALID_DPCREDENTIALS_FLAGS(lpCredentials->dwFlags))
	        {
                LEAVE_DPLAY();
  		        DPF_ERRVAL("invalid flags (0x%08x) in credentials!",lpCredentials->dwFlags);
                return DPERR_INVALIDFLAGS;
	        }
		    if ( lpCredentials->lpszUsernameA && !VALID_READ_STRING_PTR(lpCredentials->lpszUsernameA,
			    STRLEN(lpCredentials->lpszUsernameA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad user name string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpCredentials->lpszPasswordA && !VALID_READ_STRING_PTR(lpCredentials->lpszPasswordA,
			    STRLEN(lpCredentials->lpszPasswordA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad password string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
		    if ( lpCredentials->lpszDomainA && !VALID_READ_STRING_PTR(lpCredentials->lpszDomainA,
			    STRLEN(lpCredentials->lpszDomainA)) ) 
		    {
	            LEAVE_DPLAY();
	            DPF_ERR( "bad domain name string pointer" );
	            return DPERR_INVALIDPARAMS;
		    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // initialize here so we can call cleanup routines
    memset(&descW, 0, sizeof(DPSESSIONDESC2));
    memset(&credW, 0, sizeof(DPCREDENTIALS));
    memset(&secDescW, 0, sizeof(DPSECURITYDESC));

	hr = GetWideDesc(&descW,lpsdDesc);
	if (FAILED(hr))
	{
		LEAVE_DPLAY();
		return hr;
	}

    if (lpCredentials)
    {
	    hr = GetWideCredentials(&credW,lpCredentials);
	    if (FAILED(hr))
	    {
            goto CLEANUP_EXIT;
	    }
        pIntCreds = &credW;
    }

    if (lpSecDesc)
    {
	    hr = GetWideSecurityDesc(&secDescW,lpSecDesc);
	    if (FAILED(hr))
	    {
            goto CLEANUP_EXIT;
	    }
        pIntSecDesc = &secDescW;
    }

	LEAVE_DPLAY();
	
	hr = DP_SecureOpen(lpDP,&descW,dwFlags,pIntSecDesc,pIntCreds);

	ENTER_DPLAY();

CLEANUP_EXIT:    
	FreeDesc(&descW,FALSE);
    FreeCredentials(&credW,FALSE);
    FreeSecurityDesc(&secDescW, FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SecureOpen


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_GetPlayerAccount"

HRESULT DPAPI DP_A_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetPlayerAccount(lpDP,dpid,dwFlags,pvBuffer,pdwSize,TRUE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_GetPlayerAccount


#undef DPF_MODNAME
#define DPF_MODNAME "DP_A_SendChatMessage"
HRESULT DPAPI DP_A_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg)
{
	HRESULT hr;
	DPCHAT dpc;
	LPWSTR lpwszMessage = NULL; // unicode message

	ENTER_DPLAY();

    TRY
    {
		// check DPCHAT struct
		if(!VALID_READ_DPCHAT(lpMsg))
		{
			DPF_ERR("Invalid DPCHAT structure");
			hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGEA;
		}
		
		// check message string
		lpwszMessage = lpMsg->lpszMessage;
		if ( !lpwszMessage ||
			!VALID_READ_STRING_PTR(lpwszMessage,WSTRLEN_BYTES(lpwszMessage)) ) 
		{
		    DPF_ERR( "bad string pointer" );
		    hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGEA;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr =  DPERR_INVALIDPARAMS;
		goto EXIT_SENDCHATMESSAGEA;
    }
	
	// Get a Unicode copy of the string
	hr = GetWideStringFromAnsi(&lpwszMessage, lpMsg->lpszMessageA);
	if(FAILED(hr))
	{
		DPF_ERRVAL("Unable to convert message string to Unicode, hr = 0x%08x", hr);
		goto EXIT_SENDCHATMESSAGEA;
	}

	// Copy the user's DPCHAT struct into our local one and change the
	// message string pointer
	memcpy(&dpc, lpMsg, sizeof(DPCHAT));
	dpc.lpszMessage = lpwszMessage;

	LEAVE_DPLAY();

	// call the unicode entry	
	hr = DP_SendChatMessage(lpDP, idFrom, idTo, dwFlags, &dpc);
		
	ENTER_DPLAY();
	
	if(lpwszMessage)
		DPMEM_FREE(lpwszMessage);

EXIT_SENDCHATMESSAGEA:

	LEAVE_DPLAY();
	
	return hr;

} // DP_A_SendChatMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\iplay.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       iplay.c
*  Content:	IDirectPlay implementation
*  History:
*   Date		By		Reason
*   ====		==		======
* 	1/96		andyco	created it
*  	1/30/96		andyco	1st pass at list mgmt
*  	2/1/96		andyco	added namesrv support
*	2/15/96		andyco	added player messages
*	3/31/96		andyco	bugfest! !leaks	
*	4/10/96		andyco	made sp callbacks optional.  validated spdata after
*						create player
*	5/9/96		andyco	idirectplay2 
*	5/21/96		andyco	getcaps, getplayer/groupdata, getsessiondesc
*	5/31/96		andyco	playername, etc.
*	6/10/96		andyco	getxxxname,getsessiondesc copy data, don't give out ptrs.
*	6/19/96		kipo	Bug #1804. Return *pdwSize correctly in DP_Receive if
*						application buffer is too small.
*						Bug #1957. Calls to InternalSetName() had the player boolean
*						and flags parameters switched.
*						Bug #1959. In DP_DestroyGroup() the loop to remove all players
*						in the group was not doing lpGroupnode = lpGroupnode->pNextGroupnode,
*						causing it to reference through a deleted node and crash.
*						Bug #2017. InternalSetData() and SetPlayerData() had similar problems.
*						Memory leaks and crashes were occuring when MemReAlloc() returned
*						a NULL. Also, InternalSetData() was not checking to see if the data
*						length was zero before doing all this work, and was not returning
*						the HRESULT returned by SendDataChanged().
*						Derek Bug. DP_GetGroupName() and DP_GetPlayerName() had the boolean for
*						players and groups were swapped.
*						Derek Bug. InternalGetData() was not checking the application buffer size
*						correctly before copying the buffer.
*	6/20/96		andyco	added WSTRLEN_BYTES
*	6/21/96		kipo	Bug #2083. InternalGetSessionDesc() was using sizeof(DPNAME) instead
*						of sizeof(DPSESSIONDESC2); free existing names if you pass in a null
*						DPNAME structure.
*	6/23/96		kipo	updated for latest service provider interfaces.

*	6/25/96		kipo	added support for DPADDRESS.
*	6/30/96		andyco	added remote + local data, moved setdata to do.c. made 
*						getplayer,internalsetxxx share code.
*	7/1/96		andyco	changed check for !LOCAL instead of REMOTE, since
*						* & 0 will never be !0  (!)
*  7/8/96       ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
*                       to 'dpnName' to match DPLAY.H
*                       Change DPCAPS_NAMESERVER to DPCAPS_ISHOST
*                       Deleted function DP_SaveSession
*	7/10/96		andyco	added pending on nametable download
*	7/10/96		kipo	renamed system messages
*   7/11/96     ajayj   DPSESSION_PLAYERSDISABLED -> DPSESSION_NEWPLAYERSDISABLED
*	7/11/96		andyco	1. dp_destroyplayer was calling dp_deleteplayerfromgroup
*						passing dplayi_dplay instead of dplayi_int.  doh.  	#2330.
*						2. internalopensession was getting session name from
*						user strings, not from nameservers session desc.  caused
*						the name server to appear not to migrate.  #2216.
*						3.  Getplayeraddress changed to look for null callback
*						and return e_notimpl.  #2327. 
*   7/20/96     kipo	InternalGetSessionDesc() was calling STRLEN on a UNICODE
*						string and thus returning the wrong session name length. #2524
*	7/27/96		kipo	Bug #2691. Need to increment/decrement lpGroup->nPlayers when
*						you add/delete players from a group so the name table packing
*						includes the players in groups.	 Player event is a handle now.
*	8/1/96		andyco	changed dp_destroyplayer to internaldestroy.  added 
*						keepalivethreadproc.
*	8/6/96		andyco	added id mangling
*	8/8/96		andyco	added internalxxx for all player mgmt fn's to handle 
*						correctly propagating messages.
*	8/9/96		andyco	check max player on player creation
*	8/10/96		andyco	guaranteed flags.  no more terminatethread for 
*						keepalive thread
*  8/12/96		andyco	added internalreceive so we can get addplayer 10 size correct.
*  8/16/96		andyco 	store nameserver for new id requests
*  8/23/96		kipo	call OS_IsValidHandle() on even passed to CreatePlayer
*  8/28/96		andyco	don't freenametable if getnametable fails - we need 
*						it to get rid of sysplayer (bug 3537)
*  8/30/96		andyco	fix up pointers on destroyplayerorgroup(3655)
*  9/3/96		andyco	drop lock on close,destroyplayer sp callback
*  9/4/96		andyco	DON'T drop lock on destroyplayer!
*  10/2/96      sohailm bug #2847: replaced VALID_*_PTR() macros with VALID_READ_*_PTR() macros
*                       where appropriate.
*  10/2/96      sohailm added code to validate user's DPNAME ptrs before accessing them
*  10/9/96		andyco	got rid of race condition in handlereply by adding
*						gbWaitingForReply. raid #3848.
*  10/10/96		andyco	set this->lpsdDesc to NULL if SP OpenSession call fails,
*						so we can call open again.  raid # 3784.
*  10/11/96     sohailm implemented DP_SetSessionDesc() and InternalSetSessionDesc()
*                       added code to fix up DPSYS_SETSESSIONDESC message pointers
*  10/12/96		andyco	added DPLAYI_GROUP_DPLAYOWNS.  SysGroup. 
*  11/11/96		andyco	support for DPLAYI_PLAYER_APPSERVER, free updatelists w/ 
*						player / groups.  always create sysgroup- no just if 
*						sp optimizes it.
* 11/20/96		andyco	added control panel (perf) thread startup / shutdown.
*						this thread updates the directx control panel w/ dplay
*						stats. see perf.c
*	12/5/96		andyco	if CreateSystemPlayer fails, bail before we try + create 
*						system group (and die)! Bug 4840.
*  01/09/96     sohailm do not return an error if dwMaxPlayers is set to zero (#5171)
*                       return the right error code if dwMaxPlayers is being set to
*                        less than dwCurrentPlayers (#5175)
*  01/16/97     sohailm client now checks if session is allowing players before 
*                       opening it (#4574)
*	1/15/96		andyco	handle groups correctly - added system player groupnode
*						support. 
*	1/24/97		andyco	detect dx3 nameservers. check pidTo + pidFrom in receive.
*						don't allow send of a NULL buffer. Raid 5294,5402, 5403, 5427.
* 	1/28/97		andyco	fixed setdata / setname to pass fPropagate so we can do permission
*						checking
*	2/1/97		andyco	dplay drops lock on send.  take service lock on dp_ entry points.
*	2/11/97		kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
*	2/15/97		andyco	remember the nameserver, even if it's local
*	2/18/97		kipo	fix bugs #4933 and #4934 by checking for invalid flags
*						in InternalCreatePlayer
*   2/26/97     sohailm don't let dwMaxPlayers to be set to more than sp can handle (5447)
*   2/26/97     sohailm initialize the reserved fields in the session desc 
*                       when session is created(4499).
*	3/5/97		andyco	changed keepalive thread to dplay thread
*	3/10/97		andyco	reset only session flags on close
*	3/12/97		myronth	added lobby support for Open & Close
*	3/13/97		myronth	flagged unsupported lobby methods as such
*   3/13/97     sohailm added functions SecureOpen(), CopyCredentials(), ValidateOpenParams(),
*                       modified InternalOpenSession to handle security, and DP_Open to 
*                       to use ValidateOpenParams().
*	3/17/97		myronth	Added lobby support for Create/DestroyGroup/Player
*	3/20/97		myronth	Added lobby support for AddPlayerToGroup and
*						DeletePlayerFromGroup, changed to use IS_LOBBYOWNED macro
*	3/21/97		myronth	Added lobby support for SetGroup/PlayerName, 
*						Get/SetGroup/PlayerData
*   3/18/97     sohailm Added support to cleanup context ptrs from the nametable during Close()
*                       Updated GetNameTable() to not send a nametable request if nameserver is 
*                       DX5 or greater (optimization - nameserver responds to addforward).
*                       Open and SetSessionDesc set the DPSESSION_PASSWORDREQUIRED flag if session
*                       requires a password.
*	3/25/97		kipo	treat zero-length password strings just like NULL password
*						strings for DX3 compatability; check for valid session flags
*						in Open and SetSessionDesc.
*   3/28/97     sohailm don't allow toggling DPSESSION_SECURESERVER in SetSessionDesc.
*   3/30/97     sohailm when open fails, drop the dplay lock before calling close so we don't 
*                       assert in close.
*   3/31/97     sohailm changed dpf to print out session desc flags in hex (open)
*	3/31/97		myronth	Added use of the propagate flag for all player management
*						messages which can come from the lobby.  If the flag is
*						cleared, it means the lobby called it for a remote player.
*   4/02/97     sohailm now we reset the login state when session is closed (7192)
*	4/10/97		myronth	Added support for GetCaps/GetPlayerCaps, fixed GetPlayerAddress
*	4/20/97		andyco	group in group
*   4/23/97     sohailm Added support for reporting signing and encryption caps.
*                       Added support for player message signing and encryption.
*	5/8/97		andyco	removed update list
*	5/8/97		myronth	Turned on system players for lobby-owned objects, made
*						subgroup methods work with the lobby
*	5/11/97		kipo	Fixed bugs #5408, 5406, 7435, 5249, 5250
*	5/13/97		myronth	Pass credentials to lobby's Open call, SecureOpen
*  05/17/97     sohailm Updated InternalOpenSession, Close, and SecureOpen to support CAPI encryption
*                       Removed check for dwMaxPlayers > allowed by SP (5448).
*                       Enabled encryption support.
*                       Now we check the flags in security desc and credentials (8387)
*                       Added DP_GetAccountDesc(), InternalGetAccountDesc().
*	5/17/97		myronth	SendChatMessage and it's pointer fixups
*	5/17/97		kipo	There was a bug in GetNameTable() where it was setting
*						the ghReplyProcessed event twice on the way out,
*						which would let handler.c in, trashing the buffer
*						that GetNameTable() was using.
*	5/17/97		myronth	Can't AddGroupToGroup on the same group
*	5/18/97		kipo	Don't allow group operations on the system group
*	5/18/97		kipo	Set DPLAYI_GROUP_STAGINGAREA flag in InternalCreatePlayer
*   5/18/97     sohailm Now we check if client is logged in before we allow send on 
*                       a secure player to player message.
*	5/20/97		myronth	Changed when lobby is called in AddPlayerToGroup,
*						DeletePlayerFromGroup, and DestroyGroup. (Bug #8586)
*						Removed the STAGINGAREA error case for CreateGroup (Bug #8743)
*   5/21/97     kipo	Bug #8744: DPSESSION_MULTICASTSERVER can't be changed
*						by SetSessionDesc().
*	5/21/97		myronth	Moved AddPlayerToGroup call in the lobby to eliminate
*						a race condition
*   5/22/97     kipo	Bug #8330: because the session list is not global in DX
*						we had a regression with X-Wing vs. Tie Fighter, fixed
*						by re-aquiring the session; added DPSP_MSG_AUTONAMETABLE
*						check in GetNameTable
*	5/22/97		myronth	Changed when lobby is called in DeletePlayerFromGroup
*						and DestroyGroup.  Now drop locks in several other
*						functions when we call the lobby.
*	5/23/97		andyco	unpack session desc w/ nametable. don't allow send
*						to non-local player unless i'm the multicastserver
*	5/23/97		kipo	Added support for return status codes
*	5/23/97		myronth	Fixed DeleteGroupFromGroup bug #8396, changed name of
*						RemoveGroupFromGroups to RemoveGroupFromAllGroups
*   5/24/97     sohailm We weren't setting the security description parameters correctly
*                       when user passed in a NULL CAPI provider name.
*	5/27/97		myronth	Re-fixed #8396 at a higher level
*	5/30/97		myronth	Added DP_GetGroupParent
*   5/30/97     sohailm update CopyCredentials() and DP_SecureOpen() to handle domain name.
*                       Added DP_GetPlayerAccount() and InternalGetPlayerAccount()
*	5/30/97		kipo	Added GetPlayerFlags() and GetGroupFlags()
*	6/2/97		andyco	raid 9199 + 9063.  multicast server + client server error checking.
*	6/4/97		myronth	Bug #9146 -- SendChatMessage with remote From player should fail
*	6/4/97		myronth	Bug #9507 -- Failed lobby Open was leaving the dplay object initialized
*	6/4/97		kip		Bug #9311 don't param check DPNAME structure (regression with DX3)
*	6/6/97		myronth	Moved call to lobby in InternalDeletePlayerFromGroup
*   6/09/97     sohailm More parameter validation in DP_SecureOpen()
*	6/11/97		myronth	Drop dplay lock before calling lobby GetCaps/GetPlayerCaps (#9756)
*   6/16/97     sohailm no security on sps that don't support reliable messages (#9872).
*   6/22/97     sohailm Secure messages are now routed using the multi-casting code.
*                       Added check to not allow raw player messages in a secure session.
*   6/23/97     sohailm Cleanup public keys when session is closed.
*   6/24/97     sohailm We were releasing the crypt context before releasing keys (#10272).
*   6/25/97     kipo	Only allow secure server when client server is also set
*   7/28/97		sohailm Enable multicast with security by default.
*						Removed check for client-server when secure session is requested.
*						Raw player messages are not allowed in a secure session.
*   8/4/97		andyco	reset this->dwMinVersion on close
*	8/19/97		myronth	Added <mmsystem.h> dependency to make the NT build happy
*	8/29/97		sohailm	return hresult in RemoveGroupFromGroupList (bug 10927) + 
*						don't drop lock in RemoveGroupFromGroupList (bug 10933).
*	9/29/97		myronth	SetPlayer/GroupData/Name calls to lobby now wait for
*						response from server before changing local info (#12554)
*						SendChatMessage sends to remote players for DPID_ALLPLAYERS (#12524)
*	10/21/97	myronth	Added hidden flag to CreateGroup, Added stubbed out
*						group owner methods
*	10/29/97	myronth	Added support for group owners (affects Create/DestroyGroup,
*						CreateGroupInGroup, DestroyPlayer)
*	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
*   11/17/19    aarono  Added SendEx/GetMessageQueue/CancelSend
*	11/19/97	myronth	Allow host to destroy remote players (#12901) and
*						fixed bug in InternalGetCaps (#12634)
*	11/24/97	myronth	Fixed CreateGroupInGroup w/ ParentID = 0 (#15245)
*						and EnumJoinSession w/ max players (#15229)
*	12/5/97		andyco	voice stuff
*	12/29/97	myronth	TRUE != DPSEND_GUARANTEED (#15887), Also fixed
*						CreateGroupInGroup for invalid parent (#15245), and
*						Removed invalid DeleteGroupFromGroup msg for real
*						child groups (#15264)
*	12/29/97	sohailm	Clients can't join secure session if hosted with DPOPEN_RETURNSTATUS (#15239)
*						Send SetSessionDesc system message reliably (#15461)
*	01/14/98	sohailm	Clear DPCAPS_GROUPOPTIMIZED flag when CLIENT_SERVER, DX3_INGAME,
*						or SECURE_SERVER (#15210)
*	1/20/98		myronth	#ifdef'd out voice support
*	1/26/98		sohailm	added session flags to SP_OPEN data structure
*	1/26/98		sohailm added an upper bound to join timeout.
*   2/2/98      aarono  moved FreePacketList and re-ordered locking to avoid 
*                       deadlock on close.
*   2/2/98      aarono  fixed error checking on priority in DP_SendEx
*   2/3/98      aarono  changed when we get remote version to DP_Open
*   2/3/98      aarono  changed open to get frame size again in case changed because protocol running.
*   2/13/98     aarono  async support
*   2/18/98     aarono  moved ProtocolInit into Open
*                       call protocol direct rather than through table.
*   2/19/98     aarono  call FiniProtocol in DP_Close
*   3/5/98	    aarono	B#18776 don't allow changing DPSESSION_DIRECTPROTOCOL in SetSessionDesc
*   3/5/98	    aarono	B#19916 don't allow GetMessageQueue on idFrom a group.
*   3/10/98     aarono  adding ref on dplay object insufficient, added ENTER_DPLAY()
*                       to DP_Cancel and DP_GetMessageQueue.
*   3/12/98     aarono  fixed DP_Close to shutdown threads better
*   3/13/98     aarono  fixed packetize shutdown for packetizeandsendreliable change
*   3/13/98     aarono  fixed protocol initialization path by getting caps everytime
*   3/13/98     aarono  changed DP_SendEx to validate send parms earlier.
*   3/19/98     aarono  don't let app change DPSESSION_OPTIMIZELATENCY flag.
*   3/30/98     aarono  fix locking in MessageQueue and Cancel methods.
*   3/31/98    a-peterz #21331: Check flags before using them.
*   4/15/98     aarono  B#22909 validate idTo on GetMessageQueue
*   4/23/98     aarono  fix memory leak in GetNameTable
*   6/2/98      aarono  don't wait for pending sends
*                       pass DPSEND_NOCOPY to protocol if present
*                       fix psp accounting on error in SendEx
*                       Make GetMessageQueue ask for System Queue
*   6/6/98      aarono  Don't drop DPLAY() lock across ProtocolDeletePlayer
*                       since code around it can't handle it.
*   6/8/98      aarono+peterz B#25311 BellHop can't shutdown, because of
*                       re-enter to close, made this OK.
*  6/10/98 aarono add PendingList to PLAYER and SENDPARM, complete pending
*                     sends on close before blowing away PLAYER
*  6/19/98      aarono add last ptr for message queues, makes insert
*                      constant time instead of O(n) where n is number
*                      of messages in queue.
*  6/22/98      aarono NULL sysplayer when blowing it away.
*  1/27/99      aarono don't call SP when create player not there.
*  7/9/99       aarono MANBUG#25328 not protecting release of protocol
*                      properly can cause exception when racing close.
*  8/02/99		aarono removed old voice support
*  8/05/99      aarono Moved voice over to DPMSG_VOICE
*  8/05/99		rodtoll Added call into retrofit
*  8/20/99		rodtoll	Added support for new retrofit
*  10/25/99		pnewson added support for launching voice via new 
*						application flags
* 11/02/99		rodtoll	Fixes to support Bug #116677 - Can't use lobby clients that don't hang around
* 12/13/99		pnewson bugs #123583, 123601, 123604 - support to launch dpvhelp.exe on 
*						apps that are not registered or badly registered
* 05/19/00      rodtoll Bug #34304 - Retrofit is launched for non-TCP/IP providers
* 06/26/00 aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
*                       added re-notification during simultaneous join CREATEPLAYERVERIFY
* 07/22/00 rodtoll Bug #40296, 38858 - Crashes due to shutdown race condition
*   				 Now for a thread to make an indication into voice they addref the interface
*					 so that the voice core can tell when all indications have returned.    
* 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
* 01/18/2001	rodtoll	Prevent retrofit from running on Whistler
*
***************************************************************************/

// issues:
// 	some stuff in try/except blocks is not really dangerous...
  
// todo - get latency w/ player caps
// todo - who has right to set session desc?

#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"
#include "dvretro.h"
#include "dplobpr.h"

// todo - This #define can be removed once we fix the DPF stuff on NT.
// currently, this is not getting defined by the makefile like it is
// on Win95, so we need to define it here. -- myronth
#ifndef PROF_SECT
#define PROF_SECT	"DirectPlay"
#endif // PROF_SECT

// registry keys and value names
#define DPLAY_REGISTRY_APPS		"Software\\Microsoft\\DirectPlay\\Applications"
#define REGSTR_VAL_GUID	    	"Guid"
#define REGSTR_VAL_FLAGS	    "dwFlags"

#undef DPF_MODNAME
#define DPF_MODNAME "DPVoiceCheckOS"
// DPVoiceCheckOS
//
// This function returns TRUE if this is a platform the retrofit runs on.
//
// This function will return DVERR_GENERIC if this is a platform the retrofit does not
// run on.
//
HRESULT DPVoiceCheckOS()
{
	OSVERSIONINFOA osVerInfo;
	LONG lLastError;

	osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFOA );

	if( GetVersionExA( &osVerInfo ) )
	{
		// Win2K
		if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
		{
			// NOTE: If we enable Whistler support we have to ensure that this returns an error
			// 		 if we're booting in safe-mode!
			/*
			// Whistler -- Major Version = 5 & Build # > 2195
			if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
			{
				return DV_OK;
			}*/

			return DVERR_GENERIC;
		}
		// Win9X
		else
		{
			// Millenium Major = 4, Minor = 90
			if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) &&
				(LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
			{
				return DV_OK;
			}

			return DVERR_GENERIC;
		}
	}
	else
	{
		lLastError = GetLastError();

		return DVERR_GENERIC;
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"LookupVoiceRetrofitFlag"
BOOL LookupVoiceRetrofitFlag(LPGUID lpguidApp)
{
	CHAR szAppKeyName[_MAX_PATH];
	CHAR szGuidValueName[_MAX_PATH];
	CHAR szFlagsValueName[_MAX_PATH];
	CHAR szFileValueName[_MAX_PATH];
	CHAR szFile[_MAX_PATH];
	CHAR szLauncherValueName[_MAX_PATH];
	CHAR szLauncher[_MAX_PATH];
	CHAR name[_MAX_PATH];
	CHAR guidString[_MAX_PATH];
	WCHAR guidWString[_MAX_PATH];
	LONG lErr;
	HKEY hKey;
	DWORD index;
	INT i;
	HRESULT hr;
    DWORD	type;
    DWORD	cb;
    DWORD	flags;
    BOOL fRet = FALSE;
	HANDLE hFile;
	CHAR file_name[_MAX_PATH]; // general purpose
	CHAR name_last[_MAX_PATH]; // stores last component of file_name

	// Shortcut to ensure retrofit doesn't load on Whistler  
	if( FAILED( DPVoiceCheckOS() ) )
		return FALSE;

	file_name[0]=0; // make prefix happy.

    // Dump the guid for debug purposes.
    DPF(5, "Looking up Voice Retrofit Flag for app");
    DPF(5, "App GUID: {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}", 
    	lpguidApp->Data1,
    	lpguidApp->Data2,
    	lpguidApp->Data3,
    	lpguidApp->Data4[0],
    	lpguidApp->Data4[1],
    	lpguidApp->Data4[2],
    	lpguidApp->Data4[3],
    	lpguidApp->Data4[4],
    	lpguidApp->Data4[5],
    	lpguidApp->Data4[6],
    	lpguidApp->Data4[7]);    	

	// sniff out the exe file name of the current game
    hFile =  GetModuleHandleA( NULL );
	
	GetModuleFileNameA( hFile, file_name, sizeof(file_name));

	DPF(5,"Full App NAME: %s",file_name);

    i = strlen( file_name )-1;
    while( i >=0 && file_name[i] != '\\' )
    {
	i--;
    }
    i++;
    strcpy( name_last, &file_name[i] );
	DPF(5,"App EXE NAME: %s", name_last);
    
	
	// look in the applications key to see if the voice retrofit should be run
	
	hr = WideToAnsi(szAppKeyName, SZ_DPLAY_APPS_KEY, OS_StrLen(SZ_DPLAY_APPS_KEY));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert key name to ANSI");
		return FALSE;
	}
	hr = WideToAnsi(szGuidValueName, SZ_GUID, OS_StrLen(SZ_GUID));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}
	hr = WideToAnsi(szFlagsValueName, SZ_DWFLAGS, OS_StrLen(SZ_DWFLAGS));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}

	hr = WideToAnsi(szFileValueName, SZ_FILE, OS_StrLen(SZ_FILE));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}

	hr = WideToAnsi(szLauncherValueName, SZ_LAUNCHER, OS_StrLen(SZ_LAUNCHER));
	if (FAILED(hr))
	{
		DPF(0, "Unable to convert value name to ANSI");
		return FALSE;
	}
	
	lErr = RegOpenKeyExA(HKEY_LOCAL_MACHINE,szAppKeyName,0,KEY_READ,&hKey);
	
	if (ERROR_SUCCESS != lErr) 
	{
		DPF(0,"Could not open registry key err = %d, there must be no applications registered",lErr);
		return FALSE;	// ok, no registered apps, no voice
	}

	// read the dwFlags value from the root app key for the default retrofit decision
	cb = sizeof( flags );
    if( !RegQueryValueExA( hKey, szFlagsValueName, NULL, &type, (LPSTR) &flags, &cb ) )
	{
		DPF(5, "Found global application flags, checking for DPLAPP_AUTOVOICE");
		if (flags & DPLAPP_AUTOVOICE)
		{
			DPF(5, "Found global application flags (0x%08x), defaulting to voice retrofit ON", flags);
			fRet = TRUE;			
		}
		else
		{
			DPF(5, "Found global application flags (0x%08x), defaulting to voice retrofit OFF", flags);
			fRet = FALSE;
		}
	}
	else
	{
		DPF(5, "No global application flags found, defaulting to voice retrofit OFF");
		fRet = FALSE;
	}

	index = 0;
    /*
     * run through all keys
     */
    while( !RegEnumKeyA( hKey, index, name, sizeof( name ) ) )
    {
		HKEY	hsubkey;
	    GUID 	guid;
	    HRESULT hr;
	    BOOL 	fMatch;

		
		if(!RegOpenKeyA(hKey,name,&hsubkey))
		{
			// get the GUID for this entry
			cb = sizeof( guidString );
		    if( !RegQueryValueExA( hsubkey, szGuidValueName, NULL, &type, guidString, &cb ) )
		    {
				if( type == REG_SZ )
				{
					DPF(5, "Registry GUID: %s", guidString);
				   	// convert the string from the registry to a real guid
				   	hr = AnsiToWide(guidWString, guidString, cb);
				   	if (!FAILED(hr))
				   	{
				   		hr = GUIDFromString(guidWString, &guid);
				   		if (FAILED(hr))
						{
							DPF( 0, "    Error converting from string to guid");
							guid = GUID_NULL;
						}
					} else {
				   		DPF(0, "    Unable to convert string to wide string");
						guid = GUID_NULL;
					}
				} else {
				   	DPF( 0, "    Guid not a string!!!" );
					guid = GUID_NULL;
				}
			} else {
				DPF( 0, "    Guid name not found!!!" );
				guid = GUID_NULL;
		    }

			// get the "File" for this entry
			cb = sizeof( szFile );
		    if( !RegQueryValueExA( hsubkey, szFileValueName, NULL, &type, szFile, &cb ) )
		    {
				if( type == REG_SZ )
				{
					DPF(5, "Registry File: %s", szFile);
				} else {
				   	DPF( 0, "    File not a string!!!" );
					szFile[0] = 0;
				}
			} else {
				DPF( 0, "    File name not found!!!" );
				szFile[0] = 0;
		    }

			// get the "Launcher" for this entry
			cb = sizeof( szLauncher );
		    if( !RegQueryValueExA( hsubkey, szLauncherValueName, NULL, &type, szLauncher, &cb ) )
		    {
				if( type == REG_SZ )
				{
					DPF(5, "Registry Launcher: %s", szLauncher);
				} else {
				   	DPF( 0, "    Launcher not a string!!!" );
					szLauncher[0] = 0;
				}
			} else {
				DPF( 0, "    Launcher name not found!!!" );
				szLauncher[0] = 0;
		    }

		   	// check to see if this entry's GUID matches the app GUID,
		   	// or if the exe name matches the File or Launcher entries
			fMatch = FALSE;
		   	if (!IsEqualGUID(&guid, &GUID_NULL))
		   	{
			   	if (IsEqualGUID(&guid, lpguidApp))
			   	{
			   		DPF(5, "Found matching app GUID in registry");
			   		fMatch = TRUE;
			   	}
			}
			if (szFile[0] != 0)
			{
				if (_stricmp(szFile, name_last) == 0)
				{
			   		DPF(5, "Found matching app File in registry");
			   		fMatch = TRUE;
				}
			}
			if (szLauncher[0] != 0)
			{
				if (_stricmp(szLauncher, name_last) == 0)
				{
			   		DPF(5, "Found matching app Launcher in registry");
			   		fMatch = TRUE;
				}
			}

			if (fMatch == TRUE)
			{
		   		// we have a match, get the flags
			    cb = sizeof( flags );
			    if( !RegQueryValueExA( hsubkey, szFlagsValueName, NULL, &type, (LPSTR) &flags, &cb ) )
			    {
					if( (type == REG_DWORD) || (type == REG_BINARY && cb == sizeof( flags )) )
					{
						DPF(5, "App flags: %x", flags);
						// we have the flags, set the retrofit bit if the flags
						// indicate to do so
						if ((flags & DPLAPP_AUTOVOICE) && !(flags & DPLAPP_SELFVOICE))
						{
							// that's it, turn on the voice
							DPF(5, "Found app specific retrofit flags (%08x), voice retrofit ON", flags);
							fRet = TRUE;
						}
						else
						{
							DPF(5, "Found app specific retrofit flags (%08x), voice retrofit OFF", flags);
							fRet = FALSE;
						}
				    } else {
				    	DPF( 0, "    Not BINARY DWORD flags\n");
				    }
				} else {
					DPF( 0, "    No flags found for app %s", name );
			    }
				break; // get out of loop
			}
			
		}
		if(hsubkey)RegCloseKey(hsubkey);
		hsubkey=NULL;
		index++;
	}

	RegCloseKey(hKey);

	return fRet;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_AddGroupToGroup"
HRESULT InternalAddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup,DWORD dwFlags,
	BOOL fPropagate) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_GROUP lpGroupTo; 
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_SUBGROUP lpSubgroup;
	
	DPF(5,"adding group id %d to group id %d fPropagate = %d\n",idGroup,idGroupTo,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    
        lpGroupTo = GroupFromID(this,idGroupTo);
        if ((!VALID_DPLAY_GROUP(lpGroupTo)) || (DPID_ALLPLAYERS == idGroupTo)) 
        {
			DPF_ERRVAL("invalid parent group id = %d", idGroupTo);
            return DPERR_INVALIDGROUP;
        }

        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	
	// make sure they aren't trying to add a group to itself
	if(lpGroupTo == lpGroup)
	{
		DPF_ERR("Cannot add a group to itself");
		return DPERR_INVALIDGROUP;
	}

	// make sure group isn't already in group
	lpSubgroup = lpGroupTo->pSubgroups;
    while (lpSubgroup) 
    {
        if (lpSubgroup->pGroup == lpGroup) 
        {
			DPF(0,"group already in group!");
			return DP_OK;
        }
		// check next node
        lpSubgroup = lpSubgroup->pNextSubgroup;
    }

    // need a new DPLAYI_SUBGROUP
    lpSubgroup = DPMEM_ALLOC(sizeof(DPLAYI_SUBGROUP));
    if (!lpSubgroup) 
    {
        DPF_ERR("out of memory getting groupnode");
        return E_OUTOFMEMORY;
    }

	if (fPropagate)
	{
		if (dwFlags & DPGROUP_SHORTCUT)
		{
			hr = SendPlayerManagementMessage(this, DPSP_MSG_ADDSHORTCUTTOGROUP, idGroup, 
				idGroupTo);
			
		}
				
		if (FAILED(hr))	
		{
			ASSERT(FALSE); // sendsysmessage should not fail!
			// if this failed, we could have hosed global name table
			// keep going...
			hr = DP_OK;
		}
	}

	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared. If it is cleared, the lobby is calling us for a
	// remote group and we don't want to call it back in that case.
	// Also, if the DPGROUP_SHORTCUT flag is not set, then this is
	// being called from CreateGroupInGroup, so don't call the lobby
	// in that case.  The lobby will be called from DP_CreateGroupInGroup
	if((IS_LOBBY_OWNED(this)) && (fPropagate) && (dwFlags & DPGROUP_SHORTCUT))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		// REVIEW!!!! -- Should we make sure the service lock is taken???
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_AddGroupToGroup(this->lpLobbyObject, idGroupTo, idGroup);

		// Take the lock back
		ENTER_DPLAY();

		// If the lobby failed, free our memory and exit without adding the group
		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to add group to group, hr = 0x%08x", hr);
			DPMEM_FREE(lpSubgroup);
			return hr;
		}
	}

	// set up the players groupnode
    lpSubgroup->pGroup = lpGroup;
	lpSubgroup->dwFlags = dwFlags;
	
	// stick it on the front
	lpSubgroup->pNextSubgroup = lpGroupTo->pSubgroups;
	lpGroupTo->pSubgroups = lpSubgroup;
	// update groupto
	lpGroupTo->nSubgroups++;

    // updates groups group info
    lpGroup->nGroups++;
    lpGroup->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;
	
    return DP_OK;
	
}  // InternalAddGroupToGroup  

HRESULT DPAPI DP_AddGroupToGroup(LPDIRECTPLAY lpDP, DPID idGroupTo, DPID idGroup) 
{
	HRESULT hr;
	
	ENTER_ALL();	
	
	hr = InternalAddGroupToGroup(lpDP,idGroupTo,idGroup,DPGROUP_SHORTCUT,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
} // DP_AddGroupToGroup

  
#undef DPF_MODNAME
#define DPF_MODNAME	"DP_AddPlayerToGroup"

// we asked the SP to add a player to this group
// the SP failed, so we make the group dplay owned
// this means we have to call the sp to remove all players and destroy the group (just call
// the SP, we don't actually destroy the group)
HRESULT MakeGroupDPlayOwned(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup)
{
	HRESULT hr=DP_OK;
    LPDPLAYI_GROUPNODE lpGroupnode;
	DPSP_REMOVEPLAYERFROMGROUPDATA removedata;
	DPSP_DELETEGROUPDATA deletedata;
	
    ASSERT(!(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS));

    if (this->pcbSPCallbacks->RemovePlayerFromGroup) 
    {
		// a-josbor: ask the sp to remove all players from the group
		// only do this if we have an SP that is DX6 or later!
		if ((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
		{
		    lpGroupnode = lpGroup->pGroupnodes;
		    while ( lpGroupnode )
		    {
		        ASSERT(lpGroupnode->pPlayer);
			     // notify sp
				removedata.idPlayer = lpGroupnode->pPlayer->dwID;
				removedata.idGroup = lpGroup->dwID;        
				removedata.lpISP = this->pISP;

			    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&removedata);
			    if (FAILED(hr)) 
			    {
					DPF(0,"MakeGroupDPlayOwned :: SP - remove player from group failed - hr = 0x%08lx\n",hr);
					// keep going
			    }
			    lpGroupnode = lpGroupnode->pNextGroupnode;
			}
		}
		
		// ask the sp remove all the system players from the group 
	    lpGroupnode = lpGroup->pSysPlayerGroupnodes;
	    while ( lpGroupnode )
	    {
	        ASSERT(lpGroupnode->pPlayer);
		     // notify sp
			removedata.idPlayer = lpGroupnode->pPlayer->dwID;
			removedata.idGroup = lpGroup->dwID;        
			removedata.lpISP = this->pISP;

		    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&removedata);
		    if (FAILED(hr)) 
		    {
				DPF(0,"MakeGroupDPlayOwned :: SP - remove player from group failed - hr = 0x%08lx\n",hr);
				// keep going
		    }
		    lpGroupnode = lpGroupnode->pNextGroupnode;
		}
		
		
	}
	else 
	{
		// no callback - no biggie
	}
	
	// now, tell sp to nuke group
    if (this->pcbSPCallbacks->DeleteGroup) 
    {
	    // call sp
		deletedata.idGroup = lpGroup->dwID;
		deletedata.dwFlags = lpGroup->dwFlags;
		deletedata.lpISP = this->pISP;

    	hr = CALLSP(this->pcbSPCallbacks->DeleteGroup,&deletedata);
		if (FAILED(hr)) 
		{
			DPF(0,"MakeGroupDPlayOwned :: SP - delete group failed - hr = 0x%08lx\n",hr);
			// keep going
		}
    }
	else 
	{
		// no callback - no biggie
	}
											   
	// dplay owns it!										   
    lpGroup->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
    
    return DP_OK;
			
} // MakeGroupDPlayOwned

LPDPLAYI_GROUPNODE FindPlayerInGroupList(LPDPLAYI_GROUPNODE pGroupnode,DPID id)
{
	BOOL bFound = FALSE;
	LPDPLAYI_GROUPNODE pFoundNode = NULL;
	
	while (pGroupnode && !bFound)
	{
		if (pGroupnode->pPlayer->dwID == id)
		{
			bFound = TRUE;
			pFoundNode = pGroupnode;
		}
		else 
		{
			pGroupnode = pGroupnode->pNextGroupnode;	
		}
	} // while
	
	return pFoundNode;
	
} // FindPlayerInGroupList


// assumption: we only add sys players to sys groups
HRESULT InternalAddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer,BOOL fPropagate) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_PLAYER lpPlayer;
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_GROUPNODE lpGroupnode,lpSysGroupnode=NULL, lpGroupNodeAlloc=NULL;
	DPSP_ADDPLAYERTOGROUPDATA data;
	BOOL fSysPlayer = FALSE;
	
	DPF(5,"adding player id %d to group id %d fPropagate = %d\n",idPlayer,idGroup,fPropagate);

    //
	// Validate parameters
    // 
    
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    
        lpGroup = GroupFromID(this,idGroup);
        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d",idGroup);
            return DPERR_INVALIDGROUP;
        }

        lpPlayer = PlayerFromID(this,idPlayer);
        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }
        
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	//
	// Ensure that sys players are only added
	// to sysgroups
	//

	if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		ASSERT(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP); // should only add sysplayers to sysgroup!
		fSysPlayer = TRUE;
	}
	

	//
	// Ensure that we don't add a player
	// to a group of which he is already a 
	// member
	//
	if (fSysPlayer)
	{
		lpGroupnode = lpGroup->pSysPlayerGroupnodes;	// sys players go in the sysplayer group nodes
	} else {
		lpGroupnode = lpGroup->pGroupnodes;				// regular players go in the regular player list
	}	
		
    while (lpGroupnode) 
    {
        if (lpGroupnode->pPlayer == lpPlayer) 
        {
			if (fSysPlayer)  
				DPF(3,"system player already in group!");
			else 
				DPF(0,"player already in group -- idGroup = %lx, idPlayer = %lx", idGroup, idPlayer);
				
			return DP_OK;			// we found the player already in this group.  Just return quietly.
        }
		// check next node
        lpGroupnode = lpGroupnode->pNextGroupnode;
    }


	//	alloc the player's node now
	lpGroupNodeAlloc=DPMEM_ALLOC(sizeof(DPLAYI_GROUPNODE));
	if(!lpGroupNodeAlloc){
		return DPERR_NOMEMORY;
	}
	

	// if the player being added isn't a sys player and there is no DX3 in the game,
	//	we need to make sure the sys player for this player is in the game
	if (!fSysPlayer && !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
	{
		LPDPLAYI_PLAYER pSysPlayer = PlayerFromID(this,lpPlayer->dwIDSysPlayer);
		ASSERT(VALID_DPLAY_PLAYER(pSysPlayer));
		if (!VALID_DPLAY_PLAYER(pSysPlayer))
		{
			DPF(0,"could not find system player");
			ASSERT(FALSE);
			// let it go...
			hr = E_FAIL;
			goto EXIT;
		}
			
		// is this players system player in the group?
		lpSysGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpPlayer->dwIDSysPlayer);

		// if not, we go ahead and add it.  
		if (!lpSysGroupnode)
		{

			 // alloc a groupnode for the system player
		    lpSysGroupnode = DPMEM_ALLOC(sizeof(DPLAYI_GROUPNODE));
		    if (!lpSysGroupnode) 
		    {
		        DPF_ERR("out of memory adding system group node");
		        hr=E_OUTOFMEMORY;
		        goto EXIT;
		    }

			//
			// NOTE: In DX6, we add both the sysplayers and the regular players to the
			//       group AND INFORM THE SP.  It is up to the SP to distinguish
			//       systemplayers and regular players in a group.  The SP may
			//       deliver receives EITHER to the sysplayers or the regular
			//       players but not both.  The SP can differentiate sysplayers
			//       from regular players based on the flags passed into 
			//       SP_CreatePlayer.

			// now, inform the SP that we're adding this player to the group
			// this matches what happened with pre-DX6 SPs ( only sys players
			//	added to non-sys groups were told to the SP)
		    if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
				&& (this->pcbSPCallbacks->AddPlayerToGroup))
		    {
				ASSERT(lpSysGroupnode);
				data.idPlayer = pSysPlayer->dwID;
				data.idGroup = lpGroup->dwID;
 				data.lpISP = this->pISP;
				        
			    hr = CALLSP(this->pcbSPCallbacks->AddPlayerToGroup,&data);
		    }
			else 
			{
				// SP not required to implement this
				hr = DP_OK;
			}
		    if (FAILED(hr)) 
		    {
				DPF(2,"SP - AddPlayerToGroup failed - hr = 0x%08lx - GROUP FUNCTIONALITY WILL BE EMULATED",hr);    

				// take ownership of this group
				hr = MakeGroupDPlayOwned(this,lpGroup);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
					// keep going.  sp may have not been able to clean up group - we keep trying...
					hr = DP_OK;
				}
		    } // FAILED(hr)

//			add our new group node to the front of the list
		    lpSysGroupnode->pNextGroupnode = lpGroup->pSysPlayerGroupnodes;
		    lpSysGroupnode->pPlayer = pSysPlayer;
		    lpSysGroupnode->nPlayers = 1;
		    lpGroup->pSysPlayerGroupnodes = lpSysGroupnode;

			// update the counts for the sysplayer
		    pSysPlayer->nGroups++;
	    	pSysPlayer->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;
		}
		else
		{
			lpSysGroupnode->nPlayers++;
		}
	}


//	Now add the player that was originally passed to us

	//	grab the pre-alloced group node
    lpGroupnode = lpGroupNodeAlloc;
	lpGroupNodeAlloc = NULL;
	
	//	first send the notification to the others.  Note we don't
	//	propagate sys group info
	if (!(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP) && fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_ADDPLAYERTOGROUP, idPlayer, 
			idGroup);
		if (FAILED(hr))	
		{
			ASSERT(FALSE); // sendsysmessage should not fail!
			// if this failed, we could have hosed global name table
			// keep going...
			hr = DP_OK;
		}
	}

	//	now, inform the SP that we're adding this player to the group
	//	a-josbor: only if this is DX6 or later
    if (((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
		&& !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
		&& (this->pcbSPCallbacks->AddPlayerToGroup) )
    {
		data.idPlayer = idPlayer;
		data.idGroup = idGroup;
		data.lpISP = this->pISP;
		        
	    hr = CALLSP(this->pcbSPCallbacks->AddPlayerToGroup,&data);
    }
	else 
	{
		// SP not required to implement this
		hr = DP_OK;
	}
    if (FAILED(hr)) 
    {
		DPF(2,"SP - AddPlayerToGroup failed - hr = 0x%08lx - GROUP FUNCTIONALITY WILL BE EMULATED",hr);    

		// take ownership of this group
		hr = MakeGroupDPlayOwned(this,lpGroup);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going.  sp may have not been able to clean up group - we keep trying...
			hr = DP_OK;
		}
    } // FAILED(hr)


	//
	// Update all the group cruft
	//

	// set up the player's groupnode	
	lpGroupnode->pNextGroupnode = 
		(fSysPlayer) ? lpGroup->pSysPlayerGroupnodes : lpGroup->pGroupnodes; // put the new node on the right list
	lpGroupnode->pPlayer = lpPlayer;
	lpGroupnode->nPlayers = 0;

	// fix up the groups structure
	if (fSysPlayer)
	{
		lpGroup->pSysPlayerGroupnodes = lpGroupnode;
	}
	else
	{
		lpGroup->pGroupnodes = lpGroupnode;
		lpGroup->nPlayers++;
	}
	
	// fix up the player struct
	lpPlayer->nGroups++;
	lpPlayer->dwFlags |= DPLAYI_PLAYER_PLAYERINGROUP;		


	//
	// Finally, give the lobby a crack at
	// it, if necessary.


	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared. If it is cleared, the lobby is calling us for a
	// remote player and we don't want to call it back in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		// REVIEW!!!! -- Should we make sure the service lock is taken???
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_AddPlayerToGroup(this->lpLobbyObject, idGroup, idPlayer);
		
		// Take the lock back
		ENTER_DPLAY();

		// If the lobby failed, remove the player from the group
		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to add player to group, hr = 0x%08x", hr);
			InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->pInterfaces,
					idGroup, idPlayer, FALSE);
		}
	}

EXIT:
	if(lpGroupNodeAlloc){
		DPMEM_FREE(lpGroupNodeAlloc);
	}
	
    return hr;
}  // InternalAddPlayerToGroup  


HRESULT DPAPI DP_AddPlayerToGroup(LPDIRECTPLAY lpDP, DPID idGroup, DPID idPlayer) 
{
	HRESULT hr;
	
	ENTER_ALL();	
	
	// bug 5807 - don't allow user to addplayer to system group
	if (DPID_ALLPLAYERS == idGroup)
	{
		LEAVE_ALL();
		DPF_ERRVAL("invalid group id = %d", idGroup);
		return DPERR_INVALIDGROUP;
	}

	hr = InternalAddPlayerToGroup(lpDP,idGroup,idPlayer,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_AddPlayerToGroup

#undef DPF_MODNAME
#define DPF_MODNAME "FreePacketList"
// remove any packetized mesages that haven't been completed yet
void FreePacketList(LPDPLAYI_DPLAY this)
{
	LPPACKETNODE pNode,pNodeNext;
	UINT_PTR uTickEvent;

	//
	// Packet list nulled here to keep PacketizeTick from
	// accessing the list while we are freeing it.
	//
	
	pNode = this->pPacketList;
	this->pPacketList = NULL;
	uTickEvent=this->uPacketTickEvent;
	this->uPacketTickEvent=0;

	LEAVE_DPLAY();
	if(uTickEvent){
		// Shutdown the ticker that ages out 
		// PacketizeAndSend Receives. -- can't hold DPLAY lock when
		// calling timeKillEvent on an event that takes the lock since
		// on NT timeKillEvent doesn't return until the function is
		// done, which would cause a deadlock if we had the lock.
		timeKillEvent((DWORD)uTickEvent);
	}	
	ENTER_DPLAY();

	while (pNode)
	{
		pNodeNext = pNode->pNextPacketnode;

		if(pNode->bReliable && pNode->bReceive){
			this->nPacketsTimingOut -= 1;
			ASSERT(!(this->nPacketsTimingOut&0x80000000));
		}

		// free up the packet node
		FreePacketNode(pNode);
				
		pNode = pNodeNext;
	}
	
	ASSERT(this->nPacketsTimingOut == 0);

	Sleep(0); // allow expired timers to run.

	return ;
	
} // FreePacketList

// remove any pending messages
void FreePendingList(LPDPLAYI_DPLAY this)
{
	LPPENDINGNODE pmsg,pmsgNext;

	pmsg = this->pMessagesPending;
	while (pmsg)
	{
		pmsgNext = pmsg->pNextNode;
		if (pmsg->pMessage) DPMEM_FREE(pmsg->pMessage);
		if (VALID_SPHEADER(pmsg->pHeader)) DPMEM_FREE(pmsg->pHeader);
		DPMEM_FREE(pmsg);
		pmsg = pmsgNext;
	}

	this->pMessagesPending = NULL;
	this->pLastPendingMessage = NULL;
	
	ASSERT(0 == this->nMessagesPending);

	return ;
		
} // FreePendingList 

// nuke our keep alive thread or our control panel thread
// signal the thread (so it will wake up and exit), then wait for it to
// go away
void KillThread(HANDLE hThread,HANDLE hEvent)
{
	DWORD dwRet;
	
	if (hThread)
	{
		SetEvent(hEvent);
		
		// wait for it to die
		dwRet = WaitForSingleObject(hThread,INFINITE);
		if (WAIT_OBJECT_0 != dwRet) 
		{
			ASSERT(FALSE);
			// sholuld never happen
		}
		
		if (!CloseHandle(hThread))
		{
			DWORD dwErr = GetLastError();
			
			DPF(0,"could not close thread - err = %d\n",dwErr);
		}

		if (!CloseHandle(hEvent))
		{
			DWORD dwErr = GetLastError();
			
			DPF(0,"could not close event handle - err = %d\n",dwErr);
		}
		
	}
	else 
	{
		ASSERT(!hEvent);
	}

	return ;
	
} // KillThread

// called by DP_Close
void CloseSecurity(LPDPLAYI_DPLAY this)
{
    // free up the security desc
    if (this->pSecurityDesc)
    {
        FreeSecurityDesc(this->pSecurityDesc,FALSE);
        DPMEM_FREE(this->pSecurityDesc);
        this->pSecurityDesc = NULL;
    }

    if (this->phCredential)
    {
        OS_FreeCredentialHandle(this->phCredential);
        DPMEM_FREE(this->phCredential);
        this->phCredential = NULL;
    }

    // free up user credentials
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }

    if (this->phContext)
    {
        OS_DeleteSecurityContext(this->phContext);
        DPMEM_FREE(this->phContext);
        this->phContext = NULL;
    }

    // cleanup CAPI stuff
    if (this->hPublicKey) 
    {
        OS_CryptDestroyKey(this->hPublicKey);
        this->hPublicKey = 0;
    }
    if (this->hServerPublicKey) 
    {
        OS_CryptDestroyKey(this->hServerPublicKey);
        this->hServerPublicKey = 0;
    }
    if (this->hEncryptionKey) 
    {
        OS_CryptDestroyKey(this->hEncryptionKey);
        this->hEncryptionKey = 0;
    }
    
    if (this->hDecryptionKey) 
    {
        OS_CryptDestroyKey(this->hDecryptionKey);
        this->hDecryptionKey = 0;
    }

    if (this->pPublicKey)
    {
	    DPMEM_FREE(this->pPublicKey);
	    this->pPublicKey = NULL;
    }

	// All objects contained in a crypt context must be released before 
	// freeing the context. Otherwise, it will cause handle leaks.
    if (this->hCSP) 
    {
        OS_CryptReleaseContext(this->hCSP,0);
        this->hCSP = 0;
    }

    // reset login state
    this->LoginState = DPLOGIN_NEGOTIATE;
    // reset the buffer sizes
    this->ulMaxContextBufferSize = 0;
    this->ulMaxSignatureSize = 0;

} // CloseSecurity


// Release a message node and any buffer that is stored on it.
VOID FreeMessageNode(LPDPLAYI_DPLAY this, LPMESSAGENODE pmsn)
{
	PSENDPARMS psp;
	DWORD dwType=0;

	if(pmsn->pMessage)
	{	
		dwType=(*((LPDPMSG_GENERIC)pmsn->pMessage)).dwType;

		// check for DPSYS_SENDCOMPLETE
		if (pmsn->idFrom == DPID_SYSMSG && dwType == DPSYS_SENDCOMPLETE)
		{
			DPF(8,"Freeing a DPSYS_SENDCOMPLETE message. pmsn == 0x%x", pmsn);
			psp=CONTAINING_RECORD(pmsn,SENDPARMS,msn);
			FreeSendParms(psp);
			// a-josbor: note, we don't free the pmsn because it's freed by FreeSendParams,
			//	according to aarono
		}
		else
		{
			DPMEM_FREE(pmsn->pMessage);
			DPMEM_FREE(pmsn);
		}
	}
	
	this->nMessages--;
}



// Note on closing of Retry and Keepalive thread.  The Retry and KeepAlive threads both do ENTER_ALL's
// in their processing path.  So when we wait for them to complete in DP_Close, we don't know if the
// interface pointer is still valid after we return (since we must drop both locks in order to wait or
// else we would deadlock).  So we flag that that part of shutdown is done and we go back to the top
// of DP_Close and revalidate the 'this' pointer before going on.

HRESULT DPAPI DP_Close(LPDIRECTPLAY lpDP) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPDPLAYI_PLAYER pPlayer,pPlayerNext;
	LPDPLAYI_GROUP pGroup,pGroupNext;
	LPMESSAGENODE pmsg,pmsgNext;
	int nMessages=0;
    DWORD index;
    LPCLIENTINFO pClientInfo;
	HANDLE hPerfThread;
	HANDLE hPerfEvent;
	BOOL   fDidClose=FALSE;
	BOOL   bWaitForDplayThread=FALSE;

Top:
	ENTER_ALL();

	DPF(8, "DP_Close: Parameters: (0x%x)", lpDP);
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// Notify the voice layer that the session is stopped.
    if( !this->fDidVoiceClose )
    {    
		this->fDidVoiceClose = TRUE;    
	    LEAVE_ALL();
		DVoiceNotify( this, DVEVENT_STOPSESSION, 0, 0, DVTRANSPORT_OBJECTTYPE_BOTH );    
		goto Top;
    }

	if (!this->lpsdDesc) 
	{
		LEAVE_ALL();
		DPF_ERR("no session!");
		return DPERR_NOSESSIONS;
	}

	// rodtoll
	// Performing voice shutdown
	if( this->fLoadRetrofit )
	{
		DV_Retro_Stop( this );	
	}

	// stop the enum thread
	if (this->dwFlags & DPLAYI_DPLAY_ENUM)	
	{
		StopEnumThread(this);
		bWaitForDplayThread=TRUE;
	} else {
		bWaitForDplayThread=FALSE;
	}

	// mark dplay as closed
	this->dwFlags |= DPLAYI_DPLAY_CLOSED;

	// if keep alives are on, turn 'em off
	if (this->dwFlags & DPLAYI_DPLAY_KEEPALIVE || bWaitForDplayThread)	
	{
		HANDLE hWait;
		this->dwFlags &= ~DPLAYI_DPLAY_KEEPALIVE;
		// tell thread to wake up and smell the new settings
		SetEvent(this->hDPlayThreadEvent);
		hWait=this->hDPlayThread;
		this->hDPlayThread=0;
		LEAVE_ALL();
		WaitForSingleObject(hWait,INFINITE);
		CloseHandle(hWait);
		goto Top;	// this may now be invalid, back to the top
	}

	if(this->hPerfThread){
		// drop the locks, in case our threads are blocked trying to get in
		hPerfThread=this->hPerfThread;
		hPerfEvent=this->hPerfEvent;
		this->hPerfThread=0;
		this->hPerfEvent=0;
		LEAVE_ALL();
		KillThread(hPerfThread,hPerfEvent);
		goto Top;
	}
	
	// first, destroy all local players except sysplayer
	// (sysplayer is last local player to be destroyed, since it
	// needs to send destroy messages)

	pPlayer=this->pPlayers;
	
	while (pPlayer)
	{
		pPlayerNext=pPlayer->pNextPlayer;
		// store next player now (so we don't blow it away...)
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{

			if(pPlayer != this->pSysPlayer){
				hr = InternalDestroyPlayer(this,pPlayer,TRUE,FALSE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				} else {
					pPlayerNext=this->pPlayers; // list may have been nuked, back to beginning.
				}	
			} else {
				DPF(0,"Just avoided nuking sysplayer w/o sysplayer flag set on it! this %x pPlayer %x\n",this,pPlayer);
				DEBUG_BREAK();
			}
		}
		pPlayer=pPlayerNext;
	}

	// destroy groups - note, this will also destroy the sysgroup...
	pGroup = this->pGroups;
	while (pGroup)
	{
		// store next Group now (so we don't blow it away...)
		pGroupNext = pGroup->pNextGroup;
		if (pGroup != this->pSysGroup) // destroy sysgroup later
		{
			hr = InternalDestroyGroup(this,pGroup,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			// since internaldestroygroup may have nuked > 1 group (sub-groups)
			// we reset to beginning of list
			pGroupNext =  this->pGroups;
		}
		pGroup = pGroupNext;
	}

    // security related cleanup
    if (SECURE_SERVER(this))
    {
        if (this->pSysPlayer && IAM_NAMESERVER(this))
        {
            // cleanup any lingering client info structures - this could happen
            // if nameserver gives out an id in response to a negotiate message 
            // and the client never comes back
            for (index=0; index < this->uiNameTableSize; index++)
            {
                if ((NAMETABLE_PENDING == this->pNameTable[index].dwItem))
                {
                    // is client info stored in here ?
                    pClientInfo = (LPCLIENTINFO) this->pNameTable[index].pvData;
                    if (pClientInfo)
                    {
                        RemoveClientInfo(pClientInfo);
                        // free up the memory
                        DPMEM_FREE(pClientInfo);
                    }
                }
            }
        }
    }

	// sysplayer should be only local player left
	// we could have a session w/ no sysplayer if it was 
	// opened enumonly
	if (this->pSysPlayer)
	{
		hr = InternalDestroyPlayer(this,this->pSysPlayer,TRUE,FALSE);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}// sysplayer
	this->pSysPlayer = NULL;

	// now, destroy sys group
	if (this->pSysGroup)
	{
			hr = InternalDestroyGroup(this,this->pSysGroup,FALSE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
	}
	this->pGroups = NULL;
	this->pSysGroup = NULL;


	// finally, destroy all non-local players
	pPlayer = this->pPlayers;
	while (pPlayer)
	{

		// store next player now (so we don't blow it away...)
		pPlayerNext = pPlayer->pNextPlayer;

		ASSERT(!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL));
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}

		pPlayer = pPlayerNext;
	}
 	this->pPlayers = NULL;

	PACKETIZE_LOCK();

	// on IPX we need to give the sockets a chance to do their sending...
	if(!EMPTY_BILINK(&this->RetryList))
	{
		PACKETIZE_UNLOCK();
		Sleep(2500);
	} else {
		PACKETIZE_UNLOCK();
	}

	//
	// if the retry thread is running, shut it down.
	//
	if(this->hRetryThread){
		HANDLE hWait;
		SetEvent(this->hRetry);
		hWait=this->hRetryThread;
		this->hRetryThread=0;
		LEAVE_ALL();
		WaitForSingleObject(hWait,INFINITE);
		CloseHandle(hWait);
		goto Top;	// this may now be invalid, back to the top
	}

	if(this->hRetry){
		FiniPacketize(this); // cleans up handle and critical section.
	}	

	// notify sp
	// drop locks, in case sp needs has any threads blocked on handlemessage

	if(!fDidClose){
		
		// If this object is lobby-owned, call the lobby here
		if(IS_LOBBY_OWNED(this))
		{
			LEAVE_ALL();
			
			hr = PRV_Close(this->lpLobbyObject);
			fDidClose=TRUE;
			
			goto Top;
		}
		else
		{
			if (this->pcbSPCallbacks->CloseEx) 
			{
				DPSP_CLOSEDATA cd;
				
				cd.lpISP = this->pISP;

				LEAVE_DPLAY();
	    		hr = CALLSP(this->pcbSPCallbacks->CloseEx,&cd);					
	    		ENTER_DPLAY();
	    		fDidClose=TRUE;

			}
			else if (this->pcbSPCallbacks->Close) 
			{
				// dx3 sp's had a VOID arg list for shutdown
				LEAVE_DPLAY();
	    		hr = CALLSPVOID( this->pcbSPCallbacks->Close );
	    		ENTER_DPLAY();
	    		fDidClose=TRUE;
	    		
			}
			else 
			{
				// no callback - no biggie
				hr = DP_OK;
			}
		}
		
		if (FAILED(hr)) 
	    {
			DPF(0,"Close session failed - hr = 0x%08lx\n",hr);
			// keep going...
	    }
	}
	

	// Shutdown the protocol if running.
	if(this->pProtocol){
		// need to NULL this->pProtocol before dropping lock.
		LPPROTOCOL_PART pProtocol=this->pProtocol;
		this->pProtocol=NULL;
		LEAVE_ALL();
		FiniProtocol(pProtocol);
		goto Top;
	}

	// get rid of any messages left in the apps q
	pmsgNext = this->pMessageList;
	DPF(0,"close - cleaning up %d messages\n",this->nMessages);
	while (pmsgNext)
	{
		pmsg = pmsgNext;
		pmsgNext = pmsg->pNextMessage;
		// free up this message node
		FreeMessageNode(this, pmsg);
	}
	ASSERT(0 == this->nMessages);
	this->pMessageList = NULL;
	this->pLastMessage = NULL;

    // the cleanup needs to happen after we are done sending secure messages 
    if (SECURE_SERVER(this))
    {
		CloseSecurity(this);
    }

	// free up the session desc
	if (this->lpsdDesc)
	{
        FreeDesc(this->lpsdDesc,FALSE);
        DPMEM_FREE(this->lpsdDesc);
    	this->lpsdDesc=NULL;
	} 

	// free up the name table
	if (this->pNameTable) DPMEM_FREE(this->pNameTable);
	this->pNameTable=NULL;
	this->uiNameTableSize = 0;
	this->uiNameTableLastUsed = 0;


	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		FreePendingList(this);		
		this->dwFlags &= ~DPLAYI_DPLAY_PENDING;
	}

	// reset all session level flags
	this->dwFlags &= ~ (DPLAYI_DPLAY_SESSIONFLAGS);

	// reset the min version for this object
	this->dwMinVersion = DPSP_MSG_VERSION;
	
	while (this->pAddForwardList) FreeAddForwardNode(this,this->pAddForwardList);
	this->pAddForwardList = NULL;

	if(this->pTargetList){
		DPMEM_FREE(this->pTargetList);
	}

	if(this->pExpandedTargetList){
		DPMEM_FREE(this->pExpandedTargetList);
	}

	LEAVE_ALL();

	DPF(8, "Leaving DP_Close");

    return DP_OK;
        
}//DP_Close

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreatePlayer/DP_CreateGroup"

// allocate player structure
HRESULT AllocatePlayer( LPDPLAYI_PLAYER * lplpPlayer)
{
    LPDPLAYI_PLAYER pPlayer;

    // alloc memory for the player
    pPlayer = DPMEM_ALLOC(sizeof(DPLAYI_PLAYER));
    
    if (!pPlayer) 
    {
		*lplpPlayer = NULL;
        DPF_ERR("player alloc failed!");
        return E_OUTOFMEMORY;
    }
    
    pPlayer->dwSize = sizeof(DPLAYI_PLAYER); // used to validate structure

    // return the new player
    *lplpPlayer = pPlayer;
    
    return DP_OK;
} // AllocatePlayer

// done w/ player data structure
HRESULT DeallocPlayer(LPDPLAYI_PLAYER lpPlayer) 
{
    if (!lpPlayer) return E_UNEXPECTED;
	if ((lpPlayer->hEvent) &&
		(lpPlayer->dwFlags & DPLAYI_PLAYER_CREATEDPLAYEREVENT))
	{
		CloseHandle(lpPlayer->hEvent);
	}
    if (lpPlayer->lpszShortName) DPMEM_FREE(lpPlayer->lpszShortName);
    if (lpPlayer->lpszLongName) DPMEM_FREE(lpPlayer->lpszLongName);
	if (lpPlayer->pvPlayerData) DPMEM_FREE(lpPlayer->pvPlayerData);
	if (lpPlayer->pvPlayerLocalData) DPMEM_FREE(lpPlayer->pvPlayerLocalData);

	// free it's sp data
	if (lpPlayer->pvSPData) DPMEM_FREE(lpPlayer->pvSPData);
	if (lpPlayer->pvSPLocalData) DPMEM_FREE(lpPlayer->pvSPLocalData);	

    // free security context and credential handle
    if (lpPlayer->pClientInfo) 
    {
        RemoveClientInfo(lpPlayer->pClientInfo);
        DPMEM_FREE(lpPlayer->pClientInfo);
        lpPlayer->pClientInfo = NULL;
    }

#ifdef DEBUG
    lpPlayer->lpszShortName= IntToPtr(0xBEEDBEBE);
    lpPlayer->lpszLongName= IntToPtr(0xBEEDBEBE); 
	lpPlayer->pvPlayerData= IntToPtr(0xBEEDBEBE); 
	lpPlayer->pvPlayerLocalData= IntToPtr(0xBEEDBEBE);
	lpPlayer->pvSPData= IntToPtr(0xBEEDBEBE);
	lpPlayer->pvSPLocalData= IntToPtr(0xBEEDBEBE);
#endif 		

    lpPlayer->dwSize=0xdeadbeef; //just in case someone tries to reuse dead memory
    DPMEM_FREE(lpPlayer);

    return DP_OK;

} // DeallocPlayer

// call sp's create player callback
// called by GetPlayer and UnpackPlayerList
HRESULT CallSPCreatePlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL bLocal,
	LPVOID pvSPMessageHeader, BOOL bNotifyProtocol)
{
	HRESULT hr=DP_OK;
    DPSP_CREATEPLAYERDATA cpd;

    if (this->pcbSPCallbacks->CreatePlayer || (bNotifyProtocol && this->pProtocol)) 
    {
	    // call sp
		memset(&cpd,0,sizeof(cpd));
	    cpd.idPlayer = pPlayer->dwID;
		cpd.lpSPMessageHeader = pvSPMessageHeader;
		cpd.dwFlags = pPlayer->dwFlags;
		cpd.lpISP = this->pISP;

		if(bNotifyProtocol && this->pProtocol){
			hr = ProtocolCreatePlayer(&cpd); // calls SP too.
		} else {
		    hr = CALLSP(this->pcbSPCallbacks->CreatePlayer,&cpd);	    	
		}    
	    if (FAILED(hr)) 
	    {
			DPF(0,"SP - Create player failed - hr = 0x%08lx\n",hr);
			return hr;
	    }
    }
	else 
	{
		// its ok if the sp doesn't implement this...
	}

	return hr;

} // CallSPCreatePlayer


/*
 ** GetPlayer	
 *
 *  CALLED BY:	InternalCreatePlayer,unpack player list and handledeadnameserver.
 *
 *  PARAMETERS:
 *		this - dplay object
 *		ppPlayer - pointer to player to create. return value
 *		pName - strings
 *		phEvent - handle to receive event
 *		pvData	- player data blob
 *		dwDataSize - size of blob
 *      dwFlags - player flags
 *      lpszPassword - session password, if creating a system player. NULL otherwise.
 *		dwLobbyID -- ID of the player in a lobby sesssion, assigned by the lobby server
 *
 *  DESCRIPTION: Creates the player. Allocs the player structure,and sets the data and calls the 
 *		sp (and adds to nametable) if local.
 *
 *	
 *  RETURNS:
 *		 DP_OK or E_OUTOFMEMORY or sp scode
 *
 */
HRESULT GetPlayer(LPDPLAYI_DPLAY this,  LPDPLAYI_PLAYER * ppPlayer,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags, LPWSTR lpszSessionPassword, DWORD dwLobbyID)
{
    HRESULT hr = DP_OK;
    DWORD id=0;
	LPDPLAYI_PLAYER pLastPlayer;

	
	DPF(8, "GetPlayer: Parameters:(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, %u, 0x%x, 0x%x, %u)",
		this, ppPlayer, pName, hEvent, pvData, dwDataSize, dwFlags, lpszSessionPassword, dwLobbyID);

    // a-josbor: First thing: decrement our reservation count if it's a
    //	remote player.  We want to do this even if there is an error
    //	creating the player
    if (IAM_NAMESERVER(this) && !(dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
    	if (this->dwPlayerReservations > 0)	// just in case...
    		this->dwPlayerReservations--;
    }


    // allocate / initialize a dplayi_player structure
    hr = AllocatePlayer( ppPlayer );
    if (FAILED(hr)) 
    {
    	return hr;
    }

	// update player fields
    (*ppPlayer)->lpDP = this;
    (*ppPlayer)->dwFlags = dwFlags;
    (*ppPlayer)->hEvent = hEvent;	
	(*ppPlayer)->nPendingSends = 0;
	InitBilink(&((*ppPlayer)->PendingList));
	
	// set up the name
	hr = DoPlayerName(*ppPlayer,pName);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// set up the data
	hr = DoPlayerData(*ppPlayer,pvData,dwDataSize,DPSET_REMOTE);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

     // if it's the app server, remember it
    if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_APPSERVER)
    {
    	this->pServerPlayer = (*ppPlayer);
    }

     // if it's the name server, remember it
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_NAMESRVR)
	{
		DPF(4,"creating name server");
		this->pNameServer = (*ppPlayer);
	}

	// add local player to name table.  
	// if its not local, unpack will add it for us, 
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
	    // if it's the app server, use the reserved appplayer id
	    if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_APPSERVER)
	    {
		    (*ppPlayer)->dwID = DPID_SERVERPLAYER;
	    }
	    else 
	    {
		    // get a player id, add player to name table
		    hr = AddItemToNameTable(this,(DWORD_PTR) (*ppPlayer),&id,TRUE,dwLobbyID);
		    if (FAILED(hr)) 
		    {
				goto ERROR_EXIT;
		    }
		    
			(*ppPlayer)->dwID = id;
	    }

		// Make sure we have a system player (a lobby-owned object may not)
		if(this->pSysPlayer)
		{
			(*ppPlayer)->dwIDSysPlayer = this->pSysPlayer->dwID;
			(*ppPlayer)->dwCreateTime = timeGetTime();
		}
		
		(*ppPlayer)->dwVersion = DPSP_MSG_VERSION;
		
		// give sp a pop at the player...
		hr = CallSPCreatePlayer(this,*ppPlayer,TRUE,NULL,TRUE);
		if (FAILED(hr))
		{
			FreeNameTableEntry(this,id);
			goto ERROR_EXIT;
		}

		// notify all local and remote players of new player
		// unpack will send create messages for non-local players...
		hr = SendCreateMessage( this, *ppPlayer,TRUE, lpszSessionPassword);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// hmmm, what to do with a failure here?
			// keep going...
			hr = DP_OK;
		}

		// add player to system group.
		// unpack will do this for non-local players
		if (this->pSysGroup)
		{
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			(*ppPlayer)->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
		}

	}  // local

	// new sysplayers go on the front of the list
	// this is so when we unpack players and add them to the system group, we always
	// need to unpack system players first...
	if ((*ppPlayer)->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
	{
		// slap 'em on the front
		(*ppPlayer)->pNextPlayer = this->pPlayers;
		this->pPlayers = *ppPlayer;
	}
	else 
	{
		// put new non-sysplayer at the back of the list
		pLastPlayer = this->pPlayers;
		if (!pLastPlayer) 
		{
			this->pPlayers = (*ppPlayer);
		}
		else 
		{
			// find the last system player in the list - insert our new 
			// player behind it...
			while ((pLastPlayer->pNextPlayer) 
				&& (pLastPlayer->pNextPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) 
			{
				pLastPlayer = pLastPlayer->pNextPlayer;		
			}
			ASSERT(pLastPlayer);
			// also, if there's a dx3 in the session, the list may be out of order
			if(!(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
			{
				ASSERT(pLastPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
				if(pLastPlayer->pNextPlayer)
				{
					ASSERT(!(pLastPlayer->pNextPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER));
				}
			}
			(*ppPlayer)->pNextPlayer = pLastPlayer->pNextPlayer;
			pLastPlayer->pNextPlayer = (*ppPlayer);
		}
	}

	if (!(dwFlags & DPLAYI_PLAYER_SYSPLAYER))
	{
		this->lpsdDesc->dwCurrentPlayers++;
	}

	this->nPlayers++;
	
	DPF(8, "GetPlayer: Returning DP_OK", hr);

	// SUCCESS
    return hr;

ERROR_EXIT:
	
	DPF(0,"*****	GetPlayer failed - hr = 0x%08lx !!!\n",hr);
	DeallocPlayer(*ppPlayer);
	*ppPlayer = NULL;
	return hr;
    	
} // GetPlayer


HRESULT AllocGroup(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP * ppGroup)
{

    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP pGroup;

    // alloc memory for the group
    pGroup = DPMEM_ALLOC(sizeof(DPLAYI_GROUP));
    
    if (!pGroup) 
    {
        DPF_ERR("group alloc failed!");
        return E_OUTOFMEMORY;
    }
    
    pGroup->dwSize = sizeof(DPLAYI_GROUP); // used to validate structure

    // return the new group
    *ppGroup = pGroup;
    			
    return hr;

} // AllocGroup

HRESULT DeallocGroup(LPDPLAYI_GROUP lpGroup) 
{
    if (lpGroup->lpszShortName) DPMEM_FREE(lpGroup->lpszShortName);
    if (lpGroup->lpszLongName) DPMEM_FREE(lpGroup->lpszLongName);
	if (lpGroup->pvPlayerData) DPMEM_FREE(lpGroup->pvPlayerData);
	if (lpGroup->pvPlayerLocalData) DPMEM_FREE(lpGroup->pvPlayerLocalData);

    lpGroup->dwSize=0xdeadbeef; //just in case someone tries to reuse dead memory	
    DPMEM_FREE(lpGroup);

    return DP_OK;
    
} // DeallocGroup

// call sp's create group callback
// called by GetGroup and UnpackGroupList
HRESULT CallSPCreateGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroup,BOOL bLocal,
	LPVOID pvSPMessageHeader)
{
	HRESULT hr=DP_OK;
    DPSP_CREATEGROUPDATA cgd;

	if (this->dwFlags & DPLAYI_DPLAY_DX3INGAME)
	{
		// no optimized groups w/ dx3
		hr = E_NOTIMPL;
	}
    else if (this->pcbSPCallbacks->CreateGroup) 
    {
	    // call sp
		memset(&cgd,0,sizeof(cgd));
	    cgd.idGroup = pGroup->dwID;
		cgd.lpSPMessageHeader = pvSPMessageHeader;
		cgd.dwFlags = pGroup->dwFlags;
		cgd.lpISP = this->pISP;

	    hr = CALLSP(this->pcbSPCallbacks->CreateGroup,&cgd);	    	
	    if (FAILED(hr)) 
	    {
			DPF(0,"SP - Create group failed - hr = 0x%08lx\n",hr);
	    }

    }
	else 
	{
		// if they don't support it - dplay will emulate it
		hr = E_NOTIMPL;
	}

	if (FAILED(hr))
	{
		// the SP couldn't do it.  mark group as owned by dplay.
		pGroup->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
	}
	
	return DP_OK;

} // CallSPCreateGroup

// called by DP_CreateGroup and UnpackPlayerAndGroupList
// actually creates the group.
// todo - make this and getplayer use the same code!
HRESULT GetGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP * ppGroup,LPDPNAME pName,
	LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,DPID idParent,DWORD dwLobbyID)
{
	HRESULT hr;
	DWORD id;
	LPDPLAYI_GROUP pLastGroup; // stick new groups on end
	
    // create a group
    hr = AllocGroup(this, (LPDPLAYI_GROUP *)ppGroup);
    if (FAILED(hr)) 
    {
        return hr;
    }

	// set up the name
	hr = DoPlayerName((LPDPLAYI_PLAYER)*ppGroup,pName);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// set up the data
	hr = DoPlayerData((LPDPLAYI_PLAYER)*ppGroup,pvData,dwDataSize,DPSET_REMOTE);
    if (FAILED(hr)) 
    {
		goto ERROR_EXIT;
    }

	// store the flags
	(*ppGroup)->dwFlags = dwFlags;
    (*ppGroup)->lpDP = this;
   	(*ppGroup)->dwIDParent = idParent;
	
	if ((*ppGroup)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)  
	{
		if ((*ppGroup)->dwFlags & DPLAYI_GROUP_SYSGROUP)
		{
			// use the reserved id for the system group
			(*ppGroup)->dwID = DPID_ALLPLAYERS;
		}
		else 
		{
		    // get a Group id, add Group to name table
		    hr = AddItemToNameTable(this,(DWORD_PTR) (*ppGroup),&id,FALSE,dwLobbyID);
		    if (FAILED(hr)) 
		    {
				goto ERROR_EXIT;
		    }

			(*ppGroup)->dwID = id;
		}
		

		// Make sure we have a system player (a lobby-owned object may not)
		if(this->pSysPlayer)
		{
			(*ppGroup)->dwIDSysPlayer = this->pSysPlayer->dwID;
		}

		(*ppGroup)->dwVersion = DPSP_MSG_VERSION;
		
		// tell sp about group
		hr = CallSPCreateGroup(this,*ppGroup,TRUE,NULL);
		if (FAILED(hr))
		{
			// make group dplay owned
			(*ppGroup)->dwFlags |= DPLAYI_GROUP_DPLAYOWNS;
		}

		// don't send create message if it's the system group
		if (!(dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// notify all local and remote players of new group
			// unpack will send create messages for non-local groups...
			hr = SendCreateMessage( this, *ppGroup,FALSE,NULL);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// hmmm, what to do with a failure here?
				// keep going...
				hr = DP_OK;
			}
		}

	}  // local

	// andyco - DX5 - new groups go on back

	if (this->pGroups) // empty list?
	{
		pLastGroup = this->pGroups;	
		// find the last one
		while (pLastGroup->pNextGroup)
		{
			 pLastGroup = pLastGroup->pNextGroup;
		}
		// found the end, stick the new group on
		ASSERT(pLastGroup);
		pLastGroup->pNextGroup = *ppGroup;
	}
	else 
	{
		this->pGroups = *ppGroup;
	}
	
	this->nGroups++;    

	return hr;

ERROR_EXIT:

	DPF(0,"*** GetGroup failed - hr = 0x%08lx\n",hr);
	DeallocGroup(*ppGroup);
	return hr;

} // GetGroup	


void MakeLocalPlayerGroupOwner(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP lpGroup,
		LPDPLAYI_PLAYER lpOwner)
{
	LPDPLAYI_GROUPOWNER		lpOwnerNode = NULL;


	ASSERT(lpGroup);

	// If we don't have a player, just make the server player own the group
	if(!lpOwner)
		lpGroup->dwOwnerID = DPID_SERVERPLAYER;

	// Allocate memory for the owner node
	lpOwnerNode = DPMEM_ALLOC(sizeof(DPLAYI_GROUPOWNER));
	if(!lpOwnerNode)
	{
		DPF_ERR("Unable to allocate memory for groupowner node");
		// So just set the group's owner to DPID_SERVERPLAYER
		lpGroup->dwOwnerID = DPID_SERVERPLAYER;
		return;
	}

	// Setup the node
	lpOwnerNode->pGroup = lpGroup;

	// Add it to the list
	lpOwnerNode->pNext = lpOwner->pOwnerGroupList;
	lpOwner->pOwnerGroupList = lpOwnerNode;

	// Set the group's owner ID
	lpGroup->dwOwnerID = lpOwner->dwID;

} // MakeLocalPlayerGroupOwner


/*
 ** InternalCreatePlayer	
 *
 *  CALLED BY:	DP_CreatePlayer,DP_CreateGroup,
 *
 *  PARAMETERS:
 *		lpDP - dplay interface pointer
 *		pid -  player / group id - return value
 *		pName - strings
 *		phEvent - handle to receive event. NULL for groups
 *		pvData	- player data blob
 *		dwDataSize - size of blob
 *		dwCreateFlags - dwFlags passed to create fn.
 *
 *  DESCRIPTION: validates params for DP_CreatePlayer/Group.
 *				calls GetPlayer or GetGroup to create + set up
 *				the player or group.
 *
 *	
 *  RETURNS:
 *		 DP_OK or E_OUTOFMEMORY or GetPlayer/Group error code.
 *
 */

// assumes service + dplay lock taken!
HRESULT InternalCreatePlayer(LPDIRECTPLAY lpDP, LPDPID pid,LPDPNAME pName,
	HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags,BOOL fPlayer,DPID idParent)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	DWORD dwPlayerFlags;
	LPWSTR lpszShortName,lpszLongName;
	LPDPLAYI_PLAYER lpPlayer=NULL;
	LPDPLAYI_GROUP lpGroup=NULL;
	LPDPLAYI_PLAYER lpRandomPlayer=NULL;
	DPID idOwner;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc) 
		{
			DPF_ERR("must join session before creating players");
			return DPERR_INVALIDPARAMS;
		}
		if (!VALID_DWORD_PTR(pid))
		{
			DPF_ERR("invalid pid pointer");
			return DPERR_INVALIDPARAMS;
		}
        if (pName && !VALID_READ_DPNAME_PTR(pName))
        {
			DPF_ERR("invalid dpname pointer");
			ASSERT(FALSE);

			// returning an error here causes a regression with DX3, since
			// we did not do parameter checks on the name previously
//			return DPERR_INVALIDPARAMS;
        }

		// check strings
		if (pName)
		{
			lpszShortName = pName->lpszShortName;
			lpszLongName = pName->lpszLongName;
			if ( lpszShortName && 
				!VALID_READ_STRING_PTR(lpszShortName,WSTRLEN_BYTES(lpszShortName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
			if ( lpszLongName && 
				!VALID_READ_STRING_PTR(lpszLongName,WSTRLEN_BYTES(lpszLongName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
		}
		// check event handle
		if ((hEvent) && (!OS_IsValidHandle(hEvent)))
		{
	        DPF_ERR( "bad event handle" );
	        return DPERR_INVALIDPARAMS;
		}		
		// check blob
		if (dwDataSize && !VALID_READ_STRING_PTR(pvData,dwDataSize)) 
		{
	        DPF_ERR( "bad player blob" );
	        return DPERR_INVALIDPARAMS;
		}

		if (fPlayer)
		{
			// check player flags
			if (!VALID_CREATEPLAYER_FLAGS(dwFlags))
			{
				DPF_ERR( "invalid flags" );
				return DPERR_INVALIDFLAGS;
			}
		}
		else
		{
			// check group flags
			if (!VALID_CREATEGROUP_FLAGS(dwFlags))
			{
				DPF_ERR( "invalid flags" );
				return DPERR_INVALIDFLAGS;
			}
		}
		
		// only nameserver can create serverplayer
		if ( (dwFlags & DPPLAYER_SERVERPLAYER) && !(IAM_NAMESERVER(this)) )
		{
			DPF_ERR("only host can create server player");
			return DPERR_INVALIDFLAGS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// see if we're allowed to create a player
	if (fPlayer)
	{
		if ( this->lpsdDesc->dwMaxPlayers ) 
		{
			if (this->lpsdDesc->dwCurrentPlayers >= this->lpsdDesc->dwMaxPlayers )
			{
				DPF(1,"can't create new player - exceeded dwMaxPlayers");
				return DPERR_CANTCREATEPLAYER;
			}
		}
		if (this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED)
		{
			DPF_ERR("can't create new player - DPSESSION_NEWPLAYERSDISABLED");
			return DPERR_CANTCREATEPLAYER;
		}
		// in a client server session, the session host (server) can't create
		// any players other than the DPID_SERVERPLAYER
		if ((this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) && 
			(IAM_NAMESERVER(this)) && !(dwFlags & DPPLAYER_SERVERPLAYER) )
		{
			DPF_ERR(" session host can only create DPPLAYER_SERVERPLAYER");
			return DPERR_ACCESSDENIED;
		}
	}

	// If this object is lobby-owned, do the server stuff and take
	// care of the rest of the nametable stuff from the lobby code.
	if(IS_LOBBY_OWNED(this))
	{
		// We need to drop the lock so the lobby's receive thread can
		// get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		if(fPlayer)
		{
			hr = PRV_CreatePlayer(this->lpLobbyObject, pid, pName, hEvent,
								pvData, dwDataSize, dwFlags);
		}
		else
		{
			// If it's a group, someone on this machine needs to be the group
			// owner, so just randomly pick a local player.  If there aren't
			// any local players, make the server player be the owner.
			lpRandomPlayer = GetRandomLocalPlayer(this);
			idOwner = (lpRandomPlayer ? lpRandomPlayer->dwID : DPID_SERVERPLAYER);
			
			// If there is a parent ID, then this is a CreateGroupInGroup call
			if(idParent)
			{
				hr = PRV_CreateGroupInGroup(this->lpLobbyObject, idParent,
						pid, pName,	pvData, dwDataSize, dwFlags, idOwner);
			}
			else
			{
				hr = PRV_CreateGroup(this->lpLobbyObject, pid, pName,
						pvData, dwDataSize, dwFlags, idOwner);
			}

			// Store the owner in the group, and create a reference node in the player
			if(SUCCEEDED(hr))
			{
				// Get the player the lobby just created
				lpGroup = GroupFromID(this, *pid);
				if(lpGroup)
					MakeLocalPlayerGroupOwner(this, lpGroup, lpRandomPlayer);
			}
		}
		
		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed creating player or group on the lobby, hr = 0x%08x", hr);
		}

		// Since all of the work below is already done by the lobby,
		// we can exit here.
		return hr;
	}

	// go get a player
	dwPlayerFlags =  DPLAYI_PLAYER_PLAYERLOCAL;
	
	if (dwFlags & DPPLAYER_SERVERPLAYER)
	{
		if (this->pServerPlayer)
		{
			DPF_ERR("server player already exists");
			return DPERR_CANTCREATEPLAYER;
		}
		// else
		dwPlayerFlags |= DPLAYI_PLAYER_APPSERVER;
	}

	if (dwFlags & DPPLAYER_SPECTATOR)
		dwPlayerFlags |= DPLAYI_PLAYER_SPECTATOR;

	if (dwFlags & DPGROUP_STAGINGAREA)
		dwPlayerFlags |= DPLAYI_GROUP_STAGINGAREA;

	if(dwFlags & DPGROUP_HIDDEN)
		dwPlayerFlags |= DPLAYI_GROUP_HIDDEN;

	if (fPlayer)
	{
	    hr = GetPlayer(this, &lpPlayer,pName,hEvent,pvData,dwDataSize,dwPlayerFlags,NULL,0);
	}
	else 
	{
	    hr = GetGroup(this, &lpGroup,pName,pvData,dwDataSize,dwPlayerFlags,idParent,0);
	}
    if (FAILED(hr)) 
    {
		DPF(0,"Create player / group failed - hr = 0x%08lx\n",hr);
		if (hr == DPERR_TIMEOUT)
			hr = DPERR_CANTCREATEPLAYER;
        return hr;
    }

	// Check to ensure it's a player before we start the 
	// retrofit, don't start in a group create or system
	// player create.
	//
	if( lpPlayer && !(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) )
	{
		if ( ((this->lpLaunchingLobbyObject)?(this->lpsdDesc->dwFlags&DPSESSION_ALLOWVOICERETRO):TRUE) &&
			 (LookupVoiceRetrofitFlag(&this->lpsdDesc->guidApplication) ) && 
			 (memcmp( &this->pspNode->guid,&DPSPGUID_TCPIP, sizeof( GUID ) ) == 0 ) )
		{
		    this->fLoadRetrofit = TRUE;
			DPF(1, "Retrofit flag detected: Calling DV_Retro_Start");
			DV_Retro_Start( this );
		}
		else
		{
		    this->fLoadRetrofit = FALSE;		
			DPF(1, "Retrofit flag NOT detected: NOT Calling DV_Retro_Start");
			DPF(1, "OR Non-TCP provider specified" );
		}
	}
	
	// store the return value
	if (fPlayer) *pid = lpPlayer->dwID;
	else *pid = lpGroup->dwID;

	if (hr == DPERR_TIMEOUT)
		hr = DPERR_CANTCREATEPLAYER;

	return hr;
} // InternalCreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreatePlayer"
HRESULT DPAPI DP_CreatePlayer(LPDIRECTPLAY lpDP, LPDPID pidPlayerID,
	LPDPNAME pName,HANDLE hEvent,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;

	ENTER_ALL();
	
	hr = InternalCreatePlayer(lpDP, pidPlayerID,pName,hEvent,pvData,
		dwDataSize,dwFlags,TRUE,0) ;

	LEAVE_ALL();		
	
	return hr;

}// DP_CreatePlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreateGroup"
HRESULT DPAPI DP_CreateGroup(LPDIRECTPLAY lpDP, LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT hr;

	ENTER_ALL();
	
	hr = InternalCreatePlayer(lpDP, pidGroupID,pName,NULL,pvData,
		dwDataSize,dwFlags,FALSE,0) ;

	LEAVE_ALL();
	
	return hr;
        
} // DP	_CreateGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CreateGroupInGroup"

HRESULT DPAPI DP_CreateGroupInGroup(LPDIRECTPLAY lpDP, DPID idParentGroup,LPDPID pidGroupID,
	LPDPNAME pName,LPVOID pvData,DWORD dwDataSize,DWORD dwFlags) 
{
	HRESULT			hr;
	LPDPLAYI_GROUP	pGroup = NULL;
	LPDPLAYI_DPLAY	this = NULL;


	ENTER_ALL();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// We must have a valid parent -- zero is not a valid parent.
	    pGroup = GroupFromID(this,idParentGroup);
	    if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == idParentGroup)) 
	    {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idParentGroup);
	        return DPERR_INVALIDGROUP;
	    }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// go get the group
	hr = InternalCreatePlayer(lpDP, pidGroupID,pName,NULL,pvData,
		dwDataSize,dwFlags,FALSE,idParentGroup) ;
	if (FAILED(hr))
	{
		DPF_ERRVAL("Could not create group - hr = 0x%08lx\n",hr);
		goto CLEANUP_EXIT;
	}

	// add group to group
	hr = InternalAddGroupToGroup(lpDP,idParentGroup,*pidGroupID,dwFlags,TRUE);	
	if (FAILED(hr))
	{
		DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
		DP_DestroyGroup(lpDP,*pidGroupID);
		*pidGroupID = 0;
	}

	// fall through

CLEANUP_EXIT:		
	
	LEAVE_ALL();
	
	return hr;
        
} // DP_CreateGroupInGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DeleteGroupFromGroup"

// delete lpGroupRemove from lpGroup
HRESULT RemoveGroupFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_GROUP lpGroupRemove)
{
    HRESULT hr=DP_OK;
	LPDPLAYI_SUBGROUP lpSubgroup,lpSubgroupPrev=NULL;
    BOOL bFoundIt=FALSE;

	lpSubgroup = lpGroup->pSubgroups;
	
    // find the groupnode corresponding to this player
    while ( (lpSubgroup) && (!bFoundIt))
    {
        if (lpSubgroup->pGroup == lpGroupRemove) 
        {
            bFoundIt = TRUE;
            // remove this groupnode from the group list
            if (!lpSubgroupPrev) 
            {
                // remove groupnode from beginning of list
            	lpGroup->pSubgroups = lpSubgroup->pNextSubgroup;
            }
            else
            {
                // remove groupnode from middle (or end) of list
            	lpSubgroupPrev->pNextSubgroup = lpSubgroup->pNextSubgroup;
            }
        } 
		else 
		{
			// check next node
	        lpSubgroupPrev = lpSubgroup;
	        lpSubgroup = lpSubgroup->pNextSubgroup;
		}        
    } // while

    if (bFoundIt) 
    {
		lpGroup->nSubgroups--;		// one less group in this group			

		// free up groupnode
    	DPMEM_FREE(lpSubgroup);

        lpGroupRemove->nGroups--;
        if (0 == lpGroupRemove->nGroups) 
        {
            // mark player as not in any group
            lpGroupRemove->dwFlags &= ~DPLAYI_PLAYER_PLAYERINGROUP;	
        }
    }
    else
    {
		// this can happen - e.g. group deleted, etc. off the wire
		DPF(4,"could not remove group from group - player id %d not found in group id %d\n",
				lpGroup->dwID,lpGroupRemove->dwID);
    	hr = E_FAIL; 
    }
    
    return hr;
} // RemoveGroupFromGroup

HRESULT InternalDeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,DPID idGroup,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP lpGroup; 
    LPDPLAYI_GROUP lpGroupFrom; 	
	
	DPF(5,"deleting group id %d from group id %d - propagate = %d",idGroup,idGroupFrom,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
        lpGroupFrom = GroupFromID(this,idGroupFrom);
        if ((!VALID_DPLAY_GROUP(lpGroupFrom)) || (DPID_ALLPLAYERS == idGroupFrom)) 
        {
			DPF(0, "invalid Group From id -- idGroupFrom = %lx", idGroupFrom);
            return DPERR_INVALIDGROUP;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// First, if this is a parent/child relationship, then the fPropagate flag must be
	// set to FALSE because we never give out DeleteGroupInGroup messages for
	// real subgroups (non-shortcuts).  Bug #15264.
	if(lpGroup->dwIDParent == lpGroupFrom->dwID)
		fPropagate = FALSE;

    hr = RemoveGroupFromGroup(lpGroupFrom,lpGroup);
    if (FAILED(hr)) 
    {
		// this can happen if e.g. player not in group...
		return hr;
    }

	// If this is a lobby-owned object, we need to call the lobby.  UNLESS
	// the fPropagate flag is cleared.  If it is cleared,  it means the
	// lobby called us for a remote group and we dont want to call it back
	// in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DeleteGroupFromGroup(this->lpLobbyObject, idGroupFrom, idGroup);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed deleting group from group on the lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

    // don't bother telling people about the sysgroup or system players
    if (fPropagate)
    {
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEGROUPFROMGROUP, idGroup, 
			idGroupFrom);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
			hr = DP_OK;
		}
    }

    return hr;
	
} // InternalDeleteGroupFromGroup

HRESULT DPAPI DP_DeleteGroupFromGroup(LPDIRECTPLAY lpDP, DPID idGroupFrom,DPID idGroup) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUP lpGroup; 
	

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_ALL();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        
		// Make sure this is a shortcut and not a parent-child (bug #8396)
		if((lpGroup->dwIDParent == idGroupFrom))
		{
			LEAVE_ALL();
			DPF_ERR("Cannot delete a child group from it's parent, please use DestroyGroup");
			return DPERR_ACCESSDENIED;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }


	hr = InternalDeleteGroupFromGroup(lpDP, idGroupFrom,idGroup,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_DeleteGroupFromGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DeletePlayerFromGroup"

// delete lpPlayer from lpGroupnode. called by DP_DeletePlayerFromGroup
// returns DP_OK or E_FAIL if player isn't in group
HRESULT RemovePlayerFromGroup(LPDPLAYI_GROUP lpGroup,LPDPLAYI_PLAYER lpPlayer)
{
    HRESULT hr=DP_OK;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodePrev = NULL;
    BOOL bFoundIt=FALSE;
	LPDPLAYI_GROUPNODE * ppRootGroupnode;
	
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
	{
		lpGroupnode = lpGroup->pSysPlayerGroupnodes;
		ppRootGroupnode = &((LPDPLAYI_GROUPNODE)lpGroup->pSysPlayerGroupnodes);
	}
	else 
	{
		lpGroupnode = lpGroup->pGroupnodes;		
		ppRootGroupnode = &((LPDPLAYI_GROUPNODE)lpGroup->pGroupnodes);		
	}
	
    // find the groupnode corresponding to this player
    while ( (lpGroupnode) && (!bFoundIt))
    {
        if (lpGroupnode->pPlayer == lpPlayer) 
        {
            bFoundIt = TRUE;
            // remove this groupnode from the group list
            if (!lpGroupnodePrev) 
            {
                // remove groupnode from beginning of list
            	*ppRootGroupnode = lpGroupnode->pNextGroupnode;
            }
            else
            {
                // remove groupnode from middle (or end) of list
            	lpGroupnodePrev->pNextGroupnode = lpGroupnode->pNextGroupnode;
            }
        } // (lpGroupnode->pPlayer == lpPlayer) 
		else 
		{
			// check next node
	        lpGroupnodePrev=lpGroupnode;
	        lpGroupnode = lpGroupnode->pNextGroupnode;
		}        
    } // while

    if (bFoundIt) 
    {
		if (!(DPLAYI_PLAYER_SYSPLAYER & lpPlayer->dwFlags))
		{
			// only dec the player count on non-system players
			lpGroup->nPlayers--;		// one less player in this group			
		}


		// free up groupnode
    	DPMEM_FREE(lpGroupnode);

        lpPlayer->nGroups--;
        if (0==lpPlayer->nGroups) 
        {
            // mark player as not in any group
            lpPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERINGROUP;	
        }
    }
    else
    {
		DPF(4,"could not remove player from group - player id %d not found in group id %d\n",
				lpPlayer->dwID,lpGroup->dwID);
    	hr = DPERR_INVALIDPLAYER; 
    }
    
    return hr;
} // RemovePlayerFromGroup

HRESULT InternalDeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
    LPDPLAYI_GROUP lpGroup; 
	DPSP_REMOVEPLAYERFROMGROUPDATA data;
	LPDPLAYI_GROUPNODE pSysGroupnode;
	
	DPF(5,"deleting player id %d from group id %d - propagate = %d",idPlayer,idGroup,fPropagate);

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        
        lpGroup = GroupFromID(this,idGroup);

        if (!VALID_DPLAY_GROUP(lpGroup)) 
        {
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }

        lpPlayer = PlayerFromID(this,idPlayer);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

//	a-josbor: tell the SP that we have removed this player from the group
	// only do this if we have an SP that is DX6 or later!
	if ((this->dwSPVersion & DPSP_MAJORVERSIONMASK) > DPSP_DX5VERSION)
	{
		if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
			&& (this->pcbSPCallbacks->RemovePlayerFromGroup) )
		{
			data.idPlayer = lpPlayer->dwID;
			data.idGroup = lpGroup->dwID;        
			data.lpISP = this->pISP;

		    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&data);
		}
		else 
		{
			// no callback - no biggie
		}
		if (FAILED(hr)) 
		{
			DPF(0,"SP - remove player from group failed - hr = 0x%08lx\n",hr);
		}
	}
	
//	now do the actual removal
    hr = RemovePlayerFromGroup(lpGroup,lpPlayer);
    if (FAILED(hr)) 
    {
		// this can happen if e.g. player not in group...
		return hr;
    }

    // don't bother telling people about the sysgroup or system players
    if (!(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP) && !(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
		&& fPropagate)
    {
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYERFROMGROUP, idPlayer, 
			idGroup);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
			hr = DP_OK;
		}
    }

	// update the system player groupnode.
 	pSysGroupnode = FindPlayerInGroupList(lpGroup->pSysPlayerGroupnodes,lpPlayer->dwIDSysPlayer);
	if (pSysGroupnode)
	{
		pSysGroupnode->nPlayers--;
		// when this goes to 0, remove the system player from the group
	    // notify sp if we need to (notify both pre and post DX6 SPs)
		if (pSysGroupnode->nPlayers == 0 && !(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
		    if ( !(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) 
				&& (this->pcbSPCallbacks->RemovePlayerFromGroup) )
		    {
				data.idPlayer = pSysGroupnode->pPlayer->dwID;
				data.idGroup = lpGroup->dwID;        
				data.lpISP = this->pISP;

			    hr = CALLSP(this->pcbSPCallbacks->RemovePlayerFromGroup,&data);
		    }
			else 
			{
				// no callback - no biggie
			}
		    if (FAILED(hr)) 
		    {
				DPF(0,"SP - remove player from group failed - hr = 0x%08lx\n",hr);
		    }

		    hr = RemovePlayerFromGroup(lpGroup,pSysGroupnode->pPlayer);
		    if (FAILED(hr)) 
		    {
				ASSERT(FALSE);
		    }

		}
	}

	// If this is a lobby-owned object, we need to call the lobby.  UNLESS
	// the fPropagate flag is cleared.  If it is cleared,  it means the
	// lobby called us for a remote player and we dont want to call it back
	// in that case.  OR if the group is the system group, we don't want to
	// call the lobby
	if((IS_LOBBY_OWNED(this)) && (fPropagate) && (idGroup != 0))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DeletePlayerFromGroup(this->lpLobbyObject, idGroup, idPlayer);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed deleting player from group on the lobby, hr = 0x%08x", hr);
			
			// If this failed, we need to add the player back into the group
			InternalAddPlayerToGroup(lpDP, idGroup, idPlayer, FALSE);
		}
	}

    return DP_OK;
	
} // InternalDeletePlayerFromGroup

HRESULT DPAPI DP_DeletePlayerFromGroup(LPDIRECTPLAY lpDP, DPID idGroup,DPID idPlayer) 
{
	HRESULT hr;
	
	ENTER_ALL();

	if (DPID_ALLPLAYERS == idGroup)
	{
		DPF_ERRVAL("invalid group id = %d", idGroup);
		LEAVE_ALL();
		return DPERR_INVALIDGROUP;
	}

	hr = InternalDeletePlayerFromGroup(lpDP, idGroup,idPlayer,TRUE);
	
	LEAVE_ALL();
	
	return hr;
	
}//DP_DeletePlayerFromGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DestroyPlayer"

/*
 ** RemovePlayerFromGroups
 *
 *  CALLED BY: DP_DestroyPlayer
 *
 *  PARAMETERS:
 *	lpPlayer - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: calls InternalDeletePlayerFromGroup on all groups until
 *		player is not in anymore groups
 *
 *  RETURNS: DP_OK
 *
 */

HRESULT RemovePlayerFromGroups(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,BOOL fPropagate) 
{
    LPDPLAYI_GROUP lpGroup;
    LPDPLAYI_GROUPNODE_V lpNodes;
    HRESULT hr;

    // we do this by walking the group list, and calling delete from group on all groups
    if (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)
    {
        lpGroup=this->pGroups;

    	while (lpGroup && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP) )
    	{
	 		if (lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
			{
				lpNodes = lpGroup->pSysPlayerGroupnodes;
			}
			else
			{
				lpNodes = lpGroup->pGroupnodes;
			}

	   		if (FindPlayerInGroupList(lpNodes,lpPlayer->dwID))
    		{
	        	// this fn. will attempt to remove player from group.
	            // (if players not in group, no big deal).
	            // when player is removed from all groups, DP_DeletePlayerFromGroup
	            // resets DPLAYI_FLAGS_PLAYERINGROUP
	        	hr = InternalDeletePlayerFromGroup((LPDIRECTPLAY)this->pInterfaces,
						lpGroup->dwID,lpPlayer->dwID,fPropagate);
				// ISSUE:  If the remove fails, we could get hosed in an infinite loop
				//		so we just move on to the next group
				if (FAILED(hr))
				{
					// this can fail because, e.g., the player is not in this
					// particular group...
					DPF(4,"DP_DeletePlayerFromGroup failed - hr = 0x%08lx\n",hr);
					// keep trying...

					lpGroup = lpGroup->pNextGroup;
				}
				else
				{
					lpGroup = this->pGroups;
				}
			}
			else
			{
	        	lpGroup=lpGroup->pNextGroup;
	        }
	    }	
    }
    return DP_OK;
        
} // RemovePlayerFromGroups

/*
 ** RemovePlayerFromPlayerList
 *
 *  CALLED BY: DP_DestroyPlayer
 *
 *  PARAMETERS:
 *	lpPlayer - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: takes player out of dplay objects list of players
 *
 *  RETURNS: DP_OK unless player is not in list
 *
 */

HRESULT RemovePlayerFromPlayerList(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer) 
{
    LPDPLAYI_PLAYER pRefPlayer,pPrevPlayer;
    BOOL bFoundIt=FALSE;
    
    pRefPlayer=this->pPlayers;
    pPrevPlayer=NULL;
    
    
    while ( (pRefPlayer) && (!bFoundIt))
    {
        if (pRefPlayer == lpPlayer) 
        {
            bFoundIt = TRUE;
            if (!pPrevPlayer)
            {
                // remove from front of list
            	this->pPlayers=pRefPlayer->pNextPlayer;
            }
            else
            {
            	// remove this player from the middle (or end) of list
  	        	pPrevPlayer->pNextPlayer = pRefPlayer->pNextPlayer;
            }
        }

        pPrevPlayer=pRefPlayer;
        pRefPlayer = pRefPlayer->pNextPlayer;
    }

    if (!bFoundIt) 
    {
    	ASSERT(FALSE);
    	DEBUG_BREAK();
    	return E_UNEXPECTED;	
    }
    return DP_OK;
}	// RemovePlayerFromPlayerList


void RemoveOwnerFromGroup(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP lpGroup,
		LPDPLAYI_PLAYER lpPlayer, BOOL fPropagate)
{
	LPDPLAYI_GROUPOWNER		lpNode, lpPrev = NULL;
	HRESULT					hr;

	ASSERT(lpGroup);
	ASSERT(lpPlayer);

	lpNode = lpPlayer->pOwnerGroupList;

	// Walk the list of groups in the player's list
	while(lpNode)
	{
		if(lpNode->pGroup == lpGroup)
		{
			// Remove the node from the list
			if(lpPrev)
				lpPrev->pNext = lpNode->pNext;
			else
				lpPlayer->pOwnerGroupList = lpNode->pNext;

			// Now free the node
			DPMEM_FREE(lpNode);
			lpNode = NULL;
		}
		else
		{
			// Move to the next node
			lpPrev = lpNode;
			lpNode = lpNode->pNext;
		}
	}

	// If the player is local, and the group is local, we want to set the
	// owner of the group to be the server player.  If the player is remote,
	// or if the gorup is remote, we don't
	// want to touch it, because they may not really be going away, they
	// may only be getting purged from the nametable due to our
	// nametable partitioning algorithm.
	// Also, make sure the propagate flag is set, otherwise we don't
	// need to tell the server or the other players at all (this happens
	// if the group is being destroyed)
	if(fPropagate && (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		(lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Change the owner of the group to the server player
		hr = DPL_SetGroupOwner((LPDIRECTPLAY)this->pInterfaces, lpGroup->dwID,
				DPID_SERVERPLAYER);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to set group owner to DPID_SERVERPLAYER, hr = 0x%08x", hr);
		}

		// Take the lock back
		ENTER_DPLAY();
	}

} // RemoveOwnerFromGroup

// Completes all pending sends from a player right away.
VOID CompletePendingSends(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	BILINK *pBilink;
	PSENDPARMS psp, pspcopy;

	pBilink=pPlayer->PendingList.next;
	while(pBilink!=&pPlayer->PendingList){
		psp=CONTAINING_RECORD(pBilink, SENDPARMS, PendingList);
		pBilink=pBilink->next;
		
		Delete(&psp->PendingList);
		InitBilink(&psp->PendingList);
		pspcopy=GetSendParms(); // allocates send parm, sets refcount to 1.
		if(pspcopy){
			DPF(5,"Queueing completion of send psp %x not really yet completed, using copy %x\n",psp, pspcopy);
			memcpy(&pspcopy->PendingList, &psp->PendingList, sizeof(SENDPARMS)-offsetof(SENDPARMS,PendingList));
			InitBilink(&pspcopy->PendingList);
			pspcopy->hr=DPERR_INVALIDPLAYER;
			pspcopy->dwSendCompletionTime=timeGetTime();
			QueueSendCompletion(this, pspcopy);
		}
	}
}

/*
 ** InternalDestroyPlayer
 *
 *  CALLED BY:	DP_DestroyPlayer,KillPlayer (from ping.c)
 *
 *  PARAMETERS: 
 *				lpPlayer - player we want killed
 *				fPropagate - if we're called from KillPlayer (ping.c) and we want
 *					to remove the player from the global nametable, this is TRUE
 *				fLookForNewNS - if this is the Nameserver, whether or not to look for another
 *  DESCRIPTION:
 *				kills the player
 *
 *  RETURNS:
 *				pretty much DP_OK
 *
 */
HRESULT InternalDestroyPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,BOOL fPropagate,BOOL fLookForNewNS) 
{
    HRESULT hr = DP_OK;
    DPSP_DELETEPLAYERDATA dd;
	BOOL fNameServer = lpPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR;
	BOOL fLocal = lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL;
	DPID dwPlayerID;

	ASSERT(lpPlayer != NULL);
	
	#ifdef DEBUG
	if(lpPlayer->nPendingSends){
		DPF(0,"WARNING:Destroying player with %d pending sends...\n",lpPlayer->nPendingSends);
	}
	#endif
	
	DPF(5,"destroying player - id = %d\n",lpPlayer->dwID);
	DPF(5,"local = %d, nameserver = %d", fLocal, fNameServer);

	if (lpPlayer == this->pSysPlayer)
	{
		// it's only leagal to delete the Sys player if we're closing
		ASSERT(this->dwFlags & DPLAYI_DPLAY_CLOSED);
		if (!(this->dwFlags & DPLAYI_DPLAY_CLOSED))
			return DPERR_GENERIC;
	}
	
	dwPlayerID=lpPlayer->dwID;

	DPF(8,"In InternalDestroyPlayer, calling CompletePendingSends...\n");
	CompletePendingSends(this,lpPlayer);

	// If this is a lobby object, call the lobby code instead of calling
	// a dplay SP.  The CALLSP code which follows will not get executed
	// since the callback will not exist for a lobby-owned object.  However,
	// if the fPropagate flag is cleared, it means the lobby called us
	// for a remote player, so don't call it back.  Don't call the lobby
	// if it is a system player either.
	if((IS_LOBBY_OWNED(this)) && (fPropagate) &&
		(!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DestroyPlayer(this->lpLobbyObject, lpPlayer->dwID);
		
		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to destroy player, hr = 0x%08x", hr);
			return hr;
		}
		else
		{
			// Clear the propagate flag so that dplay doesn't call back into
			// the lobby inside RemovePlayerFromGroups (and InternalDelete-
			// PlayerFromGroup), because it will fail since the lobby has
			// already deleted the player.
			fPropagate = FALSE;
		}
	}

	if(lpPlayer->dwFlags & DPLAYI_PLAYER_BEING_DESTROYED){
		return DPERR_INVALIDPLAYER;
	} else {
		lpPlayer->dwFlags |= DPLAYI_PLAYER_BEING_DESTROYED;
	}	

	// remove player from any groups
	hr = RemovePlayerFromGroups(this,lpPlayer,fPropagate);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

	// call the sp
	if (this->pcbSPCallbacks->DeletePlayer || this->pProtocol)
	{
		// call sp
		dd.idPlayer = lpPlayer->dwID;
		dd.dwFlags = lpPlayer->dwFlags; 
		dd.lpISP = this->pISP;

		ASSERT(gnDPCSCount==1);

		if(this->pProtocol){
			hr = ProtocolDeletePlayer(&dd); 
		} 
		
		if(this->pcbSPCallbacks->DeletePlayer){
	    	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
			if (FAILED(hr)) 
			{
				DPF_ERR(" SP could not delete player!!"); 
			}
	    }	

	}
	else 
	{
		// sp doesn't need to implement this one...
	}
	
    // remove player from player list
    hr = RemovePlayerFromPlayerList(this,lpPlayer);
	this->nPlayers--;
	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

	if (fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER, lpPlayer->dwID, 
			0);		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		// could have lost player pointer in SendPlayerManagementMessage, re-establish
		lpPlayer=PlayerFromID(this,dwPlayerID);
		if(!lpPlayer){
			DPF(0,"Player x%x was blown away during propogation of Delete\n",dwPlayerID);
			goto EXIT;
		}
	}

	
	// app server?
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
	{
		DPF(4,"destroying app server");
		this->pServerPlayer = NULL;
	}

	// name server?
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
	{
		DPF(4,"destroying name server");
		this->pNameServer = NULL;
	}
	
	// Owner of any groups?  Then remove ourselves as the owner.
	while(lpPlayer->pOwnerGroupList)
	{
		RemoveOwnerFromGroup(this, lpPlayer->pOwnerGroupList->pGroup,
			lpPlayer, TRUE);

		lpPlayer=PlayerFromID(this,dwPlayerID);
		if(!lpPlayer){
			DPF(0,"Player x%x was blown away during RemoveOwnerFromGroup\n", dwPlayerID);
			goto EXIT;
		}
	}

    FreeNameTableEntry(this,lpPlayer->dwID);

    // update sessiondesc
    if (!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) this->lpsdDesc->dwCurrentPlayers--;

    // deallocate strings + player
    DeallocPlayer(lpPlayer);

	// if we're pushing this delete across the wire, and its the 
	// nameserver we deleted, see if we're the new name server	
	if ( (fNameServer || 
		 (this->dwMinVersion >= DPSP_MSG_DX61AVERSION && this->dwFlags & DPLAYI_DPLAY_NONAMESERVER)
		 ) && !fLocal &&  fLookForNewNS)
	{
		// We shouldn't ever get in here if we're a lobby-owned object
		ASSERT(!IS_LOBBY_OWNED(this));

		hr = HandleDeadNameServer(this);
		if (FAILED(hr))
		{
			DPF(0,"HandleDeadNameServer returned error: 0x%x\n", hr);
			ASSERT(FALSE);
		}
	}
	
    // todo - cruise any messages (this will apply to lobby objects as well)
EXIT:
    return DP_OK;
	
} // InternalDestroyPlayer

HRESULT DPAPI DP_DestroyPlayer(LPDIRECTPLAY lpDP, DPID idPlayer) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	BOOL fLocal;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
        lpPlayer = PlayerFromID(this,idPlayer);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid player id = %d", idPlayer);
            return DPERR_INVALIDPLAYER;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_ALL();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
    
	fLocal = lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL;
	
	// Because of bug #12901, we want the host to be able to destroy all
	// players (even remote players) so they can implement their
	// own keep-alives.
	if ((!fLocal) && (!IAM_NAMESERVER(this)))
	{
		LEAVE_ALL();
		DPF_ERR("attempt to destroy non-local player.  not gonna happen.");
		return DPERR_ACCESSDENIED;
	}
		
	hr = InternalDestroyPlayer(this,lpPlayer,TRUE,TRUE);

	LEAVE_ALL();

    return hr;
       
}//DP_DestroyPlayer

#undef DPF_MODNAME
#define DPF_MODNAME "DP_DestroyGroup"

HRESULT RemoveGroupFromGroupList(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup) 
{
	LPDPLAYI_GROUP lpGroupPrev,lpGroupSearch;
	BOOL bFoundIt=FALSE;

	// remove the group from the list
	lpGroupSearch = this->pGroups;
	lpGroupPrev=NULL;
	
	while ((lpGroupSearch)&&(!bFoundIt))
	{
		if (lpGroupSearch->dwID == lpGroup->dwID) bFoundIt=TRUE;
		else 
		{
			lpGroupPrev=lpGroupSearch;
			lpGroupSearch=lpGroupSearch->pNextGroup;
		}
	} 

	if (!bFoundIt) 
	{
		ASSERT(FALSE);
		DPF_ERR("bad group!");
        return DPERR_INVALIDPARAMS;
	}

	ASSERT(lpGroupSearch->pGroupnodes == NULL);
	if (lpGroupPrev) lpGroupPrev->pNextGroup = lpGroupSearch->pNextGroup;
    else this->pGroups = lpGroupSearch->pNextGroup;

	// success
	return DP_OK;
	
} // RemoveGroupFromGroupList

/*
 ** RemoveGroupFromAllGroups
 *
 *  CALLED BY: DP_DestroyGroup
 *
 *  PARAMETERS:
 *	lpGroup - player to remove
 *	this - dplay object
 *
 *  DESCRIPTION: calls InternalDeleteGroupFromGroup on all groups until
 *		player is not in anymore groups
 *
 *  RETURNS: DP_OK
 *
 */

HRESULT RemoveGroupFromAllGroups(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup,BOOL fPropagate) 
{
    LPDPLAYI_GROUP lpGroupFrom;
    HRESULT hr;

    // we do this by walking the group list, and calling delete from group on all groups
    if (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP)
    {
        lpGroupFrom=this->pGroups;
        
    	while (lpGroupFrom && (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    	{
			// Don't try to remove any groups from the system group
			// because there will never be any in it and we're just
			// wasting our time
			if(lpGroupFrom->dwID != DPID_ALLPLAYERS)
			{
				// this fn. will attempt to remove player from group.
				// (if players not in group, no big deal).
				// when player is removed from all groups, DP_DeleteGroupFromGroup
				// resets DPLAYI_FLAGS_PLAYERINGROUP
            	hr = InternalDeleteGroupFromGroup((LPDIRECTPLAY)this->pInterfaces,
						lpGroupFrom->dwID,lpGroup->dwID,fPropagate);
				if (FAILED(hr))
				{
					// this can fail because, e.g., the player is not in this
					// particular group...
					DPF(4,"DP_DeleteGroupFromGroup failed - hr = 0x%08lx\n",hr);
					// keep trying...
				}
			}
            lpGroupFrom=lpGroupFrom->pNextGroup;		
    	}	
    }
    return DP_OK;
        
} // RemoveGroupFromAllGroups

//
// called by DP_DestroyGroup and SP_HandlePlayerMgmt and DP_Close
// if called by DP_DestroyGroup, fPropagate is TRUE, and we should remove group
// from global nametable.  Otherwise, we just remove from our nametable
HRESULT InternalDestroyGroup(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP lpGroup,BOOL fPropagate)
{
	HRESULT hr;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodeNext; 
	DPSP_DELETEGROUPDATA dd;
	LPDPLAYI_SUBGROUP pSubgroup,pSubgroupNext;
	LPDPLAYI_PLAYER pOwner = NULL;
	 	
	// If this is a lobby object, call the lobby.  Unless the fPropagate flag
	// is cleared.  If it is cleared, it means the lobby called us for a
	// remote player and we don't want to call it back in that case.
	if((IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// Drop the lock so the lobby provider's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_DestroyGroup(this->lpLobbyObject, lpGroup->dwID);

		// Take the lock back
		ENTER_DPLAY();

		if(FAILED(hr))
		{
			DPF_ERRVAL("Lobby failed to destroy group, hr = 0x%08x", hr);
			return hr;
		}
		else
		{
			// Clear the propagate flag so that dplay doesn't call back into
			// the lobby inside RemoveGroupsFromGroups (and InternalDelete-
			// GroupFromGroup), because it will fail since the lobby has
			// already deleted the group.  Ditto for all the following
			// DeleteGroup.... and DeletePlayer calls.
			fPropagate = FALSE;
		}
	}

    // remove group from any groups
    hr = RemoveGroupFromAllGroups(this,lpGroup,fPropagate);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// keep trying
	}

    // remove all players from group
    // just remove the 1st player in the list until all players are gone
    lpGroupnode = lpGroup->pGroupnodes;
    while (lpGroupnode)
    {
		// save next group node b4 we delete current one...
		// If this is a lobby object, we don't need to propagate the
		// DeletePlayerFromGroup message because the server already
		// knows about it.  Besides, it will fail out since the lobby
		// code has already removed the GroupID from the map table.
		lpGroupnodeNext = lpGroupnode->pNextGroupnode;
        hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,lpGroupnode->pPlayer->dwID,
			(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}
 		lpGroupnode =  lpGroupnodeNext;
 	}

    // remove all system players from group
    // just remove the 1st player in the list until all players are gone
    lpGroupnode = lpGroup->pSysPlayerGroupnodes;
	// only system group can have system players in a group w/ no corresponding app player
	if (lpGroupnode) ASSERT(lpGroup->dwFlags & DPLAYI_GROUP_SYSGROUP);
    while (lpGroupnode)
    {
		// save next group node b4 we delete current one...
		// we never propagate this since it's sysplayer stuff...
		lpGroupnodeNext = lpGroupnode->pNextGroupnode;
        hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,lpGroupnode->pPlayer->dwID,
			FALSE);
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}
 		lpGroupnode =  lpGroupnodeNext;
 	}
	
	// remove all groups from group
	// if subgroup is not a shortcut, destroy subgroup too
	pSubgroup = lpGroup->pSubgroups;
	while (pSubgroup)
	{
		pSubgroupNext = pSubgroup->pNextSubgroup;

		if (! (pSubgroup->dwFlags & DPGROUP_SHORTCUT) )
		{
			LPDPLAYI_GROUP pGroupKill = pSubgroup->pGroup; // pSubgroup	is gonna get
															// nuked b4 we're done with it
			
			// it's not a shortcut, it's contained.  remove it, then destroy it.
			hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
			lpGroup->dwID,pSubgroup->pGroup->dwID,FALSE);
			
			hr = InternalDestroyGroup(this,pGroupKill,
				(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
			
			// we may have effected the list - start over to be safe
			pSubgroupNext = lpGroup->pSubgroups;
		}
		else 
		{
			// it's  a shortcut, delete it
			hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
				lpGroup->dwID,pSubgroup->pGroup->dwID,
				(IS_LOBBY_OWNED(this) ? FALSE : fPropagate));
		}
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			// keep trying
		}

		pSubgroup = pSubgroupNext;
	}
	
	if (fPropagate)
	{
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEGROUP, 0, lpGroup->dwID);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep going
		}
	}

	if (!(lpGroup->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && (this->pcbSPCallbacks->DeleteGroup) )
	{
		// call sp
		dd.idGroup = lpGroup->dwID;
		dd.dwFlags = lpGroup->dwFlags;
		dd.lpISP = this->pISP;

    	hr = CALLSP(this->pcbSPCallbacks->DeleteGroup,&dd);
		if (FAILED(hr)) 
		{
			DPF_ERR("sp - could not delete group!!"); 
		}
	}
	else 
	{
		// sp doesn't need to implement this one...
	}

	// Are we a lobby session and is there an owner.  If so, remove the owner
	// node from the player's list.
	if(IS_LOBBY_OWNED(this) && (lpGroup->dwOwnerID != DPID_SERVERPLAYER))
	{
		pOwner = PlayerFromID(this, lpGroup->dwOwnerID);
		if(pOwner)
			RemoveOwnerFromGroup(this, lpGroup, pOwner, FALSE);
	}

    hr = FreeNameTableEntry(this,lpGroup->dwID);
	if (FAILED(hr))
	{
    	return hr;
	}
	
	hr = RemoveGroupFromGroupList(this,lpGroup);
	if (FAILED(hr))
	{
    	return hr;
	}

	DeallocGroup(lpGroup);

	this->nGroups--;
	
	return DP_OK;
	
} // InternalDestroyGroup

HRESULT DPAPI DP_DestroyGroup(LPDIRECTPLAY lpDP, DPID idGroup) 
{

    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP lpGroup;
	BOOL fLocal;

	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }
		
        lpGroup = GroupFromID(this,idGroup);
        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == idGroup)) 
        {
			LEAVE_ALL();
			DPF_ERRVAL("invalid group id = %d", idGroup);
            return DPERR_INVALIDGROUP;
        }
        		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }

	fLocal = (lpGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;
	DPF(3,"destroying group - fLocal = %d\n",fLocal);
	
	hr = InternalDestroyGroup( this, lpGroup, TRUE);

	LEAVE_ALL();
    return hr;
        
}//DP_DestroyGroup

#undef DPF_MODNAME
#define DPF_MODNAME "DP_EnableNewPlayers"

HRESULT DPAPI DP_EnableNewPlayers(LPDIRECTPLAY lpDP, BOOL bEnable) 
{

    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }
	
	if (!this->lpsdDesc) 
	{
		LEAVE_DPLAY();
		DPF_ERR("must open a session before enabling new players");
		return DPERR_NOSESSIONS;
	}

    // set dp_bNewPlayersEnabled
    if (bEnable) 
    {
		this->lpsdDesc->dwFlags &= ~DPSESSION_NEWPLAYERSDISABLED;
    }
    else
    {
		this->lpsdDesc->dwFlags |= DPSESSION_NEWPLAYERSDISABLED;
    } 
	
	
    LEAVE_DPLAY();
    return hr;

}//DP_EnableNewPlayers

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetCaps"

void SetDefaultCaps(LPDPCAPS lpDPCaps)
{

	// just to be safe (belt + suspenders!)
	memset(lpDPCaps,0,sizeof(DPCAPS));

	lpDPCaps->dwSize = sizeof(DPCAPS);
		
	// we show the 0 values here, just to be explicit
	lpDPCaps->dwMaxBufferSize 		= DPLAY_MAX_BUFFER_SIZE;
	lpDPCaps->dwMaxQueueSize		= 0;    
	lpDPCaps->dwMaxPlayers			= DPLAY_MAX_PLAYERS;			
	lpDPCaps->dwHundredBaud			= 0;     
	lpDPCaps->dwLatency				= 0;
	lpDPCaps->dwMaxLocalPlayers		= DPLAY_MAX_PLAYERS;	
	lpDPCaps->dwFlags				= 0;
	lpDPCaps->dwHeaderLength		= 0;
	lpDPCaps->dwTimeout				= 0;

	return;

} // SetDefaultCaps

// called by InternalGetCaps.  set dpplayercaps
HRESULT GetPlayerCaps(LPDPCAPS lpCaps,LPDPLAYI_PLAYER lpPlayer)
{
	ASSERT(lpPlayer);
	if (!lpPlayer) return E_FAIL; // ACK!
	
	if (lpPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
		lpCaps->dwFlags |= DPPLAYERCAPS_LOCAL;		
	} 

	if(!lpCaps->dwLatency){
		// neither SP or Protocol had a guess at the latency, so use our best guess. 
		lpCaps->dwLatency=lpPlayer->dwLatencyLastPing;
	}

	return DP_OK;		
} // GetPlayerCaps

// called by getcaps,getplayercaps
// assumes dplay lock taken!
HRESULT InternalGetCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,BOOL fPlayer,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	DPSP_GETCAPSDATA gcd;
	LPDPLAYI_PLAYER lpPlayer;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!VALID_DPLAY_CAPS(lpDPCaps))
		{
			DPF_ERR("invalid caps struct");
	        return DPERR_INVALIDPARAMS;
		}
		if (dwFlags & ~DPGETCAPS_GUARANTEED)
		{
			DPF_ERR("invalid caps flags");
			return DPERR_INVALIDPARAMS;
		}
        if (fPlayer)
        {
	        lpPlayer = PlayerFromID(this,idPlayer);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERR("invalid player");
	            return DPERR_INVALIDPLAYER;
	        }	
        } 
		else 
		{
			lpPlayer = NULL;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	SetDefaultCaps(lpDPCaps);

	// If this is lobby-owned, call the lobby provider here and let it fill
	// in the caps structure
	if(IS_LOBBY_OWNED(this))
	{
		// Drop the dplay lock
		LEAVE_DPLAY();
		
		// Call the appropriate GetCaps or GetPlayerCaps in the lobby
		if(!lpPlayer)
		{
			hr = PRV_GetCaps(this->lpLobbyObject, dwFlags, lpDPCaps);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed calling GetCaps in the lobby, hr = 0x%08x", hr);
			}
		}
		else
		{
			hr = PRV_GetPlayerCaps(this->lpLobbyObject, dwFlags, idPlayer, lpDPCaps);
			if(FAILED(hr))
			{
				DPF_ERRVAL("Failed calling GetPlayerCaps in the lobby, hr = 0x%08x", hr);
			}
		}

		// Take the lock back
		ENTER_DPLAY();

		// If we failed, bail
		if(FAILED(hr))
			return hr;
	}


    // get caps from sp
    if (this->pcbSPCallbacks->GetCaps) 
    {
		// call sp
		gcd.lpCaps = lpDPCaps;
		gcd.dwFlags = dwFlags;
		if (lpPlayer) gcd.idPlayer = lpPlayer->dwID;
		else gcd.idPlayer = 0;
		gcd.lpISP = this->pISP;

		if(this->pProtocol){
			hr = ProtocolGetCaps(&gcd); // calls sp and patches returns
		} else {
		    hr = CALLSP(this->pcbSPCallbacks->GetCaps,&gcd);	    	
	    }
  	    if (FAILED(hr)) 
	    {
			DPF(0,"sp get caps failed - hr = 0x%08lx\n",hr);
	    }
  	}
	else 
	{
		// no callback is ok
	}
	
	// if the buffer size is zero, set it to the max (#12634)
	if(lpDPCaps->dwMaxBufferSize == 0)
		lpDPCaps->dwMaxBufferSize = DPLAY_MAX_BUFFER_SIZE;

	// fix up max buffer size (since we add header) raid # 2324
	lpDPCaps->dwMaxBufferSize -= sizeof(MSG_PLAYERMESSAGE);

	// for dx3, we don't support guaranteed unless sp does
	if (lpDPCaps->dwFlags & DPCAPS_GUARANTEEDOPTIMIZED)	
	{
		lpDPCaps->dwFlags |= DPCAPS_GUARANTEEDSUPPORTED;
	} else {
		this->dwFlags |= DPLAYI_DPLAY_SPUNRELIABLE;
	}

	// are we the host? (nameserver)
	if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)) 
	{
		lpDPCaps->dwFlags |= DPCAPS_ISHOST;
	}
	else 
	{
		lpDPCaps->dwFlags &= ~DPCAPS_ISHOST;
	} 

    // setup security caps
    if (this->dwFlags & DPLAYI_DPLAY_SECURITY)
    {
        // digital signing is supported
        lpDPCaps->dwFlags |= DPCAPS_SIGNINGSUPPORTED;

        // do we have encryption support ?
        if (this->dwFlags & DPLAYI_DPLAY_ENCRYPTION)
        {
            lpDPCaps->dwFlags |= DPCAPS_ENCRYPTIONSUPPORTED;
        }
        else
        {
            lpDPCaps->dwFlags &= ~DPCAPS_ENCRYPTIONSUPPORTED;
        }

    }
    
    if (lpDPCaps->dwFlags & DPCAPS_GROUPOPTIMIZED)
    {
    	// sp wants to optimize groups
    	if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||
    		(this->lpsdDesc && (this->lpsdDesc->dwFlags & (DPSESSION_CLIENTSERVER | DPSESSION_SECURESERVER))))
		{
			// if these conditions are true dplay will take over the owndership of groups
			// and won't allow sp to optimize groups
			lpDPCaps->dwFlags &= ~(DPCAPS_GROUPOPTIMIZED);
		}
	}

	this->dwSPFlags = lpDPCaps->dwFlags;	// remember the SP caps to validate send params.
	
	// player caps - note, we just stuff 'em on top of dpcaps for compatibility
	if (fPlayer) hr = GetPlayerCaps(lpDPCaps,lpPlayer);

	return hr;

} // InternalGetCaps

HRESULT DPAPI DP_GetCaps(LPDIRECTPLAY lpDP, LPDPCAPS lpDPCaps,DWORD dwFlags) 
{
	HRESULT hr;

    ENTER_DPLAY();
	
	hr = InternalGetCaps(lpDP,0, lpDPCaps,FALSE,dwFlags);
	 
    LEAVE_DPLAY();
    return hr;
        
}//DP_GetCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetMessageCount"

HRESULT DPAPI DP_GetMessageCount(LPDIRECTPLAY lpDP, DPID idPlayer, LPDWORD pdwCount) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPMESSAGENODE pmsg;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		if (idPlayer)
		{
			LPDPLAYI_PLAYER pPlayer;

			pPlayer = PlayerFromID(this,idPlayer);
			if (!VALID_DPLAY_PLAYER(pPlayer)) 
			{
				DPF_ERRVAL("invalid player id = %d", idPlayer);
				LEAVE_DPLAY();
				return DPERR_INVALIDPLAYER;
			}
		}

		if (!VALID_DWORD_PTR(pdwCount))
		{
	        DPF_ERR( "bad count pointer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}
		*pdwCount = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	if (!idPlayer)
	{
		*pdwCount = (DWORD)this->nMessages;		
	} 
	else 
	{
		pmsg = this->pMessageList; //  1st message
		while (pmsg)
		{		
			if (pmsg->idTo == idPlayer) (*pdwCount)++;
			pmsg = pmsg->pNextMessage;
		}
	}

    LEAVE_DPLAY();
    return hr;
        
}//DP_GetMessageCount

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerAddress"

HRESULT DPAPI DP_GetPlayerAddress(LPDIRECTPLAY lpDP,DPID idPlayer, LPVOID pvAddress,
	LPDWORD pdwAddressSize) 
{
	
    LPDPLAYI_DPLAY this;
    LPDPLAYI_PLAYER lpPlayer = NULL;
    HRESULT hr = DP_OK;
	DPSP_GETADDRESSDATA dad;
	DPSP_GETADDRESSCHOICESDATA dac;

    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();
			return hr;
        }

		// check player address if there is one
		if (idPlayer != DPID_ALLPLAYERS)
		{
			lpPlayer = PlayerFromID(this,idPlayer);
			if (!VALID_DPLAY_PLAYER(lpPlayer)) 
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("invalid player id = %d", idPlayer);
				return DPERR_INVALIDPLAYER;
			}
		}

		if (!VALID_DWORD_PTR(pdwAddressSize))
		{
	        DPF_ERR( "bad size pointer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}

		if (!pvAddress) *pdwAddressSize = 0;

		if (*pdwAddressSize && 
			!VALID_STRING_PTR(pvAddress,*pdwAddressSize))
		{
	        DPF_ERR( "bad addresss buffer" );
	        LEAVE_DPLAY();
	        return DPERR_INVALIDPARAMS;
		}

		if(IS_LOBBY_OWNED(this))
		{
			LEAVE_DPLAY();
			DPF_ERR("GetPlayerAddress not supported for lobby connections");
			return DPERR_UNSUPPORTED;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	// if they ask for the player address for all players, then we give
	// them the address choices available for this service provider
	if (DPID_ALLPLAYERS == idPlayer)
	{
		if (this->pcbSPCallbacks->GetAddressChoices)
		{
			dac.lpAddress = pvAddress;
			dac.lpdwAddressSize = pdwAddressSize;
			dac.lpISP = this->pISP;

			hr = CALLSP(this->pcbSPCallbacks->GetAddressChoices,&dac);	    			
		}
		else 
		{
			hr = E_NOTIMPL;
		}
	}

	// otherwise just get address for the given player
	else
	{
		if (this->pcbSPCallbacks->GetAddress)
		{
			dad.idPlayer = lpPlayer->dwIDSysPlayer;
			dad.lpAddress = pvAddress;
			dad.lpdwAddressSize = pdwAddressSize;
			dad.dwFlags = lpPlayer->dwFlags;
			dad.lpISP = this->pISP;

			hr = CALLSP(this->pcbSPCallbacks->GetAddress,&dad);	    			
		}
		else 
		{
			hr = E_NOTIMPL;
		}
	}
 
	LEAVE_DPLAY();

	return hr;
		
} // DP_GetPlayerAddress

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerCaps"

HRESULT DPAPI DP_GetPlayerCaps(LPDIRECTPLAY lpDP,DPID idPlayer, LPDPCAPS lpDPCaps,DWORD dwFlags) 
{
	HRESULT hr;

    ENTER_DPLAY();
	
	hr = InternalGetCaps(lpDP,idPlayer, lpDPCaps,TRUE,dwFlags);
	 
    LEAVE_DPLAY();
    return hr;
        
}//DP_GetPlayerCaps

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerData/GetGroupData"

// called by internalcreateplayer,internalsetname,internalsetdata
HRESULT CheckGetDataFlags(DWORD dwFlags)
{
	// check flags
	if ( dwFlags & ~(DPGET_REMOTE | DPGET_LOCAL) )
		
	{
		DPF_ERR("bad flags");
		return DPERR_INVALIDPARAMS;	
	}

	return DP_OK;

} // CheckSetDataFlags

// take a pointer to a buffer, stick a player(or group) data in it, slap the strings
// on the end.  
HRESULT  InternalGetData(LPDIRECTPLAY lpDP,DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;
	LPVOID pvSource; // local or remote data
	DWORD dwSourceSize;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwDataSize))
		{
			DPF_ERR("invalid pdwDataSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!pvData) *pdwDataSize = 0;
		if (*pdwDataSize && !VALID_STRING_PTR(pvData,*pdwDataSize))
		{
			DPF_ERR("invalid buffer");
			return DPERR_INVALIDPARAMS;	
		}
		// check flags
		hr = CheckGetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			DPF_ERR("invalid get data flags");
			return hr;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// figure out which source they want
	if (dwFlags & DPGET_LOCAL)
	{
		pvSource = pPlayer->pvPlayerLocalData;
		dwSourceSize = pPlayer->dwPlayerLocalDataSize;
	}
	else 
	{
		// If this is a lobby-owned object, we need to go get the data
		// from the lobby server.  We will never store it locally (sorry
		// for the pun).
		if(!IS_LOBBY_OWNED(this))
		{
			pvSource = pPlayer->pvPlayerData;
			dwSourceSize = pPlayer->dwPlayerDataSize;
		}
		else
		{
			// Drop the lock so response from the lobby can get back in
			ASSERT(1 == gnDPCSCount);
			LEAVE_DPLAY();
			
			// Get the data from the lobby
			if(fPlayer)
			{
				hr = PRV_GetPlayerData(this->lpLobbyObject, id,
							pvData, pdwDataSize);
			}
			else
			{
				hr = PRV_GetGroupData(this->lpLobbyObject, id,
							pvData, pdwDataSize);
			}

			// Take the lock again
			ENTER_DPLAY();
			
			// Since we've already copied the data into the caller's buffer,
			// we can just exit from here.
			return hr;
		}
	}

	// see if we've got space for it
	if (*pdwDataSize < dwSourceSize)
	{
		// not enough space
		*pdwDataSize = dwSourceSize;
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		// copy it
		*pdwDataSize = dwSourceSize;
		hr = DP_OK;
		memcpy(pvData,pvSource,*pdwDataSize);		
	}
	
	return hr;
	
} // InternalGetData  

HRESULT DPAPI DP_GetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetData(lpDP,id,pvData,pdwDataSize,dwFlags,FALSE);

	LEAVE_DPLAY();
	
	return hr;
	

} // DP_GetGroupData   

HRESULT DPAPI DP_GetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,
	LPDWORD pdwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetData(lpDP,id,pvData,pdwDataSize,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerData  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupName"

// take a pointer to a buffer, stick a session desc in it, slap the strings
// on the end.  
HRESULT InternalGetName(LPDIRECTPLAY lpDP, DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fPlayer,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	UINT nShortLen,nLongLen; // length in bytes of strings
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwSize))
		{
			DPF_ERR("invalid pdwDataSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!pvBuffer) *pdwSize = 0;
		if (*pdwSize && !VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
			DPF_ERR("invalid buffer");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	if (fAnsi)
	{
		nShortLen = WSTR_ANSILENGTH(pPlayer->lpszShortName);
		nLongLen = WSTR_ANSILENGTH(pPlayer->lpszLongName);
	}
	else 
	{
		nShortLen = WSTRLEN_BYTES(pPlayer->lpszShortName);
		nLongLen = WSTRLEN_BYTES(pPlayer->lpszLongName);
	}

	// see if buffer is big enough
	if (*pdwSize < sizeof(DPNAME) + nShortLen + nLongLen )
	{
		*pdwSize = sizeof(DPNAME) + nShortLen + nLongLen;
		return DPERR_BUFFERTOOSMALL;
	}

	// zero it
	memset(pvBuffer,0,*pdwSize);
	
	// set up the playername struct, followed by strings
	*pdwSize = sizeof(DPNAME) + nShortLen + nLongLen;
	((LPDPNAME)pvBuffer)->dwSize = sizeof(DPNAME);

	// get strings
	if (fAnsi)
	{
		LPSTR psz;

		// short name, then long name
		psz = (LPBYTE)pvBuffer+sizeof(DPNAME);

		if (pPlayer->lpszShortName)
		{
			// string goes after name struct in buffer
			WideToAnsi(psz,pPlayer->lpszShortName,nShortLen);
			((LPDPNAME)pvBuffer)->lpszShortNameA = psz;
			// now, long name
			psz += nShortLen;
		}
		
		if (pPlayer->lpszLongName)
		{
			// string goes after session desc in buffer
			WideToAnsi(psz,pPlayer->lpszLongName,nLongLen);
			((LPDPNAME)pvBuffer)->lpszLongNameA = psz;
		}

	}
	else 
	{
		LPWSTR pszW;

		pszW = (LPWSTR)((LPBYTE)pvBuffer+sizeof(DPNAME));

		// short name, then long name
		if (pPlayer->lpszShortName)
		{
			// string goes after player name struct in buffer
			memcpy(pszW,pPlayer->lpszShortName,nShortLen);
			((LPDPNAME)pvBuffer)->lpszShortName = pszW;
		}
		
		if (pPlayer->lpszLongName)
		{
			// now, long name
			pszW = (LPWSTR)((LPBYTE)pszW + nShortLen);
			// string goes after session desc in buffer
			memcpy(pszW,pPlayer->lpszLongName,nLongLen);
			((LPDPNAME)pvBuffer)->lpszLongName = pszW;
		}
	}
	
	return DP_OK;
} // InternalGetName

HRESULT DPAPI DP_GetGroupName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)	
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, FALSE, FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerName"

HRESULT DPAPI DP_GetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPVOID pvBuffer,
	LPDWORD pdwSize)
{

	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetName(lpDP, id, pvBuffer, pdwSize, TRUE, FALSE);

	LEAVE_DPLAY();
	
	return hr;


} // DP_GetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "InternalGetFlags"

HRESULT  InternalGetFlags(LPDIRECTPLAY lpDP,DPID id,LPDWORD pdwFlags,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
        if (fPlayer)
        {
        	pPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(pPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        pGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// still use the pPlayer, since we care only about common fields
			pPlayer = (LPDPLAYI_PLAYER)pGroup;
		}
		if (!VALID_DWORD_PTR(pdwFlags))
		{
			DPF_ERR("invalid flags pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// get the flags
	*pdwFlags = GetPlayerFlags(pPlayer);
	
	return DP_OK;
	
} // InternalGetFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerFlags"

HRESULT DPAPI DP_GetPlayerFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetFlags(lpDP,id,pdwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupFlags"

HRESULT DPAPI DP_GetGroupFlags(LPDIRECTPLAY lpDP, DPID id,LPDWORD pdwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetFlags(lpDP,id,pdwFlags,FALSE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetGroupFlags  

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetSessionDesc"

// take a pointer to a buffer, stick a session desc in it, slap the strings
// on the end.
HRESULT InternalGetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	UINT nNameLen,nPasswordLen; // session name length, in bytes
	HRESULT hr;
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before getting desc!");
			return DPERR_NOSESSIONS;
		}
		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;
		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	if (fAnsi)
	{
		nPasswordLen = WSTR_ANSILENGTH(this->lpsdDesc->lpszPassword);
		nNameLen = WSTR_ANSILENGTH(this->lpsdDesc->lpszSessionName);
	}
	else 
	{
		nPasswordLen = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);	
		nNameLen = WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
	}	
	
	if (*pdwSize < sizeof(DPSESSIONDESC2) + nNameLen  + nPasswordLen)
	{
		*pdwSize = sizeof(DPSESSIONDESC2) + nNameLen + nPasswordLen;
		return DPERR_BUFFERTOOSMALL;
	}

	// zero it
	memset(pvBuffer,0,*pdwSize);

	*pdwSize = sizeof(DPSESSIONDESC2) + nNameLen + nPasswordLen;

	// pack it up
	memcpy(pvBuffer,this->lpsdDesc,sizeof(DPSESSIONDESC2));

	// get strings
	if (fAnsi)
	{
		LPSTR psz;

		psz = (LPBYTE)pvBuffer+sizeof(DPSESSIONDESC2);

		if (this->lpsdDesc->lpszSessionName)
		{
			// string goes after session desc in buffer
			WideToAnsi(psz,this->lpsdDesc->lpszSessionName,nNameLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszSessionNameA = psz;
		}
		
		if (this->lpsdDesc->lpszPassword)
		{
			// now, password
			psz += nNameLen;
			// password follows session same
			WideToAnsi(psz,this->lpsdDesc->lpszPassword,nPasswordLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszPasswordA = psz;
		}
	}
	else 
	{
		LPWSTR pszW;
		
		pszW = (LPWSTR)((LPBYTE)pvBuffer+sizeof(DPSESSIONDESC2));
		
		if (this->lpsdDesc->lpszSessionName)
		{
			// 1st, session name
			memcpy(pszW,this->lpsdDesc->lpszSessionName,nNameLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszSessionName = pszW;
		}			
		
		if (this->lpsdDesc->lpszPassword)
		{
			// then, password
			pszW = (LPWSTR)((LPBYTE)pszW + nNameLen);
			memcpy(pszW,this->lpsdDesc->lpszPassword,nPasswordLen);
			((LPDPSESSIONDESC2)pvBuffer)->lpszPassword = pszW;
		}
	}
	
	return DP_OK;
} // InternalGetSessionDesc

HRESULT DPAPI DP_GetSessionDesc(LPDIRECTPLAY lpDP, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetSessionDesc(lpDP,pvBuffer,pdwSize,FALSE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Initialize"

HRESULT DPAPI DP_Initialize(LPDIRECTPLAY lpDP, LPGUID lpGuid) 
{
    return DPERR_ALREADYINITIALIZED;	
}//DP_Initialize

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Open"

// get the system player / system group
HRESULT CreateSystemPlayer(LPDPLAYI_DPLAY this,DWORD dwFlags, LPWSTR lpszPassword)
{
	HRESULT hr;
	

   	// Even though the DPID_LOBBYSYSTEMPLAYER looks conspicuous here, it will
	// not have any effect in dplay sessions.  It will only be used if
	// we are in a lobby session.  Same for DPID_LOBBYSYSTEMGROUP below.
	hr = GetPlayer(this,&this->pSysPlayer,NULL,NULL,NULL,0,dwFlags,
			lpszPassword,DPID_LOBBYSYSTEMPLAYER);
    if (FAILED(hr)) 
    {
        DPF(0,"Could not create sysplayer - hr = 0x%08lx\n",hr);
		return hr;
    }

	// Create a system group.  This will be the group of all players
	// when we get a send to dpid_allplayers, we send it to this group and let sp 
	// optimize it.
   	hr = GetGroup(this,&((LPDPLAYI_GROUP)this->pSysGroup),NULL,NULL,0,
			DPLAYI_GROUP_SYSGROUP | DPLAYI_PLAYER_PLAYERLOCAL,0,
			DPID_LOBBYSYSTEMGROUP);
    if (FAILED(hr)) 
    {
        DPF(0,"Could not create system group - hr = 0x%08lx\n",hr);
		return hr;
    }
    
	ASSERT(this->pSysPlayer);

   	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
   			this->pSysPlayer->dwID,FALSE);
    if (FAILED(hr)) 
    {
		ASSERT(FALSE);
        DPF(0,"Could not add system player to  system group - hr = 0x%08lx\n",hr);
    }

	return hr;	

} // CreateSystemPlayer

// get the session desc out of an enumplayers reply
HRESULT UnpackSessionDesc(LPDPLAYI_DPLAY this,LPMSG_ENUMPLAYERSREPLY pmsg)
{
	LPDPSESSIONDESC2 psdNew;
	HRESULT hr;
	LPWSTR lpsz;
	
	ASSERT(this->lpsdDesc); // should have had one, with open

	psdNew = (LPDPSESSIONDESC2)((LPBYTE)pmsg + pmsg->dwDescOffset);
	
	// free any old strings
	if (this->lpsdDesc->lpszSessionName) DPMEM_FREE(this->lpsdDesc->lpszSessionName);
	if (this->lpsdDesc->lpszPassword) DPMEM_FREE(this->lpsdDesc->lpszPassword);
	
	// copy over the new desc
	memcpy(this->lpsdDesc,psdNew,sizeof(DPSESSIONDESC2));
		
	if (pmsg->dwNameOffset) GetString(&lpsz, (WCHAR *)((LPBYTE)pmsg + pmsg->dwNameOffset) );
	else lpsz = NULL;
	this->lpsdDesc->lpszSessionName = lpsz;

	if (pmsg->dwPasswordOffset) GetString(&lpsz, (WCHAR *)((LPBYTE)pmsg + pmsg->dwPasswordOffset) );
	else lpsz = NULL;
	this->lpsdDesc->lpszPassword = lpsz;
	
	return DP_OK;

	return hr;
	
} // UnpackSessionDesc

// called when we first join a session
// downloads the list of players and groups in the session from the nameserver
// called by internalopensession
HRESULT GetNameTable(LPDPLAYI_DPLAY this, DWORD dwServerVersion, BOOL fEnumOnly)
{
    UINT nPlayers,nGroups,nShortcuts; 
    LPMSG_SYSMESSAGE pmereq;
	LPBYTE pBuffer;
	LPBYTE pReply=NULL;
	LPVOID pvSPHeader;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	DWORD dwTimeout;
	DWORD dwVersion;
    DWORD dwCommand;

	DWORD dwReplyCommand;

    // send an enumplayers message if enumerating players in a remote session or
    // if nameserver won't automagically respond w/ the nametable on the addforward
    if ((fEnumOnly) || (dwServerVersion < DPSP_MSG_AUTONAMETABLE))
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
	    pBuffer = DPMEM_ALLOC(dwMessageSize);
	    if (!pBuffer) 
	    {
		    DPF_ERR("could not send request - out of memory");
		    return E_OUTOFMEMORY;
	    }

	    // pmsg follows sp blob
	    pmereq = (LPMSG_SYSMESSAGE)(pBuffer + this->dwSPHeaderSize);

        // build a message to send to the sp
   	    SET_MESSAGE_HDR(pmereq);

        SET_MESSAGE_COMMAND(pmereq,DPSP_MSG_ENUMPLAYER);

        // !! Review - the following stuff is already set in SendCreateMessage (AddForward)!!

	    // this flag indicates that any messages received before we get the whole
	    // nametable should be q'ed up.  Flag is reset in pending.c.
	    if (this->pSysPlayer)
	    {
		    // ok.  we've got a sysplayer, so we must be joining game for real.
		    // put us in pending mode, so we don't miss any nametable changes
		    // while we're waiting for the nametable to arrive
		    this->dwFlags |= DPLAYI_DPLAY_PENDING;
	    }

		if(dwServerVersion >= DPSP_MSG_DX5VERSION && !CLIENT_SERVER(this)){
			dwReplyCommand = DPSP_MSG_SUPERENUMPLAYERSREPLY;
		} else {
			dwReplyCommand = DPSP_MSG_ENUMPLAYERSREPLY;
		}


		SetupForReply(this,dwReplyCommand);

    	DPF(2,"requesting nametable");	

		//this->dwServerPlayerVersion=dwServerVersion; //moved to DP_Open

	    hr = SendDPMessage(this,this->pSysPlayer,NULL,pBuffer,dwMessageSize,DPSEND_SYSMESS,FALSE);

	    DPMEM_FREE(pBuffer); // done w/ message
	    
	    if (FAILED(hr)) 
	    {
	    	UnSetupForReply(this);
		    DPF_ERRVAL("could not send enumplayers request, hr = 0x%08lx", hr);
		    return hr;
	    }
    } 
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= (DP_NAMETABLE_SCALE-5);// scale up the amount of time we wait 
										// (nametable can be big)
										
	if (dwTimeout > DP_MAX_CONNECT_TIME)
		dwTimeout = DP_MAX_CONNECT_TIME;

	// changing to 30 sec on client, 15 sec on host.
	if(dwTimeout < DP_MAX_CONNECT_TIME/2){
		dwTimeout = DP_MAX_CONNECT_TIME/2;  
	}	

    DPF(2,"waiting for nametable:: timeout = %d\n",dwTimeout);	

	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

	hr=WaitForReply(this, &pReply, &pvSPHeader, dwTimeout);

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	// got a buffer with a message in it

    // if nameserver is DX5 or greater, it will respond with the nametable if 
    // addforward succeeds, otherwise it will respond with an addforwardreply containing
    // the error.
    dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReply);
    if (DPSP_MSG_ADDFORWARDREPLY == dwCommand)
    {
        hr = ((LPMSG_ADDFORWARDREPLY)pReply)->hResult;
        DPF_ERRVAL("Addforward failed: hr = 0x%08x\n",hr);

		// let handler.c continue
        goto CLEANUP_EXIT;
    }
	//
	// if it's a dx3 nameserver, the nametable will not be in the correct order
	//
	dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);
	if (DPSP_MSG_DX3VERSION == dwVersion) 
	{
		DPF(1,"name server is DX3");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	nPlayers = ((LPMSG_ENUMPLAYERSREPLY)pReply)->nPlayers;
	nGroups =  ((LPMSG_ENUMPLAYERSREPLY)pReply)->nGroups;
	
	DPF(0,"received %d players and %d groups and from name server\n",nPlayers,nGroups);

	if (dwVersion >= DPSP_MSG_SESSIONNAMETABLE)
	{
		hr = UnpackSessionDesc(this,(LPMSG_ENUMPLAYERSREPLY)pReply);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	// unpack  player list (player buffer follows enumreply message in buffer)
	this->lpsdDesc->dwCurrentPlayers = 0; // unpack will generate correct player count
	
	if (GET_MESSAGE_COMMAND((LPMSG_ENUMPLAYERSREPLY)pReply) == DPSP_MSG_SUPERENUMPLAYERSREPLY)
	{
		nShortcuts = ((LPMSG_ENUMPLAYERSREPLY)pReply)->nShortcuts;
	
		UnSuperpackPlayerAndGroupList(this,pReply+((LPMSG_ENUMPLAYERSREPLY)pReply)->dwPackedOffset,
			nPlayers,nGroups,nShortcuts,pvSPHeader);
	}
	else 
	{
		ASSERT(GET_MESSAGE_COMMAND((LPMSG_ENUMPLAYERSREPLY)pReply)== DPSP_MSG_ENUMPLAYERSREPLY);
		UnpackPlayerAndGroupList(this,pReply+((LPMSG_ENUMPLAYERSREPLY)pReply)->dwPackedOffset,
			nPlayers,nGroups,pvSPHeader);
	}

	if (this->pSysPlayer)
	{
		// execute any pending commands we may have queud
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE); // ?
		}
	}

// if we sucessfully received the name table, we have already
// set ghReplyProcessed to let handler.c run again. We do NOT
// want to set the event again or handler.c will not block the
// next time around.

CLEANUP_EXIT:
	if(pReply){
		FreeReplyBuffer(pReply);	
	}	
	
    // done
    return hr;

} // GetNameTable 

// called by InternalOpenSession
HRESULT AllocNameTable(LPDPLAYI_DPLAY this)
{
	UINT nPlayers;

	// now, alloc space for the nametable
    nPlayers =  this->lpsdDesc->dwCurrentPlayers + NAMETABLE_INITSIZE;
    
    // alloc the nametable
    this->pNameTable = DPMEM_ALLOC(nPlayers*sizeof(NAMETABLE));
    if (!this->pNameTable) 
    {
    	return E_OUTOFMEMORY;
    }
    
    this->uiNameTableSize  = nPlayers;
    DPF(0,"created name table of size %d\n",nPlayers);

	return DP_OK;

} // AllocNameTable

// todo - do we only do this on iplay1?
// put a DPSYS_CONNECTED in the apps message q
HRESULT DoConnected(LPDPLAYI_DPLAY this)
{
	LPDPMSG_GENERIC pconnected;
	LPMESSAGENODE pmsn;

	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
	if (!pmsn)
	{
		DPF_ERR("could not alloc message node!");
		return E_OUTOFMEMORY;
	}
	pconnected = DPMEM_ALLOC(sizeof(DPMSG_GENERIC));
	if (!pconnected)
	{
		DPMEM_FREE(pmsn);
		DPF_ERR("could not alloc message node!");
		return E_OUTOFMEMORY;
	}
	pconnected->dwType = DPSYS_CONNECT;
	pmsn->pNextMessage = NULL;
	pmsn->pMessage = pconnected;
	pmsn->dwMessageSize = sizeof(DPMSG_GENERIC);

	ASSERT(!this->pMessageList);
	this->pMessageList = pmsn;
	this->pLastMessage = pmsn;
	this->nMessages = 1;

	return DP_OK;

} // DoConnected

// called by internalenumsessions or internalopensession
// start our worker thread
// bKeepAlive is TRUE if we need keepalive, false if we need async enums
// if it's false, the seup was done in internalenum
HRESULT StartDPlayThread(LPDPLAYI_DPLAY this,BOOL bKeepAlive)
{
	DWORD dwThreadID;
	DPCAPS caps;
	HRESULT hr;

	if (bKeepAlive)	
	{
		// 1st, see if sp can do it
		memset(&caps,0,sizeof(caps));
		caps.dwSize = sizeof(caps);
		hr = DP_GetCaps((IDirectPlay *)this->pInterfaces,&caps,0);
		if (FAILED(hr))	
		{
			ASSERT(FALSE);
		}
		else 
		{
			// if sp does it, don't start the thread
			if (caps.dwFlags & DPCAPS_KEEPALIVEOPTIMIZED) return DP_OK;
		}
		
		// SP doesn't do it - we have to
		this->dwFlags |= DPLAYI_DPLAY_KEEPALIVE;
		this->dwLastPing = GetTickCount();
	}
	
	if (this->hDPlayThread)
	{
		// already running...just signal it that something has changed
		SetEvent(this->hDPlayThreadEvent);
		return DP_OK;
	}

	// get us a event
	this->hDPlayThreadEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
	if (!this->hDPlayThreadEvent)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);				
		DPF(0,"could not create worker thread event - err = %d\n",dwErr);
		return E_FAIL;
	}
	
	this->hDPlayThread = CreateThread(NULL,0,DPlayThreadProc,this,0,&dwThreadID);
	if (!this->hDPlayThread)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);
		DPF(0,"could not create worker thread - err = %d\n",dwErr);

		CloseHandle(this->hDPlayThreadEvent);
		this->hDPlayThreadEvent = 0;
		return E_FAIL;
	}
	
	return DP_OK;
	
} // StartDPlayThread

void StartPerf(LPDPLAYI_DPLAY this)
{
	DWORD dwThreadID;
	UINT nWantCPL;
	HRESULT hr;
	
	// 1st, see if we the user wants one
	nWantCPL = GetProfileIntA( PROF_SECT, "dxcpl", 0);
	// they must enter non-zero if they want it
	if (0 == nWantCPL)
	{
		// they don't want it
		// let's see if the dpcpl is running, just to make sure
		hr = InitMappingStuff(this);
		// if this failed, dplay cpl is not running
		if (FAILED(hr)) return ;
		// if the cpl is running, we'll talk to it
	}
	
	// get us a event
	this->hPerfEvent = CreateEventA(NULL,FALSE,FALSE,NULL);
	if (!this->hPerfEvent)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);				
		DPF(0,"could not create perf event - err = %d\n",dwErr);
		return ;
	}
	
	this->hPerfThread = CreateThread(NULL,0,PerfThreadProc,this,0,&dwThreadID);
	if (!this->hPerfThread)
	{
		DWORD dwErr = GetLastError();

		ASSERT(FALSE);
		DPF(0,"could not create perf thread - err = %d\n",dwErr);
		CloseHandle(this->hPerfEvent);
		this->hPerfEvent = 0;
		return ;
	}
	
	return ;
	
} // StartPerf

/*
 ** CopyCredentials
 *
 *  CALLED BY: InternalOpenSession()
 *
 *  PARAMETERS: pCredentialsDest - user credentials ptr (destination)
 *				pCredentialsSrc - user credentials ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies user credentials while allocating memory for username and password strings.
 *                These strings need to be freed by the calling function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopyCredentials(LPDPCREDENTIALS pCredentialsDest, 
                         LPCDPCREDENTIALS pCredentialsSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pCredentialsDest && pCredentialsSrc);

    memcpy(pCredentialsDest, pCredentialsSrc, sizeof(DPCREDENTIALS));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pCredentialsDest->lpszUsernameA), pCredentialsSrc->lpszUsername);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pCredentialsDest->lpszPasswordA), pCredentialsSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pCredentialsDest->lpszDomainA), pCredentialsSrc->lpszDomain);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pCredentialsDest->lpszUsername), pCredentialsSrc->lpszUsername);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pCredentialsDest->lpszPassword), pCredentialsSrc->lpszPassword);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pCredentialsDest->lpszDomain), pCredentialsSrc->lpszDomain);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeCredentials(pCredentialsDest, bAnsi);
    return hr;
} // CopyCredentials

HRESULT SetupSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC lpSecDesc)
{
    HRESULT hr;
    LPDPSECURITYDESC pSecDescLocal;
    LPWSTR pwszSSPIProvider=NULL,pwszCAPIProvider=NULL;
    DWORD dwCAPIProviderType,dwEncryptionAlgorithm;

    // alloc space for the security description
    pSecDescLocal = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDescLocal) 
    {
        DPF_ERR("couldn't allocate space for security desc - out of memory!");
        return DPERR_OUTOFMEMORY;
    }           

    // if app doesn't provide a security desc, setup defaults
    if (NULL == lpSecDesc)
    {
        // use default SSPI provider
        DPF(0, "No security description was provided - using defaults (NTLM and Microsoft's RSA Base Provider)");
        hr = GetString(&pwszSSPIProvider, DPLAY_DEFAULT_SECURITY_PACKAGE);
	    if (FAILED(hr))
	    {
		    DPF_ERRVAL("Failed to setup default SSPI Provider: hr = 0x%08lx", hr);
		    goto CLEANUP_EXIT;
	    }
	    // use default CAPI provider 
        // NULL means Microsoft's RSA Base Provider
	    dwCAPIProviderType = PROV_RSA_FULL; // full support
	    dwEncryptionAlgorithm = CALG_RC4;	 // stream cipher
    }
    else
    {
        // app passed in a security desc

	    // setup the SSPI provider
	    if (lpSecDesc->lpszSSPIProvider)
	    {
            DPF(0,"Using SSPI Provider: \"%ls\"", lpSecDesc->lpszSSPIProvider);
		    // copy the package name provided by application
            hr = GetString(&pwszSSPIProvider, lpSecDesc->lpszSSPIProvider);
	    }
	    else
	    {
		    // if app doesn't provide one, use the default security package
		    DPF(0, "No SSPI provider specified - using the default: %ls",DPLAY_DEFAULT_SECURITY_PACKAGE);
		    hr = GetString(&pwszSSPIProvider, DPLAY_DEFAULT_SECURITY_PACKAGE);
	    }
	    if (FAILED(hr))
	    {
		    DPF_ERRVAL("Failed to setup default SSPI Provider: hr = 0x%08lx", hr);
		    goto CLEANUP_EXIT;
	    }

	    // setup the CAPI provider
	    if (lpSecDesc->lpszCAPIProvider)
	    {
            dwCAPIProviderType = lpSecDesc->dwCAPIProviderType;
            dwEncryptionAlgorithm = lpSecDesc->dwEncryptionAlgorithm;

		    DPF(0, "Using CAPI provider: \"%ls\"",lpSecDesc->lpszCAPIProvider);

		    // copy the package name provided by application
            hr = GetString(&pwszCAPIProvider, lpSecDesc->lpszCAPIProvider);
		    if (FAILED(hr))
		    {
			    DPF_ERRVAL("Failed to setup default CAPI Provider: hr = 0x%08lx", hr);
			    goto CLEANUP_EXIT;
		    }
	    }
	    else
	    {
		    // if app doesn't provide one, use the default security package
		    DPF(0, "No CAPI provider specified - using Microsoft's RSA Base Provider");

	        // use default CAPI provider 
            // NULL means Microsoft's RSA Base Provider
	        dwCAPIProviderType = PROV_RSA_FULL; // full support
	        dwEncryptionAlgorithm = CALG_RC4;	 // stream cipher
	    }
    }

    // success

    // setup a security description
    pSecDescLocal->lpszSSPIProvider = pwszSSPIProvider;
    pSecDescLocal->lpszCAPIProvider = pwszCAPIProvider;
    pSecDescLocal->dwCAPIProviderType = dwCAPIProviderType;
    pSecDescLocal->dwEncryptionAlgorithm = dwEncryptionAlgorithm;
    pSecDescLocal->dwSize = sizeof(DPSECURITYDESC);
    pSecDescLocal->dwFlags = 0;

    // remember it in the dplay object
    this->pSecurityDesc = pSecDescLocal;

    return DP_OK;

CLEANUP_EXIT:

    if (pwszSSPIProvider) DPMEM_FREE(pwszSSPIProvider);
    if (pwszCAPIProvider) DPMEM_FREE(pwszCAPIProvider);
    if (pSecDescLocal) DPMEM_FREE(pSecDescLocal);

    return hr;
}  // SetupSecurityDesc

// find (or create) the session pointed to by lpSDesc.
// fEnumOnly means don't actually join - don't create the sysplayer...
HRESULT InternalOpenSession(LPDPLAYI_DPLAY this,LPCDPSESSIONDESC2 lpSDesc,
	BOOL fEnumOnly,DWORD dwFlags,BOOL fStuffInstanceGUID, 
    LPCDPSECURITYDESC lpSecDesc,LPCDPCREDENTIALS lpCredentials)
{
	HRESULT hr = DP_OK;
    BOOL bNameSrvr = FALSE;
    DWORD dwPlayerFlags; // flags for our system player
    LPDPSESSIONDESC2 lpLocalDesc=NULL;
	DPSP_OPENDATA opd;
	BOOL bCreate;
	LPSESSIONLIST pSession;
    DWORD dwServerVersion=0;
	BOOL bReturnStatus; // true to override dialogs and return status
	DPCAPS dpCaps;


	DPF(5, "InternalOpenSession: Parameters: (0x%x, 0x%x, %i, 0x%x, %i, 0x%x, 0x%x)",
		this, lpSDesc, fEnumOnly, dwFlags, fStuffInstanceGUID, lpSecDesc, lpCredentials);

	this->fDidVoiceClose = FALSE;

    //
	//
	// alloc space for the game description. if we create a game, we
	// use the passsed sessiondesc. if we join a game, we use the session
	// desc that enum stored for us.
    lpLocalDesc = DPMEM_ALLOC(sizeof(DPSESSIONDESC2));
    if (!lpLocalDesc) 
    {
    	DPF_ERR("open session - out of memory!");
        return E_OUTOFMEMORY;
    }

	// flags for the sysplayer
    dwPlayerFlags = DPLAYI_PLAYER_SYSPLAYER | DPLAYI_PLAYER_PLAYERLOCAL;

	// app can request that the SP not display any status
	// dialogs while opening by setting this flag. The SP
	// will return status codes while open is in progress

	bReturnStatus = (dwFlags & DPOPEN_RETURNSTATUS) ? TRUE : FALSE; 

	// 
	// get the session desc
    if (dwFlags & DPOPEN_JOIN) 
    {
		bCreate = FALSE;
		
		// find the matching session...
		pSession = FindSessionInSessionList(this,&(lpSDesc->guidInstance));	
		if (!pSession) 
		{
			DPF_ERR("could not find matching session to open");
            hr = DPERR_NOSESSIONS;
            goto CLEANUP_EXIT;
		}

    	DPF(0,"Remote dplay version %x\n",pSession->dwVersion);
	    this->dwServerPlayerVersion = pSession->dwVersion;

        if (pSession->dpDesc.dwFlags & DPSESSION_SECURESERVER)
        {
            //joining a secure session

            //do not allow enumeration on a remote session without authentication
            if (fEnumOnly)
            {
                DPF(0, "Can't enumerate a secure session without logging in");
                hr = DPERR_ACCESSDENIED;
                goto CLEANUP_EXIT;
            }
        }
        else
        {
            // joining an unsecure session
            if (lpSecDesc)
            {
                DPF_ERR("Passed security description while joining an unsecure session");
                hr = DPERR_INVALIDPARAMS;
                goto CLEANUP_EXIT;
            }
            if (lpCredentials)
            {
                DPF_ERR("Passed credentials while joining an unsecure session");
                hr = DPERR_INVALIDPARAMS;
                goto CLEANUP_EXIT;
            }
        }

        // if session we are trying to join is password protected
        if (pSession->dpDesc.dwFlags & DPSESSION_PASSWORDREQUIRED)
        {
            // do not allow enumeration of players without joining
            if (fEnumOnly)
            {
			    DPF(0,"session requires a password - join session before enumerating players\n");
                hr = DPERR_ACCESSDENIED;
                goto CLEANUP_EXIT;
            }
        }

        // check if the session is available to join
	    if ((pSession->dpDesc.dwFlags & DPSESSION_NEWPLAYERSDISABLED) ||
            (pSession->dpDesc.dwFlags & DPSESSION_JOINDISABLED))
        {
			DPF(0,"session is not allowing players to join\n");
            hr = DPERR_NONEWPLAYERS;
            goto CLEANUP_EXIT;
        }
	    
		// make sure we haven't reached the maximum number of players in
		// the session, unless we are just enum'ing, then let it join anyway
		if ((!fEnumOnly) && (pSession->dpDesc.dwMaxPlayers && 
           (pSession->dpDesc.dwCurrentPlayers >= pSession->dpDesc.dwMaxPlayers)))
		{
			DPF_ERR("Session already contains the maximum number of players");
			hr = DPERR_NONEWPLAYERS;
			goto CLEANUP_EXIT;
		}

        // initialize security, if we are joining a secure session, unless the SP
		// (or LP) is handling the security, in which case we can skip this
        if((pSession->dpDesc.dwFlags & DPSESSION_SECURESERVER) &&
			(!(this->dwFlags & DPLAYI_DPLAY_SPSECURITY)))
        {
            // initialize security
            hr = InitSecurity(this);
            if (FAILED(hr))
            {
                DPF(0, "Failed to initialize SSPI: hr = 0x%08lx", hr);
                goto CLEANUP_EXIT;
            }
        }
        
	    memcpy(lpLocalDesc,&(pSession->dpDesc),sizeof(DPSESSIONDESC2));

		// copy over the strings from the session desc supplied by the namesrvr
		GetString(&(lpLocalDesc->lpszSessionName),pSession->dpDesc.lpszSessionName);
		GetString(&(lpLocalDesc->lpszPassword),pSession->dpDesc.lpszPassword);
    }
	else
    {    	
	    this->dwServerPlayerVersion = DPSP_MSG_VERSION;
        // if we are creating a secure server
        if (lpSDesc->dwFlags & DPSESSION_SECURESERVER)
        {
			if(lpSDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL){
				DPF(0, "Tried to run protocol on secure session, not allowed, returning INVALIDFLAGS\n");
				hr=DPERR_INVALIDFLAGS;
				goto CLEANUP_EXIT;
			}
			
            // initialize security
            hr = InitSecurity(this);
            if (FAILED(hr))
            {
                DPF(0, "Failed to initialize SSPI hr = 0x%08lx", hr);
                goto CLEANUP_EXIT;
            }

            // we shouldn't have security desc yet
            ASSERT(!this->pSecurityDesc);

            // setup security description
            hr = SetupSecurityDesc(this, lpSecDesc);
            if (FAILED(hr))
            {
                DPF_ERRVAL("Failed to setup security description: hr=0x%08x",hr);
                goto CLEANUP_EXIT;
            }
        }

		// create a session.
		// copy the passed desc, and create a name server
		bCreate = TRUE;

		ASSERT(DPOPEN_CREATE & dwFlags);
	    memcpy(lpLocalDesc,lpSDesc,sizeof(DPSESSIONDESC2));

		// a-josbor: see if the WIN.INI file tells us to force the protocol on
		if (!(lpLocalDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL))
		{
		    if (GetProfileIntA( "DirectPlay", "Protocol", 0 ) == 1)
		    {
	            DPF(0, "Warning!  DirectProtocol turned ON by WIN.INI setting\n");
		    	lpLocalDesc->dwFlags |= DPSESSION_DIRECTPLAYPROTOCOL;
		    	bForceDGAsync=TRUE;
		    }
		}
		
        // init session desc properly
        lpLocalDesc->dwCurrentPlayers = 0;

    	dwPlayerFlags |= DPLAYI_PLAYER_NAMESRVR;

		// get a guid for this session
		// if we're stuffing the guid (called by dpconnect) then leave
		// the guid alone
		if (!fStuffInstanceGUID) OS_CreateGuid(&(lpLocalDesc->guidInstance));

		// copy over the strings from the session desc supplied by the user	
		GetString(&(lpLocalDesc->lpszSessionName),lpSDesc->lpszSessionName);
		GetString(&(lpLocalDesc->lpszPassword),lpSDesc->lpszPassword);

		// set up the player id xor key
		// the tick count serves as a pretty good randomizer
		lpLocalDesc->dwReserved1 = GetTickCount();
        // initialize the reserved fields
        lpLocalDesc->dwReserved2 = 0;
        // if session has a password, setup the PASSWORDREQUIRED flag in the session desc 
		// treat zero-length string like a NULL password to be compatible with
		// the behavior of DX3
        if ((lpSDesc->lpszPassword) &&
			(WSTRLEN(lpSDesc->lpszPassword) > 1))
        {
            lpLocalDesc->dwFlags |= DPSESSION_PASSWORDREQUIRED;
        }
		// if session is secure, use multicast
		if (lpSDesc->dwFlags & DPSESSION_SECURESERVER)
		{
			DPF(0,"Session is secure - enabling multicast");
			lpLocalDesc->dwFlags |= DPSESSION_MULTICASTSERVER;
		}
		
    } // create
		
    if (lpCredentials)
    {
        // app passed in user credentials - remember them in the dplay object
        // so we can use them while acquiring the credentials handle (after getting 
        // the package name from the server)
        ASSERT(!this->pUserCredentials);

        // allocate memory for storing credentials
        this->pUserCredentials = DPMEM_ALLOC(sizeof(DPCREDENTIALS));
        if (!this->pUserCredentials)
        {
            DPF_ERR("Failed to allocate credentials structure - out of memory!");
            hr = DPERR_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
        // remember the user credentials in the directplay object
        hr = CopyCredentials(this->pUserCredentials,lpCredentials, FALSE);                
        if (FAILED(hr))
        {
            DPF_ERRVAL("Couldn't store credentials: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }
    }

	// we  should not have a session desc yet!
	ASSERT(!this->lpsdDesc);

	// If this is a lobby-owned object, call the lobby here
	if(IS_LOBBY_OWNED(this))
	{
		// Drop the lock so the lobby's receive thread can get back in
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Open a session to the lobby
		hr = PRV_Open(this->lpLobbyObject, lpLocalDesc, dwFlags, lpCredentials);
		// Take the lock back
		ENTER_DPLAY();
		
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed to Open lobby session, hr = 0x%08x", hr);
			goto CLEANUP_EXIT;
		}
	}

	// store the new session desc
    this->lpsdDesc =lpLocalDesc;
	// fixup protocol flags
	if(lpLocalDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL){
		this->dwFlags |= DPLAYI_DPLAY_PROTOCOL;
		DPF(0,">>>RUNNING WITH DIRECTPROTOCOL<<<\n");
	}
	if(lpLocalDesc->dwFlags & DPSESSION_NOPRESERVEORDER){
		this->dwFlags |= DPLAYI_DPLAY_PROTOCOLNOORDER;
	}

    if (this->pcbSPCallbacks->Open) 
    {
		opd.bCreate = bCreate;
		if (bCreate)
		{
			opd.lpSPMessageHeader = NULL;
		}
		else 
		{
			opd.lpSPMessageHeader = pSession->pvSPMessageData;
		}
		
		opd.lpISP = this->pISP;
		opd.bReturnStatus = bReturnStatus;
		opd.dwOpenFlags = dwFlags;
		opd.dwSessionFlags = this->lpsdDesc->dwFlags;
		
	    hr = CALLSP(this->pcbSPCallbacks->Open,&opd);	    	
	    if (FAILED(hr)) 
	    {
			DPF(0,"Open session callback failed - hr = 0x%08lx\n",hr);
            goto CLEANUP_EXIT;
	    }
    }
	else 
	{
		// no callback - no biggie
	}

	// Get Caps so we can tell if we need the protocol.

    ZeroMemory(&dpCaps,sizeof(dpCaps));
    dpCaps.dwSize = sizeof(dpCaps);
	hr=InternalGetCaps((LPDIRECTPLAY)this->pInterfaces,0, &dpCaps,FALSE,0);
    if (SUCCEEDED(hr) && !(dpCaps.dwFlags & DPCAPS_GUARANTEEDOPTIMIZED)){
		this->dwFlags |= DPLAYI_DPLAY_SPUNRELIABLE;
	}

	if(this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE | DPLAYI_DPLAY_PROTOCOL)){
	
		hr=InitPacketize(this);
		if(FAILED(hr)){
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
	}
	
	if(this->dwFlags & DPLAYI_DPLAY_PROTOCOL){

		// Initialize Dplay's reliable protocol on the interface.
		hr=InitProtocol(this);
		if(FAILED(hr)){
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}

		// Get message sizes (again) since different with protocol running.
		hr=GetMaxMessageSize(this);
	    if (FAILED(hr))
	    {
	    	DPF_ERRVAL("Failed to get message sizes with protocol running hr=%08x\n",hr);
	        ASSERT(FALSE);
	        goto CLEANUP_EXIT;
	    }

	} 

	// alloc the nametable
	hr = AllocNameTable(this);
    if (FAILED(hr)) 
    {
		DPF(0,"Open session callback failed - hr = 0x%08lx\n",hr);
		// since we've succeeded sp's open call, shut down the session
        goto CLOSESESSION_EXIT;
    }

	// get the system player
	if (!fEnumOnly)
	{
		// we're actually joining this session
		hr = CreateSystemPlayer(this,dwPlayerFlags,lpSDesc->lpszPassword);
		if (FAILED(hr))
		{
			DPF_ERR("could not get system player");
            goto CLOSESESSION_EXIT;
		}

		// If we're a lobby object, we can skip everything that follows because it
		// has either already been done, or doesn't apply to lobbies.
		if(IS_LOBBY_OWNED(this))
			return hr;

        // setup credentials for the system player
        if ((DPOPEN_CREATE & dwFlags) && (lpSDesc->dwFlags & DPSESSION_SECURESERVER))
        {
			hr = LoadSecurityProviders(this,SSPI_SERVER);
            if (FAILED(hr))
            {
                DPF_ERR("Failed to setup credentials");
                goto CLOSESESSION_EXIT;
            }
        }

		// put a DPSYS_CONNECT in the apps queue
		// we do this only for mech, since mech needs it
		// (but it breaks doom ii, so we can't do it always)
		if (gbMech) hr = DoConnected(this);

		// stop the enum thread
		if (this->dwFlags & DPLAYI_DPLAY_ENUM)	
		{
			StopEnumThread(this);
		}

		// a-josbor: if we're the nameserver start the DPLAY thread.  That's where we
		// clean up the reservation list
		// also start it up if we're using keepalives
		if ((this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE)
			|| (IAM_NAMESERVER(this)))
		{
			StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
		}
		
		// start up the perf thread
		StartPerf(this);
		
	}

	//
    // get the name table
    // need to get the list of players from the name server
   	if (!(dwPlayerFlags & DPLAYI_PLAYER_NAMESRVR))
   	{
        ASSERT(pSession);
        // pass the name server's version so we don't send an enumplayers message
        // if it is dx5 or later
        hr = GetNameTable(this, pSession->dwVersion, fEnumOnly);	
		if (FAILED(hr)) 
		{
			DPF_ERR("could not download name table!");
            goto CLOSESESSION_EXIT;
		}
   	}

    // cleanup credentials - we don't want them hanging in our dplay object
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }

	DPF(8, "GetSPPlayerData: Returning DP_OK");

    // success
	return DP_OK;

    // if we reach here, we have allocated a session and perhaps initialized this->lpsdDesc
CLEANUP_EXIT:
    FreeDesc(lpLocalDesc, FALSE);
    DPMEM_FREE(lpLocalDesc);
    
    this->lpsdDesc = NULL;
    if (this->pUserCredentials)
    {
        FreeCredentials(this->pUserCredentials,FALSE);
        DPMEM_FREE(this->pUserCredentials);
        this->pUserCredentials = NULL;
    }
    if(this->pProtocol){
    	FiniProtocol(this->pProtocol);
    	this->pProtocol=NULL;
    }
    if(this->hRetryThread){
    	this->dwFlags |= DPLAYI_DPLAY_CLOSED;
    	KillThread(this->hRetryThread, this->hRetry);
    	this->hRetryThread=0;
    	FiniPacketize(this);
    	this->dwFlags &= ~DPLAYI_DPLAY_CLOSED;
    }
    
	DPF(8, "GetSPPlayerData: Returning (cleanup exit) [0x%lx]", hr);
	
    return hr;

    // if we reach here, sp's open call was successfull
CLOSESESSION_EXIT:
    LEAVE_ALL();
    DP_Close((IDirectPlay *)this->pInterfaces);
    ENTER_ALL();
    
	DPF(8, "GetSPPlayerData: Returning (closesession exit) [0x%lx]", hr);
	
    return hr;

} // InternalOpenSession

// assumes it is being called in a TRY block
HRESULT ValidateOpenParams(LPDPLAYI_DPLAY this, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags)
{
    HRESULT hr;
    DPCAPS dpCaps;

    if (!VALID_READ_DPSESSIONDESC2(lpsdDesc)) 
    {
  		DPF_ERR("invalid session desc");
        return DPERR_INVALIDPARAMS;
    }

	if (!VALID_OPEN_FLAGS(dwFlags))
	{
  		DPF_ERR("invalid flags");
        return DPERR_INVALIDPARAMS;
	}

	// REVIEW NOTE: DX3 did not check for invalid flags in the session desc.
	// Therefore, apps may have been passing in garbage here and we would
	// not have caught it. Now we are checking to make sure the flags are valid.
	// This could cause a regression, since we will fail now where we did not before.

	if (!VALID_DPSESSIONDESC2_FLAGS(lpsdDesc->dwFlags))
	{
  		DPF_ERRVAL("invalid flags (0x%08x) in session desc!",lpsdDesc->dwFlags);
		ASSERT(FALSE);				// assert so we pay attention!
        return DPERR_INVALIDFLAGS;
	}
	
    // don't allow nameserver migration with 
    // DPSESSION_SECURESERVER or DPSESSION_CLIENTSERVER	or DPSESSION_MULTICASTSERVER
    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
	    DPF_ERR("Can't set host migration on a secure server");
	    return DPERR_INVALIDFLAGS;
    }

    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER))
    {
	    DPF_ERR("Can't set host migration on client server");
	    return DPERR_INVALIDFLAGS;
    }

    if ((lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) && 
        (lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER))
    {
	    DPF_ERR("Can't set host migration on multicast server");
	    return DPERR_INVALIDFLAGS;
    }

	if ((lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) && 
		(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
	{
		DPF(0,"Warning! Player messages sent secure will contain headers");
	}

	if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
		WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}
	if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
		WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
	{
	    DPF_ERR( "bad string pointer" );
	    return DPERR_INVALIDPARAMS;
	}

    if ((dwFlags & DPOPEN_CREATE) && (lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
        // dplay security is only available if sp supports reliable communication
        ZeroMemory(&dpCaps,sizeof(dpCaps));
        dpCaps.dwSize = sizeof(dpCaps);
	    hr = InternalGetCaps((LPDIRECTPLAY)this->pInterfaces,0, &dpCaps,FALSE,0);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get caps: hr=0x%08x",hr);
            return hr;
        }
        if (!(dpCaps.dwFlags & DPCAPS_GUARANTEEDSUPPORTED))
        {
            DPF_ERR("Can't host a secure session - sp doesn't support reliable messages");
            return DPERR_UNSUPPORTED;
        }
    }

    // all params are ok
    return DP_OK;
}

// In DX3 the list of sessions was stored in a global list.
// In DX5, the list is stored with the DirectPlay object.
//
// This means if a DX3 app did an EnumSessions() on one object
// and then Open(JOIN) on a different object, the session list would
// be preserved between objects and the join would work.
//
// On DX5 this would fail since the session list was not preserved.
//
// We found one DX3 game (X-Wing vs. Tie Fighter) that was depending on
// this - there may be more. The fix was to simply EnumSessions again
// until the requested session was found.

#define FILE_NAME_SIZE	256

BOOL XWingHack(LPDPLAYI_DPLAY this, LPDPSESSIONDESC2 lpsdDesc)
{
	DPLCONNECTION	connect;
	char			lpszFileName[FILE_NAME_SIZE];
	char			lpszXWing[] = "z_xvt__.exe";
	char			*lpszCheck;
	HRESULT			hr;

	// get path name of app we are running
	if (!GetModuleFileNameA(NULL,lpszFileName,FILE_NAME_SIZE)) 
		return (FALSE);

	// make sure string is big enough
	if (STRLEN(lpszFileName) < STRLEN(lpszXWing))
		return (FALSE);

	// match app name against characters at end of path name
	lpszCheck = lpszFileName + STRLEN(lpszFileName) - STRLEN(lpszXWing);

	LowerCase(lpszCheck);

	// bail if name does not match
	if (0 != strcmp(lpszCheck, lpszXWing))
		return (FALSE);

	DPF(1,"Found X-Wing!!!");

	memset(&connect, 0, sizeof(DPLCONNECTION));
	connect.lpSessionDesc = lpsdDesc;

	// get this session instance into the session list if it takes all night
	DPF(1,"Re-aquiring session...");
	hr = ConnectFindSession(this, &connect);

	if FAILED(hr)
		return (FALSE);
	else
		return (TRUE);
}

HRESULT DPAPI DP_Open(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags ) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }

	    if (this->lpsdDesc)
	    {
			LEAVE_ALL();
		    DPF_ERR("session already open!");
		    return DPERR_ALREADYINITIALIZED;
	    }

        // parameter validation
        hr = ValidateOpenParams(this, lpsdDesc, dwFlags);
        if (FAILED(hr))
        {
		    LEAVE_ALL();
	        return hr;
        }
    }

    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
		LEAVE_ALL();
        return DPERR_INVALIDPARAMS;
    }			        

	hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,NULL,NULL);

	// this is a hack to make X-Wing vs. Tie Fighter work
	// it will go out on the network, find the specified session
	// and add it to the session list.
	if ((DPERR_NOSESSIONS == hr) && (XWingHack(this, lpsdDesc)))
	{
		hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,NULL,NULL);
	}

	LEAVE_ALL();
    return hr;
        
}//DP_Open

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Receive"

// we've just copied our private pmsg over to users pvBuffer
// if it was a system message, we need to fix up our pointers
void FixUpPointers(LPVOID pvBuffer)  
{
	DWORD dwType;
	UINT nShortLen=0,nLongLen=0;
	LPBYTE pBufferIndex;

	dwType = ((LPDPMSG_GENERIC)pvBuffer)->dwType;

	switch (dwType)
	{
		case DPSYS_CREATEPLAYERORGROUP:
			{
				LPDPMSG_CREATEPLAYERORGROUP pmsg = (LPDPMSG_CREATEPLAYERORGROUP)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_CREATEPLAYERORGROUP);

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
				// now, lpData - follows strings
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}

			}		
			break;

		case DPSYS_SETPLAYERORGROUPDATA:
			{
				
				LPDPMSG_SETPLAYERORGROUPDATA pmsg = (LPDPMSG_SETPLAYERORGROUPDATA)pvBuffer;
				 				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPDATA);

				// data follows msg
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}


			}
			break;
			
		case DPSYS_SETPLAYERORGROUPNAME:
			{
				LPDPMSG_SETPLAYERORGROUPNAME pmsg = (LPDPMSG_SETPLAYERORGROUPNAME)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETPLAYERORGROUPNAME);

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
			}
			break;

		case DPSYS_DESTROYPLAYERORGROUP:	
			{
				LPDPMSG_DESTROYPLAYERORGROUP pmsg = (LPDPMSG_DESTROYPLAYERORGROUP)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_DESTROYPLAYERORGROUP);

				// fix up local data pointer
				if (pmsg->lpLocalData)
				{
					pmsg->lpLocalData = pBufferIndex;
					pBufferIndex += pmsg->dwLocalDataSize;
				}
				// fix up remote data pointer
				if (pmsg->lpRemoteData)
				{
					pmsg->lpRemoteData = pBufferIndex;
					pBufferIndex += pmsg->dwRemoteDataSize;
				}

				nShortLen = WSTRLEN_BYTES(pmsg->dpnName.lpszShortName);
				nLongLen = WSTRLEN_BYTES(pmsg->dpnName.lpszLongName);

				// fix up string pointers - strings follow msg
				if (nShortLen)
				{
					pmsg->dpnName.lpszShortName = (LPWSTR)pBufferIndex;
					pBufferIndex += nShortLen;
				}
				if (nLongLen)
				{
					pmsg->dpnName.lpszLongName = (LPWSTR)pBufferIndex;
					pBufferIndex += nLongLen;
				}
				
			}
			break;

		case DPSYS_SETSESSIONDESC:
			{
                UINT nSessionNameLen, nPasswordLen;
				LPDPMSG_SETSESSIONDESC pmsg = (LPDPMSG_SETSESSIONDESC)pvBuffer;
				
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SETSESSIONDESC);

				nSessionNameLen = WSTRLEN_BYTES(pmsg->dpDesc.lpszSessionName);
				nPasswordLen = WSTRLEN_BYTES(pmsg->dpDesc.lpszPassword);

				// fix up string pointers - strings follow msg
				if (nSessionNameLen)
				{
					pmsg->dpDesc.lpszSessionName = (LPWSTR)pBufferIndex;
					pBufferIndex += nSessionNameLen;
				}
				if (nPasswordLen)
				{
					pmsg->dpDesc.lpszPassword = (LPWSTR)pBufferIndex;
				}
			}
			break;

        case DPSYS_SECUREMESSAGE:
            {
                LPDPMSG_SECUREMESSAGE pmsg = (LPDPMSG_SECUREMESSAGE)pvBuffer;

                // fix up data pointer
				pBufferIndex = (LPBYTE)pmsg + sizeof(DPMSG_SECUREMESSAGE);

				// data follows msg
				if (pmsg->lpData)
				{
					pmsg->lpData = pBufferIndex;
				}
            }
            break;

		case DPSYS_STARTSESSION:
			{
				LPDPMSG_STARTSESSION	pmsg = (LPDPMSG_STARTSESSION)pvBuffer;

				// First fix up the DPLCONNECTION pointer itself
				pmsg->lpConn = (LPDPLCONNECTION)((LPBYTE)pmsg +
								sizeof(DPMSG_STARTSESSION));
				
				// Call the function in the lobby which does this
				PRV_FixupDPLCONNECTIONPointers(pmsg->lpConn);
			}
			break;
		
		case DPSYS_CHAT:
			{
				LPDPMSG_CHAT	pmsg = (LPDPMSG_CHAT)pvBuffer;

				pmsg->lpChat = (LPDPCHAT)((LPBYTE)pmsg + sizeof(DPMSG_CHAT));
				pmsg->lpChat->lpszMessage = (LPWSTR)((LPBYTE)pmsg + sizeof(DPMSG_CHAT) +
						sizeof(DPCHAT));
			}
			break;

		default:
			// no ptrs to fix up...
			break;
	} // switch

	return ;
	
} // FixUpPointers

// if its an addlayer message, return size of dplay 10 add player message
DWORD OldMessageSize(LPMESSAGENODE pmsg)
{
	DWORD dwType;

	dwType = ((LPDPMSG_GENERIC)(pmsg->pMessage))->dwType;

	if (DPSYS_ADDPLAYER == dwType)
	{
		// make sure we tell the app to alloc enough space for the larger of the
		// addplayer1 and the addplayer2
		if (pmsg->dwMessageSize < sizeof(DPMSG_ADDPLAYER)) return sizeof(DPMSG_ADDPLAYER);
		else return pmsg->dwMessageSize;
	}
	// else
	return pmsg->dwMessageSize;
} // OldMessageSize

// called by dp_1_receive,dp_a_receive, dp_receive
// dwCaller is RECEIVE_2,RECEIVE_2A, or RECEIVE_1 depending on who called 
// us
HRESULT InternalReceive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
                LPVOID pvBuffer,LPDWORD pdwSize,DWORD dwCaller	) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	LPMESSAGENODE pmsg,pmsgPrev=NULL;
	DWORD dwActualSize; // message size may be adjusted if
						// it's a 1.0 system message
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		if  ((!pidTo) || (!VALID_ID_PTR(pidTo)))
		{
	        DPF_ERR( "Bad pidTo" );
	        return DPERR_INVALIDPARAMS;
		}

		if ((!pidFrom) || (!VALID_ID_PTR(pidFrom)))
		{
	        DPF_ERR( "Bad pidFrom" );
	        return DPERR_INVALIDPARAMS;
		}

		if (!VALID_RECEIVE_FLAGS(dwFlags))
		{
	        DPF_ERR( "invalid flags" );
	        return DPERR_INVALIDFLAGS;
		}

		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;
		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	pmsgPrev = NULL;
	pmsg = this->pMessageList; //  1st message

	// check for a match to or from a specific player
	if (dwFlags & (DPRECEIVE_TOPLAYER | DPRECEIVE_FROMPLAYER))
	{
		// loop over all the messages in the queue
		while (pmsg)
		{
			// both "to" and "from" must match
			if ((dwFlags & DPRECEIVE_TOPLAYER) &&
				(dwFlags & DPRECEIVE_FROMPLAYER))
			{
				// make sure both id's match
				if ((pmsg->idTo == *pidTo) &&
					(pmsg->idFrom == *pidFrom))
				{
					break;
				}
			}

			// just "to" has to match
			else if (dwFlags & DPRECEIVE_TOPLAYER)
			{
				// make sure "to" id's match
				if (pmsg->idTo == *pidTo)
				{
					break;
				}
			}

			// just "from" has to match
			else if (dwFlags & DPRECEIVE_FROMPLAYER)
			{
				// make sure "from" id's match
				if (pmsg->idFrom == *pidFrom)
				{
					break;
				}
			}

			// no match found, so go to next message
			pmsgPrev = pmsg;
			pmsg = pmsg->pNextMessage;
		}
	}

	// there are no messages for us
	if (!pmsg) 
	{
		return DPERR_NOMESSAGES;
	}
   
	// if it's 1.0, we may need to resize 
	if ((dwCaller == RECEIVE_1) && (0 == pmsg->idFrom))
	{
		dwActualSize = OldMessageSize(pmsg);
	}
	else 
	{
		dwActualSize = pmsg->dwMessageSize;
	}
	// see if the apps buffer is big enough
	if (*pdwSize < dwActualSize)
	{
		*pdwSize = dwActualSize;		// tell app how much is needed
		return DPERR_BUFFERTOOSMALL;
	}

	// copy the buffer over
	memcpy((LPBYTE *)pvBuffer,pmsg->pMessage,pmsg->dwMessageSize);
	*pdwSize = pmsg->dwMessageSize;
	*pidTo = pmsg->idTo;
	*pidFrom = pmsg->idFrom;

	DPF(5,"player id %d received message from player id %d\n",*pidTo,*pidFrom);

	if (0 == *pidFrom)
	{
		FixUpPointers(pvBuffer);
	}
	// remove message (unless its a peek)
	if (!(dwFlags & DPRECEIVE_PEEK))
	{
		if (!pmsgPrev) 
		{
			// 1st message on list
			this->pMessageList = pmsg->pNextMessage;
		} else {
			// not 1st message on list
			pmsgPrev->pNextMessage = pmsg->pNextMessage;
		}	
		
		if(pmsg == this->pLastMessage){
			this->pLastMessage = pmsgPrev;
		}

		FreeMessageNode(this, pmsg);
	}

    return hr;
        
}// InternalReceive


HRESULT DPAPI DP_Receive(LPDIRECTPLAY lpDP, LPDPID pidFrom,LPDPID pidTo,DWORD dwFlags,
                LPVOID pvBuffer,LPDWORD pdwSize	) 
{
	HRESULT hr;
	
	ENTER_DPLAY();
	
	hr = InternalReceive(lpDP, pidFrom,pidTo,dwFlags,pvBuffer,pdwSize,RECEIVE_2);
		
	LEAVE_DPLAY();
	
	return hr;
			
}//DP_Receive

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommonSendParms"

__inline HRESULT ValidateCommonSendParms(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
                LPVOID pvBuffer,DWORD dwBufSize,LPDPLAYI_PLAYER *ppPlayerFrom,
                LPDPLAYI_PLAYER *ppPlayerTo, LPDPLAYI_GROUP *ppGroupTo, BOOL *pbToPlayer)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// check src player        
		*ppPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(*ppPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			return DPERR_INVALIDPLAYER;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			*ppPlayerTo = PlayerFromID(this,idTo);
			if (VALID_DPLAY_PLAYER(*ppPlayerTo)) 
			{		  
				*pbToPlayer = TRUE;
			}
			else 
			{
				*ppGroupTo = GroupFromID(this,idTo);
				if (VALID_DPLAY_GROUP(*ppGroupTo)) 
				{
					*pbToPlayer = FALSE;
				}
				else 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					return DPERR_INVALIDPARAMS;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if (!VALID_SEND_FLAGS(dwFlags))
		{
			DPF_ERR("bad dwFlags");
            return DPERR_INVALIDPARAMS;
		}

		if((dwFlags & DPSEND_ASYNC)){
			DPF_ERR("trying async send on old send api");
			return DPERR_UNSUPPORTED;
		}

        if ((dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            // secure messages can only be sent in a secure session
            if (!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
			    DPF_ERR("Can't send a secure message - session is not secure");
                return DPERR_INVALIDPARAMS;
            }

            // secure message can only be sent reliable
            if (!(dwFlags & DPSEND_GUARANTEED))
            {
			    DPF_ERR("Can't send a secure message - message is not reliable");
                return DPERR_INVALIDPARAMS;
            }
        }

		// check the buffer
		if (!VALID_READ_STRING_PTR(pvBuffer,dwBufSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (0 == dwBufSize)
		{
			DPF_ERR("invalid buffer size");
			return DPERR_INVALIDPARAMS;			
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        return DPERR_INVALIDPARAMS;
    }

	// if player from is not local, and i am not the nameserver in a multicast 
	// session, the send is no good
	ASSERT(this->lpsdDesc);	   
	if ( !((*ppPlayerFrom)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		!((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) && IAM_NAMESERVER(this)) )
	{
		DPF_ERR("attempt to send from non-local player");
		return DPERR_ACCESSDENIED;
	}
	
	if (dwFlags & DPSEND_GUARANTEED ) DPF(7,"sending DPSEND_GUARANTEED");

    // if encryption was requested, check if support is available
    if ((dwFlags & DPSEND_ENCRYPTED) && !(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
    {
        DPF_ERR("Encryption is not supported");
        return DPERR_ENCRYPTIONNOTSUPPORTED;
    }

    // If a client is trying to send a secure message, make sure they have logged in
    if ((dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)) && !IAM_NAMESERVER(this))
    {
        if (DPLOGIN_SUCCESS != this->LoginState)
        {
            DPF_ERR("Client hasn't logged in yet");
            return DPERR_NOTLOGGEDIN;
        }
    }
    
    return DP_OK;
}

#undef DPF_MODNAME
#define DPF_MODNAME "DP_Send"
HRESULT DPAPI DP_Send(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,
                LPVOID pvBuffer,DWORD dwBufSize	) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP pGroupTo; 
    LPDPLAYI_PLAYER pPlayerTo,pPlayerFrom;
	BOOL bToPlayer= FALSE;

	ENTER_ALL();

	hr=ValidateCommonSendParms(lpDP, idFrom, idTo, dwFlags, pvBuffer, dwBufSize,
							   &pPlayerFrom, &pPlayerTo, &pGroupTo, &bToPlayer);

	if(FAILED(hr)){
		LEAVE_ALL();
		return hr;
	}

    this = DPLAY_FROM_INT(lpDP);
	
	DPF(9,"sending message from %d to %d\n",idFrom,idTo);

	// If this object is lobby-owned, pass the message off to it here
	// since it will do all the server stuff
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_Send(this->lpLobbyObject, idFrom, idTo, dwFlags,
						pvBuffer, dwBufSize);
		// Since the lobby already sent the message, we can just return
		// from here.
		LEAVE_ALL();
		return hr;
	}

	// do the send
	if (bToPlayer)
	{
		hr = SendPlayerMessage( this, pPlayerFrom, pPlayerTo, dwFlags, pvBuffer, 
			dwBufSize);
	}
	else 
	{
		// send to group
		hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwFlags,pvBuffer,
				dwBufSize,TRUE);
	}

	if (FAILED(hr)) DPF(0," send failed - hr = 0x%08lx\n",hr);

	LEAVE_ALL();
    return hr;
        
}//DP_Send

#undef DPF_MODNAME
#define DPF_MODNAME "ValidateCommonSendParms"

__inline HRESULT ValidateCommonSendParmsEx(LPDIRECTPLAY lpDP, LPSENDPARMS psp)
{
    LPDPLAYI_DPLAY this;
	HRESULT hr;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

		// check src player        
		psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
		if (!VALID_DPLAY_PLAYER(psp->pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr=DPERR_INVALIDPLAYER;
    		goto ERROR_EXIT;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			psp->pPlayerTo = PlayerFromID(this,psp->idTo);
			if (VALID_DPLAY_PLAYER(psp->pPlayerTo)) 
			{		  
				psp->pGroupTo = NULL;
			}
			else 
			{
				psp->pGroupTo = GroupFromID(this,psp->idTo);
				if (VALID_DPLAY_GROUP(psp->pGroupTo)) 
				{
					psp->pPlayerTo = NULL;
				}
				else 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					hr=DPERR_INVALIDPLAYER;
		    		goto ERROR_EXIT;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if (!VALID_SEND_FLAGS(psp->dwFlags))
		{
			DPF_ERR("bad dwFlags");
			hr=DPERR_INVALIDFLAGS;
    		goto ERROR_EXIT;
		}

		if((psp->dwFlags & DPSEND_ASYNC) && !(this->dwSPFlags & DPCAPS_ASYNCSUPPORTED)){
			DPF_ERR("trying async send when not supported");
			return DPERR_UNSUPPORTED;
		}

        if ((psp->dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            // secure messages can only be sent in a secure session
            if (!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
			    DPF_ERR("Can't send a secure message - session is not secure");
			    hr=DPERR_INVALIDFLAGS;
	    		goto ERROR_EXIT;
            }

            // secure message can only be sent reliable
            if (!(psp->dwFlags & DPSEND_GUARANTEED))
            {
			    DPF_ERR("Can't send a secure message - message is not reliable");
			    hr=DPERR_INVALIDFLAGS;
	    		goto ERROR_EXIT;
            }
        }

		// check the buffer
		if (!VALID_READ_STRING_PTR(psp->lpData,psp->dwDataSize))
		{
	        DPF_ERR( "bad buffer pointer" );
    		goto INVALID_PARMS_EXIT;
		}

		if(!VALID_DWORD_PTR(psp->lpdwMsgID)){
			DPF_ERR( "bad message id pointer\n");
    		goto INVALID_PARMS_EXIT;
		}

		if (0 == psp->dwDataSize)
		{
			DPF_ERR("invalid buffer size");
    		goto INVALID_PARMS_EXIT;
		}
		

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
		goto INVALID_PARMS_EXIT;
    }

	// if player from is not local, and i am not the nameserver in a multicast 
	// session, the send is no good
	ASSERT(this->lpsdDesc);	   
	if ( !((psp->pPlayerFrom)->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
		!((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) && IAM_NAMESERVER(this)) )
	{
		DPF_ERR("attempt to send from non-local player");
		return DPERR_ACCESSDENIED;
	}
	
	if (psp->dwFlags & DPSEND_GUARANTEED ) DPF(7,"sending DPSEND_GUARANTEED");

    // if encryption was requested, check if support is available
    if ((psp->dwFlags & DPSEND_ENCRYPTED) && !(this->dwFlags & DPLAYI_DPLAY_ENCRYPTION))
    {
        DPF_ERR("Encryption is not supported");
        return DPERR_ENCRYPTIONNOTSUPPORTED;
    }

    // If a client is trying to send a secure message, make sure they have logged in
    if ((psp->dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)) && !IAM_NAMESERVER(this))
    {
        if (DPLOGIN_SUCCESS != this->LoginState)
        {
            DPF_ERR("Client hasn't logged in yet");
            return DPERR_NOTLOGGEDIN;
        }
    }

	if(psp->dwPriority && !(this->dwSPFlags & DPCAPS_SENDPRIORITYSUPPORTED)){
		return DPERR_UNSUPPORTED;
	}

    if(psp->dwPriority > DPSEND_MAX_PRI){
	    DPF_ERR( "Priority is too high for user send" );		
	    hr=DPERR_INVALIDPRIORITY;
    	goto ERROR_EXIT;
    }

	if(psp->dwTimeout && !(this->dwSPFlags & DPCAPS_SENDTIMEOUTSUPPORTED)){
		return DPERR_UNSUPPORTED;
	}

    // do tests for async send validity
    if(psp->dwFlags & DPSEND_ASYNC){
    	#ifdef DEBUG
		if(psp->dwTimeout > 60000*60){
   			DPF_ERR("SendTimeOut is greater than 1 hour?");
    	} else if(psp->dwTimeout > 60000*5){
    		DPF_ERR( "SendTimeOut is greater than 5 minutes?");
    	}
    	#endif
    } else {
    	// A synchronous send.  
    	if(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG){
    		DPF_ERR( "Can't use DPSEND_NOSENDCOMPLETEMSG on synchronous send\n");
    		return DPERR_INVALIDFLAGS;
    	}
    }
    
    return DP_OK;

INVALID_PARMS_EXIT:    
	return DPERR_INVALIDPARAMS;

ERROR_EXIT:
	return hr;
}


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SendEx"

#ifdef DEBUG
UINT nCallsToSend=0;
#endif

HRESULT DPAPI DP_SendEx(
	LPDIRECTPLAY lpDP, 
	DPID idFrom, 
	DPID idTo, 
	DWORD dwFlags,
	LPVOID lpData, 
	DWORD dwDataSize, 
	DWORD dwPriority, 
	DWORD dwTimeout, 
	LPVOID lpUserContext,
	DWORD_PTR *lpdwMsgID)
{
    HRESULT hr = DP_OK;

    LPDPLAYI_DPLAY this;
	LPSENDPARMS psp;

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	// make sure we 0 out his returned msg id.  Just to be safe
	if (lpdwMsgID)
		*lpdwMsgID = 0;

	if(FAILED(hr)){
		return hr;
	}

	psp=GetSendParms(); // allocates send parm, sets refcount to 1.

	if(!psp){
		return DPERR_OUTOFMEMORY;
	}
	
	InitBilink(&psp->PendingList);

	psp->dwSendTime    = timeGetTime();

	psp->idFrom        = idFrom;
	psp->idTo          = idTo;
	psp->dwFlags       = dwFlags;
	psp->lpData        = lpData;		// user buffer, not valid after return from call
	psp->dwDataSize    = dwDataSize;    // unless DPSEND_NOCOPY is set.
	psp->dwPriority    = dwPriority;
	psp->dwTimeout     = dwTimeout;
	psp->lpUserContext = lpUserContext;
	psp->lpdwMsgID     = lpdwMsgID;
		
	if(!psp->lpdwMsgID){
		psp->lpdwMsgID = &psp->dwMsgID;
	}

	psp->hr            = DP_OK;
	
	psp->cBuffers         = 0;
	psp->dwTotalSize      = dwDataSize;

	psp->iContext = 0;
	psp->nContext = 0; 
	psp->nComplete= 0;
	psp->hContext = NULL;

	ENTER_ALL();

	hr=ValidateCommonSendParmsEx(lpDP, psp); // Fills in players and groups.
	
	if(FAILED(hr)){
		psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;		
		goto EXIT;
	}

	//
	// Double buffer the send memory if necessary.
	//
	
	if((psp->dwFlags & DPSEND_ASYNC) && !(psp->dwFlags & DPSEND_NOCOPY))
	{
		// ASYNC send and sender retains ownership of send buffers, so we must copy.
		psp->Buffers[0].pData      = MsgAlloc(psp->dwDataSize);
		if(!psp->Buffers[0].pData){
			hr=DPERR_OUTOFMEMORY;
			psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;
			goto EXIT;
		}
		psp->Buffers[0].len        = psp->dwDataSize;
		
		memcpy(psp->Buffers[0].pData,psp->lpData,psp->dwDataSize);
		
		psp->BufFree[0].fnFree     = MsgFree;
		psp->BufFree[0].lpvContext = NULL;

		if(this->pProtocol){
			psp->dwFlags |= DPSEND_NOCOPY;	// we copied the data, so the protocol doesn't need to.
		}
		
	} else {
		psp->Buffers[0].pData = lpData;
		psp->Buffers[0].len   = dwDataSize;
		psp->BufFree[0].fnFree = NULL;
		psp->BufFree[0].lpvContext = NULL;
	}
	psp->cBuffers=1;
	
	DPF(9,"sending message from %d to %d\n",idFrom,idTo);

	// If this object is lobby-owned, pass the message off to it here
	// since it will do all the server stuff
	if(IS_LOBBY_OWNED(this))
	{
		// NOTE: MYRONTH, MAKE PRV_SendEx
		//      - not likely now, DP4 being put to bed AO 04/03/2001
		#if 0
		hr = PRV_Send(this->lpLobbyObject, idFrom, idTo, dwFlags,
						pvBuffer, dwBufSize);
						
		// Since the lobby already sent the message, we can just return
		// from here.
		#endif
		hr=E_NOTIMPL;
		LEAVE_ALL();
		return hr;
	}

	if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG) && (psp->dwFlags & DPSEND_ASYNC)){
		InterlockedIncrement(&psp->pPlayerFrom->nPendingSends);
		InsertBefore(&psp->PendingList, &psp->pPlayerFrom->PendingList);
		DPF(9,"INC pPlayerFrom %x, nPendingSends %d\n",psp->pPlayerFrom, psp->pPlayerFrom->nPendingSends);
	}	

	// do the send
	if (psp->pPlayerTo)
	{
		#ifdef DEBUG
		nCallsToSend++;
		#endif
		hr = SendPlayerMessageEx( this, psp );
	}
	else 
	{
		ASSERT(psp->pGroupTo);
		// send to group
		#ifdef DEBUG
		nCallsToSend++;
		#endif
		hr = SendGroupMessageEx(this, psp, TRUE);
	}

EXIT:
	if(FAILED(hr) && hr!=DPERR_PENDING){
		if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG)){
			psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
			if(psp->pPlayerFrom){
				InterlockedDecrement(&psp->pPlayerFrom->nPendingSends);
				Delete(&psp->PendingList);
				InitBilink(&psp->PendingList);
			}
			psp->dwFlags |= DPSEND_NOSENDCOMPLETEMSG;
		}
	}

	LEAVE_ALL();

	pspDecRef(this,psp); // remove this functions reference.

    return hr;

} // DP_SendEx

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CancelMessage"

HRESULT DPAPI DP_CancelMessage(LPDIRECTPLAY lpDP, DWORD dwMsgID, DWORD dwFlags)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_CANCELDATA CancelData;
	PSENDPARMS psp=NULL;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(dwFlags){
		// Reserved for future expansion of API.
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	if(!this->pcbSPCallbacks->Cancel && !(this->pProtocol)){
		hr=DPERR_UNSUPPORTED;
		goto ERROR_EXIT;
	}

	if(dwMsgID){

                psp=pspFromContext(this, (LPVOID)(DWORD_PTR)dwMsgID, TRUE); // adds a reference to psp

		if(!psp){
			hr=DPERR_UNKNOWNMESSAGE;
			goto ERROR_EXIT;
		}

		EnterCriticalSection(&psp->cs);
		if(psp->nComplete){
			LeaveCriticalSection(&psp->cs);
			hr=DPERR_CANCELFAILED;
			goto ERROR_EXIT2;
		}
		LeaveCriticalSection(&psp->cs);

		// We don't need to lock the Context list, since it cannot grow now since the send returned, so
		// the list is held in place by the refcount on the psp.
		ReadContextList(this, psp->hContext, &CancelData.lprglpvSPMsgID, &CancelData.cSPMsgID,FALSE);
	} else {
		CancelData.dwFlags=DPCANCELSEND_ALL;
		CancelData.lprglpvSPMsgID = 0;
		CancelData.cSPMsgID       = 0;
	}
	
	CancelData.lpISP	      = this->pISP;
	CancelData.dwFlags        = 0;
	CancelData.dwMinPriority  = 0;
	CancelData.dwMaxPriority  = 0;
	
	if(this->pProtocol){
		hr=ProtocolCancel(&CancelData); // calls SP if appropriate.
	} else {
		hr=CALLSP(this->pcbSPCallbacks->Cancel,&CancelData);
	}

ERROR_EXIT2:
	if(psp){
		pspDecRef(this, psp);
	}	

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
	
} // DP_CancelMessage

#undef DPF_MODNAME
#define DPF_MODNAME "DP_CancelMessage"

HRESULT DPAPI DP_CancelPriority(LPDIRECTPLAY lpDP, DWORD dwMinPriority, DWORD dwMaxPriority,DWORD dwFlags)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_CANCELDATA CancelData;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(!this->pcbSPCallbacks->Cancel && !(this->pProtocol)){
		hr=DPERR_UNSUPPORTED;
		goto ERROR_EXIT;
	}

	if(dwFlags){
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	if(dwMinPriority > dwMaxPriority){
		hr=DPERR_INVALIDPARAMS;
		goto ERROR_EXIT;
	}

	if(dwMaxPriority > DPSEND_MAX_PRIORITY){
		hr=DPERR_INVALIDPARAMS;
		goto ERROR_EXIT;
	}

	CancelData.lpISP	      = this->pISP;
	CancelData.dwFlags        = DPCANCELSEND_PRIORITY;
	CancelData.lprglpvSPMsgID = NULL;
	CancelData.cSPMsgID       = 0;
	CancelData.dwMinPriority  = dwMinPriority;
	CancelData.dwMaxPriority  = dwMaxPriority;

	if(this->pProtocol){
		hr=ProtocolCancel(&CancelData); // calls SP if appropriate
	} else {
		hr=CALLSP(this->pcbSPCallbacks->Cancel,&CancelData);
	}

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
} // DP_CancelPriority

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetMessageQueue"

extern HRESULT DPAPI DP_GetMessageQueue(LPDIRECTPLAY lpDP, DPID idFrom, DPID idTo, DWORD dwFlags,
	LPDWORD lpdwNumMsgs, LPDWORD lpdwNumBytes)
{
    HRESULT hr = DP_OK;
    LPDPLAYI_DPLAY this;
    DPSP_GETMESSAGEQUEUEDATA GetMessageQueueData;
	LPMESSAGENODE pmsn;
	LPDPLAYI_PLAYER lpPlayer;
	DWORD dwPlayerFlags;


	DWORD dwNumMsgs;
	DWORD dwNumBytes;

	ENTER_ALL();

    this = DPLAY_FROM_INT(lpDP);
	hr = VALID_DPLAY_PTR( this );

	if(FAILED(hr)){
		goto ERROR_EXIT;
	}

	if(!dwFlags){
		dwFlags=DPMESSAGEQUEUE_SEND;
	}

	if( (!(dwFlags & (DPMESSAGEQUEUE_SEND|DPMESSAGEQUEUE_RECEIVE) ) ) || 
		((dwFlags-1 & dwFlags)!=0)
	  )
	{
		// an invalid flag bit is set OR more than one flag bit is set.
		hr=DPERR_INVALIDFLAGS;
		goto ERROR_EXIT;
	}

	// Parameter Validation - yada yada yada
	if(dwFlags==DPMESSAGEQUEUE_SEND){	
	
		if(!this->pcbSPCallbacks->GetMessageQueue && !(this->pProtocol)){
			hr=DPERR_UNSUPPORTED;
			goto ERROR_EXIT;
		}
		
		if(idFrom){
		
			// can only get send queue for local from players.
			
			lpPlayer=PlayerFromID(this,idFrom);

			// make sure this is not a group.
			if (!VALID_DPLAY_PLAYER(lpPlayer)) { //ISSUE: only works because players/groups differ in size!
				lpPlayer=NULL;
			}
			if(lpPlayer){
				dwPlayerFlags=lpPlayer->dwFlags;
			}	

			if(!lpPlayer || !(dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
		
		if(idTo){
			// can only get receive queue for local to players
			lpPlayer=PlayerFromID(this,idTo);
			
			if(!lpPlayer) {
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}

			// Route messages through system player on host unless DX3 in game
			// Messages delivered by host use the embedded FromID in the message
			// to notify the receiver who the message was from.

			if (!(lpPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		   		(! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ))
			{
				ASSERT(lpPlayer->dwIDSysPlayer);
				idTo = lpPlayer->dwIDSysPlayer;
			}

		}
		
	} else {
		// must be asking for the receive queue
		if(idTo){
			// can only get receive queue for local to players
			lpPlayer=PlayerFromID(this,idTo);
			if(lpPlayer){
				dwPlayerFlags=lpPlayer->dwFlags;
			}	
			
			if(!lpPlayer || !(dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
		// can't receive messages from a group.
		if(idFrom){
		
			lpPlayer=PlayerFromID(this,idFrom);
			
			if (!VALID_DPLAY_PLAYER(lpPlayer)) { //ISSUE: only works because players/groups differ in size!
				lpPlayer=NULL;
			}

			if(!lpPlayer){
				hr=DPERR_INVALIDPLAYER;
				goto ERROR_EXIT;
			}
		}
	}


	if(dwFlags == DPMESSAGEQUEUE_SEND){

		// Get the send queue from the SP.
	
		GetMessageQueueData.lpISP   = this->pISP;
		GetMessageQueueData.dwFlags = 0;
		GetMessageQueueData.idFrom  = idFrom;
		GetMessageQueueData.idTo    = idTo;
		if(lpdwNumMsgs){
			GetMessageQueueData.lpdwNumMsgs = &dwNumMsgs;
		} else {
			GetMessageQueueData.lpdwNumMsgs = NULL;
		}
		if(lpdwNumBytes){
			GetMessageQueueData.lpdwNumBytes = &dwNumBytes;
		} else {
			GetMessageQueueData.lpdwNumBytes = NULL;
		}
		if(this->pProtocol){
			hr=ProtocolGetMessageQueue(&GetMessageQueueData);
		} else {
			hr=CALLSP(this->pcbSPCallbacks->GetMessageQueue,&GetMessageQueueData);
		}	

		if(FAILED(hr)){
			goto ERROR_EXIT;
		}
		

	} else {

		ASSERT(dwFlags == DPMESSAGEQUEUE_RECEIVE);
		// Get DPLAY's receive Queue
	
	
		dwNumMsgs  = 0;
		dwNumBytes = 0;

		pmsn = this->pMessageList;

		// optimization: if we don't specify to or from, and don't want bytes, just
		//	grab the count
		if (!idTo && !idFrom && !lpdwNumBytes)
		{
			dwNumMsgs = this->nMessages;
		} 
		else			// the normal way
		{
			while (pmsn)
			{
				BOOL count = TRUE;

				if (idTo && idTo != pmsn->idTo)
				{
					count = FALSE;
				}	

				if (idFrom && idFrom != pmsn->idFrom)
				{
					count = FALSE;
				}	

				if (count)
				{
					dwNumMsgs++;
					dwNumBytes+=pmsn->dwMessageSize;
				}
				pmsn = pmsn->pNextMessage;
			}
		}
	}
	
	TRY {
		if(lpdwNumMsgs){
			*lpdwNumMsgs = dwNumMsgs;
		}
		if(lpdwNumBytes){
			*lpdwNumBytes = dwNumBytes;
		}	
	} EXCEPT( EXCEPTION_EXECUTE_HANDLER ) {
        DPF_ERR( "GetMessageQueue: Exception encountered setting returned values" );
        hr=DPERR_INVALIDPARAMS;
    }
 

ERROR_EXIT:
	LEAVE_ALL();
	return hr;
} // DP_GetMessageQueue

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetGroupData"  

// called by internalcreateplayer,internalsetname,internalsetdata
HRESULT CheckSetDataFlags(DWORD dwFlags)
{
	// check flags
	if ( dwFlags & ~(DPSET_REMOTE | DPSET_LOCAL | DPSET_GUARANTEED)) 
		
	{
		DPF_ERR("bad flags");
		return DPERR_INVALIDPARAMS;	
	}
	if ( (dwFlags & DPSET_LOCAL) && (dwFlags & DPSET_GUARANTEED) )
	{
		DPF_ERR(" invalid dwFlags combination");
		return DPERR_INVALIDPARAMS;
	}
	
	return DP_OK;

} // CheckSetDataFlags

/*
 ** InternalSetData
 *
 *  CALLED BY:	DP_SetGroupData and DP_SetPlayerData, and by handler.c 
 *
 *  PARAMETERS:	
 * 			fPropagate is set to TRUE when called from the DP_SetGroupData or DP_SetPlayerData - this
 * 			means we need to propagate the data - we were called by the client.	If we're called 
 *			by handler.c, fPropagate is set to FALSE.  we just set the data on the	local machine.
 *
 *  DESCRIPTION:
 *		updates the player data.
 *		propagates to all remote machine if dwFlags = DPSET_REMOTE and fPropagate is TRUE
 *
 */
HRESULT InternalSetData(LPDIRECTPLAY lpDP, DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags,BOOL fPlayer,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check src player        
 		if (fPlayer)
		{
	        lpPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
		    lpGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// cast the group so we can just use pPlayer
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
		}

		// check flags
		hr = CheckSetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			return hr;
		}

		// check permissions for remote data
		if(fPropagate && !(dwFlags & DPSET_LOCAL))
		{
			// this was generated by the local client
			// make sure they have permission
			ASSERT(this->pSysPlayer);
			if (this->pSysPlayer->dwID != lpPlayer->dwIDSysPlayer)
			{
				DPF_ERR("attempt to set data on player / group not owned by this client");
				return DPERR_ACCESSDENIED;
			}
		}
		
		// check blob
		if (dwDataSize && !VALID_READ_STRING_PTR(pvData,dwDataSize)) 
		{
	        DPF_ERR( "bad player blob" );
	        return DPERR_INVALIDPARAMS;
		}
    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
   
	// If this is a lobby-owned object, and it's remote, then call the lobby
	if(!(dwFlags & DPSET_LOCAL) && IS_LOBBY_OWNED(this))
	{
		// We need to drop the lock in case the GUARANTEED flag is set.
		// In that case, the lobby provider's receive thread needs to
		// be able to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		if(fPlayer)
		{
			hr = PRV_SetPlayerData(this->lpLobbyObject, id, pvData,
						dwDataSize, dwFlags);
		}
		else
		{
			hr = PRV_SetGroupData(this->lpLobbyObject, id, pvData,
						dwDataSize, dwFlags);
		}

		// Take the lock again
		ENTER_DPLAY();

		// If we failed, exit here
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling SetPlayer/GroupData in the lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

	// set up the data
	hr = DoPlayerData(lpPlayer,pvData,dwDataSize,dwFlags);
    if (FAILED(hr)) 
    {
		DPF_ERRVAL("could not set data - hr = 0x%08lx\n",hr);
		return hr;
    }
	
	if (!(dwFlags & DPSET_LOCAL))
	{
		// tell the world
		if (fPropagate)
		{
			if (dwFlags & DPSET_GUARANTEED)
			{
				ASSERT(1 == gnDPCSCount);
				LEAVE_DPLAY();
				hr = SendDataChanged(this,lpPlayer,fPlayer,DPSEND_GUARANTEE);
				ENTER_DPLAY();
			}	
			else
			{
				hr = SendDataChanged(this,lpPlayer,fPlayer,0);
			}
		}
	}

	return hr;

} // InternalSetData

HRESULT DPAPI DP_SetGroupData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetData(lpDP,id,pData,dwDataSize,dwFlags,FALSE,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetGroupData   


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetPlayerData"

HRESULT DPAPI DP_SetPlayerData(LPDIRECTPLAY lpDP, DPID id,LPVOID pData,
	DWORD dwDataSize,DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetData(lpDP,id,pData,dwDataSize,dwFlags,TRUE,TRUE);
															  
	LEAVE_DPLAY();
	
	return hr;
	
} // DP_SetPlayerData  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetGroupName/SetPlayerName"

/*
 ** InternalSetName
 *
 *  CALLED BY:	DP_SetGroupName and DP_SetPlayerName, and by handler.c 
 *
 *  PARAMETERS:	
 * 			fPropagate is set to TRUE when called from the DP_SetGroupName or DP_SetPlayerName - this
 * 			means we need to propagate the Name - we were called by the client.	If we're called 
 *			by handler.c, fPropagate is set to FALSE.  we just set the Name on the	local machine.
 *
 *  DESCRIPTION:
 *		updates the player Name.
 *		propagates to all remote machine if dwFlags = DPSET_REMOTE and fPropagate is TRUE
 *
 */
HRESULT InternalSetName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,BOOL fPlayer,
	DWORD dwFlags,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPWSTR lpszShortName,lpszLongName;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		// check src player        
 		if (fPlayer)
		{
	        lpPlayer = PlayerFromID(this,id);
	        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
	        {
				DPF_ERRVAL("invalid player id = %d", id);
	            return DPERR_INVALIDPLAYER;
	        }
		}
		else 
		{
	        lpGroup = GroupFromID(this,id);
	        if ((!VALID_DPLAY_GROUP(lpGroup)) || (DPID_ALLPLAYERS == id)) 
	        {
				DPF_ERRVAL("invalid group id = %d", id);
	            return DPERR_INVALIDGROUP;
	        }
			// cast the group so we can just use pPlayer
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
		}

		// check flags
		hr = CheckSetDataFlags(dwFlags);
		if (FAILED(hr))
		{
			return hr;
		}

		// check permissions for remote data
		if(fPropagate && !(dwFlags & DPSET_LOCAL))
		{
			// this was generated by the local client
			// make sure they have permission
			ASSERT(this->pSysPlayer);
			if (this->pSysPlayer->dwID != lpPlayer->dwIDSysPlayer)
			{
				DPF_ERR("attempt to set name on player / group not owned by this client");
				return DPERR_ACCESSDENIED;
			}
		}

        if (pName && !VALID_READ_DPNAME_PTR(pName))
        {
			DPF_ERR("invalid dpname pointer");
			return DPERR_INVALIDPARAMS;
        }

		// check strings
		if (pName)
		{
			lpszShortName = pName->lpszShortName;
			lpszLongName = pName->lpszLongName;
			if ( lpszShortName && 
				!VALID_READ_STRING_PTR(lpszShortName,WSTRLEN_BYTES(lpszShortName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
			if ( lpszLongName && 
				!VALID_READ_STRING_PTR(lpszLongName,WSTRLEN_BYTES(lpszLongName)) ) 
			{
		        DPF_ERR( "bad string pointer" );
		        return DPERR_INVALIDPARAMS;
			}
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	
	// If this is a lobby-owned object, call the lobby.  UNLESS the fPropagate
	// flag is cleared.  If it is cleared, it means the lobby called into us
	// to set the name of a remote group.  We don't want to call the lobby
	// back in that case.
	if(!(dwFlags & DPSET_LOCAL) && (IS_LOBBY_OWNED(this)) && (fPropagate))
	{
		// We need to drop the lock in case the GUARANTEED flag is set.  In
		// that case, the lobby provider's receive thread needs to be able
		// to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		if(fPlayer)
		{
			hr = PRV_SetPlayerName(this->lpLobbyObject, id, pName, dwFlags);
		}
		else
		{
			hr = PRV_SetGroupName(this->lpLobbyObject, id, pName, dwFlags);
		}

		// Take the lock back
		ENTER_DPLAY();

		// If it failed, just bail here
		if(FAILED(hr))
		{
			DPF_ERRVAL("Failed calling SetPlayer/GroupName in lobby, hr = 0x%08x", hr);
			return hr;
		}
	}

	// set up the name
	hr = DoPlayerName(lpPlayer,pName);
    if (FAILED(hr)) 
    {
		DPF_ERRVAL("could not set name - hr = 0x%08lx\n",hr);
		return hr;
    }

	if (!(dwFlags & DPSET_LOCAL))
	{
		if (fPropagate)
		{
			if (dwFlags & DPSET_GUARANTEED)
			{
				hr = SendNameChanged(this,lpPlayer,fPlayer,DPSEND_GUARANTEED);
			}											  
			else
			{
				hr = SendNameChanged(this,lpPlayer,fPlayer,0);
			} 	
		}
	}

	return hr;

} // InternalSetName

HRESULT DPAPI DP_SetGroupName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetName(lpDP,id,pName,FALSE,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetGroupName

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetPlayerName"

HRESULT DPAPI DP_SetPlayerName(LPDIRECTPLAY lpDP,DPID id,LPDPNAME pName,
	DWORD dwFlags)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalSetName(lpDP,id,pName,TRUE,dwFlags,TRUE);

	LEAVE_DPLAY();
	
	return hr;

} // DP_SetPlayerName

#undef DPF_MODNAME
#define DPF_MODNAME "InternalSetSessionDesc"
HRESULT InternalSetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc, DWORD dwFlags, BOOL fPropagate)
{
	LPDPLAYI_DPLAY this;
    HRESULT hr;
    DPCAPS dpCaps;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			return DPERR_NOSESSIONS;
		}
		if (!VALID_READ_DPSESSIONDESC2(lpsdDesc))
		{
			DPF_ERR("invalid session desc");
			return DPERR_INVALIDPARAMS;
		}
		if (!VALID_DPSESSIONDESC2_FLAGS(lpsdDesc->dwFlags))
		{
			DPF_ERR("invalid session desc flags");
			return DPERR_INVALIDFLAGS;
		}

		// check strings
		if ( lpsdDesc->lpszSessionName && !VALID_READ_STRING_PTR(lpsdDesc->lpszSessionName,
			WSTRLEN_BYTES(lpsdDesc->lpszSessionName)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
		if ( lpsdDesc->lpszPassword && !VALID_READ_STRING_PTR(lpsdDesc->lpszPassword,
			WSTRLEN_BYTES(lpsdDesc->lpszPassword)) ) 
		{
	        DPF_ERR( "bad string pointer" );
	        return DPERR_INVALIDPARAMS;
		}
        // no flags are supported
        if (dwFlags != 0)
        {
	        DPF_ERR( "Invalid flags" );
	        return DPERR_INVALIDPARAMS;
        }

		// This method is not supported for lobby connections
		if(IS_LOBBY_OWNED(this))
		{
			DPF_ERR("SetSessionDesc not supported for lobby connections");
			return DPERR_ACCESSDENIED;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // check to make sure there is a system player
	if (!this->pSysPlayer)
	{
		DPF(1,"SetSessionDesc - session not currently open - failing");
		return E_FAIL;
	}

    // only a host can change the session desc
    // fPropagate is used here to distinguish between a user call and an
    // internal call (e.g. from handler.c)
    if ( fPropagate && !(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
    {
		DPF_ERR("A non-host can't set session desc");
		return DPERR_ACCESSDENIED;
    }

    // can't set max allowed players to less than current players
    // unless it is zero which means unlimited max players
	if ((lpsdDesc->dwMaxPlayers > 0) &&
        (lpsdDesc->dwMaxPlayers < this->lpsdDesc->dwCurrentPlayers))
	{
		DPF_ERR("can't set max players < current players");
		return DPERR_INVALIDPARAMS;
	}

    // get the caps so we can check how many max players sp allows
    dpCaps.dwSize = sizeof(DPCAPS);
    hr = InternalGetCaps(lpDP, 0, &dpCaps, FALSE, 0);
    if (FAILED(hr))
    {
        DPF_ERR("couldn't get caps for the current session");
        return hr;
    }

	// we don't allow reseting the following flags 
    //   DPSESSION_NOMESSAGEID, 
    //   DPSESSION_KEEPALIVE, 
    //   DPSESSION_MIGRATEHOST
    //   DPSESSION_SECURESERVER
    //   DPSESSION_CLIENTSERVER
    // all other flags are OK
    
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ==
			(lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)) )
	{
		DPF_ERR("error - can not reset DPSESSION_NOMESSAGEID");
		return DPERR_INVALIDPARAMS;
	}
	
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE) ==
			(lpsdDesc->dwFlags & DPSESSION_KEEPALIVE)) )
	{
		DPF_ERR("error - can not reset DPSESSION_KEEPALIVE");
		return DPERR_INVALIDPARAMS;
	}
	
	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) ==
			(lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST)) )
	{
		DPF_ERR("error - can not reset DPSESSION_MIGRATEHOST");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_SECURESERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_SECURESERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_CLIENTSERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) ==
			(lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER)) )
	{
		DPF_ERR("error - can not reset DPSESSION_MULTICASTSERVER");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL) == 
			(lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL)) )
	{
		DPF_ERR("error - can not change DPSESSION_DIRECTPLAYPROTOCOL\n");
		return DPERR_INVALIDPARAMS;
	}

	if ( ! ((this->lpsdDesc->dwFlags & DPSESSION_OPTIMIZELATENCY) == 
			(lpsdDesc->dwFlags & DPSESSION_OPTIMIZELATENCY)) )
	{
		DPF_ERR("error - can not change DPSESSION_OPTIMIZELATENCY\n");
		return DPERR_INVALIDPARAMS;
	}

	if( this->lpsdDesc->dwFlags & DPSESSION_ALLOWVOICERETRO ){
		// Don't allow over-riding this flag.
		lpsdDesc->dwFlags |= DPSESSION_ALLOWVOICERETRO;
	}

    // update the existing session desc
	this->lpsdDesc->dwFlags = lpsdDesc->dwFlags;
	this->lpsdDesc->dwMaxPlayers = lpsdDesc->dwMaxPlayers;
	this->lpsdDesc->dwUser1 = lpsdDesc->dwUser1;
	this->lpsdDesc->dwUser2 = lpsdDesc->dwUser2;
	this->lpsdDesc->dwUser3	= lpsdDesc->dwUser3;
	this->lpsdDesc->dwUser4	= lpsdDesc->dwUser4;

	// copy strings
	if (this->lpsdDesc->lpszSessionName) DPMEM_FREE(this->lpsdDesc->lpszSessionName);
	GetString(&(this->lpsdDesc->lpszSessionName),lpsdDesc->lpszSessionName);

	if (this->lpsdDesc->lpszPassword) DPMEM_FREE(this->lpsdDesc->lpszPassword);
	GetString(&(this->lpsdDesc->lpszPassword),lpsdDesc->lpszPassword);

    // if session has a password, setup the password required flag
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        this->lpsdDesc->dwFlags |= DPSESSION_PASSWORDREQUIRED;
    }
    else
    {
        this->lpsdDesc->dwFlags &= ~DPSESSION_PASSWORDREQUIRED;
    }

    // tell the world/local players
	if (fPropagate)
	{
		// send this message guaranteed
	    hr = SendSessionDescChanged(this, dwFlags | DPSEND_GUARANTEED);
	}

    return hr;
} // InternalSetSessionDesc

#undef DPF_MODNAME
#define DPF_MODNAME "DP_SetSessionDesc"
HRESULT DPAPI DP_SetSessionDesc(LPDIRECTPLAY lpDP, LPDPSESSIONDESC2 lpsdDesc,DWORD dwFlags)
{
    HRESULT hr;
    BOOL bPropogate;
	LPDPLAYI_DPLAY this;

	ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto exit;
        }
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before settig desc!");
			hr = DPERR_NOSESSIONS;
			goto exit;
		}
	} 
	EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr = DPERR_INVALIDPARAMS;
        goto exit;
    }

	if(this->lpsdDesc->dwFlags & DPSESSION_NOSESSIONDESCMESSAGES){
		bPropogate=FALSE;
	} else {
		bPropogate=TRUE;
	}

    hr = InternalSetSessionDesc(lpDP, lpsdDesc, dwFlags, bPropogate);


exit:
    LEAVE_DPLAY();

    return hr;
} // DP_SetSessionDesc  


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SecureOpen"

HRESULT DPAPI DP_SecureOpen(LPDIRECTPLAY lpDP, LPCDPSESSIONDESC2 lpsdDesc, DWORD dwFlags,                             
    LPCDPSECURITYDESC lpSecDesc, LPCDPCREDENTIALS lpCredentials) 
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			LEAVE_ALL();
			return hr;
        }

	    if (this->lpsdDesc)
	    {
			LEAVE_ALL();
		    DPF_ERR("session already open!");
		    return DPERR_ALREADYINITIALIZED;
	    }

        // validate regular open params
        hr = ValidateOpenParams(this,lpsdDesc,dwFlags);
        if (FAILED(hr))
        {
		    LEAVE_ALL();
		    return hr;
        }

        // validate the additional params
        // null lpSecDesc is ok, we'll use the default
        if (lpSecDesc)            
        {
            // app passed in a security desc 

            // can't pass security desc to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed a security description while creating an unsecure session");                
	            goto INVALID_PARAMS_EXIT;
            }
            // join case will be checked after we find the session in our list

            // need to be hosting
            if (dwFlags & DPOPEN_JOIN)
            {
                DPF_ERR("Can't pass a security description while joining");                
	            goto INVALID_PARAMS_EXIT;
            }

            if (!VALID_READ_DPSECURITYDESC(lpSecDesc)) 
            {
    			DPF_ERR("invalid security desc");
	            goto INVALID_PARAMS_EXIT;
            }
	        if (!VALID_DPSECURITYDESC_FLAGS(lpSecDesc->dwFlags))
	        {
  		        DPF_ERRVAL("invalid flags (0x%08x) in security desc!",lpSecDesc->dwFlags);
                hr=DPERR_INVALIDFLAGS;
                goto CLEANUP_EXIT;
	        }
		    if ( lpSecDesc->lpszSSPIProvider && !VALID_READ_STRING_PTR(lpSecDesc->lpszSSPIProvider,
			    WSTRLEN_BYTES(lpSecDesc->lpszSSPIProvider)) ) 
		    {
	            DPF_ERR( "bad SSPI provider name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpSecDesc->lpszCAPIProvider && !VALID_READ_STRING_PTR(lpSecDesc->lpszCAPIProvider,
			    WSTRLEN_BYTES(lpSecDesc->lpszCAPIProvider)) ) 
		    {
	            DPF_ERR( "bad CAPI provider name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
        }
        // null lpCredentials is ok, sspi will pop the dialg
        if (lpCredentials)            
        {
            // app passed in credentials

            // can't pass credentials to an unsecure session
            if ((dwFlags & DPOPEN_CREATE) && !(lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
            {
                DPF_ERR("Passed credentials while creating an unsecure session");                
	            goto INVALID_PARAMS_EXIT;
            }
            // join case will be checked after we find the session in our list
            
            if (!VALID_READ_DPCREDENTIALS(lpCredentials)) 
            {
    			DPF_ERR("invalid credentials structure");
	            goto INVALID_PARAMS_EXIT;
            }
	        if (!VALID_DPCREDENTIALS_FLAGS(lpCredentials->dwFlags))
	        {
  		        DPF_ERRVAL("invalid flags (0x%08x) in credentials!",lpCredentials->dwFlags);
                hr=DPERR_INVALIDFLAGS;
                goto CLEANUP_EXIT;
	        }
		    if ( lpCredentials->lpszUsername && !VALID_READ_STRING_PTR(lpCredentials->lpszUsername,
			    WSTRLEN_BYTES(lpCredentials->lpszUsername)) ) 
		    {
	            DPF_ERR( "bad user name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpCredentials->lpszPassword && !VALID_READ_STRING_PTR(lpCredentials->lpszPassword,
			    WSTRLEN_BYTES(lpCredentials->lpszPassword)) ) 
		    {
	            DPF_ERR( "bad password string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
		    if ( lpCredentials->lpszDomain && !VALID_READ_STRING_PTR(lpCredentials->lpszDomain,
			    WSTRLEN_BYTES(lpCredentials->lpszDomain)) ) 
		    {
	            DPF_ERR( "bad domain name string pointer" );
	            goto INVALID_PARAMS_EXIT;
		    }
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr=DPERR_INVALIDPARAMS;
        goto CLEANUP_EXIT;
    }			        

	hr =  InternalOpenSession( this, lpsdDesc,FALSE,dwFlags,FALSE,lpSecDesc,lpCredentials);

CLEANUP_EXIT:
	LEAVE_ALL();
    return hr;

INVALID_PARAMS_EXIT:
	hr=DPERR_INVALIDPARAMS;
	goto CLEANUP_EXIT;
	
}//DP_SecureOpen

#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetPlayerAccount"

// take a pointer to a buffer, stick an account desc in it, slap the strings
// on the end.
HRESULT InternalGetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize,BOOL fAnsi)
{
	LPDPLAYI_DPLAY this;
	UINT nNameLen=0; // user name length, in bytes
	HRESULT hr;
	LPDPACCOUNTDESC pAccountDesc;
    PCtxtHandle phContext;
    DWORD dwBufferSize=0;
    LPDPLAYI_PLAYER pPlayer;
    LPWSTR pwszUserName=NULL;
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

        if (!VALID_DPACCOUNTDESC_FLAGS(dwFlags))
        {
  		    DPF_ERRVAL("invalid flags (0x%08x)",dwFlags);
            return DPERR_INVALIDFLAGS;
        }

        // need to have a session
		if (!this->lpsdDesc)
		{
			DPF_ERR("must open session before getting account desc!");
			return DPERR_NOSESSIONS;
		}

        // must be a secure session
        if (!SECURE_SERVER(this))
        {
            DPF_ERR("session is not secure!");
            return DPERR_UNSUPPORTED;
        }

        // allowed only on a nameserver
        if (!IAM_NAMESERVER(this))
        {
            DPF_ERR("can't get account info on the client!");
            return DPERR_ACCESSDENIED;
        }

		// check the buffer
		if (!VALID_DWORD_PTR(pdwSize))
		{
	        DPF_ERR( "bad dwSize pointer" );
	        return DPERR_INVALIDPARAMS;
		}

		if (NULL == pvBuffer) *pdwSize = 0;

		if (!VALID_STRING_PTR(pvBuffer,*pdwSize))
		{
	        DPF_ERR( "bad buffer pointer" );
	        return DPERR_INVALIDPARAMS;
		}

        // get the player structure for the specified id
        pPlayer = PlayerFromID(this,dpid);
        if (!pPlayer)
        {
            DPF_ERRVAL("Failed to get security context handle - Invalid player id %d", dpid);
            return DPERR_INVALIDPLAYER;
        }

        if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)
        {
            // assert so we notice!
            ASSERT(FALSE);
            DPF_ERR("Failed to get security context handle - a system player was passed");
            return DPERR_INVALIDPLAYER;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

    // only system players have a security context handle
    // so get the corresponding system player
    pPlayer = PlayerFromID(this,pPlayer->dwIDSysPlayer);
    if (!pPlayer)
    {
        DPF_ERRVAL("Failed to locate system player (%d)",pPlayer->dwIDSysPlayer);
        return DPERR_INVALIDPLAYER;
    }

    // check if they are asking for nameserver's account description
    if (pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
    {
        // yep, can't do it
        DPF_ERR("Can't get nameserver's account description");
        return DPERR_INVALIDPLAYER;
    }

    // if we reach here means player is logged in, so just grab the context handle
    // belonging to the system player
    phContext = &(pPlayer->pClientInfo->hContext);

    // get user name associated with this security context
    hr = OS_QueryContextUserName(phContext,&pwszUserName);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to get user name associated: hr=0x%08x",hr);
        return hr;
    }

    // remember the length of the username
    nNameLen = WSTRLEN(pwszUserName);

    // calculate the required buffer size
    dwBufferSize = sizeof(DPACCOUNTDESC);

    // add the size of username
    if (fAnsi)
    {
        dwBufferSize += nNameLen;
    }
    else
    {
        dwBufferSize += WSTRLEN_BYTES(pwszUserName);
    }

    // check if user passed in a big enough buffer
	if (*pdwSize < dwBufferSize)
	{
		*pdwSize = dwBufferSize;
        hr = DPERR_BUFFERTOOSMALL;
        goto CLEANUP_EXIT;
	}

	// zero buffer passed in
	ZeroMemory(pvBuffer,*pdwSize);
    // use the buffer as an accountdesc
	pAccountDesc = (LPDPACCOUNTDESC) pvBuffer;
    pAccountDesc->dwSize = sizeof(DPACCOUNTDESC);
    // flags are zero for now

    // set buffer size to return to app
	*pdwSize = dwBufferSize;

    // copy username string into the buffer after the desc.
    if (nNameLen)
    {
		LPBYTE pbUsername = (LPBYTE)pvBuffer+sizeof(DPACCOUNTDESC);

        // return string in the proper format to the app
        if (fAnsi)
        {
            // app called the ansi interface, so convert string to ansi before copying
            WideToAnsi(pbUsername,pwszUserName,nNameLen);
            pAccountDesc->lpszAccountIDA = (LPSTR)pbUsername;
        }
        else
        {
            // app called the unicode interface, so just copy the strings over
            wcscpy((LPWSTR)pbUsername, pwszUserName);
            pAccountDesc->lpszAccountID = (LPWSTR)pbUsername;
        }
    }

    // success
    hr = DP_OK;

    // fall through
CLEANUP_EXIT:
    if (pwszUserName) DPMEM_FREE(pwszUserName);
	return hr;
} // InternalGetPlayerAccount


HRESULT DPAPI DP_GetPlayerAccount(LPDIRECTPLAY lpDP, DPID dpid, DWORD dwFlags, LPVOID pvBuffer,
	LPDWORD pdwSize)
{
	HRESULT hr;

	ENTER_DPLAY();
	
	hr = InternalGetPlayerAccount(lpDP,dpid,dwFlags,pvBuffer,pdwSize,FALSE);	

	LEAVE_DPLAY();
	
	return hr;

} // DP_GetPlayerAccount


#undef DPF_MODNAME
#define DPF_MODNAME "DP_SendChatMessage"
/*
 ** DP_SendChatMessage
 *
 *  PARAMETERS:	
 * 			
 *  DESCRIPTION:
 *		Send a chat message to the appropriate players
 *
 */
HRESULT DPAPI DP_SendChatMessage(LPDIRECTPLAY lpDP,DPID idFrom,DPID idTo,
		DWORD dwFlags,LPDPCHAT lpMsg)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_PLAYER pPlayerFrom = NULL, pPlayerTo = NULL;
	LPWSTR lpszMessage = NULL;
	BOOL bToPlayer = FALSE;

	
	ENTER_ALL();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto EXIT_SENDCHATMESSAGE;
        }

		// check src player        
		pPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr = DPERR_INVALIDPLAYER;
			goto EXIT_SENDCHATMESSAGE;
		}

		// if the player from is remote, fail the call
		if(!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			DPF_ERR("Cannot send a chat message FROM a remote player");
			hr = DPERR_ACCESSDENIED;
			goto EXIT_SENDCHATMESSAGE;
		}

		// Since the lobby doesn't need anything from this dplay object's
		// player struct, let the lobby validate the To ID.  We may
		// still know about players who are missing from the local nametable.
		if(!IS_LOBBY_OWNED(this))
		{
			// see if it's a player or group
			pPlayerTo = PlayerFromID(this,idTo);
			if(VALID_DPLAY_PLAYER(pPlayerTo))
			{
				bToPlayer = TRUE;
			}
			else
			{		  
				pPlayerTo = (LPDPLAYI_PLAYER)GroupFromID(this,idTo);
				if (!VALID_DPLAY_GROUP(((LPDPLAYI_GROUP)pPlayerTo))) 
				{
					// bogus id! - player may have been deleted...
					DPF_ERR("bad player to");
					hr = DPERR_INVALIDPARAMS;
					goto EXIT_SENDCHATMESSAGE;
				}// not player or group
			} // group
		} // lobby-owned

		// check flags
		if(!VALID_CHAT_FLAGS(dwFlags))
		{
			DPF_ERR("Invalid flags");
			hr = DPERR_INVALIDFLAGS;
			goto EXIT_SENDCHATMESSAGE;
		}

		// check DPCHAT struct
		if(!VALID_READ_DPCHAT(lpMsg))
		{
			DPF_ERR("Invalid DPCHAT structure");
			hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGE;
		}

		// verify the flags inside the DPCHAT struct (none currently defined)
		if(lpMsg->dwFlags)
		{
			DPF_ERR("Invalid flags in the DPCHAT structure");
			hr = DPERR_INVALIDFLAGS;
			goto EXIT_SENDCHATMESSAGE;
		}
		
		// check message string
		lpszMessage = lpMsg->lpszMessage;
		if ( !lpszMessage ||
			!VALID_READ_STRING_PTR(lpszMessage,WSTRLEN_BYTES(lpszMessage)) ) 
		{
		    DPF_ERR( "bad string pointer" );
		    hr =  DPERR_INVALIDPARAMS;
			goto EXIT_SENDCHATMESSAGE;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        hr =  DPERR_INVALIDPARAMS;
		goto EXIT_SENDCHATMESSAGE;
    }
	
	// do the send
	if(!IS_LOBBY_OWNED(this))
	{
		// just send to the player
		hr = SendChatMessage(this, pPlayerFrom, pPlayerTo, dwFlags, lpMsg, bToPlayer);
	}
	else
	{
		// We need to drop the lock in case the GUARANTEED flag is set.  In
		// that case, the lobby provider's receive thread needs to be able
		// to get back in.
		ASSERT(1 == gnDPCSCount);
		LEAVE_DPLAY();

		// Call the lobby
		hr = PRV_SendChatMessage(this->lpLobbyObject, idFrom, idTo, dwFlags, lpMsg);

		// Take the lock back
		ENTER_DPLAY();
	}

	if (FAILED(hr))
	{
		DPF_ERRVAL("SendChatMessage failed - hr = 0x%08lx\n",hr);
	}


EXIT_SENDCHATMESSAGE:

	LEAVE_ALL();

	return hr;

} // DP_SendChatMessage



#undef DPF_MODNAME
#define DPF_MODNAME "DP_GetGroupParent"
/*
 ** DP_GetGroupParent
 *
 *  PARAMETERS:	
 * 			
 *  DESCRIPTION:
 *		Get the DPID of a group's parent group
 *
 */
HRESULT DPAPI DP_GetGroupParent(LPDIRECTPLAY lpDP, DPID idGroup, LPDPID pidParent)	
{
	LPDPLAYI_DPLAY this;
	LPDPLAYI_GROUP pGroup;
	HRESULT hr;


	ENTER_DPLAY();
	
    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }

	    pGroup = GroupFromID(this,idGroup);
	    if ((!VALID_DPLAY_GROUP(pGroup)) || (DPID_ALLPLAYERS == idGroup)) 
	    {
			LEAVE_DPLAY();
			DPF_ERRVAL("invalid group id = %d", idGroup);
	        return DPERR_INVALIDGROUP;
	    }

		if (!VALID_DWORD_PTR(pidParent))
		{
			LEAVE_DPLAY();
			DPF_ERR("invalid pidParent");
			return DPERR_INVALIDPARAMS;	
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }
	

	// Fill in the group's parent
	*pidParent = pGroup->dwIDParent;

	LEAVE_DPLAY();
	return DP_OK;

} // DP_GetGroupParent
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\loopbksp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       loopbksp.c
 *  Content:	direct play loopback service provider (built-in)
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 * 10/4/99		aarono  created for loopback tests on audio support.
 ***************************************************************************/

#define INITGUID 

#include "windows.h"
#include "windowsx.h"
#include "dplay.h"
#include "dplaysp.h"
#include "newdpf.h"
#include "loopbksp.h"

SPNODE LBSPNode;
// main entry point for service provider
// sp should fill in callbacks (pSD->lpCB) and do init stuff here
HRESULT WINAPI LBSPInit(LPSPINITDATA pSD) 
{
    HRESULT hr;
	GLOBALDATA gd,*pgd;
	UINT dwSize;

	// Zero out global data
	memset(&gd,0,sizeof(gd));

    // set up callbacks
    pSD->lpCB->CreatePlayer = LBSP_CreatePlayer;
    pSD->lpCB->DeletePlayer = LBSP_DeletePlayer;
    pSD->lpCB->Send = LBSP_Send;
    pSD->lpCB->EnumSessions = LBSP_EnumSessions;
    pSD->lpCB->Reply = LBSP_Reply;
	pSD->lpCB->ShutdownEx = LBSP_Shutdown;
	pSD->lpCB->GetCaps = LBSP_GetCaps;
	pSD->lpCB->Open = LBSP_Open;
	pSD->lpCB->CloseEx = LBSP_Close;
	pSD->lpCB->GetAddress = LBSP_GetAddress;
   	//pSD->lpCB->SendToGroupEx = SP_SendToGroupEx;             // optional - not impl
   	//pSD->lpCB->Cancel        = SP_Cancel;                    // optional - not impl
    pSD->lpCB->SendEx		   = LBSP_SendEx;                  // required for async
   	//pSD->lpCB->GetMessageQueue = LBSP_GetMessageQueue;    

	pSD->dwSPHeaderSize = 0;

	// return version number so DirectPlay will treat us with respect
	pSD->dwSPVersion = (DPSP_MAJORVERSION);

	// store the globaldata
	hr = pSD->lpISP->lpVtbl->SetSPData(pSD->lpISP,&gd,sizeof(GLOBALDATA),DPSET_LOCAL);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}
	
	hr = pSD->lpISP->lpVtbl->GetSPData(pSD->lpISP,&pgd,&dwSize,DPGET_LOCAL);

	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}

	// Initialize the critical section stored in the global data.
	InitializeCriticalSection(&pgd->cs);
	
	// success!
	return DP_OK;    

ERROR_EXIT:

	DPF_ERR("Loopback SPInit - abnormal exit");

	return hr;

} // SPInit

HRESULT WINAPI LBSP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd) 
{
    HRESULT hr=DP_OK;
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;

	// get the global data
	hr =pcpd->lpISP->lpVtbl->GetSPData(pcpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("Loopback SP: couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->cs);
	pgd->dwNumPlayers++;
	DPF(9,"Loopback SP: new player, now have %d",pgd->dwNumPlayers);
	LeaveCriticalSection(&pgd->cs);

	return DP_OK;
} // CreatePlayer

HRESULT WINAPI LBSP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(9, "Loopback SP: Entering SP_DeletePlayer, player %d, flags 0x%x, lpISP 0x%08x\n",
		pdpd->idPlayer, pdpd->dwFlags, pdpd->lpISP);
	
	// get the global data
	hr =pdpd->lpISP->lpVtbl->GetSPData(pdpd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	EnterCriticalSection(&pgd->cs);
	pgd->dwNumPlayers--;
	DPF(9,"Loopback SP: delete player, now have %d",pgd->dwNumPlayers);
	LeaveCriticalSection(&pgd->cs);

	return DP_OK;

} // DeletePlayer

HRESULT WINAPI LBSP_SendEx(LPDPSP_SENDEXDATA psd)
{
    HRESULT hr;

	DWORD cbTotalBytesToCopy;
	DWORD cbBytesToCopy;
	DWORD iWritePos;
	DWORD iSrcBuf;

	CHAR SendData[MAX_LOOPBACK_SEND_SIZE];

	// Gather data into 1 buffer;
	
	iWritePos=0;
	iSrcBuf=0;
	cbTotalBytesToCopy=psd->dwMessageSize;

	if(cbTotalBytesToCopy > MAX_LOOPBACK_SEND_SIZE){
		DPF(0,"Loopback SP: trying to send too big a message %d bytes, max is %d bytes",cbTotalBytesToCopy, MAX_LOOPBACK_SEND_SIZE);
		return DPERR_SENDTOOBIG;
	}
	
	while(cbTotalBytesToCopy){
		cbBytesToCopy=(*(psd->lpSendBuffers+iSrcBuf)).len;
		memcpy(&SendData[iWritePos], (*(psd->lpSendBuffers+iSrcBuf)).pData, cbBytesToCopy);
		cbTotalBytesToCopy -= cbBytesToCopy;
		iWritePos += cbBytesToCopy;
	}

	// Loop back to message handler

	hr=psd->lpISP->lpVtbl->HandleMessage(psd->lpISP, SendData, psd->dwMessageSize,NULL);

	if(psd->dwFlags & DPSEND_ASYNC){

		if(!(psd->dwFlags & DPSEND_NOSENDCOMPLETEMSG)){
			// Complete the message
			psd->lpISP->lpVtbl->SendComplete(psd->lpISP, psd->lpDPContext, hr);
		}

		return DPERR_PENDING;

	} else {
	
		return DP_OK;
		
	}

} // SendEx

HRESULT WINAPI LBSP_Send(LPDPSP_SENDDATA psd)
{
	HRESULT hr;

	hr=psd->lpISP->lpVtbl->HandleMessage(psd->lpISP, psd->lpMessage, psd->dwMessageSize,NULL);

	return DP_OK;
} // send


HRESULT WINAPI LBSP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
	HRESULT hr;

	DPF(9,"Loopback SP_EnumSessions");
	
	hr=ped->lpISP->lpVtbl->HandleMessage(ped->lpISP, ped->lpMessage, ped->dwMessageSize,NULL);

	return DP_OK;
}

HRESULT WINAPI LBSP_Reply(LPDPSP_REPLYDATA prd)
{
	HRESULT hr;

	DPF(9,"Loopback SP_Reply");
	
	hr=prd->lpISP->lpVtbl->HandleMessage(prd->lpISP, prd->lpMessage, prd->dwMessageSize,NULL);

	return DP_OK;
}

HRESULT WINAPI LBSP_Shutdown(LPDPSP_SHUTDOWNDATA psd) 
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(9,"Loopback SP_Shutdown");

	// get the global data
	hr = psd->lpISP->lpVtbl->GetSPData(psd->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("Loopback SP Shutdown: couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	DeleteCriticalSection(&pgd->cs);

	return DP_OK;
}

HRESULT WINAPI LBSP_Open(LPDPSP_OPENDATA pod) 
{
	DPF(9,"Loopback SP_Open");
	return DP_OK;
}

HRESULT WINAPI LBSP_Close(LPDPSP_CLOSEDATA pcd)
{
	DPF(9,"Loopback SP_Close");
	return DP_OK;
}
// sp only sets fields it cares about

HRESULT WINAPI LBSP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{

	pcd->lpCaps->dwHeaderLength = 0;
	pcd->lpCaps->dwMaxBufferSize = MAX_LOOPBACK_SEND_SIZE;

	pcd->lpCaps->dwFlags |= (DPCAPS_ASYNCSUPPORTED);

	pcd->lpCaps->dwLatency = 500;
	pcd->lpCaps->dwTimeout = 5000;

	return DP_OK;

} // SP_GetCaps

HRESULT WINAPI LBSP_GetAddress(LPDPSP_GETADDRESSDATA pad)
{
	DWORD dwDataSize = sizeof(GLOBALDATA);
	LPGLOBALDATA pgd;
	HRESULT hr;

	DPF(9,"Loopback SP_GetAddress");

	// get the global data
	hr = pad->lpISP->lpVtbl->GetSPData(pad->lpISP,(LPVOID *)&pgd,&dwDataSize,DPGET_LOCAL);
	if (FAILED(hr) || (dwDataSize != sizeof(GLOBALDATA) ))
	{
		DPF_ERR("Loopback SP Shutdown: couldn't get SP data from DirectPlay - failing");
		return E_FAIL;
	}

	hr = pad->lpISP->lpVtbl->CreateAddress(pad->lpISP, &GUID_DPLAY_LOOPBACKSP, &GUID_LOOPBACK, NULL,0,pad->lpAddress,pad->lpdwAddressSize);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\loopbksp.h ===
#include "windows.h"
#include "windowsx.h"
#include "dplay.h"
#include "dplaysp.h"
#include "dplaypr.h"
#include "newdpf.h"

#define MAX_LOOPBACK_SEND_SIZE 2048

// {8AEF46DA-4B31-4732-958F-AF25D0B0BCD8}
DEFINE_GUID(GUID_DPLAY_LOOPBACKSP, 
0x8aef46da, 0x4b31, 0x4732, 0x95, 0x8f, 0xaf, 0x25, 0xd0, 0xb0, 0xbc, 0xd8);

// {5A030546-81F0-4055-A65C-3CC0B65B9792}
DEFINE_GUID(GUID_LOOPBACK, 
0x5a030546, 0x81f0, 0x4055, 0xa6, 0x5c, 0x3c, 0xc0, 0xb6, 0x5b, 0x97, 0x92);

typedef struct _GLOBALDATA{
	CRITICAL_SECTION cs;
	DWORD			 dwNumPlayers;
}GLOBALDATA,*LPGLOBALDATA;

extern HRESULT WINAPI LBSPInit(LPSPINITDATA pSD);
extern HRESULT WINAPI LBSP_CreatePlayer(LPDPSP_CREATEPLAYERDATA pcpd);
extern HRESULT WINAPI LBSP_DeletePlayer(LPDPSP_DELETEPLAYERDATA pdpd);
extern HRESULT WINAPI LBSP_SendEx(LPDPSP_SENDEXDATA psd);
extern HRESULT WINAPI LBSP_Send(LPDPSP_SENDDATA psd);
extern HRESULT WINAPI LBSP_Shutdown(LPDPSP_SHUTDOWNDATA psd);
extern HRESULT WINAPI LBSP_Open(LPDPSP_OPENDATA pod);
extern HRESULT WINAPI LBSP_Close(LPDPSP_CLOSEDATA pcd);
extern HRESULT WINAPI LBSP_GetCaps(LPDPSP_GETCAPSDATA pcd);
extern HRESULT WINAPI LBSP_GetAddress(LPDPSP_GETADDRESSDATA pad);
extern HRESULT WINAPI LBSP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped);
extern HRESULT WINAPI LBSP_Reply(LPDPSP_REPLYDATA prd);

extern SPNODE LBSPNode;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\mcontext.c ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcontext.c
 *  Content:	message context mapping for SendEx
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *	12/8/97		aarono      Created
 *  2/13/98     aarono      fixed bugs found by async testing
 *  2/18/98     aarono      wasn't dropping lock in error path - fixed
 *  6/20/98     aarono      pspFromContext, used count w/o init.
 *  12/22/2000  aarono      Whistler B#190380 use process heap for retail
 *  01/12/2001  aarono      Whistler B#285097 not freeing to right heap.
 *
 *  Abstract:
 *
 *  Maintains a table of context mappings for messages being sent
 *  asynchronously.  Also keeps track of group sends vs. directed
 *  sends so that cancel can cancel them together.
 * 
 ***************************************************************************/

/*

	Structures:

	Context mapping is done on the array of MSGCONTEXTENTRY's 
	this->pMsgContexts.  This is a MsgContextTable which can be
	grown if it gets empty.  Each context provided is an integer
	index from 0 to the list size.  To avoid context collisions
	the context is composed of 2 parts.  A high 16 bits that is 
	cycled with every allocation and the low 16 bits which is the
	index in the context table. 
	
*/


#include "dplaypr.h"
#include "mcontext.h"

// Allocate the pool heads for context mapping buffers.
// sizes range from 2 to MSG_FAST_CONTEXT_POOL_SIZE. Larger
// allocations are off the heap.
VOID InitTablePool(LPDPLAYI_DPLAY this)
{
	UINT i;

	// Initialize the group context list pool.
	for (i=0; i < MSG_FAST_CONTEXT_POOL_SIZE; i++){
		this->GrpMsgContextPool[i]=0;
	}

	InitializeCriticalSection(&this->ContextTableCS);
	
}

// Free the pools and the head of the context mapping buffers.
// Note, not protected so all buffer ownership must already
// have reverted.
VOID FiniTablePool(LPDPLAYI_DPLAY this)
{
	UINT i;
	PVOID pFree;
	
	for(i=0;i<MSG_FAST_CONTEXT_POOL_SIZE;i++){
		while(this->GrpMsgContextPool[i]){
			pFree=this->GrpMsgContextPool[i];
			this->GrpMsgContextPool[i]=*((PVOID *)this->GrpMsgContextPool[i]);
			DPMEM_FREE(pFree);
		}
	}
	DeleteCriticalSection(&this->ContextTableCS);
}

// Initializes the ContextTable.  The context table is an array of MSGCONTEXTENTRY's
// each one is used to map a DPLAY send context to the SP's internal context.  Entries
// are either a single entry or a list.  In the case of a list, a pointer to the list
// is entered into the CONTEXTENTRY.  Lists are allocated from the TablePool.
HRESULT InitContextTable(LPDPLAYI_DPLAY this)
{
	INT i;

	// Allocate the context mapping table
	this->pMsgContexts=(PMSGCONTEXTTABLE)DPMEM_ALLOC(sizeof(MSGCONTEXTTABLE)+
									INIT_CONTEXT_TABLE_SIZE * sizeof(MSGCONTEXTENTRY));

	if(!this->pMsgContexts){
		return DPERR_OUTOFMEMORY;
	}

	// Initialize the context mapping table.
	// this->pMsgContexts->nUnique=0; //by ZERO_INIT
	this->pMsgContexts->nTableSize=INIT_CONTEXT_TABLE_SIZE;

	this->pMsgContexts->iNextAvail=0;
	for(i=0;i<INIT_CONTEXT_TABLE_SIZE-1;i++){
		this->pMsgContexts->MsgContextEntry[i].iNextAvail=i+1;
	}
	this->pMsgContexts->MsgContextEntry[INIT_CONTEXT_TABLE_SIZE-1].iNextAvail = LIST_END;

	return DP_OK;
}

// FiniContextTable - uninitialize the context table
VOID FiniContextTable(LPDPLAYI_DPLAY this)
{
	if(this->pMsgContexts){
		DPMEM_FREE(this->pMsgContexts);
		this->pMsgContexts=NULL;
	}	
}

// verify the context is the one allocated, i.e. hasn't been recycled.
BOOL VerifyContext(LPDPLAYI_DPLAY this, PVOID Context)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	if(iEntry > Table.nTableSize-1){
		return FALSE;
	}

	if(Entry[iEntry].nUnique && 
	   (Entry[iEntry].nUnique == ((DWORD_PTR)Context & CONTEXT_UNIQUE_MASK))
	  )
	{
		return TRUE;
	} else {
		return FALSE;
	}

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// Retrieves a pointer the array of values stored in a context, and the 
// number of entries in the array
HRESULT ReadContextList(
	LPDPLAYI_DPLAY this, 
	PVOID Context, 
	PAPVOID *ppapvContextArray, 	//output
	PUINT lpnArrayEntries,   		//output
	BOOL  bVerify					// whether we need to verify the Context
	
)
{
	HRESULT hr=DP_OK;
	
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);

	if(bVerify && !VerifyContext(this,Context)){
		hr=DPERR_GENERIC;
		goto EXIT;
	}

	*lpnArrayEntries=Entry[iEntry].nContexts;
//	if(*lpnArrayEntries==1){
//		*ppapvContextArray=(PAPVOID)(&Entry[iEntry].pv);
//	} else {
		*ppapvContextArray=Entry[iEntry].papv;
//	}

EXIT:	
	LeaveCriticalSection(&this->ContextTableCS);

	return hr;

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// Sets a pointer the array of values stored in a context, and the 
// number of entries in the array
HRESULT WriteContextList(
	LPDPLAYI_DPLAY this, 
	PVOID Context, 
	PAPVOID papvContextArray, 	
	UINT    nArrayEntries		
)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);
	Entry[iEntry].nContexts=nArrayEntries;
	Entry[iEntry].papv = papvContextArray;
	LeaveCriticalSection(&this->ContextTableCS);
	
	return DP_OK;

	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}


// Retrieves a pointer the array of values stored in a context, and the 
// number of entries in the array 
PSENDPARMS pspFromContext(
	LPDPLAYI_DPLAY this, 
	PVOID Context,
	BOOL  bAddRef
)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry (Table.MsgContextEntry)
	#define iEntry ((UINT_PTR)(Context)&CONTEXT_INDEX_MASK)

	PSENDPARMS psp;
	UINT count;
	
	ASSERT(iEntry <= Table.nTableSize);

	EnterCriticalSection(&this->ContextTableCS);
	if(VerifyContext(this,Context)){
		psp=Entry[iEntry].psp;
		if(bAddRef){
			count=pspAddRefNZ(psp); 
			if(count==0){
				psp=NULL; // object already being freed.
			}
		}
	} else {
		psp=NULL;
	}
	LeaveCriticalSection(&this->ContextTableCS);

	return psp;
	
	#undef iEntry
	#undef pTable
	#undef Table
	#undef Entry
}

// allocates a list of contexts from the Table Pool.
PAPVOID AllocContextList(LPDPLAYI_DPLAY this, UINT nArrayEntries)
{
	PAPVOID papv;

	ASSERT(nArrayEntries);

	EnterCriticalSection(&this->ContextTableCS);
	
	if((nArrayEntries <= MSG_FAST_CONTEXT_POOL_SIZE) &&
	   (papv=(PAPVOID)this->GrpMsgContextPool[nArrayEntries]))
	{
		this->GrpMsgContextPool[nArrayEntries]=*(PVOID *)this->GrpMsgContextPool[nArrayEntries];
		LeaveCriticalSection(&this->ContextTableCS);
	}
	else 
	{
		LeaveCriticalSection(&this->ContextTableCS);
		papv=DPMEM_ALLOC(nArrayEntries*sizeof(PVOID));
	}
	return papv;
}

// releases the memory associated with a context list
VOID FreeContextList(LPDPLAYI_DPLAY this, PAPVOID papv, UINT nArrayEntries)
{
	#define pNext ((PVOID *)papv)

	if(nArrayEntries){
		if(nArrayEntries > MSG_FAST_CONTEXT_POOL_SIZE){
			ASSERT(0);
			DPMEM_FREE(papv);
		} else {
			EnterCriticalSection(&this->ContextTableCS);
			*pNext = this->GrpMsgContextPool[nArrayEntries];
			this->GrpMsgContextPool[nArrayEntries]=(PVOID)papv;
			LeaveCriticalSection(&this->ContextTableCS);
		}
	}
	#undef pNext
}

// returns a context list entry to the free pool.
VOID ReleaseContextList(LPDPLAYI_DPLAY this, PVOID Context)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry Table.MsgContextEntry
	#define iEntry ((UINT_PTR)Context&CONTEXT_INDEX_MASK)

	PAPVOID papv;
	UINT 	nContexts;

	EnterCriticalSection(&this->ContextTableCS);

		// save this so we can do free outside lock.
		nContexts=Entry[iEntry].nContexts;
		papv=Entry[iEntry].papv;

		Entry[iEntry].iNextAvail=Table.iNextAvail;
		Table.iNextAvail=(DWORD)iEntry;

		Entry[iEntry].nUnique=0;  // flags not in use.
	
	LeaveCriticalSection(&this->ContextTableCS);

	if(nContexts){
		FreeContextList(this, papv,nContexts);
	}
	
	
	#undef iEntry
	#undef Entry
	#undef Table
	#undef pTable
}

// allocates a context table of the appropriate size and returns the handle
// to use to manipulate the table.
PVOID AllocateContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nArrayEntries)
{
	#define pTable (this->pMsgContexts)
	#define Table (*pTable)
	#define Entry Table.MsgContextEntry
	#define NewTable (*pNewTable)

	UINT              i;
	UINT_PTR		  iEntry;
	PMSGCONTEXTTABLE  pNewTable;

	// First find a free context table entry.
	EnterCriticalSection(&this->ContextTableCS);

	if(Table.iNextAvail == LIST_END) {
		// Need to re-allocate the table.

		// Allocate the new table.

		// Allocate the context mapping table
		pNewTable=(PMSGCONTEXTTABLE)DPMEM_ALLOC(sizeof(MSGCONTEXTTABLE)+
				(Table.nTableSize+CONTEXT_TABLE_GROW_SIZE) * sizeof(MSGCONTEXTENTRY));

		if(!pNewTable){
			LeaveCriticalSection(&this->ContextTableCS);
			return NULL;
		}
		
		memcpy(pNewTable, pTable, Table.nTableSize*sizeof(MSGCONTEXTENTRY)+sizeof(MSGCONTEXTTABLE));

		DPMEM_FREE(pTable);

		NewTable.iNextAvail=NewTable.nTableSize;
		NewTable.nTableSize=NewTable.nTableSize+CONTEXT_TABLE_GROW_SIZE;
		
		for(i=NewTable.iNextAvail; i < NewTable.nTableSize-1; i++){
			NewTable.MsgContextEntry[i].iNextAvail=i+1;
		}
		NewTable.MsgContextEntry[NewTable.nTableSize-1].iNextAvail = LIST_END;
		
		pTable=pNewTable;

	}

	iEntry=Table.iNextAvail;
	Table.iNextAvail=Entry[Table.iNextAvail].iNextAvail;

	LeaveCriticalSection(&this->ContextTableCS);
	
	// If this is an array, look for array buffers of the pooled size, else allocate

	Entry[iEntry].nContexts = nArrayEntries;
	Entry[iEntry].psp       = psp;


	Entry[iEntry].papv = AllocContextList(this, nArrayEntries);
	
	if(!Entry[iEntry].papv){
		ASSERT(0);
		// couldn't get a context list, free the entry and bail.
		EnterCriticalSection(&this->ContextTableCS);
		Entry[iEntry].iNextAvail=Table.iNextAvail;
		Table.iNextAvail=(DWORD)iEntry;
		LeaveCriticalSection(&this->ContextTableCS);
		return NULL;
	}

	EnterCriticalSection(&this->ContextTableCS);
	
	// increment uniqueness, never zero.
	do {
		pTable->nUnique += UNIQUE_ADD;
	} while(!pTable->nUnique);

	Entry[iEntry].nUnique=pTable->nUnique;

	LeaveCriticalSection(&this->ContextTableCS);

	ASSERT(((iEntry+Entry[iEntry].nUnique)&CONTEXT_INDEX_MASK) == iEntry);

	return ((PVOID)(iEntry+Entry[iEntry].nUnique));
	
	#undef pTable
	#undef Table
	#undef NewTable
	#undef Entry
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\mcontext.h ===
/*==========================================================================
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mcontext.h
 *  Content:	structures for message context mapping for SendEx
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *	12/8/97		aarono      Created
 *  2/13/98     aarono      got rid of special case for 1 context
 *
 *  Abstract:
 *
 *  Maintains a table of context mappings for messages being sent
 *  asynchronously.  Also keeps track of group sends vs. directed
 *  sends so that cancel can cancel them together.
 * 
 ***************************************************************************/
#ifndef _MSG_CONTEXT_H_
#define _MSG_CONTEXT_H_
		
#define MSG_FAST_CONTEXT_POOL_SIZE  20

#define INIT_CONTEXT_TABLE_SIZE     16
#define CONTEXT_TABLE_GROW_SIZE     16

#define N_UNIQUE_BITS 16
#define UNIQUE_ADD (1<<(32-N_UNIQUE_BITS))
#define CONTEXT_INDEX_MASK (UNIQUE_ADD-1)
#define CONTEXT_UNIQUE_MASK (0xFFFFFFFF-CONTEXT_INDEX_MASK)

#define LIST_END 0xFFFFFFFF

typedef PVOID (*PAPVOID)[]; // pointer to array of void pointers

typedef struct _SENDPARMS SENDPARMS, *PSENDPARMS, *LPSENDPARMS;

typedef struct _MsgContextEntry {
	PSENDPARMS psp;
	DWORD      nUnique;
	DWORD	   nContexts;
	union {
		PAPVOID   papv;	 
		UINT      iNextAvail;
	};	
} MSGCONTEXTENTRY, *PMSGCONTEXTENTRY;

typedef struct _MsgContextTable {
	UINT nUnique;
 	UINT nTableSize;
 	UINT iNextAvail;
 	MSGCONTEXTENTRY MsgContextEntry[0];
} MSGCONTEXTTABLE, *PMSGCONTEXTTABLE;

VOID InitTablePool(LPDPLAYI_DPLAY this);
VOID FiniTablePool(LPDPLAYI_DPLAY this);


//Internal
HRESULT InitContextTable(LPDPLAYI_DPLAY this);
VOID FiniContextTable(LPDPLAYI_DPLAY this);
PAPVOID AllocContextList(LPDPLAYI_DPLAY this, UINT nArrayEntries);
VOID FreeContextList(LPDPLAYI_DPLAY this, PAPVOID pList, UINT nArrayEntries);

//External
HRESULT ReadContextList(LPDPLAYI_DPLAY this, PVOID Context, PAPVOID *lplpContextArray, PUINT lpnArrayEntries,BOOL bVerify);
HRESULT WriteContextList(LPDPLAYI_DPLAY this, PVOID Context, PAPVOID papvContextArray, 	UINT nArrayEntries);
VOID ReleaseContextList(LPDPLAYI_DPLAY this, PVOID Context);
PVOID AllocateContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nArrayEntries);
PSENDPARMS pspFromContext(LPDPLAYI_DPLAY this, 	PVOID Context, BOOL bAddRef);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\msgmem.c ===
/*==========================================================================
*
*  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
*
*  File:       msgmem.c
*  Content:	   message memory management
*  History:
*   Date		By		Reason
*   ====		==		======
*  12/31/97   aarono    Original
*
*
* Abstract
* --------
* (AO 12-31-97)
* Contention is that using the heap manager is not actually significant
* vs doing our own memory management for message buffers.  I do not
* currently support this contention and believe that directplay should not
* call HeapAlloc or GlobalAlloc in the hot path.  In order to prove this
* though I will first use HeapAlloc and GlobalAlloc for a profile run
* through these routines.  If the per hit is significant for a server type
* configuration then we will write our own packet memory manager. If the
* perf hit of using system heap is negligible this fill will be left as is.
***************************************************************************/

#include "dplaypr.h"

void * MsgAlloc( int size )
{
	return DPMEM_ALLOC(size);
}

void MsgFree (void *context, void *pmem)
{
	DPMEM_FREE(pmem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\namesrv.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       namesrv.c
 *  Content:	name management code
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  1/96		andyco	created it
 *	4/15/96		andyco	added handledeadnameserver
 *	6/19/96		kipo	Fixed a problem in GrowTable() with MemReAlloc() returning
 *						NULL, which caused a memory leak and possibly a crash if someone
 *						was not expecting this->pNameTable to ever be NULL.
 *	6/22/96		andyco	indicate whether we're asking for player or group id
 *						in sendnsnewidrequest.
 *	8/1/96		andyco	changed dp_destroyplayer to internaldestroy
 *	8/6/96		andyco	version in commands.  extensible on the wire support. 
 *						id mangling.
 *	8/8/96		andyco	 get playerid timeout from sp (by calling getdefaultimeout).
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 *	10/14/96	andyco	check nametable index BEFORE using it...bug 3946
 *	12/18/96	andyco	moved bogus assert on additemtonametable 
 *  01/17/97    sohailm now we send player flags in request player id message
 *	1/15/98		andyco	cleaned up handledeadnameserver - no longer nukes
 *						old sysplayer.
 *  3/14/97     sohailm integrated security code into SendNewIDRequest, 
 *                      added functions IsValidID and DataFromID. Updated function NameFromID
 *                      to use IsValidID.
 *	3/17/97		myronth	Fixed AddItemToNameTable to work from lobby objects
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Updated SendCreateMessage call to pass NULL for session password
 *  3/28/97     sohailm Request group id message is being signed now if session is secure
 *  4/14/97     sohailm Updated calls to SetupCredentials() to reflect change in params.
 *	5/8/97		myronth	Fixed comment to better reflect the state of affairs
 *  5/12/97     sohialm Updated SendNSNewIDRequest() to process the new PLAYERIDREPLY format
 *	5/17/97		kipo	There was a bug in SendNSNewIDRequest() where it was setting
 *						the ghReplyProcessed event twice on the way out,
 *						which would let handler.c in, trashing the buffer
 *						that SendNSNewIDRequest() was using.
  *	5/18/97		andyco	changed nameserver migration to always send delete / create messages
 *						for new host. nuke item in table if  we add something new
 *						to non-empty spot.
 *	6/16/97		andyco	reset ping timer when we become host
 *  6/22/97     sohailm added support to store security desc in the dplay object on the client
 *	8/19/97		myronth	Send lobby system message when we become the host
 *	8/19/97		myronth	Changed to different lobby system message function
 *	9/29/97		myronth	Fixed group ID on DeleteGroup msgs generated by the
 *						corrupt nametable fixup code (#12533)
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/29/97	myronth	Nametable corruption fixes (#15234, #15254)
 *	12/29/97	sohailm	Don't migrate the host in client server or secure sessions (#15224)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	Changed PRV_SendStandardSystemMessage
 *	1/27/98		myronth	Moved debug spew for nametable corruption
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  2/18/98     aarono  changed to direct calls to protocol
 *  8/04/99     aarono  added HOSTMIGRATION notification for DirectVoice
 *  8/10/99		rodtoll	Fixed host migration notification (For DXVoice)
 * 04/06/00     rodtoll Updated to match new approach to having only 1 voice server and 1 client attached to object 
 * 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
 ***************************************************************************/


#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"NS_AllocNameTableEntry"


HRESULT GrowTable(LPDPLAYI_DPLAY this) 
{
	LPVOID	pvTempNameTable;

    pvTempNameTable = DPMEM_REALLOC(this->pNameTable,sizeof(NAMETABLE)*this->uiNameTableSize*2);
    if (!pvTempNameTable) 
    {
    	DPF_ERR("COULD NOT GROW NAME TABLE");	
        return E_OUTOFMEMORY;
    }

    this->pNameTable = pvTempNameTable;
    this->uiNameTableSize *= 2;
    DPF(1,"Grew name table to %d entries\n",this->uiNameTableSize);
    return DP_OK;

}

// this code only executes on the NameServer

DPID MangleID(DWORD index,DWORD dwUnique,DWORD dwKey)
{
	DPID id;

    // construct a mangled id, = dwUnique<<16 | index ^ key
    id = dwUnique<<16;
    id |= index;
   	id ^= dwKey;

	return id;
} // MangleID

HRESULT WINAPI NS_AllocNameTableEntry(LPDPLAYI_DPLAY this,DWORD * pID)
{
    DWORD index;
    BOOL bFoundSlot=FALSE;
    HRESULT hr = DP_OK;
	BOOL bInvalidID = TRUE; // set to FALSE only when we decide this is not
							// not a restricted id
	
    // find the first unoccupied bucket
    index = this->uiNameTableLastUsed;

    // search fron lastused to end. we do this to keep the
    // bucket usage uniformly distributed in the list (i.e. don't
    // always search from beginning for empty slot...)
    while (!bFoundSlot && (index < this->uiNameTableSize))
    {
        // is this slot empty?
        bFoundSlot = (0 == this->pNameTable[index].dwItem);
        if (!bFoundSlot) index++;
    }
    if (!bFoundSlot) 
    {
        index = 0;
        // search from beginning to last used
        while (!bFoundSlot && (index < this->uiNameTableLastUsed))
        {
            // is this slot empty?
            bFoundSlot = (0 == this->pNameTable[index].dwItem);
            if (!bFoundSlot) index++;
        }
            	
    }
    if (!bFoundSlot) 
    {
    	hr = GrowTable(this);
        if (FAILED(hr)) 
        {
                return hr;
        }
        // try again
    	return NS_AllocNameTableEntry(this,pID);
    }

    // make sure we don't reuse b4 client has time to set item
    this->pNameTable[index].dwItem = NAMETABLE_PENDING;
	this->pNameTable[index].dwUnique++;

    this->uiNameTableLastUsed = index;

    while (bInvalidID)
    {
		// mangle it!
		*pID = MangleID(index,this->pNameTable[index].dwUnique,(DWORD)this->lpsdDesc->dwReserved1);

		// EEEK!  make sure the mangled id is not one of our reserved id's 
		if ( (DPID_SERVERPLAYER == *pID ) || (DPID_ALLPLAYERS == *pID) || 
			(DPID_UNKNOWN == *pID) )
		{
			// bump the unique count, and try again
			DPF(2,"NS_AllocNameTableEntry  --  found invalid id - trying again");
			this->pNameTable[index].dwUnique++;
		}
		else 
		{
			// this id is ok
			bInvalidID = FALSE;
		}
    
    } // while
	
    return DP_OK;
        
} // NS_AllocNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"SendNSNewIDRequest"

/*
 ** CopySecurityDesc
 *
 *  CALLED BY: SendNSNewIDRequest()
 *
 *  PARAMETERS: pSecDescDest - security description ptr (destination)
 *				pSecDescSrc - security descrption ptr (source, UNICODE)
 *				bAnsi - ANSI or UNICODE 
 *
 *  DESCRIPTION:  Copies a security description while allocating memory for SSPIProvider 
 *                and CAPIProvider strings. These strings need to be freed by the calling 
 *                function.
 *
 *  RETURNS: DP_OK, E_OUTOFMEMORY
 *
 */
HRESULT CopySecurityDesc(LPDPSECURITYDESC pSecDescDest, 
                         LPCDPSECURITYDESC pSecDescSrc, BOOL bAnsi)
{
    HRESULT hr;

    ASSERT(pSecDescDest && pSecDescSrc);

    memcpy(pSecDescDest, pSecDescSrc, sizeof(DPSECURITYDESC));

    if (bAnsi)
    {
        hr = GetAnsiString(&(pSecDescDest->lpszSSPIProviderA), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetAnsiString(&(pSecDescDest->lpszCAPIProviderA), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }
    else
    {
        hr = GetString(&(pSecDescDest->lpszSSPIProvider), pSecDescSrc->lpszSSPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
        hr = GetString(&(pSecDescDest->lpszCAPIProvider), pSecDescSrc->lpszCAPIProvider);
        if (FAILED(hr))
        {
            goto ERROR_EXIT;
        }
    }

    // success
    return DP_OK;

ERROR_EXIT:

    FreeSecurityDesc(pSecDescDest, bAnsi);
    return hr;
} // CopySecurityDesc

// copies the security desc into the dplay object
HRESULT StoreSecurityDesc(LPDPLAYI_DPLAY this, LPCDPSECURITYDESC pInSecDesc)
{
    LPDPSECURITYDESC pSecDesc;
    HRESULT hr;

    pSecDesc = DPMEM_ALLOC(sizeof(DPSECURITYDESC));
    if (!pSecDesc)
    {
        DPF_ERR("Failed to store security desc - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    hr = CopySecurityDesc(pSecDesc, pInSecDesc, FALSE);
    if (FAILED(hr))
    {
        DPF_ERRVAL("Failed to copy security desc - hr=0x%08x",hr);
        goto ERROR_EXIT;
    }

    DPF(1,"SSPI provider: %ls",pSecDesc->lpszSSPIProvider);
    if (pSecDesc->lpszCAPIProvider)
    {
        DPF(1,"CAPI provider: %ls",pSecDesc->lpszCAPIProvider);
    }
    else
    {
        DPF(1,"CAPI provider: Microsoft's RSA Base Provider");
    }

    // success
    this->pSecurityDesc = pSecDesc;
    return DP_OK;

    // NOT a fall through

ERROR_EXIT:

    if (pSecDesc) 
    {
        FreeSecurityDesc(pSecDesc,FALSE);
        DPMEM_FREE(pSecDesc);
    }
    return hr;
}

// send a request for a new id to the namesrvr
// reply will include the id
// hmm, we should send the player stuff w/ the id request,  so ns doesn't get out of sync
HRESULT SendNSNewIDRequest(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer) 
{
    LPMSG_REQUESTPLAYERID pmsg; // the request we will send
    LPMSG_PLAYERIDREPLY pReply=NULL;
	DWORD dwMessageSize;
    HRESULT hr=DP_OK;
	LPBYTE pBuffer;
	DWORD dwTimeout, dwVersion;
    BOOL fLogin=FALSE;
		
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_REQUESTPLAYERID);
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	pmsg = (LPMSG_REQUESTPLAYERID)(pBuffer + this->dwSPHeaderSize);

	// set up msg
    SET_MESSAGE_HDR(pmsg);
    if (fPlayer) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTPLAYERID);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_REQUESTGROUPID);

    // need to send flags to name server so it can verify permissions
    // before creating an ID for this player
    pmsg->dwFlags = ((LPDPLAYI_PLAYER)dwItem)->dwFlags;
	
	// get the appropriate timeout
	dwTimeout = GetDefaultTimeout( this, TRUE);
	dwTimeout *= DP_GETID_SCALE;

	if(dwTimeout < 30000){
		dwTimeout=30000;
	}

	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));

	DPF(2,"sending new player id request :: flags = %d,timeout = %d\n",((LPDPLAYI_GROUP)dwItem)->dwFlags,dwTimeout);

	if(this->pSysPlayer){
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
	}	

	SetupForReply(this, DPSP_MSG_REQUESTPLAYERREPLY);
	
    // call send
	// note that this->pNameServer will be NULL when we're requesting our
	// sysplayers id.  it will be non-null for subsequent requests.
	hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pBuffer,
						dwMessageSize,DPSEND_GUARANTEED,FALSE);

	DPMEM_FREE(pBuffer);
	if (FAILED(hr)) 
	{
		DPF_ERR("could not send newplayerid request");
		UnSetupForReply(this);
		return hr;
	}
	
	#ifdef DEBUG
	ASSERT(1 == gnDPCSCount); // this needs to be 1 now, so we can drop the lock below 
							  // and receive our reply on the sp's thread
	#endif 
	// we're protected by the service crit section here, so we can leave dplay
	// (so reply can be processed)
	LEAVE_DPLAY();

    // wait for the answer
    hr = WaitForReply(this,(PCHAR *)&pReply,NULL,dwTimeout);

	ENTER_DPLAY();

	if(FAILED(hr)){
		goto CLEANUP_EXIT;
	}

	ASSERT(pReply);

    // get the message version
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReply);

	// In DX6 and later versioned messages, there is a return code in the
	// reply.  We need to make sure it wasn't an error (#15891)
	if(dwVersion >= DPSP_MSG_DX6VERSION)
	{
		// If we fail, 
		if(FAILED(pReply->hr))
		{
			hr = pReply->hr;
			goto CLEANUP_EXIT;
		}
	}

    *pid = pReply->dwID;

    // If server is DX5 or later and is secure, the reply will contain a security 
	// description detailing the security packages needed for establishing a secure channel
	// with the server.
    if (( dwVersion >= DPSP_MSG_DX5VERSION ) && (pReply->dwSSPIProviderOffset))
    {
        // fix up pointers in security desc in the reply buffer        
		pReply->dpSecDesc.lpszSSPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwSSPIProviderOffset);
		if (pReply->dwCAPIProviderOffset)
		{
			pReply->dpSecDesc.lpszCAPIProvider = (LPWSTR)((LPBYTE)pReply + pReply->dwCAPIProviderOffset);
		}

        hr = StoreSecurityDesc(this, &(pReply->dpSecDesc));
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to store security desc: hr=0x%08x",hr);
            goto CLEANUP_EXIT;
        }

        // we need to login
        fLogin = TRUE;

        // set the system player id here, so authentication routines can use it
    	ASSERT(this->pSysPlayer);
        this->pSysPlayer->dwID = *pid;

		// Initialize SSPI and CAPI providers
		hr = LoadSecurityProviders(this, SSPI_CLIENT);
        if (FAILED(hr))
        {
            DPF_ERR("Failed to setup security providers");

			// let handler.c continue
            goto CLEANUP_EXIT;
        }
    }

    if (fLogin)
    {
        hr = Login(this);
        if (FAILED(hr))
        {
            DPF_ERR("User authentication failed...Exiting");
        }
    }


    DPF(2,"received id # %d from name server\n",*pid);

	if(this->pSysPlayer){
		ExecutePendingCommands(this);
	}	

CLEANUP_EXIT:	
    // done
    if(pReply){
		FreeReplyBuffer((PCHAR)pReply);
	}	
    return hr;

} // SendNSNewIDRequest 
	
#undef DPF_MODNAME
#define DPF_MODNAME	"AddItemToNameTable"

// NukeNameTable (below) is about to nuke a player from our (corrupted) nametable
// this routine puts a delete message for that player in our apps message q
// we build a DPSP_MSG_PLAYERMGMT w/ just enough info for BuildDeleteMessage to 
// do it's thing
void QDeleteMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	
	if (fPlayer)
	{
		DPF(5, "Queueing DESTROYPLAYER message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYER);
		msg.dwPlayerID = pPlayer->dwID;
	}
	else
	{
		DPF(5, "Queueing DESTROYGROUP message id = %lx", pPlayer->dwID);
		SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUP);
		msg.dwGroupID = pPlayer->dwID;
	}
	
	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteMessage


void QDeletePlayerFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_PLAYER pPlayer)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYERFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pPlayer->dwID;
	
	DPF(5, "Queueing DELETEPLAYERFROMGROUP message idGroupFrom = %lx, idPlayer = %lx", pGroup->dwID, pPlayer->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeletePlayerFromGroupMessage


void QDeleteGroupFromGroupMessage(LPDPLAYI_DPLAY this,
		LPDPLAYI_GROUP pGroup, LPDPLAYI_GROUP pSubgroup)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;
	
	DPF(5,"Q'ing app message for player being removed from corrupt nametable group");

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEGROUPFROMGROUP);
	msg.dwGroupID = pGroup->dwID;
	msg.dwPlayerID = pSubgroup->dwID;
	
	DPF(5, "Queueing DELETEGROUPFROMGROUP message idGroupFrom = %lx, idGroup = %lx", pGroup->dwID, pSubgroup->dwID);

	// message is now a ready to go!
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
		
	return ;
	
} // QDeleteGroupFromGroupMessage


void QDeleteAndDestroyMessagesForPlayer(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom)
    {
		// Only walk the list if it's not the system group	
		if(!(pGroupFrom->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			// Next walk the list of players in the group
			pGroupnode = pGroupFrom->pGroupnodes;
			while(pGroupnode)
			{
				if(pGroupnode->pPlayer->dwID == pPlayer->dwID)
				{
					// Queue the DeletePlayerFromGroup message
					QDeletePlayerFromGroupMessage(this, pGroupFrom, pGroupnode->pPlayer);
				}

				// Move to the next one
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Now queue the final destroy message for the player
	QDeleteMessage(this,pPlayer,TRUE);

} // QDeleteAndDestroyMessagesForPlayer


void QDestroyMessageForGroupAndFamily(LPDPLAYI_DPLAY this, LPDPLAYI_GROUP pGroup)
{
	LPDPLAYI_GROUPNODE	pGroupnode = NULL;
	LPDPLAYI_SUBGROUP	pSubgroup = NULL;
	LPDPLAYI_GROUP		pGroupFrom = NULL;


	// First walk the list of groups looking for shortcuts to the group
	// which is going to be destroyed.
    pGroupFrom=this->pGroups;
    while(pGroupFrom && (pGroup->dwFlags & DPLAYI_PLAYER_PLAYERINGROUP))
    {
		// Walk the subgroups for this group and see if the group being
		// destroyed is among them.  If it is, send a message.		
		pSubgroup = pGroupFrom->pSubgroups;
		while(pSubgroup)
		{
			// If the ID's match, send the message, but also
			// make sure we don't send a DeleteGroupFromGroup message for
			// a real parent/child relationship
			if((pSubgroup->pGroup->dwID == pGroup->dwID) &&
				(pGroupFrom->dwID != pGroup->dwIDParent))
			{
				QDeleteGroupFromGroupMessage(this, pGroupFrom, pGroup);
			}

			// Move to the next one
			pSubgroup = pSubgroup->pNextSubgroup;
		}

		// Move to the next group
		pGroupFrom = pGroupFrom->pNextGroup;
	}

	// Next walk the list of players in the group
    pGroupnode = pGroup->pGroupnodes;
    while (pGroupnode)
    {
		// Queue the DeletePlayerFromGroup message
		QDeletePlayerFromGroupMessage(this, pGroup, pGroupnode->pPlayer);

		// Move to the next one
		pGroupnode = pGroupnode->pNextGroupnode;
	}

	// Next walk the list of subgroups (this includes both childres & shortcuts)
	pSubgroup = pGroup->pSubgroups;
	while(pSubgroup)
	{
		// See if the group is just a shortcut or a real child
		if(!(pSubgroup->dwFlags & DPGROUP_SHORTCUT))
		{
			// It's a real child, so just setup the destroy messages
			// NOTE: This goes recursive right here
			QDestroyMessageForGroupAndFamily(this, pSubgroup->pGroup);
		}
		else
		{
			// It's a shortcut, so just queue the deletegroupfromgroup message
			QDeleteGroupFromGroupMessage(this, pGroup, pSubgroup->pGroup);
		}

		// Move to the next one
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	// Now queue the destroy message for the group itself
	QDeleteMessage(this,(LPDPLAYI_PLAYER)pGroup,FALSE);

} // QDestroyMessageForGroupAndFamily


void NukeNameTableItem(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	HRESULT hr;
	BOOL fPlayer;
	LPDPLAYI_GROUP pGroup;
	

    TRY
    {
		if (VALID_DPLAY_PLAYER(pPlayer)) fPlayer = TRUE;
		else 
		{
			pGroup = (LPDPLAYI_GROUP)pPlayer;
			if (!VALID_DPLAY_GROUP(pGroup))
			{
				DPF_ERR("found item in nametable - it's not a player or a group - AAAAGH - it's a creepy monster");
				return;
			}
		 	fPlayer = FALSE;
		}
		DPF(0," invalid item found - fPlayer = %d  id = %lx\n",fPlayer,pPlayer->dwID);		
	}
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		ASSERT(FALSE); // ACK!
		return ;
    }

	// now, delete it!	
	if (fPlayer)
	{
		// put a  mesage in the apps message q that the player is being deleted
		QDeleteAndDestroyMessagesForPlayer(this,pPlayer);

		// destroy the player
		hr = InternalDestroyPlayer(this,pPlayer,FALSE,FALSE);	
	}
	else
	{
		// put messages in the apps message q that the group and all it's
		// children (and shortcuts) are being destroyed
		QDestroyMessageForGroupAndFamily(this, (LPDPLAYI_GROUP)pPlayer);
		
		// destroy the group
		hr = InternalDestroyGroup(this,(LPDPLAYI_GROUP)pPlayer,FALSE);
	}
	if (FAILED(hr))
	{
		DPF(0,"COULD NOT NUKE ITEM hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	return;
	
}  // NukeNameTableItem


HRESULT AddItemToNameTable(LPDPLAYI_DPLAY this,DWORD_PTR dwItem,DWORD *pid,BOOL fPlayer,DWORD dwLobbyID)
{
    HRESULT hr=DP_OK;
	DWORD dwUnmangledID;
    DWORD index,unique;
  	BOOL bLocal;
	LPDPLAYI_PLAYER pPlayer = (LPDPLAYI_PLAYER)dwItem;

	// we can cast either a group or a player to a player, since the flags are 
	// in the same place...
	bLocal = (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE : FALSE;

	// non-local players don't need a new index
	if(bLocal)
	{
	  	// If this object is lobby owned, we won't be a nameserver,
		// but we always want to alloc the ID locally anyway
		if(IS_LOBBY_OWNED(this))
		{
			hr = NS_AllocNameTableEntry(this, pid);
		}
		else
		{
			ASSERT(this->pSysPlayer);

			// ask ns for an index
			// if we're the namesrvr, just go get it
			if(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)
			{
				hr = NS_AllocNameTableEntry(this,pid);    	
			}
			else 
			{
				hr = SendNSNewIDRequest(this,dwItem,pid,fPlayer);
			}
		}

		if (FAILED(hr)) 
		{
			DPF_ERR("could not get new id for item");
			return hr;	
		}
	}

	dwUnmangledID = *pid ^ (DWORD)this->lpsdDesc->dwReserved1;
	
	// if it's not local, assume pid was set when / wherever item was created
    index = dwUnmangledID & INDEX_MASK; 
	unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

	// do we need to grow the table?
	// if so, keep growing it until its big enough...
    while (index >= this->uiNameTableSize) 
    {
        hr = GrowTable(this);
        if (FAILED(hr)) 
        {
            return hr;
        }

    }

    if (index > this->uiNameTableSize ) 
    {
        ASSERT(FALSE); // ??? rut ro
        return E_UNEXPECTED;
    }

	// if there is already something here, we're in trouble.
	// this means we missed a system message (e.g. deleteplayer or deletegroup)
	// and our nametable is corrupt.  we will hope for the best, and delete the
	// item here. andyco.
	if (this->pNameTable[index].dwItem &&  (NAMETABLE_PENDING != this->pNameTable[index].dwItem))
	{
		DPF(5,"		!!!   NAMETABLE CORRUPTION DETECTED.  DPLAY WILL CORRECT ITSELF	!!!");
		NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
	} 

	this->pNameTable[index].dwItem = dwItem;
	this->pNameTable[index].dwUnique = unique;

	// If this is a lobby session, we need to make the ID be the lobby ID
	if(IS_LOBBY_OWNED(this))
	{
		hr = PRV_AddMapIDNode(this->lpLobbyObject, dwLobbyID, *pid);
		if(FAILED(hr))
		{
			DPF_ERRVAL("Unable to add an entry to the map table, hr = 0x%08x", hr);
			NukeNameTableItem(this,(LPDPLAYI_PLAYER)(this->pNameTable[index].dwItem));
			return hr;
		}

		// Fix the output dpid to be the lobby ID
		*pid = dwLobbyID;
	}

	return hr;
} // AddItemToNameTable

#undef DPF_MODNAME
#define DPF_MODNAME	"FreeNameTableEntry"

// mark this spot in the name table as unused
HRESULT FreeNameTableEntry(LPDPLAYI_DPLAY this,DWORD dpid)
{
    HRESULT hr=DP_OK;
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DWORD id;

	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return E_UNEXPECTED;
	}

	// don't get upset if they try to free the system group or server player id	
	if (DPID_ALLPLAYERS == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_ALLPLAYERS - ignoring");
		return DP_OK;
	}
	
	if (DPID_SERVERPLAYER == dpid)
	{
		DPF(8,"FreeNameTableEntry id == DPID_SERVERPLAYER - ignoring");
		return DP_OK;
	}
	
	
	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF_ERRVAL("Unable to unmap id %lu, not freeing nametable entry", dpid);
			ASSERT(FALSE);
			return DPERR_INVALIDPARAM;
		}
	}
	else
		id = dpid;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;
	
    index = dwUnmangledID & INDEX_MASK;
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	ASSERT(FALSE); 	// ACK!!!
    	// this should *NEVER* happen!
    	// should almost be an int 3 here ?
    	// andyco. 10/14/96
    	DPF_ERR("asked for element outside table!");
        return E_UNEXPECTED;
    }

    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF_ERR("asked for invalid element");
        return E_UNEXPECTED;	 
    }

    if (NAMETABLE_PENDING == this->pNameTable[index].dwItem)
    {
        // remove client info
        if (this->pNameTable[index].pvData)
        {
            DPMEM_FREE(this->pNameTable[index].pvData);
        }
    }

    this->pNameTable[index].dwItem = 0;
    this->pNameTable[index].pvData = NULL;

	// Now delete them from the map table if this is a lobby session
	if(IS_LOBBY_OWNED(this))
	{
		PRV_DeleteMapIDNode(this->lpLobbyObject, dpid);
	}

    return hr;
}// FreeNameTableEntry

#undef DPF_MODNAME
#define DPF_MODNAME	"IsValidID"

// check the element at location index in the nametable.
// (if its unique code matches) 
BOOL IsValidID(LPDPLAYI_DPLAY this,DWORD id) 
{	
	if (DPID_ALLPLAYERS == id)
	{
		// it's ok.  they tried to resolve the system group to a player
		DPF(8,"asked for id == DPID_ALLPLAYERS - failing");
		return FALSE;
	}
	
	if (DPID_SERVERPLAYER == id)
	{
		// it's ok.  they tried to resolve the server player to a group.
		DPF(8,"asked for id == DPID_SERVERPLAYER - failing");
		return FALSE;
	}
	
	if (!(this->lpsdDesc))
	{
		DPF(1,"unable to resolve player id - session closed");
		return FALSE;
	}	
	if (!(this->pNameTable))
	{
		DPF_ERR("ACK no name table !");
		ASSERT(FALSE); // should NEVER happen
		return FALSE;
	}

    return TRUE;

} // IsValidID

#undef DPF_MODNAME
#define DPF_MODNAME	"DataFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
LPVOID DataFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return NULL;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id))
        return NULL;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"DataFromID:asked for element outside table - id = %d!",id);
        return NULL;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"DataFromID:asked for element w/ invalid tag - id = %d!",id);
        return NULL;
    }

    return this->pNameTable[index].pvData;
} // DataFromID

#undef DPF_MODNAME
#define DPF_MODNAME	"NameFromID"

// extract the element at location index in the nametable.
// (if its unique code matches) 
DWORD_PTR NameFromID(LPDPLAYI_DPLAY this,DWORD dpid) 
{
    DWORD index;
    DWORD unique;
	DWORD dwUnmangledID;
	DPID id;

	// If this is a lobby session, we need to unmap the ID
	if(IS_LOBBY_OWNED(this))
	{
		if(!PRV_GetDPIDByLobbyID(this->lpLobbyObject, dpid, &id))
		{
			DPF(2, "Unable to unmap id %lu", dpid);
			return 0;
		}
	}
	else
		id = dpid;

    if (!IsValidID(this, id)) return 0;

	dwUnmangledID = id ^ (DWORD)this->lpsdDesc->dwReserved1;

    index = dwUnmangledID & INDEX_MASK; 
    unique = (dwUnmangledID & (~INDEX_MASK)) >> 16;

    if (index >= this->uiNameTableSize) 
    {
    	DPF(0,"NameFromID:asked for element outside table - id = %d!",id);
        return 0;
    }
    if (this->pNameTable[index].dwUnique != unique) 
    {
    	DPF(0,"NameFromID:asked for element w/ invalid tag - id = %d!",id);
        return 0;
    }

    return this->pNameTable[index].dwItem;
} // NameFromID
    
// return a dplay group corresponding to id.
// return null if id not valid
LPDPLAYI_GROUP GroupFromID(LPDPLAYI_DPLAY this,DWORD idGroupID) 
{
	if (DPID_ALLPLAYERS == idGroupID)
	{
		if (!this->pSysGroup)
		{
			DPF_ERR("System group not found");
			return NULL;	
		} 
		return this->pSysGroup;
	}
    return (LPDPLAYI_GROUP)NameFromID(this,idGroupID);	
} // GroupFromID
// return a dplay player corresponding to id.
// return null if id not valid
LPDPLAYI_PLAYER PlayerFromID(LPDPLAYI_DPLAY this,DWORD idPlayerID)
{
	if (DPID_SERVERPLAYER == idPlayerID)
	{
		if (!this->pServerPlayer)
		{
			DPF_ERR(" server player not found");
			return NULL;	
		} 
		return this->pServerPlayer;
	}
    return (LPDPLAYI_PLAYER)NameFromID(this,idPlayerID);		
} // PlayerFromID

DPID PlayerIDFromSysPlayerID(LPDPLAYI_DPLAY this,DPID dpidSysPlayer)
{
	LPDPLAYI_PLAYER pPlayerWalker=this->pPlayers;
	
	while(pPlayerWalker)
	{
		if(pPlayerWalker->dwIDSysPlayer == dpidSysPlayer){
			return pPlayerWalker->dwID;
		}
		pPlayerWalker = pPlayerWalker->pNextPlayer;
	}
	return 0;
}

// Someone is telling us they are the new nameserver.
HRESULT NS_HandleIAmNameServer(LPDPLAYI_DPLAY this,LPMSG_IAMNAMESERVER pmsg, LPVOID pvSPHeader)
{
	LPDPLAYI_PLAYER pPlayer;
	HRESULT hr;
	DPSP_DELETEPLAYERDATA dd;

	pPlayer=PlayerFromID(this, pmsg->dwIDHost);

	if(!pPlayer){
		return DPERR_INVALIDPLAYER;
	}

	if(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL){
		return DP_OK;
	}

	dd.idPlayer       = pPlayer->dwID;
	dd.dwFlags        = pPlayer->dwFlags;
	dd.lpISP          = this->pISP;

	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer, &dd);

	if(FAILED(hr)){
		DPF_ERR("SP Could Not Delete Player in preparation for flags change in NS_HandleIamNameServer\n");
	}

	pPlayer->dwFlags = ((pPlayer->dwFlags & DPLAYI_PLAYER_NONPROP_FLAGS) | pmsg->dwFlags);
	
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
	
	pPlayer->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;//paranoia
	this->pNameServer = pPlayer;

	// NOTE: blows away the header.  May not be compatible with all SPs.
	if(pPlayer->pvSPData){
		DPMEM_FREE(pPlayer->pvSPData);
	}

	pPlayer->pvSPData=DPMEM_ALLOC(pmsg->dwSPDataSize+1);
	if(!pPlayer->pvSPData){
		DPF_ERR("Ran out of memory trying to allocate spdata block\n");
		hr=DPERR_OUTOFMEMORY;
		return hr;
	}
	memcpy(pPlayer->pvSPData, pmsg->SPData, pmsg->dwSPDataSize);
	pPlayer->dwSPDataSize=pmsg->dwSPDataSize;
	
	hr = CallSPCreatePlayer(this,pPlayer,FALSE,pvSPHeader,FALSE);
	
	if(FAILED(hr)){
		DPF_ERR("SP Couldn't Recreate Player in NS_HandleIamNameServer\n");
		return hr;
	}
	
	this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;

	LEAVE_DPLAY();

	DVoiceNotify(this,DVEVENT_MIGRATEHOST,PlayerIDFromSysPlayerID(this,pPlayer->dwID),0, DVTRANSPORT_OBJECTTYPE_BOTH);
	
	ENTER_ALL();

	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return hr;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}
	
	
	LEAVE_SERVICE();
	
	return hr;

}


// the nameserver has migrated to this client
// we need to recreate our sysplayer as  the nameserver
// we don't actually destroy the sysplayer, we just call the sp's
// destroy for the old (non-nameserver) and then create for the
// new (nameserver)
HRESULT MakeMeNameServer(LPDPLAYI_DPLAY this)
{
    DPSP_DELETEPLAYERDATA dd;
	HRESULT hr;

	DPF(0,"the name server has migrated to this client!");
	ASSERT(this->pSysPlayer);

	if (!this->pSysPlayer)
		return E_FAIL;

	// call sp delete player
	if (this->pcbSPCallbacks->DeletePlayer)
    {
	    // call sp
		dd.idPlayer = this->pSysPlayer->dwID;
		dd.dwFlags = this->pSysPlayer->dwFlags;
		dd.lpISP = this->pISP;

 	 	hr = CALLSP(this->pcbSPCallbacks->DeletePlayer,&dd);
 	 	
		if (FAILED(hr)) 
		{
			DPF_ERR(" SP could not delete sysplayer in preparation for migration"); 
			ASSERT(FALSE);
			// keep trying...
		}
	}
	
	// free up the sp data
	if (this->pSysPlayer->pvSPData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPData);
		this->pSysPlayer->pvSPData = NULL;
	}
	
	if (this->pSysPlayer->pvSPLocalData) 
	{
		DPMEM_FREE(this->pSysPlayer->pvSPLocalData);	
		this->pSysPlayer->pvSPLocalData = NULL;
	}
	this->pSysPlayer->dwSPLocalDataSize = 0;
	this->pSysPlayer->dwSPDataSize = 0;

	// get the sp to make us a nameserver (poof - you're a nameserver!)	
	this->pSysPlayer->dwFlags |= DPLAYI_PLAYER_NAMESRVR;
	// now, call the sp to create our nameserver
	hr = CallSPCreatePlayer(this,this->pSysPlayer,TRUE,NULL,FALSE);
	if (FAILED(hr))
	{
		DPF(0,"could not migrate nameserver - sp create player failed hr = 0x%08lx\n",hr);
		DPF(0,"game play should continue normally, but there is no more nameserver");
		// we should be ok to keep going here.  the nameserver is toast, but the game should go on...
		return hr;
	}

	// a-josbor: make sure the dplay thread is running to care for the reservation count
	StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	

	// remember that we are the system player
	this->pNameServer = this->pSysPlayer;

	if((this->dwMinVersion >= DPSP_MSG_DX61VERSION) && 
	   (this->dwMinVersion >= DPSP_MSG_DX61AVERSION || this->pProtocol)){
		// we used to tell everyone that the system player was deleted and then
		// recreated.  This is a very bad thing to do with the protocol running
		// so we instead send an IAMHOST message to give the other players a chance
		// to update their information on who is the name server.
		hr=SendIAmNameServer(this);
		if(FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
	} else {
		// tell the world about our new player
		// 1st, delete the non-nameserver old player
		hr = SendPlayerManagementMessage(this, DPSP_MSG_DELETEPLAYER|DPSP_MSG_ASYNC, 
			this->pSysPlayer->dwID,0);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		
		// now, create the new nameserver player
		hr = SendCreateMessage( this, this->pSysPlayer,TRUE,NULL);	
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

	}
	// tell our local players we're the nameserver
	hr = SendMeNameServer(this);
	if (FAILED(hr))
	{
		DPF(0,"could not send name server message - hr = 0x%08lx\n",hr);
		ASSERT(FALSE);
	}

	// Send a system message to the lobby server, telling them the
	// host just migrated to this client
	PRV_SendStandardSystemMessage(this->lpLaunchingLobbyObject,
			DPLSYS_NEWSESSIONHOST, DPLOBBYPR_GAMEID);

	// reset our ping counter, so we don't start sending pings
	// until things have settled down...
	this->dwLastPing = GetTickCount();
	
	return DP_OK;
	
} // MakeMeNameServer

// called by handler.c when it gets a dp_deleteplayer on 
// the namesrvr
HRESULT HandleDeadNameServer(LPDPLAYI_DPLAY this)
{
	DWORD IDMin; // the minimum player id, and the index of that id
	BOOL bFound = FALSE;
	LPDPLAYI_PLAYER pPlayer,pNewServer = NULL;	
	HRESULT hr = DP_OK;

	// In a client-server or secure session, don't migrate the host
	if ( (this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) 
		||  (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) 
		|| !(this->lpsdDesc->dwFlags & DPSESSION_MIGRATEHOST) )
	{
		DPF(0,"Name server is dead.  Game over!");
		return HandleSessionLost(this);
	}

	DPF(0,"Name server dead.  Finding new name server");

	IDMin = (DWORD) -1;

	// search the name table, looking for a new namesrvr
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if (DPLAYI_PLAYER_SYSPLAYER & pPlayer->dwFlags )
		{
			if (pPlayer->dwID < IDMin) 
			{
				bFound=TRUE;
				IDMin = pPlayer->dwID;
				pNewServer = pPlayer;
			} // id < idMin
		} // sysplayer
		pPlayer = pPlayer->pNextPlayer;
	} // while

	if (!bFound) 
	{
		DPF(0,"Could not find new name srvr - ack!");
		return E_FAIL;
	}

	DPF(0,"found new name srvr - id = %d\n",IDMin);

	if (this->pSysPlayer && (this->pSysPlayer->dwID == IDMin)) 
	{
		this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
		hr = MakeMeNameServer(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// we should be ok to keep going here
		}
	} // id == idmin
	else {
		// Mark no nameserver and do keepalives until we find one.
		this->dwFlags |= DPLAYI_DPLAY_NONAMESERVER;
		StartDPlayThread(this,this->lpsdDesc->dwFlags & DPSESSION_KEEPALIVE);	
	}

	return hr;

} // HandleDeadNameServer


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\pack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pack.c
 *  Content:	packs / unpacks players + group before / after network xport
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/13/96		andyco	created it
 *	4/15/96		andyco	unpack calls sp's create player fn
 *	4/22/96		andyco	unapck takes pmsg 
 *	5/31/96		andyco	group and players use same pack / unpack show
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *	6/25/96		andyco 	check data size before unpack
 *	7/10/96		andyco	don't unpack our sysplayer (pending already put 
 *						'em in the table)
 *	7/27/96		kipo	call PackPlayer() with bPlayer == FALSE to pack players
 *						in group along with the rest of the group data.
 *	8/1/96		andyco	added system player id to packed struct
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *	10/14/96	andyco	don't pack up system group.  add players to system
 *						group after unpacking.
 *	1/15/97		andyco	set new players' sysplayer id early enough to add
 *						to system group
 *	2/15/97		andyco	moved "remember name server" to iplay.c 
 *  3/12/97     sohailm updated UnpackPlayer() to move the security context ptr from the
 *                      nametable to the player structure when session is secure
 *  3/24/97     sohailm updated UnPackPlayer to pass NULL for session password to GetPlayer and
 *                      SendCreateMessage
 *	4/20/97		andyco	group in group 
 *	5/8/97		andyco	packing for CLIENT_SERVER
 *  6/22/97     sohailm Updated code to use pClientInfo.
 *   8/4/97		andyco	track this->dwMinVersion as we unpack
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *   4/1/98     aarono  don't propogate local only player flags
 ***************************************************************************/

// todo - handle unpack error on create group/player

 /**************************************************************************
 *
 * packed player format :                                            
 *                                                                   
 * 		+ for player                                                    
 * 	                                                                  
 * 			DPLAYI_PACKED  pPacked; // packed player struct             
 * 			LPWSTR lpszShortName; 	// size = pPacked->iShortNameLength 
 * 			LPWSTR lpszLongName;  	// size = pPacked->iLongNameLength  
 * 			LPVOID pvSPData;	  	// size = pPacked->dwSPDataSize     
 * 			LPVOID pvPlayerData;  	// size = pPacked->dwPlayerDataSize 
 * 	                                                                  
 * 		+ for group                                                     
 *
 * 			DPLAYI_PACKED  pPacked; // packed player struct             
 * 			LPWSTR lpszShortName; 	// size = pPacked->iShortNameLength 
 * 			LPWSTR lpszLongName;  	// size = pPacked->iLongNameLength  
 * 			LPVOID pvSPData;	  	// size = pPacked->dwSPDataSize     
 * 			LPVOID pvPlayerData;  	// size = pPacked->dwPlayerDataSize 
 * 			DWORD  dwIDs[dwNumPlayers] // size = pPacked->dwNumPlayers
 *
 *	packed player list format :
 *	
 *		msg (e.g. CreatePlayer,CreateGroup,EnumPlayersReply)
 *		PackedPlayer[nPlayers]
 *		PackedGroup[nGroups]
 *		msgdata[this->dwSPHeaderSize] (set by sp on send / receive)
 *	
 *
 **************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"Pack -- "

// andyco - todo - remove TODOTODOTODO hack
// put in to find stress bug where system player hasn't been added yet
void CheckStressHack(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPDPLAYI_PLAYER pSearchPlayer = this->pPlayers;
	
	if (!pPlayer) return ;
	
	while (pSearchPlayer)
	{
		if ( !(pSearchPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && (pSearchPlayer->dwIDSysPlayer == pPlayer->dwID)
			&& !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
		{
			DPF(0,"player in nametable before system player!");
			ASSERT(FALSE);
#if 0 // - andyco removed for beta 1
			DPF(0,"found player in nametable before system player - going to int 3 - contact andyco");
			DebugBreak();
#endif 			
		}
		pSearchPlayer = pSearchPlayer->pNextPlayer;
	}

	return ;
		
} // CheckStressHack

/*
 ** UnpackPlayer
 *
 *  CALLED BY: UnpackPlayerAndGroupList
 *
 *  PARAMETERS: 
 *		this - direct play object
 *		pPacked - packed player or group
 *		pMsg - original message received (used so we can get sp's message data
 *			out for CreatePlayer call)
 *		bPlayer - is packed a player or a group?
 *
 *  DESCRIPTION: unpacks player. creates new player, sets it up.
 *
 *  RETURNS: SP's hr, or result	of GetPlayer or SendCreateMessage
 *
 */
HRESULT UnpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_PACKEDPLAYER pPacked,
	LPVOID pvSPHeader,BOOL bPlayer)
{
    LPWSTR lpszShortName, lpszLongName;
	DWORD dwFlags;
	DPNAME PlayerName;
	LPVOID pvPlayerData;
	LPVOID pvSPData;
    LPDPLAYI_PLAYER pNewPlayer;
	LPDPLAYI_GROUP pNewGroup;
    LPBYTE pBufferIndex = (LPBYTE)pPacked;
	HRESULT hr;

	// unpack the strings  - they folow the packed player in the buffer
	if (pPacked->iShortNameLength) 
	{
		lpszShortName = (WCHAR *)(pBufferIndex + pPacked->dwFixedSize);
	}	
	else lpszShortName = NULL;

	if (pPacked->iLongNameLength) 
	{
		lpszLongName =(WCHAR *)( pBufferIndex + pPacked->dwFixedSize
			+ pPacked->iShortNameLength);
	}
	else lpszLongName = NULL;

	dwFlags = pPacked->dwFlags;
	
	// player is not local
	dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;

	PlayerName.lpszShortName = lpszShortName;
	PlayerName.lpszLongName = lpszLongName;
		
	pvPlayerData = pBufferIndex + pPacked->dwFixedSize + 
		pPacked->iShortNameLength + pPacked->iLongNameLength + 
		pPacked->dwSPDataSize;

	// go create the player
	if (bPlayer)
	{
		hr = GetPlayer(this,&pNewPlayer,&PlayerName,NULL,pvPlayerData,
			pPacked->dwPlayerDataSize,dwFlags,NULL,0);
		// andyco - debug code to catch stress bug 
		// todo - REMOVE HACKHACK TODOTODO
		if ( SUCCEEDED(hr) && (dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			CheckStressHack(this,pNewPlayer);
		}
	}
	else 
	{
		hr = GetGroup(this,&pNewGroup,&PlayerName,pvPlayerData,
			pPacked->dwPlayerDataSize,dwFlags,0,0);
		if (FAILED(hr)) 
		{
			ASSERT(FALSE);
			return hr;
			// rut ro!
		}
		// cast to player - we only going to use common fields
		pNewPlayer = (LPDPLAYI_PLAYER)pNewGroup;		
	}
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		return hr;
		// rut ro!
	}

	pNewPlayer->dwIDSysPlayer = pPacked->dwIDSysPlayer;
	pNewPlayer->dwVersion = pPacked->dwVersion;	
	
	if (DPSP_MSG_DX3VERSION == pNewPlayer->dwVersion)
	{
		DPF(0,"detected DX3 client in game");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if (pNewPlayer->dwVersion && (pNewPlayer->dwVersion < this->dwMinVersion))
	{
		this->dwMinVersion = pNewPlayer->dwVersion;
		DPF(2,"found new min player version of %d\n",this->dwMinVersion);
	}
	
	if (pPacked->dwSPDataSize)
	{
		// copy the sp data - 1st, alloc space
		pNewPlayer->pvSPData = DPMEM_ALLOC(pPacked->dwSPDataSize);
		if (!pNewPlayer->pvSPData) 
		{
			// rut ro!
			DPF_ERR("out of memory, could not copy spdata to new player!");
			return E_OUTOFMEMORY;
		}
		pNewPlayer->dwSPDataSize = pPacked->dwSPDataSize;
	
		pvSPData = 	pBufferIndex + pPacked->dwFixedSize + pPacked->iShortNameLength 
			+ pPacked->iLongNameLength;
		// copy the spdata from the packed to the player
		memcpy(pNewPlayer->pvSPData,pvSPData,pPacked->dwSPDataSize);
	}

	// now, set the id and add to nametable
	pNewPlayer->dwID = pPacked->dwID;

    // if we are a secure server and we receive a remote system player, 
    // move the pClientInfo from the nametable into the player structure before the slot
    // is taken by the player
	//
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this) &&
        !(pNewPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
        (pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        pNewPlayer->pClientInfo = (LPCLIENTINFO) DataFromID(this,pNewPlayer->dwID);
		DPF(6,"pClientInfo=0x%08x for player %d",pNewPlayer->pClientInfo,pNewPlayer->dwID);
    }
    

	// don't add to the nametable if it's the app server - this id is fixed
	if (!(pNewPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))	
	{
		hr = AddItemToNameTable(this,(DWORD_PTR)pNewPlayer,&(pNewPlayer->dwID),TRUE,0);
	    if (FAILED(hr)) 
	    {
			ASSERT(FALSE);
			// if this fails, we're hosed!  there's no id on the player, but its in the list...
			// todo - what now???
	    }
	}

	// call sp 	
	if (bPlayer)
	{
		// tell sp about player
		hr = CallSPCreatePlayer(this,pNewPlayer,FALSE,pvSPHeader,TRUE);
		
	    // add to system group
	    if (this->pSysGroup)
	    {
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			pNewPlayer->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
	    }
	}
	else 
	{
		// tell sp about group
		hr = CallSPCreateGroup(this,(LPDPLAYI_GROUP)pNewPlayer,TRUE,pvSPHeader);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// todo -handle create player / group fails on unpack
	}
	
	// if it's a group, unpack group info
	if (!bPlayer)
	{
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList;
		DWORD dwPlayerID;

		if ( (pNewPlayer->dwVersion >= DPSP_MSG_GROUPINGROUP) && (pPacked->dwIDParent) )
		{
			pNewGroup->dwIDParent = pPacked->dwIDParent;
			// add it to parent
			hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces,pPacked->dwIDParent,
				pNewGroup->dwID,0,FALSE);
			if (FAILED(hr))
			{
				DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
				// keep trying...
			}
		}

		nPlayers = pPacked->dwNumPlayers;
		// list of id's is list thing in packed buffer
		pdwIDList = (LPDWORD) ((LPBYTE)pPacked + pPacked->dwFixedSize + 
			pPacked->iShortNameLength + pPacked->iLongNameLength + 
			pPacked->dwSPDataSize + pPacked->dwPlayerDataSize);

		// now, add the players to the group
		while (nPlayers>0)
		{
			nPlayers--;
			dwPlayerID = *pdwIDList++;
			hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,pPacked->dwID,
				dwPlayerID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
				// keep trying...
			}
		}	
		
		// all done!
	} // !bPlayer

	return hr;

}// UnpackPlayer

/*
 ** UnpackPlayerAndGroupList
 *
 *  CALLED BY: handler.c (on createplayer/group message) and iplay.c (CreateNameTable)
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *		pvSPHeader - sp's header, as received off the wire
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT UnpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
	LPBYTE pBufferIndex;
	LPDPLAYI_PACKEDPLAYER pPacked;

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		// don't unpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		if ( !(this->pSysPlayer && (pPacked->dwID == this->pSysPlayer->dwID)) )
		{
			hr = UnpackPlayer(this,pPacked,pvSPHeader,TRUE);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
				// keep trying
			}
		}

		nPlayers --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_PACKEDPLAYER)pBufferIndex;
		
		hr = UnpackPlayer(this,pPacked,pvSPHeader,FALSE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nGroups --;
		// point to next pPacked in list
		pBufferIndex += pPacked->dwSize;		
   	} 
		
	return hr;

} // UnpackPlayerAndGroupList

DWORD PackedPlayerSize(LPDPLAYI_PLAYER pPlayer) 
{
	DWORD dwSize = 0;
	LPDPLAYI_DPLAY this = pPlayer->lpDP;
	
	dwSize = (WSTRLEN(pPlayer->lpszShortName) + WSTRLEN(pPlayer->lpszLongName)) 
		* sizeof(WCHAR)	+ sizeof(DPLAYI_PACKEDPLAYER) + 
		pPlayer->dwPlayerDataSize + pPlayer->dwSPDataSize;
		
	return dwSize;
} // PackedPlayerSize


DWORD PackedGroupSize(LPDPLAYI_GROUP  pGroup)
{
	DWORD dwSize = 0;
	
	// space for player stuff, plus space for group list 
	dwSize = PackedPlayerSize((LPDPLAYI_PLAYER)pGroup) + 
		pGroup->nPlayers*sizeof(DPID);
		
	return dwSize;	
} // PackedGroupSize

// returns how big the packed player structure is for the nPlayers
DWORD PackedBufferSize(LPDPLAYI_PLAYER pPlayer,int nPlayers,BOOL bPlayer) 
{
	DWORD dwSize=0;
	LPDPLAYI_GROUP pGroup = (LPDPLAYI_GROUP)pPlayer;
	
	while (nPlayers > 0)
	{
		if (bPlayer)
		{

			ASSERT(pPlayer);
			dwSize += PackedPlayerSize(pPlayer);
			pPlayer=pPlayer->pNextPlayer;
		}
		else 
		{
			ASSERT(pGroup);
			// don't count the system group - we don't send that one
			if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
			{
				dwSize += PackedGroupSize(pGroup);
			}
			
			pGroup = pGroup->pNextGroup;			
		}
		nPlayers--;		
	}	
	return dwSize;
}// PackedBufferSize

// constructs a packedplayer object from pPlayer. stores result in pBuffer
// returns size of packed player
DWORD PackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) 
{
	DPLAYI_PACKEDPLAYER Packed;
	int iShortStrLen=0,iLongStrLen=0;
	LPBYTE pBufferIndex = pBuffer;
		
	if (!pBuffer)
	{
		return PackedBufferSize(pPlayer,1,bPlayer);
	} // pBuffer

	// just to be safe
	memset(&Packed,0,sizeof(DPLAYI_PACKEDPLAYER));
	
	// figure out how big the packed struct is, setting short and long strlen
	iShortStrLen = WSTRLEN_BYTES(pPlayer->lpszShortName);
	iLongStrLen = WSTRLEN_BYTES(pPlayer->lpszLongName);
	
	if (bPlayer)
	{
		Packed.dwSize =  PackedPlayerSize(pPlayer);
		Packed.dwNumPlayers = 0;
	}
	else 
	{
		Packed.dwSize = PackedGroupSize((LPDPLAYI_GROUP)pPlayer);
		Packed.dwNumPlayers = ((LPDPLAYI_GROUP)pPlayer)->nPlayers;
	}
	
	Packed.iShortNameLength = iShortStrLen;
	Packed.iLongNameLength = iLongStrLen;
	
	// copy over relevant fields
	Packed.dwFlags = pPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS); 
	Packed.dwID = pPlayer->dwID;
	Packed.dwPlayerDataSize = pPlayer->dwPlayerDataSize;

	Packed.dwIDSysPlayer = pPlayer->dwIDSysPlayer;
	Packed.dwVersion = pPlayer->dwVersion;	
	Packed.dwFixedSize = sizeof(DPLAYI_PACKEDPLAYER);
	Packed.dwIDParent = pPlayer->dwIDParent;
	
	// start filling up variable size structs behind the fixed size one
	pBufferIndex+= sizeof(Packed);
	
	// store strings after packed
	if (pPlayer->lpszShortName)	
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		pBufferIndex += iShortStrLen;
	}
	if (pPlayer->lpszLongName)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		pBufferIndex += iLongStrLen;
	}

	// pack sp data
	if (pPlayer->pvSPData)
	{
		// store spdata after strings
		memcpy(pBufferIndex,pPlayer->pvSPData,pPlayer->dwSPDataSize);
		pBufferIndex += pPlayer->dwSPDataSize;
		Packed.dwSPDataSize = pPlayer->dwSPDataSize;
	}
	else 
	{
		Packed.dwSPDataSize = 0;
	}

	if (pPlayer->pvPlayerData)
	{
		// copy playerdata after spdata
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
	}

	// if it's a group, store the list of id's after the playerdata
	if (!bPlayer)
	{
		LPDPLAYI_GROUPNODE pGroupnode = ((LPDPLAYI_GROUP)pPlayer)->pGroupnodes;
		LPDPID pdwBufferIndex;
		
		// we shouldn't be asked to pack the sysgroup
		ASSERT(! (pPlayer->dwFlags & DPLAYI_GROUP_SYSGROUP));

		pBufferIndex += pPlayer->dwPlayerDataSize;
		pdwBufferIndex = (LPDPID)pBufferIndex;

		// add the players in the group onto the list
		while (pGroupnode)
		{
			ASSERT(pGroupnode->pPlayer);
			*pdwBufferIndex++ = pGroupnode->pPlayer->dwID;
			pGroupnode = pGroupnode->pNextGroupnode;
		}
	}

	// store the fixed size packed struct in buffer
	memcpy(pBuffer,&Packed,sizeof(Packed));

	// all done
	return Packed.dwSize;	
	
} // PackPlayer

					
HRESULT PackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) 
{

	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP 	pGroup;

	if (!pBuffer) 
	{
		if (CLIENT_SERVER(this))
		{
			ASSERT(this->pSysPlayer);
			*pdwBufferSize = PackedBufferSize(this->pSysPlayer,1,TRUE);
			if (this->pServerPlayer) 
			{
				*pdwBufferSize += PackedBufferSize(this->pServerPlayer,1,TRUE);
			}
		}
		else 
		{
			*pdwBufferSize = PackedBufferSize((LPDPLAYI_PLAYER)this->pGroups,
				this->nGroups,FALSE);
			*pdwBufferSize += PackedBufferSize(this->pPlayers,this->nPlayers,TRUE);
		}
		return DP_OK;
	}
	// else, assume buffer is big enough...
	
	// if we're client server, just send the minimum info...
	if (CLIENT_SERVER(this))
	{
		ASSERT(this->pSysPlayer);	
		pBuffer += PackPlayer(this->pSysPlayer,pBuffer,TRUE);
		if (this->pServerPlayer) 
		{
				pBuffer += PackPlayer(this->pServerPlayer,pBuffer,TRUE);
		}
		return DP_OK;
	}
			
	// if not, pack all players
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pBuffer += PackPlayer(pPlayer,pBuffer,TRUE);
		pPlayer = pPlayer->pNextPlayer;
	}
	// next, pack groups
	pGroup = this->pGroups;
	while (pGroup)
	{
		// don't send the system group 
		if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			pBuffer += PackPlayer((LPDPLAYI_PLAYER)pGroup,pBuffer,FALSE);
		}
		pGroup = pGroup->pNextGroup;
	}

	return DP_OK;
	
}// PackPlayerAndGroupList	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\paketize.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       paketize.c
*  Content:		break sends or replies up into sp-size packets
*  History:
*   Date		By		Reason
*   ====		==		======
*	7/25/96		andyco	created it 'cause IPX wont packetize for
*						us.
*	7/26/96		kipo	check for pvSPHeader == NULL before calling memcpy (#2654)
*   3/18/97     sohailm HandlePacket shouldn't copy the sp header if it is
*                       DPSP_HEADER_LOCALMSG
*   6/17/97     aarono  Added reliability
*   2/2/98      aarono  Added test for closing to SendTimeOut
*   2/3/98      aarono  Fixed Paketize test for RAW mode
*   2/18/98     aarono  changed error checks to FAILED(hr)
*   3/5/98      aarono  NeedsReliablePacketize won't say so for 
*                       ENUMSESSIONSREPLY as this can lead to machines with
*                       improper IPX net number hanging up the host.
*   3/9/98      aarono  added more messages to packetize to avoid deadlocks.
*   3/13/98     aarono  rearchitected packetize retry/timeout for NT mmTimer 
*                       contraints.
*   3/26/98     aarono  B#21476 free retry packet nodes during close
*   4/1/98      aarono  B#21476 also need to free from timeoutlist
*   4/24/98     aarono  DX5 compat, reduce size of packetize messages
*    6/6/98     aarono  Fix for handling large loopback messages with protocol
*   6/19/98     aarono  Don't do our own reliability when the SP does it already.
*   8/21/98     aarono  Don't send packetize messages to machines with no nametable.
*   8/05/99     aarono  Packetize Reliabe VOICE message.
*   6/26/00     aarono  Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
*                       added re-notification during simultaneous join CREATEPLAYERVERIFY
*
***************************************************************************/

#include "dplaypr.h"
#include <mmsystem.h>
#include "..\protocol\mytimer.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"HandlePacket"

VOID StartPacketizeTicker(LPDPLAYI_DPLAY this);
VOID SendPacketizeACK(LPDPLAYI_DPLAY this, LPPACKETNODE pNode,LPMSG_PACKET pmsg);
VOID SendNextPacket(LPDPLAYI_DPLAY this, LPPACKETNODE pNode, BOOL bInDplay);
void BlowAwayPacketNode(LPDPLAYI_DPLAY this, LPPACKETNODE pNode);

#define PACKETIZE_RECEIVE_TIMEOUT   60000	/* Always give up after this ms time */
#define MIN_RECEIVE_TIMEOUT         10000   /* Never give up before this ms time */
#define TICKER_INTERVAL  			15000	/* Check for expired receives this often*/
#define TICKER_RESOLUTION 			1000	/* How accurate we want the ticker (not very) */
#define MAX_PACKETIZE_RETRY 		16		/* Generally how often to retry before giving up*/

#define SIGNATURE(a,b,c,d) (UINT)(a+(b<<8)+(c<<16)+(d<<24))

#define NODE_SIGN SIGNATURE('N','O','D','E')
#define NODE_UNSIGN SIGNATURE('n','o','d','e')

// The PacketizeTimeoutListLock controls access to the PacketizeTimeoutList AND the 
// RetryList in each DPLAY object.  Use PACKETIZE_LOCK() PACKETIZE_UNLOCK() macros.
CRITICAL_SECTION g_PacketizeTimeoutListLock;
BILINK           g_PacketizeTimeoutList={&g_PacketizeTimeoutList, &g_PacketizeTimeoutList};


BOOL NeedsReliablePacketize(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, DWORD dwFlags)
{

	if ((dwFlags & DPSEND_GUARANTEED) &&
	    (this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE|DPLAYI_DPLAY_PROTOCOL)) && 
	    (dwVersion >= DPSP_MSG_RELIABLEVERSION))
	{
		switch (dwCommand)
		{
			//case DPSP_MSG_ENUMSESSIONSREPLY: -- can't do enumsession reply on packetizer
			//                                    since remote may be invalid subnet, hanging
			//                                    machine as IPX does RIPs, actually crashing IPX too.
			case DPSP_MSG_ENUMSESSIONS:
			case DPSP_MSG_ENUMPLAYER:
			case DPSP_MSG_ENUMPLAYERSREPLY:
			case DPSP_MSG_REQUESTGROUPID:
			case DPSP_MSG_REQUESTPLAYERID:
			case DPSP_MSG_CREATEGROUP:
			case DPSP_MSG_DELETEGROUP:
			case DPSP_MSG_REQUESTPLAYERREPLY:
			case DPSP_MSG_ADDFORWARDREQUEST:
			case DPSP_MSG_NAMESERVER:
			case DPSP_MSG_SESSIONDESCCHANGED:
			case DPSP_MSG_CREATEPLAYER:	
			case DPSP_MSG_DELETEPLAYER: 
			case DPSP_MSG_ADDPLAYERTOGROUP:
			case DPSP_MSG_DELETEPLAYERFROMGROUP:
			case DPSP_MSG_ADDFORWARDREPLY:
			case DPSP_MSG_ADDSHORTCUTTOGROUP:
			case DPSP_MSG_DELETEGROUPFROMGROUP:
			case DPSP_MSG_SUPERENUMPLAYERSREPLY:
			case DPSP_MSG_CHAT:
			case DPSP_MSG_ADDFORWARD:			
			case DPSP_MSG_ADDFORWARDACK:
			case DPSP_MSG_ASK4MULTICAST:
			case DPSP_MSG_ASK4MULTICASTGUARANTEED:
			case DPSP_MSG_IAMNAMESERVER:
			case DPSP_MSG_CREATEPLAYERVERIFY:
	//		case DPSP_MSG_VOICE:
			return TRUE;
				
			default:
				return FALSE;
		}
	} else {
		return FALSE;
	}

}

// Not quite symetric with Init, must kill the thread before calling this.
// key of non-zero this->hRetry to see if this is necessary.
VOID FiniPacketize(LPDPLAYI_DPLAY this)
{
	FreePacketizeRetryList(this);
	CloseHandle(this->hRetry);
	this->hRetry=0;
}

// Free Packetize Retry List
VOID FreePacketizeRetryList(LPDPLAYI_DPLAY this)
{
	LPPACKETNODE pNode;
	BILINK *pBilink;

	PACKETIZE_LOCK();

	// pull off retry list
	while(!EMPTY_BILINK(&this->RetryList)){
		pBilink=this->RetryList.next;
		pNode=CONTAINING_RECORD(pBilink, PACKETNODE, RetryList);

		BlowAwayPacketNode(this, pNode);
	}	

	// pull off timeout list
	pBilink=g_PacketizeTimeoutList.next;
	while(pBilink != &g_PacketizeTimeoutList){
		pNode=CONTAINING_RECORD(pBilink, PACKETNODE, TimeoutList);
		pBilink=pBilink->next;

		if(this==pNode->lpDPlay){
			BlowAwayPacketNode(this, pNode);
		}
	}

	PACKETIZE_UNLOCK();
}

// Initialize for packetize and send reliable.
HRESULT InitPacketize(LPDPLAYI_DPLAY this)
{
	HRESULT hr;
	DWORD dwThreadID;

	this->hRetry=CreateEventA(NULL,FALSE,FALSE,NULL);
	if(!this->hRetry){
		DPF(0,"InitPacketize failing, couldn't allocate retry thread event\n");
		hr=DPERR_OUTOFMEMORY;
		goto EXIT;
	}

	this->hRetryThread=CreateThread(NULL,4096,PacketizeRetryThread,this,0,&dwThreadID);
	if(!this->hRetryThread){
		DPF(0,"InitPacketize failing, couldn't allocate retry thread\n");
		hr=DPERR_OUTOFMEMORY;
		goto ERROR_EXIT;
	}

	InitBilink(&this->RetryList);

	hr=DP_OK;
	
EXIT:
	return hr;

ERROR_EXIT:
	if(this->hRetry){
		CloseHandle(this->hRetry);
		this->hRetry=0;
	}
	return hr;
}

// need a thread to do retries for reliable sends due to problems dealing
// with differences between NT and Win95 mmTimers.
DWORD WINAPI PacketizeRetryThread(LPDPLAYI_DPLAY this)
{
	BILINK *pBilink;
	LPPACKETNODE pNode;
	UINT tmCurrentTime;

	DPF(9,"==>PacketizeRetryThread starting\n");

	while(TRUE){
	
		// wait for a message to send or shutdown.
		WaitForSingleObject(this->hRetry, INFINITE); 

		if(this->dwFlags & DPLAYI_DPLAY_CLOSED){
			// we test here in case of an error during startup, in this
			// case the error path of startup is the only thread that
			// could have signaled us.
			break;
		}
		
		tmCurrentTime=timeGetTime();
		
		ENTER_ALL();
		PACKETIZE_LOCK();
		
		while(!EMPTY_BILINK(&this->RetryList)){

			pBilink=this->RetryList.next;
			pNode=CONTAINING_RECORD(pBilink, PACKETNODE, RetryList);
			Delete(&pNode->RetryList);
			InitBilink(&pNode->RetryList);
			
			if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
			{
				// DP_CLOSE signaled us to shut down.
				PACKETIZE_UNLOCK();
				LEAVE_ALL();
				goto ERROR_EXIT;
			}

			pNode->dwRetryCount++;
			if((pNode->dwRetryCount>=MAX_PACKETIZE_RETRY) && 
		 	   (tmCurrentTime-pNode->tmTransmitTime > MIN_RECEIVE_TIMEOUT)){
				DPF(5,"Packetize SendTimeOut: Exceeded Max Retries, giving up (quietly!)\n");
				BlowAwayPacketNode(this, pNode);
				continue;
			}

			if(this->pProtocol){
				EnterCriticalSection(&this->pProtocol->m_SPLock);// don't re-enter SP.
				SendNextPacket(this,pNode,TRUE);
				LeaveCriticalSection(&this->pProtocol->m_SPLock);
			} else {
				SendNextPacket(this,pNode,TRUE);
			}	
		}
		
		PACKETIZE_UNLOCK();
		LEAVE_ALL();
	}


	DPF(1,"<== PacketizeRetryThread Exiting\n");
ERROR_EXIT:
	return TRUE;
	
}

VOID CancelPacketizeRetryTimer(LPPACKETNODE  pNode)
{
	UINT_PTR uRetry=0;
	HRESULT rc;
	DWORD Unique;

	ASSERT(pNode->bReliable);

	PACKETIZE_LOCK();
	
		if(!EMPTY_BILINK(&pNode->TimeoutList)){
			uRetry=pNode->uRetryTimer;
			Unique=pNode->Unique;
			pNode->uRetryTimer=0;
			Delete(&pNode->TimeoutList);
			InitBilink(&pNode->TimeoutList);
		}	

		if(!EMPTY_BILINK(&pNode->RetryList)){
			Delete(&pNode->RetryList);
			InitBilink(&pNode->RetryList);
		}
		
	PACKETIZE_UNLOCK();
	
	if(uRetry){
		rc=CancelMyTimer(uRetry,Unique);
		DPF(9,"CancelTimer:KillEvent %x returned %x\n",uRetry,rc);
	}	
}

// free up the contents of a single packetnode
// called by handlepacket and DP_Close (via FreePacketList)
void FreePacketNode(LPPACKETNODE pNode)
{
#ifdef DEBUG
	DPF(8,"Freeing Packet Node: %x",pNode);
	if(pNode->bReliable){
		DPF(8," Reliable ");
	}else{
		DPF(8," Unreliable ");
	}
	if(pNode->bReceive){
		DPF(8,"Receive, age %d ms\n",timeGetTime()-pNode->tmLastReceive);
	} else {
		DPF(8,"Send\n");
	}

	if(pNode->Signature != NODE_SIGN){
		DPF(0,"INVALID PACKET NODE %x, Sign %x\n",pNode, pNode->Signature);
		DEBUG_BREAK();
	}
#endif
	
	if(pNode->bReliable && !(pNode->bReceive)){
		CancelPacketizeRetryTimer(pNode);
	}	
	pNode->Signature=NODE_UNSIGN;
	if (pNode->pBuffer) DPMEM_FREE(pNode->pBuffer);
	if (VALID_SPHEADER(pNode->pvSPHeader)) DPMEM_FREE(pNode->pvSPHeader);
	DPMEM_FREE(pNode);

} // FreePacketNode

// like FreePacketNode, but also does the list removal - only for Send nodes.
void BlowAwayPacketNode(LPDPLAYI_DPLAY this, LPPACKETNODE pNode)
{
	LPPACKETNODE pNodeWalker;

	DPF(8,"==>BlowAwayPacketNode\n");

	pNodeWalker=(LPPACKETNODE)&this->pPacketList; //tricky...

	while(pNodeWalker && pNodeWalker->pNext!=pNode){
		pNodeWalker=pNodeWalker->pNext;
		ASSERT(pNodeWalker->Signature==NODE_SIGN);
	}
	if(pNodeWalker){
		pNodeWalker->pNext=pNode->pNext;
	}else{
		DPF(0,"ERROR: tried to remove packetnode not on list pNode=%x\n",pNode);
		ASSERT(0);
		DEBUG_BREAK();
	}
		
	FreePacketNode(pNode);
	DPF(8,"<==BlowAwayPacketNode\n");
}

/*
 ** NewPacketnode
 *
 *  CALLED BY:	 HandlePacket, PacketizeAndSend.
 *
 *  PARAMETERS:
 *				ppNode - node to be alloc'ed
 *				pmsg - first packet received in message we're alloc'ing for
 *
 *  DESCRIPTION:
 *				alloc space for a new packetnode
 *				set up static data (e.g. guid, total num packets, etc.)
 *				we actually copy pmsg->pmessage over in HandlePacket
 *
 *  			Note: PacketNodes are used for both sending and receiving
 *                    Packetized Messages
 *
 *  RETURNS:  DP_OK or E_OUTOFMEMORY
 *
 */
HRESULT NewPacketnode(
	LPDPLAYI_DPLAY this,
	LPPACKETNODE * ppNode,
	LPGUID lpGUID,
	DWORD  dwMessageSize,
	DWORD  dwTotalPackets,
	LPVOID pvSPHeader
)	
{
	HRESULT hr;
	DWORD   dwExtraSize;

	LPPACKETNODE pNode;

	// alloc the node
	pNode = DPMEM_ALLOC(sizeof(PACKETNODE));
	
	if (!pNode)
	{
		DPF_ERR("could not get new packetnode -  out of memory");
		hr =  E_OUTOFMEMORY;
		return hr;
	}

	InitBilink(&pNode->TimeoutList);
	InitBilink(&pNode->RetryList);

	pNode->Signature = NODE_SIGN; // must be here so error path doesn't debug_break()
	
	DPF(8,"NewPacketNode: %x\n",pNode);

	dwExtraSize=this->dwSPHeaderSize+sizeof(MSG_PACKET);
	// alloc the buffer - extra space at front so we can build send buffers.
	pNode->pBuffer = DPMEM_ALLOC(dwMessageSize+dwExtraSize);
	if (!pNode->pBuffer)
	{
		DPF_ERR("could not get buffer for new packetnode -  out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}
	
	pNode->pMessage = pNode->pBuffer + dwExtraSize;

	// alloc and copy the header (if necessary)
	
	if (pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader)){
	
		pNode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pNode->pvSPHeader)
		{
			DPF_ERR("could not get header for new packetnode");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pNode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
		
	}	

	// stick the new node on the front of the list
	pNode->pNextPacketnode = this->pPacketList;
	this->pPacketList = pNode;

	pNode->guidMessage = *lpGUID;
	pNode->dwMessageSize = dwMessageSize; 
	pNode->dwTotalPackets = dwTotalPackets;

	*ppNode = pNode;
	
	return DP_OK;

ERROR_EXIT:

	FreePacketNode(pNode);
	return hr;

} // NewPacketnode

// called by handler.c
// we received a packet.
HRESULT HandlePacket(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPMSG_PACKET pmsg = (LPMSG_PACKET)pReceiveBuffer;
	LPPACKETNODE pNode,pNodePrev;
	BOOL bFoundIt = FALSE;
	HRESULT hr;
	BOOL bRetry;
	ULONG command;

	command=GET_MESSAGE_COMMAND(pmsg);

	// see if this packet is in the list
	pNode = this->pPacketList;
	pNodePrev = NULL;
	while (pNode && !bFoundIt)
	{
		if ( IsEqualIID(&(pNode->guidMessage),&(pmsg->guidMessage)))
	 	{
			bFoundIt = TRUE;
		}
		else 
		{
			// keep looking
			pNodePrev = pNode;
			pNode = pNode->pNextPacketnode;
		}
	}

	if (!bFoundIt)
	{
		switch(command){
			case DPSP_MSG_PACKET:
			case DPSP_MSG_PACKET2_DATA:
				// 
				// this is a new mesage
				DPF(8,"creating new packetnode");
				
				hr = NewPacketnode(this,&pNode,&pmsg->guidMessage,pmsg->dwMessageSize,pmsg->dwTotalPackets,pvSPHeader);

				if (FAILED(hr))
				{
					DPF_ERR(" could not get new packetnode");
					return hr;
				}

				if(command==DPSP_MSG_PACKET2_DATA){
					pNode->bReliable=TRUE;
					pNode->bReceive=TRUE;
				} else {
					ASSERT(command==DPSP_MSG_PACKET);
					pNode->bReliable=FALSE;
					pNode->bReceive=TRUE;
				}
				break;
				
			case DPSP_MSG_PACKET2_ACK:	
				DPF(6,"Got ACK for MSG that is no longer around\n");
				goto exit;
				break;
		}

	}
	else 
	{
		DPF(8," got packet for existing message");
	}

	if(command==DPSP_MSG_PACKET2_ACK){

		// GOT AN ACK
		
		CancelPacketizeRetryTimer(pNode);

		// Copy return info if necessary.
		if(!pNode->pvSPHeader && pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader)){
			// ACK from SEND has return information, copy so we can use Reply instead of Send.
			pNode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
			if (pNode->pvSPHeader){
				memcpy(pNode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
			}	
		}	

		if(pmsg->dwPacketID==pNode->dwSoFarPackets){
			// Got ack for last send, update stats, send next packet.
			pNode->dwSoFarPackets++;
			pNode->dwLatency = timeGetTime()-pNode->tmTransmitTime; 
			pNode->dwRetryCount = 0;
			if (pNode->dwLatency < 25){
				DPF(5, "Packetize: Got really low latency %dms, using 25ms to be safe\n",pNode->dwLatency);
				pNode->dwLatency = 25; 
			}	
			SendNextPacket(this, pNode, TRUE); // will also terminate the send if no more to send.
		} else {
			DPF(8,"Rejecting extra ACK\n");
		}
		
	} else {

		// DATA PACKET
		
		// copy this packet's data into the node
		if(pmsg->dwPacketID==pNode->dwSoFarPackets){

			memcpy(pNode->pMessage + pmsg->dwOffset,pReceiveBuffer + sizeof(MSG_PACKET),
					pmsg->dwDataSize);


			if(pmsg->dwOffset+pmsg->dwDataSize > pNode->dwMessageSize){
				DPF(0,"Packetize HandlePacket Message to big, pmsg->dwOffset %d, pmsg->dwDataSize %d, pNode->dwMessageSize %d\n",pmsg->dwOffset,pmsg->dwDataSize,pNode->dwMessageSize);
				DEBUG_BREAK();
			}
			
			pNode->dwSoFarPackets++;
			bRetry=FALSE;
			DPF(8,"received %d packets out of %d total",pNode->dwSoFarPackets,pNode->dwTotalPackets);
		} else {
			bRetry=TRUE;
			DPF(8,"received duplicate of %d packet out of %d total",pNode->dwSoFarPackets,pNode->dwTotalPackets);
		}
		
		if(command==DPSP_MSG_PACKET2_DATA){
			// ACK original or Retry.
			ASSERT(pNode->bReliable);
			DPF(8,"HandlePacket: Sending ACK\n");
			SendPacketizeACK(this,pNode,pmsg); // see header for side effects.
		}

		if(pNode->bReliable){
			pNode->tmLastReceive=timeGetTime();
		}	

		if (pNode->dwSoFarPackets == pNode->dwTotalPackets && !bRetry)
		{
			// GOT A COMPLETE MESSAGE
			// call handler
			DPF(8," HANDLE PACKET COMPLETED PACKETIZED MESSAGE !!! ");

			// take it out of the list - must be done before releasing lock.
			if(command==DPSP_MSG_PACKET){
			
				LPPACKETNODE pNodeWalker;

				pNodeWalker=(LPPACKETNODE)&this->pPacketList; //tricky...

				while(pNodeWalker && pNodeWalker->pNext!=pNode){
					pNodeWalker=pNodeWalker->pNext;
				}
				if(pNodeWalker){
					pNodeWalker->pNext=pNode->pNext;
				}else{
					DPF(0,"ERROR: tried to remove packetnode not on list pNode=%x\n",pNode);
					ASSERT(0);
				}
				
			}
			//
			// we leave dplay, since the handler counts on being able to drop the lock
			// (so if we have another thread blocked on a reply, it can process it, 
			// e.g. getnametable)
			LEAVE_DPLAY();
			
			hr = DP_SP_HandleNonProtocolMessage((IDirectPlaySP *)this->pInterfaces,pNode->pMessage,
					pNode->dwMessageSize,pNode->pvSPHeader);

			ENTER_DPLAY();
			
			// free up the packet node
			if(command==DPSP_MSG_PACKET){
				#ifdef DEBUG
				if(pNode->Signature != NODE_SIGN){
					DPF(0,"Invalid Node %x, Signature %x\n",pNode, pNode->Signature);
					DEBUG_BREAK();
				}
				#endif
				FreePacketNode(pNode);
			} else {
				ASSERT(command==DPSP_MSG_PACKET2_DATA);
				// We dropped the lock, so make sure still in the node
				// list before we free the buffer.
				pNodePrev = this->pPacketList;
				while(pNodePrev){ 
					if(pNodePrev==pNode){
						if (pNode->pBuffer){
							// don't need the memory any more, still need the node
							// to handle ACKing retries by the other machine
							DPMEM_FREE(pNode->pBuffer);
							pNode->pBuffer=NULL;
						}	
						break;
					}
					pNodePrev=pNodePrev->pNextPacketnode;
				}

				StartPacketizeTicker(this);
				// Type 2's are removed by the ticker, after 1 minute.
			}

			return hr;
		}
	}	
	// otherwise, wait for more packets...
exit:			
	return DP_OK;

}  // HandlePacket

#undef DPF_MODNAME
#define DPF_MODNAME	"PacketizeAndSend"

// how many packets will it take to send this message?
// dwMessageSize is the message size originally passed to senddpmessage 
// (or doreply)
UINT GetNPackets(LPDPLAYI_DPLAY this,DWORD dwMessageSize,DWORD dwFlags)
{
	DWORD dwPacketSpace; // space available in a packet
	UINT nPackets;

	// how much data will we need to send (neglecting headers)
	dwMessageSize -= this->dwSPHeaderSize;

	// how big a packet can sp handle?
	if(this->pProtocol){
		if(dwFlags&DPSEND_GUARANTEE){
			dwPacketSpace = this->pProtocol->m_dwSPMaxGuaranteed;
		}else{
			dwPacketSpace = this->pProtocol->m_dwSPMaxFrame;
		}
	} else {
		if (dwFlags & DPSEND_GUARANTEE){
			dwPacketSpace = this->dwSPMaxMessageGuaranteed;
		}else{
			dwPacketSpace = this->dwSPMaxMessage;		
		}
	}

	// now, we need to put a SP header and a dplay packet header on the front
	// dwPacketSpace will be the amount of data (as opposed to header) each packet
	// can carry
	dwPacketSpace -= (this->dwSPHeaderSize + sizeof(MSG_PACKET));
	DPF(8,"get packets : space / packet = %d\n",dwPacketSpace);

	nPackets = dwMessageSize / dwPacketSpace;
	if (0 != (dwMessageSize % dwPacketSpace)) nPackets++; // little bit left over

	DPF(8,"get packets : message size = %d, packets needed = %d\n",dwMessageSize,nPackets);

	return nPackets;
	
} // GetNPackets

// called by PacketizeAndSend and HandlePacket(for ACKing)
HRESULT ReplyPacket(LPDPLAYI_DPLAY this,LPBYTE pSendPacket,DWORD dwPacketSize,
	LPVOID pvMessageHeader, USHORT dwVersion)
{
	HRESULT hr;

	hr = DoReply(this,pSendPacket,dwPacketSize,pvMessageHeader,dwVersion);

	return hr;

} // ReplyPacket

// called by PacketizeAndSend	
HRESULT SendPacket(LPDPLAYI_DPLAY this,LPBYTE pSendPacket,DWORD dwPacketSize,
	LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags, BOOL bReply)
{
	HRESULT hr;

	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendPacket,dwPacketSize,dwFlags,bReply);

	return hr;

} // SendPacket


void CALLBACK SendTimeOut( UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2 )
{
	LPPACKETNODE pNode=(LPPACKETNODE)dwUser,pNodeWalker;
	UINT tmCurrentTime;
	BILINK *pBilink;
	UINT bFound=FALSE;

	tmCurrentTime=timeGetTime();

	DPF(4,"==>PacketizeSendTimeOut uID %x dwUser %x\n",uID,dwUser);

	// we know that if we find a node on the timeout list, that:
	// 	1. the node must be valid, because it must be pulled off to be freed.
	//  2. its this pointer is valid, because DP_Close frees the list before
	//     freeing the 'this' pointer AND DP_Close takes the TimeOutListLock
	//     to do the removal.

	PACKETIZE_LOCK();

	pBilink=g_PacketizeTimeoutList.next;

	while(pBilink != &g_PacketizeTimeoutList){
		pNodeWalker=CONTAINING_RECORD(pBilink, PACKETNODE, TimeoutList);
		pBilink=pBilink->next;

		if(pNode == pNodeWalker){
			if(pNode->uRetryTimer==uID || pNode->uRetryTimer==INVALID_TIMER){
				DPF(9,"Found Node %x in List, signalling retry thread\n",dwUser);
				pNode->uRetryTimer=0;
				Delete(&pNode->TimeoutList);		
				InitBilink(&pNode->TimeoutList);
				InsertAfter(&pNode->RetryList, &pNode->lpDPlay->RetryList);
				SetEvent(pNode->lpDPlay->hRetry);
				break;
			}
		}
	}

	PACKETIZE_UNLOCK();
	
}

VOID SendNextPacket(
	LPDPLAYI_DPLAY this, 
	LPPACKETNODE pNode,
	BOOL bInDplay
	)
{
	HRESULT hr;
	LPBYTE pSendPacket; // packet we're going to send out (header ptr)
	LPBYTE pSendData;   // data area of the packet
	DWORD dwPacketSpace; // space available in the data area
	DWORD dwPacketSize;
	DWORD dwBytesSoFar;
	LPMSG_PACKET pmsg;	// pointer to packet header (after SPHeader);

	BOOL bReply;

    LPDPLAYI_PLAYER pPlayerTo,pPlayerFrom;

	if(pNode->dwSoFarPackets==pNode->dwTotalPackets){
		DPF(8,"SendNextPacket: node done, not sending, blowing away node. %x\n",pNode);
		goto exit1;
	}

	if(pNode->pvSPHeader) {
		bReply=TRUE;
	} else {
		bReply=FALSE;
	}	

	if(!bReply){

		pPlayerFrom = PlayerFromID(this,pNode->dwIDFrom);
		pPlayerTo = PlayerFromID(this,pNode->dwIDTo);
	}

	// amount of room in packet for data
	
	if(this->pProtocol){
		dwPacketSize = this->pProtocol->m_dwSPMaxFrame;
	}else{
		dwPacketSize = this->dwSPMaxMessage;	
	}	

	dwPacketSpace = dwPacketSize - (this->dwSPHeaderSize + sizeof(MSG_PACKET2));

	// walk through the buffer, overwriting space in front of next outgoing packet.
	dwBytesSoFar=(pNode->dwSoFarPackets*dwPacketSpace);
	
	pSendData   = pNode->pMessage+dwBytesSoFar;
	pSendPacket = pSendData-sizeof(MSG_PACKET2)-this->dwSPHeaderSize;

	ASSERT(pSendPacket >= pNode->pBuffer);
	ASSERT(pSendPacket < pNode->pMessage+pNode->dwMessageSize);
	
	// set up the header
	pmsg = (LPMSG_PACKET)(pSendPacket + this->dwSPHeaderSize);

	//
	// Build the header
	//

	SET_MESSAGE_HDR(pmsg);

	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_PACKET2_DATA);
	pmsg->dwTotalPackets = pNode->dwTotalPackets;
	pmsg->dwMessageSize = pNode->dwMessageSize;  // already has SP header size removed in sending case.

	pmsg->dwDataSize=dwPacketSpace;
	
	// size correction for last packet
	if(dwBytesSoFar+dwPacketSpace > pNode->dwMessageSize){
		pmsg->dwDataSize=pNode->dwMessageSize-dwBytesSoFar;
	}

	dwPacketSize=this->dwSPHeaderSize+sizeof(MSG_PACKET2)+pmsg->dwDataSize;

	pmsg->dwPacketID = (DWORD) pNode->dwSoFarPackets;

	// how many bytes into message does this packet start
	pmsg->dwOffset = (ULONG) (pSendData-pNode->pMessage); 

	pmsg->guidMessage=pNode->guidMessage;

	// we set this to INVALID_TIMER so we can check if we need to set the timeout later.
	pNode->uRetryTimer=INVALID_TIMER;
	
	if(!pNode->dwRetryCount){
		pNode->tmTransmitTime=timeGetTime();
	}	
	
	if (bReply)
	{
		DPF(7,"SendNextPacket, Reply Packet# %x From %x To %x\n",pNode->dwSoFarPackets,pPlayerFrom, pPlayerTo);
		hr = ReplyPacket(this,pSendPacket,dwPacketSize,pNode->pvSPHeader,0);			   
	}
	else 
	{
		ASSERT(pNode->dwSoFarPackets==0);
		DPF(7,"SendNextPacket, SendPacket Packet# %xFrom %x To %x\n",pNode->dwSoFarPackets,pPlayerFrom, pPlayerTo);
		hr = SendPacket(this,pSendPacket,dwPacketSize,pPlayerFrom,pPlayerTo,pNode->dwSendFlags&~DPSEND_GUARANTEED,FALSE);
	}

	// Start the retry timer - unless we already got an ACK (which will clear uRetryTimer)
	if(!FAILED(hr)){
		if(pNode->uRetryTimer==INVALID_TIMER){

			PACKETIZE_LOCK();

#if 0			
			pNode->uRetryTimer=timeSetEvent(pNode->dwLatency+pNode->dwLatency/2,
											pNode->dwLatency/4,
											SendTimeOut,
											(ULONG)pNode,
											TIME_ONESHOT);
#endif											

			pNode->uRetryTimer=SetMyTimer(pNode->dwLatency+pNode->dwLatency/2,
										   pNode->dwLatency/4,
										   SendTimeOut,
										   (ULONG_PTR)pNode,
											&pNode->Unique);

			if(pNode->uRetryTimer){
				InsertBefore(&pNode->TimeoutList, &g_PacketizeTimeoutList);
			} else {
				ASSERT(0);
				DEBUG_BREAK();
				PACKETIZE_UNLOCK();
				goto exit1;
			}
											
			PACKETIZE_UNLOCK();
			
		}	
	} else {
		goto exit1;
	}
	return;

exit1:
	BlowAwayPacketNode(this,pNode);
	return;
}

/*
 ** PacketizeAndSendReliable - if you don't want reliable, don't call this!
 *
 *  CALLED BY: 
 *
 *  PARAMETERS:
 *			this - dplay object
 *			pPlayerFrom,pPlayerTo - players who are sending. 
 *			pMessage,dwMessageSize - Message we want to send
 *			dwFlags  - send flags
 *			pvMessageHeader - message header if we're going to call reply
 *			bReply - are we doing a reply (called from HandleXXX) or a send
 *
 *
 *  DESCRIPTION: like packetize and send, but only dispatches the first
 *               packet, subsequent packets are transmitted by SendNextPacket
 *               when the previous packet was ACKed.
 *
 *               Yes folks, this is async.
 * 
 *  RETURNS:  DP_OK
 *
 */
HRESULT PacketizeAndSendReliable(
	LPDPLAYI_DPLAY  this,
	LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,
	LPBYTE pMessage,
	DWORD  dwMessageSize,
	DWORD  dwFlags,
	LPVOID pvMessageHeader,
	BOOL   bReply
)
{
	UINT  nPackets;		// number of datagrams to send this message
	DWORD dwPacketSize; // size of each packet
	GUID  guid;         // a guid for this message
	
    LPPACKETNODE pNode;	// "send" node for packet

	HRESULT hr;

	if((pPlayerTo) && (pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)){
		// don't try to send to a player that doesn't have the nametable.
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",pPlayerTo,pPlayerTo->dwID);
		return DPERR_UNAVAILABLE;
	}

	if (((dwFlags & DPSEND_GUARANTEED) &&(!(this->dwFlags & DPLAYI_DPLAY_SPUNRELIABLE))) ||
		(this->dwAppHacks & DPLAY_APPHACK_NOTIMER)
	    ) 
	{
		// SP's reliable, so we don't have to.
		return PacketizeAndSend(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags,pvMessageHeader,bReply);
	}

	// turn off guaranteed bit since we do the reliability.
	nPackets = GetNPackets(this,dwMessageSize,dwFlags&~DPSEND_GUARANTEED);

	if(this->pProtocol){
		dwPacketSize=this->pProtocol->m_dwSPMaxFrame;
	}else{
		dwPacketSize = this->dwSPMaxMessage;	
	}	

	// Create a GUID for this message... (very expensive, but this is rare)
	hr=OS_CreateGuid(&guid);

	if(FAILED(hr)){
		goto error_exit;
	}
	
	// Get a node to describe this send.
	hr=NewPacketnode(this, &pNode, &guid, dwMessageSize-this->dwSPHeaderSize, nPackets, pvMessageHeader);

	if(FAILED(hr)){
		goto error_exit;
	}

	memcpy(pNode->pMessage, pMessage+this->dwSPHeaderSize, dwMessageSize-this->dwSPHeaderSize);

	pNode->dwSoFarPackets=0;

	pNode->bReliable   = TRUE;
	pNode->bReceive    = FALSE;

	// Worse case assumption for latency, since only comes into play
	// for retries on first packet, assume 14.4 modem (aprox) 1800 bytes/sec
	// This will get updated by the first ACK.
	if(dwMessageSize < 500){
		pNode->dwLatency = 20 + dwMessageSize/2;
	} else {
		pNode->dwLatency = 600;  
	}
	
	pNode->dwRetryCount= 0;
	pNode->tmLastReceive=timeGetTime();

	if(!bReply) {
		if(pPlayerTo){
			pNode->dwIDTo=pPlayerTo->dwID;
		} else {
			pNode->dwIDTo=0;
		}
		if(pPlayerFrom){
			pNode->dwIDFrom=pPlayerFrom->dwID;
		} else {
			pNode->dwIDFrom=0;
		}
		pNode->dwSendFlags=dwFlags;
	}	

	// don't need ref for i/f ptr since timers cancelled during shutdown.
	pNode->lpDPlay=this;

	ASSERT(gnDPCSCount);
	SendNextPacket(this, pNode, TRUE);

error_exit:
	return hr;

} // PacketizeAndSendReliable



/*
 ** PacketizeAndSend
 *
 *  CALLED BY: SendDPMessage, HandleXXXMessage
 *
 *  PARAMETERS:
 *			this - dplay object
 *			pPlayerFrom,pPlayerTo - players who are sending.  NULL if we're 
 *				called by HandleXXX
 *			pMessage,dwMessageSize - Message we want to send
 *			dwFlags  - send flags
 *			pvMessageHeader - message header if we're going to call reply
 *			bReply - are we doing a reply (called from HandleXXX) or a send
 *
 *
 *  DESCRIPTION: packs up the message into sp size chunks, and sends (or replies)
 *				it out.
 *
 *  RETURNS:  DP_OK
 *
 */
HRESULT PacketizeAndSend(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,
	LPVOID pvMessageHeader,BOOL bReply)
{
	UINT nPackets;	
	LPBYTE pBufferIndex;
	DWORD dwPacketSize; // size of each packet
	DWORD dwPacketSpace; // space available in a packet for msgdata
	LPBYTE pSendPacket; // packet we're going to send out
	LPMSG_PACKET pmsg;	
	DWORD dwBytesLeft;
	DWORD iPacket=0;	// index of the current packet
	HRESULT hr = DP_OK;

	nPackets = GetNPackets(this,dwMessageSize,dwFlags);
	
	// how big a packet can sp handle?
	if(this->pProtocol){
		if(dwFlags&DPSEND_GUARANTEE){
			dwPacketSize = this->pProtocol->m_dwSPMaxGuaranteed;
		}else{
			dwPacketSize = this->pProtocol->m_dwSPMaxFrame;
		}
	} else {
		if (dwFlags & DPSEND_GUARANTEE){
			dwPacketSize = this->dwSPMaxMessageGuaranteed;
		}else{
			dwPacketSize = this->dwSPMaxMessage;		
		}
	}
	
	pSendPacket = DPMEM_ALLOC(dwPacketSize);
	if (!pSendPacket)
	{
		DPF_ERR("could not alloc packet!");
		return E_OUTOFMEMORY;
	}

	// do the one time set up of the header
	pmsg = (LPMSG_PACKET)(pSendPacket + this->dwSPHeaderSize);

	// stick a guid on this baby, so receiving end knows which message packet
	// goes with
	hr = OS_CreateGuid(&(pmsg->guidMessage));
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		goto ERROR_EXIT;
	}

	SET_MESSAGE_HDR(pmsg);

	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_PACKET);
	pmsg->dwTotalPackets = nPackets;
	pmsg->dwMessageSize = dwMessageSize - this->dwSPHeaderSize;

	// amount of room in packet for data
	// DX5 doesn't expect us to send him messages that are longer than he thinks they can be
	// even though there was an error in the size calculation in DX5.  So we subtract 8 from
	// the actual available space so we can talk to DX5 properly.
	dwPacketSpace = dwPacketSize - (this->dwSPHeaderSize + sizeof(MSG_PACKET))-8/*dx5 compat*/;

	// we start reading out of the buffer after the header
	pBufferIndex = pMessage + this->dwSPHeaderSize;
	dwBytesLeft = dwMessageSize - this->dwSPHeaderSize;

	while (iPacket < nPackets)
	{
		// set up the header info specific to this packet 
		if (dwBytesLeft >= dwPacketSpace) pmsg->dwDataSize = dwPacketSpace;
		else pmsg->dwDataSize = dwBytesLeft;

		pmsg->dwPacketID = (DWORD) iPacket;

		// how many bytes into message does this packet go
		// on the receiving side, we don't have the header, so cruise that here...
		pmsg->dwOffset = (ULONG)(pBufferIndex - pMessage - this->dwSPHeaderSize); 

		// copy the data into the packet
		memcpy(pSendPacket + this->dwSPHeaderSize + sizeof(MSG_PACKET),pBufferIndex,
				pmsg->dwDataSize);

		if (bReply)
		{
			hr = ReplyPacket(this,pSendPacket,pmsg->dwDataSize+this->dwSPHeaderSize+sizeof(MSG_PACKET),pvMessageHeader,0);			   
		}
		else 
		{
			hr = SendPacket(this,pSendPacket,pmsg->dwDataSize+this->dwSPHeaderSize+sizeof(MSG_PACKET),pPlayerFrom,pPlayerTo,dwFlags,bReply);
		}
		if (FAILED(hr))
		{
			DPF(0,"could not send packet! hr = 0x%08lx\n",hr);
			goto ERROR_EXIT;

		}
		pBufferIndex += pmsg->dwDataSize;
		dwBytesLeft -= pmsg->dwDataSize;
		iPacket++;
	}


ERROR_EXIT:

	DPMEM_FREE(pSendPacket);

	return hr;

} // PacketizeAndSend


// SendPacketizeACK is always called from HandleMessage, therefore it
// always uses ReplyPacket to send the ACK.
//
// side-effect changes the dwCmdToken of the message.-also requires header space before pMsg.
VOID SendPacketizeACK(LPDPLAYI_DPLAY this, LPPACKETNODE pNode,LPMSG_PACKET pMsg)
{
	SET_MESSAGE_HDR(pMsg);
	SET_MESSAGE_COMMAND(pMsg, DPSP_MSG_PACKET2_ACK);
	ReplyPacket(this, ((LPBYTE)pMsg)-this->dwSPHeaderSize, sizeof(MSG_PACKET2_ACK)+this->dwSPHeaderSize, pNode->pvSPHeader, DPSP_MSG_VERSION);	
}

// Note, tick runs in the MM timer thread, so it can safely take
// the DPLAY lock.

void CALLBACK PacketizeTick( UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2 )
{
	LPDPLAYI_DPLAY this = (LPDPLAYI_DPLAY)(dwUser);
	
	LPPACKETNODE pNode, pLastNode=NULL;
	LPPACKETNODE pFreeNodes=NULL;

	UINT tmCurrentTime;

	tmCurrentTime=timeGetTime();

	ENTER_DPLAY();

		DPF(8,"PACKETIZE TICK");
		
		if(this->uPacketTickEvent==uID){
		
			this->uPacketTickEvent=0;
			// Scan the list looking for completed receives that have been around for 1 minute
			// or more.  If they have been, move them to a list to be blown away.

			pLastNode=(LPPACKETNODE)&this->pPacketList; //tricky...
			pNode=this->pPacketList;

			while(pNode){
				if(pNode->bReliable && pNode->bReceive){
					if(tmCurrentTime-pNode->tmLastReceive > PACKETIZE_RECEIVE_TIMEOUT){
						// remove this node from the list.
						pLastNode->pNextPacketnode=pNode->pNextPacketnode;
						// put it on the list to be freed.
						pNode->pNextPacketnode=pFreeNodes;
						pFreeNodes=pNode;
						// skip to the next node.
						pNode=pLastNode->pNextPacketnode;
						this->nPacketsTimingOut -= 1;
						ASSERT(!(this->nPacketsTimingOut&0x80000000));
						continue;
					}
				}
				pLastNode=pNode;
				pNode=pNode->pNextPacketnode;
			}

			if(this->nPacketsTimingOut){	
				this->uPacketTickEvent = timeSetEvent(TICKER_INTERVAL,TICKER_RESOLUTION,PacketizeTick,(ULONG_PTR)this,TIME_ONESHOT);
			}
		}	

	LEAVE_DPLAY();

	// we free the nodes after to reduce serialization.
	while(pFreeNodes){
		pNode=pFreeNodes->pNextPacketnode;
		FreePacketNode(pFreeNodes);
		pFreeNodes=pNode;
	}
}

// When a player is being deleted this removes sends to that player from the message queue.
VOID DeletePlayerPackets(LPDPLAYI_DPLAY this, UINT idPlayer)
{
	LPPACKETNODE pNode;

	ENTER_DPLAY();

	DPF(8,"==>Deleting player packets for playerid:x%x",idPlayer);

		pNode=this->pPacketList;

		while(pNode){
			// only delete sending nodes, since receive nodes req'd to ACK remote retries.
			if(!pNode->bReceive && pNode->dwIDTo==idPlayer){
					pNode->dwRetryCount=MAX_PACKETIZE_RETRY; //let next timeout deal with it.
			}
			pNode=pNode->pNextPacketnode;
		}

	LEAVE_DPLAY();
	
}

// Can only be called with DPLAY LOCK held.
VOID StartPacketizeTicker(LPDPLAYI_DPLAY this)
{
	this->nPacketsTimingOut += 1;
	if(this->nPacketsTimingOut == 1){
		// First one, start up the ticker. - note ok with lock since this must be first call.
		this->uPacketTickEvent = timeSetEvent(TICKER_INTERVAL,TICKER_RESOLUTION,PacketizeTick,(ULONG_PTR)this,TIME_ONESHOT);
	} 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\pending.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       pending.c
 *  Content:	manage commands received while we're waiting for the
 *				nametable, or while we've dropped our lock during a 
 *				guaranteed send.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	6/3/96		andyco	created it.
 *	7/10/96		andyco	updated w/ pendingnodes, etc.
 *	2/1/97		andyco	modified pending so we can use it when we drop the 
 *						lock for guaranteed sends
 *	2/18/97		andyco	push pending nodes onto back (end) of Q
 *  3/17/97     sohailm push pending shouldn't copy the sp header if it is
 *                      DPSP_HEADER_LOCALMSG
 *	6/18/97		andyco	checkpending called playerfromid, and then checked for
 *						!NULL.  But, if we're the namesrvr, it could return
 *						NAMETABLE_PENDING. So, we have to call VALID_PLAYER or
 *						VALID_GROUP instead.
 *  7/28/97		sohailm	Updated pending code to enable sends in pending mode.
 *	8/29/97		sohailm	Copy sp header correctly for local messages in pushpending (bug 43571)
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *  6/19/98 	aarono  add last ptr for message queues, makes insert
 *               	    constant time instead of O(n) where n is number
 *                 		of messages in queue.
 *  6/26/00     aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 *                     B#8757 WinSE - stress,added lock on QueueMessageNodeOnReceiveList
***************************************************************************/

#include "dplaypr.h"
  
#undef DPF_MODNAME
#define DPF_MODNAME	"PushPendingCommand"

// we got a command.
// we don't have the nametable yet, so add this command to the
// pending list...
HRESULT PushPendingCommand(LPDPLAYI_DPLAY this,LPVOID pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPPENDINGNODE pmsg=NULL;
	LPVOID pReceiveCopy=NULL; // we will copy pReceiveBuffer here (SP reuses buffer)
	LPVOID pHeaderCopy=NULL; // alloc'ed if needed
	HRESULT hr;
	
	ASSERT(this->dwFlags & DPLAYI_DPLAY_PENDING);

	if (!pReceiveBuffer) return DP_OK;

	// get the pending node
	pmsg = DPMEM_ALLOC(sizeof(PENDINGNODE));
	if (!pmsg)
	{
		DPF_ERR("could not alloc new pending node - out of memory");
		return E_OUTOFMEMORY;
	}

	// copy over the message
	pReceiveCopy = DPMEM_ALLOC(dwMessageSize);
	if (!pReceiveCopy)
	{
		DPF_ERR("could not alloc pending copy buffer - out of memory");
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	}

	memcpy(pReceiveCopy,pReceiveBuffer,dwMessageSize);

	// copy over the header, if needed
	if (pvSPHeader && (DPSP_HEADER_LOCALMSG != pvSPHeader))
	{
		pHeaderCopy = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pHeaderCopy)
		{			
			DPF_ERR("could not alloc pending copy header buffer - out of memory");
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}
		memcpy(pHeaderCopy,pvSPHeader,this->dwSPHeaderSize);
	}
	else 
	{
		pHeaderCopy = pvSPHeader;
	}

	// store a copy of the command
	pmsg->pMessage = pReceiveCopy;
	pmsg->dwMessageSize = dwMessageSize;
	pmsg->pHeader = pHeaderCopy;
	pmsg->dwSendFlags = dwSendFlags; // for security code.  e.g. DPSEND_ENCRYPTED
	
	// stick pmsg on the back of the list
	if(this->pMessagesPending){
		this->pLastPendingMessage->pNextNode=pmsg;
		this->pLastPendingMessage=pmsg;
	} else {
		this->pMessagesPending=pmsg;
		this->pLastPendingMessage=pmsg;
	}

	// bump the pending count
	this->nMessagesPending++;

	// success
	return DP_OK;	

ERROR_EXIT:
	if (pmsg) DPMEM_FREE(pmsg);
	if (pReceiveCopy) DPMEM_FREE(pReceiveCopy);
	if (VALID_SPHEADER(pHeaderCopy)) DPMEM_FREE(pHeaderCopy);

	// failure
	return hr;

} // PushPendingCommand

#undef DPF_MODNAME
#define DPF_MODNAME	"ExecutePendingCommands"

// see if our pending message is a create that we got w/ the name
// table (i.e. filter redundant creates, since they would hose our
// unpack code...
HRESULT CheckPendingMessage(LPDPLAYI_DPLAY this,LPPENDINGNODE pmsg)
{
	DWORD dwCommand;

    // extract command
	if ((pmsg->dwMessageSize < sizeof(DWORD)) || (IS_PLAYER_MESSAGE(pmsg->pMessage)))
	{
		dwCommand = DPSP_MSG_PLAYERMESSAGE;
	}
	else 
	{
	    dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pmsg->pMessage));
	}
	
	switch (dwCommand)
	{

		case DPSP_MSG_CREATEPLAYER:
		case DPSP_MSG_CREATEPLAYERVERIFY:
		{
			DWORD dwPlayerID;
			LPDPLAYI_PLAYER pPlayer;

			dwPlayerID = ((LPMSG_PLAYERMGMTMESSAGE)(pmsg->pMessage))->dwPlayerID;
			// see if it already exists
			pPlayer = PlayerFromID(this,dwPlayerID);
	        if (VALID_DPLAY_PLAYER(pPlayer))
	        {
	        	switch(dwCommand){
	        		case DPSP_MSG_CREATEPLAYER:
						DPF(1,"got redundant create message in pending list id = %d - discarding",dwPlayerID);
						break;
					case DPSP_MSG_CREATEPLAYERVERIFY:
						DPF(1,"got redundant create verfiy message in pending list id = %d - discarding",dwPlayerID);
						break;
	        	}		
				return E_FAIL; // squash it
			}
			
			break;
		}		
		case DPSP_MSG_CREATEGROUP:
		{
			DWORD dwPlayerID;
			LPDPLAYI_GROUP pGroup;

			dwPlayerID = ((LPMSG_PLAYERMGMTMESSAGE)(pmsg->pMessage))->dwPlayerID;
			// see if it already exists
			pGroup = GroupFromID(this,dwPlayerID);
	        if (VALID_DPLAY_GROUP(pGroup))
	        {
				DPF(1,"got redundant create message in pending list id = %d - discarding",dwPlayerID);
				return E_FAIL; // squash it
			}

			break;
		}		

		default:
			// other messages will be benign (e.g. deletes won't delete twice, etc.)
			// let it through
			break;

	} // switch

	return DP_OK;

} // CheckPendingMessage

// run through the list of pending commands
// call handler.c w/ q'ed up commands
// caller expects this function to clear DPLAYI_DPLAY_PENDING flag
// while executing pending commands, all new messages go on the pending queue.
HRESULT ExecutePendingCommands(LPDPLAYI_DPLAY this)	
{
	LPPENDINGNODE pmsg,pmsgDelete;
	HRESULT hr;
	DWORD nMessagesPending;

	if(!(this->dwFlags & DPLAYI_DPLAY_PENDING)){
		return DP_OK;
	}

	ASSERT(this->dwFlags & DPLAYI_DPLAY_PENDING);
	ASSERT(this->pSysPlayer);
	
    if (this->dwFlags & DPLAYI_DPLAY_EXECUTINGPENDING)
    {
		// we get here when we try to flush the pending queue after completing a 
		// reliable send in execute pending mode.
        DPF(7,"We are already in execute pending mode - not flushing the pending queue");
        return DP_OK;
    }

	if (this->nMessagesPending) 
	{
		DPF(7,"STARTING -- EXECUTING PENDING LIST nCommands = %d\n",this->nMessagesPending);
		DPF(7,"	NOTE - ERROR MESSAGES GENERATED WHILE EXECUTING PENDING MAY BE BENIGN");
	}
	else 
	{
		ASSERT(NULL == this->pMessagesPending);
		this->dwFlags &= ~DPLAYI_DPLAY_PENDING;
		return DP_OK;
	}

	// mark that we're exec'ing the pending list, so player messages don't get copied again
	this->dwFlags |= DPLAYI_DPLAY_EXECUTINGPENDING;
	
	while (this->nMessagesPending)
	{
		// take the pending queue out of circulation
		pmsg = this->pMessagesPending;
		nMessagesPending = this->nMessagesPending;
		this->pMessagesPending = NULL;
		this->pLastPendingMessage = NULL;
		this->nMessagesPending = 0;

		while (pmsg)
		{
			nMessagesPending--;

			// checkpending looks for dup messages
			hr = CheckPendingMessage(this,pmsg);
			if (SUCCEEDED(hr))
			{
				// drop the lock since InternalHandleMessage will take it again
				LEAVE_DPLAY();

				hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,pmsg->pMessage,
					pmsg->dwMessageSize,pmsg->pHeader,pmsg->dwSendFlags);

				ENTER_DPLAY();

				if (FAILED(hr))
				{
					// todo - do we care about hresult here?
					// this can fail e.g. due to commands we q'ed being processed by
					// namesrvr b4 it send us the nametable...
					ASSERT(FALSE);
					// keep going...
				}
			}

			pmsgDelete = pmsg;
			pmsg = pmsg->pNextNode;  // store this now so we don't blow it away
			
			// clean up pmsgDelete
			if (pmsgDelete->pMessage) DPMEM_FREE(pmsgDelete->pMessage);
			if (VALID_SPHEADER(pmsgDelete->pHeader)) DPMEM_FREE(pmsgDelete->pHeader);
			DPMEM_FREE(pmsgDelete);
		}

		ASSERT(0 == nMessagesPending);

		// messages might have come into the pending queue when we dropped the lock
		// make sure they are all processed before exiting the loop
		DPF(7,"%d messages were pushed on the pending queue in execute pending mode",this->nMessagesPending);
	}

	ASSERT(0  == this->nMessagesPending);
	
	DPF(7,"FINISHED -- EXECUTING PENDING LIST - ERRORS NO LONGER BENIGN");
	
	// reset pending flags
	this->dwFlags &= ~(DPLAYI_DPLAY_EXECUTINGPENDING | DPLAYI_DPLAY_PENDING);
	
	return DP_OK;

} // ExecutePendingCommands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\perf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       perf.c
 *  Content:	uses a memory mapped file to send dp_perfdata to directx control
 *				panel.  see dpcpl.h and MANROOT\dxcpl\dplay.c
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  11/20/96	andyco	created it
 *
 ***************************************************************************/

#include "dplaypr.h"
#include "dpcpl.h"

#define DPF_MODNAME "performance thread"

// how often we send updates to cpl
#define PERF_INTERVAL 1000
// how long we wait before deciding cpl has gone away
#define PERF_TIMEOUT 5000

BOOL gbInitMapping; // is the mapping done?
LPDP_PERFDATA gpPerfData; // out global perfdata
HANDLE ghFile;  // handle to mapped file
HANDLE ghEvent; // event to notify cpl that there's new data
HANDLE ghMutex; // used to sync access to the mapped file
HANDLE ghAckEvent; // set by the control panel when it has processed our update

void FiniMappingStuff(LPDPLAYI_DPLAY this)
{
    if (ghFile) CloseHandle(ghFile),ghFile=NULL;
    if (ghEvent) CloseHandle(ghEvent),ghEvent=NULL;
    if (gpPerfData) UnmapViewOfFile(gpPerfData),gpPerfData = NULL;
    if (ghMutex) CloseHandle(ghMutex),ghMutex = NULL;
    if (ghAckEvent) CloseHandle(ghAckEvent),ghAckEvent=NULL;
    if (this->pPerfData) DPMEM_FREE(this->pPerfData),this->pPerfData = NULL;
	gbInitMapping = FALSE;
	
    return ;
	
} // FiniMappingStuff

HRESULT InitMappingStuff(LPDPLAYI_DPLAY this)
{
    // Create the file mapping
    ghFile = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,
		PAGE_READWRITE,	0, FILE_MAP_SIZE,FILE_MAP_NAME);

    if (NULL != ghFile && GetLastError() != ERROR_ALREADY_EXISTS)
    {
		// this is ok - we'll check again later
		DPF(9,"ack - file mapping didn't exist!");
		goto ERROR_EXIT;
    }

    gpPerfData = MapViewOfFile(ghFile, FILE_MAP_WRITE, 0, 0, 0);
    if (!gpPerfData)
    {
    	DPF_ERR("ack - could not map file");
    	goto ERROR_EXIT;
    }

    ghEvent = CreateEventA(NULL,FALSE,TRUE,EVENT_NAME);
    if (!ghEvent)
    {
    	DPF_ERR("could not create event!");
		goto ERROR_EXIT;
    }

    ghAckEvent = CreateEventA(NULL,FALSE,TRUE,ACK_EVENT_NAME);
    if (!ghAckEvent)
    {
    	DPF_ERR("could not create ack event!");
		goto ERROR_EXIT;
    }

    // used to sync access to the shared memory
    ghMutex = CreateMutexA( NULL, FALSE, MUTEX_NAME );
    if (!ghMutex)
    {
    	DPF_ERR("could not create Mutex!");
		goto ERROR_EXIT;
    }

    // alloc the perf data
    this->pPerfData = DPMEM_ALLOC(sizeof(DP_PERFDATA));
    if (!this->pPerfData)
    {
    	DPF_ERR("could not alloc perf data - out of memory!");
		goto ERROR_EXIT;
    }

    // set up the constant value stuff
    this->pPerfData->dwProcessID = GetCurrentProcessId();

    // get the exe name
   	if (!GetModuleFileNameA(NULL,this->pPerfData->pszFileName,MAX_NAME))
   	{
   		ASSERT(FALSE);
   	}

	gbInitMapping = TRUE;

    return S_OK;

ERROR_EXIT:
	FiniMappingStuff(this);
    return E_FAIL;

}  // InitMappingStuff

void ResetPerfData(LPDPLAYI_DPLAY this)
{
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS = 0;
		this->pPerfData->nReceiveBPS= 0;
		this->pPerfData->nSendPPS= 0;
		this->pPerfData->nReceivePPS= 0;
		this->pPerfData->nSendErrors= 0;
		this->pPerfData->bHost = FALSE;
	}
	
}  // ResetPerfData

void DoUpdateCPL(LPDPLAYI_DPLAY this)
{
	DWORD dwRet;

	ASSERT(this->pSysPlayer);

	// send a message to the dxcpl
	if (!gbInitMapping)
	{
		InitMappingStuff(this);
	}

	if (gbInitMapping)
	{
		ASSERT(gpPerfData);
		// take the lock
	    WaitForSingleObject( ghMutex, INFINITE );
		// copy local info to the shared perf data
		memcpy(gpPerfData,this->pPerfData,sizeof(DP_PERFDATA));
		// update the session name (in case it was changed)...
		WideToAnsi(gpPerfData->pszSessionName,this->lpsdDesc->lpszSessionName,MAX_NAME);
		// host?
		if (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) gpPerfData->bHost = TRUE;
		// nplayers
		gpPerfData->nPlayers = this->lpsdDesc->dwCurrentPlayers;
        // sp name
        ASSERT(this->pspNode);
	   	ASSERT(this->pspNode->lpszPath);
   		WideToAnsi(gpPerfData->pszSPName,this->pspNode->lpszName,MAX_NAME);

		// tell the cpl to process update
		SetEvent(ghEvent);
		
		LEAVE_DPLAY(); // so app isn't blocked while cpl processes data
		
		// wait for dxcpl to finish w/ it
		dwRet = WaitForSingleObject(ghAckEvent,PERF_TIMEOUT);

		ENTER_DPLAY();
		
		ReleaseMutex( ghMutex );

		if (WAIT_OBJECT_0 != dwRet)
		{
			// rut ro, cpl might have split
			// reset everything...
			DPF_ERR(" no response from control panel - resetting...");
			FiniMappingStuff(this);
		}
		// reset counters		
		ResetPerfData(this);
	}
	return ;

}//  DoUpdateCPL		

DWORD WINAPI PerfThreadProc(LPDPLAYI_DPLAY this)
{
	
	DWORD dwRet;
	HRESULT hr;
		
	DPF(1,"starting perf thread proc");
	
 	while (1)
 	{
		dwRet = WaitForSingleObject(this->hPerfEvent,PERF_INTERVAL);
		if (WAIT_OBJECT_0 == dwRet)
		{
			// if it's wait_object_0, someone set our event
			// dplay must be closing.  scram.
			goto CLEANUP_EXIT;
		}

		ENTER_DPLAY();

		hr = VALID_DPLAY_PTR(this);
		if ( FAILED(hr) || !(VALID_DPLAY_PLAYER(this->pSysPlayer))
			|| (this->dwFlags & DPLAYI_DPLAY_CLOSED))
		{
			LEAVE_DPLAY();
			goto CLEANUP_EXIT;
		}

		DoUpdateCPL(this);
		
		LEAVE_DPLAY();
	}	

CLEANUP_EXIT:
	FiniMappingStuff(this);
	DPF(1,"perf thread exiting");
	return 0;
	
} // PerfThreadProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\sendparm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sendparm.c
 *  Content:	management of send parameter structure
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  01/08/98  aarono    Original
 *  02/13/98  aarono    Fixed bugs found in async testing
 *  06/02/98  aarono    fix psp completion for invalid player
 *  6/10/98 aarono add PendingList to PLAYER and SENDPARM so we can track
 *                  pending sends and complete them on close.
 *  6/18/98   aarono    fix group SendEx ASYNC to use unique Header
 ***************************************************************************/

#include "dplaypr.h"
#include "mcontext.h"

// Release all memory/resources associated with a send and then the send parms themselves
VOID FreeSend(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bFreeParms)
{
	PGROUPHEADER pGroupHeader,pGroupHeaderNext;
	FreeMessageBuffers(psp);
	if(psp->hContext){
		ReleaseContextList(this, psp->hContext);	
	}
	pGroupHeader=psp->pGroupHeaders;
	while(pGroupHeader){
		ASSERT(psp->pGroupTo);
		pGroupHeaderNext=pGroupHeader->pNext;
		this->lpPlayerMsgPool->Release(this->lpPlayerMsgPool,pGroupHeader);
		pGroupHeader=pGroupHeaderNext;
	}
	if(bFreeParms){
		FreeSendParms(psp);
	}	
}

//
// Send Parm init/deinit.
//

BOOL SendInitAlloc(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	InitializeCriticalSection(&psp->cs);
	return TRUE;
}

VOID SendInit(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	psp->RefCount=1;
	psp->pGroupHeaders=NULL;
}

VOID SendFini(void *pvsp)
{
	LPSENDPARMS psp=(LPSENDPARMS)pvsp;
	DeleteCriticalSection(&psp->cs);
}

//
// Management of Context List
//

// initialize context list and info on a psp.
HRESULT InitContextList(LPDPLAYI_DPLAY this, PSENDPARMS psp, UINT nInitSize)
{
	psp->hContext=AllocateContextList(this,psp,nInitSize);
	if(!psp->hContext){
		return DPERR_OUTOFMEMORY;
	}
	
	*psp->lpdwMsgID=(DWORD_PTR)psp->hContext;
	
	psp->iContext=0;
	psp->nContext=nInitSize;
	return DP_OK;
}

// Note, this only works for context lists with an initial size > 1
UINT AddContext(LPDPLAYI_DPLAY this, PSENDPARMS psp, PVOID pvContext)
{
    UINT    n;
	PAPVOID papvList;
	UINT    nListEntries;

	PAPVOID papvNewList;
	UINT    nNewListEntries;

	EnterCriticalSection(&psp->cs);

	if(psp->iContext == psp->nContext){

			nNewListEntries=psp->iContext+4;
			// Need to grow the list
			// Get a new list
			papvNewList=AllocContextList(this,nNewListEntries);
			if(!papvNewList){
				return 0;
			}

			// transcribe the old list into the new list.
			ReadContextList(this,psp->hContext,&papvList,&nListEntries,FALSE);
			if(nListEntries){
				memcpy(papvNewList,papvList,nListEntries*sizeof(PVOID));
				// free the old list
				FreeContextList(this, papvList, nListEntries);
			}	


			// setup the new list in the psp
			WriteContextList(this, psp->hContext, papvNewList, nNewListEntries);
			psp->nContext   = nNewListEntries;
	}

	// Normal operation, set an entry.
	ReadContextList(this,psp->hContext,&papvList,&nListEntries,FALSE);
	(*papvList)[psp->iContext]=pvContext;
	
	n=psp->iContext++;

	LeaveCriticalSection(&psp->cs);
	
	return n;
}

UINT pspAddRefNZ(PSENDPARMS psp) // this one won't add to a zero refcount.
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount=++psp->RefCount;
	if(newCount==1){
		newCount=--psp->RefCount;
	}
	LeaveCriticalSection(&psp->cs);
	return newCount;
}

UINT pspAddRef(PSENDPARMS psp)
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount=++psp->RefCount;
	ASSERT(psp->RefCount != 0);
	LeaveCriticalSection(&psp->cs);
	return newCount;
}

#ifdef DEBUG
UINT nMessagesQueued=0;
#endif

UINT pspDecRef(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{
	UINT newCount;
	EnterCriticalSection(&psp->cs);
	newCount = --psp->RefCount;
	if(newCount&0x80000000){
		ASSERT(0); 
	}
	LeaveCriticalSection(&psp->cs);
	if(!newCount){
		// ref 0, no-one has another ref do completion message (if req'd), then free this baby
		if(!(psp->dwFlags & DPSEND_NOSENDCOMPLETEMSG) && (psp->dwFlags&DPSEND_ASYNC)){
			psp->dwSendCompletionTime=timeGetTime()-psp->dwSendTime;
			FreeSend(this,psp,FALSE); // must do here to avoid race with receiveQ
	 		#ifdef DEBUG
			nMessagesQueued++;
			#endif
			psp->pPlayerFrom = PlayerFromID(this,psp->idFrom);
			if (VALID_DPLAY_PLAYER(psp->pPlayerFrom)) {
				Delete(&psp->PendingList);
				InterlockedDecrement(&psp->pPlayerFrom->nPendingSends);
				DPF(9,"DEC pPlayerFrom %x, nPendingSends %d\n",psp->pPlayerFrom, psp->pPlayerFrom->nPendingSends);
				QueueSendCompletion(this, psp);
			}else{
				// This happens when client doesn't close players gracefully.
				DPF(0,"Got completion for blown away player?\n");
				FreeSendParms(psp);
			}
		} else {
			FreeSend(this,psp,TRUE);
		}
	}
	return newCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\sgl.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sgl.c
 *  Content:	functions for manipulating scatter gather lists.
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 * 12/18/97   aarono    Original
 ***************************************************************************/

#include "dplaypr.h"

void InsertSendBufferAtFront(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext)
{
	ASSERT(psp->cBuffers < MAX_SG);
	
	memmove(&psp->Buffers[1],&psp->Buffers[0],psp->cBuffers*sizeof(SGBUFFER));
	memmove(&psp->BufFree[1],&psp->BufFree[0],psp->cBuffers*sizeof(BUFFERFREE));
	psp->Buffers[0].pData=pData;
	psp->Buffers[0].len=len;
	psp->BufFree[0].fnFree=fnFree;
	psp->BufFree[0].lpvContext=lpvContext;
	psp->dwTotalSize+=len;
	psp->cBuffers++;
}

void InsertSendBufferAtEnd(LPSENDPARMS psp,LPVOID pData,INT len, FREE_ROUTINE fnFree, LPVOID lpvContext)
{
	UINT i = psp->cBuffers;

	ASSERT(psp->cBuffers < MAX_SG);
	
	
	psp->Buffers[i].pData=pData;
	psp->Buffers[i].len=len;
	psp->BufFree[i].fnFree=fnFree;
	psp->BufFree[i].lpvContext=lpvContext;
	psp->dwTotalSize+=len;
	psp->cBuffers++;
}

void FreeMessageBuffers(LPSENDPARMS psp)
{
	UINT i;
	for(i=0;i<psp->cBuffers;i++){
		if(psp->BufFree[i].fnFree){
			(*psp->BufFree[i].fnFree)(psp->BufFree[i].lpvContext,psp->Buffers[i].pData);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\sources.inc ===
!INCLUDE $(DXROOT)\dplay\bldcfg\dpvbld.inc

TARGETNAME=$(DPLAY_BUILD_FILENAME_DPLAYX)
TARGETTYPE=DYNLINK
UMTYPE=windows

USE_MAPSYM=1

INCLUDES=\
	$(DXROOT)\inc;\
	 ..\..\..\inc; \
	 ..\..\..\misc; \
	 ..\; \
	 ..\..\..\dvoice\inc; \
	 ..\..\..\dplobby\dplobby; \
	 ..\..\common; \

TARGETPATH=obj

PASS1_PUBLISH={ $(O)\dplayx.lib = $(SDK_LIB_PATH)\dplayx.lib}

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\gdi32.lib     \
           $(SDK_LIB_PATH)\libc.lib    \
           $(SDK_LIB_PATH)\rpcrt4.lib \
           $(SDK_LIB_PATH)\user32.lib    \
           $(SDK_LIB_PATH)\kernel32.lib  \
           $(SDK_LIB_PATH)\uuid.lib  \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\version.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\ole32.lib

DLLENTRY=DllMain

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DUNICODE -D_UNICODE \
!if "$(VOICE_TARGET)" == "gamevoice" 
	/DVOICE_BUILD_GAMEVOICE \
!endif
!if "$(VOICE_TARGET)" == "allegiance"
	/DVOICE_BUILD_ALLEGIANCE \
!endif
	-DNEW_DPF -DSECURITY_WIN32

LINKER_FLAGS=-SECTION:share,RWS

LINKLIBS= \
	 ..\..\..\dplobby\dplobby\$(PLAT_DIR)\$(_OBJ_DIR)\*\dplobby.lib \
	 ..\..\protocol\$(PLAT_DIR)\$(_OBJ_DIR)\*\protocol.lib

SOURCES= \
	..\loopbksp.c \
	..\dpdvtran.c \
	..\apphack.c \
	..\connect.c \
	..\perf.c \
	..\dpthread.c \
	..\paketize.c \
	..\api.c \
	..\dpos.c \
	..\iplaya.c \
	..\iplay1.c \
	..\dpunk.c \
	..\iplay.c \
	..\enum.c \
	..\dllmain.c \
	..\namesrv.c \
	..\handler.c \
	..\pack.c \
	..\sysmess.c \
	..\pending.c \
	..\sphelp.c \
	..\do.c \
	..\dpmem.c \
	..\classfac.c \
	..\dplay.rc \
	..\dpsecure.c \
	..\dpsecos.c \
	..\superpac.c \
	..\sendparm.c \
	..\sgl.c \
	..\mcontext.c \
	..\fpm.c \
	..\msgmem.c \
	memalloc.c \
	newdpf.c \
	dputils.c \
	..\dvretro.c

DLLDEF=..\$(DPLAY_BUILD_FILENAME_DPLAYX).def

NTTARGETFILE0=MISC

!ifndef  MAKEDLL
!if "$(__PRODUCT)" == "DX8"
MISCFILES=$(TARGET)
!endif
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\sphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sphelp.c
 *  Content:	helper functions for sp
 *
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	 6/6/96		andyco	created it
 *	6/22/96		kipo	added EnumConnectionData() method.
 *	6/24/96		andyco	added IDirectPlaySP to EnumConnectionData
 *	6/25/96		kipo	added support for DPADDRESS and changed GetFlags
 *						to GetPlayerFlags.
 *	6/28/96		kipo	added support for CreateAddress() method.
 *	7/11/96		andyco	changed guid * to refguid in createaddress.
 *	7/16/96		kipo	changed address types to be GUIDs instead of 4CC
 *	8/1/96		andyco	dplay keeps copy of sp's data, instead of pointer
 *	8/15/96		andyco	added local / remote to spdata
 *	1/2/97		myronth	added wrapper for CreateAddress and EnumAddress
 *	2/7/97		andyco	added get/set spdata
 *	2/18/97		kipo	fixed bugs #3285, #4638, and #4639 by checking for
 *						invalid flags correctly
 *	3/17/97		kipo	added support for CreateCompoundAddress()
 *  7/28/97		sohailm	address buffer chunks returned by EnumAddress were not
 *                      aligned.
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 ***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_SetSPPlayerData"

// store a chunk o' data w/ a player or group, or w/ the this ptr if lpPlayer is 
// NULL
HRESULT DoSPData(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER lpPlayer,LPVOID pvSource,
	DWORD dwSourceSize,DWORD dwFlags)
{
	LPVOID pvDest; // we set these two based on which flags 
	DWORD dwDestSize; // to dplayi_player->(local)data

	// figure out which dest they want
	if (NULL == lpPlayer)
	{
		pvDest = this->pvSPLocalData;
		dwDestSize = this->dwSPLocalDataSize;
	}
	else if (dwFlags & DPSET_LOCAL)
	{
		pvDest = lpPlayer->pvSPLocalData;
		dwDestSize = lpPlayer->dwSPLocalDataSize;
	}
	else 
	{
		pvDest = lpPlayer->pvSPData;
		dwDestSize = lpPlayer->dwSPDataSize;
	}

	// are we copying anything
	if (dwSourceSize)
	{
		// see if we need to alloc dest
		if (0 == dwDestSize)
		{
			ASSERT(!pvDest);
			pvDest = DPMEM_ALLOC(dwSourceSize);
			if (!pvDest)
			{
				DPF_ERR("could not alloc player blob!");
				return E_OUTOFMEMORY;
			}
		} // !pvDest
		// do we need to realloc?
		else if (dwSourceSize != dwDestSize)
		{
			LPVOID	pvTempSPData;

			ASSERT(pvDest);
			pvTempSPData = DPMEM_REALLOC(pvDest,dwSourceSize);
			if (!pvTempSPData)
			{
				DPF_ERR("could not re-alloc player blob!");
				return E_OUTOFMEMORY;
			}
		   	pvDest = pvTempSPData;
		}
		// copy the data over
		memcpy(pvDest,pvSource,dwSourceSize);
		dwDestSize = dwSourceSize;

	} // dwDataSize
	else 
	{
		// set it to NULL
		if (dwDestSize)
		{
			ASSERT(pvDest);
			DPMEM_FREE(pvDest);
			pvDest = NULL;
			dwDestSize = 0;
		}
	} // !dwSourceSize

	// update the appropriate pointer
	if (NULL == lpPlayer)
	{
		this->pvSPLocalData = pvDest;
		this->dwSPLocalDataSize = dwDestSize;
	}
	else if (dwFlags & DPSET_LOCAL)
	{
		lpPlayer->pvSPLocalData = pvDest;
		lpPlayer->dwSPLocalDataSize = dwDestSize;
	}
	else 
	{
		//
		// set the remote data
		lpPlayer->pvSPData = pvDest;
		lpPlayer->dwSPDataSize = dwDestSize;
	}

	return DP_OK;

} // DoSPData

   
#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_SetSPPlayerData"

//	 
// sp's can set a blob of data with a player (or group)
HRESULT DPAPI DP_SP_SetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }
		if (!VALID_STRING_PTR(pvData,dwDataSize))
		{
			LEAVE_DPLAY();
			DPF_ERR("SP - passed bad buffer");
            return DPERR_INVALIDPARAM;
		}

		if (dwFlags & ~DPSET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid flags");
			return DPERR_INVALIDFLAGS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	hr = DoSPData(this,lpPlayer,pvData,dwDataSize,dwFlags);	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		DPF_ERRVAL("could not set player data- hr = 0x%08lx\n",hr);
	}

	LEAVE_DPLAY();
	return hr;

} // DPlay_SetSPPlayerData

#ifdef BIGMESSAGEDEFENSE
#undef DPF_MODNAME
#define DPF_MODNAME	"HandleSPBigMessageNotification"

void HandleSPBigMessageNotification(LPDPLAYI_DPLAY this, LPDPSP_MSGTOOBIG pBigMessageInfo)
{
	DWORD				dwCommand;
	DWORD				dwVersion;
	DWORD				dwIDFrom = 0;
    LPDPLAYI_PLAYER 	lpPlayer;
    HRESULT				hr;
	
	DPF(6, "SP told us it got a message that's too big!\n");

 	// get the message pointer.  Let's see if we can
	// figure our who sent it and kill them
    hr = GetMessageCommand(this, pBigMessageInfo->pReceiveBuffer, 
    		pBigMessageInfo->dwMessageSize, &dwCommand, &dwVersion);
    if (FAILED(hr))
    {
    	DPF(6,"In HandleSPBigMessageNotification, unable to determine who sent us the message (the scum!)\n");
		return;
    }

	switch(dwCommand)
	{
		case DPSP_MSG_SIGNED:
		{
			dwIDFrom = ((LPMSG_SECURE)pBigMessageInfo->pReceiveBuffer)->dwIDFrom;
		}
		break;

		case DPSP_MSG_PLAYERMESSAGE:
		{
			if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
			{
				dwIDFrom = ((LPMSG_PLAYERMESSAGE)pBigMessageInfo->pReceiveBuffer)->idFrom;
			}
		}
		break;

		case DPSP_MSG_NEGOTIATE:
		case DPSP_MSG_CHALLENGERESPONSE:
		{
			dwIDFrom = ((LPMSG_AUTHENTICATION) pBigMessageInfo->pReceiveBuffer)->dwIDFrom;
		}
		break;
		case DPSP_MSG_ASK4MULTICASTGUARANTEED:
		case DPSP_MSG_ASK4MULTICAST:
		{
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pBigMessageInfo->pReceiveBuffer)->idPlayerFrom;
		}
		break;
		default:
		   	DPF(6,"In HandleSPBigMessageNotification, unable to determine who sent us the message (the scum!)\n");
		break;
	}
	
//	if we got a player id, kill them
	if (dwIDFrom != 0)
	{
    	DPF(6,"In HandleSPBigMessageNotification, Identified evil sender as %d!\n", dwIDFrom);

        lpPlayer = PlayerFromID(this,dwIDFrom);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
 			DPF(2, "Tried to get invalid player!: %d\n", dwIDFrom);
           return;
        }

    	DPF(6,"Removing player %d from our nametable!\n", dwIDFrom);
		hr = InternalDestroyPlayer(this,lpPlayer,IAM_NAMESERVER(this),FALSE);
		if (FAILED(hr))
		{
			DPF(2, "Error returned from InternalDestroyPlayer: %d\n", hr);
		}
	}
}


#undef DPF_MODNAME
#define DPF_MODNAME	"HandleSPPlayersConnectionLost"

void HandleSPPlayersConnectionLost(LPDPLAYI_DPLAY this, LPDPSP_PLAYERDEAD pBigMessageInfo)
{
    LPDPLAYI_PLAYER 	lpPlayer;
    HRESULT				hr;
	
	DPF(6, "SP told us it got a player's connection was lost!\n");

	if (pBigMessageInfo->dwID != 0)
	{
        lpPlayer = PlayerFromID(this,pBigMessageInfo->dwID);

        if (!VALID_DPLAY_PLAYER(lpPlayer)) 
        {
 			DPF(2, "Tried to get invalid player!: %d\n", pBigMessageInfo->dwID);
           return;
        }

    	DPF(6,"Removing player %d from our nametable!\n", pBigMessageInfo->dwID);
		hr = InternalDestroyPlayer(this,lpPlayer,IAM_NAMESERVER(this),FALSE);
		if (FAILED(hr))
		{
			DPF(2, "Error returned from InternalDestroyPlayer: %d\n", hr);
		}
	}
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_HandleSPMessage"

HRESULT DPAPI DP_SP_HandleSPWarning(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	DWORD			dwOpcode;

	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	dwOpcode = *((LPDWORD) pReceiveBuffer);
 	// look at the opcode and see if we understand what the SP is trying to tell us
 	switch(dwOpcode)
 	{
 		case DPSPWARN_MESSAGETOOBIG:
 			HandleSPBigMessageNotification(this, (LPDPSP_MSGTOOBIG)pReceiveBuffer);
 		break;

 		case DPSPWARN_PLAYERDEAD:
 			HandleSPPlayersConnectionLost(this, (LPDPSP_PLAYERDEAD) pReceiveBuffer);
 		break;
 		
 		default:
 			DPF(2, "Got a SP notification that we don't understand! %d\n", dwOpcode);
 		break;
 	}


	LEAVE_DPLAY();
	return hr;
} // DP_SP_HandleSPWarning

#endif /* BIGMESSAGEDEFENSE */

#undef DPF_MODNAME
#define DPF_MODNAME	"DPlay_GetSPPlayerData"
// 
// sp's can get the blob of data previously set w/ player or group
// we give out our pointer to the sp here (no data copying)
HRESULT DPAPI DP_SP_GetSPPlayerData(IDirectPlaySP * pISP,DPID id,LPVOID * ppvData,LPDWORD pdwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }

		if (dwFlags & ~DPGET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Invalid flags");
			return DPERR_INVALIDFLAGS;
		}

		*pdwDataSize = 0;
	 	*ppvData = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	if (dwFlags & DPGET_LOCAL)
	{
		*pdwDataSize  = lpPlayer->dwSPLocalDataSize;
		*ppvData = lpPlayer->pvSPLocalData;
	}
	else 
	{
		*pdwDataSize  = lpPlayer->dwSPDataSize;
		*ppvData = lpPlayer->pvSPData;
	}
	
	LEAVE_DPLAY();
	return DP_OK;

} // DPlay_GetSPPlayerData

// the sp can get the player (or group) flags (DPLAYI_PLAYER_xxx) with this call...
HRESULT DPAPI DP_SP_GetPlayerFlags(IDirectPlaySP * pISP,DPID id,LPDWORD pdwFlags)
{
	LPDPLAYI_PLAYER lpPlayer;
	LPDPLAYI_GROUP lpGroup;
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		lpPlayer = PlayerFromID(this,id);
        if ( !VALID_DPLAY_PLAYER(lpPlayer))
        {
			lpGroup = GroupFromID(this,id);
			if(!VALID_DPLAY_GROUP(lpGroup))
			{
				LEAVE_DPLAY();
				DPF_ERRVAL("SP - passed bad player / group id = %d", id);
				return DPERR_INVALIDPLAYER;
			}
			
			// Cast it to a player
			lpPlayer = (LPDPLAYI_PLAYER)lpGroup;
        }
		*pdwFlags = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }
	
	*pdwFlags = lpPlayer->dwFlags;

	LEAVE_DPLAY();
	return DP_OK;
} // DPlay_GetFlags


#undef DPF_MODNAME
#define DPF_MODNAME	"InternalCreateAddress"

// create address structure
HRESULT InternalCreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPADDRESSHEADER	lpHeader;
	DWORD			dwRequiredSize;
	HRESULT			hr;
	
    TRY
    {
		if (!VALID_READ_PTR(lpguidSP, sizeof(GUID)))
		{
			DPF_ERR("invalid SP GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_READ_PTR(lpguidDataType, sizeof(GUID)))
		{
			DPF_ERR("invalid data GUID pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_READ_PTR(lpData, dwDataSize))
		{
			DPF_ERR("passed invalid lpData pointer");
			return DPERR_INVALIDPARAMS;	
		}

		if (!VALID_DWORD_PTR(lpdwAddressSize))
		{
			DPF_ERR("invalid lpdwAddressSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!lpAddress) *lpdwAddressSize = 0;
		if (*lpdwAddressSize && !VALID_WRITE_PTR(lpAddress,*lpdwAddressSize))
		{
			DPF_ERR("invalid lpAddress pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// make sure we have enough space
	dwRequiredSize = sizeof(ADDRESSHEADER) + dwDataSize;	
	if (*lpdwAddressSize < dwRequiredSize)
	{
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		lpHeader = (LPADDRESSHEADER) lpAddress;

		// create service provider chunk
		// 1st, size
		lpHeader->dpaSizeChunk.guidDataType = DPAID_TotalSize;
		lpHeader->dpaSizeChunk.dwDataSize = sizeof(DWORD);		
		lpHeader->dwTotalSize = dwRequiredSize;
		// next, SP guid
		lpHeader->dpaSPChunk.guidDataType = DPAID_ServiceProvider;
		lpHeader->dpaSPChunk.dwDataSize = sizeof(GUID);
		lpHeader->guidSP = *lpguidSP;

		// create data chunk
		lpHeader->dpaAddressChunk.guidDataType = *lpguidDataType;
		lpHeader->dpaAddressChunk.dwDataSize = dwDataSize;
		memcpy((LPBYTE) lpHeader + sizeof(ADDRESSHEADER), lpData, dwDataSize);		

		hr = DP_OK;
	}
	
	*lpdwAddressSize = dwRequiredSize;

	return (hr);
} // InternalCreateAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_CreateAddress"
HRESULT DPAPI DP_SP_CreateAddress(IDirectPlaySP * pISP,
	REFGUID lpguidSP, REFGUID lpguidDataType, LPCVOID lpData, DWORD dwDataSize,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalCreateAddress(pISP, lpguidSP, lpguidDataType, lpData,
								dwDataSize, lpAddress, lpdwAddressSize);

} // CreateAddress

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalCreateCompoundAddress"

// create address with multiple chunks
HRESULT InternalCreateCompoundAddress(
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPADDRESSHEADER	lpHeader;
	DWORD			dwRequiredSize, dwTotalDataSize, i;
	LPBYTE			lpb;
	HRESULT			hr;
	
    TRY
    {
		if (!VALID_READ_PTR(lpAddressElements, dwAddressElementCount * sizeof(DPCOMPOUNDADDRESSELEMENT)))
		{
			DPF_ERR("invalid address elements pointer");
			return DPERR_INVALIDPARAMS;	
		}

		dwTotalDataSize = 0;
		for (i = 0; i < dwAddressElementCount; i++)
		{
			if (!VALID_READ_PTR(lpAddressElements[i].lpData, lpAddressElements[i].dwDataSize))
			{
				DPF_ERR("passed invalid lpData pointer");
				return DPERR_INVALIDPARAMS;	
			}
			dwTotalDataSize += lpAddressElements[i].dwDataSize;
		}

		if (!VALID_DWORD_PTR(lpdwAddressSize))
		{
			DPF_ERR("invalid lpdwAddressSize");
			return DPERR_INVALIDPARAMS;	
		}

		if (!lpAddress) *lpdwAddressSize = 0;
		if (*lpdwAddressSize && !VALID_WRITE_PTR(lpAddress,*lpdwAddressSize))
		{
			DPF_ERR("invalid lpAddress pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// make sure we have enough space
	dwRequiredSize = sizeof(DPADDRESS) + sizeof(DWORD) +
					 sizeof(DPADDRESS) * dwAddressElementCount + dwTotalDataSize;	
	if (*lpdwAddressSize < dwRequiredSize)
	{
		hr = DPERR_BUFFERTOOSMALL;
	}
	else 
	{
		lpHeader = (LPADDRESSHEADER) lpAddress;

		// create total size chunk at beginning of address
		lpHeader->dpaSizeChunk.guidDataType = DPAID_TotalSize;
		lpHeader->dpaSizeChunk.dwDataSize = sizeof(DWORD);		
		lpHeader->dwTotalSize = dwRequiredSize;

		// pack all the other chunks
		lpb = (LPBYTE) lpAddress + sizeof(DPADDRESS) + sizeof(DWORD);
		for (i = 0; i < dwAddressElementCount; i++)
		{
			// chunk descriptor
			lpAddress = (LPDPADDRESS) lpb;
			lpAddress->guidDataType = lpAddressElements[i].guidDataType;
			lpAddress->dwDataSize = lpAddressElements[i].dwDataSize;
			lpb += sizeof(DPADDRESS);

			// chunk data
			memcpy(lpb, lpAddressElements[i].lpData, lpAddressElements[i].dwDataSize);
			lpb += lpAddressElements[i].dwDataSize;
		}

		hr = DP_OK;
	}
	
	*lpdwAddressSize = dwRequiredSize;

	return (hr);
} // InternalCreateCompoundAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_CreateCompoundAddress"
HRESULT DPAPI DP_SP_CreateCompoundAddress(IDirectPlaySP * pISP,
	LPDPCOMPOUNDADDRESSELEMENT lpAddressElements, DWORD dwAddressElementCount,
	LPDPADDRESS lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalCreateCompoundAddress(lpAddressElements, dwAddressElementCount,
								   lpAddress, lpdwAddressSize);

} // CreateCompoundAddresses

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalEnumAddress"

// enumerate the chunks in a connection data buffer
HRESULT InternalEnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext)
{
	LPDPADDRESS		lpChunk, lpCopy=NULL;
	DWORD			dwAmountParsed;
	BOOL			bContinue;
	HRESULT         hr;
	
    TRY
    {
		if (!VALIDEX_CODE_PTR(lpEnumCallback))
		{
		    DPF_ERR("Invalid callback routine");
		    return (DPERR_INVALIDPARAMS);
		}

		if (!VALID_READ_PTR(lpAddress, dwAddressSize))
		{
			DPF_ERR("Bad data buffer");
            return (DPERR_INVALIDPARAMS);
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// Allocate a buffer big enough to accomodate any address chunk embedded 
	// in the passed in buffer. We are making local copies here to ensure proper 
	// memory alignment of the address chunks.
	lpCopy = DPMEM_ALLOC(dwAddressSize);
	if (!lpCopy)
	{
		DPF_ERR("Failed to copy address buffer (for alignment) - out of memory");
		return DPERR_OUTOFMEMORY;
	}
	
	lpChunk = (LPDPADDRESS) lpAddress;
	dwAmountParsed = 0;
	while (dwAmountParsed < dwAddressSize)
	{
		// don't walk off the end of the buffer reading chunk header
		if ((dwAmountParsed + sizeof(DPADDRESS)) > dwAddressSize)
		{
			hr = DPERR_INVALIDPARAMS;
			goto CLEANUP_EXIT;
		}

		// don't walk off the end of the buffer reading chunk data
		if ((dwAmountParsed + sizeof(DPADDRESS) + lpChunk->dwDataSize) > dwAddressSize)
		{
			hr = DPERR_INVALIDPARAMS;
			goto CLEANUP_EXIT;
		}

		// copy address chunk to local buffer
		memcpy(lpCopy, lpChunk, sizeof(DPADDRESS) + lpChunk->dwDataSize);

		// call the callback
		bContinue = (lpEnumCallback)(&lpCopy->guidDataType, lpCopy->dwDataSize,
								   (LPBYTE)lpCopy + sizeof(DPADDRESS), lpContext);

		// callback asked to stop
		if (!bContinue)
		{
			hr = DP_OK;
			goto CLEANUP_EXIT;
		}

		dwAmountParsed += sizeof(DPADDRESS) + lpChunk->dwDataSize;
		lpChunk = (LPDPADDRESS) ((LPBYTE)lpAddress + dwAmountParsed);
	}

	// sucess
	hr = DP_OK;

	// fall through

CLEANUP_EXIT:
	// cleanup allocations
	if (lpCopy) DPMEM_FREE(lpCopy);
	return hr;

} // EnumAddress


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_EnumAddress"
HRESULT DPAPI DP_SP_EnumAddress(IDirectPlaySP * pISP,
	LPDPENUMADDRESSCALLBACK lpEnumCallback, LPCVOID lpAddress, DWORD dwAddressSize,
	LPVOID lpContext)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	return InternalEnumAddress(pISP, lpEnumCallback, lpAddress,
								dwAddressSize, lpContext);

} // EnumAddress


// Registry definitions
#define MRU_KEY_PARENT      HKEY_CURRENT_USER
#define MRU_KEY_TOP         L"Software\\Microsoft\\DirectPlay\\Service Providers"

// Entry linked list node
typedef struct tagENTRYNODE
{
    struct tagENTRYNODE     *lpNext;
    LPVOID                  lpvData;
    DWORD                   dwSize;
} ENTRYNODE, *LPENTRYNODE;

// Entry linked list head
LPENTRYNODE                 g_lpEntryListHead = NULL;

// Local prototypes
HRESULT InternalEnumMRUEntries(LPCWSTR lpszSection, LPCWSTR lpszKey, LPENUMMRUCALLBACK fnCallback, LPVOID lpvContext, DWORD dwMaxEntries);
BOOL CALLBACK InternalEnumMRUCallback(LPCVOID, DWORD, LPVOID);
LPENTRYNODE AddEntryNode(LPVOID, DWORD);
LPENTRYNODE RemoveEntryNode(LPENTRYNODE);
void FreeEntryList(void);
int CompareMemory(LPCVOID, LPCVOID, DWORD);
long RegDelAllValues(HKEY);
long OpenMRUKey(LPCWSTR, LPCWSTR, HKEY *, DWORD);
int wstrlen(LPCWSTR);
int wstrcpy(LPWSTR, LPCWSTR);
int wstrcat(LPWSTR, LPCWSTR);


// ---------------------------------------------------------------------------
// EnumMRUEntries
// ---------------------------------------------------------------------------
// Description:             Enumerates entries stored in the service provider
//                          MRU list, passing each to a callback function.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPENUMMRUCALLBACK  Pointer to the application-defined callback
//                          function.
//  [in] LPVOID             Context passed to callback function.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT DPAPI DP_SP_EnumMRUEntries(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPENUMMRUCALLBACK fnCallback,
					LPVOID lpvContext)
{
	LPDPLAYI_DPLAY	this;
	HRESULT hr;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

	// Call the internal enumeration routine
    return InternalEnumMRUEntries(lpszSection, lpszKey, fnCallback, lpvContext, MAXDWORD);
}


// ---------------------------------------------------------------------------
// AddMRUEntry
// ---------------------------------------------------------------------------
// Description:             Adds a new entry to the MRU list.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPVOID             New data.
//  [in] DWORD              New data size.
//  [in] DWORD              Maximum number of entries to save.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT DPAPI DP_SP_AddMRUEntry(IDirectPlaySP * pISP,
					LPCWSTR lpszSection, LPCWSTR lpszKey,
					LPCVOID lpvData, DWORD dwDataSize, DWORD dwMaxEntries)
{
    HRESULT                 hr;             // Return code
    HKEY                    hKey;           // Registry key
    LPENTRYNODE             lpNode;         // Generic linked list node
    long                    lResult;        // Return code from registry operations
    char                    szValue[13];    // New value name
    WCHAR                   szWValue[13];   // Unicode version of above name
    DWORD                   dwIndex;        // Current value index
	LPDPLAYI_DPLAY			this;
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            return hr;
        }
		if (!VALID_READ_PTR(lpvData, dwDataSize))
		{
			DPF_ERR("passed invalid lpvData pointer");
			return DPERR_INVALIDPARAMS;	
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }

    // Enumerate existing entries, adding each one to the linked list
    FreeEntryList();

    if(FAILED(hr = InternalEnumMRUEntries(lpszSection, lpszKey, InternalEnumMRUCallback, NULL, dwMaxEntries)))
    {
        FreeEntryList();
        return hr;
    }

    // Create the registry key
    if((lResult = OpenMRUKey(lpszSection, lpszKey, &hKey, GENERIC_WRITE)) != ERROR_SUCCESS)
    {
        FreeEntryList();
        return DPERR_GENERIC;
    }

    // Delete all existing values
    RegDelAllValues(hKey);

    // Search for a match to the passed-in data in the linked list
    lpNode = g_lpEntryListHead;

    while(lpNode)
    {
        if(lpNode->dwSize == dwDataSize && !CompareMemory(lpNode->lpvData, lpvData, dwDataSize))
        {
            // Item appears in the list.  Remove it.
            lpNode = RemoveEntryNode(lpNode);
        }
        else
        {
            lpNode = lpNode->lpNext;
        }
    }

    // Write the new data to the beginning of the list
    dwIndex = 0;

    if(dwMaxEntries)
    {
        wsprintfA(szValue, "%lu", dwIndex);
        AnsiToWide(szWValue, szValue, sizeof(szWValue));

        if((lResult = OS_RegSetValueEx(hKey, szWValue, 0, REG_BINARY, lpvData, dwDataSize)) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            FreeEntryList();
            return DPERR_GENERIC;
        }

        dwIndex++;
    }

    // Write all other entries to the list
    lpNode = g_lpEntryListHead;
    
    while(dwIndex < dwMaxEntries && lpNode)
    {
        wsprintfA(szValue, "%lu", dwIndex);
        AnsiToWide(szWValue, szValue, sizeof(szWValue));

        if((lResult = OS_RegSetValueEx(hKey, szWValue, 0, REG_BINARY, lpNode->lpvData, lpNode->dwSize)) != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            FreeEntryList();
            return DPERR_GENERIC;
        }

        dwIndex++;
        lpNode = lpNode->lpNext;
    }

    // Clean up
    RegCloseKey(hKey);
    FreeEntryList();

    // Return success
    return DP_OK;
}


// ---------------------------------------------------------------------------
// InternalEnumMRUEntries
// ---------------------------------------------------------------------------
// Description:             Enumerates entries stored in the service provider
//                          MRU list, passing each to a callback function.
// Arguments:
//  [in] LPCWSTR            Registry section name.  Should be the same
//                          description string used to identify the service
//                          provider.
//  [in] LPCWSTR            Registry key name.  Something like 'MRU'.
//  [in] LPENUMMRUCALLBACK  Pointer to the application-defined callback
//                          function.
//  [in] LPVOID             Context passed to callback function.
//  [in] DWORD              Maximum count of entries to enumerate.
// Returns:
//  HRESULT                 DirectPlay error code.
HRESULT InternalEnumMRUEntries(LPCWSTR lpszSection, LPCWSTR lpszKey, LPENUMMRUCALLBACK fnCallback, LPVOID lpvContext, DWORD dwMaxEntries)
{
    HKEY                    hKey;           // Registry key
    long                    lResult;        // Return from registry calls
    DWORD                   dwMaxNameSize;  // Maximum size of registry value names
    DWORD                   dwMaxDataSize;  // Maximum size of registry value data
    LPWSTR                  lpszName;       // Value name
    LPBYTE                  lpbData;        // Value data
    DWORD                   dwNameSize;     // Size of this value name
    DWORD                   dwDataSize;     // Size of this value data
    BOOL                    fContinue;      // Continue enumeration
    DWORD                   dwType;         // Type of registry data.  Must be REG_BINARY
    DWORD                   dwIndex;        // Current value index

    TRY
    {
		if (!VALID_READ_STRING_PTR(lpszSection, WSTRLEN_BYTES(lpszSection))) 
		{
		    DPF_ERR( "bad section string pointer" );
		    return DPERR_INVALIDPARAMS;
		}
		if (!VALID_READ_STRING_PTR(lpszKey, WSTRLEN_BYTES(lpszKey))) 
		{
		    DPF_ERR( "bad key string pointer" );
		    return DPERR_INVALIDPARAMS;
		}

		if (!VALIDEX_CODE_PTR(fnCallback))
		{
		    DPF_ERR("Invalid callback routine");
		    return (DPERR_INVALIDPARAMS);
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        return (DPERR_EXCEPTION);
    }
    
    // Open the registry key
    if((lResult = OpenMRUKey(lpszSection, lpszKey, &hKey, GENERIC_READ)) != ERROR_SUCCESS)
    {
        // Key doesn't exist.  Nothing to enumerate.
        return DP_OK;
    }

    // Get maximum sizes for names and data
    if((lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxNameSize, &dwMaxDataSize, NULL, NULL)) != ERROR_SUCCESS)
    {
        // No values to enumerate
        RegCloseKey(hKey);
        return DP_OK;
    }

    // Name size does not include the NULL terminator
    dwMaxNameSize++;

    // Nor does it use WCHAR
    dwMaxNameSize *= sizeof(WCHAR);
    
    // Allocate memory
    if(!(lpszName = (LPWSTR)DPMEM_ALLOC(dwMaxNameSize)))
    {
        RegCloseKey(hKey);
        return DPERR_OUTOFMEMORY;
    }

    if(!(lpbData = (LPBYTE)DPMEM_ALLOC(dwMaxDataSize)))
    {
        DPMEM_FREE(lpszName);
        RegCloseKey(hKey);
        return DPERR_OUTOFMEMORY;
    }

    // Enumerate values
    dwIndex = 0;
    fContinue = TRUE;

    while(dwIndex < dwMaxEntries && fContinue)
    {
        // Get value name and data
        dwNameSize = dwMaxNameSize;
        dwDataSize = dwMaxDataSize;

        if((lResult = OS_RegEnumValue(hKey, dwIndex, lpszName, &dwNameSize, NULL, &dwType, lpbData, &dwDataSize)) != ERROR_SUCCESS)
        {
            // No more entries
            break;
        }

        // Validate type.  Must be REG_BINARY
        if(dwType == REG_BINARY)
        {
            // Call callback function
            fContinue = fnCallback(lpbData, dwDataSize, lpvContext);
        }

        // Next value, please
        dwIndex++;
    }

    // Free memory
    DPMEM_FREE(lpszName);
    DPMEM_FREE(lpbData);

    // Close the registry key
    RegCloseKey(hKey);

    // Return success
    return DP_OK;
}


// ---------------------------------------------------------------------------
// InternalEnumMRUCallback
// ---------------------------------------------------------------------------
// Description:             Callback function for InternalEnumMRUEntries.
//                          Called from AddMRUEntry to create a linked list
//                          of entries.
// Arguments:
//  LPVOID                  Data.
//  DWORD                   Data size.
//  LPVOID                  Context.
// Returns:
//  BOOL                    TRUE to continue enumeration.
BOOL CALLBACK InternalEnumMRUCallback(LPVOID lpvData, DWORD dwDataSize, LPVOID lpvContext)
{
    AddEntryNode(lpvData, dwDataSize);
    return TRUE;
}


// ---------------------------------------------------------------------------
// AddEntryNode
// ---------------------------------------------------------------------------
// Description:             Adds an MRU entry to the linked list
// Arguments:
//  [in] LPVOID             Data.
//  [in] DWORD              Data size.
// Returns:
//  LPENTRYNODE             Pointer to the node in the list, or NULL on 
//                          failure.
LPENTRYNODE AddEntryNode(LPVOID lpvData, DWORD dwDataSize)
{
    LPENTRYNODE             lpNode;         // Generic node pointer

    if(g_lpEntryListHead)
    {
        // Seek to the end of the list
        lpNode = g_lpEntryListHead;

        while(lpNode->lpNext)
            lpNode = lpNode->lpNext;

        // Allocate memory for the new node
        if(!(lpNode->lpNext = (LPENTRYNODE)DPMEM_ALLOC(sizeof(ENTRYNODE) + dwDataSize)))
        {
            return NULL;
        }

        lpNode = lpNode->lpNext;
    }
    else
    {
        // Allocate memory for the new node
        if(!(lpNode = g_lpEntryListHead = (LPENTRYNODE)DPMEM_ALLOC(sizeof(ENTRYNODE) + dwDataSize)))
        {
            return NULL;
        }
    }

    // Copy the data
    lpNode->lpNext = NULL;
    lpNode->lpvData = lpNode + 1;
    lpNode->dwSize = dwDataSize;
    
    CopyMemory(lpNode->lpvData, lpvData, dwDataSize);

    // Return success
    return lpNode;
}


// ---------------------------------------------------------------------------
// RemoveEntryNode
// ---------------------------------------------------------------------------
// Description:             Removes an MRU entry from the linked list.
// Arguments:
//  [in] LPENTRYNODE        Node to remove.
// Returns:
//  LPENTRYNODE             Pointer to the next node in the list, or NULL on
//                          failure.
LPENTRYNODE RemoveEntryNode(LPENTRYNODE lpRemove)
{
    LPENTRYNODE             lpNode;         // Generic node pointer

    // Make sure there's really a list
    if(!g_lpEntryListHead)
    {
        return NULL;
    }

    // Is the node to remove the list head?
    if(lpRemove == g_lpEntryListHead)
    {
        // Remove the current list head and replace it
        lpNode = g_lpEntryListHead->lpNext;
        DPMEM_FREE(g_lpEntryListHead);
        g_lpEntryListHead = lpNode;
    }
    else
    {
        // Find the node in the list and remove it
        lpNode = g_lpEntryListHead;

        while(lpNode->lpNext && lpNode->lpNext != lpRemove)
            lpNode = lpNode->lpNext;

        if(lpNode->lpNext != lpRemove)
        {
            // Couldn't find the node
            return NULL;
        }

        // Remove the node
        lpNode->lpNext = lpRemove->lpNext;
        DPMEM_FREE(lpRemove);
        lpNode = lpNode->lpNext;
    }

    // Return success
    return lpNode;
}


// ---------------------------------------------------------------------------
// FreeEntryList
// ---------------------------------------------------------------------------
// Description:             Frees the entire MRU entry list.
// Arguments:
//  void
// Returns:
//  void
void FreeEntryList(void)
{
    LPENTRYNODE             lpNode = g_lpEntryListHead;

    while(lpNode)
    {
        lpNode = RemoveEntryNode(lpNode);
    }
}


// ---------------------------------------------------------------------------
// CompareMemory
// ---------------------------------------------------------------------------
// Description:             Compares two memory buffers.
// Arguments:
//  [in] LPVOID             First buffer to compare.
//  [in] LPVOID             Second buffer to compare.
//  [in] DWORD              Buffer sizes.  Don't even bother calling this
//                          function if the sizes differ.
// Returns:
//  int                     0 if the buffers compare.
int CompareMemory(LPVOID lpv1, LPVOID lpv2, DWORD dwSize)
{
    if(!dwSize)
    {
        return 0;
    }

    while(dwSize--)
    {
        if(*(LPBYTE)lpv1 != *(LPBYTE)lpv2)
        {
            return *(LPBYTE)lpv1 - *(LPBYTE)lpv2;
        }
    }

    return 0;
}


// ---------------------------------------------------------------------------
// RegDelAllValues
// ---------------------------------------------------------------------------
// Description:             Removes all values from a registry key.
// Arguments:
//  [in] HKEY               Key to clean.
// Returns:
//  long                    Registry error code.
long RegDelAllValues(HKEY hKey)
{
    long                    lResult;            // Registry error code
    DWORD                   dwMaxNameSize;      // Maximum value name size
    LPWSTR                  lpszName;           // Value name
    DWORD                   dwNameSize;         // Value name size

    // Get maximum name size
    if((lResult = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &dwMaxNameSize, NULL, NULL,NULL)) != ERROR_SUCCESS)
    {
        return lResult;
    }

    // Allocate memory
    dwMaxNameSize++;
    dwMaxNameSize *= sizeof(WCHAR);

    if(!(lpszName = (LPWSTR)DPMEM_ALLOC(dwMaxNameSize)))
    {
        return ERROR_OUTOFMEMORY;
    }

    // Enumerate all values
    while(1)
    {
        // Get name
        dwNameSize = dwMaxNameSize;

        if((lResult = OS_RegEnumValue(hKey, 0, lpszName, &dwNameSize, NULL, NULL, NULL, NULL)) != ERROR_SUCCESS)
        {
            break;
        }

        // Delete the value
        OS_RegDeleteValue(hKey, lpszName);
    }

    // Free memory
    DPMEM_FREE(lpszName);

    // Return success
    return ERROR_SUCCESS;
}


// ---------------------------------------------------------------------------
// OpenMRUKey
// ---------------------------------------------------------------------------
// Description:             Opens the MRU registry key.
// Arguments:
//  [in] LPCWSTR            Section name.
//  [in] LPCWSTR            Key name.
//  [out] HKEY *            Pointer to a registry key handle.
//  [in] DWORD              Open flags.
// Returns:
//  long                    Registry error code.
long OpenMRUKey(LPCWSTR lpszSection, LPCWSTR lpszKey, HKEY *lphKey, DWORD dwFlags)
{
    LPWSTR                  lpszFullKey;    // Full key name
    long                    lResult;        // Error code
    DWORD                   dwAction;       // Action returned from RegCreateKeyEx()
    
    // Get the full key name
    if(!(lpszFullKey = (LPWSTR)DPMEM_ALLOC((wstrlen(MRU_KEY_TOP) + 1 + wstrlen(lpszSection) + 1 + wstrlen(lpszKey) + 1) * sizeof(WCHAR))))
    {
        return ERROR_OUTOFMEMORY;
    }

    wstrcpy(lpszFullKey, MRU_KEY_TOP);
    wstrcat(lpszFullKey, L"\\");
    wstrcat(lpszFullKey, lpszSection);
    wstrcat(lpszFullKey, L"\\");
    wstrcat(lpszFullKey, lpszKey);

    // Open or create the key
    if(dwFlags == GENERIC_READ)
    {
        lResult = OS_RegOpenKeyEx(MRU_KEY_PARENT, lpszFullKey, 0, KEY_ALL_ACCESS, lphKey);
    }
    else
    {
        lResult = OS_RegCreateKeyEx(MRU_KEY_PARENT, lpszFullKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, lphKey, &dwAction);
    }

    // Free memory
    DPMEM_FREE(lpszFullKey);

    // Return
    return lResult;
}


// ---------------------------------------------------------------------------
// wstrlen, wstrcpy, wstrcat
// ---------------------------------------------------------------------------
// Description:             Unicode string helper functions.
int wstrlen(LPCWSTR lpszString)
{
    int                     nLen = 0;

    while(*lpszString++)
    {
        nLen++;
    }

    return nLen;
}


int wstrcpy(LPWSTR lpszDest, LPCWSTR lpszSrc)
{
    int                     nLen = 0;
    
    while(*lpszSrc)
    {
        *lpszDest++ = *lpszSrc++;
        nLen++;
    }

    *lpszDest = 0;

    return nLen;
}


int wstrcat(LPWSTR lpszDest, LPCWSTR lpszSrc)
{
    while(*lpszDest)
    {
        lpszDest++;
    }

    return wstrcpy(lpszDest, lpszSrc);
}


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_GetSPData"

// 
// sp's can get the blob of data previously set w/ this IDirectPlay pointer
// we give out our pointer to the sp here (no data copying)
HRESULT DPAPI DP_SP_GetSPData(IDirectPlaySP * pISP,LPVOID * ppvData,LPDWORD pdwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (dwFlags != DPGET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Local data only supported for this release");
			return E_NOTIMPL;
		}
		
		*pdwDataSize = 0;
	 	*ppvData = 0;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	*pdwDataSize  = this->dwSPLocalDataSize;
	*ppvData = this->pvSPLocalData;

	LEAVE_DPLAY();
	return DP_OK;

} // DPlay_GetSPPlayerData

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_SetSPData"

//	 
// sp's can set a blob of data with each idirectplaysp 
HRESULT DPAPI DP_SP_SetSPData(IDirectPlaySP * pISP,LPVOID pvData,DWORD dwDataSize,
	DWORD dwFlags)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;
	
	ENTER_DPLAY();
	
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (!VALID_STRING_PTR(pvData,dwDataSize))
		{
			LEAVE_DPLAY();
			DPF_ERR("SP - passed bad buffer");
            return DPERR_INVALIDPARAM;
		}

		if (dwFlags != DPSET_LOCAL)
		{
			LEAVE_DPLAY();
			DPF_ERR("Local data only supported for this release");
			return E_NOTIMPL;
		}

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
        DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_EXCEPTION;
    }

	hr = DoSPData(this,NULL,pvData,dwDataSize,dwFlags);	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		DPF_ERRVAL("could not set idirectplaysp data- hr = 0x%08lx\n",hr);
	}

	LEAVE_DPLAY();
	return hr;

} // DPlay_SetSPPlayerData


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\superpac.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SuperPack.c
 *  Content:	SuperPacks / unSuperPacks players + group before / after network xport
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  4/16/97		andyco	created it
 *  6/22/97     sohailm updated to use pClientInfo.
 *  8/4/97		andyco	track this->dwMinVersion as we unpack
 *	11/5/97		myronth	Expose lobby ID's as DPID's in lobby sessions
 *   4/1/98     aarono  don't propogate local only player flags
 ***************************************************************************/

 /**************************************************************************
 *
 * SuperPacked player format :                                            
 *
 *	fixed fields
 *		dwFixedSize - size of fixed struct
 *		dwFlags - player or group flags (DPLAYI_
 *		DPID - the id of the player or group
 *		dwMask - bitfield indicating which optional fields are present
 *	
 *	optional fields
 *		dwVersion - version of player - present if dwFlags & DPLAYI_PLAYER_SYSPLAYER
 *		idSysPlayer - present if ! (dwFlags & DPLAYI_PLAYER_SYSPLAYER)
 *		dwSPDataSize 
 *		pvSPData 
 *		dwPlayerDataSize
 *		pvPlayerData
 *		pszShortName
 *		pszLongName
 *		dwNPlayers - # players in a group
 *		dwNGroupGroups - the number of contained groups in a group
 *
 *	after all the packed players and groups comes a list of linked groups 
 *
 **************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"SuperSuperPack! -- "

// offsets within mask of fields
#define SHORTSTR 	0 // 1 bit - string or not
#define LONGSTR 	1 // 1 bit - string or not
#define	SPDATA		2 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define	PLAYERDATA	4 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define NPLAYERS	6 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size
#define	IDPARENT	8 // 1 bit - present or not
#define SHORTCUTS	9 // 2 bits - not present (0), byte (1), word (2) or dword (3) for size

// constants used to define whether we've written a value into our buffer using a 
// byte, word, or dword
#define SIZE_BYTE	1
#define SIZE_WORD	2
#define SIZE_DWORD	3

// used to determine if the size fits in byte, word or dword
#define BYTE_MASK 0xFFFFFF00
#define WORD_MASK 0xFFFF0000

// extract dwBits bits from the dword dwMask, from loc'n dwOffset
DWORD GetMaskValue(DWORD dwMask,DWORD dwOffset,DWORD dwBits)
{
	DWORD rval;
	
	// shift it right to shift off right most bits
	rval = dwMask >> dwOffset;
	
	// shift it left to shift off left most bits
	rval = rval << (32 - dwBits);
	
	// shitf it back to right align rval
	rval = rval >> (32 - dwBits);	

	return rval;
		
} // GetMaskValue

DWORD GetSize(LPBYTE * ppBufferIndex,DWORD dwMaskValue)
{
	DWORD rval;

	// pick off the dword
	rval = *((LPDWORD)*ppBufferIndex);	

	switch (dwMaskValue)
	{
		// trim any extra bits, and advance ppBufferIndex as necessary
		case SIZE_BYTE:
			rval &= ~BYTE_MASK;			
			*ppBufferIndex += sizeof(BYTE);
			break;
		case SIZE_WORD:
			rval &= ~WORD_MASK;
			*ppBufferIndex += sizeof(WORD);			
			break;
		case SIZE_DWORD:			
			*ppBufferIndex += sizeof(DWORD);			
			break;
		default:
			ASSERT(FALSE);
			break;
	}	
	
	return rval;
	
} // GetSize

/*
 ** UnSuperpackPlayer
 *
 *  CALLED BY: UnSuperpackPlayerAndGroupList
 *
 *  PARAMETERS: 
 *		this - direct play object
 *		pPacked - packed player or group
 *		pMsg - original message received (used so we can get sp's message data
 *			out for CreatePlayer call)
 *		bPlayer - is packed a player or a group?
 *		ppBuffer - set to end of packed player in buffer
 *
 *  DESCRIPTION: UnSuperpacks player. creates new player, sets it up.
 *
 *  RETURNS: SP's hr, or result	of GetPlayer or SendCreateMessage
 *
 */
HRESULT UnSuperpackPlayer(LPDPLAYI_DPLAY this,LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked,
	LPVOID pvSPHeader,BOOL bPlayer,LPBYTE * ppBuffer)
{
    LPWSTR lpszShortName, lpszLongName;
	DPNAME PlayerName;
	LPVOID pvPlayerData;
	LPVOID pvSPData;
    LPDPLAYI_PLAYER pNewPlayer;
	LPDPLAYI_GROUP pNewGroup;
    LPBYTE pBufferIndex;
	HRESULT hr;
	DWORD dwMaskValue;
	DWORD dwPlayerDataSize=0,dwSPDataSize=0;
	DWORD dwVersion,dwIDSysPlayer;
	BOOL fSizeOnly = FALSE;
	DPID idParent = 0;
	
	pBufferIndex = (LPBYTE)pSuperPacked + pSuperPacked->dwFixedSize;	
	
	if (pSuperPacked->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
	{
		// system player - get version
		dwVersion = GetSize(&pBufferIndex,SIZE_DWORD);
		dwIDSysPlayer = pSuperPacked->dwID;
	}
	else 
	{
		// non system player - get system player
		dwIDSysPlayer = GetSize(&pBufferIndex,SIZE_DWORD);
		dwVersion = 0; // todo - do we need version on non-sysplayer?
	}
	
	if (this->pSysPlayer && (this->pSysPlayer->dwID == dwIDSysPlayer))
	{
		// skip this player - it's our own system player
		fSizeOnly = TRUE; 
	}

	// short name
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SHORTSTR,1);
	if (dwMaskValue)
	{
		lpszShortName = (WCHAR *)(pBufferIndex);
		pBufferIndex += WSTRLEN_BYTES(lpszShortName);
	}
	else lpszShortName = NULL;

	// long name
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,LONGSTR,1);
	if (dwMaskValue)
	{
		lpszLongName = (WCHAR *)(pBufferIndex);
		pBufferIndex += WSTRLEN_BYTES(lpszLongName);
	}
	else lpszLongName = NULL;

	memset(&PlayerName,0,sizeof(DPNAME));
	PlayerName.dwSize = sizeof(DPNAME);
	PlayerName.lpszShortName = lpszShortName;
	PlayerName.lpszLongName = lpszLongName;

	// player data
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,PLAYERDATA,2);
	if (dwMaskValue)
	{
		dwPlayerDataSize = GetSize(&pBufferIndex,dwMaskValue);
		pvPlayerData = pBufferIndex;
		pBufferIndex += dwPlayerDataSize;
	}
	else pvPlayerData = NULL;

	// sp data
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SPDATA,2);
	if (dwMaskValue)
	{
		dwSPDataSize = GetSize(&pBufferIndex,dwMaskValue);
		pvSPData = pBufferIndex;
		pBufferIndex += dwSPDataSize;
	}
	else pvSPData = NULL;

	// player is not local
	pSuperPacked->dwFlags &= ~DPLAYI_PLAYER_PLAYERLOCAL;

	// id Parent?
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,IDPARENT,1);
	if (dwMaskValue)
	{
		ASSERT(!bPlayer);
		idParent = *(((DWORD *)pBufferIndex)++);
	}

	// if it's a player, this is the end of the packed buffer
	*ppBuffer = pBufferIndex;	
	
	if (fSizeOnly)
	{
		ASSERT(bPlayer); // only should happen w/ our own sysplayer
		return DP_OK;
	}

	// go create the player
	if (bPlayer)
	{
		hr = GetPlayer(this,&pNewPlayer,&PlayerName,NULL,pvPlayerData,
			dwPlayerDataSize,pSuperPacked->dwFlags,NULL,0);
	}
	else 
	{
		hr = GetGroup(this,&pNewGroup,&PlayerName,pvPlayerData,
			dwPlayerDataSize,pSuperPacked->dwFlags,idParent,0);
		// cast to player - we only going to use common fields
		pNewPlayer = (LPDPLAYI_PLAYER)pNewGroup;		
	}
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		return hr;
		// rut ro!
	}

	pNewPlayer->dwIDSysPlayer = dwIDSysPlayer;
	pNewPlayer->dwVersion = dwVersion;	
	
	if (DPSP_MSG_DX3VERSION == pNewPlayer->dwVersion)
	{
		DPF(0,"detected DX3 client in game");
		this->dwFlags |= DPLAYI_DPLAY_DX3INGAME;
	}

	if (pNewPlayer->dwVersion && (pNewPlayer->dwVersion < this->dwMinVersion))
	{
		this->dwMinVersion = pNewPlayer->dwVersion;
		DPF(2,"found new min player version of %d\n",this->dwMinVersion);
	}

	if (dwSPDataSize)
	{
		// copy the sp data - 1st, alloc space
		pNewPlayer->pvSPData = DPMEM_ALLOC(dwSPDataSize);
		if (!pNewPlayer->pvSPData) 
		{
			// rut ro!
			DPF_ERR("out of memory, could not copy spdata to new player!");
			return E_OUTOFMEMORY;
		}
		pNewPlayer->dwSPDataSize = dwSPDataSize;
	
		// copy the spdata from the packed to the player
		memcpy(pNewPlayer->pvSPData,pvSPData,dwSPDataSize);
	}

	// now, set the id and add to nametable
	pNewPlayer->dwID = pSuperPacked->dwID;

    // if we are a secure server and we receive a remote system player, 
    // move the phContext from the nametable into the player structure before the slot
    // is taken by the player
	//
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this) &&
        !(pNewPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) &&
        (pNewPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        pNewPlayer->pClientInfo = (LPCLIENTINFO) DataFromID(this,pNewPlayer->dwID);
		DPF(6,"pClientInfo=0x%08x for player %d",pNewPlayer->pClientInfo,pNewPlayer->dwID);
    }
    

	// don't add to the nametable if it's the app server - this id is fixed
	if (!(pNewPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER))	
	{
		hr = AddItemToNameTable(this,(DWORD_PTR)pNewPlayer,&(pNewPlayer->dwID),TRUE,0);
	    if (FAILED(hr)) 
	    {
			ASSERT(FALSE);
			// if this fails, we're hosed!  there's no id on the player, but its in the list...
			// todo - what now???
	    }
	}

	// call sp 	
	if (bPlayer)
	{
		// tell sp about player
		hr = CallSPCreatePlayer(this,pNewPlayer,FALSE,pvSPHeader,TRUE);
		
	    // add to system group
	    if (this->pSysGroup)
	    {
	    	hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,this->pSysGroup->dwID,
	    			pNewPlayer->dwID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
			}
	    }
	}
	else 
	{
		// tell sp about group
		hr = CallSPCreateGroup(this,(LPDPLAYI_GROUP)pNewPlayer,TRUE,pvSPHeader);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		// todo -handle create player / group fails on UnSuperpack
	}

	// if it's a group, UnSuperpack group info
	if (!bPlayer)
	{
		UINT nPlayers; // # players in group
		LPDWORD pdwIDList = (LPDWORD)pBufferIndex;
		DWORD dwPlayerID;

		if (idParent)
		{
			// add it to parent
			hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces,idParent,
				pNewPlayer->dwID,0,FALSE);
			if (FAILED(hr))
			{
				DPF_ERRVAL("Could not add group to group - hr = 0x%08lx\n",hr);
				// keep trying...
			}
		}
		
		dwMaskValue = GetMaskValue(pSuperPacked->dwMask,NPLAYERS,2);
		if (dwMaskValue)
		{
			nPlayers = GetSize(&pBufferIndex,dwMaskValue);
			pdwIDList = (LPDWORD)pBufferIndex;
		}
		else nPlayers = 0;

		// now, add the players to the group
		while (nPlayers>0)
		{
			nPlayers--;
			dwPlayerID = *pdwIDList++;
			hr = InternalAddPlayerToGroup((LPDIRECTPLAY)this->pInterfaces,pSuperPacked->dwID,
				dwPlayerID,FALSE);
			if (FAILED(hr)) 
			{
				ASSERT(FALSE);
				// keep trying...
			}
		}	
		
		*ppBuffer = (LPBYTE)pdwIDList;	
	// all done!
	} // !bPlayer

	return hr;

}// UnSuperpackPlayer

HRESULT UnSuperpackShortcuts(LPDPLAYI_DPLAY this,LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked,
	LPBYTE * ppBuffer)
{
    LPBYTE pBufferIndex;
	HRESULT hr;
	DWORD dwMaskValue;
	LPDWORD pdwBufferIndex;
	DWORD nShortcuts = 0;
	DWORD i;
	DPID idShortcut;
	
	pBufferIndex = (LPBYTE)pSuperPacked + pSuperPacked->dwFixedSize;	
	
	dwMaskValue = GetMaskValue(pSuperPacked->dwMask,SHORTCUTS,2);
	if (dwMaskValue)
	{
		nShortcuts = GetSize(&pBufferIndex,dwMaskValue);
	}
	ASSERT(nShortcuts > 0);
	
	pdwBufferIndex = (LPDWORD)pBufferIndex;
	for (i=0;i<nShortcuts ;i++ )
	{
		idShortcut = *pdwBufferIndex++;
		hr = InternalAddGroupToGroup((LPDIRECTPLAY)this->pInterfaces, 
			pSuperPacked->dwID, idShortcut,DPGROUP_SHORTCUT,FALSE);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	// remember where we are
	*ppBuffer = (LPBYTE)pdwBufferIndex;
	
	return DP_OK;
	
} // UnSuperpackShortcuts

/*
 ** UnSuperpackPlayerAndGroupList
 *
 *  CALLED BY: handler.c (on createplayer/group message) and iplay.c (CreateNameTable)
 *
 *  PARAMETERS:
 *		this - direct play object
 *		pBuffer - pointer to the buffer with the packed player list
 *		nPlayer - # of players in the list
 *		nGroups - # of groups in the list
 *		pvSPHeader - sp's header, as received off the wire
 *
 *  DESCRIPTION:
 *
 *  RETURNS:
 *
 */
HRESULT UnSuperpackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,UINT nPlayers,
	UINT nGroups,UINT nShortcuts,LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
	LPBYTE pBufferIndex;
	LPDPLAYI_SUPERPACKEDPLAYER pPacked;

	pBufferIndex = pBuffer;

   	while (nPlayers>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		// don't UnSuperpack our own sysplayer - since we added it to the nametable
		// for pending stuff...
		hr = UnSuperpackPlayer(this,pPacked,pvSPHeader,TRUE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}

		nPlayers --;
   	} 

   	while (nGroups>0)
   	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackPlayer(this,pPacked,pvSPHeader,FALSE,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nGroups --;
   	} 
	
	while (nShortcuts > 0)
	{
		pPacked = (LPDPLAYI_SUPERPACKEDPLAYER)pBufferIndex;
		
		hr = UnSuperpackShortcuts(this,pPacked,&pBufferIndex);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			// keep trying
		}
		nShortcuts--;
	}	
	return hr;

} // UnSuperpackPlayerAndGroupList

// how mayn bytes to represent dwSize
DWORD ByteSize(DWORD dwSize)
{
	if ( !(dwSize & BYTE_MASK) )
	{
		// fits in a byte
		return sizeof(BYTE);
	}
	 
	if ( !(dwSize & WORD_MASK) )
	{
		// fits in a WORD
		return sizeof(WORD);
	}

	return sizeof(DWORD);
	
} // ByteSize

DWORD SuperPackedPlayerSize(LPDPLAYI_PLAYER pPlayer) 
{
	DWORD dwSize = 0;
	
	// space 4 strings + struct + version/sysplayer id
	dwSize = (WSTRLEN(pPlayer->lpszShortName) + WSTRLEN(pPlayer->lpszLongName)) 
		* sizeof(WCHAR)	+ sizeof(DPLAYI_SUPERPACKEDPLAYER) + sizeof(DWORD);
		
	// player + sp data need data + 1 
	if (pPlayer->dwPlayerDataSize)
	{
		dwSize += pPlayer->dwPlayerDataSize	+ ByteSize(pPlayer->dwPlayerDataSize);
	}		 

	if (pPlayer->dwSPDataSize)
	{
		dwSize += pPlayer->dwSPDataSize + ByteSize(pPlayer->dwSPDataSize);
	}

	return dwSize;

} // SuperPackedPlayerSize

DWORD SuperPackedGroupSize(LPDPLAYI_GROUP  pGroup)
{
	DWORD dwSize = 0;
	LPDPLAYI_SUBGROUP pSubgroup;
	UINT nShortcuts;

	// space for player stuff, plus space for group list 
	dwSize = SuperPackedPlayerSize((LPDPLAYI_PLAYER)pGroup);
	
	if (pGroup->nPlayers)
	{
		dwSize += pGroup->nPlayers*sizeof(DPID) + ByteSize(pGroup->nPlayers);
	}
	
	if (pGroup->dwIDParent)
	{
		dwSize += sizeof(DPID);
	}
	
	// see if we'll have shortcuts w/ this group
	nShortcuts = 0;
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			nShortcuts++;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	if (nShortcuts)		
	{
		// if there were shortcuts, then this group will have a packed struct, the number of shortcuts
		// and a list of shortcuts at the end
		dwSize += sizeof(DPLAYI_SUPERPACKEDPLAYER)  + ByteSize(nShortcuts) + nShortcuts*sizeof(DPID);
	}
	
	return dwSize;	
} // SuperPackedGroupSize

// returns how big the SuperPacked player structure is for the nPlayers
DWORD SuperPackedBufferSize(LPDPLAYI_PLAYER pPlayer,int nPlayers,BOOL bPlayer) 
{
	DWORD dwSize=0;
	LPDPLAYI_GROUP pGroup = (LPDPLAYI_GROUP)pPlayer;
		
	while (nPlayers > 0)
	{
		if (bPlayer)
		{

			ASSERT(pPlayer);
			dwSize += SuperPackedPlayerSize(pPlayer);
			pPlayer=pPlayer->pNextPlayer;
		}
		else 
		{
			ASSERT(pGroup);
			// don't count the system group - we don't send that one
			if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
			{
				dwSize += SuperPackedGroupSize(pGroup);
			}
			
			pGroup = pGroup->pNextGroup;			
		}
		nPlayers--;		
	}	
	return dwSize;
} // SuperPackedBufferSize

// set some bits (dwVal) at some offset (dwOffset) in a mask (pdwMask)
// called by SuperPackPlayer  
void SetMask(LPDWORD pdwMask,DWORD dwOffset,DWORD dwVal)
{
	*pdwMask |= dwVal<<dwOffset;
} // SetMask


// writes the dwSize field into the buffer as a byte, word or dword.
// returns 1,2 or 3 for byte, word or dword
DWORD WriteSize(LPBYTE * ppBuffer,DWORD dwSize)
{
	if ( !(dwSize & BYTE_MASK) )
	{
		// fits in a byte
		*((BYTE *)*ppBuffer) = (BYTE)dwSize;
		*ppBuffer += sizeof(BYTE);
		return SIZE_BYTE;
	}

	if ( !(dwSize & WORD_MASK) )
	{
		// fits in a WORD
		*((WORD *)*ppBuffer) = (WORD)dwSize;
		*ppBuffer += sizeof(WORD);
		return SIZE_WORD;
	}

	// needs the whole mccoy
	*((DWORD *)*ppBuffer) = dwSize;
	*ppBuffer += sizeof(DWORD);

	return SIZE_DWORD;
	
} // WriteSize

// constructs a SuperPackedplayer object from pPlayer. stores result in pBuffer
// returns size of SuperPacked player
DWORD SuperPackPlayer(LPDPLAYI_PLAYER pPlayer,LPBYTE pBuffer,BOOL bPlayer) 
{
	LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked;
	int iStrLen;
	LPBYTE pBufferIndex = pBuffer + sizeof(DPLAYI_SUPERPACKEDPLAYER);
	DWORD dwMaskValue;
		
	if (!pBuffer)
	{
		return SuperPackedBufferSize(pPlayer,1,bPlayer);
	} // pBuffer

	pSuperPacked = (LPDPLAYI_SUPERPACKEDPLAYER)	pBuffer;
	
	pSuperPacked->dwFixedSize = sizeof(DPLAYI_SUPERPACKEDPLAYER);
	pSuperPacked->dwID = pPlayer->dwID;
	pSuperPacked->dwFlags = pPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS);

	// if it's a sysplayer, set the version
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
	{
		*((DWORD *)pBufferIndex) = pPlayer->dwVersion;
	}
	else 
	{						   
		// otherwise, store the sysplayer id
		*((DWORD *)pBufferIndex) = pPlayer->dwIDSysPlayer;
	}
	pBufferIndex += sizeof(DWORD);
	
	// short name	
	if (pPlayer->lpszShortName)	
	{
		iStrLen	= WSTRLEN_BYTES(pPlayer->lpszShortName);
		memcpy(pBufferIndex,pPlayer->lpszShortName,iStrLen);
		pBufferIndex += iStrLen;
		// set the mask bit
		SetMask(&(pSuperPacked->dwMask),SHORTSTR,1);
	}
	// next, long name
	if (pPlayer->lpszLongName)
	{
		iStrLen	= WSTRLEN_BYTES(pPlayer->lpszLongName);
		memcpy(pBufferIndex,pPlayer->lpszLongName,iStrLen);
		pBufferIndex += iStrLen;
		SetMask(&(pSuperPacked->dwMask),LONGSTR,1);
	}

	// next, player data
	if (pPlayer->pvPlayerData)
	{
		// 1st, store the size		
		dwMaskValue = WriteSize(&pBufferIndex,pPlayer->dwPlayerDataSize);
		// set the mask bits
		SetMask(&(pSuperPacked->dwMask),PLAYERDATA,dwMaskValue);
		// next, the data
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		pBufferIndex += pPlayer->dwPlayerDataSize;
	}

	// finally, pack sp data
	if (pPlayer->pvSPData)
	{
		// 1st, store the size		
		dwMaskValue = WriteSize(&pBufferIndex,pPlayer->dwSPDataSize);
		// set the mask bits
		SetMask(&(pSuperPacked->dwMask),SPDATA,dwMaskValue);
		// next, the data
		memcpy(pBufferIndex,pPlayer->pvSPData,pPlayer->dwSPDataSize);
		pBufferIndex += pPlayer->dwSPDataSize;

	}

	if (!bPlayer)
	{
		// we shouldn't be asked to pack the sysgroup
		ASSERT(! (pPlayer->dwFlags & DPLAYI_GROUP_SYSGROUP));

		// parent id ?
		if (((LPDPLAYI_GROUP)pPlayer)->dwIDParent)
		{
			SetMask(&(pSuperPacked->dwMask),IDPARENT,1);
			*(((DWORD *)pBufferIndex)++) = ((LPDPLAYI_GROUP)pPlayer)->dwIDParent;
		}
		
		// next, any players in group
		if ( ((LPDPLAYI_GROUP)pPlayer)->nPlayers )
		{
			LPDPLAYI_GROUPNODE pGroupnode = ((LPDPLAYI_GROUP)pPlayer)->pGroupnodes;

			// 1st, store the size		
			dwMaskValue = WriteSize(&pBufferIndex,((LPDPLAYI_GROUP)pPlayer)->nPlayers);
			// set the mask bits
			SetMask(&(pSuperPacked->dwMask),NPLAYERS,dwMaskValue);
			// next, write the list of player id's
			while (pGroupnode)
			{
				ASSERT(pGroupnode->pPlayer);
				*(((DWORD *)pBufferIndex)++) = pGroupnode->pPlayer->dwID;
				pGroupnode = pGroupnode->pNextGroupnode;
			}
		} // players
		
		
	} // !bPlayer
	return (DWORD)(pBufferIndex - pBuffer);

} // SuperPackPlayer

// throw the shortcuts onto the end of the biffer
DWORD SuperPackShortcuts(LPDPLAYI_GROUP pGroup,LPBYTE pBuffer)
{
	LPDPLAYI_SUBGROUP pSubgroup;
	LPDPLAYI_SUPERPACKEDPLAYER pSuperPacked;
	LPBYTE pBufferIndex;
	LPDWORD pdwBufferIndex;
	DWORD dwMaskValue;
	UINT nShortcuts = 0;  

	// 1st - see if there are any	
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			nShortcuts++;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	if (!nShortcuts) return 0;
	
	pSuperPacked = (LPDPLAYI_SUPERPACKEDPLAYER)	pBuffer;
	pBufferIndex = pBuffer + sizeof(DPLAYI_SUPERPACKEDPLAYER);
	
	pSuperPacked->dwFixedSize = sizeof(DPLAYI_SUPERPACKEDPLAYER);
	pSuperPacked->dwID = pGroup->dwID;
	pSuperPacked->dwFlags = pGroup->dwFlags;

	// stick the number of subgroups in the struct
	dwMaskValue = WriteSize(&pBufferIndex,nShortcuts);
	ASSERT(dwMaskValue>=1);
	SetMask(&(pSuperPacked->dwMask),SHORTCUTS,dwMaskValue);

	// now, add subgroup id's	
	pSubgroup = pGroup->pSubgroups;
	pdwBufferIndex= (LPDWORD)pBufferIndex;
	
	pSubgroup = pGroup->pSubgroups;
	while (pSubgroup)
	{
		if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
		{
			*pdwBufferIndex++ = pSubgroup->pGroup->dwID;
		}
		
		pSubgroup = pSubgroup->pNextSubgroup;
	}

	
	pBufferIndex = (LPBYTE)pdwBufferIndex;
	return (DWORD)(pBufferIndex - pBuffer);

} // SuperPackShortcuts

					
HRESULT SuperPackPlayerAndGroupList(LPDPLAYI_DPLAY this,LPBYTE pBuffer,
	DWORD *pdwBufferSize) 
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP 	pGroup;
	
	if (CLIENT_SERVER(this))
	{
		// we should never get called for client server - that should use regular pack.c
		ASSERT(FALSE); 
		return E_FAIL; // E_DON'T_DO_THAT!
	}

	if (!pBuffer) 
	{
		*pdwBufferSize = SuperPackedBufferSize((LPDPLAYI_PLAYER)this->pGroups,
				this->nGroups,FALSE);
		*pdwBufferSize += SuperPackedBufferSize(this->pPlayers,this->nPlayers,TRUE);
		return DP_OK;
	}
	// else, assume buffer is big enough...
	
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		pBuffer += SuperPackPlayer(pPlayer,pBuffer,TRUE);
		pPlayer = pPlayer->pNextPlayer;
	}
	// next, SuperPack groups
	pGroup = this->pGroups;
	while (pGroup)
	{
		// don't send the system group 
		if (!(pGroup->dwFlags & DPLAYI_GROUP_SYSGROUP))
		{
			pBuffer += SuperPackPlayer((LPDPLAYI_PLAYER)pGroup,pBuffer,FALSE);
		}
		pGroup = pGroup->pNextGroup;
	}
	
	// finally, superpac shortcuts
	pGroup = this->pGroups;
	while (pGroup)
	{
		pBuffer += SuperPackShortcuts(pGroup,pBuffer);
		pGroup = pGroup->pNextGroup;
	}

	return DP_OK;
	
}// SuperPackPlayerAndGroupList	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\sysmess.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       sysmess.c
 *  Content:	sends system messages e.g. create/delete player
 *				also sends player to player messages
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/13/96		andyco	created it
 *	2/15/96		andyco	added player - player messages
 *	3/7/96		andyco	added reliable / unreliable player messages
 *	4/23/96		andyco	added delete player when send returns E_FAIL
 *	6/4/96		andyco	deletes player on dperr_playerlost, not e_fail
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *  6/21/96		kipo	Bug #2081. Need to subtract off header size from
 *						message size in SendDPMessage() before calling
 *						DPlay_HandleSPMessage() for local players.
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	7/10/96		andyco	changes for pending - checks on sendsystemmessage 
 *						modified for 2nd local sysplayer. 
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *						check for session lost on send to remote players
 *	8/8/96		andyco	added support for dpsession_nomessageid
 * 10/11/96     sohailm added SendSessionDescChanged()
 * 10/12/96		andyco	added optimized groups
 * 11/12/96		andyco	added system group / server player. unified sendtogroup
 *						and broadcast.
 * 11/21/96		andyco	update perf data if this->pPerfData exists...
 * 1/1/97		andyco	happy new year! all sends go to system players - this way
 *						sp's have fewer players to keep track of.
 *	1/28/97		andyco	SendName/DataChanged takes fPropagate flag so we can 
 *						correctly propagate these
 *	2/1/97		andyco	drop the dplay locks and go into pending modes on sends
 *						for guaranteed player / group messags (app messages only). Bug 5290.
 *  3/14/97     sohailm added functions NeedSigning(), InternalSendDPMessage(), 
 *                      BroadCastSystemMessage() and IsBroadCastSystemMessage().
 *                      modified SendDPMessage() to use InternalSendDPMessage() and 
 *                       SignAndSendDPMessage().
 *                      updated SendSystemMessage to route system messages through nameserver when 
 *                      session is secure.                      
 *  3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 *  3/24/97     sohailm Added support for passing session password in addforward
 *  4/11/97		andyco	changed SendSystemMessage, and added ask4multicast
 *	4/20/97		andyco	group in group
 *  4/23/97     sohailm The new SendSystemMessage() was not forwarding system messages to local
 *                      players.
 *                      Added support for encrypting ADDFORWARD and SESSIONDESCCHANGED messages.
 *	5/8/97		andyco	changed SendSystemMessage() to deal w/ CLIENT_SERVER. 
 *						removed update list.
 *  5/08/97     sohailm Temporarily disabled encryption of addforward and setsessiondesc messages.
 *  5/12/97     sohailm Enabled encryption of addforward and setsessiondesc messages.
 *                      Updated NeedSecurity() to allow security in the key exchange state.
 *	5/17/97		myronth	Send the SendChatMessage system message
 *	5/17/97		kipo	There was a bug in SendGroupMessage () where it was
 *						always taking the dplay lock after sending a message if
 *						the pending flag was set. This is bad if the pending flag
 *						was already set when we came into SendGroupMessage(),
 *						(i.e. during DP_Close), causing use to not drop the lock.
 *  5/18/97     sohailm Player-Player messages were not secure, when sent from the server.
 *  5/21/97     sohailm NeedSecurity() now fails if dplay is not providing security support.
 *                      Replaced DP_SP_HandleMessage call in InternalSendDPMessage an 
 *                      InternalHandleMessage() call.
 *	6/2/97		andyco	check for no nameserver in client server case in sendsystemmessage
 *  6/23/97     sohailm Now we use SSPI for message signing until client logs in. After which
 *                      signing is done using CAPI.
 *	6/24/97		kipo	distribute group messages from the server to the client
 *						one message at a time (like DX3) in case the client
 *						does not know about the group.
 *	7/30/97		andyco	return hr on sendplayermessage from actual send
 *  8/01/97		sohailm	removed message broadcasting code written for security.
 *						implemented peer-peer security using dplay multicasting code.
 *  8/4/97		andyco	added SendAsyncAddForward
 *	11/19/97	myronth	Fixed uninitialized To player in SendGroupMessage (#10319)
 *	11/24/97	myronth	Fixed SetSessionDesc messages for client/server (#15226)
 *	1/9/97		myronth	Fixed SendChatMessage to groups (#15294, #16353)
 *	1/14/98		sohailm	don't allow sp to optimize groups in CLIENT_SERVER and SECURE_SERVER(#15210)
 *	1/28/98		sohailm keep groups local to the client in CLIENT_SERVER (#16340)
 *  2/3/98      aarono  Fixed Paketize test for RAW mode 
 *  2/18/98     aarono  changed to direct protocol calls
 *  4/1/98      aarono  flag players that don't have nametable, don't send to them
 *  6/2/98      aarono  skip group sends with 0 members
 *                      fix locking for player deletion
 *  6/10/98     aarono  removed dead security code
 *  6/18/98     aarono  fix group SendEx ASYNC to use unique Header
 *  08/05/99    aarono  moved voice over to DPMSG_VOICE
 *  10/14/99    aarono  integrated fixes from NT tree for group sends.
 *  01/18/00    aarono  Millennium B#128337 - use replaceheader for all 
 *                      group ASYNC SendEx.  Winsock doesn't copy data.
 *  06/26/00    aarono  Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 *  06/27/00    aarono  105298 order of precedence error in SendCreateMessage, added ()'s
 ***************************************************************************/


#include "dplaypr.h"
#include "dpcpl.h"
#include "dpsecure.h"
#include "dpprot.h"

#undef DPF_MODNAME
#define DPF_MODNAME "NeedsSecurity"

// this function is called just before a message is handed off to the service provider
// here we decide if the outgoing message needs to be sent securely

BOOL NeedsSecurity(LPDPLAYI_DPLAY this, DWORD dwCommand, DWORD dwVersion, 
    LPDPLAYI_PLAYER pPlayerFrom, LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags)
{
    // message doesn't need security if any of the following conditions satisfy

    // dplay is not providing security
    if (!(this->dwFlags & DPLAYI_DPLAY_SECURITY))
    {
        return FALSE;
    }

    // no player yet
    if (!pPlayerFrom)
    {
        return FALSE;
    }

    // message is to a local player
    if (pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
    {
        return FALSE;
    }

    // if we are a client and are not in a signing state
    if (!IAM_NAMESERVER(this) && !VALID_SIGNING_STATE(this))
    {
        return FALSE;
    }

	// if message is one of the following
    switch (dwCommand) {
    case DPSP_MSG_PLAYERMESSAGE:
	// multicast messages could be player messages
	case DPSP_MSG_ASK4MULTICASTGUARANTEED:
		// security only if requested
        if (!(dwFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED)))
        {
            return FALSE;
        }
        break;

    case DPSP_MSG_PING:
    case DPSP_MSG_PINGREPLY:
        return FALSE;
        break;
    }

    // send message securely
    return TRUE;

} // NeedsSecurity

/*
 ** CheckPacketize
 *
 *  CALLED BY:	InternalSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - send flags
 *
 *  DESCRIPTION: checks if we should packetize the send for reliablilty.
 *
 *  RETURNS: sp return value
 *
 */

BOOL CheckPacketize(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,DWORD fSPHeader) 
{
	DWORD dwSPHeaderSize;
	DWORD dwSign;
	DWORD dwCommand;
	LPDPLAYI_PLAYER pSysPlayerTo;
	DWORD dwVersion;
	
	if((this->dwFlags & (DPLAYI_DPLAY_SPUNRELIABLE|DPLAYI_DPLAY_PROTOCOL)) && (dwMessageSize >= this->dwSPHeaderSize+sizeof(MSG_SYSMESSAGE))) // quick test
	{
		if(fSPHeader){
			dwSPHeaderSize=this->dwSPHeaderSize;
		} else {
			dwSPHeaderSize=0;
		}
		
		dwSign    = ((LPMSG_SYSMESSAGE)(pMessage+dwSPHeaderSize))->dwHeader;
		dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pMessage+dwSPHeaderSize));

		// find dplay version at target so we know if it even supports this type of packetize.
		if(pPlayerTo)
		{
			dwVersion=pPlayerTo->dwVersion;
			if(!dwVersion)
			{ 
				pSysPlayerTo=PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
				if(pSysPlayerTo)
				{
					dwVersion=pPlayerTo->dwVersion=pSysPlayerTo->dwVersion;
				} 
				else 
				{
					ASSERT(0);
					dwVersion=DPSP_MSG_VERSION;
				}
			}
		} 
		else 
		{
			// No pPlayerTo, using SP cached nameserver, grab target version from this.
			dwVersion=this->dwServerPlayerVersion;
		}
		
		if((dwSign==MSG_HDR) && NeedsReliablePacketize(this, dwCommand, dwVersion, dwFlags))
		{
			return TRUE;
		}
	}
	return FALSE;
}			
#undef DPF_MODNAME
#define DPF_MODNAME "InternalSendDPMessage"

/*
 ** InternalSendDPMessage
 *
 *  CALLED BY:	SendDPMessage or SignAndSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				fReliable - requires reliable send?
 *
 *  DESCRIPTION: calls sp to send message
 *
 *  RETURNS: sp return value
 *
 */

HRESULT InternalSendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock) 
{
    DPSP_SENDDATA sd;
	HRESULT hr,hr2;
	DWORD dwMax;
 	LPDPLAYI_PLAYER pSysPlayer;
	
	// first, make sure the player isn't on the dead list
	if (pPlayerTo)
	{
		pSysPlayer=PlayerFromID(this,pPlayerTo->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer)) 
		{
		    if (pSysPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST)
		    {
		    	DPF(7, "Not sending to %d because the CONNLOST flag is set", pPlayerTo->dwID);
		    	return DPERR_CONNECTIONLOST;
		    }
		}
	}
	
	DPF(7, "Sending message from player id %d to player id %d",
		(pPlayerFrom ? pPlayerFrom->dwID : 0),
		(pPlayerTo ? pPlayerTo->dwID : 0));

	if (dwFlags & DPSEND_GUARANTEED)
	{
		// do we need to packetize for reliability?
		if (!(pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))){ // don't do reliability on loopback.
			if(CheckPacketize(this,	pPlayerTo,pMessage,dwMessageSize,dwFlags,TRUE)){
				DPF(3,"InternalSendDPMessage :: message needs reliable delivery - packetizing with reliablility");
				hr = PacketizeAndSendReliable(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags,
					NULL,FALSE);
				return hr;
			}
		}	
		dwMax = this->dwSPMaxMessageGuaranteed;
	}
	else 
	{
		dwMax = this->dwSPMaxMessage;
	}


	// do we need to packetize
	if (dwMessageSize > dwMax)
	{
		DPF(3,"send :: message too big - packetizing");
		hr = PacketizeAndSend(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,
			dwFlags,NULL,FALSE);

		return hr;
	}

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS += dwMessageSize - this->dwSPHeaderSize;
		this->pPerfData->nSendPPS++;
	}
	
    // build the senddata
    sd.dwFlags = dwFlags;
	sd.bSystemMessage = TRUE;

	// to
	if (NULL == pPlayerTo)
	{
		sd.idPlayerTo = 0;		
	}
	else 
	{
		sd.idPlayerTo = pPlayerTo->dwID;					
		if (!(pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) 
		{
			if (! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
			{
				
				// tell sp to send it to this players system player
				// all sends get routed to system players
				// note that the actual player id is embedded in the message,
				// and will be used for delivery at the receiving end.
				//
				// we can't do this if dx3 players in game, since dx3 nameserver
				// migration doesn't update system player id's
				ASSERT(pPlayerTo->dwIDSysPlayer);
				sd.idPlayerTo = pPlayerTo->dwIDSysPlayer;
			}
		}
	}
	
	// from
	if (NULL == pPlayerFrom)
	{
		sd.idPlayerFrom = 0;		
	}
	else 
	{
		// if it's not from a system player, it's not a system message
		if (!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) sd.bSystemMessage = FALSE;	
		sd.idPlayerFrom = pPlayerFrom->dwID;					
	}

    sd.lpMessage = pMessage;
	sd.dwMessageSize = dwMessageSize;
	sd.lpISP = this->pISP;

	if (pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) 
	{
		DPF(7,"delivering message locally");

		// call our handler directly, bypassing sp
		hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,(LPBYTE)sd.lpMessage + 
			this->dwSPHeaderSize,dwMessageSize - this->dwSPHeaderSize,DPSP_HEADER_LOCALMSG,dwFlags);
	}
	else if((pPlayerTo) && (pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE)){
		// don't try to send to a player that doesn't have the nametable.
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",pPlayerTo,pPlayerTo->dwID);
		hr=DPERR_UNAVAILABLE;
	}
    // call sp
    else if (this->pcbSPCallbacks->Send) 
    {

		// make sure we haven't lost the session...
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			DPF_ERR(" ACK - Session Lost - attempt to send to remote player failed!");
			return DPERR_SESSIONLOST;
		}

		if(bDropLock){
			LEAVE_DPLAY();
		}
		DPF(7,"delivering message to service provider");

		if(this->pProtocol){
			hr = ProtocolSend(&sd); // calls sp too.
		} else {
	    	hr = CALLSP(this->pcbSPCallbacks->Send,&sd);    	
	    }

		if(bDropLock){
			ENTER_DPLAY();
		}
	    
		if (DPERR_SESSIONLOST == hr)
		{
			DPF_ERR(" got session lost back from SP ");
			hr = HandleSessionLost(this);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		else if (hr == DPERR_CONNECTIONLOST)
		{
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF(5, " got connection lost for player %d from SP\n", sd.idPlayerTo);
			
			pPlayerToKill=PlayerFromID(this,sd.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
		    		// set the flag on the player's sys player
		    		pPlayerToKill->dwFlags |= DPLAYI_PLAYER_CONNECTION_LOST;
			    	pPlayerToKill->dwTimeToDie = GetTickCount() /*+ 15000*/;
		    		this->dwZombieCount++;
		    		
					// a-josbor: we can't start the DPLAY thread here becase
					// it might deadlock with the DPLAY lock.  Any ideas?
					//  -seems to be working fine AO 04/03/2001
		    		StartDPlayThread(this, FALSE);
				}
		    }
		}
		else if (hr == DPERR_INVALIDPLAYER){
		
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF_ERR(" got invalid player from SP, killing player\n");

			hr = DPERR_CONNECTIONLOST;
			
			pPlayerToKill=PlayerFromID(this,sd.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
		    	// a-josbor:  actually, kill his sys player
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
					hr2 = KillPlayer(this, pPlayerToKill,IAM_NAMESERVER(this));	// a-josbor: if we're the host tell everyone they're nuked
				}
				else
				{
					DPF_ERR("ERROR: Trying to kill invalid player!");
				}
		    }
			else
			{
				DPF_ERR("ERROR: Trying to kill invalid player!");
			}
			
			if(FAILED(hr2))
			{
				ASSERT(FALSE);
			}
		}
    }
	else 
	{
		hr = DPERR_GENERIC;
		ASSERT(FALSE);
	}

	if (FAILED(hr) && hr != DPERR_PENDING) 
	{
		DPF(0,"DP Send - failed hr = 0x%08lx\n",hr);
	}

	return hr; 		
} // InternalSendDPMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendDPMessage"

#undef DPF_MODNAME
#define DPF_MODNAME "ConcatenateSendBuffer"
/*
 ** ConcatenateSendBuffer
 *
 *  CALLED BY:	
 *
 *  PARAMETERS: this - idplay
 *              psed  - sendex parameters
 *              psd   - send paramter struct to be filled in.
 *
 *
 *  DESCRIPTION: converts a scatter gather array into a contiguous
 *               buffer for use in older DPLAY entry points.
 *
 *  NOTE:        allocates
 *
 *  RETURNS: pointer to new buffer, or NULL if out of memory
 *
 */

PUCHAR ConcatenateSendBuffer(LPDPLAYI_DPLAY this, LPSGBUFFER lpSGBuffers, UINT cBuffers, DWORD dwTotalSize)
{
	DWORD   dwMessageSize;
	PUCHAR  pBuffer;
	UINT    i;
	UINT    offset;

	dwMessageSize=this->dwSPHeaderSize+dwTotalSize;

	pBuffer=MsgAlloc(dwMessageSize);
	if(!pBuffer){
		goto exit;
	}

	// copy the SG buffers into the single buffer.  Leave dwSPHeaderSize bytes empty at front.
	offset=this->dwSPHeaderSize;
	for(i=0;i<cBuffers;i++){
		memcpy(pBuffer+offset,lpSGBuffers[i].pData,lpSGBuffers[i].len);
		offset+=lpSGBuffers[i].len;
	}

exit:
	return pBuffer;
}


#undef DPF_MODNAME
#define DPF_MODNAME "ConvertSendExDataToSendData"

/*
 ** ConvertSendExDataToSendData
 *
 *  CALLED BY:	SendDPMessageEx
 *
 *  PARAMETERS: this - idplay
 *              psed  - sendex parameters
 *              psd   - send paramter struct to be filled in.
 *
 *
 *  DESCRIPTION: converts sendexdata to senddata for use
 *               on old sp's or when looping back a send.
 *               Transcribes the Scatter gather buffers and
 *               leave space for the SP header at the front.
 *
 *  RETURNS: sp return value
 *
 */

HRESULT ConvertSendExDataToSendData(LPDPLAYI_DPLAY this, LPDPSP_SENDEXDATA psed, LPDPSP_SENDDATA psd) 
{
	PUCHAR  pBuffer;
	DWORD   dwMessageSize;

	pBuffer=ConcatenateSendBuffer(this,psed->lpSendBuffers,psed->cBuffers,psed->dwMessageSize);
	
	if(!pBuffer){
		return DPERR_NOMEMORY;
	}

	dwMessageSize=this->dwSPHeaderSize+psed->dwMessageSize;

	// same flags except no new bits.
	psd->dwFlags = psed->dwFlags & ~(DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG);

	psd->idPlayerTo     = psed->idPlayerTo;
	psd->idPlayerFrom   = psed->idPlayerFrom;
	psd->lpMessage      = pBuffer;
	psd->dwMessageSize  = dwMessageSize;
	psd->bSystemMessage = psed->bSystemMessage;
	psd->lpISP          = psed->lpISP;
	
	return DP_OK;
}


#undef DPF_MODNAME
#define DPF_MODNAME "InternalSendDPMessageEx"

/*
 ** InternalSendDPMessageEx
 *
 *  CALLED BY:	SendDPMessage or SignAndSendDPMessage
 *
 *  PARAMETERS: this - idplay
 *              psp  - send parameters
 *
 *
 *  DESCRIPTION: calls sp to send message
 *
 *  RETURNS: sp return value
 *
 */

HRESULT InternalSendDPMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp, BOOL bDropLock) 
{
	DPSP_SENDDATA   sd;
    DPSP_SENDEXDATA sed;
	HRESULT hr,hr2;
	DWORD dwMax;
	DWORD dwSPMsgID; // storage for message id returned by SP
	PUCHAR pBuffer=NULL;
	DWORD bOldSend=FALSE;
 	LPDPLAYI_PLAYER pSysPlayer;

	ASSERT(psp);
	
	// first, make sure the player isn't on the dead list
	if (psp->pPlayerTo)
	{
		pSysPlayer=PlayerFromID(this,psp->pPlayerTo->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer)) 
		{
		    if (pSysPlayer->dwFlags & DPLAYI_PLAYER_CONNECTION_LOST)
		    {
		    	DPF(7, "Not sending to %d because the CONNLOST flag is set", psp->pPlayerTo->dwID);
		    	return DPERR_CONNECTIONLOST;
		    }
		}
	}
	
	DPF(7, "Sending message from player id %d to player id %d",
		(psp->pPlayerFrom ? psp->pPlayerFrom->dwID : 0),
		(psp->pPlayerTo ? psp->pPlayerTo->dwID : 0));

	if (psp->dwFlags & DPSEND_GUARANTEED)
	{
		// do we need to packetize for reliability?
		// don't do reliability on loopback
		if (!(psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))){ 

			if(CheckPacketize(this,	psp->pPlayerTo,psp->Buffers[0].pData,psp->dwTotalSize,psp->dwFlags,FALSE)){
				DPF(3,"InternalSendDPMessage :: message needs reliable delivery - packetizing with reliablility");
				
				pBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
				if(!pBuffer){
					return DPERR_NOMEMORY;
				}
				hr = PacketizeAndSendReliable(this,psp->pPlayerFrom,psp->pPlayerTo,pBuffer,psp->dwTotalSize+this->dwSPHeaderSize,psp->dwFlags,NULL,FALSE);
				goto EXIT;
			}
			
		}	
		dwMax = this->dwSPMaxMessageGuaranteed;
	}
	else 
	{
		dwMax = this->dwSPMaxMessage;
	}


	// do we need to packetize
	if (psp->dwTotalSize > dwMax)
	{
		DPF(3,"send :: message too big - packetizing");
		pBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
		if(!pBuffer){
			return DPERR_NOMEMORY;
		}
		hr = PacketizeAndSend(this,psp->pPlayerFrom,psp->pPlayerTo,pBuffer,psp->dwTotalSize+this->dwSPHeaderSize,psp->dwFlags,NULL,FALSE);
		goto EXIT;
	}

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nSendBPS += psp->dwTotalSize - this->dwSPHeaderSize;
		this->pPerfData->nSendPPS++;
	}

	//
    // build the SendExData
    //
    
	sed.lpISP = this->pISP;
    sed.dwFlags = psp->dwFlags;
	sed.bSystemMessage = TRUE;

	// TO ID
	if (NULL == psp->pPlayerTo)	{

		sed.idPlayerTo = 0;		

	} else 	{
	
		sed.idPlayerTo = psp->pPlayerTo->dwID;					
		
		// Route messages through system player on host unless DX3 in game
		// Messages delivered by host use the embedded FromID in the message
		// to notify the receiver who the message was from.

		if (!(psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		   (! (this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ))
		{
				ASSERT(psp->pPlayerTo->dwIDSysPlayer);
				sed.idPlayerTo = psp->pPlayerTo->dwIDSysPlayer;
		}
	}
	
	// FROM ID
	if (NULL == psp->pPlayerFrom){
		sed.idPlayerFrom = 0;		
	}else {
		// if it's not from a system player, it's not a system message
		if (!(psp->pPlayerFrom->dwFlags & DPLAYI_PLAYER_SYSPLAYER)) sed.bSystemMessage = FALSE;	
		sed.idPlayerFrom = psp->pPlayerFrom->dwID;					
	}

	// MESSAGE DATA
    sed.lpSendBuffers = &psp->Buffers[0];
    sed.cBuffers      = psp->cBuffers;
	sed.dwMessageSize = psp->dwTotalSize;

	// OTHER PARAMS
	sed.dwPriority    = psp->dwPriority;
	sed.dwTimeout     = psp->dwTimeout;
	sed.lpDPContext   = (LPVOID)psp->hContext;
	sed.lpdwSPMsgID   = &dwSPMsgID;
	    

	if (psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) {
	
		DPF(7,"delivering message locally");

		// Handle Message doesn't understand sed's, make contiguous.
		hr=ConvertSendExDataToSendData(this, &sed,&sd);
		
		if(!FAILED(hr)){
			pBuffer=sd.lpMessage;
			// call our handler directly, bypassing sp
			hr = InternalHandleMessage((IDirectPlaySP *)this->pInterfaces,(LPBYTE)sd.lpMessage + 
				this->dwSPHeaderSize,sd.dwMessageSize - this->dwSPHeaderSize,DPSP_HEADER_LOCALMSG,sd.dwFlags);
		} 

	}
	else if((psp->pPlayerTo) && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE) && (!(psp->dwFlags & DPSEND_ASYNC))){
		DPF(0,"Failing message to player w/o nametable pPlayer %x id %x\n",psp->pPlayerTo,psp->pPlayerTo->dwID);
		// don't try to send to a player that doesn't have the nametable.
		hr=DPERR_UNAVAILABLE;
    } else if (this->pcbSPCallbacks->Send) 	{ // call sp
        
		// make sure we haven't lost the session...
		if (this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)
		{
			DPF_ERR(" ACK - Session Lost - attempt to send to remote player failed!");
			hr = DPERR_SESSIONLOST;
			goto EXIT;
		}

		pspAddRef(psp);			// AddRef in anticipation of the send pending, must be added before
								// send, because it could complete in the send call causing the reference
								// count to go to zero.


		DPF(7,"delivering message to service provider");

		if(bDropLock){
			LEAVE_DPLAY();	//icky,icky,icky, get rid of API level lock! - not likely now AO 04/03/2001
		}	

		if(this->pProtocol){
		
			hr = ProtocolSendEx(&sed); // protocol will call SP.
			
		} else if(this->pcbSPCallbacks->SendEx){
		
		    hr = CALLSP(this->pcbSPCallbacks->SendEx,&sed);    	
		    
		} else {

			// No extended send, convert to old method.
			if(!pBuffer){
				hr=ConvertSendExDataToSendData(this, &sed,&sd);
			} else {
				hr=DP_OK;
			}
			if(!FAILED(hr)){
				pBuffer=sd.lpMessage;
				bOldSend=TRUE;
				if(this->pProtocol){
					hr = ProtocolSend(&sd);  // protocol will call SP.
				} else {
				    hr = CALLSP(this->pcbSPCallbacks->Send,&sd);    	
				}    
			}    
		}
		
		if(bDropLock){
			ENTER_DPLAY();
		}
		
		if(hr == DPERR_PENDING){
                        AddContext(this,psp,(LPVOID)(DWORD_PTR)dwSPMsgID);
		} else if(!(psp->dwFlags & DPSEND_ASYNC) || bOldSend || FAILED(hr)){
			// even in DP_OK case, completion still happens, so we 
			// only pull off the reference in an error case or the SYNC case.
			pspDecRef(this,psp);
		} 

		// error handling
		if (DPERR_SESSIONLOST == hr)
		{
			// Completely lost our connection to the game.
			
			DPF_ERR(" got session lost back from SP ");

			hr = HandleSessionLost(this);
			
			if (FAILED(hr))	{
				ASSERT(FALSE);
			}
		}
		else if (hr == DPERR_CONNECTIONLOST)
		{
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF(5, " got connection lost for player %d from SP\n", sed.idPlayerTo);
			
			pPlayerToKill=PlayerFromID(this,sed.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
		    		// set the flag on the player's sys player
		    		pPlayerToKill->dwFlags |= DPLAYI_PLAYER_CONNECTION_LOST;
			    	pPlayerToKill->dwTimeToDie = GetTickCount() /*+ 15000*/;
		    		this->dwZombieCount++;
					// a-josbor: we can't start the DPLAY thread here becase
					// it might deadlock with the DPLAY lock.  Any ideas?
					//  -seems to work OK, AO 04/03/2001
		    		StartDPlayThread(this, FALSE);
				}
		    }
		}
		else if (hr == DPERR_INVALIDPLAYER){
		
			LPDPLAYI_PLAYER pPlayerToKill;
			DPF_ERR(" got invalid player from SP, killing player\n");

			hr = DPERR_CONNECTIONLOST;
			
			pPlayerToKill=PlayerFromID(this,sed.idPlayerTo);
		    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
		    {
		    	// a-josbor:  actually, kill his sys player
				pPlayerToKill=PlayerFromID(this,pPlayerToKill->dwIDSysPlayer);
			    if (VALID_DPLAY_PLAYER(pPlayerToKill)) 
			    {
					hr2 = KillPlayer(this, pPlayerToKill,IAM_NAMESERVER(this));	// a-josbor: if we're the host tell everyone they're nuked
				}
				else
				{
					DPF_ERR("ERROR: Trying to kill invalid player!");
				}
		    }
			else
			{
				DPF_ERR("ERROR: Trying to kill invalid player!");
			}
			
			if(FAILED(hr2))
			{
				ASSERT(FALSE);
			}
		}
    } else {
		// No Send Handler???
		hr=DPERR_GENERIC; // make prefix happy.
		ASSERT(FALSE);
	}

EXIT:
	// CleanUp
	if(pBuffer){
		MsgFree(NULL, pBuffer);
	}

	if (FAILED(hr) && hr != DPERR_PENDING) {
		DPF(0,"DP SendEx - failed hr = 0x%08lx\n",hr);
	}

	return hr; 		
} // InternalSendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendDPMessage"

/*
 ** SendDPMessage
 *
 *  CALLED BY:	anyone wanting to invoke the sp's send
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - message attributes (gauranteed, encrypted, signed, etc.)
 *
 *  DESCRIPTION: calls either SecureSendDPMessage or InternalSendDPMessage depending on 
 *              whether the message needs security or not.
 *
 *  RETURNS:    return value from sp or from SecureSendDPMessage
 *
 */

HRESULT SendDPMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pMessage,DWORD dwMessageSize,DWORD dwFlags,BOOL bDropLock) 
{
	HRESULT hr;

	// If this is a lobby-owned object, we are never going to send a
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

    if (SECURE_SERVER(this))
    {
        DWORD dwCommand=0,dwVersion=0;

        // what message are we sending ?
        hr = GetMessageCommand(this, pMessage+this->dwSPHeaderSize, dwMessageSize, 
            &dwCommand, &dwVersion);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get the message type: hr=0x%08x",hr);
            return hr;
        }

        // do we need to send message securely ?
        if (NeedsSecurity(this, dwCommand, dwVersion, pPlayerFrom, pPlayerTo, dwFlags))
        {
            if ((DPSP_MSG_ADDFORWARDREQUEST == dwCommand) ||
                (DPSP_MSG_SESSIONDESCCHANGED == dwCommand))
            {
				// encrypted messages are signed as well
                dwFlags |= DPSEND_ENCRYPTED;
            }
            else
            {
                dwFlags |= DPSEND_SIGNED;
            }

            // secure messages are sent guaranteed regardless
            dwFlags |=  DPSEND_GUARANTEED;

			// SSPI is used for signing messages during client logon. After logon is completed
			// all messages are signed using CAPI.
			if (!IAM_NAMESERVER(this) && (DPLOGIN_SUCCESS != this->LoginState))
			{
				// send message securely (uses SSPI signing)
				hr = SecureSendDPMessage(this, pPlayerFrom, pPlayerTo, pMessage, 
					dwMessageSize, dwFlags, bDropLock);
			}
			else
			{
				// send message securely (uses CAPI signing)
				hr = SecureSendDPMessageCAPI(this, pPlayerFrom, pPlayerTo, pMessage, 
					dwMessageSize, dwFlags, bDropLock);

			}
			if (FAILED(hr))
			{
				DPF_ERRVAL("Failed to send message securely [0x%08x]", hr);
			}

            // all done
            return hr;
        }
    }

    // if we reach here, security was not requested so just
    // send the message in plain.
    hr = InternalSendDPMessage(this,pPlayerFrom,pPlayerTo,pMessage,dwMessageSize,dwFlags, bDropLock);

	return hr; 		
} // SendDPMessage


/*
 ** SendDPMessageEx
 *
 *  CALLED BY:	anyone wanting to invoke the sp's send
 *
 *  PARAMETERS: this - idplay
 *				pPlayerFrom - player sending message
 *				pPlayerTo - player to send to
 *				pMessage - buffer to send
 *				dwMessageLength - size of mess
 *				dwFlags - message attributes (gauranteed, encrypted, signed, etc.)
 *
 *  DESCRIPTION: calls either SecureSendDPMessage or InternalSendDPMessage depending on 
 *              whether the message needs security or not.
 *
 *  RETURNS:    return value from sp or from SecureSendDPMessage
 *
 */

HRESULT SendDPMessageEx(LPDPLAYI_DPLAY this,LPSENDPARMS psp, BOOL bDropLock) 
{
	HRESULT hr;

	// If this is a lobby-owned object, we are never going to send a
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

    if (SECURE_SERVER(this))
    {
        DWORD dwCommand=0,dwVersion=0;

        // what message are we sending ?
        hr = GetMessageCommand(this, psp->Buffers[0].pData, psp->dwTotalSize,&dwCommand,&dwVersion);
        if (FAILED(hr))
        {
            DPF_ERRVAL("Failed to get the message type: hr=0x%08x",hr);
            return hr;
        }

		ASSERT(!this->pProtocol);
	
		if (NeedsSecurity(this, dwCommand, dwVersion, psp->pPlayerFrom, psp->pPlayerTo, psp->dwFlags))
        {
            if ((DPSP_MSG_ADDFORWARDREQUEST == dwCommand) ||
                (DPSP_MSG_SESSIONDESCCHANGED == dwCommand))
            {
				// encrypted messages are signed as well
                psp->dwFlags |= DPSEND_ENCRYPTED;
            }
            else
            {
                psp->dwFlags |= DPSEND_SIGNED;
            }
            
            // secure messages are sent guaranteed regardless
            psp->dwFlags |=  DPSEND_GUARANTEED;

			// SSPI is used for signing messages during client logon. After logon is completed
			// all messages are signed using CAPI.
			if (!IAM_NAMESERVER(this) && (DPLOGIN_SUCCESS != this->LoginState))
			{
				// send message securely (uses SSPI signing)
				hr = SecureSendDPMessageEx(this, psp, bDropLock);
			}
			else
			{
				// send message securely (uses CAPI signing)
				hr = SecureSendDPMessageCAPIEx(this, psp, bDropLock);

			}
			if (FAILED(hr) && hr != DPERR_PENDING)
			{
				DPF_ERRVAL("Failed to send message securely [0x%08x]", hr);
			}

            // all done
            return hr;
        }
    }

    // if we reach here, security was not requested so just
    // send the message in plain.
    hr = InternalSendDPMessageEx(this,psp,bDropLock);

	return hr; 		
} // SendDPMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendSystemMessage"

/*
 ** SendSystemMessage
 *
 *  CALLED BY: SendCreateMessage,SendPlayerManagementMessage
 *
 *  PARAMETERS: this - idplay
 *				pSendBuffer,dwBufferSize - buffer to send
 *				fPropagate - do we need to send this message to remote system players (TRUE),
 *					or do we just want to pass it on to our local (non-system) players (FALSE).
 *				fSetTo - do we need to set the id of the player we're sending to ?
 *					Some messages (e.g. playermgmtmessages) need the dest player
 *					to be set in the message.  See DPlay_HandleSPMessage in handler.c.
 *
 *  DESCRIPTION: sends messag to all remote system players (if fLocal is TRUE), and 
 *			to all local players
 *
 *  RETURNS:  DP_OK or failure from sp
 *
 */
HRESULT SendSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	DWORD dwFlags, BOOL bIsPlyrMgmtMsg)
{
	HRESULT hr=DP_OK;
   	LPMSG_PLAYERMGMTMESSAGE pmsg = NULL;

	// If this is a lobby-owned object, we are never going to send a system
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

	if(bIsPlyrMgmtMsg)
		pmsg = (LPMSG_PLAYERMGMTMESSAGE)((LPBYTE)pSendBuffer + this->dwSPHeaderSize);

	if(this->dwFlags & DPLAYI_DPLAY_CLOSED){
		dwFlags &= ~DPSEND_ASYNC; // force sends on closing to be synchronous
	}

	if (CLIENT_SERVER(this))
	{
		// are we the nameserver?
		if (IAM_NAMESERVER(this))
		{
			ASSERT(this->pSysPlayer);
			// if so, only tell the world about events related to my system player or 
			// the appserver id
			if ((!bIsPlyrMgmtMsg)
				|| (pmsg->dwPlayerID == this->pSysPlayer->dwID) 
				|| (pmsg->dwPlayerID == DPID_SERVERPLAYER) )
			{
				// tell the world (this will also distribute it to our local players)
				if (this->pSysGroup) 
				{
					hr = SendGroupMessage(this,this->pSysPlayer,this->pSysGroup,dwFlags,
						pSendBuffer,dwMessageSize,FALSE);
				}
				// there won't be a sytemgroup if e.g. we're creating our system 
				// player - that's ok
			}
			// a-josbor: special case.  If we're deleting a player, we need to inform
			//	that player only
			else if (bIsPlyrMgmtMsg && GET_MESSAGE_COMMAND(pmsg) == DPSP_MSG_DELETEPLAYER)
			{
				LPDPLAYI_PLAYER pPlayer;

				pPlayer = PlayerFromID(this, pmsg->dwPlayerID);
				if (VALID_DPLAY_PLAYER(pPlayer))
				{
					hr = SendDPMessage(this, NULL, pPlayer, pSendBuffer,
						dwMessageSize, dwFlags,FALSE);
				}
			}
		} // IAM_NAMESERVER
		else 
		{
			// i am not the nameserver, tell the nameserver
			if (this->pNameServer)
			{
				if (bIsPlyrMgmtMsg)
				{
					// don't send any group related messages to the nameserver
					// a-josbor: handle these two special cases: commands where we have
					// a valid player in the player field, but it's really a group message.
					// note that we can't just check the groupId field of the player message
					// struct, because we'd be interpreting the structure incorrectly for
					// certain messages (i.e. PLAYERDATACHANGED)
					if ((VALID_DPLAY_PLAYER(PlayerFromID(this,pmsg->dwPlayerID)))	// in other words, not a group
						&& (GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_ADDPLAYERTOGROUP)
						&& (GET_MESSAGE_COMMAND(pmsg) != DPSP_MSG_DELETEPLAYERFROMGROUP))
					{
						pmsg->dwIDTo = this->pNameServer->dwID;
							
						// send message to nameserver
						hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
							dwMessageSize,dwFlags,FALSE);
					}
				}
				else
				{
					// send message to nameserver
					hr = SendDPMessage(this,this->pSysPlayer,this->pNameServer,pSendBuffer,
						dwMessageSize,dwFlags,FALSE);
				}
			}
			else 
			{
			 	// this can happen if e.g. nameserver quits before we do
			}
		} // ! IAM_NAMESERVER

		// finally, distribute the message to all our local players
	    hr =  DistributeSystemMessage(this,pSendBuffer+this->dwSPHeaderSize,
            dwMessageSize-this->dwSPHeaderSize);

	} // CLIENT_SERVER
	else 
	{
		if (this->pSysGroup) 
		{
			hr = SendGroupMessage(this,this->pSysPlayer,this->pSysGroup,dwFlags,
				pSendBuffer,dwMessageSize,FALSE);
		}
		else 
		{
			// this will happen e.g. when you are creating your system player
			DPF(5,"no system group - system message not sent");
		}
	} // ! CLIENT_SERVER
		
	return DP_OK;
	
} // SendSystemMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendCreateMessage"

/*
 ** SendCreateMessage
 *
 *  CALLED BY: DP_CreatePlayer, DP_CreateGroup
 *
 *  PARAMETERS:
 *					this - 	dplay object
 *					pPlayer - player or group we're creating
 *					fPlayer - if !0, creating player, else creating group
 *                  lpszSessionPassword - session password, if creating system player, 
 *                                        otherwise NULL
 *
 *  DESCRIPTION:
 *					sets up a createxxx message
 *					packs the player or groupdata into the message, and sends it out
 *
 *  RETURNS:  result from sendsystemmessage, senddpmessage, or E_OUTOFMEMORY.
 *
 */
HRESULT SendCreateMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
    LPWSTR lpszSessionPassword)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize, dwPasswordLen=0, dwNoTickCountMessageSize;
	BOOL fPropagate;
	PUINT pTickCount;
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// If this is a lobby-owned object, we are never going to send a create
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this))
		return DP_OK;

	// if the player we're creating is local, we need to propagate the announcement,
	// i.e. tell the world...
	fPropagate =  (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) ? TRUE:FALSE;
    
	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,fPlayer);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

    DPF(2,"sending new player announcment id = %d fPropagate = %d",msg.dwPlayerID,fPropagate);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    // add password size to message size
    if (lpszSessionPassword)
    {
        dwPasswordLen = WSTRLEN_BYTES(lpszSessionPassword);
        dwMessageSize += dwPasswordLen + sizeof(UINT)/* for TickCount */;
        dwNoTickCountMessageSize = dwMessageSize - sizeof(UINT);
    } else {
		// add extra space to use for TickCount if necessary.  Tickcount is sent in join
		// on the latest versions so we don't join a different session than we enumerated.
		dwNoTickCountMessageSize=dwMessageSize;
		dwMessageSize+=sizeof(UINT)+2; // 2 for NULL password
	}	

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CREATEPLAYER);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CREATEGROUP);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),fPlayer);

	// are we sending the create player announcement for our sysplayer?
	if (fPropagate && (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) && 
		this->pSysPlayer && !(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR) )
	{
		LPMSG_SYSMESSAGE pmsg = (LPMSG_SYSMESSAGE)(pSendBuffer + this->dwSPHeaderSize);

        // if nameserver is dx5 or greater, it will require a password in the addforward
        // message. Fill in the password regardless of the nameserver's version, 'cause dx3
        // won't even look at it.
        if (lpszSessionPassword && dwPasswordLen > 2)
        {
            memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 
                lpszSessionPassword, dwPasswordLen);
            ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
            pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + dwPasswordLen);
        } else {
        	// Set NULL password so we can put tick count past it.
            memset(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 0, 2);
            ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
            pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + 2);
        }

		if(this->lpsdDesc){
			// put tickcount at end of message to allow verification of session
			*pTickCount=(DWORD)this->lpsdDesc->dwReserved1;
		}	

        // if nameserver is dx5 or greater, it will respond with the nametable
        // GetNameTable() in iplay.c will block for the nametable download

	    // this flag indicates that any messages received before we get the whole
	    // nametable should be q'ed up.  Flag is reset in pending.c.
	    if (this->pSysPlayer)
	    {
		    // ok.  we've got a sysplayer, so we must be joining game for real.
		    // put us in pending mode, so we don't miss any nametable changes
		    // while we're waiting for the nametable to arrive
		    this->dwFlags |= DPLAYI_DPLAY_PENDING;
	    }

		if(!CLIENT_SERVER(this)){
			SetupForReply(this, DPSP_MSG_SUPERENUMPLAYERSREPLY);
		} else {
			SetupForReply(this, DPSP_MSG_ENUMPLAYERSREPLY);
		}	

		//
		// tell the namesrvr to forward this message...
		// this is to get us into the global nametable - even though we
		// haven't downloaded it yet.  this allows the nametable pending
		// stuff to work, and ensures our name table is kept in sync.
		//
		SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ADDFORWARDREQUEST);
		hr = SendDPMessage(this,pPlayer,NULL,pSendBuffer,dwMessageSize,DPSEND_GUARANTEE,FALSE);
		if(FAILED(hr)){
			UnSetupForReply(this);
		}
	}
	else 
	{
		DWORD dwExtraFlags;
    	// Set NULL password so we can put tick count past it.
//        memset(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize, 0, 2);
//        ((LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer + this->dwSPHeaderSize))->dwPasswordOffset = sizeof(msg)+dwDataSize;
//        pTickCount=(PUINT)(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + dwDataSize + 2);
//
//		if(this->lpsdDesc){
			// put tickcount at end of message to allow verification of session
//			*pTickCount=this->lpsdDesc->dwReserved1;
//		}	

		if(this->lpsdDesc && (this->lpsdDesc->dwFlags & (DPSESSION_CLIENTSERVER|DPSESSION_SECURESERVER))){
			dwExtraFlags=0;
		} else {
			dwExtraFlags=DPSEND_SYSMESS;
		}
		
		// it's just a regular system message
		hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,DPSEND_GUARANTEE|dwExtraFlags,TRUE);

		if(dwExtraFlags){
			// reduce chance of losing first reliable messages due to race
			// between async creation and sending of first message.
			Sleep(100);
		}
	}
	DPMEM_FREE(pSendBuffer);
    
    // done
    return hr;
} // SendCreateMessage 

#undef DPF_MODNAME
#define DPF_MODNAME "SendCreateVerifyMessage"

/*
 ** SendCreateVerifyMessage
 *
 *  CALLED BY:
 *
 *  PARAMETERS:
 *
 *  DESCRIPTION:
 *
 *  RETURNS:  
 *
 */
HRESULT SendCreateVerifyMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer, DWORD dwMessageType, DWORD dwReplyToVersion, LPVOID pvSPHeader)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize;
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,TRUE);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

    DPF(1,"sending player verify id = %d\n",msg.dwPlayerID);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,dwMessageType);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),TRUE);

	DoReply(this, pSendBuffer,dwMessageSize, pvSPHeader,dwReplyToVersion);
	
	DPMEM_FREE(pSendBuffer);
    
    // done
    return hr;
} // SendCreateVerifyMessage

#undef DPF_MODNAME
#define DPF_MODNAME "DoCreateVerify"
HRESULT DoCreateVerify(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer,DWORD dwMessageSize,	LPVOID pvSPHeader) 
{

	// We just got a player create message for a remote non-system player.  There is a bug in the nametable management
	// that may lead to the remote machine having missed our create player message if we created our local-players around
	// the time he was creating his system player.  To work around this problem, where he wasn't notified of our local player
	// creation, we send him an additional create player message in the form of a DPSP_MSG_CREATEPLAYERVERIFY.  We only
	// send this message if we get the creation within 40 seconds of creating our local player, since it is unlikely that the race
	// occured if the window is beyond this.

	// If we find the person sending us this message is before this fix DPSP_MSG_DX8VERSION2, then we send him a 
	// DPSP_MSG_CREATEPLAYER message.  Otherwise we send DPSP_MSG_CREATEPLAYERVERIFY.  The new message type
	// allows us to avoid getting into a situation where we ping-pong creation messages.  There is no issue with older
	// clients since they will not send an additional CREATE message.

	// If the remote client is pre-dx5, we don't bother, they have so many other problems this is nigling.

	// Have DPLAY lock on way in, but will need both locks to Send, so we drop the DPLAY lock and ENTER_ALL, we
	// drop the SERVICE lock on the way out, so we leave as we entered.

	// AO - 6/26/00 can't send extra create for DX5 because although it won't add the player twice it WILL post
	// the message to the user twice (doh!).
	
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	DWORD dwVersion;
	DWORD dwCommand;
	HRESULT hr=DP_OK;
	LPDPLAYI_PLAYER pPlayer;
	DWORD tNow;

	LEAVE_DPLAY();
	ENTER_ALL();
						
	TRY 
	{
	
		hr = VALID_DPLAY_PTR( this );
		
		if (FAILED(hr))	{
			LEAVE_SERVICE();
			return hr;
	    }
	    
	} 
	EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_SERVICE();
        return DPERR_INVALIDPARAMS;
	}

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;

	dwVersion=GET_MESSAGE_VERSION(pmsg);

    if(dwVersion >= DPSP_MSG_DX8VERSION2)
    {
		dwCommand=DPSP_MSG_CREATEPLAYERVERIFY;
    } else {
    	// don't bother with DX3. (or DX5)
    	hr=DP_OK;
    	goto exit;
    }

	// walk player list, inform sender of all our local players if we created any
	// of them in the last 40 seconds. (after 39 days there will also be another
	// 40 second window, but its benign anyway, so no special case req'd).
	tNow=timeGetTime();
	pPlayer=this->pPlayers;

	while(pPlayer){
		// only send for local non-system players.
		if((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
		  !(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
		  (tNow-pPlayer->dwCreateTime < 40000))
		{
			hr=SendCreateVerifyMessage(this,pPlayer,dwCommand,dwVersion,pvSPHeader);
		}
		pPlayer=pPlayer->pNextPlayer;
	}

exit:
	LEAVE_SERVICE();
	return hr;
}

#undef DPF_MODNAME
//
// repackage the pSendBuffer to have a player wrapper
// called in case someone tries to send a message that has our token
// as the first dword.
HRESULT WrapPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
	LPDPLAYI_PLAYER pPlayerTo,LPBYTE pSendBuffer,DWORD dwMessageSize,DWORD dwFlags, BOOL bDropLock)
{
	HRESULT hr;
	LPMSG_SYSMESSAGE psm;
	LPBYTE pWrapBuffer;
	DWORD dwWrapSize;
	
	// get rid of the header sendplayermessage put on it...
	dwMessageSize -= this->dwSPHeaderSize;
	pSendBuffer += this->dwSPHeaderSize;
	
	dwWrapSize = dwMessageSize +  GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
	
	// alloc a new message buffer, wrap it w/ our header and send it out
	pWrapBuffer = DPMEM_ALLOC(dwWrapSize);
	if (!pWrapBuffer)
	{
		DPF_ERR("could not send player-player message OUT OF MEMORY");
		return E_OUTOFMEMORY;
	}

	psm = (LPMSG_SYSMESSAGE)(pWrapBuffer + this->dwSPHeaderSize);
	
	SET_MESSAGE_HDR(psm);
	SET_MESSAGE_COMMAND(psm,DPSP_MSG_PLAYERWRAPPER);

	// set up the buffer,
	memcpy(pWrapBuffer + this->dwSPHeaderSize + sizeof(MSG_SYSMESSAGE),pSendBuffer,
		dwMessageSize);
		
	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pWrapBuffer,dwWrapSize,
		dwFlags, bDropLock);		
		
	DPMEM_FREE(pWrapBuffer);
	
	return hr;
} // WrapPlayerMessage


// alloc space for a player - player message.
// called by SendPlayerMessage and SendGroupMessage
HRESULT SetupPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp)
{
	LPMSG_PLAYERMESSAGE psm;
	BOOL bPutMessageIDs = TRUE;
	
	
	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		return DP_OK;
	}

	psm = GetPlayerMessageHeader();

    if (NULL == psm) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	// not naked - put to + from on 
	psm->idFrom = psp->pPlayerFrom->dwID;
	if(psp->pPlayerTo){
		psm->idTo = psp->pPlayerTo->dwID;
	} else {
		ASSERT(psp->pGroupTo);
		psm->idTo = psp->pGroupTo->dwID;
	}

	InsertSendBufferAtFront(psp,psm,sizeof(MSG_PLAYERMESSAGE),PlayerMessageFreeFn,PlayerMessageFreeContext);

	return DP_OK;
		
	
} // SetupPlayerMessage

HRESULT	ReplacePlayerHeader(LPDPLAYI_DPLAY this,LPSENDPARMS psp)
{
	LPMSG_PLAYERMESSAGE psm;
	PGROUPHEADER pGroupHeader;
	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		return DP_OK;
	}

	psm = GetPlayerMessageHeader();

    if (NULL == psm) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	// not naked - put to + from on 
	psm->idFrom = psp->pPlayerFrom->dwID;
	ASSERT(psp->pGroupTo);
	psm->idTo = psp->pGroupTo->dwID;

	// link the old header on list to be freed when send is done.
	pGroupHeader=(PGROUPHEADER)psp->Buffers[0].pData;
	pGroupHeader->pNext=psp->pGroupHeaders;
	psp->pGroupHeaders=pGroupHeader;

	psp->Buffers[0].pData=(PUCHAR)psm;
	ASSERT(psp->Buffers[0].len==sizeof(MSG_PLAYERMESSAGE));
	return DP_OK;
}

// alloc space for a player - player message.
// called by SendPlayerMessage and SendGroupMessage
HRESULT SetupPlayerMessage(LPDPLAYI_DPLAY this,LPBYTE * ppSendBuffer,DWORD * pdwMessageSize,
	LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo,LPVOID pvBuffer,DWORD dwBufSize)
{
	LPMSG_PLAYERMESSAGE psm;
	BOOL bPutMessageIDs = TRUE;
	
	ASSERT(pdwMessageSize);
	ASSERT(ppSendBuffer);

	*pdwMessageSize = dwBufSize + GET_MESSAGE_SIZE(this,MSG_PLAYERMESSAGE);

	// note - secure messages can't be sent raw (message ids are required for routing)
	if ((this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) &&
		!SECURE_SERVER(this))
	{
		// naked! - no player ids in the message
		*pdwMessageSize -= sizeof(MSG_PLAYERMESSAGE);
		bPutMessageIDs = FALSE;
	}
	
	*ppSendBuffer = DPMEM_ALLOC(*pdwMessageSize);
    if (NULL == *ppSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }

	// build the player message
	// note, we don't put a header ('yalp') on this...
	// messages arriving without our header are assumed
	// to be player messsages

	if (bPutMessageIDs)
	{
		psm = (	LPMSG_PLAYERMESSAGE ) (*ppSendBuffer +  this->dwSPHeaderSize);
		// not naked - put to + from on 
		psm->idFrom = pPlayerFrom->dwID;
		psm->idTo = pPlayerTo->dwID;

		// copy player message into send buffer
		memcpy(*ppSendBuffer + this->dwSPHeaderSize + sizeof(MSG_PLAYERMESSAGE),(LPBYTE)pvBuffer,dwBufSize);
	}
	else
	{
		// naked!
		// copy just player message into send buffer
		memcpy(*ppSendBuffer + this->dwSPHeaderSize,(LPBYTE)pvBuffer,dwBufSize);
	}
	
	return DP_OK;
		
	
} // SetupPlayerMessage

// send a player to player message. called by idirectplay?::send
HRESULT SendPlayerMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo,DWORD dwFlags,LPVOID pvBuffer,DWORD dwBufSize)
{
	HRESULT hr=DP_OK;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer=NULL;
	HRESULT hrSend=DP_OK; // the hresult we actually return
	BOOL bDropLock = FALSE; // should we drop the lock across send?

	hr = SetupPlayerMessage( this,&pSendBuffer,&dwMessageSize,pPlayerFrom,pPlayerTo,
		pvBuffer,dwBufSize);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	DPF(9,"flags = %d sending player-player message, total size = %d,msg size = %d\n",dwFlags,dwMessageSize,dwBufSize);
	
	// if session is secure, route message through the nameserver
	if (SECURE_SERVER(this) && !IAM_NAMESERVER(this) && 
		!(pPlayerTo && (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
	{
		DPF(6,"Routing player message through nameserver");
		pPlayerTo = this->pNameServer;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if (dwFlags & DPSEND_GUARANTEE)
	{
		// note - we could already be in pending mode (executing pending commands on the server)
		DPF(6," guaranteed send - entering pending mode");
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop it
	}

	// make sure we don't send dplay's msg_hdr as the first dword in the message
	if ((dwMessageSize >= sizeof(DWORD)) && 
		(*(DWORD *)(pSendBuffer + this->dwSPHeaderSize) == MSG_HDR))
	{
	 	DPF(1,"app sending dplays command token - repackaging");
		hrSend = WrapPlayerMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,
			dwMessageSize,dwFlags,bDropLock);
	}
	else 
	{
		hrSend = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,dwMessageSize,
			dwFlags,bDropLock);		
	}	
	if (FAILED(hrSend) && (hrSend != DPERR_PENDING))	
	{
		DPF(0,"send message failed hr = 0x%08lx\n",hrSend);
	}

	// if we dropped the lock above make sure to take it again

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	DPMEM_FREE(pSendBuffer);
	return hrSend;

} // SendPlayerMessage	

MSG_SYSMESSAGE COMMAND_WRAPPER={MSG_HDR,DPSP_MSG_PLAYERWRAPPER};

// send a player to player message. called by idirectplay?::send
HRESULT SendPlayerMessageEx(LPDPLAYI_DPLAY this, LPSENDPARMS psp)
{
	HRESULT hr=DP_OK;
	HRESULT hrSend=DP_OK; // the hresult we actually return
	BOOL bDropLock = FALSE; // did we drop the lock ?

	hr = SetupPlayerMessageEx(this, psp);
	
	if (FAILED(hr))
	{
		ASSERT(FALSE);
		return hr;
	}

	DPF(9,"flags = %d sending player-player message, total size = %d,msg size = %d\n",psp->dwFlags,psp->dwTotalSize,psp->dwDataSize);
	
	// if session is secure, route message through the nameserver
	if (SECURE_SERVER(this) && !IAM_NAMESERVER(this) && 
		!(psp->pPlayerTo && (psp->pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)))
	{
		DPF(6,"Routing player message through nameserver");
		psp->pPlayerTo = this->pNameServer;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation -- OPTIMIZATION
	if (psp->dwFlags & DPSEND_GUARANTEE)
	{
		// note - we could already be in pending mode (executing pending commands on the server)
		DPF(6," guaranteed send - entering pending mode");
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop lock across send call.
	}

	// make sure we don't send dplay's msg_hdr as the first dword in the message
	if ((psp->Buffers[0].len >= sizeof(DWORD)) && 
		(*(DWORD *)(psp->Buffers[0].pData) == MSG_HDR))
	{
	 	DPF(1,"app sending dplays command token - tacking on wrapping");
	 	InsertSendBufferAtFront(psp,&COMMAND_WRAPPER,sizeof(COMMAND_WRAPPER),NULL,NULL);
	}

	// Directed send usually requires one send to the application, so allocate one
	// context in the context list to begin with.
	InitContextList(this,psp,1);
	
	hrSend = SendDPMessageEx(this,psp,bDropLock);		
	
	if (FAILED(hrSend) && hrSend != DPERR_PENDING)	
	{
		DPF(0,"send message failed hr = 0x%08lx\n",hrSend);
	}

	// if we dropped the lock above make sure to take it again

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	return hrSend;

} // SendPlayerMessageEx


#undef DPF_MODNAME
#define DPF_MODNAME "SendGroupMessage"

// call the SP's send to group function
// called by SendGroupMessage
HRESULT SendSPGroupMessage(LPDPLAYI_DPLAY this,DPID idPlayerFrom,DPID idGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize)
{
	DPSP_SENDTOGROUPDATA sd;
	HRESULT hr;

	sd.dwFlags = dwFlags;
	sd.idGroupTo = idGroupTo;
	sd.idPlayerFrom = idPlayerFrom;
	sd.lpMessage = pvBuffer;
	sd.dwMessageSize = dwBufSize;
	sd.lpISP = this->pISP;

    hr = CALLSP(this->pcbSPCallbacks->SendToGroup,&sd);
    
    if (FAILED(hr))
    {
    	DPF(0,"send to group failed! hr = 0x%08lx\n",hr);
    }
    
    return hr;
    
} // SendSPGroupMessage

#undef DPF_MODNAME

#define DPF_MODNAME "SendGroupMessageEx"
HRESULT SendSPGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{
	DWORD dwSPMsgID;
	DPSP_SENDTOGROUPEXDATA sed;
	HRESULT hr;

	hr=InitContextList(this,psp,1);

	if(FAILED(hr)){
		return hr;
	}

	sed.lpISP          = this->pISP;
	sed.dwFlags        = psp->dwFlags;
	sed.idGroupTo      = psp->idTo;
	sed.idPlayerFrom   = psp->idFrom;
	sed.lpSendBuffers  = &psp->Buffers[0];
	sed.cBuffers       = psp->cBuffers;
	sed.dwMessageSize  = psp->dwTotalSize;
	sed.dwPriority     = psp->dwPriority;
	sed.dwTimeout      = psp->dwTimeout;
	sed.lpDPContext    = psp->hContext;
	sed.lpdwSPMsgID    = &dwSPMsgID;

	pspAddRef(psp);

    hr = CALLSP(this->pcbSPCallbacks->SendToGroupEx,&sed);

	if(hr==DPERR_PENDING){
                AddContext(this,psp,(LPVOID)(DWORD_PTR)dwSPMsgID);
	} else {
		pspDecRef(this, psp);
	}
	return hr;
}
#undef DPF_MODNAME

#define DPF_MODNAME "AskServerToMulticast"
// ask the name server to send our group message for us
HRESULT AskServerToMulticast(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage)
{
	LPMSG_ASK4MULTICAST pmsg;
	DWORD dwTotalSize; // pvBuffer + pmsg
	LPBYTE pSendBuffer; // buffer we're going to send out
	HRESULT hr;
	BOOL bDropLock=FALSE; // drop the lock ?
		
	DPF(4,"routing group send via multicast server");

	if (!fPlayerMessage)	
	{
		// don't ship the header on our embedded system message
		ASSERT(dwBufSize > this->dwSPHeaderSize); // better have a header on it! 
		dwBufSize -= this->dwSPHeaderSize;
		pvBuffer = (LPBYTE)pvBuffer + this->dwSPHeaderSize; // point to the system message

		if (SECURE_SERVER(this))
		{
			// we are making the system message secure here because the hook cannot distinguish 
			// between a player and a system message when multicasted. A secure player message 
			// will have this flag set.
			dwFlags |= DPSEND_SIGNED;
		}
	}
	
	dwTotalSize = dwBufSize + GET_MESSAGE_SIZE(this,MSG_ASK4MULTICAST);
	
	pSendBuffer = DPMEM_ALLOC(dwTotalSize);
	if (!pSendBuffer)
	{
		DPF_ERR("could not send group message - out of memory");
		return DPERR_OUTOFMEMORY;
		
	}

	pmsg = (LPMSG_ASK4MULTICAST)(pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);

	if (dwFlags & DPSEND_GUARANTEED)
	{
	    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ASK4MULTICASTGUARANTEED);		
	}
	else 
	{
	    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_ASK4MULTICAST);
	}

	// set up the fixed data
	pmsg->idGroupTo = pGroupTo->dwID;
	pmsg->idPlayerFrom = pPlayerFrom->dwID;
	pmsg->dwMessageOffset = sizeof(MSG_ASK4MULTICAST);
	
	// stick the message on the end
	memcpy((LPBYTE)pmsg+sizeof(MSG_ASK4MULTICAST),pvBuffer,dwBufSize);

	// if it's a guaranteed send of a player message, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if (fPlayerMessage && (dwFlags & DPSEND_GUARANTEED))
	{
		DPF(6,"guaranteed player message being multicasted - entering pending mode");
		ASSERT(!(this->dwFlags & DPLAYI_DPLAY_PENDING));
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount); // we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;	// drop the lock across send.
	}
	
	// send it to the nameserver
   	hr = SendDPMessage(this,pPlayerFrom,this->pNameServer,(LPBYTE)pSendBuffer,dwTotalSize,dwFlags,bDropLock);			

	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{		
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	DPMEM_FREE(pSendBuffer);
	
	return hr;	

} // AskServerToMulticast

#define MAX_FAST_TO_IDS 512

// send a player or system message to a group.  called by idirectplay::send, SendSystemMessage and SendUpdateMessage
HRESULT SendGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_GROUP pGroupTo,DWORD dwFlags,
	LPVOID pvBuffer,DWORD dwBufSize,BOOL fPlayerMessage)
{
	LPDPLAYI_PLAYER	pPlayer;
    LPDPLAYI_GROUPNODE lpGroupnode,lpGroupnodeWalker;
	DWORD dwMessageSize;
	LPBYTE pSendBuffer;
	HRESULT hr=DP_OK;
	BOOL bAlloc = FALSE; // did we alloc the send buffer?
	BOOL bDX3SetPlayerTo = FALSE; // there's a dx3 player in the game
	BOOL bDropLock = FALSE; // did we drop the lock?

	DPID FromID;
	DPID ToID;

	UINT iToIDs;
	UINT cToIDs;
	DWORD (*pdwToIDs)[];
	DWORD rgdwToIDs[MAX_FAST_TO_IDS];
								  
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);

	// if there's a multicast server, and dplay owns this group (not optimized), and we're
	// not the server, we want the server to distribut this bad boy for us
	if ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) &&
		(pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		!(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
		// send it to the multicast server
		hr = AskServerToMulticast(this,pPlayerFrom,pGroupTo,dwFlags,pvBuffer,
			dwBufSize,fPlayerMessage);
		return hr;
	}

	if (fPlayerMessage)
	{
		hr = SetupPlayerMessage( this,&pSendBuffer,&dwMessageSize,pPlayerFrom,(LPDPLAYI_PLAYER)pGroupTo,
			pvBuffer,dwBufSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			return hr;
		}
		bAlloc = TRUE;
	}
	else 
	{
		pSendBuffer = pvBuffer;
		dwMessageSize = dwBufSize;
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if ((dwFlags & DPSEND_GUARANTEE) && fPlayerMessage)
	{
		DPF(6," guaranteed send to group - entering pending mode");
		// note - we could already be in pending mode (executing pending commands on the server)
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount);	// we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;		// we dropped it
	}

	// optimize the send only if the sp owns the group and there's no dx3 clients (optimized
	// sends won't work w/ dx3 clients)
	if (!(pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		(this->pcbSPCallbacks->SendToGroup) && 
		!(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) &&
		!(this->lpsdDesc->dwFlags & DPSESSION_CLIENTSERVER) &&
		!(this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
	{
		FromID = pPlayerFrom->dwID;
		ToID   = pGroupTo->dwID;
		if(bDropLock){
			LEAVE_DPLAY();
		}
		// group is owned by sp,  let them do the send
		hr = SendSPGroupMessage(this,FromID,ToID,dwFlags,pSendBuffer,dwMessageSize);
		
		if(bDropLock){
			ENTER_DPLAY();
		}
		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	} // SendToGroup
	else
	{
		// otherwise, this dplay has to do the send.  In DX3, we sent one packet out to
		// each player. lpGroupnode is the list of players in the group

		// in client/server, the server may create groups containing a client that the
		// client does not know about. So, you can't send to the group on the client, you
		// have to send to each player on the client individually.

		if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||			// do it the DX3 way
			(IAM_NAMESERVER(this) && CLIENT_SERVER(this)))		// send to client individually
		{
			// have to send to each individual player
			if (fPlayerMessage) lpGroupnode = pGroupTo->pGroupnodes;
			// send it to the system players
			else lpGroupnode = pGroupTo->pSysPlayerGroupnodes;			
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (! (this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ) bDX3SetPlayerTo = TRUE;
		}
		else 
		{
			// if it's dx5 or better, send to sysplayer - let them distribute
			lpGroupnode = pGroupTo->pSysPlayerGroupnodes;			
		}

		
		iToIDs = 0;

//		a-josbor:  I'm not sure what this 'fix' is trying to say.  The pGroupTo->nPlayers is a count of all the 
//			regular (non-sys) players in the group.  This is different from the number of system players
//			that proxy all those players.  The count of the system players is really the only thing
//			interesting in post-DX3 games.  However, the code DOES do the right thing (count and send)
//			to only the system players.

			//cToIDs = pGroupTo->nPlayers+1; // sometimes we see a sysgroup with count not set so +1
			// workaround, sometimes count not right...
			lpGroupnodeWalker=lpGroupnode;

			cToIDs=0;
			while(lpGroupnodeWalker){
			   cToIDs++;     
			   lpGroupnodeWalker = lpGroupnodeWalker->pNextGroupnode; 
			}
			if(pGroupTo->nPlayers+1 < cToIDs){
				DPF(0,"WARNING: Group player count bad! (%d < %d) good thing we are working around...\n", pGroupTo->nPlayers+1, cToIDs);
			}
			// end workaround
		
		if(cToIDs > MAX_FAST_TO_IDS){
			// need to allocate a block of memory for the ToID list
			pdwToIDs = DPMEM_ALLOC(cToIDs*sizeof(DWORD));
			if(!pdwToIDs){
				hr=DPERR_NOMEMORY;
				goto error_exit;
			}
		} else {
			// use the block of memory from the stack.
			pdwToIDs = (DWORD (*)[])&rgdwToIDs;
		}

		iToIDs=0;

		// copy the to ids in the group into an array.
		while (lpGroupnode)
		{
			pPlayer = lpGroupnode->pPlayer;
			(*pdwToIDs)[iToIDs++]=pPlayer->dwID;
			ASSERT(iToIDs <= cToIDs);
			lpGroupnode = lpGroupnode->pNextGroupnode; 
		}	

		cToIDs=iToIDs; // actual number filled in.

		for(iToIDs=0; iToIDs < cToIDs ; iToIDs++){
		
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (fPlayerMessage)
			{
				LPMSG_PLAYERMESSAGE pmsg = (LPMSG_PLAYERMESSAGE)(pSendBuffer +  this->dwSPHeaderSize);

				if(bDX3SetPlayerTo) {
					pmsg->idTo = (*pdwToIDs)[iToIDs];
				} 
			}
			else // it's a system message
			{
				LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)(pSendBuffer +  this->dwSPHeaderSize);
				DWORD dwCommand=GET_MESSAGE_COMMAND(pmsg);

				// If it's a chat message, we don't want to mess with the To player ID
				if(dwCommand != DPSP_MSG_CHAT && dwCommand != DPSP_MSG_VOICE){
					if(bDX3SetPlayerTo) {
						pmsg->dwIDTo = (*pdwToIDs)[iToIDs];
					} 
					else 
					{
//						a-josbor: it's a system message, so just set the to field to 0
//							to avoid garbage on the wire.  The message will be distributed
//							to the system group on all receipient machines.
						pmsg->dwIDTo = 0;
					}	
				}
			}

			pPlayer=PlayerFromID(this, (*pdwToIDs)[iToIDs]);

			if(pPlayer){

			   	hr = SendDPMessage(this,pPlayerFrom,pPlayer,pSendBuffer,dwMessageSize,dwFlags,bDropLock);		
				if (FAILED(hr) && (hr != DPERR_PENDING))	
				{
					DPF(0,"SendGroup : send message failed hr = 0x%08lx\n",hr);	
					// keep trying...
				}
			}	
			
		} /* for */
		
		if(pdwToIDs != (DWORD (*)[])&rgdwToIDs){
			DPMEM_FREE(pdwToIDs);
		}

	}

	// clean up pending mode
	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		// flush any commands that came in while our send was going on
		hr = ExecutePendingCommands(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	if (bAlloc) DPMEM_FREE(pSendBuffer);

	return DP_OK;

error_exit:
	if (bAlloc) DPMEM_FREE(pSendBuffer);
	return hr;
	
} // SendGroupMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendGroupMessageEx"

// send a player or system message to a group.  called by idirectplay::send, SendSystemMessage and SendUpdateMessage
HRESULT SendGroupMessageEx(LPDPLAYI_DPLAY this, PSENDPARMS psp, BOOL fPlayerMessage)
{
	LPDPLAYI_PLAYER pPlayer;
    LPDPLAYI_GROUPNODE lpGroupnode;
	LPBYTE pSendBuffer=NULL;
	HRESULT hr=DP_OK,hr2;
	BOOL bDX3SetPlayerTo = FALSE; // there's a dx3 player in the game
	BOOL bDropLock = FALSE; // Are we dropping the lock across sends?
	BOOL bReturnPending = FALSE;

	DPID FromID;
	DPID ToID;

	UINT  iToIDs;
	UINT  cToIDs;
	DWORD (*pdwToIDs)[];
	DWORD rgdwToIDs[MAX_FAST_TO_IDS];
	BOOL  bIds;
								  
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);

	// if there's a multicast server, and dplay owns this group (not optimized), and we're
	// not the server, we want the server to distribut this bad boy for us
	if ((this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER) &&
		(psp->pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		!(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR))
	{
	#if 0
		// Makes room for a header, so strip it.
		pSendBuffer=ConcatenateSendBuffer(this, &psp->Buffers[0], psp->cBuffers, psp->dwTotalSize);
		if(!pSendBuffer){
			return DPERR_NOMEMORY;
		}
		// send it to the multicast server
		hr = AskServerToMulticast(this,
								  psp->pPlayerFrom,
								  psp->pGroupTo,
								  psp->dwFlags & ~DPSEND_NOCOPY,
								  pSendBuffer+this->dwSPHeaderSize,
								  psp->dwTotalSize,
								  fPlayerMessage);
	#endif
		// send it to the multicast server
		// Since this fn is only ever called with 1 SG buffer currently, this is more effecient...
		hr = AskServerToMulticast(this,
								  psp->pPlayerFrom,
								  psp->pGroupTo,
								  psp->dwFlags & ~DPSEND_NOCOPY,
								  psp->Buffers[0].pData,
								  psp->Buffers[0].len,
								  fPlayerMessage);
	
		goto EXIT;
	}

	bIds=(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID)?(FALSE):(TRUE);

	if (fPlayerMessage)
	{
		hr = SetupPlayerMessageEx(this,psp);
		if(FAILED(hr)){
			goto EXIT;
		}
	}

	// if it's a guaranteed send, put us into pending mode
	// this will keep us from getting into a deadlock situation 
	if ((psp->dwFlags & DPSEND_GUARANTEE) && fPlayerMessage)
	{
		DPF(6," guaranteed send to group - entering pending mode");
		// note - we could already be in pending mode (executing pending commands on the server)
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
		// drop the lock
		ASSERT(1 == gnDPCSCount);	// we want to make sure we're really dropping it

		// we need to remember that we dropped the lock so that we can
		// take it again later. We don't want to use the pending flag since
		// this might already be set when we come in here (i.e. during DP_Close)
		bDropLock = TRUE;		// drop lock across send calls.
	}

	// optimize the send only if the sp owns the group and there's no dx3 clients (optimized
	// sends won't work w/ dx3 clients)
	if (!(psp->pGroupTo->dwFlags & DPLAYI_GROUP_DPLAYOWNS) && 
		(this->pcbSPCallbacks->SendToGroup) && !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME))
	{
		FromID = psp->pPlayerFrom->dwID;
		ToID   = psp->pGroupTo->dwID;
		
		if(bDropLock){
			LEAVE_DPLAY();
		}
		
		// group is owned by sp,  let them do the send
		if(this->pcbSPCallbacks->SendToGroupEx){
			hr=SendSPGroupMessageEx(this,psp);
		} else {
			pSendBuffer=ConcatenateSendBuffer(this,&psp->Buffers[0],psp->cBuffers,psp->dwTotalSize);
			if(!pSendBuffer){
				goto EXIT;
			}
			hr = SendSPGroupMessage(this,
									FromID,
									ToID,
									psp->dwFlags,
									pSendBuffer,
									psp->dwTotalSize+this->dwSPHeaderSize);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}	

		if(bDropLock){
			ENTER_DPLAY();
		}
	} // SendToGroup
	else
	{
		// otherwise, this dplay has to do the send.  In DX3, we sent one packet out to
		// each player. lpGroupnode is the list of players in the group

		// in client/server, the server may create groups containing a client that the
		// client does not know about. So, you can't send to the group on the client, you
		// have to send to each player on the client individually.

		if ((this->dwFlags & DPLAYI_DPLAY_DX3INGAME) ||			// do it the DX3 way
			(IAM_NAMESERVER(this) && CLIENT_SERVER(this)))		// send to client individually
		{
			// have to send to each individual player
			if (fPlayerMessage) lpGroupnode = psp->pGroupTo->pGroupnodes;
			// send it to the system players
			else lpGroupnode = psp->pGroupTo->pSysPlayerGroupnodes;			
			// if there's a dx3 client in the game, we can't deliver it to a group - 
			// we need to put the correct player id in the message
			if (! (this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID) ) bDX3SetPlayerTo = TRUE;
		}
		else 
		{
			// if it's dx5 or better, send to sysplayer - let them distribute
			lpGroupnode = psp->pGroupTo->pSysPlayerGroupnodes;			
		}


		// AO - Fixing a bug, can't run grouplist without a lock!  so we will copy the id's
		//      into a list.  The maximum size of the list is pGroupTo->nPlayers, so we alloc
		//      a buffer of this size.  If there are less than 128 entries, we get the memory
		//      from the stack, if not, we get the memory from the heap.

		iToIDs = 0;
		cToIDs = psp->pGroupTo->nPlayers+1;
		
		if(cToIDs > MAX_FAST_TO_IDS){
			// need to allocate a block of memory for the ToID list
			pdwToIDs = DPMEM_ALLOC(cToIDs*sizeof(DWORD));
			if(!pdwToIDs){
				hr=DPERR_NOMEMORY;
				goto EXIT;
			}
		} else {
			// use the block of memory from the stack.
			pdwToIDs = (DWORD (*)[])&rgdwToIDs;
		}

		// copy the to ids in the group into an array.
		while (lpGroupnode)
		{
			pPlayer = lpGroupnode->pPlayer;
			(*pdwToIDs)[iToIDs++]=pPlayer->dwID;
			ASSERT(iToIDs <= cToIDs);
			lpGroupnode = lpGroupnode->pNextGroupnode; 
		}	

		cToIDs=iToIDs; // actual number filled in.

		if(!cToIDs){
			goto EXIT2;
		}

		// Now we know how big the list will be, we can allocate a context list.
		hr=InitContextList(this,psp,cToIDs);
		if(FAILED(hr)){
			goto EXIT2;
		}
		
		for(iToIDs=0; iToIDs < cToIDs ; iToIDs++){


			if(bIds){
				if(fPlayerMessage && (iToIDs > 0) && 
				  (psp->dwFlags & DPSEND_ASYNC)){
					// Need to swap out header so its unique during the call if
					// we are sending async.
					hr=ReplacePlayerHeader(this,psp);
					if(hr!=DP_OK){
						bReturnPending=FALSE;
						DPF(0,"Ran out of memory building unique header for group send\n");
						break;
					}
				}
			
				// if there's a dx3 client in the game, we can't deliver it to a group - 
				// we need to put the correct player id in the message
				if (fPlayerMessage)
				{
					LPMSG_PLAYERMESSAGE pmsg = (LPMSG_PLAYERMESSAGE)(psp->Buffers[0].pData);

					if(bDX3SetPlayerTo) {
						pmsg->idTo = (*pdwToIDs)[iToIDs];
					} else {
						pmsg->idTo = 0;
					}	
				}
			}	
			else if(!fPlayerMessage)// it's a system message
			{
				LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)(psp->Buffers[0].pData);

				if(bDX3SetPlayerTo) {
					pmsg->dwIDTo = (*pdwToIDs)[iToIDs];
				} else {
					pmsg->dwIDTo = 0;
				}	
			}

			psp->pPlayerTo=PlayerFromID(this, (*pdwToIDs)[iToIDs]);

			if(psp->pPlayerTo){

		   		hr = SendDPMessageEx(this,psp,bDropLock);	// handles adding refs.

				if(hr==DPERR_PENDING){
					bReturnPending=TRUE;				
				} else if(FAILED(hr)) {
					if(hr==DPERR_NOMEMORY){
						bReturnPending=FALSE;
					}
					DPF(0,"SendGroup : send message failed hr = 0x%08lx\n",hr);	
					// keep trying...
				}
			}	
			
		} /* for */
EXIT2:		
		if(pdwToIDs != (DWORD (*)[])&rgdwToIDs){
			DPMEM_FREE(pdwToIDs);
		}

	}

EXIT:

	if(pSendBuffer){
		MsgFree(NULL,pSendBuffer);
	}

	// clean up pending mode
	if (this->dwFlags & DPLAYI_DPLAY_PENDING)
	{
		// flush any commands that came in while our send was going on
		hr2 = ExecutePendingCommands(this);
		if (FAILED(hr2))
		{
			ASSERT(FALSE);
		}
	}

	if(bReturnPending){
		return DPERR_PENDING;
	} else {	
		return hr;
	}	

} // SendGroupMessageEx

#undef DPF_MODNAME
#define DPF_MODNAME "SendPlayerManagementMessage"

// called by InternalAddPlayerToGroup , InternalDeletePlayerFromGroup, InternalDestroyGroup, InternalDestroyPlayer
// addplayer/addgroup use sendaddmessage
HRESULT SendPlayerManagementMessage(LPDPLAYI_DPLAY this,DWORD dwCmd,DPID idPlayer,
	DPID idGroup)
{
	DWORD dwMessageSize;
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	HRESULT hr;
	LPBYTE pBuffer;
	DWORD dwExtraFlags=0;
//	BOOL bWait=FALSE;

	if(dwCmd & DPSP_MSG_ASYNC){
		dwCmd &= ~DPSP_MSG_ASYNC;
		dwExtraFlags=DPSEND_SYSMESS;
	}


	// alloc + set up message
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE);

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)((LPBYTE)pBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);
	SET_MESSAGE_COMMAND(pmsg,dwCmd);

	// fill in message specific info
	switch (dwCmd)
	{
		case DPSP_MSG_DELETEPLAYER:
			pmsg->dwPlayerID = idPlayer;
			
			if(this->pSysPlayer && idPlayer==this->pSysPlayer->dwID){
				//dwExtraFlags = 0; // by init
			} else {
//				bWait=TRUE;
				dwExtraFlags = DPSEND_SYSMESS;
			}
			break;
			

		case DPSP_MSG_DELETEGROUP:
			pmsg->dwGroupID = idGroup;
			break;

		case DPSP_MSG_ADDSHORTCUTTOGROUP:
		case DPSP_MSG_DELETEGROUPFROMGROUP:
		case DPSP_MSG_ADDPLAYERTOGROUP:
		case DPSP_MSG_DELETEPLAYERFROMGROUP:  
			pmsg->dwPlayerID = idPlayer;
			pmsg->dwGroupID = idGroup;
			break;
			
		default:
			ASSERT(FALSE);
			break;			
	}	

	hr = SendSystemMessage(this,pBuffer,dwMessageSize,DPSEND_GUARANTEE|dwExtraFlags,TRUE);

	DPMEM_FREE(pBuffer);

//	if(bWait){
//		Sleep(250);
//	}

	return hr;

} // SendPlayerManagementMessage

#undef DPF_MODNAME
#define DPF_MODNAME "SendDataChanged"

// the player blob has changed. tell the world.
HRESULT SendDataChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags)
{
	MSG_PLAYERDATA msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERDATA) + pPlayer->dwPlayerDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);

    if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_PLAYERDATACHANGED);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_GROUPDATACHANGED);
	
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwDataSize = pPlayer->dwPlayerDataSize;
	msg.dwDataOffset = sizeof(msg);
	
	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));
	// copy the new player data into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),pPlayer->pvPlayerData,
		pPlayer->dwPlayerDataSize);

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize, dwFlags|DPSEND_ASYNC,TRUE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendDataChanged

#undef DPF_MODNAME
#define DPF_MODNAME "SendNameChanged"

// the players name has changed. tell the world.
HRESULT SendNameChanged(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,BOOL fPlayer,
	DWORD dwFlags)
{
	MSG_PLAYERNAME msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;
	UINT nShortLength,nLongLength; // name length, in bytes

	nShortLength = WSTRLEN_BYTES(pPlayer->lpszShortName);
	nLongLength =  WSTRLEN_BYTES(pPlayer->lpszLongName);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERNAME) + nShortLength + nLongLength; 

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);

    if (fPlayer) SET_MESSAGE_COMMAND(&msg,DPSP_MSG_PLAYERNAMECHANGED);
	else SET_MESSAGE_COMMAND(&msg,DPSP_MSG_GROUPNAMECHANGED);

	msg.dwPlayerID = pPlayer->dwID;

	// copy the short name into the buffer
	if (nShortLength)
	{
		// copy the short name into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),pPlayer->lpszShortName,
			nShortLength);
		msg.dwShortOffset = sizeof(msg);
	}
	else 
	{
		msg.dwShortOffset = 0;
	}
	// copy the long name into the send buffer	
	if (nLongLength)
	{
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + nShortLength,
			pPlayer->lpszLongName,nLongLength);
		msg.dwLongOffset = sizeof(msg) + nShortLength;
	}
	else 
	{
		msg.dwLongOffset = 0;
	}
	
	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,dwFlags|DPSEND_ASYNC,TRUE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendNameChanged

#undef DPF_MODNAME
#define DPF_MODNAME "SendIAmNameServer"

// this idirectplay has become the nameserver.  tell all remote players.
HRESULT SendIAmNameServer(LPDPLAYI_DPLAY this)
{
	LPBYTE pbuf;
	LPMSG_IAMNAMESERVER pmsg;
	HRESULT hr;

	pbuf=DPMEM_ALLOC(GET_MESSAGE_SIZE(this,MSG_IAMNAMESERVER)+this->pSysPlayer->dwSPDataSize);

	if(pbuf) {

		pmsg=(LPMSG_IAMNAMESERVER)(pbuf+this->dwSPHeaderSize);

		memset(pmsg,0,sizeof(MSG_IAMNAMESERVER));

	    // build a message to send 
		SET_MESSAGE_HDR(pmsg);
		SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_IAMNAMESERVER);

		ASSERT(this->pSysPlayer);
		ASSERT(this->pSysPlayer->dwID);

		pmsg->dwIDHost = this->pSysPlayer->dwID;
		pmsg->dwFlags = this->pSysPlayer->dwFlags & ~(DPLAYI_PLAYER_NONPROP_FLAGS|DPLAYI_PLAYER_PLAYERLOCAL);
		pmsg->dwSPDataSize = this->pSysPlayer->dwSPDataSize;
		memcpy((PCHAR)(pmsg+1),this->pSysPlayer->pvSPData, this->pSysPlayer->dwSPDataSize);

		hr = SendSystemMessage(this,pbuf,this->dwSPHeaderSize+sizeof(MSG_IAMNAMESERVER)+this->pSysPlayer->dwSPDataSize,DPSEND_SYSMESS,FALSE);

		DPMEM_FREE(pbuf);

	} else {
		hr=DPERR_OUTOFMEMORY;
	}
	return hr;

} // SendIAmNameServer


#undef DPF_MODNAME
#define DPF_MODNAME "SendMeNameServer"

// this idirectplay has become the nameserver.  tell all local players.
HRESULT SendMeNameServer(LPDPLAYI_DPLAY this)
{
	MSG_PLAYERMGMTMESSAGE msg;
	HRESULT hr;

	memset(&msg,0,sizeof(MSG_PLAYERMGMTMESSAGE));

    // build a message to send to our local players
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_NAMESERVER);

	// send it out to our local players 
	hr = DistributeSystemMessage(this,(LPBYTE)&msg,sizeof(MSG_PLAYERMGMTMESSAGE));
	
	return hr;

} // SendMeNameServer

#undef DPF_MODNAME
#define DPF_MODNAME "SendSessionDescChanged"

// the sessiion desc has changed. tell the world.
HRESULT SendSessionDescChanged(LPDPLAYI_DPLAY this, DWORD dwFlags)
{
	MSG_SESSIONDESC msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
	HRESULT hr;
    UINT nSessionNameLength, nPasswordLength;

    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
    SET_MESSAGE_COMMAND(&msg,DPSP_MSG_SESSIONDESCCHANGED);
    memcpy(&(msg.dpDesc), this->lpsdDesc, sizeof(DPSESSIONDESC2));

    // calculate the size of the send buffer
    nSessionNameLength  = WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
	nPasswordLength     = WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);
	// message size + name + password
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SESSIONDESC) 
                    + sizeof(DPSESSIONDESC2) + nSessionNameLength 
                    + nPasswordLength;

    // allocate send buffer
    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not session desc changed message - out of memory");
        return E_OUTOFMEMORY;
    }
		
	// copy the session name into the buffer
	if (nSessionNameLength)
	{
		// copy the session name into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),this->lpsdDesc->lpszSessionName,
			nSessionNameLength);
		msg.dwSessionNameOffset = sizeof(msg);
	}
	else 
	{
		msg.dwSessionNameOffset = 0;
	}

	// copy the password into the send buffer	
	if (nPasswordLength)
	{
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg) + nSessionNameLength,
			this->lpsdDesc->lpszPassword,nPasswordLength);
		msg.dwPasswordOffset = sizeof(msg) + nSessionNameLength;
	}
	else 
	{
		msg.dwPasswordOffset = 0;
	}

	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	hr = SendSystemMessage(this,pSendBuffer,dwMessageSize,dwFlags|DPSEND_ASYNC,FALSE);
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendSessionDescChanged


#undef DPF_MODNAME
#define DPF_MODNAME "SendChatMessage"

// Send a chat message (it's in system message format)
HRESULT SendChatMessage(LPDPLAYI_DPLAY this, LPDPLAYI_PLAYER pPlayerFrom,
		LPDPLAYI_PLAYER pPlayerTo, DWORD dwFlags, LPDPCHAT lpMsg, BOOL fPlayer)
{
	MSG_CHAT msg;
	LPBYTE pSendBuffer;
	DWORD dwMsgSize;
	HRESULT hr;
	UINT nMsgLength; // message length, in bytes

	nMsgLength = WSTRLEN_BYTES(lpMsg->lpszMessage);

	// message size + blob size
	dwMsgSize = GET_MESSAGE_SIZE(this,MSG_CHAT) + nMsgLength; 

    pSendBuffer = DPMEM_ALLOC(dwMsgSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send chat message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the player (or group)
	SET_MESSAGE_HDR(&msg);

	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_CHAT);

	msg.dwIDFrom = pPlayerFrom->dwID;
	msg.dwIDTo = pPlayerTo->dwID;
	msg.dwFlags = lpMsg->dwFlags;

	// copy the short name into the buffer
	if (nMsgLength)
	{
		// copy the message into the send buffer
		memcpy(pSendBuffer + this->dwSPHeaderSize + sizeof(msg),
			lpMsg->lpszMessage,	nMsgLength);
		msg.dwMessageOffset = sizeof(msg);
	}
	else 
	{
		msg.dwMessageOffset = 0;
	}

	// copy the msg into the send buffer
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// Send to the appropriate player(s)
	if(fPlayer)
	{
		if(dwFlags & DPSEND_GUARANTEE){
			this->dwFlags |= DPLAYI_DPLAY_PENDING;

		}
		hr = SendDPMessage( this, pPlayerFrom, pPlayerTo, pSendBuffer,
				dwMsgSize, dwFlags|DPSEND_ASYNC, (dwFlags&DPSEND_GUARANTEE)?TRUE:FALSE);

		ExecutePendingCommands(this);
	}
	else 
	{
		// send to group
		hr = SendGroupMessage(this, pPlayerFrom, (LPDPLAYI_GROUP)pPlayerTo,
				dwFlags|DPSEND_ASYNC, pSendBuffer, dwMsgSize, FALSE);
	}
	
	DPMEM_FREE(pSendBuffer);

	return hr;

} // SendChatMessage


// called by SendAsyncAddForward to see if we should send an add forward
// to pPlayer
BOOL IsInAddForwardList(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPADDFORWARDNODE pnode = this->pAddForwardList;
	BOOL bFound = FALSE;
	
	while (pnode && !bFound)
	{
		if (pnode->dwIDSysPlayer == pPlayer->dwID) bFound = TRUE;
		else pnode = pnode->pNextNode;
	}
	
	return bFound;
	
} // IsInAddForwardList

HRESULT SendAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,LPADDFORWARDNODE pnode)
{
    HRESULT hr=DP_OK;
    MSG_PLAYERMGMTMESSAGE msg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize, dwDataSize;
	LPDPLAYI_GROUPNODE lpGroupnode;
	LPDPLAYI_PLAYER pPlayerTo;
		
	ASSERT(IAM_NAMESERVER(this));
	
	// If this is a lobby-owned object, we are never going to send a create
	// message anywhere, so just return success from here to keep the
	// dplay code running as expected.
	if(IS_LOBBY_OWNED(this)) return DP_OK;

	// no add forward in client server 
	if (CLIENT_SERVER(this)) return DP_OK; 
	
    // clear off all fields, so we don't pass stack garbage
    memset(&msg,0,sizeof(msg));

	// call packplayerlist w/ null buffer to find out how big this player is when packed
	dwDataSize = PackPlayer( pPlayer,NULL,TRUE);
	msg.dwPlayerID = pPlayer->dwID;
	msg.dwCreateOffset = sizeof(msg);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERMGMTMESSAGE) + dwDataSize;

    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send create message - out of memory");
        return E_OUTOFMEMORY;
    }
	
    // build a message to send to the sp
	SET_MESSAGE_HDR(&msg);
	SET_MESSAGE_COMMAND(&msg,DPSP_MSG_ADDFORWARD);

	// set up the buffer, msg followed by packed player or group struct
	memcpy(pSendBuffer + this->dwSPHeaderSize,&msg,sizeof(msg));

	// pack up the player list!	
	PackPlayer(pPlayer,pSendBuffer + this->dwSPHeaderSize + sizeof(msg),TRUE);

	// now, send it to all system players who are not in the addforwardq
	ASSERT(this->pSysGroup);
	lpGroupnode = this->pSysGroup->pSysPlayerGroupnodes;			
	while (lpGroupnode)
	{
		pPlayerTo = lpGroupnode->pPlayer;
		lpGroupnode = lpGroupnode->pNextGroupnode;
		if (!IsInAddForwardList(this,pPlayerTo) && (pPlayerTo != this->pSysPlayer))
		{
			pnode->nAcksReq++; // we're sending to pPlayerTo, we need an ack from him
			
		   	hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwMessageSize,
				DPSEND_GUARANTEED | DPSEND_ASYNC, FALSE);		
			if (FAILED(hr)) 
			{
				DPF(0,"SendAddForward : send message failed hr = 0x%08lx\n",hr);	
				pnode->nAcksReq--;
				// keep trying...
			}
		}
	}
   
    DPF(2,"sent add forward announcment id = %d - nAcksRequired = %d",msg.dwPlayerID,pnode->nAcksReq); 
	
	DPMEM_FREE(pSendBuffer);
	
    // done
    return DP_OK;

} // SendAsyncAddForward
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\handler.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       handler.c
 *  Content:	handles messages received by sp. 
 *
 *		function prefixes indicate which players execute code
 *			NS_	- executes on name server only
 *			SP_ - executed by sysplayer only
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *  2/1/96		andyco	created it
 *	2/14/96		andyco	added user message support
 *	3/1/96		andyco	added user system messages
 *	4/12/96		andyco	added DPlay_xxx for sp's to call 
 *	4/25/96		andyco	added spblob space at end of msg's
 *	5/20/96		andyco	idirectplay2
 *	5/29/96		andyco	combined builbuildaddplayer and buildaddgroup into build add
 *	6/6/96		andyco	added namechanged,datachanged
 *	6/20/96		andyco	added WSTRLEN_BYTES
 *	6/22/96		andyco	check guid + pw at server on enumsessoins
 *	6/22/96		andyco	check max players b4 giving out new player id
 *	6/23/96		kipo	updated for latest service provider interfaces.
 *	6/24/96		kipo	changed guidGame to guidApplication.
 *	7/1/96		andyco	turned on xxxPlayerxxGroup messages.  these weren't
 *						being generated, and left us w/ a messagenode w/ a
 *						NULL message
 *	7/3/96		andyco	setting names in buildxxxmessage was not properly 
 *						setting the pointers.  Fixes RAID # 2200.
 *  7/8/96      ajayj   Changed references to data member 'PlayerName' in DPMSG_xxx
 *                      to 'dpnName' to match DPLAY.H
 *                      Change DPSESSION_MIGRATENAMESERVER to DPSESSION_MIGRATEHOST
 *                      Change DPSYS_NAMESERVER to DPSYS_HOST
 *	7/10/96		andyco	turned on add_forward support for pending...
 *	7/10/96		kipo	renamed system messages
 *  7/30/96     kipo    player event is a handle now.
 *	8/6/96		andyco	version in commands.  extensible on the wire support.
 *						handle YOUAREDEAD and session lost.
 *	8/8/96		andyco	added support for dpsession_nomessageid
 *  8/12/96		andyco	builddelete was pulling player off stack (unit'ed). duh.
 *	9/1/96		andyco	throw away player-player mess's from invalid players
 *	10/9/96		andyco	got rid of race condition in handlereply by adding
 *						gbWaitingForReply
 * 10/11/96     sohailm added BuildSessionDescMessage() and SP_HandleSessionDescChanged()
 *                      added logic to handle DPSP_MSG_SESSIONDESCCHANGED message.
 * 10/12/96		andyco	don't count sysgroup in enumplayersreply
 * 11/12/96		andyco	support for server players - updatelist
 * 11/21/96		andyco	update perf data if this->pPerfData exists...
 * 01/16/97     sohailm name server doesn't respond to new id requests if session is
 *                      not allowing players (#4574)
 * 1/15/96		andyco	fixed handling of incoming messages to groups
 * 1/24/97		andyco	raid 4728 - don't crash if handle message gets a null message.
 * 1/28/97		andyco	transfer groups to nameserver when sysplayer owning group dies
 * 1/30/97      sohailm don't use size of message to identify version (#5504).
 *	2/1/97		andyco	don't memcpy player messages if we are in pending mode - 
 *						use the copy made by pending.c
 * 2/11/97		kipo	added DPNAME structure to DPMSG_DESTROYPLAYERORGROUP
 * 2/26/97      sohailm update cached session descs on subsequent enumsessions (5838)
 *	3/5/97		andyco	timestamp enumsessions reply
 *	3/10/97		andyco	toggle pending mode when we have multiple local players.
 *						drop player mgmt messages when session is closed.
 * 3/12/97		myronth	Work around for global session list (hack)
 * 3/12/97      sohailm Integrated security into directplay
 * 3/20/97		myronth	Changed to use IS_LOBBYOWNED macro
 * 3/24/97      sohailm Updated EnumSessions to do the filtering on the server.
 *                      Added functionality for DPSESSION_PRIVATE and DPENUMSESSIONS_PASSWORDREQUIRED
 *                      Open now checks for a password and availability of the session
 * 3/25/97		kipo	treat zero-length password strings just like NULL password
 *						strings for DX3 compatability.
 * 3/30/97      sohailm Don't put pingreplys on the pending list.
 *                      Message signatures are not verified in execute pending mode anymore.
 * 4/04/97      sohailm Let pings through in pending mode, but only after downloading the nametable
 * 4/11/97		andyco	added domulticast
 * 4/14/97      sohailm Added support to handle encrypted messages.
 *	4/20/97		andyco	group in group 
 * 4/24/97      sohailm Now we deliver secure player-player messages as DPSYS_SECUREMESSAGE 
 *                      system messages.
 *	5/8/97		andyco	fixed 5893 - incorrectly homing on forwardaddplayer.  changed
 *						NS_HandleEnumPlayers to pack on client_server. removed updatelist.
 *	5/8/97		myronth	Build StartSession system message
 * 05/12/97     sohailm Now we send the entire DPSECURITYDESC in PLAYERIDREPLY.
 *                      Added support to process DPSP_MSG_KEYEXCHANGE.
 *	5/17/97		myronth Build and handle SendChatMessage system messages
 *	5/17/97		kipo	Make sure the ghReplyProcessed is reset
 *	5/18/97		andyco	add validatedplay on debug builds
 *  5/18/97     sohailm BuildSecureSystem() was not reporting the correct message size (8647).
 *	5/19/97		andyco	put bandaid on SP_HandlePlayerMgmtMessage
 *  5/21/97     sohailm Added InternalHandleMessage().
 *                      Now we pass DPSEND_SIGNED and DPSEND_ENCRYPTED in the secure player message
 *                      flags instead of DPSECURE_SIGNED and DPSECURE_ENCRYPTED.
 *	5/21/97		myronth	Change to correct DPMSG_CHAT format	(#8642)
 *	5/23/97		andyco	session desc goes w/ nametable.  added dplayi_dplay_handlemulticast
 *						so we correctly  locally process multicast forwards
 *	5/27/97		kipo	Add player flags to CreateGroup/Player and DestroyGroup/Player
 *	5/29/97		andyco	removed EXECUTING_PENDING optimization - too much grief
 *	5/30/97		kipo	added DPPLAYER_LOCAL
 *  6/09/97     sohailm Renamed DPSP_MSG_ACCESSDENIED to DPSP_MSG_LOGONDENIED.
 *  6/10/97     kipo	Put ping and ping reply messages on pending queue.
 *  6/16/97     sohailm Updated calls to HandleAuthenticationReply() to take message size.
 *  6/23/97     sohailm Updated InternalHandleMessage() to check the flags on secure messages.
 *	7/30/97		myronth	Added use of dwReserved fields in StartSession message for
 *						standard lobby messaging to work correctly
 *  7/31/97		sohailm	Added peer-peer message security using multicast.
 *   8/4/97		andyco	added support for async add forward
 *	8/29/97		sohailm GPF in NS_DoAsyncAddForward when modem sp is loaded (bug #12459).
 *	10/21/97	myronth	Added support for hidden group flag
 *	10/29/97	myronth	Added BuildGroupOwnerChangedMessage and case statement for it
 *	11/5/97		myronth	Removed bogus (also unneeded) prototype
 *	11/19/97	myronth	Fixed VALID_DPLAY_GROUP macro (#12841)
 *	12/5/97		andyco	voice stuff
 *	12/29/97	myronth	Nametable corruption related fix -- don't queue msgs
 *						for remote stuff which doesn't affect the nametable
 *	12/30/97	sohailm	DPSYSMSG_SESSIONLOST does not cause player event to be set (#16141)
 *	1/5/97		myronth	Fixed error paths for client/server (#15891)
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/27/98		myronth	Delete remote players/groups on sessionlost (#15255)
 *  2/13/98     aarono  Added flag to internal destroy player calls for async
 *  3/19/98     aarono  Added prenotification of pending DELETEPLAYER messages
 *                      so the protocol can bail on ongoing sends to that player
 *	3/23/98     aarono  Now ADDFORWARD is spoofed from ADDFORWARDREQ
 *  3/31/98     aarono  backout ADDFORWARD spoof
 *  4/1/98      aarono  flag players that don't have nametable, don't send to them
 *  6/6/98      aarono  Fix for handling large loopback messages with protocol
 *  6/19/98 	aarono  add last ptr for message queues, makes insert
 *              	    constant time instead of O(n) where n is number
 *                	    of messages in queue.
 *  8/02/99		aarono  removed old voice support
 *  8/02/99		rodtoll voice support - added temporary voice message hook
 *  8/04/99     aarono  fixed voice group remove notify, added MIGRATION notify
 *  8/05/99     aarono  Moved voice over to DPMSG_VOICE
 *  8/10/99		rodtoll	Modified notify calls to release lock to prevent deadlocks
 *  9/09/99		rodtoll	Updated calls into voice message handler so they happen
 *						even if no client is active yet.  (For new retro launch procedure)
 * 11/02/99		rodtoll Fixes to support Bueg#11677 - Can't use lobby clients that don't hang around
 * 11/30/99     aarono  Fix Multicast Server Send with Protocol
 * 12/09/99		rodtoll	DoProtocolMulticast didn't have a return hr, added it.  
 * 02/08/00		aarono  Mill Bug 130398 leaking in SendAddForwardReply error case.
 * 04/07/00     rodtoll Fixed Bug #32179 - Registering > 1 interface
 * 04/07/00     aarono  Mill Bug 143823: Trap in HandleSessionLost fix bad assumption
 *                       about lock not being dropped in NukeXXX call. (not fixed in Mill/just DX8)
 * 06/26/00     aarono Manbug 36989 Players sometimes fail to join properly (get 1/2 joined)
 *                       added re-notification during simultaneous join CREATEPLAYERVERIFY
 * 08/03/2000	rodtoll	Bug #41475 - Leave locks before calling notification
 *
 ****************************************************************************/

// todo - send fail message on max players

#include "dplaypr.h"
#include "dpsecure.h"
#include "dpprot.h"

// #define this on to make DIE_PIGGY DEBUG_BREAK();
#undef DIE_PIG
  
// globals to hold buffer for enum players and new player id replies
LPBYTE gpRequestPlayerBuffer, gpEnumPlayersReplyBuffer;
LPVOID gpvEnumPlayersHeader;
BOOL gbWaitingForReply=FALSE;
BOOL gbWaitingForEnumReply=FALSE;

#undef DPF_MODNAME
#define DPF_MODNAME	"DoReply"

// called by PacketizeAndSend and ns_handlexxx	
HRESULT DoReply(LPDPLAYI_DPLAY this,LPBYTE pSendBuffer,DWORD dwMessageSize,
	LPVOID pvMessageHeader, DWORD dwReplyToVersion)
{
	DPSP_REPLYDATA rd;
	HRESULT hr;

	if(!dwReplyToVersion){

		if (!this->pSysPlayer)
		{
			DPF(1,"Reply - session not currently open - failing");
			return E_FAIL;
		}
		ASSERT(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR);
		ASSERT(!(this->dwFlags & DPLAYI_DPLAY_SESSIONLOST));
	} else {
		// doing reply for reliability (ACK) 
	}

	// do we need to packetize for reliability?
	if(this->dwFlags & DPLAYI_DPLAY_SPUNRELIABLE) // quick test
	{
		DWORD dwCommand;
		dwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)(pSendBuffer+this->dwSPHeaderSize));

		if(NeedsReliablePacketize(this, dwCommand, dwReplyToVersion, DPSEND_GUARANTEED)){
			DPF(3,"reply :: message needs reliable delivery - packetizing with reliablility");
			hr = PacketizeAndSendReliable(this,NULL,NULL,pSendBuffer,dwMessageSize,0,
				pvMessageHeader,TRUE);
			return hr;
		}
	}

//	ASSERT(!(this->dwFlags & DPLAYI_DPLAY_SESSIONLOST)); 
	
	// do we need to packetize for size?
	if (dwMessageSize > ((this->pProtocol)?(this->pProtocol->m_dwSPMaxGuaranteed):(this->dwSPMaxMessageGuaranteed)))
	{
		DPF(3,"reply :: message too big - packetizing");
		hr = PacketizeAndSend(this,NULL,NULL,pSendBuffer,dwMessageSize,0,
			pvMessageHeader,TRUE);
		return hr;
	}

    // call sp
    if (this->pcbSPCallbacks->Reply) 
    {
		rd.lpSPMessageHeader = pvMessageHeader;
		rd.lpMessage = pSendBuffer;
		rd.dwMessageSize = dwMessageSize;
		if(this->pSysPlayer){ 
	        rd.idNameServer = this->pSysPlayer->dwID;
	    } else {
			// we need to reply before we know the nameserver for ACKs on reliability.
	    	rd.idNameServer = 0;
	    }
    	rd.lpISP = this->pISP;

	 	hr = CALLSP(this->pcbSPCallbacks->Reply,&rd);    	
    }
	else 
	{
		hr = E_FAIL;
		ASSERT(FALSE); // no callback?
	}

	if (DPERR_SESSIONLOST == hr)
	{
		DPF_ERR(" got session lost back from SP ");
		hr = HandleSessionLost(this);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}

	return hr;

} // DoReply

// When running the directplay protocol, we can't just send the message addressed from 
// a remote player.  This is because the protocol's internal structures for sending to/from
// that player don't exist on this machine.  Instead we wrap the message in a system message
// DPSP_MSG_MULTICASTDELIVER and crack it on the receiver.
HRESULT DoProtocolMulticast(LPDPLAYI_DPLAY this,LPMSG_ASK4MULTICAST pmcast,DWORD dwBufferSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPBYTE pmsg; // multicast message + header
	HRESULT hr;
	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_GROUP pGroupTo;
	DWORD dwCommand = 0;
	DWORD dwVersion;
	DWORD dwMessageSize;
	LPBYTE pbForward;
	DWORD dwForwardSize;

	pmsg = (LPBYTE)pmcast + pmcast->dwMessageOffset;

	DPF(4,"multicast server routing from player id = %d to group id = %d\n",
		pmcast->idPlayerFrom,pmcast->idGroupTo);
	
	// the embedded message is the size of the total message - the size of the ask4mcast header
	dwMessageSize = dwBufferSize - pmcast->dwMessageOffset;
    hr = GetMessageCommand(this, (LPBYTE)pmsg, dwMessageSize, &dwCommand, &dwVersion);

	pPlayerFrom = PlayerFromID(this,pmcast->idPlayerFrom);
	if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
	{
		DPF(0,"bad player from id = %d\n",pmcast->idPlayerFrom);
		return DPERR_INVALIDPLAYER;
	}
	pGroupTo = GroupFromID(this,pmcast->idGroupTo);
	if (!VALID_DPLAY_GROUP(pGroupTo)) 
	{
		DPF(0,"bad groupto id = %d\n",pmcast->idGroupTo);
		return DPERR_INVALIDGROUP;
	}

	if (DPSP_MSG_CREATEPLAYER == dwCommand)
	{
		// this is a SUPER-HACK!
		// but, it's the only way to get the pvSPHeader through to unpack player without
		// gutting dplay.
		// this makes sure player gets created locally w/ correct header
		// below, this createplayer message will come back to our sysplayer, who
		// will find the player already in the list, and ignore it. sigh. 
		// but, it works...andyco 4/11/97.
		UnpackPlayerAndGroupList(this,(LPBYTE) pmsg + 
			((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,1,0,pvSPHeader);
	}

	// change the message to MULTICASTDELIVERY
	SET_MESSAGE_COMMAND(pmcast,DPSP_MSG_MULTICASTDELIVERY);
	
	// sp header?
	if (this->dwSPHeaderSize)
	{
		// need to add space at the beginning for sp header		
		dwForwardSize = dwBufferSize + this->dwSPHeaderSize;
		pbForward = DPMEM_ALLOC(dwForwardSize);
		if (!pbForward)
		{
			DPF_ERR("could not send multicast - out of memory");
			return DPERR_OUTOFMEMORY;	
		}	 
		memcpy(pbForward + this->dwSPHeaderSize,(LPBYTE)pmcast,dwBufferSize);

		// put us in "multicast" mode.  when this message comes back to our sp, it will 
		// come in as if it were generated locally.  so, in this mode we know we need 
		// to process the message
		this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
		hr = SendGroupMessage(this,this->pSysPlayer,pGroupTo,dwSendFlags|DPSEND_ASYNC,pbForward,dwForwardSize,FALSE);
		this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
					
		DPMEM_FREE(pbForward);
	}
	else 
	{
		// no need for header - send out received message
		this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
		hr = SendGroupMessage(this,this->pSysPlayer,pGroupTo,dwSendFlags|DPSEND_ASYNC,pmsg,dwMessageSize,FALSE);
		this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
	}

	if (FAILED(hr))
	{
		DPF(0,"multicast server - could not route from player id = %d to group id = %d hr = 0x%08lx\n",
			pmcast->idPlayerFrom,pmcast->idGroupTo,hr);
	}
	
	return hr;	
	
}

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_HANDLER"
// a client wants us to send a multicast for them
HRESULT DoMulticast(LPDPLAYI_DPLAY this,LPMSG_ASK4MULTICAST pmcast,DWORD dwBufferSize,
	LPVOID pvSPHeader,DWORD dwSendFlags)
{
	LPBYTE pmsg; // multicast message + header
	HRESULT hr;
	LPDPLAYI_PLAYER pPlayerFrom;
	LPDPLAYI_GROUP pGroupTo;
	DWORD dwCommand = 0;
	DWORD dwVersion;
	DWORD dwMessageSize;
	
	ASSERT(this->pSysPlayer);
	ASSERT(this->pSysPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER);
	ASSERT(this->lpsdDesc);
	ASSERT(this->lpsdDesc->dwFlags & DPSESSION_MULTICASTSERVER);

	if(this->dwFlags & DPLAYI_DPLAY_PROTOCOL){
		return DoProtocolMulticast(	this, pmcast, dwBufferSize, pvSPHeader, dwSendFlags);
	}
	
	pmsg = (LPBYTE)pmcast + pmcast->dwMessageOffset;

	DPF(4,"multicast server routing from player id = %d to group id = %d\n",
		pmcast->idPlayerFrom,pmcast->idGroupTo);
	
	// the embedded message is the size of the total message - the size of the ask4mcast header
	dwMessageSize = dwBufferSize - pmcast->dwMessageOffset;
    hr = GetMessageCommand(this, (LPBYTE)pmsg, dwMessageSize, &dwCommand, &dwVersion);
	ASSERT(SUCCEEDED(hr)); // this should not fail

	if (DPSP_MSG_PLAYERMESSAGE == dwCommand)	
	{
		// need to drop the locks here - send expects to be able to go into pending
		// mode...
		LEAVE_DPLAY();
		
		// call send - it will push the bits through the wire for us
		hr = DP_Send((LPDIRECTPLAY)this->pInterfaces,pmcast->idPlayerFrom,
			pmcast->idGroupTo,dwSendFlags,pmsg,dwMessageSize);
		
		ENTER_DPLAY();
	}
	else // it's a system message
	{
		LPBYTE pbForward;
		DWORD dwForwardSize;

		// multicast system messages must be signed in a secure session
		if (SECURE_SERVER(this))
		{
			if (!(dwSendFlags & DPSEND_SIGNED))
			{
				DPF_ERR("Warning! unsecure multicast message arrived - dropping message");
				return DPERR_GENERIC;
			}
		}

		pPlayerFrom = PlayerFromID(this,pmcast->idPlayerFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF(0,"bad player from id = %d\n",pmcast->idPlayerFrom);
			return DPERR_INVALIDPLAYER;
		}
		pGroupTo = GroupFromID(this,pmcast->idGroupTo);
		if (!VALID_DPLAY_GROUP(pGroupTo)) 
		{
			DPF(0,"bad groupto id = %d\n",pmcast->idGroupTo);
			return DPERR_INVALIDGROUP;
		}
    
		if (DPSP_MSG_CREATEPLAYER == dwCommand)
		{
			// this is a SUPER-HACK!
			// but, it's the only way to get the pvSPHeader through to unpack player without
			// gutting dplay.
			// this makes sure player gets created locally w/ correct header
			// below, this createplayer message will come back to our sysplayer, who
			// will find the player already in the list, and ignore it. sigh. 
			// but, it works...andyco 4/11/97.
			UnpackPlayerAndGroupList(this,(LPBYTE) pmsg + 
				((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,1,0,pvSPHeader);
		}
		
		// sp header?
		if (this->dwSPHeaderSize)
		{
			// need to add space at the beginning for sp header		
			dwForwardSize = dwMessageSize + this->dwSPHeaderSize;
			pbForward = DPMEM_ALLOC(dwForwardSize);
			if (!pbForward)
			{
				DPF_ERR("could not send multicast - out of memory");
				return DPERR_OUTOFMEMORY;	
			}	 
			memcpy(pbForward + this->dwSPHeaderSize,(LPBYTE)pmsg,dwMessageSize);
			
			// put us in "multicast" mode.  when this message comes back to our sp, it will 
			// come in as if it were generated locally.  so, in this mode we know we need 
			// to process the message
			this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
			hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwSendFlags|DPSEND_ASYNC,pbForward,dwForwardSize,FALSE);
			this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
						
			DPMEM_FREE(pbForward);
		}
		else 
		{
			// no need for header - send out received message
			this->dwFlags |= DPLAYI_DPLAY_HANDLEMULTICAST;
			hr = SendGroupMessage(this,pPlayerFrom,pGroupTo,dwSendFlags|DPSEND_ASYNC,pmsg,dwMessageSize,FALSE);
			this->dwFlags &= ~DPLAYI_DPLAY_HANDLEMULTICAST;
		}
		
	} // fPlayerMessage
		
	if (FAILED(hr))
	{
		DPF(0,"multicast server - could not route from player id = %d to group id = %d hr = 0x%08lx\n",
			pmcast->idPlayerFrom,pmcast->idGroupTo,hr);
	}
	
	return hr;	
	
} // DoMulticast

//
// put a session lost message in players message q 
// called by HandleSessionLost
HRESULT QSessionLost(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer)
{
	LPMESSAGENODE pmsn; // we'll add this node to iplay's list of nodes		
	LPDPMSG_GENERIC pmsg;	
	
	// alloc the messagenode 
	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
	if (!pmsn)
	{
		DPF_ERR("could not alloc space for session lost message node");
		return E_OUTOFMEMORY;
	}
	// alloc the actual message	
	pmsg = DPMEM_ALLOC(sizeof(DPMSG_GENERIC));
	if (!pmsg)
	{
		DPF_ERR("could not alloc space for session lost message");
		return E_OUTOFMEMORY;
	}

	// set up the message	
	pmsg->dwType = DPSYS_SESSIONLOST;

	// set up the messagenode
	pmsn->idTo = pPlayer->dwID; 
	pmsn->pMessage = pmsg;
	pmsn->dwMessageSize = sizeof(DPMSG_GENERIC);

	this->nMessages++;

	// stick this bad news on the front of the list
	pmsn->pNextMessage = this->pMessageList;
	this->pMessageList = pmsn;
	if(!this->pLastMessage){
		this->pLastMessage=pmsn;
	}
	
	ASSERT(pPlayer);

	// if player has event, trigger it
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	return DP_OK;
		
}  // QSessionLost

// 
// we got either a DPSP_MSG_YOUAREDEAD off the wire, 
// or a DPERR_SESSIONLOST from a send or reply
// put a session lost message in all local players q's, print a useful
// debug message
//
HRESULT HandleSessionLost(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer, pNextPlayer;
	LPDPLAYI_GROUP	pGroup, pNextGroup;
	HRESULT hr;

	if (!this->lpsdDesc)
	{
		DPF_ERR("handlesession lost - no session");
		return DP_OK;
	}

	// Notify voice system
	// Leave locks to prevent deadlock
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		LEAVE_DPLAY();

		DVoiceNotify( this, DVEVENT_STOPSESSION, 0, 0, DVTRANSPORT_OBJECTTYPE_BOTH );		
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}
	
	DPF(0,"\n\n");
	DPF(0," DPLAY SESSION HAS BEEN LOST.  ALL ATTEMPTS TO SEND TO REMOTE PLAYERS");
	DPF(0," WILL FAIL.  THIS CAN BE CAUSED BY E.G. MODEM DROPPING, OR NETWORK CONNECTION");
	DPF(0," TIMING OUT.  HAVE A NICE DAY\n\n");
	
	this->dwFlags |= DPLAYI_DPLAY_SESSIONLOST;
	
	pPlayer = this->pPlayers;
	while (pPlayer)
	{
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			hr = QSessionLost(this,pPlayer);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
		}
		
		pPlayer = pPlayer->pNextPlayer;
	}

	// Now walk the list of players and delete all of the remote players
	pPlayer = this->pPlayers;
	while(pPlayer)
	{
		// Save the next player
		pNextPlayer = pPlayer->pNextPlayer;

		// If the player is a non-system player & they are remote, delete them
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			NukeNameTableItem(this, pPlayer);
		}

		// Move to the next player
		pPlayer = pNextPlayer;
	}

	// Now walk the list of groups and delete all of the remote groups

ScanGroups:

	pGroup = this->pGroups;
	while(pGroup)
	{
		// Save the next group
		pNextGroup = pGroup->pNextGroup;

		// If the group is remote, delete it
		if (!(pGroup->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			NukeNameTableItem(this, (LPDPLAYI_PLAYER)pGroup);
			// Nuke might drop lock, need to go back to beginning and re-scan
			goto ScanGroups;
		}

		// Move to the next group
		pGroup = pNextGroup;
	}

ScanPlayers:
	// Now walk the list of players and delete all of the remote system players
	pPlayer = this->pPlayers;
	while(pPlayer)
	{
		// Save the next player
		pNextPlayer = pPlayer->pNextPlayer;

		// Now delete the remaining remote system players
		if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			NukeNameTableItem(this, pPlayer);
			// Nuke might drop lock, need to go back to beginning and re-scan
			goto ScanPlayers;
		}

		// Move to the next player
		pPlayer = pNextPlayer;
	}

	return DP_OK;

} // HandleSessionLost	

// figure out how many groupws w/ shortucts there are in the nametable
DWORD CountShortcuts(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_GROUP pGroup = this->pGroups;
	LPDPLAYI_SUBGROUP pSubgroup;
	BOOL bShortcut;
	DWORD count = 0;  // # of groups w/ subgroups
	 	
	while (pGroup)
	{
		bShortcut = FALSE;
		pSubgroup = pGroup->pSubgroups;
		
		while (pSubgroup && !bShortcut)
		{
			if (pSubgroup->dwFlags & DPGROUP_SHORTCUT)
			{
				// got one ! go onto next group...
				bShortcut = TRUE;
				count++;
			}
			else
			{
				pSubgroup = pSubgroup->pNextSubgroup;				
			}
		} // pSubgroup
		
		pGroup = pGroup->pNextGroup;
	} // pGroup
	
	DPF(3,"found %d groups w/ shortcuts in nametable",count);
	return count;
	
} // CountShortcuts

/*
 **  NS_HandleEnumPlayers	   
 *
 *  CALLED BY: handlmessage
 *
 *  PARAMETERS:  pvSPHeader - header from SP
 *				dpidFrom - security id from requestor
 *				dwVersion - version of requestor
 *
 *  DESCRIPTION:  checks security if necessary. if dwVersion >= DX5, and it's 
 *					not client server, superpacs nametable, else it just packs nametable
 *					and sends it to requestor.
 *
 */
HRESULT NS_HandleEnumPlayers(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DPID dpidFrom,DWORD dwVersion)
{
    HRESULT hr=DP_OK;
    MSG_ENUMPLAYERSREPLY epm;
    LPBYTE pBuffer=NULL,pBufferIndex;
	DWORD dwMessageSize;
    BOOL fSuperPac;
	UINT nNameLength,nPasswordLength;
	
	if (dwVersion >= DPSP_MSG_DX5VERSION && !CLIENT_SERVER(this)) fSuperPac = TRUE;
	else fSuperPac = FALSE;
	
	ASSERT(this);
	ASSERT(this->lpsdDesc);
	ASSERT(this->pSysPlayer);
	
	// call pack w/ null buffer to figure out how big
	if (fSuperPac)
	{
		hr =  SuperPackPlayerAndGroupList( this, NULL,&dwMessageSize) ;
	}
	else 
	{
		hr =  PackPlayerAndGroupList( this, NULL,&dwMessageSize) ;
	}
    if (FAILED(hr)) 
    {
    	ASSERT(FALSE);
		return hr;
    }

	// session name goes w/ nametable
	nNameLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);
#ifdef SEND_PASSWORD	
	// todo - Sohail - need to encrypt this message before we can send
	// password.  for now, we just don't send it
	nPasswordLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszPassword);
#else 
	nPasswordLength =  0;	
#endif 
	
	// message size + blob size + session name
	dwMessageSize += GET_MESSAGE_SIZE(this,MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2) 
		+ nNameLength + nPasswordLength;

	DPF(2,"sending nametable - total size = %d\n",dwMessageSize);

    pBuffer = DPMEM_ALLOC(dwMessageSize);
    if (!pBuffer) 
    {
    	DPF_ERR("could not send player list - out of memory");
        return E_OUTOFMEMORY;
    }

    // epm is the message we want the sp to send
	SET_MESSAGE_HDR(&epm);

	if (fSuperPac)
	{
		SET_MESSAGE_COMMAND(&epm,DPSP_MSG_SUPERENUMPLAYERSREPLY);		
		epm.nShortcuts = CountShortcuts(this);
	}
	else 
	{
		SET_MESSAGE_COMMAND(&epm,DPSP_MSG_ENUMPLAYERSREPLY);
	}

	if (CLIENT_SERVER(this))
	{
		// pack will only give out app server + sysplayer
		if (this->pServerPlayer) epm.nPlayers =  2;  // nameserver + server player
		else epm.nPlayers =  1; // nameserver only
		epm.nGroups = 0;
	}
	else 
	{
	    epm.nPlayers =  this->nPlayers;
		epm.nGroups = this->nGroups;
		// if we have a sysgroup, we don't send that one...
		if (this->pSysGroup)
		{
			epm.nGroups--;
		}
	}		
	
	// put the session desc offset on
	epm.dwDescOffset = sizeof(MSG_ENUMPLAYERSREPLY);
	// name offsets
	if (nNameLength) epm.dwNameOffset = sizeof(MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2);
	else epm.dwNameOffset = 0;
	// password offsets
	if (nPasswordLength) epm.dwPasswordOffset = sizeof(MSG_ENUMPLAYERSREPLY) 
		+ sizeof(DPSESSIONDESC2) + nNameLength;
	else epm.dwPasswordOffset = 0;

	// the packed structures follow the session name
	epm.dwPackedOffset = sizeof(MSG_ENUMPLAYERSREPLY) + sizeof(DPSESSIONDESC2) 
		+ nNameLength + nPasswordLength;

    // copy the fixed message into  the buffer
    memcpy(pBuffer + this->dwSPHeaderSize,(LPBYTE)&epm,sizeof(MSG_ENUMPLAYERSREPLY));

	// now, pack up the variable size stuff
	pBufferIndex = (LPBYTE)pBuffer + this->dwSPHeaderSize + sizeof(MSG_ENUMPLAYERSREPLY);
	
	// put the session desc on
	memcpy(pBufferIndex,this->lpsdDesc,sizeof(DPSESSIONDESC2));

	// set string pointers to NULL - they must be set at client
	((LPDPSESSIONDESC2)pBufferIndex)->lpszPassword = NULL;
	((LPDPSESSIONDESC2)pBufferIndex)->lpszSessionName = NULL;

	pBufferIndex += sizeof(DPSESSIONDESC2);
	
	// next, name
	if (nNameLength) 
	{
		memcpy(pBufferIndex,this->lpsdDesc->lpszSessionName,nNameLength);
		pBufferIndex += nNameLength;
	}

	// next, password
	if (nPasswordLength) 
	{
		memcpy(pBufferIndex,this->lpsdDesc->lpszPassword,nPasswordLength);
		pBufferIndex += nPasswordLength;
	}

	// pack the players behind the password
	if (fSuperPac)
	{
		hr = SuperPackPlayerAndGroupList( this, pBufferIndex ,&dwMessageSize) ;
	}
	else 
	{
		hr = PackPlayerAndGroupList( this, pBufferIndex, &dwMessageSize) ;
	}			
	if (FAILED(hr)) 
	{
		ASSERT(FALSE);
		DPMEM_FREE(pBuffer);
		return hr;
	}

    // if session is secure, use send
    if (this->lpsdDesc && (this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER))
    {
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
            ASSERT(FALSE);  // should never happen because we just verified the sig
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pBuffer,dwMessageSize,DPSEND_SYSMESS,FALSE);
    }
    else
    {
    	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);
    }

	DPMEM_FREE(pBuffer);
    return hr;

} // handle enum players

// sends an error response to an addforward message
HRESULT NS_SendAddForwardReply(LPDPLAYI_DPLAY this, HRESULT hResult, LPVOID pvSPHeader, DPID dpidFrom, DWORD dwVersion)
{
    HRESULT hr;
    DWORD dwBufferSize;
    LPBYTE pSendBuffer;
    LPMSG_ADDFORWARDREPLY pReply;

    // 
    // Calculate buffer size needed for response
    //
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_ADDFORWARDREPLY);
    //
    // Allocate memory for the buffer
    //
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
        DPF_ERR("could not allocate memory for response - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pReply = (LPMSG_ADDFORWARDREPLY) (pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pReply);
    SET_MESSAGE_COMMAND(pReply, DPSP_MSG_ADDFORWARDREPLY);
    pReply->hResult = hResult;

	if (dpidFrom)
	{
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
			hr = DPERR_INVALIDPLAYER;
			goto err_exit;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwBufferSize,
            DPSEND_SYSMESS,FALSE);
	}
	else
	{
		hr = DoReply(this, pSendBuffer, dwBufferSize, pvSPHeader, dwVersion);
	}

err_exit:
    //
    // Free up the buffer
    //
    DPMEM_FREE(pSendBuffer);

    return hr;
} // NS_SendAddForwardReply

// this function verifies if the client can join the session
// also verifies TickCount on session, some work here is for interop with previous beta versions of DX6
HRESULT NS_IsOKToJoin(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwBufferSize, DWORD dwJoinerVersion)
{
	DWORD *pTickCount;
	BOOL  fCheckTickCount=TRUE;

    // if session has a password and it is not a zero-length string
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        LPWSTR lpszPassword;

		DPF(5,"Verifying Password\n");

        if (!((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset)
        {
            DPF(0, "nameserver denying access - no password specified");
            return DPERR_INVALIDPASSWORD;
        }

        // point to the password in the message
        lpszPassword = (LPWSTR) (pReceiveBuffer + ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset);

        // match passwords
        if (WSTRCMP(this->lpsdDesc->lpszPassword, lpszPassword))
        {
            DPF(0, "nameserver denying access - password doesn't match");
            return DPERR_INVALIDPASSWORD;
	    }
	    // tick count after password
	    pTickCount=(PUINT)(lpszPassword+WSTRLEN(lpszPassword));

		DPF(5,"pPassword = %x, pTickCount= %x\n",lpszPassword, pTickCount);
	    
    } else {
    	// expect NULL password followed by TickCount
    	if(((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPasswordOffset){
	    	pTickCount=(PUINT)(pReceiveBuffer + dwBufferSize - 4);
			DPF(5,"Didn't verify password, pTickCount= %x\n", pTickCount);
	    } else {
	    	fCheckTickCount=FALSE;
	    }

    }

	if(fCheckTickCount && dwJoinerVersion >= DPSP_MSG_DX6VERSION){
		// only verify DX6 or later and only if the buffer is big enough to have the tickcount.
		if(pReceiveBuffer+dwBufferSize >= (PUCHAR)(pTickCount+1)){
			if(this->lpsdDesc->dwReserved1 != *pTickCount){
				DPF(0,"Client trying to join old session, returning DPERR_NONEWPLAYERS\n");
				return DPERR_NONEWPLAYERS;
			}
		}
	}

    // verify permissions based on player flags
    if (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)
    {
	    DPF(0,"nameserver denying access - session is not allowing join");
	    return DPERR_NONEWPLAYERS;
    }

    if (this->lpsdDesc->dwMaxPlayers && 
        (this->lpsdDesc->dwCurrentPlayers >= this->lpsdDesc->dwMaxPlayers))
    {
        DPF(0,"nameserver denying access - session maxed out");
        return DPERR_NONEWPLAYERS;
    }

    return DP_OK;

} // IsOKToJoin

HRESULT FreeAddForwardNode(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind)
{
	BOOL bFound = FALSE;
	LPADDFORWARDNODE pnodeSearch = this->pAddForwardList,pnodePrev = NULL;
	
	// first, find the node
	while (pnodeSearch && !bFound)
	{
		if (pnodeSearch == pnodeFind) bFound = TRUE;
		else 
		{
			pnodePrev = pnodeSearch;
			pnodeSearch = pnodeSearch->pNextNode;
		}
	}
	
	if (!bFound)	
	{
		ASSERT(bFound); // false!
		// BUMMER! this is badbadbad
		return E_FAIL; // good ol' E_FAIL
	}
	
	// remove node from list
	if (pnodePrev) 
	{
		// remove from middle
		pnodePrev->pNextNode = pnodeSearch->pNextNode; 
	}
	else
	{
		// remove from head
		ASSERT(this->pAddForwardList == pnodeSearch);
		this->pAddForwardList = this->pAddForwardList->pNextNode;
	} 
	
	// free up the node
	if (VALID_SPHEADER(pnodeSearch->pvSPHeader)) DPMEM_FREE(pnodeSearch->pvSPHeader);
	DPMEM_FREE(pnodeSearch);
	
	return DP_OK;
		
} // FreeAddForwardNode

BOOL IsAddForwardNodeOnList(LPDPLAYI_DPLAY this, LPADDFORWARDNODE pnodeFind)
{
	LPADDFORWARDNODE pnodeSearch = this->pAddForwardList;
	
	while(pnodeSearch){
		if(pnodeSearch == pnodeFind){
			return TRUE;
		}
		pnodeSearch=pnodeSearch->pNextNode;
	}
	return FALSE;
}

// start up an async add forward
HRESULT NS_DoAsyncAddForward(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayer,LPVOID pvSPHeader,
	 DPID dpidFrom,DWORD dwVersion)
{
	HRESULT hr;
	LPADDFORWARDNODE pnode;
	DWORD dwTimeout; // how long we wait before giving up on ack's
	DWORD dwPlayerID;
	
	pnode = DPMEM_ALLOC(sizeof(ADDFORWARDNODE));
	if (!pnode)
	{
		DPF_ERR("could not start async add forward - out of memory!!");
		return DPERR_OUTOFMEMORY;
	}
	
	// store the spheader for when we eventually send the nametable
	if (this->dwSPHeaderSize)
	{
		pnode->pvSPHeader = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pnode->pvSPHeader)
		{
			DPF_ERR("could not start async add forward - out of memory!!");
			DPMEM_FREE(pnode);
			return DPERR_OUTOFMEMORY;
		}
		if (pvSPHeader)
		{
			memcpy(pnode->pvSPHeader,pvSPHeader,this->dwSPHeaderSize);
		}
	}
				
	// stick new node on the front of the list
	pnode->pNextNode = this->pAddForwardList;
	this->pAddForwardList = pnode;

	dwPlayerID=pPlayer->dwID;
	
	pnode->dwIDSysPlayer = pPlayer->dwIDSysPlayer;
	pnode->dpidFrom = dpidFrom;
	pnode->dwVersion = dwVersion;

	if(pPlayer->dwIDSysPlayer == dwPlayerID){
		DPF(6,"Player x%x doesn't have nametable, sends will fail idFrom=%x.\n",pPlayer->dwID, dpidFrom);
		pPlayer->dwFlags |= DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE;
	}	
	
	hr = SendAsyncAddForward(this,pPlayer,pnode);
	if (FAILED(hr))	
	{
		ASSERT(FALSE);
	}

	// pnode could be invalid (may have already got ACKs and cleared it out),
	// so we need to make sure it is still in the nodelist (i.e. valid).

	if(!IsAddForwardNodeOnList(this,pnode)){
		goto EXIT;
	}
	
	// if we don't need any ack's, send the nametable...
	if (0 == pnode->nAcksReq)
	{
		pPlayer=PlayerFromID(this,dwPlayerID);
		if(pPlayer->dwIDSysPlayer == dwPlayerID){
			pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
		}	
		
	    hr = NS_HandleEnumPlayers(this, pnode->pvSPHeader, pnode->dpidFrom,pnode->dwVersion);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
		
		hr = FreeAddForwardNode(this,pnode);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	else 
	{
		// get the worker thread to keep on eye on this node.  so, if a client doesn't ack, eventually
		// we give up and just send the new client the nametable...

		// we multiply GetDefaultTimeout * the number of req's we sent, since we have to wait
		// for a reply from each of them 
		dwTimeout = DP_NAMETABLE_SCALE * GetDefaultTimeout(this,TRUE);
		if(dwTimeout > 15000){
			dwTimeout = 15000;
		}
		DPF(3,"waiting for add forward.  nAcksReq = %d, timeout = %d\n",pnode->nAcksReq,dwTimeout);
		// after this tick count, we give up + send the nametable
		pnode->dwGiveUpTickCount = GetTickCount() + dwTimeout; 

		// StartDPlayThread will either start the thread, or signal it
		// that something new is afoot
		StartDPlayThread(this,FALSE);
	}
	
EXIT:			
	return DP_OK;
	
} // NS_DoAsyncAddForward

// a player is going to join the game.  they want the name server to tell the world they exist
// so they will be able to process any messages that occur between when we package the nametable
// and they receive it
HRESULT NS_HandleAddForwardRequest(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,DWORD dwBufferSize,
	LPVOID pvSPHeader, DPID dpidFrom)
{
	HRESULT hr;
    DWORD dwVersion;
    LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
	LPDPLAYI_PLAYER pPlayer = NULL; // our version of new player
	DPID id;
		
    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

    if (dwVersion >= DPSP_MSG_DX5VERSION)
    {
        // verify client can join the session
        hr = NS_IsOKToJoin(this, pReceiveBuffer, dwBufferSize, dwVersion);
        if (FAILED(hr))
        {
        	if (this->dwPlayerReservations > 0)
        		this->dwPlayerReservations--;
			goto ERROR_EXIT;
        }
    } // dwVersion 


	// reset the command to create player 
	SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_CREATEPLAYER);

	// get the new player out of the message  - note we can't let sendsystemmessage do this
	// for us, since we can't get the correct sp header if we do it that way
	UnpackPlayerAndGroupList(this,pReceiveBuffer + 
		((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwCreateOffset,1,0,pvSPHeader);

	// tell the world about the new player		
	// note - we can't just forward the message we received, since the player would be "homed" wrong
	// instead, we pack up our version of the player, which has the correct net address set
	// and send that to the world
	id = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;
	pPlayer = PlayerFromID(this,id);
	if (!VALID_DPLAY_PLAYER(pPlayer))
	{
		ASSERT(FALSE);
		hr = E_FAIL;
		goto ERROR_EXIT;
	}

	// if all clients in the game can handle the async addforward, do that
	// 
	if (this->dwMinVersion >= DPSP_MSG_ASYNCADDFORWARD)
	{
		hr = NS_DoAsyncAddForward(this,pPlayer,pvSPHeader,dpidFrom, dwVersion);
		if (FAILED(hr))
		{
			goto ERROR_EXIT;
		}
	}
	else
	{
		// else we have to do it the old way
		// there is a race condition which could cause simultaneous joins bugs...
		hr = SendCreateMessage( this, pPlayer,TRUE, NULL);	
		if (FAILED(hr))
		{
			goto ERROR_EXIT;
		}
		
	    // from DPSP_MSG_AUTONAMETABLE onwards, nameserver will automatically respond with the nametable if client
	    // is dx5 or greater
	    if (dwVersion >= DPSP_MSG_AUTONAMETABLE)
	    {
	        hr = NS_HandleEnumPlayers(this, pvSPHeader, dpidFrom,dwVersion);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
	    }
		
	}

	return DP_OK;

ERROR_EXIT:

	DPF_ERRVAL("could not process add forward - hr = 0x%08lx\n",hr);

    hr = NS_SendAddForwardReply(this,hr,pvSPHeader,dpidFrom, dwVersion);
    if (FAILED(hr))
    {
       // if this happens, client won't get a response and will timeout
	    DPF(0, "Couldn't send access denied message: hr = 0x%08x", hr);
    }

    // remove id from nametable
    if(pPlayer){
    	NukeNameTableItem(this, pPlayer);
    } else {
	    hr = FreeNameTableEntry(this, ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	}    
    if (FAILED(hr))
    {
	    DPF(0, "Couldn't delete nametable entry for %d: hr = 0x%08x",
            ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID, hr);
    }
	
	return hr;
	
} // NS_HandleAddForwardRequest

// we got an addforward from the nameserver.  send an ack, then unpack the player
HRESULT  SP_HandleAddForward(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	LPVOID pvSPHeader,DPID dpidFrom, DWORD dwVersion)
{
    HRESULT hr;
    DWORD dwBufferSize;
    LPBYTE pSendBuffer;
	LPMSG_ADDFORWARDACK pAck;
	LPMSG_PLAYERMGMTMESSAGE pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;

    DPF(2,"got add forward announcment for id = %d",pmsg->dwPlayerID); 
	
    dwBufferSize = GET_MESSAGE_SIZE(this,MSG_ADDFORWARDACK);
    pSendBuffer = DPMEM_ALLOC(dwBufferSize);
    if (NULL == pSendBuffer) 
    {
        DPF_ERR("could not allocate memory for addforward ack - out of memory");
        return DPERR_OUTOFMEMORY;
    }

    pAck = (LPMSG_ADDFORWARDACK) (pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pAck);
    SET_MESSAGE_COMMAND(pAck, DPSP_MSG_ADDFORWARDACK);
    pAck->dwID = pmsg->dwPlayerID;

	if (dpidFrom)
	{
        LPDPLAYI_PLAYER pPlayerTo;

		pPlayerTo = PlayerFromID(this,dpidFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerTo)) 
		{
			DPF_ERR("bad player id!!");
			return DPERR_INVALIDPLAYER;
		}
        hr = SendDPMessage(this,this->pSysPlayer,pPlayerTo,pSendBuffer,dwBufferSize,
            DPSEND_GUARANTEED | DPSEND_ASYNC,FALSE);
	}
	else
	{
		hr = DoReply(this, pSendBuffer, dwBufferSize, pvSPHeader,dwVersion);
	}
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

    //
    // Free up the buffer
    //
    DPMEM_FREE(pSendBuffer);

	// finally, unpack the new player by resetting DPMSG_ADDFORWARD to DPMSG_CREATEPLAYER
	// and calling handleplayermgmt
    SET_MESSAGE_COMMAND(pmsg, DPSP_MSG_CREATEPLAYER);
	hr = SP_HandlePlayerMgmt(this->pSysPlayer,pReceiveBuffer,dwBufferSize,pvSPHeader);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
	
	return DP_OK;
	
} // SP_HandleAddForward

// we got an ack for one of our addforwad's
HRESULT NS_HandleAddForwardACK(LPDPLAYI_DPLAY this,LPMSG_ADDFORWARDACK pAck)
{
	HRESULT hr;
	BOOL bFound = FALSE;
	LPADDFORWARDNODE pnode = this->pAddForwardList;
	LPDPLAYI_PLAYER pPlayer;
	
	// first, find the node
	while (pnode && !bFound)
	{
		if (pnode->dwIDSysPlayer == pAck->dwID) bFound = TRUE;
		else pnode = pnode->pNextNode;
	}
	
	if (!bFound)	
	{
		// it's possible we gave up waiting on this ack, and just sent the nametable.
		return DP_OK;
	}

	// bump the ack count
	pnode->nAcksRecv++;

    DPF(2,"got add forward ack # %d of %d required for player id = %d",pnode->nAcksRecv,pnode->nAcksReq,pAck->dwID); 
	
	if (pnode->nAcksRecv != pnode->nAcksReq) return DP_OK;
	
	// else, we got 'em all!!
	// send the nametable, and free up the node
	pPlayer=PlayerFromID(this, pnode->dwIDSysPlayer);
	if(pPlayer){
		pPlayer->dwFlags &= ~(DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE);
	}
    hr = NS_HandleEnumPlayers(this, pnode->pvSPHeader, pnode->dpidFrom,pnode->dwVersion);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	hr = FreeAddForwardNode(this,pnode);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}
	
	return DP_OK;	
		
	
} // NS_HandleAddForwardACK

HRESULT NS_HandleEnumSessions(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,LPBYTE pReceiveBuffer, DWORD dwSendFlags)
{
    HRESULT hr;
    LPMSG_ENUMSESSIONSREPLY perm; 
    LPMSG_ENUMSESSIONS pEnumRequest = (LPMSG_ENUMSESSIONS)pReceiveBuffer;
    DWORD dwMessageSize;
	LPBYTE pIndex;
	UINT nNameLength;
	LPBYTE pBuffer;
    DWORD dwVersion;
    LPWSTR lpszPassword;

	ASSERT(this);
	ASSERT(this->lpsdDesc);
    ASSERT(pReceiveBuffer);

	// check if they specified a guid
	if (!IsEqualGUID(&(pEnumRequest->guidApplication),&GUID_NULL))  // did they specify a guid?
	{
		// if they specified one, and it doesn't match, bail
		if (!IsEqualGUID(&(pEnumRequest->guidApplication),&(this->lpsdDesc->guidApplication))) 
		{
            DPF(2, "nameserver not responding - guid doesn't match");
			return FALSE;
		}
	}

    dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

	// make sure the password on the received buffer matches our password
	// only check if they have a password, and it's not just the null terminator
    if ((this->lpsdDesc->lpszPassword) &&
		(WSTRLEN(this->lpsdDesc->lpszPassword) > 1))
    {
        //
        // we verify the password, if client is DX3 or 
        // client is DX5 or later, but didn't request passworded sessions or
        // session is private 
        // 
        if ((DPSP_MSG_DX3VERSION == dwVersion) || 
            !(pEnumRequest->dwFlags & DPENUMSESSIONS_PASSWORDREQUIRED) || 
            (this->lpsdDesc->dwFlags & DPSESSION_PRIVATE)) 
        {   
	        // if no password is specified
            if (0 == pEnumRequest->dwPasswordOffset)
            {
                DPF(2, "nameserver not responding - no password specified");
                return FALSE;
            }

            // point to the password in the request
            lpszPassword = (LPWSTR)((LPBYTE)pEnumRequest + pEnumRequest->dwPasswordOffset);

            // if password doesn't match
	        if (WSTRCMP(this->lpsdDesc->lpszPassword, lpszPassword))
            {
                DPF(2, "nameserver not responding - password doesn't match");
                return FALSE;
	        }
        }
    }

    // if DPENUMSESSIONS_ALL flag is specified ignore the following checks.
    // look for the flags only if the client is DX5 or greater
    if ((dwVersion >= DPSP_MSG_DX5VERSION) && !(pEnumRequest->dwFlags & DPENUMSESSIONS_ALL))
    {
	    // don't reply if session is maxed out
	    if ((this->lpsdDesc->dwMaxPlayers) && 
            (this->lpsdDesc->dwCurrentPlayers + this->dwPlayerReservations >= this->lpsdDesc->dwMaxPlayers))
        {
            DPF(2, "nameserver not responding - session maxed out");
            return FALSE;
	    }
	    
	    // don't reply if session is not allowing new players
	    if (this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED)
        {
            DPF(2, "nameserver not responding - not allowing new players");
            return FALSE;
        }
	    
        // don't reply if if session is not allowing join
        if (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)
        {
            DPF(2, "nameserver not responding - not allowing join");
            return FALSE;
        }
    }

	if (dwVersion < DPSP_MSG_DX6VERSION)
	{
		// if we're running the protocol, do not respond to pre-DX6 people
		if (this->lpsdDesc->dwFlags & DPSESSION_DIRECTPLAYPROTOCOL)
		{
            DPF(2, "nameserver not responding - protocol prevents < DX6");
            return FALSE;
		}
	}
	
    // now send the enumsessions reply
	nNameLength =  WSTRLEN_BYTES(this->lpsdDesc->lpszSessionName);

	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_ENUMSESSIONSREPLY);
	dwMessageSize +=  nNameLength ;

	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

	// pmsg follows sp blob
	perm = (LPMSG_ENUMSESSIONSREPLY)(pBuffer + this->dwSPHeaderSize);

	// perm is the buffer we want the sp to send
	SET_MESSAGE_HDR(perm);
    SET_MESSAGE_COMMAND(perm,DPSP_MSG_ENUMSESSIONSREPLY);

    // if we receive an unsecure enumsessions request and the session is secure
    // we respond with only the public information in the session desc
    if ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) && 
        !(dwSendFlags & DPSEND_SIGNED))
    {
        perm->dpDesc.dwSize = this->lpsdDesc->dwSize;
        perm->dpDesc.dwFlags = DPSESSION_SECURESERVER;
        perm->dpDesc.guidInstance = this->lpsdDesc->guidInstance;
        perm->dpDesc.guidApplication = this->lpsdDesc->guidApplication;
        perm->dpDesc.dwReserved1 = this->lpsdDesc->dwReserved1;
    }
    else
    {
        // ok to send the entire session desc
        perm->dpDesc =  *(this->lpsdDesc);
    }

	// pack strings on end
	pIndex = (LPBYTE)perm+sizeof(MSG_ENUMSESSIONSREPLY);
	if (nNameLength) 
	{
		memcpy(pIndex,this->lpsdDesc->lpszSessionName,nNameLength);
		perm->dwNameOffset = sizeof(MSG_ENUMSESSIONSREPLY);
	}

	// set string pointers to NULL - they must be set at client
	perm->dpDesc.lpszPassword = NULL;
	perm->dpDesc.lpszSessionName = NULL;

	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);

	DPMEM_FREE(pBuffer);

    return hr;

} // NS_HandleEnumSessions



HRESULT NS_SendIDRequestErrorReply(LPDPLAYI_DPLAY this, LPVOID pvSPHeader,
		HRESULT hrError, DWORD dwVersion)
{
	LPBYTE					pBuffer = NULL;
	LPMSG_PLAYERIDREPLY		prm = NULL;
	DWORD					dwMessageSize;
	HRESULT					hr;


	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);

    // allocate memory for the message
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return DPERR_OUTOFMEMORY;
	}

	// Setup the header
	prm = (LPMSG_PLAYERIDREPLY)(pBuffer + this->dwSPHeaderSize);
    SET_MESSAGE_HDR(prm);
    SET_MESSAGE_COMMAND(prm, DPSP_MSG_REQUESTPLAYERREPLY);
	prm->hr = hrError;

	// Send the reply
	hr = DoReply(this, pBuffer, dwMessageSize, pvSPHeader, dwVersion);

	// Free the buffer
	DPMEM_FREE(pBuffer);

	return hr;

} // NS_SendIDRequestErrorReply



HRESULT NS_HandleRequestPlayerID(LPDPLAYI_DPLAY this,LPVOID pvSPHeader,DWORD dwCommand, DWORD dwFlags, 
                                 BOOL fCheckPlayerFlags, DWORD dwVersion)
{
    HRESULT hr = DP_OK;
 	DWORD dwMessageSize, dwSSPIProviderSize=0, dwCAPIProviderSize=0, dwID=0;
	LPBYTE pBuffer;
    BOOL fSendSecurityDesc=FALSE;
    LPMSG_PLAYERIDREPLY prm;

	ASSERT(this);
	ASSERT(this->lpsdDesc);

	// if it's a player id, check dwmax players
	if (DPSP_MSG_REQUESTPLAYERID == dwCommand)
	{
        if (fCheckPlayerFlags)
        {
            // verify permissions based on player flags
            if ((this->lpsdDesc->dwFlags & DPSESSION_NEWPLAYERSDISABLED) ||
                ((dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
                 (this->lpsdDesc->dwFlags & DPSESSION_JOINDISABLED)))
            {
			    DPF(1,"not giving out new id - session is not allowing new players");
				
				// If the client is DX6 or greater, we want to send an
				// error back to them.  If it's pre-DX6, we will just fail
				// and let the client timeout so we preserve backward compatibility
				if(dwVersion >= DPSP_MSG_DX6VERSION)
				{
					hr = NS_SendIDRequestErrorReply(this, pvSPHeader, DPERR_CANTCREATEPLAYER, dwVersion);
				}
			    return hr;
            }
        }

		// a-josbor: be sure to count reservations, too!
        if (this->lpsdDesc->dwMaxPlayers && 
            (this->lpsdDesc->dwCurrentPlayers + this->dwPlayerReservations >= this->lpsdDesc->dwMaxPlayers))
		{
			DPF(1,"not giving out new id - too many players");

			// If the client is DX6 or greater, we want to send an
			// error back to them.  If it's pre-DX6, we will just fail
			// and let the client timeout so we preserve backward compatibility
			if(dwVersion >= DPSP_MSG_DX6VERSION)
			{
				hr = NS_SendIDRequestErrorReply(this, pvSPHeader, DPERR_CANTCREATEPLAYER, dwVersion);
			}
			return hr;
		}
	}

    // if session is secure and request is for system player id, send security package name
    if ((this->lpsdDesc->dwFlags & DPSESSION_SECURESERVER) && (dwFlags & DPLAYI_PLAYER_SYSPLAYER))
    {
        fSendSecurityDesc = TRUE;
    }

    if (fSendSecurityDesc)
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);
        dwSSPIProviderSize = WSTRLEN_BYTES(this->pSecurityDesc->lpszSSPIProvider);
        dwCAPIProviderSize = WSTRLEN_BYTES(this->pSecurityDesc->lpszCAPIProvider);
        dwMessageSize += dwSSPIProviderSize + dwCAPIProviderSize;
    }
    else
    {
	    // message size + blob size
	    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_PLAYERIDREPLY);
    }

    // allocate memory for the message
	pBuffer = DPMEM_ALLOC(dwMessageSize);
	if (!pBuffer) 
	{
		DPF_ERR("could not send request - out of memory");
		return E_OUTOFMEMORY;
	}

    // get a new id
    hr = NS_AllocNameTableEntry(this,&dwID);
	if (FAILED(hr)) 
	{
		DPF_ERR("namesrvr- could not alloc new player id");
		DPMEM_FREE(pBuffer);
		return hr;
	}

    // prm is the buffer we want the sp to send
	prm = (LPMSG_PLAYERIDREPLY)(pBuffer + this->dwSPHeaderSize);
    SET_MESSAGE_HDR(prm);
    SET_MESSAGE_COMMAND(prm,DPSP_MSG_REQUESTPLAYERREPLY);
    prm->dwID = dwID;

    // setup the message
    if (fSendSecurityDesc)
    {
		// copy the current security descrption into the message buffer
		memcpy(&prm->dpSecDesc, this->pSecurityDesc, sizeof(DPSECURITYDESC));

		// setup offsets to provider strings
		if (this->pSecurityDesc->lpszSSPIProvider)
		{
	        prm->dwSSPIProviderOffset = sizeof(MSG_PLAYERIDREPLY);
		    // copy strings at the end of the message
            memcpy((LPBYTE)prm+prm->dwSSPIProviderOffset, 
                this->pSecurityDesc->lpszSSPIProvider, dwSSPIProviderSize);
		}
	
		if (this->pSecurityDesc->lpszCAPIProvider)
		{
			prm->dwCAPIProviderOffset = sizeof(MSG_PLAYERIDREPLY) + dwSSPIProviderSize;
            memcpy((LPBYTE)prm+prm->dwCAPIProviderOffset, 
                this->pSecurityDesc->lpszCAPIProvider, dwCAPIProviderSize);
		}

    }

	hr = DoReply(this,pBuffer,dwMessageSize,pvSPHeader,dwVersion);

//	a-josbor: we successfully handed out a player id. Increment the reservation count now
//	to avoid letting too many players in under race conditions
	if (!FAILED(hr))
	{
		this->dwPlayerReservations++;
		this->dwLastReservationTime = GetTickCount();
	}
	
	DPMEM_FREE(pBuffer);
    return hr;

}// NS_HandleRequestPlayerID


#undef DPF_MODNAME
#define DPF_MODNAME	"TransferGroupsToNameServer"

// a system player has been deleted
// make any groups owned by that system player be owned by the nameserver
HRESULT TransferGroupsToNameServer(LPDPLAYI_DPLAY this,DPID idSysPlayer)
{
	LPDPLAYI_GROUP lpGroup;

	if (!this->pNameServer)	return E_FAIL;
	
	lpGroup = this->pGroups;
	
	while (lpGroup)
	{
		if (lpGroup->dwIDSysPlayer == idSysPlayer)
		{
			ASSERT(this->pNameServer);

			// idSysPlayer is history
			// make group owned by name server
			DPF(2,"transferring ownership of group id = %d from sysplayer id = %d to nameserver id = %d\n",
				lpGroup->dwID,idSysPlayer,this->pNameServer->dwID);
				
			lpGroup->dwIDSysPlayer = this->pNameServer->dwID;
		}
		lpGroup = lpGroup->pNextGroup;
	}

	return DP_OK;
	
} // TransferGroupsToNameServer

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_HandlePlayerMgmt"

// we got a system message off the wire
// put a message in the q fo all local players 
HRESULT  DistributeSystemMessage(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize)
{
	HRESULT hr;
	LPDPLAYI_PLAYER	pPlayer;
	
	pPlayer = this->pPlayers; 
	
	while (pPlayer)
	{
		// only distribute it to local non-system players
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,FALSE,0);
			if (FAILED(hr))
			{
				DPF_ERRVAL("could not handle player system message hr = 0x%08lx\n",hr);
			}
		}
		pPlayer = pPlayer->pNextPlayer;
	}
	
	return DP_OK;
			
} // DistributeSystemMessage

// tell pvSPHeader to go away
void SendDiePiggy(LPDPLAYI_DPLAY this,LPVOID pvSPHeader)
{
	LPMSG_SYSMESSAGE pmsg;
	LPBYTE pBuffer;
	DWORD dwMessageSize;
	
    dwMessageSize = GET_MESSAGE_SIZE(this,MSG_SYSMESSAGE);
    pBuffer = DPMEM_ALLOC(dwMessageSize);
    if (!pBuffer) 
    {
	    DPF_ERR("could not send die piggy - out of memory");
	    return;
    }

    // pmsg follows sp blob
    pmsg = (LPMSG_SYSMESSAGE)(pBuffer + this->dwSPHeaderSize);

    // build a message to send to the sp
    SET_MESSAGE_HDR(pmsg);
    SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_DIEPIGGY);
	
	DoReply(this,pBuffer,dwMessageSize,pvSPHeader,0);
	
	return ;
	
} // SendDiePiggy

/*
 ** SP_HandlePlayerMgmt
 *
 *  CALLED BY:	DPlay_HandleSPMessage
 *
 *  PARAMETERS:
 *				pPlayer - player that received the message (sysplayer)
 *				pReceiveBuffer - message that was received
 *
 *  DESCRIPTION:
 *				our sysplayer got a state changed message off the wire. process it,
 *				and tell all local players
 *
 *  RETURNS: corresponding idirectplay hr
 *
 */

HRESULT SP_HandlePlayerMgmt(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader) 
{
    HRESULT hr = DP_OK;
	LPDPLAYI_DPLAY this;
	LPMSG_PLAYERMGMTMESSAGE pmsg;
	DWORD dwCmd;
	BOOL bDistribute = TRUE; // when deleting a player or group, we need to
							// build the player message b4 it's gone.  this flag
							// tells us not to do it twice
			 
	if (!pPlayer)
	{
		DPF_ERR("got system message, but don't have a system player ACK ACK ACK");

#ifdef DIE_PIG
		DPF_ERRVAL("sending DIE PIGGY.  sayonara sucker pvSPHeader = 0x%08lx",pvSPHeader);
		SendDiePiggy(gpObjectList,pvSPHeader);
		DEBUG_BREAK();
#endif 		

		ASSERT(FALSE);
		return E_FAIL;
	}
	
	if(!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)){
		DPF(0,"Player %x is a sysplayer that is going away, rejecting system message\n",pPlayer);
		return E_FAIL;
	}
	
	this = pPlayer->lpDP;

	pmsg = (LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
	dwCmd = GET_MESSAGE_COMMAND(pmsg);

	// if it's remote or we're not handling a multicast, we don't need to process the message
	if ((DPSP_HEADER_LOCALMSG != pvSPHeader) || (this->dwFlags & DPLAYI_DPLAY_HANDLEMULTICAST))
	{
		// We want the default hresult to be DPERR_GENERIC so that we don't send
		// the message unless the processing is successful.
		hr = DPERR_GENERIC;
		
		switch (dwCmd)
		{
			case DPSP_MSG_DELETEPLAYER: 
			{
				BOOL bNameSrvr=FALSE; // used to indicate name srvr going away 
				BOOL bSysPlayer=FALSE; // set to TRUE if we're nuking a system player
				LPDPLAYI_PLAYER pDeletedPlayer;
				DPID idSysPlayer;  // the id of the deleted system player

				DPF(4, "Got DPSP_MSG_DELETEPLAYER for %d.", pmsg->dwPlayerID);
				
				pDeletedPlayer = PlayerFromID(this,pmsg->dwPlayerID);
		        if (!VALID_DPLAY_PLAYER(pDeletedPlayer)) 
		        {
					DPF_ERR("bad player id!!");
//					ASSERT(FALSE);
					return DPERR_INVALIDPARAMS; // bail!
		        }				

				#define DPLAYI_PLAYER_LOCALAPPSERVER (DPLAYI_PLAYER_APPSERVER|DPLAYI_PLAYER_PLAYERLOCAL)
				// seems like a remote is trying to delete the app server.
				if((pDeletedPlayer->dwFlags & DPLAYI_PLAYER_LOCALAPPSERVER)==DPLAYI_PLAYER_LOCALAPPSERVER)
				{
					DPF_ERR("remote trying to delete local appserver player, not allowed!!!!\n");
					return DPERR_INVALIDPARAMS;
				}
				#undef DPLAYI_PLAYER_LOCALAPPSERVER

				if (DPLAYI_PLAYER_SYSPLAYER & pDeletedPlayer->dwFlags) 
				{
					// if it's the name srvr, we want to deal w/ it after we delete
					// it from the table
					if (DPLAYI_PLAYER_NAMESRVR & pDeletedPlayer->dwFlags) bNameSrvr = TRUE;
					bSysPlayer = TRUE;				
					idSysPlayer = pDeletedPlayer->dwID; // we may need this below to take ownership of its groups		
				}
				
				// need to distribute player system messages now, b4 player is nuked				
				hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				bDistribute = FALSE;
				
				hr = InternalDestroyPlayer(this,pDeletedPlayer,FALSE,TRUE);	
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				
				// if a sysplayer was nuked, and there was no DX3 in the game, we can reassign
				// the sysplayers group to the current name server.  if there is dx3 in the game,
				// we don't know the id of the new name server yet
				if (bSysPlayer & !(this->dwFlags & DPLAYI_DPLAY_DX3INGAME) )
				{
					TransferGroupsToNameServer(this,idSysPlayer);
				}

				
				break;
			} // case dpsp_msg_deleteplayer

			case DPSP_MSG_CREATEPLAYER:
			case DPSP_MSG_CREATEPLAYERVERIFY:
			{
				LPDPLAYI_PLAYER pPlayer;
				
				// Need to set the hresult to DP_OK so we send the message
				hr = DP_OK;

				SET_MESSAGE_COMMAND_ONLY(pmsg,DPSP_MSG_CREATEPLAYER);
				// make sure player's not already in our nametable
				// this will happen e.g. on an addforward
				pPlayer = PlayerFromID(this,pmsg->dwPlayerID);
				if (!VALID_DPLAY_PLAYER(pPlayer))
				{
					// get the new player out of the message 
					hr = UnpackPlayerAndGroupList(this,pReceiveBuffer + 
						((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,1,0,pvSPHeader);

					// if this is the nameserver, clear the nonameserver flag
					pPlayer = PlayerFromID(this,pmsg->dwPlayerID);
					if(VALID_DPLAY_PLAYER(pPlayer) && pPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR){
						this->dwFlags &= ~DPLAYI_DPLAY_NONAMESERVER;
						LEAVE_DPLAY();

						DVoiceNotify(this,DVEVENT_MIGRATEHOST,PlayerIDFromSysPlayerID(this,pmsg->dwPlayerID),0,DVTRANSPORT_OBJECTTYPE_BOTH );						
						
						ENTER_ALL();
						
						TRY 
						{
						
							hr = VALID_DPLAY_PTR( this );
							
							if (FAILED(hr))	{
								LEAVE_SERVICE();
								return hr;
						    }
						    
						} 
						EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
					        DPF_ERR( "Exception encountered validating parameters" );
					        LEAVE_SERVICE();
					        return DPERR_INVALIDPARAMS;
						}
						
						LEAVE_SERVICE();
					}

					// Only DoCreateVerify if we aren't the nameserver (not necessary in this case), see DoCreateVerify for details.
					// We also only do it when being notified of non-sysplayer creation.
					pPlayer=PlayerFromID(this,pmsg->dwPlayerID);
					if(  VALID_DPLAY_PLAYER(pPlayer) &&
						!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) &&
						!(this->pSysPlayer && (this->pSysPlayer->dwFlags & DPLAYI_PLAYER_NAMESRVR)) && 
						(dwCmd == DPSP_MSG_CREATEPLAYER)){
						// Have DPLAY() lock
						DoCreateVerify(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
					}
					// Note: we are going to distribute the creation message because this guy was NOT
					//      in the original nametable download (regardless of Verify or Create Message).
				} else {
					if(!(this->dwFlags & DPLAYI_DPLAY_HANDLEMULTICAST)){
						bDistribute=FALSE;
					}	
				}
				break;
			}
				
			case DPSP_MSG_DELETEGROUP:
			{
				LPDPLAYI_GROUP pGroup;
				
		        pGroup = GroupFromID(this,pmsg->dwGroupID);
		        if (!VALID_DPLAY_GROUP(pGroup)) 
		        {
					DPF_ERR("could not delete group - invalid group id");
		            return DPERR_INVALIDGROUP;
		        }
				
				// need to distribute player system messages now, b4 player is nuked				
				hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}
				bDistribute = FALSE;

				hr = InternalDestroyGroup(this,pGroup,FALSE);
				if (FAILED(hr))
				{
					ASSERT(FALSE);
				}

				break;
			}

			case DPSP_MSG_CREATEGROUP: 
			{
				// get the new group out of the message 
				hr = UnpackPlayerAndGroupList(this,pReceiveBuffer +
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwCreateOffset,0,1,pvSPHeader);
				break;
			}

			case DPSP_MSG_ADDPLAYERTOGROUP:
				hr = InternalAddPlayerToGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
			case DPSP_MSG_DELETEPLAYERFROMGROUP:
				hr = InternalDeletePlayerFromGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;
			
			case DPSP_MSG_PLAYERDATACHANGED: 
			case DPSP_MSG_GROUPDATACHANGED:
			case DPSP_MSG_PLAYERNAMECHANGED:
			case DPSP_MSG_GROUPNAMECHANGED:

				hr = SP_HandleDataChanged(this,pReceiveBuffer);
				break;
			
			case DPSP_MSG_SESSIONDESCCHANGED:

				hr = SP_HandleSessionDescChanged(this,pReceiveBuffer);
				break;

			case DPSP_MSG_ADDSHORTCUTTOGROUP:
				hr = InternalAddGroupToGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,DPGROUP_SHORTCUT,FALSE);
				break;

			case DPSP_MSG_DELETEGROUPFROMGROUP:
				hr = InternalDeleteGroupFromGroup((IDirectPlay *)this->pInterfaces,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwGroupID,
					((LPMSG_PLAYERMGMTMESSAGE)pmsg)->dwPlayerID,FALSE);
				break;

			default:
				ASSERT(FALSE);
				DPF(0,"SP_Playermess: received unrecognized message - msg = %d\n",dwCmd);
		} // switch
	} // DPSP_HEADER_LOCALMSG

	// dplay has processed the system message - tell all local players about it
	if (bDistribute && SUCCEEDED(hr))
	{
		hr = DistributeSystemMessage(this,pReceiveBuffer,dwMessageSize);		
		if (FAILED(hr))
		{
			ASSERT(FALSE);
		}
	}
	
	return DP_OK;
} // SP_HandlePlayerMgmt

// construct player or group flags
DWORD GetPlayerFlags(LPDPLAYI_PLAYER pPlayer)
{
	DWORD	dwFlags;

	dwFlags = 0;

	// player is a server player
	if (pPlayer->dwFlags & DPLAYI_PLAYER_APPSERVER)
	{
		dwFlags |= DPPLAYER_SERVERPLAYER;
	}

	// player is a spectator
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SPECTATOR)
	{
		dwFlags |= DPPLAYER_SPECTATOR;
	}

	// player or group was created locally
	if (pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
	{
		dwFlags |= DPPLAYER_LOCAL;
	}

	// group is a staging area
	if (pPlayer->dwFlags & DPLAYI_GROUP_STAGINGAREA)
	{
		dwFlags |= DPGROUP_STAGINGAREA;
	}

	// group is hidden
	if (pPlayer->dwFlags & DPLAYI_GROUP_HIDDEN)
	{
		dwFlags |= DPGROUP_HIDDEN;
	}

	return (dwFlags);
} // GetPlayerFlags

#undef DPF_MODNAME
#define DPF_MODNAME	"MESSAGE BUILDER"

/*
 ** BuildAddMessage
 *
 *  CALLED BY: BuildPlayerSystemMessage
 *
 *  PARAMETERS:
 *		pPlayerSrc - the player that received this message
 *		pReceiveBuffer - the message that was received
 *		ppMessageBuffer - buffer going out to the user
 *		pdwMessagesize - size of ppMessageBuffer
 *		fPlayer - is this an addplayer or addgroup.  
 *
 *  DESCRIPTION: builds a player system message. converts dplay internal 
 *		message format to user readable format (see dplay.h). called before 
 *		putting a message in the apps message queue.
 *
 *  RETURNS: DP_OK, ppMessagebuffer,pdwMessagesize, or E_OUTOFMEMORY
 *
 */

HRESULT BuildAddMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	LPDPLAYI_PLAYER pPlayer; // the player being created
	LPDPLAYI_GROUP pGroup; // used to verify group
	DPMSG_CREATEPLAYERORGROUP dpmsg; // the message being built
	LPBYTE pBufferIndex; 
	UINT iShortStrLen,iLongStrLen; // strlength, in bytes
	HRESULT hr;
	
	memset(&dpmsg,0,sizeof(dpmsg));

	if (fPlayer)
	{
	    pPlayer = PlayerFromID(this,
	    	((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	    if (!VALID_DPLAY_PLAYER(pPlayer)) 
	    {
			// this happens (e.g. player gets deleted between when sysplayer sends addplayermessage
			// and we receive it)
	    	return DPERR_INVALIDPARAMS;
	    }
		dpmsg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		pGroup = GroupFromID(this,
			((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID);
	    if (!VALID_DPLAY_GROUP(pGroup)) 
	    {
			// this happens (e.g. player gets deleted between when sysplayer sends addplayermessage
			// and we receive it)
	    	return DPERR_INVALIDPARAMS;
	    }
		// cast to pPlayer since we only care about common fields
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
		dpmsg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	ASSERT(pPlayer);

	// don't generate player message if it's a sysplayer
	// not really an error, but we use this to make sure user doesn't 
	// see messages they shouldn't get...
	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) return E_FAIL;

	// make sure user doesn't get self - create message
	if (pPlayer->dwID == pPlayerSrc->dwID) return E_FAIL; 
	
	// build the message
	dpmsg.dwType = DPSYS_CREATEPLAYERORGROUP;
	dpmsg.dpId = pPlayer->dwID;
	dpmsg.dwCurrentPlayers = this->lpsdDesc->dwCurrentPlayers;
	dpmsg.dwDataSize = pPlayer->dwPlayerDataSize;
	dpmsg.dpnName.dwSize = sizeof(DPNAME);
	dpmsg.dpIdParent = pPlayer->dwIDParent;
	dpmsg.dwFlags = GetPlayerFlags(pPlayer);
	iShortStrLen =  WSTRLEN_BYTES(pPlayer->lpszShortName) ;
	iLongStrLen =  WSTRLEN_BYTES(pPlayer->lpszLongName) ;

	// alloc the user message
	*pdwMessageSize = sizeof(DPMSG_CREATEPLAYERORGROUP) + iShortStrLen + iLongStrLen +
		pPlayer->dwPlayerDataSize;

	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}
	
	// now , build the buffer

	// copy the strings into the buffer. set the pointers in the name
	// struct to point at the strings
	pBufferIndex = (LPBYTE) *ppMessageBuffer + sizeof(dpmsg);
	if (iShortStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszShortName = (WCHAR *)pBufferIndex;
		pBufferIndex += iShortStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszShortName = (WCHAR *)NULL;
	}

	// long string
	if (iLongStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszLongName = (WCHAR *)pBufferIndex;
		pBufferIndex += iLongStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszLongName = (WCHAR *)NULL;
	}

	// copy the player blob into the buffer. set the blob pointer
	if (pPlayer->dwPlayerDataSize)
	{
		memcpy(pBufferIndex,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		dpmsg.lpData = pBufferIndex;
	}
	else 
	{
		dpmsg.lpData = NULL;
	}

	// copy over the message portion
	memcpy(*ppMessageBuffer,&dpmsg,sizeof(dpmsg));

	// Inform DirectXVoice of event
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL ||\
	    (this->fLoadRetrofit) )
	{
		// Leave locks to prevent the deadlock
		LEAVE_DPLAY();	

		if( dpmsg.dwPlayerType == DPPLAYERTYPE_PLAYER )
		{
			DVoiceNotify( this, DVEVENT_ADDPLAYER, dpmsg.dpId, 0,DVTRANSPORT_OBJECTTYPE_BOTH );
		}	
		else
		{
			DVoiceNotify( this, DVEVENT_CREATEGROUP, dpmsg.dpId, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		}
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
	
		LEAVE_SERVICE();
	}
	
	// all done...
	return DP_OK;

} // BuildAddMessage

// see BuildAddMessage comments
HRESULT BuildDeleteMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	DPMSG_DESTROYPLAYERORGROUP dpmsg;
	LPDPLAYI_PLAYER pPlayer;
	LPBYTE pBufferIndex; 
	UINT iShortStrLen,iLongStrLen; // strlength, in bytes
	HRESULT hr;

	if (fPlayer) 
	{
		dpmsg.dpId = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;		
		// don't send to self...
		// a-josbor- in order to support the NAMESERVER being able to delete
		//	any player, we must allow the delete message to be delivered to
		//	"self"
	//	if (dpmsg.dpId == pPlayerSrc->dwID) return E_FAIL;

        pPlayer = PlayerFromID(this,dpmsg.dpId);
        if (!VALID_DPLAY_PLAYER(pPlayer)) 
        {
		
			// e.g. we've gotten two deletes. this can happen e.g.
			// w/ keep alive threads on two systems simultaneously
			// detecting someone's gone
        	return DPERR_INVALIDPARAMS;
        }

		if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER) 
		{
			// not really an error, just don't tell users about
			// sysplayer stuff
			return E_FAIL;
		}

		dpmsg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	} // fPlayer
	else 
	{	
		LPDPLAYI_GROUP pGroup;

		// group
		dpmsg.dpId = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwGroupID;
		dpmsg.dwPlayerType = DPPLAYERTYPE_GROUP;	
		
		pGroup = GroupFromID(this,dpmsg.dpId);
        if (!VALID_DPLAY_GROUP(pGroup)) 
        {
			// should never happen
			ASSERT(FALSE);		
        	return DPERR_INVALIDPARAMS;
        }
		// cast to player for what we need
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
	}

	dpmsg.dwFlags = GetPlayerFlags(pPlayer);
	dpmsg.dpIdParent = pPlayer->dwIDParent;
	dpmsg.dwType = DPSYS_DESTROYPLAYERORGROUP;
	dpmsg.dpnName.dwSize = sizeof(DPNAME);
	dpmsg.dpnName.dwFlags = 0;
	iShortStrLen =  WSTRLEN_BYTES(pPlayer->lpszShortName);
	iLongStrLen =  WSTRLEN_BYTES(pPlayer->lpszLongName);
	
	// calc message size
	*pdwMessageSize = sizeof(DPMSG_DESTROYPLAYERORGROUP)
						+ pPlayer->dwPlayerLocalDataSize
						+ pPlayer->dwPlayerDataSize
						+ iShortStrLen + iLongStrLen;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	pBufferIndex = (LPBYTE)(*ppMessageBuffer) + sizeof(dpmsg);

	// copy the local player data
	dpmsg.dwLocalDataSize = pPlayer->dwPlayerLocalDataSize;
	if (dpmsg.dwLocalDataSize)
	{
		dpmsg.lpLocalData = pBufferIndex;
		memcpy(dpmsg.lpLocalData,pPlayer->pvPlayerLocalData,pPlayer->dwPlayerLocalDataSize);
		pBufferIndex += dpmsg.dwLocalDataSize;
	}
	else 
	{
		dpmsg.lpLocalData = NULL;
	}
	
	// copy the Player data
	dpmsg.dwRemoteDataSize = pPlayer->dwPlayerDataSize;
	if (dpmsg.dwRemoteDataSize)
	{
		dpmsg.lpRemoteData = pBufferIndex;
		memcpy(dpmsg.lpRemoteData,pPlayer->pvPlayerData,pPlayer->dwPlayerDataSize);
		pBufferIndex += dpmsg.dwRemoteDataSize;
	}
	else 
	{
		dpmsg.lpRemoteData = NULL;
	}

	// copy the strings into the buffer. set the pointers in the name
	// struct to point at the strings
	if (iShortStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszShortName,iShortStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszShortName = (WCHAR *)pBufferIndex;
		pBufferIndex += iShortStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszShortName = (WCHAR *)NULL;
	}

	// long string
	if (iLongStrLen)
	{
		memcpy(pBufferIndex,pPlayer->lpszLongName,iLongStrLen);
		// set pointer to point at string in buffer
		dpmsg.dpnName.lpszLongName = (WCHAR *)pBufferIndex;
		pBufferIndex += iLongStrLen;
	}
	else 
	{
		dpmsg.dpnName.lpszLongName = (WCHAR *)NULL;
	}
	
	// put the sys message into the buffer
	memcpy(*ppMessageBuffer,&dpmsg,sizeof(dpmsg));

	// Inform DirectXVoice of event
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		// Have to let go of the lock so that the notification
		// can proceed.
		LEAVE_DPLAY();
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}

		// rodtoll: prevent deadlock, always drop locks before calling DVoiceNotify
		LEAVE_ALL();
		
		if( dpmsg.dwPlayerType == DPPLAYERTYPE_PLAYER )
		{
			DVoiceNotify( this, DVEVENT_REMOVEPLAYER, dpmsg.dpId, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		}	
		else
		{
			DVoiceNotify( this, DVEVENT_DELETEGROUP, dpmsg.dpId, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		}

		ENTER_ALL();

		LEAVE_SERVICE();
	}
	
	return DP_OK;

} // BuildDeleteMessage	

// see BuildAddPlayerMessage comments
// fAdd - True - add to group, false, delete from group
HRESULT BuildPlayerGroupMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,DWORD dwType)
{
	HRESULT hr;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	DPMSG_GROUPADD dpmsg; // add or delete mesage

	dpmsg.dpIdPlayer = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwPlayerID;
	dpmsg.dpIdGroup = ((LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer)->dwGroupID;	

	// set up dpmsg
	dpmsg.dwType = dwType;

	*pdwMessageSize = sizeof(dpmsg);
	
	// alloc the user message
	*ppMessageBuffer = NULL;
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	// Inform DirectXVoice of event
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		LEAVE_DPLAY();	

		// Have to leave the locks to prevent deadlock
		if( dwType == DPSYS_ADDPLAYERTOGROUP )
		{
			DVoiceNotify( this, DVEVENT_ADDPLAYERTOGROUP, dpmsg.dpIdGroup, dpmsg.dpIdPlayer, DVTRANSPORT_OBJECTTYPE_BOTH );
		}
		else if( dwType == DPSYS_DELETEPLAYERFROMGROUP )
		{
			DVoiceNotify( this, DVEVENT_REMOVEPLAYERFROMGROUP, dpmsg.dpIdGroup, dpmsg.dpIdPlayer, DVTRANSPORT_OBJECTTYPE_BOTH );
		}
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}	
	
	memcpy(*ppMessageBuffer,&dpmsg,*pdwMessageSize);
	return DP_OK;

	
} // BuildPlayerGroupMessage

// see BuildAddMessage comments
HRESULT BuildDataChanged(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	DPMSG_SETPLAYERORGROUPDATA msg;
	LPVOID pvData;
	DWORD dwDataSize;
	DWORD dwID;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;
	
	// see who it's from
	dwID = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwPlayerID;

	// find the data + size
	pvData = pReceiveBuffer + ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataOffset;
	dwDataSize = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataSize;

	// alloc the user message
	*pdwMessageSize = sizeof(msg) + dwDataSize;
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	msg.dwType = DPSYS_SETPLAYERORGROUPDATA;
	if (fPlayer) 
	{
		msg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		msg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	msg.dpId = dwID;
	msg.dwDataSize = dwDataSize;
	if (dwDataSize) msg.lpData = (LPBYTE)*ppMessageBuffer + sizeof(msg);
	else msg.lpData = (LPBYTE)NULL;

	// copy the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));
	// copy the data
	if (dwDataSize)
	{
		memcpy((LPBYTE)*ppMessageBuffer + sizeof(msg),pvData,dwDataSize);
	}

	return DP_OK;
} // BuildDataChanged

// see BuildAddMessage comments
HRESULT BuildNameChanged(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize,BOOL fPlayer)
{
	DPMSG_SETPLAYERORGROUPNAME msg;
	UINT nShortLength,nLongLength;
	LPWSTR pszShortName,pszLongName;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;

	msg.dpId = ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwPlayerID;

	msg.dpnName.dwSize = sizeof(msg.dpnName);
	msg.dwType = DPSYS_SETPLAYERORGROUPNAME;

	if (fPlayer) 
	{
		msg.dwPlayerType = DPPLAYERTYPE_PLAYER;
	}
	else 
	{
		msg.dwPlayerType = DPPLAYERTYPE_GROUP;
	}

	if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset)
	{
		pszShortName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset);
		nShortLength = WSTRLEN_BYTES(pszShortName);		
	}
	else 
	{
		nShortLength = 0;
		pszShortName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset)
	{
		pszLongName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset);
		nLongLength = WSTRLEN_BYTES(pszLongName);				
	}
	else 
	{
		nLongLength = 0;
		pszLongName = (LPWSTR)NULL;
	}

	
	*pdwMessageSize = sizeof(msg) + nShortLength + nLongLength;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	// copy the strings into the buffer, behind where msg will go
	// short name follows message
	if (nShortLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg),pszShortName,nShortLength);
		msg.dpnName.lpszShortName = (LPWSTR)((LPBYTE)*ppMessageBuffer + sizeof(msg));
	} 
	else 
	{
		msg.dpnName.lpszShortName = (LPWSTR)NULL;
	}
	// long name follows short name
	if (nLongLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg) + nShortLength,pszLongName,nLongLength);

		msg.dpnName.lpszLongName = (LPWSTR)( (LPBYTE)*ppMessageBuffer + sizeof(msg)
			+ nShortLength);
	} 
	else 
	{
		msg.dpnName.lpszLongName = (LPWSTR)NULL;
	}

	// now, copy over the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildNameChanged

// see BuildAddMessage comments
HRESULT BuildNameServerMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	HRESULT hr;
	DPMSG_GENERIC msg;
	LPDPLAYI_DPLAY this=pPlayerSrc->lpDP;
	
	*pdwMessageSize = sizeof(msg);
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	msg.dwType = DPSYS_HOST;

	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		// Left locks
		LEAVE_DPLAY();

		DVoiceNotify(this,DVEVENT_MIGRATEHOST,pPlayerSrc->dwID,0, DVTRANSPORT_OBJECTTYPE_BOTH);
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}

	// copy the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildNameServerMessage

// see BuildAddMessage comments
HRESULT BuildSessionDescMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	DPMSG_SETSESSIONDESC msg;
	UINT nPasswordLength,nSessionNameLength;
	LPWSTR pszSessionName,pszPassword;
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	
	if (this->lpsdDesc->dwFlags & DPSESSION_NODATAMESSAGES) return E_FAIL;

	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset)
	{
		pszSessionName = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset);
		nSessionNameLength = WSTRLEN_BYTES(pszSessionName);		
	}
	else 
	{
		nSessionNameLength = 0;
		pszSessionName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset)
	{
		pszPassword = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset);
		nPasswordLength = WSTRLEN_BYTES(pszPassword);				
	}
	else 
	{
		nPasswordLength = 0;
		pszPassword = (LPWSTR)NULL;
	}
	
	*pdwMessageSize = sizeof(msg) + nSessionNameLength + nPasswordLength;
	
	// alloc the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

    // prepare the message 

	msg.dwType = DPSYS_SETSESSIONDESC;
    // copy the session desc 
    memcpy(&(msg.dpDesc), &((LPMSG_SESSIONDESC)pReceiveBuffer)->dpDesc, sizeof(DPSESSIONDESC2));

	// copy the strings into the buffer, behind where msg will go
	// session name follows message
	if (nSessionNameLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg),pszSessionName,nSessionNameLength);
		msg.dpDesc.lpszSessionName = (LPWSTR)((LPBYTE)*ppMessageBuffer + sizeof(msg));
	} 
	else 
	{
		msg.dpDesc.lpszSessionName = (LPWSTR)NULL;
	}
	// password follows session name
	if (nPasswordLength)
	{
		memcpy(*ppMessageBuffer + sizeof(msg) + nSessionNameLength,pszPassword,nPasswordLength);
		msg.dpDesc.lpszPassword = (LPWSTR)( (LPBYTE)*ppMessageBuffer + sizeof(msg)
			+ nSessionNameLength);
	} 
	else 
	{
		msg.dpDesc.lpszPassword = (LPWSTR)NULL;
	}

	// now, copy over the message
	memcpy(*ppMessageBuffer,&msg,sizeof(msg));

	return DP_OK;

} // BuildSessionDescMessage

// see BuildAddMessage comments
HRESULT BuildSecureSystemMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize, DWORD dwSendFlags)
{	
    LPDPMSG_SECUREMESSAGE pSecureMessage;
    LPMSG_PLAYERMESSAGE pPlayerMessage=(LPMSG_PLAYERMESSAGE)pReceiveBuffer;
    DWORD dwPlayerMessageSize;
    LPDPLAYI_DPLAY this;

    ASSERT(pdwMessageSize);
    ASSERT(ppMessageBuffer);

    this = pPlayerSrc->lpDP;

	// naked?
	if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
	{
		// not naked
		// if we're not naked, player to == player from is not allowed
		if (pPlayerSrc->dwID == pPlayerMessage->idFrom)		
		{
			DPF(7,"not delivering message w/ to == from");
			return DPERR_GENERIC;
		}
		// subtract off the size of the to and from
		*pdwMessageSize -=  sizeof(MSG_PLAYERMESSAGE); // size of user data
	}

    // Remember the player message size so we can copy the correct portion of the 
    // player message from the receive buffer.
    dwPlayerMessageSize = *pdwMessageSize;

    // allocate memory for entire player message + secure msg struct
	*pdwMessageSize += sizeof(DPMSG_SECUREMESSAGE);
	
	// alloc memory for the user message
	*ppMessageBuffer = DPMEM_ALLOC(*pdwMessageSize);
	if (!*ppMessageBuffer) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return DPERR_OUTOFMEMORY;
	}

    // use the buffer as a secure message
    pSecureMessage = (LPDPMSG_SECUREMESSAGE)*ppMessageBuffer;

    // fill the message type
    pSecureMessage->dwType = DPSYS_SECUREMESSAGE;
    // fill the flags
    if (dwSendFlags & DPSEND_SIGNED)
    {
        pSecureMessage->dwFlags |= DPSEND_SIGNED;
    }
    if (dwSendFlags & DPSEND_ENCRYPTED)
    {
        pSecureMessage->dwFlags |= DPSEND_ENCRYPTED;
    }
    // fill the player from id
    pSecureMessage->dpIdFrom = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idFrom;
    // point to the actual player-player message
    pSecureMessage->lpData = (LPBYTE)pSecureMessage+sizeof(DPMSG_SECUREMESSAGE);
    // fill the message size
    pSecureMessage->dwDataSize = dwPlayerMessageSize;
    // copy the message
	if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
	{
		// not naked
		// copy message without ids
		memcpy(pSecureMessage->lpData,pReceiveBuffer+sizeof(MSG_PLAYERMESSAGE),
            dwPlayerMessageSize);
	}
	else 
	{
		// copy naked message into pMessageBuffer
		memcpy(pSecureMessage->lpData,pReceiveBuffer,dwPlayerMessageSize);
	}	

	return DP_OK;

} // BuildSecureSystemMessage

// see BuildAddMessage comments
HRESULT BuildStartSessionMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPLAYI_DPLAY this = pPlayerSrc->lpDP;
	LPDPMSG_STARTSESSION	lpmsg;
	LPMSG_STARTSESSION		lpmsgIn = (LPMSG_STARTSESSION)pReceiveBuffer;
	DWORD					dwConnSize;
	DWORD					dwSize;
	LPBYTE					lpByte = NULL, lpByte2 = NULL;
	LPDPLCONNECTION			lpConn = NULL;
	LPDPSESSIONDESC2		lpsd = NULL;
	HRESULT					hr;


	// calc the size
	dwConnSize = *pdwMessageSize - sizeof(DPSP_MSG_STARTSESSION);
	dwSize = sizeof(DPMSG_STARTSESSION) + dwConnSize;
	
	*pdwMessageSize = dwSize;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(dwSize);
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_STARTSESSION;

	// copy the message
	lpByte = (LPBYTE)lpmsg + sizeof(DPMSG_STARTSESSION);
	lpByte2 = (LPBYTE)lpmsgIn + lpmsgIn->dwConnOffset;
	memcpy(lpByte, lpByte2, dwConnSize);

	// fix the DPLCONNECTION pointer
	lpmsg->lpConn = lpConn = (LPDPLCONNECTION)lpByte;

	// Stick the dplay object's pointer in one of the reserved
	// fields in the SessionDesc so we can forward lobby messages back
	// to the server on that object.  NOTE: The following code relies on the
	// packing code for the DPLCONNECTION structure to remain unchanged.  If
	// the packing changes, this offset calculation may not work correctly.
	lpsd = (LPDPSESSIONDESC2)((LPBYTE)lpConn + (DWORD_PTR)lpConn->lpSessionDesc);
	lpsd->dwReserved1 = (DWORD_PTR)(pPlayerSrc->lpDP);
	lpsd->dwReserved2 = pPlayerSrc->dwID;

	*ppMessageBuffer = (LPBYTE)lpmsg;

	// Notify voice system, if it's there
	if( this->lpDxVoiceNotifyClient != NULL || 
	    this->lpDxVoiceNotifyServer != NULL )
	{
		LEAVE_DPLAY();

		DVoiceNotify( this, DVEVENT_STARTSESSION, 0, 0, DVTRANSPORT_OBJECTTYPE_BOTH );
		
		ENTER_ALL();

		TRY 
		{
		
			hr = VALID_DPLAY_PTR( this );
			
			if (FAILED(hr))	{
				LEAVE_SERVICE();
				return hr;
		    }
		    
		} 
		EXCEPT ( EXCEPTION_EXECUTE_HANDLER )   {
	        DPF_ERR( "Exception encountered validating parameters" );
	        LEAVE_SERVICE();
	        return DPERR_INVALIDPARAMS;
		}
		
		LEAVE_SERVICE();
	}		

	return DP_OK;

} // BuildStartSessionMessage

// see BuildAddMessage comments
HRESULT BuildChatMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_CHAT		lpmsg;
	LPMSG_CHAT			lpmsgIn = (LPMSG_CHAT)pReceiveBuffer;
	DWORD				dwStringSize, dwSize;
	LPWSTR				lpwszMessageIn = NULL, lpwszMessage = NULL;
	LPDPLAYI_PLAYER		lpPlayer = NULL;
	LPDPLAYI_GROUP		lpGroup = NULL;
	

	// If from == to, then fail building this message because we
	// don't want to send a chat message to ourself.  Normally, the
	// DistributeGroupMessage function would catch this, but since
	// this is a system message, it won't because idFrom will be zero
	if(lpmsgIn->dwIDFrom == pPlayerSrc->dwID)
		return DPERR_GENERIC;

	// calc the size of the message
	lpwszMessageIn = (LPWSTR)((LPBYTE)lpmsgIn + lpmsgIn->dwMessageOffset);
	dwStringSize = WSTRLEN_BYTES(lpwszMessageIn);
	dwSize = sizeof(DPMSG_CHAT) + sizeof(DPCHAT) + dwStringSize;
	
	*pdwMessageSize = dwSize;
	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(dwSize);
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_CHAT;
	lpmsg->idFromPlayer = lpmsgIn->dwIDFrom;
	lpmsg->lpChat = (LPDPCHAT)((LPBYTE)lpmsg + sizeof(DPMSG_CHAT));
	lpmsg->lpChat->dwSize = sizeof(DPCHAT);
	lpmsg->lpChat->dwFlags = lpmsgIn->dwFlags;

	// Determine if the message was sent to a group or a player and
	// set the appropriate idToXXXXX field in the message
	if(lpmsgIn->dwIDTo != DPID_ALLPLAYERS)
	{
		lpPlayer = PlayerFromID(pPlayerSrc->lpDP, lpmsgIn->dwIDTo);
		if(VALID_DPLAY_PLAYER(lpPlayer))
		{
			lpmsg->idToPlayer = lpmsgIn->dwIDTo;
		}
		else
		{
			lpGroup = GroupFromID(pPlayerSrc->lpDP, lpmsgIn->dwIDTo);
			if(VALID_DPLAY_GROUP(lpGroup))
			{
				lpmsg->idToGroup = lpmsgIn->dwIDTo;
			}
			else
			{
				DPF_ERRVAL("Received chat message for unknown player or group, ID = %lu", lpmsgIn->dwIDTo);
				ASSERT(FALSE);
				// I guess we'll treat it as a broadcast message
			}
		}
	}

	// copy the message
	lpwszMessage = (LPWSTR)((LPBYTE)lpmsg + sizeof(DPMSG_CHAT)
					+ sizeof(DPCHAT));
	memcpy(lpwszMessage, lpwszMessageIn, dwStringSize);

	// fix the DPCHAT string pointer
	lpmsg->lpChat->lpszMessage = lpwszMessage;

	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildChatMessage

// see BuildAddMessage comments
HRESULT BuildGroupOwnerChangedMessage(LPDPLAYI_PLAYER pPlayerSrc,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer,DWORD * pdwMessageSize)
{
	LPDPMSG_SETGROUPOWNER		lpmsg = NULL;
	LPMSG_GROUPOWNERCHANGED		lpmsgIn = (LPMSG_GROUPOWNERCHANGED)pReceiveBuffer;
	

	
	// alloc the user message
	lpmsg = DPMEM_ALLOC(sizeof(DPMSG_SETGROUPOWNER));
	if (!lpmsg) 
	{
		DPF_ERR("could not alloc user message - out of memory");
		return E_OUTOFMEMORY;
	}

	lpmsg->dwType = DPSYS_SETGROUPOWNER;
	lpmsg->idGroup = lpmsgIn->dwIDGroup;
	lpmsg->idNewOwner = lpmsgIn->dwIDNewOwner;
	lpmsg->idOldOwner = lpmsgIn->dwIDOldOwner;

	// Set the output pointers
	*pdwMessageSize = sizeof(DPMSG_SETGROUPOWNER);
	*ppMessageBuffer = (LPBYTE)lpmsg;

	return DP_OK;

} // BuildGroupOwnerChangedMessage


// sets up a dplay system message suitable for passing back to a player
/*
 ** BuildPlayerSystemMessage
 *
 *  CALLED BY:	HandlePlayerMessage
 *
 *  PARAMETERS:
 *				pPlayer	- the player that received the message
 *				pReceiveBuffer - the buffer that came off the wire
 *				ppMessageBuffer - the destination for the built message (return)
 *				pdwMessageSize - the size of the built message (return)
 *
 *  DESCRIPTION:
 *				Builds a system message (from dplay.h) corresponding to dplays
 *				internal message (from dpmess.h)
 *
 *  RETURNS: the BuildXXX rval
 *
 */
HRESULT BuildPlayerSystemMessage(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,
	LPBYTE * ppMessageBuffer, DWORD * pdwMessageSize) 
{
	DWORD dwCmd;
	HRESULT hr = DP_OK;

	dwCmd  = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);

	switch (dwCmd)
	{
		case DPSP_MSG_PLAYERDATACHANGED: 
			hr = BuildDataChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_GROUPDATACHANGED:
			hr = BuildDataChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;
			
		case DPSP_MSG_PLAYERNAMECHANGED:
			hr = BuildNameChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_GROUPNAMECHANGED:
			hr = BuildNameChanged(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;

		case DPSP_MSG_CREATEPLAYER: 
			hr = BuildAddMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;

		case DPSP_MSG_CREATEGROUP: 
			hr = BuildAddMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			break;			

		case DPSP_MSG_DELETEPLAYER:
			hr = BuildDeleteMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,TRUE);
			break;


		case DPSP_MSG_DELETEGROUP:
			hr = BuildDeleteMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,FALSE);
			
			break;

		case DPSP_MSG_ADDPLAYERTOGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_ADDPLAYERTOGROUP);
			break;

		case DPSP_MSG_DELETEPLAYERFROMGROUP:			
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_DELETEPLAYERFROMGROUP);
			break;

		case DPSP_MSG_NAMESERVER:
			hr = BuildNameServerMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;

        case DPSP_MSG_SESSIONDESCCHANGED:
            hr = BuildSessionDescMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
                    pdwMessageSize);
            break;

		case DPSP_MSG_ADDSHORTCUTTOGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_ADDGROUPTOGROUP);
			break;
			
		case DPSP_MSG_DELETEGROUPFROMGROUP:
			hr = BuildPlayerGroupMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize,DPSYS_DELETEGROUPFROMGROUP);
			break;
			
		case DPSP_MSG_STARTSESSION:
			hr = BuildStartSessionMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;
			
		case DPSP_MSG_CHAT:
			hr = BuildChatMessage(pPlayer,pReceiveBuffer,ppMessageBuffer,
					pdwMessageSize);
			break;

		case DPSP_MSG_GROUPOWNERCHANGED:
			hr = BuildGroupOwnerChangedMessage(pPlayer,pReceiveBuffer,
					ppMessageBuffer,pdwMessageSize);
			break;

		default:
			ASSERT(FALSE);
			DPF_ERR("BUILD MESS: received unrecognized message");
			return E_UNEXPECTED;

	}
	return hr;	
} // BuildPlayerSystemMessage

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_HANDLER"

// this function forwards a player message to the destination player indicated in the message
HRESULT NS_ForwardPlayerMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer, DWORD dwMessageSize,
        DWORD dwSendFlags)
{
    HRESULT hr;
    LPMSG_PLAYERMESSAGE pPlayerMsg = (LPMSG_PLAYERMESSAGE) pReceiveBuffer;
    LPBYTE pMsg;

    ASSERT(pPlayerMsg);

    // extract the message
    pMsg = (LPBYTE)pPlayerMsg + sizeof(MSG_PLAYERMESSAGE);
    dwMessageSize -= sizeof(MSG_PLAYERMESSAGE);

	DPF(7,"Forwarding player message from id %d to id %d",pPlayerMsg->idFrom, pPlayerMsg->idTo);

	if (dwSendFlags & DPSEND_GUARANTEED)
	{
		// Put us in pending mode, so messages don't get delivered out of 
		// order. A message coming off the wire can get the dplay lock in the
		// window between the time we drop it and DP_Send takes the lock.
		this->dwFlags |= DPLAYI_DPLAY_PENDING;
	}

    LEAVE_DPLAY();

	// call send - it will push the bits through the wire for us
	hr = DP_Send((LPDIRECTPLAY)this->pInterfaces,pPlayerMsg->idFrom,
		pPlayerMsg->idTo, dwSendFlags, pMsg,dwMessageSize);

    ENTER_DPLAY();

    return hr;
} // NS_ForwardPlayerMessage

// a player has received a message. this can be either 1. a system message
// (e.g. new player announcment) or 2. a player-player message
// we package it up in the public dplay format, and put it on the message q
// fPlayerMessage is TRUE if it's player-player
HRESULT HandlePlayerMessage(LPDPLAYI_PLAYER pPlayer,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage, DWORD dwSendFlags) 
{
	HRESULT hr=DP_OK;
	LPDPLAYI_DPLAY this;
	LPMESSAGENODE pmsn=NULL; // we'll add this node to iplay's list of nodes
	LPMSG_PLAYERMESSAGE pmsg; // message cast from received buffer
	LPBYTE pMessageBuffer=NULL; // buffer we copy message into for storage

	this = pPlayer->lpDP;

    // in a secure session, player messages are routed through the server
    // so forward the message to the appropriate destination player
    if (SECURE_SERVER(this) && IAM_NAMESERVER(this))
    {
        // forward all remote player messages
        if (!(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
        {
			// currently we don't have a way of knowing if a received message was sent reliably.
			// but since we know that all secure messages are sent guaranteed, we can forward
			// this message reliably.
			dwSendFlags |= DPSEND_GUARANTEED;

            hr = NS_ForwardPlayerMessage(this, pReceiveBuffer, dwMessageSize, dwSendFlags);
            return hr;
        }
    }

	// alloc a message node
	pmsn = DPMEM_ALLOC(sizeof(MESSAGENODE));
    if (!pmsn) 
    {
    	DPF_ERR("could not handle player message - out of memory");
        return E_OUTOFMEMORY;
    }

	pmsg = (LPMSG_PLAYERMESSAGE)pReceiveBuffer;

	if (fPlayerMessage)
    {   // its a player - player message
		
        if (dwSendFlags & (DPSEND_SIGNED | DPSEND_ENCRYPTED))
        {
    	    // it's a secure message - convert it to the dplay system message format
		    hr = BuildSecureSystemMessage(pPlayer,pReceiveBuffer,&pMessageBuffer,&dwMessageSize,dwSendFlags);
		    if (FAILED(hr)) 
		    {
			    // its ok to fail this.  we fail when trying to distribute sysplayer
			    // announcments to players.
			    DPMEM_FREE(pmsn);
			    return DP_OK;
		    }            
		    pmsn->idFrom = 0; // system message

			DPF(5,"PlayerID %d received secure player message (Flags=0x%08x) from playerID %d size = %d\n",pPlayer->dwID,
						dwSendFlags, pmsg->idFrom,dwMessageSize);
        }
        else // unsecure player-player message
        {
		    // naked?
		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    // not naked
			    // if we're not naked, player to == player from is not allowed
			    if (pPlayer->dwID == pmsg->idFrom)		
			    {
				    DPF(7,"not delivering message w/ to == from");
				    DPMEM_FREE(pmsn);
				    return E_FAIL;
			    }
			    // subtract off the size of the to and from
			    dwMessageSize -=  sizeof(MSG_PLAYERMESSAGE); // size of user data
		    }

		    // need to make a copy of the off the wire message
		    pMessageBuffer = DPMEM_ALLOC(dwMessageSize);
	        if (!pMessageBuffer) 
	        {
	    	    DPF_ERR("could not handle player message - out of memory");
			    DPMEM_FREE(pmsn);
	            return E_OUTOFMEMORY;
	        }

		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    // not naked
			    // copy message into pMessageBuffer
			    memcpy(pMessageBuffer,pReceiveBuffer+sizeof(MSG_PLAYERMESSAGE),dwMessageSize);
		    }
		    else 
		    {
			    // copy naked message into pMessageBuffer
			    memcpy(pMessageBuffer,pReceiveBuffer,dwMessageSize);
		    }	

		    if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
		    {
			    pmsn->idFrom = pmsg->idFrom;						
		    }
		    else 
		    {
			    pmsn->idFrom = DPID_UNKNOWN;
		    }

#if 0
			DPF(5,"Player ID %d received player mess from player ID  %d size = %d - %s,%s\n",pPlayer->dwID,
						pmsg->idFrom,dwMessageSize,pMessageBuffer,pMessageBuffer+strlen(pMessageBuffer));
#endif						
			DPF(5,"Player ID %d received player mess from player ID  %d size = %d - \n",pPlayer->dwID,
						pmsg->idFrom,dwMessageSize);

        } // DPSEND_SIGNED || DPSEND_ENCRYPTED
	}
	else 
	{
    	// it's a system message - convert it to the dplay system message format
		hr = BuildPlayerSystemMessage(pPlayer,pReceiveBuffer,&pMessageBuffer,&dwMessageSize);
		if (FAILED(hr)) 
		{
			// its ok to fail this.  we fail when trying to distribute sysplayer
			// announcments to players.
			DPMEM_FREE(pmsn);
			return DP_OK;
		}
		pmsn->idFrom = 0;
	}

	DPF(7,"Putting message in apps queue");

	pmsn->idTo = pPlayer->dwID; 		
	pmsn->pNextMessage = NULL;
	pmsn->pMessage = pMessageBuffer;
	pmsn->dwMessageSize = dwMessageSize;

	if (!pmsn->pMessage)
	{
		ASSERT(FALSE);
		DPMEM_FREE(pmsn); // ack ! this should never fail!
		return E_FAIL;
	}

	this->nMessages++;

	// find last node on list, and stick pmsn behind it

	if(this->pLastMessage){
		this->pLastMessage->pNextMessage=pmsn;
		this->pLastMessage=pmsn;
	} else {
		this->pMessageList = pmsn;
		this->pLastMessage = pmsn;
	}

	// if player has event, trigger it
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	// all done...
	return hr;
} // HandlePlayerMessage

// we got a message addressed to a group.
// distribute it to all local players in that group
HRESULT DistributeGroupMessage(LPDPLAYI_DPLAY this,LPDPLAYI_GROUP pGroupTo,LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,BOOL fPlayerMessage,DWORD dwSendFlags)
{
	LPDPLAYI_GROUPNODE pGroupnode;
	UINT nPlayers;
	HRESULT hr;

	ASSERT(this->pSysPlayer);

	// how many players are we looking for
	pGroupnode = FindPlayerInGroupList(pGroupTo->pSysPlayerGroupnodes,this->pSysPlayer->dwID);
	if (!pGroupnode)
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}
	nPlayers = pGroupnode->nPlayers;

	// walk the list of groupnodes, looking for nPlayers local players to give
	// the message to
	pGroupnode = pGroupTo->pGroupnodes;
	while ((nPlayers > 0) && (pGroupnode))
	{
		if (pGroupnode->pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		{
			hr =  HandlePlayerMessage(pGroupnode->pPlayer,pReceiveBuffer,dwMessageSize,fPlayerMessage,dwSendFlags);
			nPlayers--;
		} // local
		
		pGroupnode = pGroupnode->pNextGroupnode;
	} // while
	
	ASSERT(0 == nPlayers);
	return DP_OK;
	
} // DistributeGroupMessage


// called by HandleEnumSessionsReply returns TRUE if pDesc1 and pDesc2
// are the same session
BOOL IsEqualSessionDesc(LPDPSESSIONDESC2 pDesc1,LPDPSESSIONDESC2 pDesc2) 
{
	if (IsEqualGUID(&(pDesc1->guidInstance),&(pDesc2->guidInstance)))
		return TRUE;

	return FALSE;
} // IsEqualSessionDesc

// this client called enum sessions.  the sp got a reply, we add that 
// to the list of known sessions
HRESULT HandleEnumSessionsReply(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer,LPVOID pvSPHeader) 
{
    LPMSG_ENUMSESSIONSREPLY pem;
	LPSESSIONLIST pNewNode=NULL, pExistingNode=NULL;
	LPWSTR lpsz;

	pem = (LPMSG_ENUMSESSIONSREPLY) pReceiveBuffer;

	// alloc a new session node
	pNewNode = DPMEM_ALLOC(sizeof(SESSIONLIST));
    if (!pNewNode) 
    {
    	DPF_ERR("could not enum reply - out of memory");
        return E_OUTOFMEMORY;
    }

	// copy the description from the receive buffer to the session node
	memcpy(&(pNewNode->dpDesc),&(pem->dpDesc),sizeof(DPSESSIONDESC2));

    // remember the version of the message
    pNewNode->dwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);

    // remember the sp header for the session
	if ((this->dwSPHeaderSize) && (pvSPHeader))
	{
		// store the blob
		pNewNode->pvSPMessageData = DPMEM_ALLOC(this->dwSPHeaderSize);
		if (!pNewNode->pvSPMessageData)
		{
            DPMEM_FREE(pNewNode);
			DPF_ERR("could not alloc sp blob");
			return E_OUTOFMEMORY;
		}

		// copy the last this->dwSPHeaderSize bytes off the end of the buffer
		memcpy(pNewNode->pvSPMessageData,pvSPHeader,this->dwSPHeaderSize);
	}

	// unpack strings
	if (pem->dwNameOffset)
	{
		GetString(&lpsz,(WCHAR *)(pReceiveBuffer + pem->dwNameOffset));
		pNewNode->dpDesc.lpszSessionName = lpsz;
	}

	// see if this session is in the list
	pExistingNode = this->pSessionList;
	while (pExistingNode)
	{
		if ( IsEqualSessionDesc(&(pExistingNode->dpDesc),&(pem->dpDesc)))
		{
			// it's in the list already, so just update the node
            break;
		}
		pExistingNode = pExistingNode->pNextSession;
	}

    if (!pExistingNode)
    {
	    // put the new session list on the front of the list
	    pNewNode->pNextSession = this->pSessionList;
	    this->pSessionList = pNewNode;
		// timestamp it
		pNewNode->dwLastReply = GetTickCount();
    }
    else
    {
		// HACKHACK -- myronth -- 3/12/97
		// If the lobby owns this object, don't copy in the new address
		// because it is bogus.  We can remove this if/else after AndyCo
		// gets rid of the global session list.
		if(!IS_LOBBY_OWNED(this))
		{
			// preserve link to the next node in the session list
			pNewNode->pNextSession = pExistingNode->pNextSession;

			// cleanup old strings
			if (pExistingNode->dpDesc.lpszSessionName)
			{
				DPMEM_FREE(pExistingNode->dpDesc.lpszSessionName);
			}

			// cleanup old sp header
			if (pExistingNode->pvSPMessageData)
			{
				DPMEM_FREE(pExistingNode->pvSPMessageData);
			}

			// update the existing node
			memcpy(pExistingNode, pNewNode, sizeof(SESSIONLIST));
		}
		else
		{
			// Free the new SessionName string
			if(pNewNode->dpDesc.lpszSessionName)
				DPMEM_FREE(pNewNode->dpDesc.lpszSessionName);
		}
		// ENDHACKHACK!!!! -- myronth

		// timestamp it
		pExistingNode->dwLastReply = GetTickCount();
		
        // get rid of the new node
        DPMEM_FREE(pNewNode);
    }

	return DP_OK;

} // HandleEnumSessionsReply


// either the player name or player data has changed
// extract the params from the message, and call idirectplay to handle it
HRESULT SP_HandleDataChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer)
{
	HRESULT hr = DP_OK;
	DWORD dwCmd;
	BOOL fPlayer = FALSE;
	DWORD dwID;

	dwID = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwPlayerID;	
	
	dwCmd = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
	
	switch (dwCmd)
	{
		case DPSP_MSG_PLAYERDATACHANGED: 
			fPlayer=TRUE;
			// fall through
		case DPSP_MSG_GROUPDATACHANGED:
		{
			LPVOID pvData;
			DWORD  dwDataSize;

			dwDataSize = ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataSize;
			pvData = pReceiveBuffer + ((LPMSG_PLAYERDATA)pReceiveBuffer)->dwDataOffset;
			// get dplay to set the data
			hr = InternalSetData((IDirectPlay *)this->pInterfaces,dwID,pvData,dwDataSize,
					0,fPlayer,FALSE);
			if (FAILED(hr))
			{
				DPF(0, "InternalSetData returned error! hr = 0x%08x", hr);
			}
					
			break;
		}
		
		case DPSP_MSG_PLAYERNAMECHANGED:
			fPlayer = TRUE;
		case DPSP_MSG_GROUPNAMECHANGED:
		{
			DPNAME PlayerName;
			LPWSTR pszShortName,pszLongName;
			
			PlayerName.dwSize = sizeof(DPNAME);

			if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset)
			{
				pszShortName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwShortOffset);
			}
			else 
			{
				pszShortName = (LPWSTR)NULL;
			}
			
			if (((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset)
			{
				pszLongName = (LPWSTR)(pReceiveBuffer + ((LPMSG_PLAYERNAME)pReceiveBuffer)->dwLongOffset);
			}
			else 
			{
				pszLongName = (LPWSTR)NULL;
			}

			PlayerName.lpszShortName = pszShortName;
			PlayerName.lpszLongName = pszLongName;			
			
			// get dplay to set the name
			hr = InternalSetName((IDirectPlay *)this->pInterfaces,dwID,&PlayerName,
				fPlayer,0,FALSE);
			if (FAILED(hr))
			{
				DPF(0, "InternalSetname returned error! hr = 0x%08x", hr);
			}

			break;
			
		}
					
		default:
			ASSERT(FALSE);			
			break;

	}

	return hr;

}  // HandlePlayerData

// session desc has changed
// extract the params from the message, and call idirectplay to handle it
HRESULT SP_HandleSessionDescChanged(LPDPLAYI_DPLAY this,LPBYTE pReceiveBuffer)
{
	HRESULT hr = DP_OK;
	DWORD dwCmd;
    LPDPSESSIONDESC2 lpsdDesc;

    dwCmd = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
	
    if (DPSP_MSG_SESSIONDESCCHANGED != dwCmd)
    {
        ASSERT(FALSE);
    }

    // fix up pointers in session desc on buffer to point to the strings 
    // on the buffer
    lpsdDesc = (LPDPSESSIONDESC2)(&((LPMSG_SESSIONDESC)pReceiveBuffer)->dpDesc);

    if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset)
	{
		lpsdDesc->lpszSessionName = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwSessionNameOffset);
	}
	else 
	{
		lpsdDesc->lpszSessionName = (LPWSTR)NULL;
	}
	
	if (((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset)
	{
		lpsdDesc->lpszPassword = (LPWSTR)(pReceiveBuffer + ((LPMSG_SESSIONDESC)pReceiveBuffer)->dwPasswordOffset);
	}
	else 
	{
		lpsdDesc->lpszPassword = (LPWSTR)NULL;
	}
		
	// get dplay to set the session desc
	hr = InternalSetSessionDesc((IDirectPlay *)this->pInterfaces,lpsdDesc, 0, FALSE);
	if (FAILED(hr))
	{
		ASSERT(FALSE);
	}

	return hr;

}  // HandleSessionDescChanged


HRESULT HandleChatMessage(LPDPLAYI_DPLAY this, LPBYTE pReceiveBuffer,
			DWORD dwMessageSize)
{
	LPMSG_CHAT			lpmsg = (LPMSG_CHAT)pReceiveBuffer;
	BOOL				bToGroup = FALSE; // message is to a group	?
	DWORD				dwIDFrom, dwIDTo;
	LPDPLAYI_PLAYER		pPlayer;
	LPDPLAYI_GROUP		pGroup;
	HRESULT				hr=DP_OK;
	

	// make sure it's from a valid player					
	dwIDFrom = lpmsg->dwIDFrom;
	pPlayer = PlayerFromID(this,dwIDFrom);
	if (!VALID_DPLAY_PLAYER(pPlayer)) 
	{
		DPF_ERR("-------received player message FROM invalid player id!!");
		return DPERR_INVALIDPLAYER;
	}

	// see who the message is for
	dwIDTo = lpmsg->dwIDTo;
	pPlayer = PlayerFromID(this,dwIDTo);
	if (!VALID_DPLAY_PLAYER(pPlayer)) 
	{
		// see if it's to a group
		pGroup = GroupFromID(this,dwIDTo);
		if (!VALID_DPLAY_GROUP(pGroup))
		{
			DPF_ERR("got message for bad player / group");
			return DPERR_INVALIDPLAYER;
		}
		bToGroup = TRUE;
		pPlayer = (LPDPLAYI_PLAYER)pGroup;
	}

	if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
	{
		// ignore it					
	}
	else 
	{
		if (bToGroup)
		{
			// Send the message to the group
			hr = DistributeGroupMessage(this,(LPDPLAYI_GROUP)pPlayer,pReceiveBuffer,
					dwMessageSize, FALSE, 0);						
		} 
		else 
		{
			// Send the message directly to the player
			hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,
					FALSE, 0);
		}
	}

	return hr;

}  // HandleChatMessage


// we got a message w/ no to / from data
// pick the 1st local non-sysplayer off the player list, 
// to deliver it to
LPDPLAYI_PLAYER GetRandomLocalPlayer(LPDPLAYI_DPLAY this)
{
	LPDPLAYI_PLAYER pPlayer;
	BOOL bFound=FALSE;
	
	pPlayer = this->pPlayers;
	
	while (pPlayer && !bFound)
	{
		if ((pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL) && 
			!(pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
		{
			bFound = TRUE;
			DPF(4,"found local player id = %d to deliver naked message to",pPlayer->dwID);
		}
		else 
		{
			pPlayer = pPlayer->pNextPlayer;
		}
	}
	
	if (!bFound)
	{
		pPlayer = NULL;
		DPF(1,"no local player found to take delivery of naked message");
	}
	
	return pPlayer;		
} // GetRandomLocalPlayer

/*
 ** PutOnPendingList
 *
 *  CALLED BY: DP_SP_HandleMessage
 *
 *  PARAMETERS:
 *		this - pointer to dplay object
 *		dwCommand - message type
 *
 *  DESCRIPTION:
 *		Determines if specified message needs to be put on the pending list.
 *
 *  RETURNS: TRUE if message belongs on the pending list, FALSE otherwise.
 *
 */
BOOL PutOnPendingList(LPDPLAYI_DPLAY this, DWORD dwCommand)
{
      switch (dwCommand) {

		// let addforwardreply through - we might have been denied access
		case DPSP_MSG_ADDFORWARDREPLY:
		// let DPSP_MSG_ENUMPLAYERSREPLY through - we need this to get out of pending mode...
		case DPSP_MSG_ENUMPLAYERSREPLY:
		// let packets through also - they may be packetized enumplayersreplys
		case DPSP_MSG_PACKET:
		// let packet data through, if they need to pend they will pend when assembled.
		case DPSP_MSG_PACKET2_DATA:
		// let ACKs through for PACKET2 Data otherwise our send won't complete.
		case DPSP_MSG_PACKET2_ACK:
		// another version of enumplayersreply
		case DPSP_MSG_SUPERENUMPLAYERSREPLY:
		// pend other messages while waiting for player replay.
		case DPSP_MSG_REQUESTPLAYERREPLY:
		// allow challenge messages to pass through during logon
		case DPSP_MSG_CHALLENGE:
		// allow the access granted message to pass through during logon
		case DPSP_MSG_ACCESSGRANTED:
		// allow the logon denied message to pass through during logon
		case DPSP_MSG_LOGONDENIED:
		// allow the authentication error message to pass through during logon
		case DPSP_MSG_AUTHERROR:
		// allow the key exchange reply to pass through during logon
		case DPSP_MSG_KEYEXCHANGEREPLY:
            return FALSE;
			
        // put all other messages on the pending list
        default:
            return TRUE;
        }
}  // PutOnPendingList

#undef DPF_MODNAME
#define DPF_MODNAME	"GetMessageCommand"

/*
 ** GetMessageCommand
 *
 *  CALLED BY: DP_SP_HandleMessage
 *
 *  PARAMETERS:
 *		this - pointer to dplay object
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pdwCommand - pointer to dwCommand to be filled in by this function
 *      pdwVersion - pointer to dwVersion to be filled in by this function
 *
 *  DESCRIPTION:
 *
 *		Extracts the command and version information from the incoming message
 *
 *
 *  RETURNS: DP_OK, DPERR_INVALIDPARAMS, DPERR_UNSUPPORTED
 *
 */

HRESULT GetMessageCommand(LPDPLAYI_DPLAY this, LPVOID pReceiveBuffer, DWORD dwMessageSize, 
    LPDWORD pdwCommand, LPDWORD pdwVersion)
{
    ASSERT(pdwCommand && pdwVersion);

    // initialize in case we fail
    *pdwCommand = *pdwVersion = 0;

    // extract command
	if ( (dwMessageSize < sizeof(DWORD)) || IS_PLAYER_MESSAGE(pReceiveBuffer))
	{
		*pdwCommand = DPSP_MSG_PLAYERMESSAGE;
	}
	else 
	{
		if (dwMessageSize < sizeof(MSG_SYSMESSAGE))
		{
			DPF(0,"message size too small - %d bytes\n",dwMessageSize);
			return DPERR_INVALIDPARAMS;
		}
		
	    *pdwCommand = GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pReceiveBuffer);
		*pdwVersion = GET_MESSAGE_VERSION((LPMSG_SYSMESSAGE)pReceiveBuffer);
		if (*pdwVersion < 1)
		{
			// version 1 is where we implemented on the wire versioning and extensibility
			// any pre version 1 (EUBETA 1 and prior of dplay3) bits are out of luck
			DPF_ERR("Encountered unsupported version of DirectPlay - not responding");
			return DPERR_UNSUPPORTED;
		}
	}

    return DP_OK;
} // GetMessageCommand

#ifdef DEBUG
void ValidateDplay(LPDPLAYI_DPLAY gpThisList)
{
	LPDPLAYI_PLAYER pPlayer,pPlayerCheck;
	LPDPLAYI_GROUP pGroup,pGroupCheck;
	LPDPLAYI_DPLAY this = gpThisList;
	
	while (this)
	{
		pPlayer = this->pPlayers;
		while (pPlayer)
		{
			pPlayerCheck = PlayerFromID(this,pPlayer->dwID);
			if (!VALID_DPLAY_PLAYER(pPlayerCheck))
			{
				DPF_ERR("found invalid player in player list");
				ASSERT(FALSE);
			}
			pPlayer = pPlayer->pNextPlayer;
		}

		pGroup = this->pGroups;
		while (pGroup)
		{
			pGroupCheck = GroupFromID(this,pGroup->dwID);
			if (!VALID_DPLAY_GROUP(pGroupCheck))
			{
				DPF_ERR("found invalid group in group list");			
				ASSERT(FALSE);
			}
			pGroup = pGroup->pNextGroup;
		}

		this = this->pNextObject;
	} // this

} // ValidateDplay
#endif // DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"InternalHandleMessage"


//	a-josbor: a little routine for updating chatter count
VOID UpdateChatterCount(LPDPLAYI_DPLAY this, DPID dwIDFrom)
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_PLAYER pSysPlayer;
		
	pPlayer = PlayerFromID(this,dwIDFrom);
	if (VALID_DPLAY_PLAYER(pPlayer) && !(pPlayer->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)) 
	{
		// get the sys player for this player.  It's the only
		//	one who gets pinged
		pSysPlayer = PlayerFromID(this, pPlayer->dwIDSysPlayer);
		if (VALID_DPLAY_PLAYER(pSysPlayer))
		{
			pSysPlayer->dwChatterCount++;
			DPF(9,"++Chatter for Player %d == %d\n", pPlayer->dwIDSysPlayer, pSysPlayer->dwChatterCount);
		}
	}
}
/*
 ** InternalHandleMessage
 *
 *  CALLED BY: DP_SP_HandleMessage and other internal dplay functions.
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *      dwSendFlags - flags that were passed to SP_Send (e.g. DPSEND_ENCRYPTED).  used
 *					by security code to process messages that are delivered locally w/o
 *					needing to route them through the nameserver
 *
 *  DESCRIPTION:
 *
 *		This function routes a message to the appropriate handler.
 *
 *
 *  RETURNS: handler return
 *
 */

HRESULT DPAPI InternalHandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader, DWORD dwSendFlags)
{
    HRESULT hr=DP_OK;
    DWORD dwCommand;
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_GROUP pGroup;
	DWORD dwIDTo,dwIDFrom; 
	LPDPLAYI_DPLAY this;
	DWORD dwVersion; // version of the message we received
    DPID dpidFrom=0;
	
    ENTER_DPLAY();
	
#ifdef DEBUG	
	// make sure dplay is a happy place
	ValidateDplay(gpObjectList);
#endif // DEBUG
	
	// make sure we don't get hosed by SP
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
	        LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
		// see if dplay is closed?
		if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
		{
            LEAVE_DPLAY();
 			DPF(5,"dplay closed - ignoring messages");
            return DP_OK;
		}

		if (!VALID_STRING_PTR(pReceiveBuffer,dwMessageSize)) 
		{
            LEAVE_DPLAY();
 			DPF_ERR("sp passed invalid buffer!");
            return DPERR_INVALIDPARAMS;
		}

		if ((DPSP_HEADER_LOCALMSG != pvSPHeader) && 
            (pvSPHeader) && (!VALID_STRING_PTR(pvSPHeader,this->dwSPHeaderSize)))
		{
            LEAVE_DPLAY();
 			DPF_ERR("sp passed invalid header!");
            return DPERR_INVALIDPARAMS;
		}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

    // Get the command and version information from the message
    hr = GetMessageCommand(this, pReceiveBuffer, dwMessageSize, &dwCommand, &dwVersion);
    if (FAILED(hr))
    {
        LEAVE_DPLAY();
        return hr;
    }

    // if it is a secure message
    if ((DPSP_MSG_SIGNED == dwCommand))
    {
        LPMSG_SECURE pSecureMsg = (LPMSG_SECURE)pReceiveBuffer;

        // Verify the secure message:
        // if signed, verify the signature
        // if encrypted, decrypt the message in place
        hr = VerifyMessage(this, pReceiveBuffer, dwMessageSize);
        if (FAILED(hr))
        {
            DPF(0,"Secure message verification failed - dropping message: hr=0x%08x",hr);
            LEAVE_DPLAY();
            return DP_OK;
        }

        // Message was OK
        if (DPSP_MSG_SIGNED == dwCommand) 
        {
            dwSendFlags |= DPSEND_SIGNED;
        }

		if (pSecureMsg->dwFlags & DPSECURE_ENCRYPTEDBYCAPI)
        {
            dwSendFlags |= DPSEND_ENCRYPTED;
        }

        dpidFrom = pSecureMsg->dwIDFrom;

        // point to the embedded message (excluding the sp header)
        pReceiveBuffer = (LPBYTE)pSecureMsg+ pSecureMsg->dwDataOffset + this->dwSPHeaderSize;
        dwMessageSize = pSecureMsg->dwDataSize - this->dwSPHeaderSize;
        // Get the command and version information for this message
        hr = GetMessageCommand(this, pReceiveBuffer, dwMessageSize, &dwCommand, &dwVersion);
        if (FAILED(hr))
        {
            LEAVE_DPLAY();
            return hr;
        }
    }

    // regulate messages, if session is secure
    if (SECURE_SERVER(this))
    {
        if (dwSendFlags & DPSEND_PENDING)
        {
			// message is from the pending queue

			ASSERT(this->dwFlags & DPLAYI_DPLAY_EXECUTINGPENDING);
			// safe to process...
        }
        else
        {
            // message just came off the wire

			// make sure it is ok to process this message
            if ((DPSP_HEADER_LOCALMSG != pvSPHeader) &&
                !(dwSendFlags & (DPSEND_SIGNED|DPSEND_ENCRYPTED)) &&
                !PermitMessage(dwCommand,dwVersion))
            {
                // no
                DPF(1,"ignoring unsigned message dwCommand=%d dwVersion=%d",dwCommand,dwVersion);
                LEAVE_DPLAY();
                return DP_OK;
            }
        }
    }

    // If we are in pending mode (waiting for the nametable or waiting for a guaranteed 
    // send to complete), allow only certain messages to be processed immediately - all 
    // others go on the pending list
	if ((this->dwFlags & DPLAYI_DPLAY_PENDING) && !(dwSendFlags & DPSEND_PENDING))
    {
        if (PutOnPendingList(this, dwCommand))
	    {
	    	if(this->pProtocol){
		    	// Before we pend this command we need to tell the protocol if a player
		    	// has been deleted.  We want to stop any ongoing sends now.
		    	if(dwCommand == DPSP_MSG_DELETEPLAYER){
		    		LPMSG_PLAYERMGMTMESSAGE pmsg=(LPMSG_PLAYERMGMTMESSAGE)pReceiveBuffer;
		    		if(PlayerFromID(this,pmsg->dwPlayerID))
		    		{
			    		ProtocolPreNotifyDeletePlayer(this, pmsg->dwPlayerID);
			    	} else {
			    		DPF(1,"pending deleteplayer message for id %x, not valid player\n",pmsg->dwPlayerID);
			    	}
		    	}
	    	}
	    	// Pend the command.
			dwSendFlags |= DPSEND_PENDING;
			DPF(7,"Pushing message [%d] on the pending queue",dwCommand);
		    hr =  PushPendingCommand(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
		    LEAVE_DPLAY();
		    return hr;
	    }
    }
	
	// if we reach here pending stuff is done, so clear the flag
	dwSendFlags &= ~DPSEND_PENDING;

	// update the perfdata
	if (this->pPerfData)
	{
		this->pPerfData->nReceiveBPS += dwMessageSize;
		this->pPerfData->nReceivePPS++;
	}
	
	DPF(8,"handler - received command %d, version %d\n",dwCommand,dwVersion);


	// a-josbor: unfortunately, not all messages have a dwFrom field,
	//	so we need to case out all the ones that do, and increment
	//	the chatter count for the sending player.  NOTE! this means
	//	that you should add this call to any new message types that
	//	come along and have a dwFrom field.
    switch (dwCommand)											 
    {
		// these messages should only go to namesrvr
        case DPSP_MSG_ENUMSESSIONS:															
                
                if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
                	DPLAYI_PLAYER_NAMESRVR)) 
				{
					DPF(1,"namesrvr - got enumsessions request");
					hr = NS_HandleEnumSessions(this,pvSPHeader,pReceiveBuffer,dwSendFlags);
				}
	                
                break;
        
        case DPSP_MSG_ENUMPLAYER:

                if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
                	DPLAYI_PLAYER_NAMESRVR))
				{
					DPF(1,"namesrvr - got enumplayers request from system version %d",dwVersion);
					hr = NS_HandleEnumPlayers(this,pvSPHeader,dpidFrom,dwVersion);
                }

                break;

	   	case DPSP_MSG_REQUESTGROUPID:
        case DPSP_MSG_REQUESTPLAYERID: 
				
				if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
					DPLAYI_PLAYER_NAMESRVR))
				{
                    DWORD dwFlags=0;
                    BOOL fCheckPlayerFlags = FALSE;

					DPF(1,"namesrvr - got newplayerid request");

                    // look for flags if version is later than DX3
                    if (DPSP_MSG_DX3VERSION != dwVersion)
                    {
                        dwFlags = ((LPMSG_REQUESTPLAYERID)pReceiveBuffer)->dwFlags;
                        fCheckPlayerFlags = TRUE;
                    }
					hr = NS_HandleRequestPlayerID(this,pvSPHeader,dwCommand, dwFlags, 
                        fCheckPlayerFlags,dwVersion);
				}
				
				break;

		case DPSP_MSG_ADDFORWARDREQUEST:

				if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
					DPLAYI_PLAYER_NAMESRVR))
				{
					DPF(1,"namesrvr - got forward add player request");
					hr = NS_HandleAddForwardRequest(this,pReceiveBuffer,dwMessageSize,pvSPHeader,dpidFrom);
				}
				else 
				{
					ASSERT(FALSE); // only namesrvr should get this!
				}
				
				break;

		// handle reply from nameserver
		case DPSP_MSG_ENUMSESSIONSREPLY :

				DPF(1,"got enumsessions reply");
				hr = HandleEnumSessionsReply(this,pReceiveBuffer,pvSPHeader);

				break;

		case DPSP_MSG_REQUESTPLAYERREPLY: 
		case DPSP_MSG_SUPERENUMPLAYERSREPLY:				
		case DPSP_MSG_ENUMPLAYERSREPLY:
        case DPSP_MSG_ADDFORWARDREPLY:

				hr = HandleReply(this, pReceiveBuffer, dwMessageSize, dwCommand, pvSPHeader);
                break;

		case DPSP_MSG_PLAYERDATACHANGED: 
		case DPSP_MSG_GROUPDATACHANGED:
		case DPSP_MSG_PLAYERNAMECHANGED:
		case DPSP_MSG_GROUPNAMECHANGED:
		case DPSP_MSG_SESSIONDESCCHANGED:		
		case DPSP_MSG_CREATEPLAYER:
		case DPSP_MSG_DELETEPLAYER:
		case DPSP_MSG_ADDPLAYERTOGROUP:
 		case DPSP_MSG_DELETEPLAYERFROMGROUP:
		case DPSP_MSG_CREATEGROUP:
		case DPSP_MSG_DELETEGROUP:
		case DPSP_MSG_NAMESERVER:
		case DPSP_MSG_ADDSHORTCUTTOGROUP:
		case DPSP_MSG_DELETEGROUPFROMGROUP:
		case DPSP_MSG_CREATEPLAYERVERIFY:

				if (!this->lpsdDesc)
				{
					DPF(4,"received player mgmt message - no session open - ignoring");
					break;
				}
								
				hr =  SP_HandlePlayerMgmt(this->pSysPlayer,pReceiveBuffer,dwMessageSize,pvSPHeader);
				break;

		case DPSP_MSG_MULTICASTDELIVERY:
				{
					// transmogrify this into a player-group message
					// we currently have
					//   play xx xx xx xx 
					//	DPID  idGroupTo;
					//	DPID  idPlayerFrom;
					//	DWORD dwMessageOffset;
					// we need 
					//  DPID  idFrom
					//  DPID  idTo
					//  CHAR  Message[]
					//  we will do this by going to dwMessageOffset, and working backwards
					//  to build the correct header and then re-indicating...
					LPMSG_PLAYERMESSAGE pPlayerMessage;
					LPMSG_MULTICASTDELIVERY pMulticastDelivery;
					DWORD  dwPlayerMessageSize;
					DPID  idGroupTo;
					DPID  idPlayerFrom;
					
					DWORD dwMessageOffset;
					DWORD dwMulticastCommand=DPSP_MSG_PLAYERMESSAGE;

					pMulticastDelivery = (LPMSG_MULTICASTDELIVERY)pReceiveBuffer;
					idGroupTo		   = pMulticastDelivery->idGroupTo;
					idPlayerFrom	   = pMulticastDelivery->idPlayerFrom;
					dwMessageOffset    = pMulticastDelivery->dwMessageOffset;

					hr=GetMessageCommand(this, pReceiveBuffer+dwMessageOffset, dwMessageSize-dwMessageOffset, &dwMulticastCommand, &dwVersion);

					if(dwMulticastCommand==DPSP_MSG_PLAYERMESSAGE){
						// Its a player message, make it look like one, prepend From/To
						pPlayerMessage         = (LPMSG_PLAYERMESSAGE)(pReceiveBuffer+dwMessageOffset-sizeof(MSG_PLAYERMESSAGE));
						pPlayerMessage->idFrom = idPlayerFrom;
						pPlayerMessage->idTo   = idGroupTo;
						dwPlayerMessageSize    = dwMessageSize - dwMessageOffset + sizeof(MSG_PLAYERMESSAGE);
						hr=InternalHandleMessage(pISP,(PCHAR)pPlayerMessage,dwPlayerMessageSize,pvSPHeader,dwSendFlags);
					} else {
						// Its a system message already, just pass it on.
						hr=InternalHandleMessage(pISP,pReceiveBuffer+dwMessageOffset, dwMessageSize-dwMessageOffset, pvSPHeader, dwSendFlags);
					}
				}
				break;

		case DPSP_MSG_PLAYERWRAPPER:

				DPF(2,"got wrapped player message...");
				
				// strip off the wrapper
			   	pReceiveBuffer += sizeof(MSG_SYSMESSAGE);
				dwMessageSize -= sizeof(MSG_SYSMESSAGE);
				// fall through...
				
		case DPSP_MSG_PLAYERMESSAGE:
			{
				BOOL bToGroup = FALSE; // message is to a group	?
				
				if (!this->lpsdDesc)
				{
					DPF_ERR("player - player message thrown away - session closed");
					break;
				}

				
				if (!(this->lpsdDesc->dwFlags & DPSESSION_NOMESSAGEID))
				{
					// a-josbor: increment our chatter count
					// note, we can only do this if we have a from id
					dwIDFrom = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idFrom;

					// make sure it's from a valid player					
					pPlayer = PlayerFromID(this,dwIDFrom);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
						DPF(0,"----received player message FROM invalid player id = %d!!",dwIDFrom);
						break;
			        }
			        
					UpdateChatterCount(this, dwIDFrom);

					// see who the message is for
					dwIDTo = ((LPMSG_PLAYERMESSAGE)pReceiveBuffer)->idTo;
					pPlayer = PlayerFromID(this,dwIDTo);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
			        	// see if it's to a group
						pGroup = GroupFromID(this,dwIDTo);
						if (!VALID_DPLAY_GROUP(pGroup))
						{
							DPF(0,"----received player message TO invalid id = %d!!",dwIDFrom);
							break;
						}
						bToGroup = TRUE;
						pPlayer = (LPDPLAYI_PLAYER)pGroup;
					}
				}
				else 
				{	// message is raw

					if (dwSendFlags & DPSEND_SIGNED)
					{
						ASSERT(FALSE);
						DPF_ERR("A signed player message arrived raw - dropping message");
						hr = DPERR_UNSUPPORTED;
						break;
					}

					pPlayer = GetRandomLocalPlayer(this);
			        if (!VALID_DPLAY_PLAYER(pPlayer)) 
			        {
						DPF_ERR("could not find local player to deliver naked message to");
						break;
			        }
				}
				if (pPlayer->dwFlags & DPLAYI_PLAYER_SYSPLAYER)	
				{
					// ignore it					
				}
				else 
				{
					if (bToGroup)
					{
						hr = DistributeGroupMessage(this,(LPDPLAYI_GROUP)pPlayer,pReceiveBuffer,
							dwMessageSize,TRUE,dwSendFlags);						
					} 
					else 
					{
						hr = HandlePlayerMessage(pPlayer,pReceiveBuffer,dwMessageSize,
							TRUE,dwSendFlags);
					}
				}
			
			}  // DPSP_MSG_PLAYERMESSAGE:

			break;
				
		case DPSP_MSG_PACKET:

				if (!this->lpsdDesc)
				{
					DPF_ERR("packet thrown away - session closed");
					break;
				}
		
				hr = HandlePacket(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
				DPF(4,"handler - received packet");
				break;

		case DPSP_MSG_PACKET2_DATA:
		case DPSP_MSG_PACKET2_ACK:
				hr = HandlePacket(this,pReceiveBuffer,dwMessageSize,pvSPHeader);
				DPF(4,"handler - received packet");
				break;
	
		case DPSP_MSG_PING:
		case DPSP_MSG_PINGREPLY:
	
				if (!this->lpsdDesc)
				{
					DPF_ERR("ping thrown away - session closed");
					break;
				}

				// a-josbor: update our chatter count
				dwIDFrom = ((LPMSG_PING)pReceiveBuffer)->dwIDFrom;
				UpdateChatterCount(this, dwIDFrom);

				hr = HandlePing(this,pReceiveBuffer,pvSPHeader);
				break;
				
		case DPSP_MSG_YOUAREDEAD:
				
				// as of DX5a, this message is no longer being sent.  there was
				// a race condition that could cause all players in the session 
				// to be disconnected.  
				DPF_ERR("UH OH, SOMEONE IN THE GAME THINKS I'M DEAD");
			
				// ISSUE: should we do this regardless of whether we think
				// we're the host (consider if the game has become fragmented...)
				if (!IAM_NAMESERVER(this))hr = HandleSessionLost(this);
			
				break;

            // @@@@@@@@@@@@@@@@@@@@@@@@ SECURITY @@@@@@@@@@@@@@@@@@@@@@
            //
            // Client side messages
            //
        case DPSP_MSG_CHALLENGE:
            this->LoginState = DPLOGIN_PROGRESS;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_ACCESSGRANTED:
            //
            // Receive server's OK on our authentication request
            //
            this->LoginState = DPLOGIN_ACCESSGRANTED;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_LOGONDENIED:
            this->LoginState = DPLOGIN_LOGONDENIED;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
			return hr;
            break;

        case DPSP_MSG_AUTHERROR:
            this->LoginState = DPLOGIN_ERROR;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed 
			return hr;
            break;

		case DPSP_MSG_KEYEXCHANGEREPLY:
            this->LoginState = DPLOGIN_KEYEXCHANGE;
			// this will set the appropriate event so the blocked
			// thread (see dpsecure.c) can process reply
			hr = HandleAuthenticationReply(pReceiveBuffer,dwMessageSize);
			// we just return here, since we dropped the dplay lock 
			// to allow the async reply to be processed
            return hr;
			break;

            //
            // Server side messages
            //
        case DPSP_MSG_NEGOTIATE:
            hr = SendAuthenticationResponse(this, (LPMSG_AUTHENTICATION)pReceiveBuffer, pvSPHeader);
            break;

        case DPSP_MSG_CHALLENGERESPONSE:
            hr = SendAuthenticationResponse (this, (LPMSG_AUTHENTICATION)pReceiveBuffer, pvSPHeader);
            break;

		case DPSP_MSG_KEYEXCHANGE:
			hr = SendKeyExchangeReply(this, (LPMSG_KEYEXCHANGE)pReceiveBuffer, dpidFrom, pvSPHeader);
			break;

        // @@@@@@@@@@@@@@@@@@@@@@@@ END SECURITY @@@@@@@@@@@@@@@@@@@@@@
		
		case DPSP_MSG_ASK4MULTICASTGUARANTEED:
			dwSendFlags |= DPSEND_GUARANTEED;

			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pReceiveBuffer)->idPlayerFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = DoMulticast(this,(LPMSG_ASK4MULTICAST)pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
			break;
		
		case DPSP_MSG_ASK4MULTICAST:

			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_ASK4MULTICAST)pReceiveBuffer)->idPlayerFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = DoMulticast(this,(LPMSG_ASK4MULTICAST)pReceiveBuffer,dwMessageSize,pvSPHeader,dwSendFlags);
			break;
			
		case DPSP_MSG_CHAT:

			// a-josbor: update our chatter count
			dwIDFrom = ((LPMSG_CHAT)pReceiveBuffer)->dwIDFrom;
			UpdateChatterCount(this, dwIDFrom);

			hr = HandleChatMessage(this, pReceiveBuffer, dwMessageSize);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}
			break;

		case DPSP_MSG_DIEPIGGY:
		
			DPF_ERR("  THIS IS ONE DEAD PIGGY.  CALL ANDYCO x62693 ");
#ifdef DIE_PIG			
			DEBUG_BREAK();
#endif 
			
			break;
			
		case DPSP_MSG_ADDFORWARD:
			if ((this->pSysPlayer) && (this->pSysPlayer->dwFlags & 
				DPLAYI_PLAYER_NAMESRVR))
			{
				DPF(1, "Hey! I got an ADDFORWARD, but I'm the NameServer!  Something's wrong...");
			}

			hr = SP_HandleAddForward(this,pReceiveBuffer,pvSPHeader,dpidFrom,dwVersion);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;
			
		case DPSP_MSG_ADDFORWARDACK:
			hr = NS_HandleAddForwardACK(this,(LPMSG_ADDFORWARDACK)pReceiveBuffer);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;

		case DPSP_MSG_IAMNAMESERVER:
			hr = NS_HandleIAmNameServer(this, (LPMSG_IAMNAMESERVER)pReceiveBuffer, pvSPHeader);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}

			break;

		case DPSP_MSG_VOICE:
			hr=HandleVoiceMessage(this, pReceiveBuffer, dwMessageSize, dwSendFlags);
			if(FAILED(hr))
			{
				ASSERT(FALSE);
			}
			break;

        default:																   
                DPF(1,"received unrecognized command - %d\n",dwCommand);
                break;
    }
	
    LEAVE_DPLAY();
	// always return DP_OK here, since the sp shouldn't be handling our internal
	// errors
    return DP_OK;

} // InternalHandleMessage


#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SP_HandleMessage"

/*
 ** DP_SP_HandleMessage
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *
 *  DESCRIPTION:
 *
 *		when an sp receives a message, it calls this fn. this is where dplay receives data.
 *
 *
 *  RETURNS: return code from InternalHandleMessage.
 *
 */

HRESULT DPAPI DP_SP_HandleMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	LPDPLAYI_DPLAY this;
	HRESULT hr;

    ENTER_DPLAY();
	
	// make sure we don't get hosed by SP
    TRY
    {
		this = DPLAY_FROM_INT(pISP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
	        LEAVE_DPLAY();
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			return hr;
		}
		
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );
        LEAVE_DPLAY();
        return DPERR_INVALIDPARAMS;
    }

	// if we're closing, don't handle any messages.  Fail silently
	if (this->dwFlags & DPLAYI_DPLAY_CLOSED)
	{
		DPF(8,"In HandleMessage after call to Close.  Ignoring...");
		LEAVE_DPLAY();
		return DP_OK;
	}
		
	if(this->pProtocol){
		LEAVE_DPLAY();
		// Protocol might want this, check, returns DPERR_NOTHANDLED if not wanted.
		hr=DP_SP_ProtocolHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader);
	} else {
		// no protocol, force InternalHandleMessage.
		hr=DPERR_NOTHANDLED;
		LEAVE_DPLAY();
	}

	if(hr==DPERR_NOTHANDLED){
		// Protocol didn't consume the receive, tell regular handler.
		hr=InternalHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader, 0);
	}
	
	return hr;

} // DP_SP_HandleMessage

/*
 ** DP_SP_HandleNonProtocolMessage
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP - direct play int pointer
 *		pReceiveBuffer - buffer received off wire
 *		dwMessageSize - size of buffer
 *		pvSPHeader - sp's message header.  assumed to be this->dwSPHeaderSize bytes.
 *
 *  DESCRIPTION:
 *
 *		We are sending a message to ourselves, so don't let the protocol crack it.
 *
 *
 *  RETURNS: return code from InternalHandleMessage.
 *
 */

HRESULT DPAPI DP_SP_HandleNonProtocolMessage(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	return InternalHandleMessage(pISP, pReceiveBuffer, dwMessageSize, pvSPHeader, 0);

} // DP_SP_HandleNonProtocolMessage

VOID QueueMessageNodeOnReceiveList(LPDPLAYI_DPLAY this, LPMESSAGENODE pmsn, LPDPLAYI_PLAYER pPlayer)
{
	ENTER_DPLAY();
	
	this->nMessages++;

	pmsn->pNextMessage=NULL;

	// find last node on list, and stick pmsn behind it

	if(this->pLastMessage){
		this->pLastMessage->pNextMessage=pmsn;
		this->pLastMessage=pmsn;
	} else {
		this->pMessageList = pmsn;
		this->pLastMessage = pmsn;
	}
	
	// if player has event, trigger it-- ISSUE:need refcount on player!
	if (pPlayer->hEvent) 
	{
		DPF(9,"triggering player event");
		SetEvent(pPlayer->hEvent);		
	}

	LEAVE_DPLAY();
	
}

VOID QueueSendCompletion(LPDPLAYI_DPLAY this, PSENDPARMS psp)
{

	psp->msn.pMessage = (LPVOID)&psp->dwType;
	psp->msn.dwMessageSize = sizeof(DPMSG_SENDCOMPLETE);
	psp->msn.idFrom = DPID_SYSMSG;
	psp->msn.idTo = psp->idFrom;
	psp->dwType=DPSYS_SENDCOMPLETE;
	QueueMessageNodeOnReceiveList(this, &psp->msn, psp->pPlayerFrom);
}

/*
 ** DP_SP_SendComplete
 *
 *  CALLED BY: service provider
 *
 *  PARAMETERS:
 *		pISP             - direct play int pointer
 *      lpDPContext      - context we gave for the send
 *      CompletionStatus - status of the send
 *
 *  DESCRIPTION:
 *
 *		When an asynchronous message is completely sent, the SP calls us back to notify us.
 *
 *
 *  RETURNS: none.
 *
 */

VOID DPAPI DP_SP_SendComplete(IDirectPlaySP * pISP, LPVOID lpDPContext, HRESULT CompletionStatus)
{
	PSENDPARMS psp;

	LPDPLAYI_DPLAY this;

    ENTER_DPLAY();

	this = DPLAY_FROM_INT(pISP);

	psp=pspFromContext(this, lpDPContext,FALSE); 	
									//		|
									// Completion has a refcount, don't need another.

	ASSERT(psp);

	if(psp) {

		EnterCriticalSection(&psp->cs);
		
		psp->nComplete++;
		
		// Status set to DP_OK in Send call, if we get a different status, update it.
		// Note, the last non-ok status is the one returned.
		// Group sends are always ok unless out of memory!
		if((CompletionStatus != DP_OK) && ((!psp->pGroupTo)||(psp->pGroupTo && CompletionStatus==DPERR_NOMEMORY)) ){
			psp->hr=CompletionStatus;
		}
		
		LeaveCriticalSection(&psp->cs);
		
		pspDecRef(this, psp); // if ref hits zero, posts completion to application.

	} else {
		DPF(0,"ERROR:completion of already reassigned context?\n");
		ASSERT(0);
	}
	
	LEAVE_DPLAY();
	
	return;
} // DP_SP_HandleMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\update.c ===
/*==========================================================================
*
*  Copyright (C) 1996 - 1997 Microsoft Corporation.  All Rights Reserved.
*
*  File:       update.c
*  Content:		support for SetUpdateList method
*  History:
*   Date		By		Reason
*   ====		==		======
*	10/31/96	andyco	created it 
*   6/6/98      aarono  Fix for handling large loopback messages with protocol
*
***************************************************************************/

#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME	"DP_SetUpdateList"


// make sure player has enough room in update list to add a node of size dwUpdateNodeSize
// called by DP_SetUpdateList 
HRESULT MakeUpdateSpace(LPDPLAYI_DPLAY this,LPDPLAYI_PLAYER pPlayerTo,DWORD dwUpdateNodeSize)
{
	LPVOID pvTemp;
	DWORD dwAvailSpace;
	DWORD dwAllocSize;

	// this is how much room is available in the players update list	
	dwAvailSpace = pPlayerTo->dwUpdateListSize - 
		( pPlayerTo->pbUpdateIndex - pPlayerTo->pbUpdateList);
		
	if (!pPlayerTo->pbUpdateList)
	{
		// alloc a new list
		ASSERT( 0 == pPlayerTo->dwUpdateListSize);

		//
		// alloc enough space for 1. the on the wire header, 2. the node we're adding and 
		// 3. a little extra
		//
		dwAllocSize = GET_MESSAGE_SIZE(this,MSG_UPDATELIST) + DPUPDATE_INITIALNODESIZE + dwUpdateNodeSize;

		DPF(7,"alloc'ing update list of size = %d\n",dwAllocSize);

		pPlayerTo->pbUpdateList = DPMEM_ALLOC(dwAllocSize);
		if (!pPlayerTo->pbUpdateList)
		{
			DPF_ERR("MakeUpdateSpace - out of memory - could not alloc node list");
			return E_OUTOFMEMORY;
		}
		
		// start writing into the buffer immediately after the on the wire header
		pPlayerTo->pbUpdateIndex = pPlayerTo->pbUpdateList + GET_MESSAGE_SIZE(this,MSG_UPDATELIST);
	}
	else if (dwAvailSpace >= dwUpdateNodeSize)
	{
		// we have a list and it's big enough. all done.
		return DP_OK;
	}
	else 
	{
		// the list isn't big enough - realloc it
		// alloc enough space for 1. the current buffer, 2. the node we're adding and 
		// 3. a little extra
		//
		dwAllocSize = pPlayerTo->dwUpdateListSize +  dwUpdateNodeSize + DPUPDATE_INITIALNODESIZE;
		DPF(7,"REalloc'ing update list of size = %d\n",dwAllocSize);		
		
		pvTemp = DPMEM_REALLOC(pPlayerTo->pbUpdateList,dwAllocSize);
		if (!pvTemp)
		{
			DPF_ERR("MakeUpdateSpace - out of memory - could not realloc node list");
			return E_OUTOFMEMORY;
		}
		pPlayerTo->pbUpdateList = pvTemp;
		// since realloc may have moved update list, need to reset updateindex
		pPlayerTo->pbUpdateIndex = pPlayerTo->pbUpdateList + pPlayerTo->dwUpdateListSize - dwAvailSpace;
	}
	
	// store the new size
	pPlayerTo->dwUpdateListSize = dwAllocSize;
	
	return DP_OK;		
	
} // MakeUpdateSpace

// put the system message (pvMessage, passed in by the app) into playerTo's update
// list. 
HRESULT UpdateSystemMessage(LPDPLAYI_DPLAY this,DWORD dwUpdateFlags,DPID idFrom,
	LPDPLAYI_PLAYER lpPlayerTo,LPVOID pvMessage,DWORD dwMessageSize)
{
	LPDPMSG_GENERIC pmsg = (LPDPMSG_GENERIC)pvMessage;
	DWORD dwUpdateNodeSize;
	HRESULT hr;
	
	if (dwUpdateFlags &  DPUPDATE_CREATEPLAYER) 
	{
		LPUPDNODE_CREATEPLAYER pup;
		LPDPLAYI_PLAYER lpPlayerCreated;
		
		lpPlayerCreated = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(lpPlayerCreated))
		{
			DPF_ERR("update add player - got bogus player");
			return DPERR_INVALIDPARAMS;
		}
		
		// ACK - todo - pack up other create structs
		dwUpdateNodeSize = sizeof(UPDNODE_CREATEPLAYER); // + ...
		
		// make sure playerto has room in its update list
		hr = MakeUpdateSpace(this,lpPlayerTo,dwUpdateNodeSize);
		if (FAILED(hr))
		{
			DPF_ERR("could not add node to update list - out of memory");
			return E_OUTOFMEMORY;
		}
		pup = (LPUPDNODE_CREATEPLAYER)(lpPlayerTo->pbUpdateIndex);

		pup->dwType = dwUpdateFlags;
		pup->dwID = lpPlayerCreated->dwID;
		pup->dwFlags = lpPlayerCreated->dwFlags;
		pup->dwUpdateSize = sizeof(UPDNODE_CREATEPLAYER);
		// increment our buffer pointer
		lpPlayerTo->pbUpdateIndex += pup->dwUpdateSize;
		lpPlayerTo->nUpdates++;
	}
	if (dwUpdateFlags & DPUPDATE_DESTROYPLAYER)
	{
		LPUPDNODE_DESTROYPLAYER pup;
		
		dwUpdateNodeSize = sizeof(UPDNODE_DESTROYPLAYER);
		// make sure playerto has room in its update list
		hr = MakeUpdateSpace(this,lpPlayerTo,dwUpdateNodeSize);
		if (FAILED(hr))
		{
			DPF_ERR("could not add node to update list - out of memory");
			return E_OUTOFMEMORY;
		}
		pup = (LPUPDNODE_DESTROYPLAYER)(lpPlayerTo->pbUpdateIndex);
		pup->dwType = dwUpdateFlags;
		pup->dwID = idFrom;
		pup->dwUpdateSize = sizeof(UPDNODE_DESTROYPLAYER);
		// increment our buffer pointer
		lpPlayerTo->pbUpdateIndex += pup->dwUpdateSize;
		lpPlayerTo->nUpdates++;
	}

	return DP_OK;	
	
} // UpdateSystemMessage

// add a playermessage to lpPlayerTo's update list
HRESULT UpdatePlayerMessage(LPDPLAYI_DPLAY this,DWORD dwUpdateFlags,DPID idFrom,
	LPDPLAYI_PLAYER lpPlayerTo,LPVOID pvMessage,DWORD dwMessageSize)
{
	LPUPNODE_MESSAGE pup;
	HRESULT hr;
	DWORD dwUpdateNodeSize;
	
	dwUpdateNodeSize = sizeof(UPNODE_MESSAGE) + dwMessageSize;
	
	// make sure playerto has room in its update list
	hr = MakeUpdateSpace(this,lpPlayerTo,dwUpdateNodeSize);
	if (FAILED(hr))
	{
		DPF_ERR("could not add node to update list - out of memory");
		return E_OUTOFMEMORY;
	}
	
	pup = (LPUPNODE_MESSAGE)(lpPlayerTo->pbUpdateIndex);
	pup->dwType = DPUPDATE_MESSAGE;
	pup->idFrom = idFrom;
	pup->dwUpdateSize = sizeof(UPNODE_MESSAGE) + dwMessageSize;
	pup->dwMessageOffset = sizeof(UPNODE_MESSAGE);
	memcpy((LPBYTE)pup + sizeof(UPNODE_MESSAGE),pvMessage,dwMessageSize);
	
	// increment our buffer pointer
	lpPlayerTo->pbUpdateIndex += pup->dwUpdateSize;
	lpPlayerTo->nUpdates++;
	
	return DP_OK;
} // UpdatePlayerMessage

//
// idFrom + idTo can be a group, a player or DPID_ALLPLAYERS
//
HRESULT DPAPI DP_SetUpdateList(LPDIRECTPLAY lpDP,DWORD dwUpdateFlags,DPID idFrom, 
	DPID idTo,LPVOID pvMessage,DWORD dwMessageSize,DWORD dwSendFlags)
{
	LPDPLAYI_DPLAY this;
    HRESULT hr=DP_OK;		
    LPDPLAYI_PLAYER lpPlayerTo; // may be group or players
								// we'll cast to players since we only need 
								// update data
        
	ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
            LEAVE_DPLAY();		
            return hr;
        }

		if (!this->pServerPlayer)
		{
			LEAVE_DPLAY();
			DPF_ERR("must create server player before sending updates");
			return DPERR_UNAVAILABLE;
		}
		
		// we don't care about idFrom
		// in fact, idFrom may not even be in our nametable (already deleted)
		
		// check idTo
    	// is it a player?
        lpPlayerTo = PlayerFromID(this,idTo);
        if (!VALID_DPLAY_PLAYER(lpPlayerTo)) 
        {
        	// not a player. is it a group?
        	lpPlayerTo = (LPDPLAYI_PLAYER)GroupFromID(this,idTo);
	        if (!VALID_DPLAY_GROUP(lpPlayerTo)) 
	        {
	        	// not player or group - error
	        	LEAVE_DPLAY();
				DPF_ERR("invalid To id");
	            return DPERR_INVALIDPLAYER;
	        }
        } // idTo


        // check pvMessage
        if (!VALID_READ_STRING_PTR(pvMessage,dwMessageSize))
        {
        	LEAVE_DPLAY();
        	DPF_ERR("invalid pvMessage");
        	return DPERR_INVALIDPARAMS;
        }										

    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
		LEAVE_DPLAY();
		DPF_ERR( "Exception encountered validating parameters" );
        return DPERR_INVALIDPARAMS;
    }

	// see what they want updated
    if (dwUpdateFlags & DPUPDATE_MESSAGE)
    {
    	hr = UpdatePlayerMessage(this,dwUpdateFlags,idFrom,lpPlayerTo,pvMessage,dwMessageSize);
    	if (FAILED(hr))
    	{
    		ASSERT(FALSE);
    	}
    }
    if ((dwUpdateFlags & DPUPDATE_CREATEPLAYER) || // todo - other system messages
    	(dwUpdateFlags & DPUPDATE_DESTROYPLAYER))
    {
		if (DPID_ALLPLAYERS == idFrom)
		{
			LPDPLAYI_PLAYER lpPlayerSource = this->pPlayers;
			
			while (lpPlayerSource)
			{
				if (!(lpPlayerSource->dwFlags & DPLAYI_PLAYER_SYSPLAYER))
				{
			    	// put the system message in idTo's update list
			    	hr = UpdateSystemMessage(this,dwUpdateFlags,lpPlayerSource->dwID,lpPlayerTo,pvMessage,dwMessageSize);
			    	if (FAILED(hr)) ASSERT(FALSE);
				}
				lpPlayerSource = lpPlayerSource->pNextPlayer;
			}
		}	// all players
		// TODOTODOTODO handle from a group
		else 
		{
			// from a player
	    	// put the system message in idTo's update list
	    	hr = UpdateSystemMessage(this,dwUpdateFlags,idFrom,lpPlayerTo,pvMessage,dwMessageSize);
	    	if (FAILED(hr)) ASSERT(FALSE);
		}
    }
    if (dwUpdateFlags & DPUPDATE_FLUSH)
    {
    	// is there something to send?
		if ( GET_MESSAGE_SIZE(this,MSG_UPDATELIST) < (DWORD)UPDATE_SIZE(lpPlayerTo))
		{
			DPF(4,"sending update - nMessages = %d, dwSize = %d\n",lpPlayerTo->nUpdates,(DWORD)UPDATE_SIZE(lpPlayerTo));
	    	hr = SendUpdateMessage(this,lpPlayerTo,dwSendFlags);
			if (FAILED(hr))
			{
				ASSERT(FALSE);
			}
			lpPlayerTo->nUpdates = 0;
			// reset the pbBufferIndex			
			lpPlayerTo->pbUpdateIndex = lpPlayerTo->pbUpdateList + GET_MESSAGE_SIZE(this,MSG_UPDATELIST);
		}
    }
    else 
    {
    	DPF(5,"not sending update - update list size = %d\n",UPDATE_SIZE(lpPlayerTo));
    }

    LEAVE_DPLAY();
    
	return hr;	

} // DP_SetUpdateList


// called from HandleMessage (handler.c)
// parse the update list, calling back into handler as we go
HRESULT HandleUpdateList(IDirectPlaySP * pISP,LPBYTE pReceiveBuffer,DWORD dwTotalMessageSize)
{
	LPMSG_UPDATELIST pmsgUpdate;
	LPBYTE pbBufferIndex,pbBufferEnd;
	HRESULT hr;
	LPDPLAYI_DPLAY this;
	
	this = DPLAY_FROM_INT(pISP);

	pmsgUpdate = (LPMSG_UPDATELIST)pReceiveBuffer;
	// set pbBufferIndex to point at the 1st updatenode
	pbBufferIndex = pReceiveBuffer + pmsgUpdate->dwUpdateListOffset;
	pbBufferEnd = pReceiveBuffer + dwTotalMessageSize;
	
	// walk the list of updatenodes
	while (pbBufferIndex < pbBufferEnd)
	{
		DWORD dwType = ((LPUPNODE_GENERIC)pbBufferIndex)->dwType ;
	
		if (dwType &  DPUPDATE_MESSAGE)
		{
			LPUPNODE_MESSAGE pupMessage = (LPUPNODE_MESSAGE)pbBufferIndex;
			LPMSG_PLAYERMESSAGE pmsg;
			DWORD dwMessageSize;
			
		   	dwMessageSize = pupMessage->dwUpdateSize - pupMessage->dwMessageOffset + sizeof(MSG_PLAYERMESSAGE);
			pmsg = DPMEM_ALLOC(dwMessageSize);
			if (!pmsg)
			{
				DPF_ERR("could not handle message update - out of memory");
				return E_OUTOFMEMORY;
			}
			
			// build a player-player message
			pmsg->idTo = pmsgUpdate->dwIDTo;
			pmsg->idFrom = pupMessage->idFrom;
			// TODO - can we get around this memcpy?
			memcpy( (LPBYTE)pmsg + sizeof(MSG_PLAYERMESSAGE), (LPBYTE)pupMessage 
				+ pupMessage->dwMessageOffset,pupMessage->dwUpdateSize - pupMessage->dwMessageOffset);
			
			// call handler to deal w/ it
			hr = DP_SP_HandleNonProtocolMessage(pISP,(LPBYTE)pmsg,dwMessageSize,DPSP_HEADER_LOCALMSG);
			if (FAILED(hr))				
			{
				ASSERT(FALSE);
			}
			
			DPMEM_FREE(pmsg);
			
			// advance buffer pointer
			pbBufferIndex +=  pupMessage->dwUpdateSize;
			
		}
			
		if (dwType &  DPUPDATE_CREATEPLAYER) 
		{
			LPUPDNODE_CREATEPLAYER pupMessage = (LPUPDNODE_CREATEPLAYER)pbBufferIndex;
		    DPLAYI_PACKEDPLAYER packed;
			LPDPLAYI_PLAYER pPlayer;
			
			pPlayer = PlayerFromID(this,pupMessage->dwID);
			if (!VALID_DPLAY_PLAYER(pPlayer))
			{
				// only unpack it if it's not already here...		    
				memset(&packed,0,sizeof(packed));
				packed.dwSize = sizeof(DPLAYI_PACKEDPLAYER);
				packed.dwFlags = pupMessage->dwFlags;
				packed.dwID = pupMessage->dwID;
				packed.dwFixedSize = sizeof(DPLAYI_PACKEDPLAYER);
				hr = UnpackPlayer(this,&packed,NULL,TRUE);
				if (FAILED(hr))					
				{
					ASSERT(FALSE);
				}
			}
			// advance buffer pointer
			pbBufferIndex +=  pupMessage->dwUpdateSize;
		}
		if (dwType &  DPUPDATE_DESTROYPLAYER) 
		{
			LPUPDNODE_CREATEPLAYER pupMessage = (LPUPDNODE_CREATEPLAYER)pbBufferIndex;
			MSG_PLAYERMGMTMESSAGE msg;
			
			if (this->pSysPlayer)	
			{
				SET_MESSAGE_HDR(&msg);
				SET_MESSAGE_COMMAND(&msg,DPSP_MSG_DELETEPLAYER);
				msg.dwPlayerID = pupMessage->dwID;
				msg.dwIDTo = this->pSysPlayer->dwID;
				// call handler to deal w/ it
				hr = DP_SP_HandleNonProtocolMessage(pISP,(LPBYTE)&msg,sizeof(msg),DPSP_HEADER_LOCALMSG);
				if (FAILED(hr))				
				{
					ASSERT(FALSE);
				}
			}
			// otherwise, ignore
			
			// advance buffer pointer
			pbBufferIndex +=  pupMessage->dwUpdateSize;
		}
	} // while
	

	return DP_OK;
} // HandleUpdateList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\update.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       update.h
 *  Content:	header for app server update handling
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	10/31/96	andyco	created
 ***************************************************************************/

#ifndef __DPUPDATE_INCLUDED__
#define __DPUPDATE_INCLUDED__


/*                      */
/* Handy Macro	 		*/
/*                      */

#define UPDATE_SIZE(pPlayer) (pPlayer->pbUpdateIndex - pPlayer->pbUpdateList)

/*                      */
/* Constants	 		*/
/*                      */

// we alloc this much for the updatelist	 
#define DPUPDATE_INITIALNODESIZE			1024

/*                      */
/* Update messages		*/
/*                      */

typedef struct _UPNODE_GENERIC
{
	DWORD 	dwType; // e.g. DPUPDATE_xxx
} UPNODE_GENERIC, * LPUPNODE_GENERIC;

typedef struct _UPNODE_MESSAGE
{
	DWORD 	dwType; // e.g. DPUPDATE_xxx
	DPID	idFrom;
	DWORD	dwUpdateSize; // total size of this update node
	DWORD	dwMessageOffset; // offset of message from beginning of node
} UPNODE_MESSAGE,* LPUPNODE_MESSAGE;

typedef struct _UPDNODE_CREATEPLAYER
{
	DWORD dwType; // e.g. DPUPDATE_xxx
	DPID  dwID; // id of new player
	DWORD dwFlags; // player flags
	DWORD dwUpdateSize; // total size of this update node
	// short name, long name, data, address follow, if specified
	// by DPUDPATE_FLAGS	
	
}  UPDNODE_CREATEPLAYER, *LPUPDNODE_CREATEPLAYER;

typedef struct _UPDNODE_DESTROYPLAYER
{									
	DWORD dwType; // e.g. DPUPDATE_xxx
	DPID  dwID; // id of deleted player
	DWORD dwUpdateSize; // total size of this update node
}  UPDNODE_DESTROYPLAYER, *LPUPDNODE_DESTROYPLAYER;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\voice.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       voice.c
 *  Content:	direct play voice method support
 *  History:
 *   Date		By		   	Reason
 *   ====		==		   	======
 *  10/21/97	andyco	   	created it
  ***************************************************************************/
		
					
#include "dplaypr.h"

#undef DPF_MODNAME
#define DPF_MODNAME "SendVoiceMessage"
HRESULT SendVoiceMessage(LPDPLAYI_DPLAY this,BOOL fOpen,LPDPLAYI_PLAYER pPlayerFrom,LPDPLAYI_PLAYER pPlayerTo)
{
	HRESULT hr = DP_OK;
	LPMSG_VOICE pmsg;
	LPBYTE pSendBuffer;
	DWORD dwMessageSize;
    
	// message size + blob size
	dwMessageSize = GET_MESSAGE_SIZE(this,MSG_VOICE);
    pSendBuffer = DPMEM_ALLOC(dwMessageSize);
    if (NULL == pSendBuffer) 
    {
    	DPF_ERR("could not send data changed message - out of memory");
        return E_OUTOFMEMORY;
    }

	// message follows header    
	pmsg = (LPMSG_VOICE)(pSendBuffer + this->dwSPHeaderSize);

	SET_MESSAGE_HDR(pmsg);
	if (fOpen) SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_VOICEOPEN);
	else SET_MESSAGE_COMMAND(pmsg,DPSP_MSG_VOICECLOSE);
	
	pmsg->dwIDTo 	= pPlayerTo->dwID;
	pmsg->dwIDFrom 	= pPlayerFrom->dwID;
		
	hr = SendDPMessage(this,pPlayerFrom,pPlayerTo,pSendBuffer,dwMessageSize, DPSEND_GUARANTEED | DPSEND_ASYNC, FALSE);
	if (FAILED(hr)) 
	{
		DPF(0,"SendVoiceMessage : senddpmessage failed hr = 0x%08lx\n",hr);	
		// keep trying...
	}
	
	DPMEM_FREE(pSendBuffer);
		
	return hr;	
		
}  // SendVoiceMessage

HRESULT InternalCloseVoice(LPDPLAYI_DPLAY this,BOOL fPropagate)
{
    HRESULT hr = DP_OK;
	DPSP_CLOSEVOICEDATA cvd;
	LPDPLAYI_PLAYER pVoiceTo,pVoiceFrom;
	
	// make sure voice is open
	if (!this->pVoice)
	{
		DPF_ERR("voice channel not open!");
		return E_FAIL;
	}

	if (fPropagate) 
	{
		// 
		// we generated this message.  we need to tell sp.  
		// call SP if SP supports it 
		//
		if (this->pcbSPCallbacks->CloseVoice)
		{
			cvd.lpISP = this->pISP;
			cvd.dwFlags = 0;
		    hr = CALLSP(this->pcbSPCallbacks->CloseVoice,&cvd);
		    if (FAILED(hr)) 
		    {
				DPF_ERRVAL("SP Close voice call failed!  hr = 0x%08lx\n",hr);
				// keep going
				hr = DP_OK;
		    }
		}
		
		pVoiceTo = PlayerFromID(this,this->pVoice->idVoiceTo);
		if (!VALID_DPLAY_PLAYER(pVoiceTo)) 
		{
			DPF_ERR("could not send voice msg - invalid player to!");
			goto ERROR_EXIT;
		}

		pVoiceFrom = PlayerFromID(this,this->pVoice->idVoiceFrom);
		if (!VALID_DPLAY_PLAYER(pVoiceFrom)) 
		{
			DPF_ERR("could not send voice msg - invalid player From!");
			goto ERROR_EXIT;
		}

		hr = SendVoiceMessage(this, FALSE, pVoiceFrom,pVoiceTo);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SendVoiceMessage failed!  hr = 0x%08lx\n",hr);
			// keep trying!
			hr = DP_OK;
	    }
		
	} // fPropagate
	
ERROR_EXIT:
	
	// free up voice
	DPMEM_FREE(this->pVoice);
	this->pVoice = NULL;
	
	return DP_OK;	
}	// InternalCloseVoice


#undef DPF_MODNAME
#define DPF_MODNAME "DP_CloseVoice"
HRESULT DPAPI DP_CloseVoice(LPDIRECTPLAY lpDP,DWORD dwFlags)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;

	ENTER_SERVICE();
    ENTER_DPLAY();

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }

		// check flags
		if (dwFlags)
		{
			DPF_ERR("bad dwFlags");
            hr = DPERR_INVALIDFLAGS;
			goto CLEANUP_EXIT;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        hr = DPERR_INVALIDPARAMS;
		goto CLEANUP_EXIT;
    }

	hr = InternalCloseVoice( this, TRUE);

	// fall through
CLEANUP_EXIT:
	LEAVE_SERVICE();
    LEAVE_DPLAY();

	return hr;
	
} // DP_CloseVoice


#undef DPF_MODNAME
#define DPF_MODNAME "DP_OpenVoice"

HRESULT InternalOpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags,BOOL fPropagate)
{
    LPDPLAYI_DPLAY this;
    HRESULT hr = DP_OK;
    LPDPLAYI_GROUP pGroupTo = NULL; 
    LPDPLAYI_PLAYER pPlayerTo = NULL,pPlayerFrom = NULL;
	BOOL bToPlayer= FALSE;
	DPSP_OPENVOICEDATA ovd;
	LPDPVOICE pVoice;

    TRY
    {
        this = DPLAY_FROM_INT(lpDP);
		hr = VALID_DPLAY_PTR( this );
		if (FAILED(hr))
		{
			DPF_ERRVAL("bad dplay ptr - hr = 0x%08lx\n",hr);
			goto CLEANUP_EXIT;
        }

		// check src player        
		pPlayerFrom = PlayerFromID(this,idFrom);
		if (!VALID_DPLAY_PLAYER(pPlayerFrom)) 
		{
			DPF_ERR("bad player from");
			hr = DPERR_INVALIDPLAYER;
			goto CLEANUP_EXIT;
		}

		// see if it's a player or group
		pPlayerTo = PlayerFromID(this,idTo);
		if (VALID_DPLAY_PLAYER(pPlayerTo)) 
		{		  
			bToPlayer = TRUE;
		}
		else 
		{
			pGroupTo = GroupFromID(this,idTo);
			if (VALID_DPLAY_GROUP(pGroupTo)) 
			{
				bToPlayer = FALSE;
				// cast to player...
				pPlayerTo = (LPDPLAYI_PLAYER)pGroupTo;
				// voice not supported to groups for DX6
				DPF_ERR("voice not supported to groups yet - FAILING OPEN VOICE");
				hr = E_NOTIMPL;
				goto CLEANUP_EXIT;
			}
			else 
			{
				// bogus id! - player may have been deleted...
				DPF_ERR("bad player to");
				hr = DPERR_INVALIDPARAMS;
				goto CLEANUP_EXIT;
			}// not player or group
		} // group

		// check flags
		if (dwFlags)
		{
			DPF_ERR("bad dwFlags");
            hr = DPERR_INVALIDFLAGS;
			goto CLEANUP_EXIT;
		}

    } // try
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
        DPF_ERR( "Exception encountered validating parameters" );		
        hr = DPERR_INVALIDPARAMS;
		goto CLEANUP_EXIT;
    }

	// make sure they called Open w/ DPOPEN_VOICE
	if (!(this->dwFlags & DPLAYI_DPLAY_VOICE))
	{
		DPF_ERR("must call IDirectPlayX->Open w/ DPOPEN_VOICE to use OpenVoice!");
		hr = DPERR_UNAVAILABLE;
		goto CLEANUP_EXIT;
	}
	
	// can only have one voice 
	if (this->pVoice)
	{
		DPF_ERR("voice channel already open!");
		hr = DPERR_ALREADYINITIALIZED;
		goto CLEANUP_EXIT;
	}

	// make sure SP supports it 
	if (! (this->pcbSPCallbacks->OpenVoice) )
	{
		DPF_ERR("voice not supported by SP");
		hr = DPERR_UNSUPPORTED;
		goto CLEANUP_EXIT;
	}

	// if we're originating - make sure to + from are ok w/ voice
	if (fPropagate)	
	{
		// no voice open to local players
		if (pPlayerTo->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL)	
		{
			DPF_ERR("voice not supported to local players");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}
		
		// no voice open from non-local players
		if (!(pPlayerFrom->dwFlags & DPLAYI_PLAYER_PLAYERLOCAL))
		{
			DPF_ERR("voice not supported from non-local players");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}

		// make sure player to can accept calls	
		if (!pPlayerTo->dwFlags & DPLAYI_PLAYER_HASVOICE)
		{
			DPF_ERR("remote system does not support voice");
			hr = DPERR_UNSUPPORTED;
			goto CLEANUP_EXIT;
		}
	}
	
	// go get us a dpvoice
	pVoice = DPMEM_ALLOC(sizeof(DPVOICE));
	if (!pVoice)
	{
		DPF_ERR("could not alloc internal voice struct! out of memory");
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	pVoice->idVoiceTo = idTo;
	pVoice->idVoiceFrom = idFrom;

		
	if (fPropagate)	
	{
		// set up voice data
		ovd.idTo = idTo;
		ovd.idFrom = idFrom;
		ovd.bToPlayer = bToPlayer;
		ovd.lpISP = this->pISP;

		// tell SP to start it up
	    hr = CALLSP(this->pcbSPCallbacks->OpenVoice,&ovd);
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SP Open voice call failed!  hr = 0x%08lx\n",hr);
			// clean up the DPVOICE
			DPMEM_FREE(pVoice);
			goto CLEANUP_EXIT;
	    }

		hr = SendVoiceMessage(this, TRUE, pPlayerFrom,pPlayerTo ); 
	    if (FAILED(hr)) 
	    {
			DPF_ERRVAL("SendVoiceMessage failed!  hr = 0x%08lx\n",hr);
			// keep trying!
			hr = DP_OK;
	    }
	}

	// open succeeded - store dpvoice	
	this->pVoice = pVoice;

	// fall through
CLEANUP_EXIT:

	return hr;
    
	
} // InternalOpenVoice

HRESULT DPAPI DP_OpenVoice(LPDIRECTPLAY lpDP, DPID idFrom,DPID idTo,DWORD dwFlags) 
{
	HRESULT hr;
	
	ENTER_DPLAY();
	ENTER_SERVICE();
	
	hr =  InternalOpenVoice(lpDP, idFrom,idTo,dwFlags,TRUE);
	
	LEAVE_DPLAY();
	LEAVE_SERVICE();
	
	return hr;	
} // DP_OpenVoice
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPLAYSVR"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplay\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\dplaysvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.c
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share
 *				a single winsock port
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *  1/12/2000   aarono  added support for rsip
 * 11/29/2000   aarono  B#228292: prefix bug initialize path in WinMain()
 *
 ***************************************************************************/

#ifdef WINNT
    #ifdef DBG
        #undef DEBUG
        #define DEBUG
    #endif
#endif

#include <windows.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"
#include "rsip.h"
#include "dpnathlp.h"

#if USE_RSIP
BOOL				bRsip;
#endif

#if USE_NATHELP
extern VOID natExtend(VOID);
extern BOOL natInit(VOID);
extern VOID natFini(VOID);
extern HRESULT natRegisterUDPPort(DWORD port);
extern IDirectPlayNATHelp *g_pINatHelp;
#endif

HANDLE 				hInstApp;
BOOL		   		bNoCallbacks;
CRITICAL_SECTION    gcsCritSection;	// the crit section we take in winmain
                                	// this is a global so dphelp can take it before
                                	// forwarding enum requests that come in on its
                                	// receive thread (manbugs 3907)
int					gnCSCount;		// dplaysvr lock count

/*
 * Externs
 */
extern RECEIVELIST 	gReceiveList;
extern FDS			gReadfds;


// we watch every dplay process so when it exits we
// make sure it cleaned up...
typedef struct _PROCESSDATA
{
    struct _PROCESSDATA		*link;
    DWORD			pid;
} PROCESSDATA, *LPPROCESSDATA;

LPPROCESSDATA		lpProcessList; 	// list of all processes that are registered
									// with us



//**********************************************************************
// Globals
//**********************************************************************
BOOL					g_fDaclInited = FALSE;
SECURITY_ATTRIBUTES		g_sa;
BYTE					g_abSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
PSECURITY_ATTRIBUTES	g_psa = NULL;





/*
 * ThreadProc
 *
 * Open a process and wait for it to terminate
 */
DWORD WINAPI ThreadProc( LPVOID *pdata )
{
    HANDLE		hproc;
    DWORD		rc;
    LPPROCESSDATA	ppd;
    LPPROCESSDATA	curr;
    LPPROCESSDATA	prev;
    PROCESSDATA		pd;
	DPHELPDATA		hd;
	
    ppd = (LPPROCESSDATA) pdata;

    /*
     * get a handle to the process that attached to DDRAW
     */
    DPF( 2, "Watchdog thread started for pid %08lx", ppd->pid );

    hproc = OpenProcess( PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                            FALSE, ppd->pid );
    if( hproc == NULL )
    {
        DPF( 1, "OpenProcess for %08lx failed!", ppd->pid );
        ExitThread( 0 );
    }

    /*
     * wait for process to die
     */
    rc = WaitForSingleObject( hproc, INFINITE );
    if( rc == WAIT_FAILED )
    {
        DPF( 1, "Wait for process %08lx failed", ppd->pid );
        CloseHandle( hproc );
        ExitThread( 0 );
    }

    /*
     * remove process from the list of watched processes
     */
    ENTER_DPLAYSVR();
    pd = *ppd;
    curr = lpProcessList;
    prev = NULL;
    while( curr != NULL )
    {
        if( curr == ppd )
        {
            if( prev == NULL )
            {
                lpProcessList = curr->link;
            }
            else
            {
                prev->link = curr->link;
            }
            DPF( 2, "PID %08lx removed from list", ppd->pid );
            MemFree( curr );
            break;
        }
        prev = curr;
        curr = curr->link;
    }

    if( bNoCallbacks )
    {
		DPF( 1, "No callbacks allowed: leaving thread early" );
		LEAVE_DPLAYSVR();
		CloseHandle( hproc );
		ExitThread( 0 );
    }


	// clean up!

	memset(&hd,0,sizeof(hd));
	hd.pid = pd.pid;
	DPlayHelp_DeleteServer(&hd,TRUE);
	
    LEAVE_DPLAYSVR();
    CloseHandle( hproc );

    ExitThread( 0 );
	
	return 0;

} /* ThreadProc */

/*
 * MainWndProc
 */
LONG_PTR __stdcall MainWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch(message)
    {
        case WM_ENDSESSION:
            /*
             * shoot ourselves in the head
             */
            if( lParam == FALSE )
            {
                DPF( 3, "WM_ENDSESSION" );
                ENTER_DPLAYSVR();
                DPF( 1, "Setting NO CALLBACKS" );
                bNoCallbacks = TRUE;
                LEAVE_DPLAYSVR();
            }
            else
            {
                DPF( 3, "User logging off" );
            }

            break;

    }

    return DefWindowProc(hWnd, message, wParam, lParam);
} /* MainWndProc */

/*
 * WindowThreadProc
 */
void WindowThreadProc( LPVOID pdata )
{
    static char szClassName[] = "DPlayHelpWndClass";
    WNDCLASS 	cls;
    MSG		msg;
    HWND	hwnd;

    /*
     * build class and create window
     */
    cls.lpszClassName  = szClassName;
    cls.hbrBackground  = (HBRUSH)GetStockObject(BLACK_BRUSH);
    cls.hInstance      = hInstApp;
    cls.hIcon          = NULL;
    cls.hCursor        = NULL;
    cls.lpszMenuName   = NULL;
    cls.style          = 0;
    cls.lpfnWndProc    = (WNDPROC)MainWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    if( !RegisterClass( &cls ) )
    {
        DPF( 1, "RegisterClass FAILED!" );
        ExitThread( 0 );
    }

    hwnd = CreateWindow( szClassName, szClassName,
            WS_POPUP, 0, 0, 0, 0, NULL, NULL, hInstApp, NULL);

    if( hwnd == NULL )
    {
        DPF( 1, "No monitor window!" );
        ExitThread( 0 );
    }

    /*
     * pump the messages
     */
    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
    }
    DPF( 1, "Exiting WindowThreadProc" );
    ExitThread( 1 );

} /* WindowThreadProc */

//
// called by by DPlayHelp_AddServer when we get a new process attached.
// we wait for the process to go away, and then make sure it cleaned
// all its registered servers up.
//
void WatchNewPid(LPDPHELPDATA phd)
{
    LPPROCESSDATA	ppd;
    BOOL		found;
    DWORD		tid;

    DPF( 1, "watching new pid" );

    ENTER_DPLAYSVR();
	
    ppd = lpProcessList;
    found = FALSE;
    while( ppd != NULL )
    {
        if( ppd->pid == phd->pid )
        {
            DPF( 2, "Have thread for process %08lx already", phd->pid );
			found = TRUE;
            break;
        }
        ppd = ppd->link;
    }

    /*
     * couldn't find anyone waiting on this process, so create
     * a brand spanking new thread
     */
    if( !found )
    {
        DPF( 2, "Allocating new thread for process %08lx",phd->pid );
        ppd = MemAlloc( sizeof( PROCESSDATA ) );
        if( ppd != NULL )
        {
            HANDLE	h;

            ppd->link = lpProcessList;
            lpProcessList = ppd;
            ppd->pid = phd->pid;
            h = CreateThread(NULL,
                         0,
                         (LPTHREAD_START_ROUTINE) ThreadProc,
                         (LPVOID)ppd,
                         0,
                         (LPDWORD)&tid);
            if( h != NULL )
            {
                DPF( 2, "Thread %08lx created",tid);
                CloseHandle( h );
            }
            else
            {
                #ifdef DEBUG
                    DPF( 0, "COULD NOT CREATE HELPER THREAD FOR PID %08lx", phd->pid );
                    DebugBreak(); //_asm int 3;
                #endif
            }
        }
        else
        {
            #ifdef DEBUG
                DPF( 0, "OUT OF MEMORY CREATING HELPER THREAD FOR PID %08lx", phd->pid );
                DebugBreak(); //_asm int 3;
            #endif
        }
    }
    LEAVE_DPLAYSVR();
	
} // WatchNewPid

typedef DWORD (WINAPI *PFNREGISTERSERVICE)(DWORD,DWORD);
// nt's winbase.h doesn't have these constants - we need them
// so we can compile.  taken from \proj\dev\inc\winbase.h
#ifndef RSP_UNREGISTER_SERVICE
#define RSP_UNREGISTER_SERVICE  0x00000000
#endif
#ifndef RSP_SIMPLE_SERVICE
#define RSP_SIMPLE_SERVICE      0x00000001
#endif

// on Win95, we want to call RegisterServiceProcess
// but, it's not available on NT, so we can't import it directly
// here we try to find it dynamically in kernel32.  if we find it,
// we call it, otherwise we assume we're on NT and it's not avaible
void MakeMeService()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not register service process - expected on NT");
		FreeLibrary(hLib);
		return ;
	}
	
    pfnRegisterServiceProcess( 0, RSP_SIMPLE_SERVICE );
	FreeLibrary(hLib);
	
	return ;
} // MakeMeService	

// on Win95, we want to call RegisterServiceProcess to Unregister
// (see MakeMeService)
void StopServiceProcess()
{
	HANDLE hLib;
	PFNREGISTERSERVICE pfnRegisterServiceProcess;
	
    hLib = LoadLibrary("kernel32.dll");
	if (!hLib)
	{
		// wacky!
		DPF(1,"could not load library kernel32 to register service proc");
		return;
	}
	
	pfnRegisterServiceProcess = (PFNREGISTERSERVICE)GetProcAddress(hLib,"RegisterServiceProcess");
	if (!pfnRegisterServiceProcess)
	{
		// this is expected on NT
		DPF(3,"could not unregister service process - not avail - not tragic");
		FreeLibrary(hLib);
		return ;
	}
	
	// unregistered!
    pfnRegisterServiceProcess( 0, RSP_UNREGISTER_SERVICE );
	FreeLibrary(hLib);
	
	return ;

} // StopServiceProcess


//**********************************************************************
// ------------------------------
// DNGetNullDacl - Get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accessible by all users.
//					Taken from IDirectPlay8 code base.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl(void)
{
	// This was done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*) g_abSD, SECURITY_DESCRIPTOR_REVISION))
		{
			DPF(0, "Failed to initialize security descriptor!");
		}
		else
		{
			// Add a NULL DACL to the security descriptor.
			if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*) g_abSD, TRUE, (PACL) NULL, FALSE))
			{
				DPF(0, "Failed to set NULL DACL on security descriptor!");
			}
			else
			{
				g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
				g_sa.lpSecurityDescriptor = g_abSD;
				g_sa.bInheritHandle = FALSE;

				g_psa = &g_sa;
			}
		}
		g_fDaclInited = TRUE;
	}
	
	return g_psa;
}
//**********************************************************************

/*
 * WinMain
 */
int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                        LPSTR lpCmdLine, int nCmdShow)
{
    DWORD			tid;
    DWORD			rc;
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
    HANDLE			hstartevent;
    HANDLE			hstartupevent;
    HANDLE			hmutex;
    HANDLE			hackevent;
    LPDPHELPDATA	phd;
    HANDLE			hsharedmem;
    HANDLE			h;
    char			szSystemDir[MAX_PATH*sizeof(WCHAR)];

	DWORD			tWait;

    #if (USE_RSIP || USE_NATHELP)
   	DWORD tLast;
   	DWORD tNow;
   	#define RSIP_RENEW_TEST_INTERVAL 60000
	#endif

	
    DPFINIT();
    DPF( 2, "*** dplaysvr STARTED, PID=%08lx ***", GetCurrentProcessId() );
	
	if( !MemInit() )
	{
		DPF( 1, "Could not init memory manager" );
		return 0;
	}

	
   /*
     * Set our working directory to the system directory.
     * This prevents us from holding network connections open
     * forever if the first DirectDraw app that we run is across
     * a network connection.
     */
    memset(szSystemDir, 0, sizeof(WCHAR));  
    GetSystemDirectory(szSystemDir, sizeof(szSystemDir));
    SetCurrentDirectory(szSystemDir);


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			DPF(2, "Running on NT version %u.%u.%u, using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			DPF(2, "Running on 9x version %u.%u.%u, not using global namespace.",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		rc = GetLastError();
		DPF(0, "Could not determine OS version (err = %u), assuming global namespace not needed.", rc);
		fUseGlobalNamespace = FALSE;
	}


	// try to register ourselves as a service so user can't see us
	// in task list
	MakeMeService();

#if 0	

// andyco - not sure if we need this...

    /*
     * We must guarantee that DPHELP unloads after the last ddraw app,
     * since ctrl-alt-del may have happened while an app held the ddraw
     * lock, and DPHELP needs to clean up orphaned cheap ddraw mutex
     * locks.
     */
    if ( ! SetProcessShutdownParameters(0x100,SHUTDOWN_NORETRY) )
    {
        DPF(0,"dplaysvr could not set itself to shutdown last!");
    }

#endif


    hInstApp = hInstance;

    /*
     * create startup event
     */
	if (fUseGlobalNamespace)
	{
		hstartupevent = CreateEvent( DNGetNullDacl(), TRUE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
	}
	else
	{
		hstartupevent = CreateEvent( NULL, TRUE, FALSE, DPHELP_STARTUP_EVENT_NAME );
	}
    if( hstartupevent == NULL )
    {
        DPF( 1, "Could not create startup event!" );
        return 0;
    }


    /*
     * create shared memory area
     */
	if (fUseGlobalNamespace)
	{
		hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(),
									PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
									"Global\\" DPHELP_SHARED_NAME );
	}
	else
	{
		hsharedmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
									PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
									DPHELP_SHARED_NAME );
	}
    if( hsharedmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        return 0;
    }

    /*
     * create mutex for people who want to use the shared memory area
     */
	if (fUseGlobalNamespace)
	{
		hmutex = CreateMutex( DNGetNullDacl(), FALSE, "Global\\" DPHELP_MUTEX_NAME );
	}
	else
	{
		hmutex = CreateMutex( NULL, FALSE, DPHELP_MUTEX_NAME );
	}
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex " DPHELP_MUTEX_NAME );
        CloseHandle( hsharedmem );
        return 0;
    }

    /*
     * create events
     */
	if (fUseGlobalNamespace)
	{
		hstartevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_EVENT_NAME );
	}
	else
	{
		hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
	}   
    if( hstartevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        return 0;
    }

	if (fUseGlobalNamespace)
	{
		hackevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_ACK_EVENT_NAME );
	}
	else
	{
		hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
	}
    if( hackevent == NULL )
    {
        DPF( 1, "Could not create event " DPHELP_ACK_EVENT_NAME );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }

    /*
     * Create window so we can get messages
     */
    h = CreateThread(NULL,
                 0,
                 (LPTHREAD_START_ROUTINE) WindowThreadProc,
                 NULL,
                 0,
                 (LPDWORD)&tid );
    if( h == NULL )
    {
        DPF( 1, "Create of WindowThreadProc FAILED!" );
        CloseHandle( hackevent );
        CloseHandle( hmutex );
        CloseHandle( hsharedmem );
        CloseHandle( hstartevent );
        return 0;
    }
    CloseHandle( h );

    /*
     * serialize access to us
     */
    INIT_DPLAYSVR_CSECT();




	if (!gbIPStarted) 
    {
		rc = StartupIP();
		if (FAILED(rc))
		{
			DPF_ERR("dphelp : could not init wsock ! not adding server");
			return (rc);
		}
    }

	#if USE_RSIP

	bRsip=rsipInit();
	if(bRsip){
		rsipListenPort(FALSE, SERVER_DGRAM_PORT, NULL, NULL);
	}
	#endif

    #if USE_NATHELP
    natInit();
    if(g_pINatHelp){
        natRegisterUDPPort(SERVER_DGRAM_PORT);
    }
    #endif
	
    /*
     * let invoker and anyone else who comes along know we exist
     */
    SetEvent( hstartupevent );

	tLast=tNow=timeGetTime();

    /*
     * loop forever, processing requests
     */
    while( 1 )
    {

	wait:
		tWait=(tLast+RSIP_RENEW_TEST_INTERVAL)-tNow;
		if((int)tWait < 0){
			tWait=0;
		}
		ASSERT(!(tWait &0x80000000));
    	
        /*
         * wait to be notified of a request
         */
        DPF( 1, "Waiting for next request" );
        rc = WaitForSingleObject( hstartevent, tWait );

		#if (USE_RSIP || USE_NATHELP)
			tNow=timeGetTime();
			if(rc==WAIT_TIMEOUT)
			{
				tLast=tNow;
				#if USE_RSIP
				if(bRsip) {rsipPortExtend(tNow);}
				#elif USE_NATHELP
				if(g_pINatHelp){natExtend();}
				#endif
				goto wait;
			}
		#endif

        if( rc == WAIT_FAILED )
        {
            DPF( 1, "Wait FAILED!!!" );
            continue;
        }

        ENTER_DPLAYSVR();
        phd = (LPDPHELPDATA) MapViewOfFile( hsharedmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
        if( phd == NULL )
        {
            DPF( 1, "Could not create view of file!" );
            LEAVE_DPLAYSVR();
            continue;
        }

        /*
         * find out what we need to do
         */
        switch( phd->req )
        {
        case DPHELPREQ_SUICIDE:
            DPF( 1, "DPHELPREQ_SUICIDE" );


			#if USE_RSIP
			if(bRsip){
				rsipFini();
			}	
			#endif
			#if USE_NATHELP
			if(g_pINatHelp){
			    natFini();
			}
			#endif
			DPlayHelp_FreeServerList();
			
            SetEvent( hackevent );
            CloseHandle( hmutex );
            UnmapViewOfFile( phd );
            CloseHandle( hsharedmem );
            CloseHandle( hstartevent );
            if (gReceiveList.pConnection)
            {
            	MemFree(gReceiveList.pConnection);
            }
            if (gReadfds.pfdbigset)
            {
            	MemFree(gReadfds.pfdbigset);
            }
            FINI_DPLAYSVR_CSECT();

            #ifdef DEBUG
            	MemState();
            #endif
            DPF( 3, "Good Night Gracie" );
            TerminateProcess( GetCurrentProcess(), 0 );
            break;

		case DPHELPREQ_RETURNHELPERPID:

		    DPF( 2, "DDHELPREQ_RETURNHELPERPID" );
		    phd->pid = GetCurrentProcessId();
	    	break;
			

        case DPHELPREQ_DPLAYADDSERVER:

		    DPF( 2, "DPHELPREQ_DPLAYADDSERVER" );
            phd->hr = DPlayHelp_AddServer(phd);
            #if USE_RSIP
            if(!bRsip){
				bRsip=rsipInit();
				if(bRsip){
					rsipListenPort(FALSE, SERVER_DGRAM_PORT, NULL, NULL);
				}
            }
            #endif
            #if USE_NATHELP
            if(!g_pINatHelp){
                natInit();
                if(g_pINatHelp){
                    natRegisterUDPPort(SERVER_DGRAM_PORT);
                }
            }
            #endif
            break;

        case DPHELPREQ_DPLAYDELETESERVER:

		    DPF( 2, "DPHELPREQ_DPLAYDELETESERVER" );
            DPlayHelp_DeleteServer(phd,FALSE);
            break;

        default:
            DPF( 1, "helper - Unknown Request???" );
            break;
        }

        /*
         * let caller know we've got the news
         */
        UnmapViewOfFile( phd );
        SetEvent( hackevent );
        LEAVE_DPLAYSVR();
    }
	
	StopServiceProcess();

} /* WinMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\dplaysvr.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplaysvr.h
 *  Content: 	dplay winsock shared .exe - allows multiple apps to share 
 *				a single winsock port
 *
 *  History:
 *   Date		By		Reason
 *   ====		==		======
 *	2/10/97		andyco	created it from ddhelp 
 *	1/29/98		sohailm	added macros for critical section
 *  1/12/99     aarono  added support for rsip
 *
 ***************************************************************************/
#ifndef __DPLAYSVR_INCLUDED__
#define __DPLAYSVR_INCLUDED__

// need this for hresult
#include "ole2.h"

#define USE_RSIP 0
#define USE_NATHELP 1

// crit section
extern CRITICAL_SECTION gcsCritSection;	// defined in dphelp.c
#define INIT_DPLAYSVR_CSECT() InitializeCriticalSection(&gcsCritSection);
#define FINI_DPLAYSVR_CSECT() DeleteCriticalSection(&gcsCritSection);

#ifdef DEBUG
extern int gnCSCount; // count of dplaysvr lock
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection),gnCSCount++;
#define LEAVE_DPLAYSVR() gnCSCount--;ASSERT(gnCSCount>=0);LeaveCriticalSection(&gcsCritSection);
#else 
#define ENTER_DPLAYSVR() EnterCriticalSection(&gcsCritSection);
#define LEAVE_DPLAYSVR() LeaveCriticalSection(&gcsCritSection);
#endif

/*
 * named objects
 */
#define DPHELP_EVENT_NAME			"__DPHelpEvent__"
#define DPHELP_ACK_EVENT_NAME		"__DPHelpAckEvent__"
#define DPHELP_STARTUP_EVENT_NAME	"__DPHelpStartupEvent__"
#define DPHELP_SHARED_NAME			"__DPHelpShared__"
#define DPHELP_MUTEX_NAME			"__DPHelpMutex__"

/*
 * requests 
 */
#define DPHELPREQ_SUICIDE			1
#define DPHELPREQ_DPLAYADDSERVER	2
#define DPHELPREQ_DPLAYDELETESERVER	3
#define DPHELPREQ_RETURNHELPERPID 	4

/*
 * communication data
 */
typedef struct DPHELPDATA
{
    int			req;
    DWORD		pid;
	USHORT		port;
    HRESULT		hr;
} DPHELPDATA, *LPDPHELPDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\nathelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       nathelp.c
 *  Content:   usage for nat helper DLL
 *
 *  History:
 *  Date			By		Reason
 *  ====			==		======
 *  02/22/2001		aarono	Original
 *  04/16/2001		vanceo	Use one of the split DirectPlayNATHelp interfaces only.
 *
 *  Notes:
 *   
 ***************************************************************************/
#define INITGUID


#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#define FD_SETSIZE 1
#include <winsock2.h>
#include <initguid.h>
#include "dpsp.h"
#include "mmsystem.h"
#include "dphelp.h"

#if USE_NATHELP
#include "dpnathlp.h"


extern HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL);


HMODULE				g_hNatHelp;		// module handle for dpnhxxx.dll
DPNHHANDLE          g_hNatHelpUDP;
IDirectPlayNATHelp	*g_pINatHelp=NULL;		// interface pointer for IDirectPlayNATHelp object
DPNHCAPS            g_NatHelpCaps;

BOOL natGetCapsUpdate(VOID)
{
	HRESULT hr;
	//
	// Get Nat Capabilities - may block for a second.
	//
	
	memset(&g_NatHelpCaps,0,sizeof(DPNHCAPS));
	g_NatHelpCaps.dwSize=sizeof(DPNHCAPS);
	hr=IDirectPlayNATHelp_GetCaps(g_pINatHelp, &g_NatHelpCaps, DPNHGETCAPS_UPDATESERVERSTATUS);
	
	if(FAILED(hr))
	{
		DPF(0,"NatHelp failed to GetCaps, hr=%x\n",hr);
		return FALSE;
	}	

	if (hr == DPNHSUCCESS_ADDRESSESCHANGED)
	{
		DPF(1,"NAT Help reports addresses changed.");
	}

	return TRUE;

}

/*=============================================================================

	natInit	- Initialize nat helper i/f
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:


-----------------------------------------------------------------------------*/
BOOL natInit(VOID)
{
	BOOL bReturn = TRUE;
	HRESULT hr;
	char szNATHelpPath[256];
	PFN_DIRECTPLAYNATHELPCREATE pfnNatHelpCreate = NULL;
	BOOL fInitialized = FALSE;

	g_hNatHelp = NULL;
	g_pINatHelp = NULL;

	g_hNatHelpUDP = 0;


	//
	// See if there's a registry override.
	//
	hr = GetNATHelpDLLFromRegistry((LPGUID) (&DPSPGUID_TCPIP), szNATHelpPath, 256);
	if (hr != S_OK)
	{
		strcpy(szNATHelpPath, "dpnhpast.dll");
		DPF(4, "Couldn't get NatHelp DLL from registry, hr=%x, using default \"%s\".\n", hr, szNATHelpPath);
	}
	else
	{
		DPF(1, "Got NatHelp DLL \"%s\" from registry.\n", szNATHelpPath);
	}


	g_hNatHelp = LoadLibrary(szNATHelpPath);
	if (g_hNatHelp == NULL)
	{
		goto err_exit;
	}

	pfnNatHelpCreate = (PFN_DIRECTPLAYNATHELPCREATE) GetProcAddress(g_hNatHelp, "DirectPlayNATHelpCreate");
	if (pfnNatHelpCreate == NULL)
	{
		goto err_exit;
	}

	hr = pfnNatHelpCreate(&IID_IDirectPlayNATHelp, (void **) (&g_pINatHelp));
	if (hr != DP_OK)
	{
	    goto err_exit;
	}


	//
	// Initialize the Nat helper interface.
	//
	
	hr = IDirectPlayNATHelp_Initialize(g_pINatHelp, 0);
	if (hr != DP_OK)
	{
		DPF(0, "NatHelp failed to Initialize, hr=%x\n", hr);
		goto err_exit;
	}
	
	fInitialized = TRUE;

	if (! natGetCapsUpdate())
	{
		goto err_exit;
	}

	return TRUE;


	err_exit:
		
	if (g_pINatHelp)
	{
		if (fInitialized)
		{
			IDirectPlayNATHelp_Close(g_pINatHelp, 0);
		}
	
		IDirectPlayNATHelp_Release(g_pINatHelp);
		g_pINatHelp = NULL;
	}	

	if (g_hNatHelp)
	{
		FreeLibrary(g_hNatHelp);
		g_hNatHelp = NULL;
	}
	

	return FALSE;
}

/*=============================================================================

	natExtend - checks if port leases needs extension and extends 
					 them if necessary
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID natExtend(VOID)
{
	natGetCapsUpdate();
}

/*=============================================================================

	natFini - Shut down NATHELP support
	
	
    Description:


    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID natFini(VOID)
{

	// natDeregisterPorts(pgd); - vance says we don't need to do this.
	if(g_pINatHelp)
	{
        IDirectPlayNATHelp_Close(g_pINatHelp, 0);
	    g_hNatHelpUDP = 0;
		IDirectPlayNATHelp_Release(g_pINatHelp);
		g_pINatHelp=NULL;
	}	

	if(g_hNatHelp)
	{
		FreeLibrary(g_hNatHelp);
		g_hNatHelp=NULL;
	}
		
}

/*=============================================================================

	natRegisterUDPPort - Get a port mapping.
	
	
    Description:

        Map the shared port

    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
HRESULT natRegisterUDPPort(WORD port)
{
	SOCKADDR_IN 	sockaddr_in, sockaddr_inpublic;
	DWORD			dwFlags, dwSize;
	DPNHHANDLE		hPortMapping;
	HRESULT 		hr;


    if (!g_hNatHelpUDP)
    {	
    	memset(&sockaddr_in , 0 ,sizeof(sockaddr_in));
    	sockaddr_in.sin_family          = AF_INET;
    	sockaddr_in.sin_addr.S_un.S_addr= INADDR_ANY;
    	sockaddr_in.sin_port            = port;	// port is already in network byte order

    	dwFlags = DPNHREGISTERPORTS_SHAREDPORTS|DPNHREGISTERPORTS_FIXEDPORTS;

    	hr = IDirectPlayNATHelp_RegisterPorts(g_pINatHelp, (SOCKADDR *)&sockaddr_in, sizeof(sockaddr_in), 1, 15*60000, &hPortMapping, dwFlags);
    	if (hr != DPNH_OK)
    	{
    		DPF(0,"NATHelp_RegisterPorts failed, hr=%x",hr);
    		hr = DPERR_GENERIC;
    	}
    	else
    	{
	    	dwSize=sizeof(sockaddr_inpublic);
	    	hr = IDirectPlayNATHelp_GetRegisteredAddresses(g_pINatHelp, hPortMapping, (SOCKADDR *)&sockaddr_inpublic, &dwSize, NULL, NULL, 0);
	    	switch (hr)
	    	{
	    		case DPNH_OK:
	    		{
			    	DEBUGPRINTADDR(2, "NATHelp successfully mapped port to ", (SOCKADDR *)&sockaddr_inpublic);
		    		
			   		g_hNatHelpUDP = hPortMapping;
			   		
		    		//hr = DP_OK;
	  				break;
	    		}
	    		
	    		case DPNHERR_PORTUNAVAILABLE:
	    		{
		      		DPF(0, "NATHelp reported port %u is unavailable!",
		      			MAKEWORD(HIBYTE(port), LOBYTE(port)));
		    		
		    		hr = IDirectPlayNATHelp_DeregisterPorts(g_pINatHelp, hPortMapping, 0);
		    		if (hr != DP_OK)
		    		{
		    			DPF(0,"NATHelp_DeregisterPorts PAST returned 0x%lx\n",hr);
		    		}

		    		hr = DPNHERR_PORTUNAVAILABLE;
	  				break;
	    		}

	    		default:
	    		{
			    	DPF(1, "NATHelp couldn't map port %u, (err = 0x%lx).",
			    		MAKEWORD(HIBYTE(port), LOBYTE(port)),
			    		hr);
			    	
				   	g_hNatHelpUDP = hPortMapping;
				   	
				   	hr = DPERR_GENERIC;
				   	break;
	    		}
	    	}
    	}
    }
    else
    {
    	DPF(1, "Already registered port with NAT Help, not registering %u.",
    		MAKEWORD(HIBYTE(port), LOBYTE(port)));
	    hr = DP_OK;
    }
    
	return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\dphelp.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.c
 *  Content:    allows the dplay winsock sp's to all share a single
 *      	server socket
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   18-jul-96  andyco  initial implementation
 *   25-jul-96	andyco	ddhelp now watches dplay procs so it can remove
 *						them from our list when they go away
 *   3-sep-96	andyco	don't get stale ip's - pick up a default ip whenever
 *						we add a servernode. bug 3716.
 *   2-oct-96	andyco	propagated from \orange\ddhelp.2 to \mustard\ddhelp
 *   3-oct-96	andyco	made the winmain crit section "cs" a global so we can take
 *						it in dphelps receive thread before forwarding requests
 *   21-jan-97	kipo	use LoadLibrary on "wsock32.dll" instead of statically
 *						linking to it so DDHELP will still run even when Winsock
 *						is not around. This lets DDRAW and DSOUND work. Fixes
 *						bug #68596.
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *   01-jan-2000 aarono aaded support for rsip
 *
 ***************************************************************************/
/*============================================================================
*                                                                             
*  Why this file exists :                                                     
*                                                                             
*   when you want to find a dplay game, you send a message to a well      
*   known port (an enumrequest).                                          
*                                                                             
*   if a game is being hosted on that system, it will listen on that      
*   port, and respond to the message.                                     
*                                                                             
*   BUT, only one process can listen on a given socket.                  
*                                                                             
*   So, we let ddhelp.exe listen on that socket, and forward enumrequests 
*   to all games registered as being hosted on this system.
*	
*   see also : \%MANROOT%\dplay\wsock\dpsp.h
*                                                                             
*****************************************************************************/

// todo - should we return error codes on AddServer xproc to our caller?

#include "dphelp.h"

#undef DPF_MODNAME
#define DPF_MODNAME "DPHELP"

/*
 *  GLOBALS
 */ 
SOCKET gsDatagramListener = INVALID_SOCKET; // we listen for datagrams on this socket
SOCKET gsForwardSocket = INVALID_SOCKET;
SOCKET gsStreamListener;					// we listen for tcp connections on this socket
LPSPNODE gNodeList;
BOOL gbInit=FALSE,gbIPStarted=FALSE;
HANDLE ghDatagramReceiveThread,ghStreamReceiveThread;
BOOL gbReceiveShutdown;						// receive thread will exit when TRUE

// pointers to Winsock routines returned from GetProcAddress
cb_accept			g_accept;
cb_bind				g_bind;
cb_closesocket		g_closesocket;
cb_gethostbyname	g_gethostbyname;
cb_gethostname		g_gethostname;
cb_getpeername		g_getpeername;
cb_getsockname		g_getsockname;
cb_inet_ntoa		g_inet_ntoa;
cb_recvfrom			g_recvfrom;
cb_recv				g_recv;
cb_select			g_select;
cb_send				g_send;
cb_sendto			g_sendto;
cb_setsockopt		g_setsockopt;
cb_shutdown			g_shutdown;
cb_socket			g_socket;
cb_WSAFDIsSet		g_WSAFDIsSet;
cb_WSAGetLastError	g_WSAGetLastError;
cb_WSAStartup		g_WSAStartup;
cb_listen			g_listen;
cb_htons			g_htons;
cb_ntohs			g_ntohs;
cb_inet_addr		g_inet_addr;
cb_htonl            g_htonl;

#ifdef DEBUG

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintAddr"

// helper function called from DEBUGPRINTADDR macro
void DebugPrintAddr(UINT nLevel,LPSTR pStr,SOCKADDR * psockaddr)
{
    SOCKADDR_IN * pin = (SOCKADDR_IN *)psockaddr;

     DPF(nLevel,"%s af = AF_INET : address =  %s : port = %d\n",pStr,
     	g_inet_ntoa(pin->sin_addr),g_htons(pin->sin_port));

} // DebugPrintAddr

#undef DPF_MODNAME
#define DPF_MODNAME	"DebugPrintSocket"

void DebugPrintSocket(UINT level,LPSTR pStr,SOCKET * pSock) 
{
	SOCKADDR sockaddr;
	int addrlen=sizeof(sockaddr);

	g_getsockname(*pSock,&sockaddr,&addrlen);
	DEBUGPRINTADDR(level,pStr,&sockaddr);
	
}

#endif // debug

// this is called every time we add a new server node to our list...
HRESULT GetDefaultHostAddr(DWORD * puHostAddr)
{

//	a-josbor: we used to get the first interface and use that, but WebTV taught
//		us that that can be dangerous.  So we just use the loopback address.
//		It's guaranteed to be there.  Or so they say...

    *puHostAddr = 0x0100007f;	// loopback	127.0.0.1 (<bleeping> little-endian)
	
    return DP_OK;
	
} // GetDefaultHostAddr

// the functions DPlayHelp_xxx are called from dphelp.c

//
// add a new node to our list of servers which want to have enum 
// requests forwarded to them...
HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd)
{
    LPSPNODE pNode;
    BOOL bFoundIt=FALSE;
    HRESULT hr;
	
    if (!gbInit) 
    {
		hr = DPlayHelp_Init();
		if (FAILED(hr))
		{
			DPF_ERR("dphelp : could not init wsock ! not adding server");
			return (hr);
		}
    }

    // see if we're already watching this process
	// if we are, we won't start a watcher thread (below)
    pNode = gNodeList;

    // search the list 
    while (pNode && !bFoundIt)
    {
		if (pNode->pid == phd->pid) bFoundIt = TRUE;
		pNode = pNode->pNextNode;
    }

	//
	// now, build a new server node
    pNode = MemAlloc(sizeof(SPNODE));
    if (!pNode)
    {
        DPF_ERR("could not add new server node OUT OF MEMORY");
        return (DPERR_OUTOFMEMORY);
    }
    
    pNode->pid = phd->pid;
    // build the sockaddr
    // dwReserved1 of the phd is the port that the server is listening on
    pNode->sockaddr.sin_family =  AF_INET;
    
    // find the default ip to use w/ this host
    hr = GetDefaultHostAddr(&(pNode->sockaddr.sin_addr.s_addr));
	if (FAILED(hr))
    {
        DPF_ERR("could not get host IP address");
		MemFree(pNode);
        return (DPERR_UNAVAILABLE);
    }
    
    pNode->sockaddr.sin_port = phd->port;

    DPF(5,"dphelp :: adding new server node : pid = %d, port = %d\n",phd->pid,g_htons(phd->port));

    // link our new node onto the beginning of the list
    pNode->pNextNode = gNodeList;
    gNodeList = pNode;

	// see if we need to start our watcher thread    
    if (!bFoundIt)
    {
		//
	    // set up a thread to keep on eye on this process.
	    // we'll let the thread notify us when the process goes away
	    WatchNewPid(phd);
    }

    return (DP_OK);

} // DPlayHelp_AddServer

//
// delete the server node from proc pid from our list
// called by "ThreadProc" from DPHELP.c when the process that
// goes away, or from the client side when a session goes away.
//
// if bFreeAll is TRUE, we delete all server nodes for process
// phd->pid.  otherwise, we just delete the first server node whose
// port matches phd->port
//
BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL bFreeAll)
{
    BOOL bFoundIt = FALSE;
    LPSPNODE pNode,pNodePrev,pNodeNext;

    pNode = gNodeList;
    pNodePrev = NULL;
	pNodeNext = NULL;
	
    // search the whole list
    while (pNode && !bFoundIt)
    {
		// if we have the right pid, and it's either FreeAll or the right port - cruise it!
		if ((pNode->pid == phd->pid) &&  (bFreeAll || (pNode->sockaddr.sin_port == phd->port)) )
		{
		    // remove it from the list
		    if (pNodePrev) pNodePrev->pNextNode = pNode->pNextNode;
		    else gNodeList = pNode->pNextNode;
			
		    if (bFreeAll) 
		    {
				// pick up the next one b4 we free pNode
				pNodeNext = pNode->pNextNode;
		    }
			else 
			{
				// mark us as done
				bFoundIt = TRUE;
				pNodeNext = NULL;
			}

		    DPF(5,"dphelp :: deleting server node : pid = %d\n",pNode->pid);
		    // free up the node
		    MemFree(pNode);

			pNode = pNodeNext;
			// pNodePrev doesn't change here...
		}
		else 
		{
		    // just get the next one
		    pNodePrev = pNode;
		    pNode = pNode->pNextNode;
		}
    }


    return FALSE;

} // DPlayHelp_DeleteServer 

//
// poke an ip addr into a message blob 
// code stolen from \orange\dplay\wsock\winsock.c
void IP_SetAddr(LPVOID pmsg,SOCKADDR_IN * paddrSrc)
{
    LPSOCKADDR_IN  paddrDest; // tempo variable, makes casting less ugly
    LPMESSAGEHEADER phead;

    phead = (LPMESSAGEHEADER)pmsg;

    paddrDest = (SOCKADDR_IN *)&(phead->sockaddr);
    // poke the new ip addr into the message header
    if(paddrDest->sin_addr.s_addr==0){ // don't rehome already homed messages
	    paddrDest->sin_addr.s_addr = paddrSrc->sin_addr.s_addr;
	}    

    return;
	
} // IP_SetAddr

//
// we get a message.  presumably its an enumrequest. forward it to all registered clients.
// we "home" the message (store the received ip addr w/ it) here, 'cause otherwise the clients
// would all think it came from us.  we change the token to srvr_token so the clients know it
// came from us (so they don't home it again)
void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN * psockaddr)
{
    LPSPNODE pNode = gNodeList;
    UINT addrlen = sizeof(SOCKADDR_IN);
    UINT err;
	
    ASSERT(VALID_SP_MESSAGE(pBuffer));

    // reset the old token
    *( (DWORD *)pBuffer) &= ~TOKEN_MASK;
    // set the new token
    *( (DWORD *)pBuffer) |= HELPER_TOKEN;

    // home it
    IP_SetAddr((LPVOID)pBuffer,psockaddr);
    
    // now, forward the message to all registered servers
    while (pNode)
    {
		DEBUGPRINTADDR(7,"dplay helper  :: forwarding enum request to",(SOCKADDR *)&(pNode->sockaddr));
		// send out the enum message
        err = g_sendto(gsForwardSocket,pBuffer,dwBufferSize,0,(LPSOCKADDR)&(pNode->sockaddr),
    		addrlen);
        if (SOCKET_ERROR == err) 
        {
    	    err = g_WSAGetLastError();
	    	DPF(0,"dphelp : send failed err = %d\n",err);
        }

        pNode = pNode->pNextNode;
    }

    return ;

} // HandleIncomingMessage

//
// BUF_SIZE is our initial guess at a receive buffer size
// if we get an enum request bigger than this, we'll realloc our
// buffer, and receive successfully if they send again
// (the only way this could happen is if they have password > ~ 1000
// bytes).
#define BUF_SIZE 1024

//
// listen on our socket for enum requests
DWORD WINAPI ListenThreadProc(LPVOID pvUnused)
{
    UINT err;
    LPBYTE pBuffer=NULL;
    INT addrlen=sizeof(SOCKADDR);
    SOCKADDR sockaddr; // the from address
    DWORD dwBufSize = BUF_SIZE;

    DPF(2,"dphelp :: starting udp listen thread ");

    pBuffer = MemAlloc(BUF_SIZE);
    if (!pBuffer)
    {
        DPF_ERR("could not alloc dgram receive buffer");
        ExitThread(0);
        return 0;
    }
    while (1)
    {
        err = g_recvfrom(gsDatagramListener,pBuffer,dwBufSize,0,&sockaddr,&addrlen);
        if (SOCKET_ERROR == err) 
        {
            err = g_WSAGetLastError();
            if (WSAEMSGSIZE == err)
            {
                LPBYTE pNewBuffer;

                // buffer too small!
                dwBufSize *= 2;

	    	    DPF(9,"\n udp recv thread - resizing buffer newsize = %d\n",dwBufSize);
                pNewBuffer = MemReAlloc(pBuffer,dwBufSize);
                if (!pNewBuffer)
                {
                    DPF_ERR("could not realloc dgram receive buffer");
                    goto ERROR_EXIT;
                }
                pBuffer = pNewBuffer;
                // we can't do anything with this message, since it was truncated...
            } // WSAEMSGSIZE
            else 
            {
		#ifdef DEBUG
            	if (WSAEINTR != err) 
		        {
				    // WSAEINTR is what winsock uses to break a blocking socket out of 
				    // its wait.  it means someone killed this socket.
				    // if it's not that, then it's a real error.
		            DPF(0,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);
            	}
				else
				{
				    DPF(9,"\n udp recv error - err = %d socket = %d",err,(DWORD)gsDatagramListener);				
				}
		#endif // DEBUG 

                // we bail on errors other than WSAEMSGSIZE
                goto ERROR_EXIT;
            }
        } // SOCKET_ERROR
        else if ((err >= sizeof(DWORD)) &&  VALID_SP_MESSAGE(pBuffer))
        {
            // now, if we succeeded, err is the # of bytes read
	    	DEBUGPRINTADDR(9,"dplay helper  :: received enum request from ",(SOCKADDR *)&sockaddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pBuffer,err,(SOCKADDR_IN *)&sockaddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
        }
        else 
        {
            ASSERT(FALSE);
            // ?
        }
    } // 1

ERROR_EXIT:
    DPF(2,"UDP Listen thread exiting");
    if (pBuffer) MemFree(pBuffer);
    // all done
    ExitThread(0);
    return 0;

} // UDPListenThreadProc

// startup winsock and find the default ip addr for this machine
HRESULT  StartupIP()
{
    UINT err;
    WSADATA wsaData;
	HINSTANCE hWinsock;

	// load winsock library
    hWinsock = LoadLibrary("wsock32.dll");
	if (!hWinsock) 
	{
		DPF(0,"Could not load wsock32.dll\n");
		goto LOADLIBRARYFAILED;
	}

	// get pointers to the entry points we need

    g_accept = (cb_accept) GetProcAddress(hWinsock, "accept");
	if (!g_accept)
		goto GETPROCADDRESSFAILED;

    g_bind = (cb_bind) GetProcAddress(hWinsock, "bind");
	if (!g_bind)
		goto GETPROCADDRESSFAILED;
		
    g_closesocket = (cb_closesocket) GetProcAddress(hWinsock, "closesocket");
	if (!g_closesocket)
		goto GETPROCADDRESSFAILED;

    g_gethostbyname = (cb_gethostbyname) GetProcAddress(hWinsock, "gethostbyname");
	if (!g_gethostbyname)
		goto GETPROCADDRESSFAILED;
		
    g_gethostname = (cb_gethostname) GetProcAddress(hWinsock, "gethostname");
	if (!g_gethostname)
		goto GETPROCADDRESSFAILED;

    g_getpeername = (cb_getpeername) GetProcAddress(hWinsock, "getpeername");
	if (!g_getpeername)
		goto GETPROCADDRESSFAILED;

    g_getsockname = (cb_getsockname) GetProcAddress(hWinsock, "getsockname");
	if (!g_getsockname)
		goto GETPROCADDRESSFAILED;

    g_htons = (cb_htons) GetProcAddress(hWinsock, "htons");
	if (!g_htons)
		goto GETPROCADDRESSFAILED;
		
    g_inet_ntoa = (cb_inet_ntoa) GetProcAddress(hWinsock, "inet_ntoa");
	if (!g_inet_ntoa)
		goto GETPROCADDRESSFAILED;

    g_listen = (cb_listen) GetProcAddress(hWinsock, "listen");
	if (!g_listen)
		goto GETPROCADDRESSFAILED;
		
    g_recv = (cb_recv) GetProcAddress(hWinsock, "recv");
	if (!g_recv)
		goto GETPROCADDRESSFAILED;

    g_recvfrom = (cb_recvfrom) GetProcAddress(hWinsock, "recvfrom");
	if (!g_recvfrom)
		goto GETPROCADDRESSFAILED;

    g_select = (cb_select) GetProcAddress(hWinsock, "select");
	if (!g_select)
		goto GETPROCADDRESSFAILED;

    g_send = (cb_send) GetProcAddress(hWinsock, "send");
	if (!g_send)
		goto GETPROCADDRESSFAILED;

    g_sendto = (cb_sendto) GetProcAddress(hWinsock, "sendto");
	if (!g_sendto)
		goto GETPROCADDRESSFAILED;

    g_setsockopt = (cb_setsockopt) GetProcAddress(hWinsock, "setsockopt");
	if (!g_setsockopt)
		goto GETPROCADDRESSFAILED;

    g_shutdown = (cb_shutdown) GetProcAddress(hWinsock, "shutdown");
	if (!g_shutdown)
		goto GETPROCADDRESSFAILED;

    g_socket = (cb_socket) GetProcAddress(hWinsock, "socket");
	if (!g_socket)
		goto GETPROCADDRESSFAILED;

    g_ntohs = (cb_ntohs) GetProcAddress(hWinsock, "ntohs");
	if (!g_ntohs)
		goto GETPROCADDRESSFAILED;
		
    g_htonl = (cb_htonl) GetProcAddress(hWinsock, "htonl");
	if (!g_htonl)
		goto GETPROCADDRESSFAILED;
		
    g_inet_addr = (cb_inet_addr) GetProcAddress(hWinsock, "inet_addr");
	if (!g_inet_addr)
		goto GETPROCADDRESSFAILED;

    g_WSAFDIsSet = (cb_WSAFDIsSet) GetProcAddress(hWinsock, "__WSAFDIsSet");
	if (!g_WSAFDIsSet)
		goto GETPROCADDRESSFAILED;
		
	g_WSAGetLastError = (cb_WSAGetLastError) GetProcAddress(hWinsock, "WSAGetLastError");
	if (!g_WSAGetLastError)
		goto GETPROCADDRESSFAILED;

    g_WSAStartup = (cb_WSAStartup) GetProcAddress(hWinsock, "WSAStartup");
	if (!g_WSAStartup)
		goto GETPROCADDRESSFAILED;

	// start up sockets, asking for version 1.1
    err = g_WSAStartup(MAKEWORD(1,1), &wsaData);
    if (err) 
    {
        DPF(0,"dphelp :: could not start winsock err = %d\n",err);
        goto WSASTARTUPFAILED;
    }
    DPF(3,"dphelp :: started up winsock succesfully");
    
	gbIPStarted=TRUE;
	
    return DP_OK;

GETPROCADDRESSFAILED:
	DPF(0,"Could not find required Winsock entry point");
WSASTARTUPFAILED:
	FreeLibrary(hWinsock);
LOADLIBRARYFAILED:
	return DPERR_UNAVAILABLE;
} // StartupIP

// helper function to create the socket we listen on
HRESULT GetSocket(SOCKET * psock,DWORD type,PORT port,BOOL bBroadcast,BOOL bListen)
{
    SOCKADDR_IN sockaddr;
    UINT err;
    SOCKET sNew;

    sNew = g_socket( AF_INET, type, 0);
    if (INVALID_SOCKET == sNew) 
    {
        goto ERROR_EXIT;
    }

    // set up the sockaddr to bind to
    sockaddr.sin_family         = PF_INET;
    sockaddr.sin_addr.s_addr    = INADDR_ANY;
    sockaddr.sin_port           = port;

    // do the bind
    if( SOCKET_ERROR == g_bind( sNew, (LPSOCKADDR)&sockaddr, sizeof(sockaddr) ) )
    {
        goto ERROR_EXIT;
    }

    if (bBroadcast)
    {
		BOOL bTrue = TRUE;

        if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_BROADCAST,(char FAR *)&bTrue,
	    	sizeof(bTrue) ) )
		{
            err = g_WSAGetLastError();
		    DPF(0," dphelp - create - could not set broadcast err = %d\n",err);
		    // not really tragic, since for AF_INET it's not required to set broadcast 
		    // b4 receiving w/ MS winsock...
		}
    }

    if (bListen)
    {
	    LINGER Linger;
	    
	    // set up socket w/ max listening connections
	    err = g_listen(sNew,LISTEN_BACKLOG);
	    if (SOCKET_ERROR == err) 
	    {
	        err = g_WSAGetLastError();
	        DPF(0,"init listen socket / listen error - err = %d\n",err);
	        goto ERROR_EXIT;
	    }

		// set for hard disconnect
		Linger.l_onoff=1;
		Linger.l_linger=0;
	    
	    if( SOCKET_ERROR == g_setsockopt( sNew,SOL_SOCKET,SO_LINGER,
			(char FAR *)&Linger,sizeof(Linger) ) )
	    {
	        err = g_WSAGetLastError();
			DPF(0,"Failed to set linger option on the socket = %d\n",err);
	    }    
    }

    // success!
    *psock = sNew;
    return DP_OK;

ERROR_EXIT:
    // clean up and bail
    err = g_WSAGetLastError();
    DPF(0,"dphelp - could not get helper socket :: err = %d\n",err);
    if (INVALID_SOCKET != sNew)
    {
        g_closesocket(sNew);
    } 
    return E_FAIL;

}   // GetSocket

void CloseSocket(SOCKET * psSocket)
{
    UINT err;

    if (INVALID_SOCKET != *psSocket)
    {
    	if (SOCKET_ERROR == g_closesocket(*psSocket)) 
    	{
            err = g_WSAGetLastError();
    	    DPF(1,"dphelp : killsocket - socket close err = %d\n",err);
		}
	
		*psSocket = INVALID_SOCKET;
    }
    
    return ;

} // CloseSocket

HRESULT DPlayHelp_Init()
{
    DWORD dwThreadID;
    HRESULT hr;

    // start winsock, and get the default ip addr for this system
    if(!gbIPStarted){
	    hr = StartupIP();
	    if (FAILED(hr))
	    {
	        return hr; // StartupIP will have printed an error
	    }
	}

    // get the listen socket
    hr = GetSocket(&gsDatagramListener,SOCK_DGRAM,SERVER_DGRAM_PORT,TRUE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get the forward socket
    hr = GetSocket(&gsForwardSocket,SOCK_DGRAM,0,FALSE,FALSE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    // get us a enum sessions stream listener
	hr = GetSocket(&gsStreamListener,SOCK_STREAM,SERVER_STREAM_PORT,FALSE,TRUE);
    if (FAILED(hr))
    {
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
	

    ghDatagramReceiveThread = CreateThread(NULL,0,ListenThreadProc,NULL,0,&dwThreadID);
    if (!ghDatagramReceiveThread)
    {
        DPF_ERR("could not create udp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }

    ghStreamReceiveThread = CreateThread(NULL,0,StreamReceiveThreadProc,NULL,0,&dwThreadID);
    if (!ghStreamReceiveThread)
    {
        DPF_ERR("could not create tcp listen thread");
		hr = E_FAIL;
        goto ERROR_EXIT; // GetSocket will have printed an error
    }
    

    DPF(5,"DPLAYHELP : init succeeded");
    gbInit = TRUE;
    return DP_OK;

ERROR_EXIT:
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);
    CloseSocket(&gsStreamListener);

    return hr;

} // DPlayHelp_Init 

void DPlayHelp_FreeServerList()
{
    LPSPNODE pNodeKill,pNodeNext;

    pNodeNext = gNodeList;

    // search the whole list
    while (pNodeNext)
    {
		// kill this node
		pNodeKill = pNodeNext;
		// but first, remember what's next
		pNodeNext = pNodeKill->pNextNode;
		// free up the node
		MemFree(pNodeKill);
    }
	
    CloseSocket(&gsDatagramListener);
    CloseSocket(&gsForwardSocket);

	// close stream receive
	RemoveSocketFromList(gsStreamListener);
	gbReceiveShutdown = TRUE;
	
	// drop the lock so the threads can exit - they might be waiting on
	// the lock for cleanup
	LEAVE_DPLAYSVR();
		
    // wait for the threads to go away
   	if (ghDatagramReceiveThread) 
   		WaitForSingleObject(ghDatagramReceiveThread, INFINITE);
    if (ghStreamReceiveThread) 
    	WaitForSingleObject(ghStreamReceiveThread, INFINITE);
    
    ENTER_DPLAYSVR();
    
    if (ghDatagramReceiveThread)
    {
    	DPF(5,"datagram receive thread exited!");
	    CloseHandle(ghDatagramReceiveThread);
	    ghDatagramReceiveThread = NULL;
    }
    if (ghStreamReceiveThread)
    {
	    DPF(5,"stream receive thread exited!");
	    CloseHandle(ghStreamReceiveThread);
	    ghStreamReceiveThread = NULL;
    }


    return ;
    
} // DPlayHelp_FreeServerList



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\dphelp.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dphelp.h
 *  Content:	header for dphelp.c
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-jul-96	andyco	initial implementation
 *   25-jul-96	andyco	added watchnewpid
 *	 23-jan-97	kipo	prototypes for winsock calls
 *	 15-feb-97	andyco	moved from ddhelp to the project formerly known as
 *						ddhelp (playhelp? dplayhlp? dplay.exe? dphost?)  Allowed
 *						one process to host mulitple sessions
 *	 29-jan-98	sohailm	added support for stream enum sessions
 *   12-jan-2000 aarono added support for rsip
 *
 ***************************************************************************/

#ifndef __DPHELP_INCLUDED__
#define __DPHELP_INCLUDED__

#include "windows.h"
#include "dplaysvr.h"
#include "newdpf.h"
#include "winsock.h"
// we include dpsp.h since we'll be poking bits (sockaddr's)
// into dpsp's header
#include "dpsp.h"

// backlog for listen() api.  no constant in winsock, so we ask for the moon
#define LISTEN_BACKLOG 	60

typedef struct _SPNODE * LPSPNODE;

typedef struct _SPNODE
{
	SOCKADDR_IN sockaddr;  // socket addr of server
	DWORD pid;
	LPSPNODE  pNextNode;
} SPNODE;

// protos

// from dphelp.c
extern HRESULT DPlayHelp_AddServer(LPDPHELPDATA phd);
extern BOOL FAR PASCAL DPlayHelp_DeleteServer(LPDPHELPDATA phd,BOOL fFreeAll);
extern HRESULT DPlayHelp_Init();
extern HRESULT  StartupIP();
extern void DPlayHelp_FreeServerList();
extern DWORD WINAPI StreamAcceptThreadProc(LPVOID pvCast);
extern DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast);
extern void HandleIncomingMessage(LPBYTE pBuffer,DWORD dwBufferSize,SOCKADDR_IN * psockaddr);

// from help.c
extern void WatchNewPid(LPDPHELPDATA phd);

// from reliable.c
void RemoveSocketFromList(SOCKET socket);


//prototypes for winsock calls
typedef int (PASCAL FAR * cb_accept)(SOCKET s, struct sockaddr FAR * addr, int FAR * addrlen);
extern cb_accept	g_accept;

typedef int (PASCAL FAR * cb_bind)(SOCKET s, const struct sockaddr FAR *addr, int namelen);
extern	cb_bind	g_bind;

typedef int (PASCAL FAR * cb_closesocket)(SOCKET s);
extern	cb_closesocket	g_closesocket;

typedef struct hostent FAR * (PASCAL FAR * cb_gethostbyname)(const char FAR * name);
extern	cb_gethostbyname	g_gethostbyname;

typedef int (PASCAL FAR * cb_gethostname)(char FAR * name, int namelen);
extern	cb_gethostname	g_gethostname;

typedef int (PASCAL FAR * cb_getpeername)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getpeername	g_getpeername;

typedef int (PASCAL FAR * cb_getsockname)(SOCKET s, struct sockaddr FAR * name, int FAR * namelen);
extern	cb_getsockname	g_getsockname;

typedef u_short (PASCAL FAR * cb_htons)(u_short hostshort);
extern	cb_htons		g_htons;

typedef char FAR * (PASCAL FAR * cb_inet_ntoa)(struct in_addr in);
extern	cb_inet_ntoa	g_inet_ntoa;

typedef int (PASCAL FAR * cb_listen)(
    SOCKET s,
    int backlog
    );
extern cb_listen		g_listen;

typedef int (PASCAL FAR * cb_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    );
extern cb_recv		g_recv;

typedef int (PASCAL FAR * cb_recvfrom)(SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);
extern	cb_recvfrom	g_recvfrom;

typedef SOCKET (PASCAL FAR * cb_select)(
    int nfds,
    fd_set FAR * readfds,
    fd_set FAR * writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR * timeout
    );
extern cb_select	g_select;

typedef int (PASCAL FAR * cb_send)(SOCKET s, const char FAR * buf, int len, int flags);
extern	cb_send		g_send;

typedef int (PASCAL FAR * cb_sendto)(SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);
extern	cb_sendto	g_sendto;

typedef int (PASCAL FAR * cb_setsockopt)(SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);
extern	cb_setsockopt	g_setsockopt;

typedef int (PASCAL FAR * cb_shutdown)(SOCKET s, int how);
extern cb_shutdown	g_shutdown;

typedef SOCKET (PASCAL FAR * cb_socket)(int af, int type, int protocol);
extern	cb_socket	g_socket;

typedef int (PASCAL FAR * cb_WSAFDIsSet)(SOCKET, fd_set FAR *);
extern 	cb_WSAFDIsSet	g_WSAFDIsSet;

typedef int (PASCAL FAR * cb_WSAGetLastError)(void);
extern	cb_WSAGetLastError	g_WSAGetLastError;

typedef int (PASCAL FAR * cb_WSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
extern	cb_WSAStartup	g_WSAStartup;

typedef unsigned short (PASCAL FAR * cb_ntohs)(unsigned short netshort);
extern	cb_ntohs			g_ntohs;

typedef unsigned long (PASCAL FAR * cb_htonl)(unsigned long hostlong);
extern	cb_htonl            g_htonl;

typedef unsigned long (PASCAL FAR * cb_inet_addr)(const char *cp);
extern	cb_inet_addr			g_inet_addr;

extern BOOL gbInit,gbIPStarted;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpwsock.rc
//
#define IDD_DIALOG1                     101
#define IDD_SELECTSERVER                101
#define IDC_EDIT1                       1000
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\reliable.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       reliable.c
 *  Content:    stream communication related routines
 *  History:
 *   Date   	By  	Reason
 *   ====   	==  	======
 *   01-29-98  	sohailm	initial implementation
 *   02-15-98  a-peterz	Remove unused SetMessageHeader
 *   02-10-00  aarono   only allow one enum per socket then turf it.
 *
 ***************************************************************************/
#include "dphelp.h"

/*
 * Globals
 */
FDS	gReadfds;							// fd set to receive data
RECEIVELIST gReceiveList;				// list of connections + listener

/*
 * Externs
 */
extern SOCKET gsStreamListener;			// we listen for tcp connections on this socket
extern gbReceiveShutdown;				// receive thread will exit when TRUE
extern LPSPNODE gNodeList;

#undef DPF_MODNAME
#define DPF_MODNAME	"MakeBufferSpace"

// make sure the buffer is big enough to fit the message size
HRESULT MakeBufferSpace(LPBYTE * ppBuffer,LPDWORD pdwBufferSize,DWORD dwMessageSize)
{
	HRESULT hr = DP_OK;

	ASSERT(ppBuffer);
	ASSERT(pdwBufferSize);
		    
	ENTER_DPLAYSVR();
	
	if (!*ppBuffer)
	{
		DPF(9, "Allocating space for message of size %d", dwMessageSize);

		// need to alloc receive buffer?
		*ppBuffer = MemAlloc(dwMessageSize);
        if (!*ppBuffer)
        {
        	DPF_ERR("could not alloc stream receive buffer - out of memory");        
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
        }
		*pdwBufferSize = dwMessageSize;
	}
	// make sure receive buffer can hold data
	else if (dwMessageSize > *pdwBufferSize) 
	{
		LPVOID pvTemp;

		DPF(9, "ReAllocating space for message of size %d", dwMessageSize);

		// realloc buffer to hold data
		pvTemp = MemReAlloc(*ppBuffer,dwMessageSize);
		if (!pvTemp)
		{
        	DPF_ERR("could not realloc stream receive buffer - out of memory");
            hr = E_OUTOFMEMORY;
            goto CLEANUP_EXIT;
		}
		*ppBuffer = pvTemp;
		*pdwBufferSize = dwMessageSize;
	}

    // fall through
    
CLEANUP_EXIT: 
    
	LEAVE_DPLAYSVR();
    return hr;    
    
}  // MakeBufferSpace

#undef DPF_MODNAME
#define DPF_MODNAME	"AddSocketToReceiveList"

HRESULT AddSocketToReceiveList(SOCKET sSocket)
{
    UINT i = 0;
    UINT err, iNewSlot;
	BOOL bFoundSlot = FALSE;
    HRESULT hr = DP_OK;
    INT addrlen=sizeof(SOCKADDR);
	LPCONNECTION pNewConnection;
    
    ENTER_DPLAYSVR();
	
    // look for an empty slot 
    while ( (i < gReceiveList.nConnections) && !bFoundSlot)
    {
    	if (INVALID_SOCKET == gReceiveList.pConnection[i].socket)
    	{
    		bFoundSlot = TRUE;			
			iNewSlot = i;
    	}
        else 
        {
        	i++;
        }
    }
    
    if (!bFoundSlot)
    {
		DWORD dwCurrentSize,dwNewSize;
		
		// allocate space for list of connections
		dwCurrentSize = gReceiveList.nConnections * sizeof(CONNECTION);
		dwNewSize = dwCurrentSize +  INITIAL_RECEIVELIST_SIZE * sizeof(CONNECTION);		
		hr =  MakeBufferSpace((LPBYTE *)&(gReceiveList.pConnection),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // set all the new entries to INVALID
        for (i = gReceiveList.nConnections + 1; 
        	i < gReceiveList.nConnections + INITIAL_RECEIVELIST_SIZE; i++ )
        {
        	gReceiveList.pConnection[i].socket = INVALID_SOCKET;
        }
        
        // store the new socket in the 1st new spot
		iNewSlot = gReceiveList.nConnections;

        // allocate space for an fd set (fd_count + fd_array)
		if (gReceiveList.nConnections)
		{
	        dwCurrentSize = sizeof(u_int) + gReceiveList.nConnections * sizeof(SOCKET);
	        dwNewSize =	dwCurrentSize + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		else
		{
			dwCurrentSize = 0;
			dwNewSize = sizeof(u_int) + INITIAL_RECEIVELIST_SIZE * sizeof(SOCKET);
		}
		hr =  MakeBufferSpace((LPBYTE *)&(gReadfds.pfdbigset),&dwCurrentSize,dwNewSize);
		if (FAILED(hr))
		{
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}		
		ASSERT(dwCurrentSize == dwNewSize);
		
        // update the # of connections
        gReceiveList.nConnections += INITIAL_RECEIVELIST_SIZE; 
		// update the fd_array buffer size
		gReadfds.dwArraySize = gReceiveList.nConnections;
        
    } // !bFoundSlot

	// Initialize new connection 
	pNewConnection = &(gReceiveList.pConnection[iNewSlot]);
    pNewConnection->socket = sSocket;
	// allocate a default receive buffer
	pNewConnection->pDefaultBuffer = MemAlloc(DEFAULT_RECEIVE_BUFFERSIZE);
	if (NULL == pNewConnection->pDefaultBuffer)
	{
        DPF_ERR("could not alloc default receive buffer - out of memory");        
		hr = E_OUTOFMEMORY;
		goto CLEANUP_EXIT;
	}
	// receive buffer initially points to our default buffer
	pNewConnection->pBuffer = pNewConnection->pDefaultBuffer;
	// remember the address we are connected to
	err = g_getpeername(pNewConnection->socket, &(pNewConnection->sockAddr), &addrlen);
	if (SOCKET_ERROR == err) 
	{
		err = g_WSAGetLastError();
		DPF(1,"could not getpeername err = %d\n",err);
	}

	DPF(9, "Added new socket at index %d", iNewSlot);

CLEANUP_EXIT:
    
	LEAVE_DPLAYSVR();
    return hr;
    
}  // AddSocketToReceiveList

#undef DPF_MODNAME
#define DPF_MODNAME	"KillSocket"

HRESULT KillSocket(SOCKET sSocket,BOOL fStream,BOOL fHard)
{
	UINT err;

    if (INVALID_SOCKET == sSocket) 
    {
		return E_FAIL;
    }

	if (!fStream)
    {
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - dgram close err = %d\n",err);
			return E_FAIL;
        }
    }
	else 
	{
		LINGER Linger;

	   	if (fHard)
		{
			Linger.l_onoff=TRUE; // turn linger on
			Linger.l_linger=0; // nice small time out

		    if( SOCKET_ERROR == g_setsockopt( sSocket,SOL_SOCKET,SO_LINGER,(char FAR *)&Linger,
		                    sizeof(Linger) ) )
		    {
		        err = g_WSAGetLastError();
				DPF(0,"killsocket - stream setopt err = %d\n",err);
		    }
		}			
		#if 0
		// DON'T DO SHUTDOWN!  It leads to TIME_WAIT on sockets.
		
		if (SOCKET_ERROR == g_shutdown(sSocket,2)) 
		{
			// this may well fail, if e.g. no one is using this socket right now...
			// the error would be wsaenotconn 
	        err = g_WSAGetLastError();
			DPF(5,"killsocket - stream shutdown err = %d\n",err);
		}
		#endif
        if (SOCKET_ERROR == g_closesocket(sSocket)) 
        {
	        err = g_WSAGetLastError();
			DPF(0,"killsocket - stream close err = %d\n",err);
			return E_FAIL;
        }
    }

	return DP_OK;
	
}// KillSocket

void FreeConnection(LPCONNECTION pConnection)
{
	DEBUGPRINTSOCK(5,"Freeing connection - ",&pConnection->socket);

	// Kill them all hard so they don't wind up in TIME_WAIT state.
	KillSocket(pConnection->socket,TRUE,TRUE);

	if (pConnection->pBuffer && (pConnection->pBuffer != pConnection->pDefaultBuffer)) 
	{
		MemFree(pConnection->pBuffer);
		pConnection->pBuffer = NULL;
	}
	if (pConnection->pDefaultBuffer) 
	{
		MemFree(pConnection->pDefaultBuffer);
		pConnection->pDefaultBuffer = NULL;
	}

	// initialize connection 
    pConnection->socket = INVALID_SOCKET; // this tells us if connection is valid
	pConnection->dwCurMessageSize = 0;
	pConnection->dwTotalMessageSize = 0;
}

#undef DPF_MODNAME
#define DPF_MODNAME	"RemoveSocketFromList"

void RemoveSocketFromList(SOCKET socket)
{
    UINT i = 0;
	BOOL bFound = FALSE;

    ENTER_DPLAYSVR();
    
    // look for the corresponding connection
    while ( (i < gReceiveList.nConnections) && !bFound)
    {
    	if (gReceiveList.pConnection[i].socket == socket)
    	{
    		bFound = TRUE;
			FreeConnection(&gReceiveList.pConnection[i]);
    	}
        else 
        {
        	i++;
        }
    } // while
    
    LEAVE_DPLAYSVR();
	
	return ;	
}


#undef DPF_MODNAME
#define DPF_MODNAME	"EmptyConnectionList"

void EmptyConnectionList(void)
{
	UINT i;
	
	DPF(5, "Emptying connection list");
	
	ENTER_DPLAYSVR();
	
	for (i=0;i<gReceiveList.nConnections ;i++ )
	{
		if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
		{
			FreeConnection(&(gReceiveList.pConnection[i]));
		}
	}
	
	LEAVE_DPLAYSVR();
	
	return ;
	
}  // EmptyConnectionList

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceive"

/*
 ** StreamReceive
 *
 *  CALLED BY: StreamReceiveThreadProc
 *
 *  PARAMETERS:
 *		sSocket - socket to receive on
 *		ppBuffer - buffer to receive into - alloc'ed / realloc'ed  as necessary
 *		pdwBuffersize - size of pBuffer
 *
 *  DESCRIPTION:
 *		pull the bytes out of sSocket until no more bytes
 *
 *  RETURNS: E_FAIL on sockerr, or DP_OK. 
 *
 */
HRESULT StreamReceive(LPCONNECTION pConnection)
{
	HRESULT hr = DP_OK;
    UINT err;
    DWORD dwBytesReceived=0;
	DWORD dwMessageSize;
	LPBYTE pReceiveBuffer=NULL;
	DWORD dwReceiveBufferSize;
	
	// is it a new message ?
	if (pConnection->dwCurMessageSize == 0)
	{
		// receive the header first
		pConnection->dwTotalMessageSize = SPMESSAGEHEADERLEN;
	}

	// continue receiving message
	pReceiveBuffer = pConnection->pBuffer + pConnection->dwCurMessageSize;
	dwReceiveBufferSize = pConnection->dwTotalMessageSize - pConnection->dwCurMessageSize;

	DPF(9,"Attempting to receive %d bytes", dwReceiveBufferSize);

   	DEBUGPRINTSOCK(9,">>> receiving data on socket - ",&pConnection->socket);

	// receive data from socket 
	// note - make exactly one call to recv after select otherwise we'll hang
	dwBytesReceived = g_recv(pConnection->socket, (LPBYTE)pReceiveBuffer, dwReceiveBufferSize, 0);

   	DEBUGPRINTSOCK(9,"<<< received data on socket - ",&pConnection->socket);

	DPF(5, "received %d bytes", dwBytesReceived);

	if (0 == dwBytesReceived)
	{
		// remote side has shutdown connection gracefully
		hr = DP_OK;
		DPF(5,"Remote side has shutdown connection gracefully");
		goto CLEANUP_EXIT;
	}
	else if (SOCKET_ERROR == dwBytesReceived)
	{
		err = g_WSAGetLastError();
		DPF(0,"STREAMRECEIVEE: receive error - err = %d",err);
		hr = E_UNEXPECTED;            
		goto CLEANUP_EXIT;
	}

	// we have received this much message so far
	pConnection->dwCurMessageSize += dwBytesReceived;

	if (pConnection->dwCurMessageSize == SPMESSAGEHEADERLEN)
	{
		// we just completed receiving message header

		if (VALID_DPLAYSVR_MESSAGE(pConnection->pDefaultBuffer))
		{
			 dwMessageSize = SP_MESSAGE_SIZE(pConnection->pDefaultBuffer); // total message size			
		}
		else 
		{
			DPF(2,"got invalid message");
			ASSERT(FALSE);
			hr = E_UNEXPECTED;
			goto CLEANUP_EXIT;
		}

		// prepare to receive the rest of the message (after token)
		if (dwMessageSize)
		{
			pConnection->dwTotalMessageSize = dwMessageSize;

			// which buffer to receive message in ?
			if (dwMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
			{
				ASSERT(pConnection->pBuffer == pConnection->pDefaultBuffer);
				// get a new buffer to fit the message
				pConnection->pBuffer = MemAlloc(dwMessageSize);
				if (!pConnection->pBuffer)
				{
					DPF(0,"Failed to allocate receive buffer for message - out of memory");
					goto CLEANUP_EXIT;
				}
				// copy header into new message buffer
				memcpy(pConnection->pBuffer, pConnection->pDefaultBuffer, SPMESSAGEHEADERLEN);
			}
		}
	}

	// did we receive a complete message ?
	if (pConnection->dwCurMessageSize == pConnection->dwTotalMessageSize)
	{
		// received a complete message - process it

		if (TOKEN == SP_MESSAGE_TOKEN(pConnection->pBuffer))
		{						
	    	DEBUGPRINTADDR(9,"dplay helper  :: received reliable enum request from ",(SOCKADDR *)&pConnection->sockAddr);
		    // take the dplay lock so no one messes w/ our list of registered serves while we're 
		    // trying to send to them...
    	    ENTER_DPLAYSVR();
	    
            HandleIncomingMessage(pConnection->pBuffer, pConnection->dwTotalMessageSize,
				(SOCKADDR_IN *)&pConnection->sockAddr);
	    
		    // give up the lock
    	    LEAVE_DPLAYSVR();
		}
			
		// cleanup up new receive buffer if any
		if (pConnection->dwTotalMessageSize > DEFAULT_RECEIVE_BUFFERSIZE)
		{
			DPF(9, "Releasing receive buffer of size %d", pConnection->dwTotalMessageSize);
			if (pConnection->pBuffer) MemFree(pConnection->pBuffer);
		}			
		// initialize message information
		pConnection->dwCurMessageSize = 0;
		pConnection->dwTotalMessageSize = 0;
		pConnection->pBuffer = pConnection->pDefaultBuffer;

		// new... only allow one enum per socket, then turf it.... AO 2/10/2000
		//goto CLEANUP_EXIT;
	}

	// all done
	return DP_OK;	
	
CLEANUP_EXIT:

	RemoveSocketFromList(pConnection->socket);
	return hr;
	 	
} // StreamReceive

#undef DPF_MODNAME
#define DPF_MODNAME	"StreamReceiveThreadProc"

// watch our list of sockets, waiting for one to have data to be received, or to be closed
DWORD WINAPI StreamReceiveThreadProc(LPVOID pvCast)
{
	HRESULT hr;
	INT_PTR rval;
	UINT i = 0;
    UINT err;
    DWORD dwBufferSize = 0;    
	UINT nSelected;
    SOCKADDR sockaddr; // socket we receive from
    INT addrlen=sizeof(sockaddr);
	SOCKET sSocket;
	BOOL bTrue = TRUE;

	// add listener socket to receive list
	// listener socket should be the first socket in the receive list
	hr = AddSocketToReceiveList(gsStreamListener);
	if (FAILED(hr))
	{
		DPF(0, "Failed to add TCP listener to receive list");
		return hr;
	}
	
    while (1)
    {
		ENTER_DPLAYSVR();

		ASSERT(gReadfds.pfdbigset);
		
    	// add all sockets in our recv list to readfds
		FD_ZERO(gReadfds.pfdbigset);
		nSelected = 0;
		for (i=0;i < gReceiveList.nConnections ; i++)
		{
        	if (INVALID_SOCKET != gReceiveList.pConnection[i].socket)
        	{
		        FD_BIG_SET(gReceiveList.pConnection[i].socket,&gReadfds);
				nSelected++;
        	}
		}

		LEAVE_DPLAYSVR();

		if (0 == nSelected)		
		{
			if (gbReceiveShutdown)
			{
				DPF(2,"stream receive thread proc detected shutdown - bailing");
				goto CLEANUP_EXIT;
			}
			// we should have at least one?
			DPF_ERR("No sockets in receive list - missing listener socket? bailing!");
			ASSERT(FALSE);
			goto CLEANUP_EXIT;
		}
		
		// now, we wait for something to happen w/ our socket set
		rval = g_select(0,(fd_set *)(gReadfds.pfdbigset),NULL,NULL,NULL);
        if (SOCKET_ERROR == rval)
        {
 	      	err = g_WSAGetLastError();
	    	if (WSAEINTR != err) 
	        {
			    // WSAEINTR is what winsock uses to break a blocking socket out of 
			    // its wait.  it means someone killed this socket.
			    // if it's not that, then it's a real error.
	            DPF(0,"\n select error = %d socket - trying again",err);
	    	}
			else
			{
			    DPF(9,"\n select error = %d socket - trying again",err);				
			}
            rval = 0;
        }

		// shut 'em down?
        if (gbReceiveShutdown)
        {
        	DPF(2,"receive thread proc detected bShutdown - bailing");
            goto CLEANUP_EXIT;
        }
        
    	DPF(5,"receive thread proc - events on %d sockets",rval);
		i = 0;
		
		ENTER_DPLAYSVR();
		
        while (rval>0)
        {
	        // walk the receive list, dealing w/ all new sockets
			if (i >= gReceiveList.nConnections)
			{
				rval = 0; // just to be safe, reset
			}
            
            if (gReceiveList.pConnection[i].socket != INVALID_SOCKET)
            {
            	// see if it's in the set
                if (g_WSAFDIsSet(gReceiveList.pConnection[i].socket,(fd_set *)gReadfds.pfdbigset))
                {
                	if (0==i)
                	// we got a new connection
                	{
					    // accept any incoming connection
					    sSocket = g_accept(gReceiveList.pConnection[i].socket,&sockaddr,&addrlen);
					    if (INVALID_SOCKET == sSocket) 
					    {
					        err = g_WSAGetLastError();
				            DPF(0,"\n stream accept error - err = %d socket = %d BAILING",err,(DWORD)sSocket);
				            DPF(0, "\n !!! stream accept thread is going away - won't get reliable enum sessions anymore !!!");
				            ASSERT(FALSE);
				            LEAVE_DPLAYSVR();
							goto CLEANUP_EXIT;
					    }
					    DEBUGPRINTADDR(5,"stream - accepted connection from",&sockaddr);

						// Turn on KEEPALIVE for the socket.

						if (SOCKET_ERROR == g_setsockopt(sSocket, SOL_SOCKET, SO_KEEPALIVE, (CHAR FAR *)&bTrue, sizeof(bTrue)))
						{
								err = g_WSAGetLastError();
								DPF(0,"Failed to turn ON keepalive - continue : err = %d\n",err);
						}

						// add the new socket to our receive list
						hr = AddSocketToReceiveList(sSocket);
						if (FAILED(hr))
						{
							ASSERT(FALSE);
						}			
                	}
                	else
                	// socket has new data
                	{
						DPF(9, "Receiving on socket %d from ReceiveList", i);

    	            	// got one! this socket has something going on...
						hr = StreamReceive(&(gReceiveList.pConnection[i]));
            	        if (FAILED(hr))
                	    {
							DPF(1,"Stream Receive failed - hr = 0x%08lx\n",hr);
                    	}
                	}
                    rval--; // one less to hunt for
                } // IS_SET
            } // != INVALID_SOCKET

            i++;
                
   		} // while rval
		
		LEAVE_DPLAYSVR();
		
	} // while 1

CLEANUP_EXIT:

	EmptyConnectionList();
	DPF(5, "Stream receive thread exiting");
	    
    return 0;
    
} // ReceiveThreadProc



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\registry.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       registry.c
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  ???
 *  12/28/99    aarono  added query for required key for Win95 rsip support
 *  04/19/01    vanceo  added nathelp DLL retrieval and copied to dplaysvr
 *
 ***************************************************************************/

#include <windows.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"


#define REGISTRY_NAMELEN	512
// space (in bytes) for a human readable (unicode) guid + some extra
#define GUID_STRING_SIZE 80

#define SZ_SP_KEY		"Software\\Microsoft\\DirectPlay\\Service Providers"
#define SZ_GUID			"Guid"
#define SZ_FLAGS		"dwFlags"

#define SZ_GATEWAY		"Gateway"
#define SZ_NATHELP		"NATHelp"

#undef DPF_MODNAME
#define DPF_MODNAME "FindApplicationInRegistry"

// convert a hex char to an int - used by str to guid conversion
// we wrote our own, since the ole one is slow, and requires ole32.dll
// we use ansi strings here, since guids won't get internationalized
int GetDigit(LPSTR lpstr)
{
	char ch = *lpstr;
    
    if (ch >= '0' && ch <= '9')
        return(ch - '0');
    if (ch >= 'a' && ch <= 'f')
        return(ch - 'a' + 10);
    if (ch >= 'A' && ch <= 'F')
        return(ch - 'A' + 10);
    return(0);
}
// walk the string, writing pairs of bytes into the byte stream (guid)
// we need to write the bytes into the byte stream from right to left
// or left to right as indicated by fRightToLeft
void ConvertField(LPBYTE lpByte,LPSTR * ppStr,int iFieldSize,BOOL fRightToLeft)
{
	int i;

	for (i=0;i<iFieldSize ;i++ )
	{
		// don't barf on the field separators
		if ('-' == **ppStr) (*ppStr)++; 
		if (fRightToLeft == TRUE)
		{
			// work from right to left within the byte stream
			*(lpByte + iFieldSize - (i+1)) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		} 
		else 
		{
			// work from  left to right within the byte stream
			*(lpByte + i) = 16*GetDigit(*ppStr) + GetDigit((*ppStr)+1);
		}
		*ppStr+=2; // get next two digit pair
	}
} // ConvertField


// convert the passed in string to a real GUID
// walk the guid, setting each byte in the guid to the two digit hex pair in the
// passed string
HRESULT GUIDFromString(LPSTR lpStr, GUID * pGuid)
{
	BYTE * lpByte; // byte index into guid
	int iFieldSize; // size of current field we're converting
	// since its a guid, we can do a "brute force" conversion
	
	// make sure we have a {xxxx-...} type guid
	if ('{' !=  *lpStr) return E_FAIL;
	lpStr++;
	
	lpByte = (BYTE *)pGuid;
	// data 1
	iFieldSize = sizeof(unsigned long);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 2
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 3
	iFieldSize = sizeof(unsigned short);
	ConvertField(lpByte,&lpStr,iFieldSize,TRUE);
	lpByte += iFieldSize;

	// data 4
	iFieldSize = 8*sizeof(unsigned char);
	ConvertField(lpByte,&lpStr,iFieldSize,FALSE);
	lpByte += iFieldSize;

	// make sure we ended in the right place
	if ('}' != *lpStr) 
	{
		DPF_ERR("invalid guid!!");
		memset(pGuid,0,sizeof(GUID));
		return E_FAIL;
	}

	return DP_OK;
}// GUIDFromString

BOOL FindSPInRegistry(LPGUID lpguid, LPSTR lpszSPName, DWORD dwNameSize, HKEY * lphkey)
{
	HKEY	hkeyDPSPs, hkeySP;
	DWORD	dwIndex = 0;
	CHAR	szGuidStr[GUID_STRING_SIZE];
	DWORD	dwGuidStrSize = GUID_STRING_SIZE;
	DWORD	dwType = REG_SZ;
	GUID	guidSP;
	LONG	lReturn;
	BOOL	bFound = FALSE;
	DWORD	dwSaveNameSize = dwNameSize;


	DPF(7, "Entering FindSPInRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x, %lu, 0x%08x",
			lpguid, lpszSPName, dwNameSize, lphkey);

 	// Open the Applications key
	lReturn = RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_SP_KEY, 0,
							KEY_READ, &hkeyDPSPs);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Unable to open DPlay service provider registry key!");
		return FALSE;
	}

	// Walk the list of sps in the registry, looking for
	// the sp with the right GUID
	while(!bFound)
	{
		// Open the next SP key
		dwSaveNameSize = dwNameSize;
		dwGuidStrSize = GUID_STRING_SIZE;
		lReturn = RegEnumKeyExA(hkeyDPSPs, dwIndex++, lpszSPName,
						&dwSaveNameSize, NULL, NULL, NULL, NULL);

		// If the enum returns no more SPs, we want to bail
		if(lReturn != ERROR_SUCCESS)
			break;
		
		// Open the SP key		
		lReturn = RegOpenKeyExA(hkeyDPSPs, lpszSPName, 0,
									KEY_READ, &hkeySP);
		if(lReturn != ERROR_SUCCESS)
		{
			DPF_ERR("Unable to open sp key!");
			continue;
		}

		// Get the GUID of the SP
		lReturn = RegQueryValueExA(hkeySP, SZ_GUID, NULL, &dwType,
									(LPBYTE)&szGuidStr, &dwGuidStrSize);
		if(lReturn != ERROR_SUCCESS)
		{
			RegCloseKey(hkeySP);
			DPF_ERR("Unable to query GUID key value!");
			continue;
		}

		// Convert the string to a real GUID & Compare it to the passed in one
		GUIDFromString(szGuidStr, &guidSP);
		if(IsEqualGUID(&guidSP, lpguid))
		{
			bFound = TRUE;
			break;
		}

		// Close the SP key
		RegCloseKey(hkeySP);
	}

	// Close the SPs key
	RegCloseKey(hkeyDPSPs);

	if(bFound)
		*lphkey = hkeySP;

	return bFound;


} // FindSPInRegistry



#undef DPF_MODNAME
#define DPF_MODNAME "GetKeyValue"
BOOL GetKeyValue(HKEY hkeyApp, LPSTR lpszKey, DWORD dwType, LPBYTE * lplpValue)
{
	DWORD	dwSize;
	LPBYTE	lpTemp = NULL;
	LONG	lReturn;


	DPF(7, "Entering GetKeyValue");
	DPF(8, "Parameters: 0x%08x, 0x%08x, 0x%08x",
			hkeyApp, lpszKey, lplpValue);

	ASSERT(lplpValue);

	// Get the size of the buffer for the Path
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType, NULL, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		DPF_ERR("Error getting size of key value!");
		return FALSE;
	}

	// If the size is 1, then it is an empty string (only contains a
	// null terminator).  Treat this the same as a NULL string or a
	// missing key and fail it.
	if(dwSize <= 1)
		return FALSE;

	ENTER_DPLAYSVR();
	
	// Alloc the buffer for the Path
	lpTemp = MemAlloc(dwSize);

	LEAVE_DPLAYSVR();
	
	if(!lpTemp)
	{
		DPF_ERR("Unable to allocate temporary string for Path!");
		return FALSE;
	}

	// Get the value itself
	lReturn = RegQueryValueExA(hkeyApp, lpszKey, NULL, &dwType,
							(LPBYTE)lpTemp, &dwSize);
	if(lReturn != ERROR_SUCCESS)
	{
		MemFree(lpTemp);
		DPF_ERR("Unable to get key value!");
		return FALSE;
	}

	*lplpValue = lpTemp;
	return TRUE;

} // GetKeyValue


#undef DPF_MODNAME
#define DPF_MODNAME "GetFlagsFromRegistry"
HRESULT GetFlagsFromRegistry(LPGUID lpguidSP, LPDWORD lpdwFlags)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetFlagsFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x", lpguidSP, lpdwFlags);

	ENTER_DPLAYSVR();
	
	// Allocate memory for the App Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPLAYSVR();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the App
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the port value.
	if(!GetKeyValue(hkeySP, SZ_FLAGS, REG_BINARY, &lpValue))
	{
		DPF_ERR("Unable to get flags value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	*lpdwFlags = *(LPDWORD)lpValue;

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetFlagsFromRegistry


#if USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetGatewayFromRegistry"
HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetGatewayFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszGateway, cbszGateway);

	ENTER_DPLAYSVR();
	
	// Allocate memory for the SP Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPLAYSVR();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the gateway value.
	if(!GetKeyValue(hkeySP, SZ_GATEWAY, REG_SZ, &lpValue))
	{
		DPF_ERR("Unable to get key value from registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszGateway){
		DPF_ERR("Not enough room for gateway address");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszGateway, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetGatewayFromRegistry


#elif USE_NATHELP // !  USE_RSIP

#undef DPF_MODNAME
#define DPF_MODNAME "GetNATHelpDLLFromRegistry"
HRESULT GetNATHelpDLLFromRegistry(LPGUID lpguidSP, LPBYTE lpszNATHelpDLL, DWORD cbszNATHelpDLL)
{
	LPSTR	lpszSPName=NULL;
	HKEY	hkeySP = NULL;
	LPBYTE	lpValue=NULL;
	DWORD	dwSize = 0;
	HRESULT hr = DP_OK;


	DPF(7, "Entering GetNATHelpDLLFromRegistry");
	DPF(8, "Parameters: 0x%08x, 0x%08x %d", lpguidSP, lpszNATHelpDLL, cbszNATHelpDLL);

	ENTER_DPLAYSVR();
	
	// Allocate memory for the SP Name
	lpszSPName = MemAlloc(REGISTRY_NAMELEN);

	LEAVE_DPLAYSVR();
	
	if(!lpszSPName)
	{
		DPF_ERR("Unable to allocate memory for sp name!");
		return E_OUTOFMEMORY;
	}
	
	// Open the registry key for the SP
	if(!FindSPInRegistry(lpguidSP, lpszSPName,REGISTRY_NAMELEN, &hkeySP))
	{
		DPF_ERR("Unable to find sp in registry!");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	// Get the NAT Help value.
	if(!GetKeyValue(hkeySP, SZ_NATHELP, REG_SZ, &lpValue))
	{
		DPF(1, "Unable to get NATHelp key value from registry.");
		hr = E_FAIL;
		goto CLEANUP_EXIT;
	}

	dwSize = strlen(lpValue)+1;
	if(dwSize > cbszNATHelpDLL){
		DPF_ERR("Not enough room for NATHelp DLL path");
		goto CLEANUP_EXIT;
	}
	memcpy(lpszNATHelpDLL, lpValue, dwSize);

	// fall through

CLEANUP_EXIT:

	if (lpszSPName) MemFree(lpszSPName);
	if (lpValue) MemFree(lpValue);
	
	// Close the Apps key
	if(hkeySP)
		RegCloseKey(hkeySP);

	return hr;

} // GetNATHelpDLLFromRegistry

#endif // USE_NATHELP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\rsip.c ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rsip.c
 *  Content:	Realm Specific IP Support
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  12/7/99		aarono	Original
 *  1/8/2000    aarono  Ported for dplaysvr
 *
 *  Notes:
 *   
 *  Could optimize the building of messages with pre-initialized
 *  structures for each command, since most of the command is the same
 *  on every request anyway.
 *
 ***************************************************************************/


#define INCL_WINSOCK_API_TYPEDEFS 1 // includes winsock 2 fn proto's, for getprocaddress
#define FD_SETSIZE 1
#include <winsock2.h>
#include "dplaysvr.h"
#include "newdpf.h"
#include "memalloc.h"
#include "dphelp.h"

#if USE_RSIP
#include "rsip.h"
#include "mmsystem.h"


extern HRESULT GetGatewayFromRegistry(LPGUID lpguidSP, LPBYTE lpszGateway, DWORD cbszGateway);


typedef unsigned __int64 ULONGLONG;
#include <iphlpapi.h>
typedef DWORD (WINAPI *LpFnGetAdaptersInfo)(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
typedef DWORD (WINAPI *LpFnGetBestInterface)(UINT ipaddr, PULONG pIndex);
typedef DWORD (WINAPI *LpFnIpRenewAddress)(PIP_ADAPTER_INDEX_MAP  AdapterInfo);
// AN_IP_ADDRESS's value is unimportant
#define AN_IP_ADDRESS "204.107.191.254"
#define LOOPBACK_ADDR "127.0.0.1"
#define RESP_BUF_SIZE 100

struct _MYGLOBALDATA {
	SOCKET  	sRsip;
	SOCKADDR_IN	saddrGateway;
	CRITICAL_SECTION csRsip;
	DWORD       msgid;
	DWORD		clientid;
	PRSIP_LEASE_RECORD pRsipLeaseRecords;	// list of leases.
	PADDR_ENTRY  pAddrEntry;			// cache of mappings.
	DWORD 		 tuRetry;		//microseconds starting retry time.
} MYGLOBALDATA;

struct _MYGLOBALDATA *pgd=&MYGLOBALDATA;

// Local Functions
HRESULT rsipFindGateway(UINT myip,char *gwipaddr);
HRESULT rsipRegister();
HRESULT rsipDeregister();
HRESULT rsipParse(CHAR *pBuf, DWORD cbBuf, PRSIP_RESPONSE_INFO pRespInfo);
VOID rsipRemoveLease(DWORD bindid);
VOID rsipAddLease(DWORD bindid, BOOL ftcp_udp, DWORD addrV4, WORD lport, WORD port, DWORD tLease);
PRSIP_LEASE_RECORD rsipFindLease(BOOL ftcp_udp, WORD port);

/*=============================================================================

	rsipInit - Initialize RSIP support.  If this function succeeds then there
			   is an RSIP gateway on the network and the SP should call the
			   RSIP services when creating and destroying sockets that need
			   to be accessed from machines outside the local realm.
	
    Description:

		Looks for the Gateway, then check to see if it is RSIP enabled.

    Parameters:

    	pgd  - Service Provider's global data blob for this instance
    	lpguidSP - Service Provider guid so we can lookup gateway 
    				in the registry on Win95 original.

    Return Values:

		TRUE  - found and RSIP gateway and initialized.
		FALSE - no RSIP gateway found.

-----------------------------------------------------------------------------*/
BOOL rsipInit()
{
	HRESULT hr;
	char gwipaddr[32];
	BOOL bReturn = TRUE;
	SOCKADDR_IN saddr;

	memset(pgd,0,sizeof(MYGLOBALDATA));

	try {
	
		InitializeCriticalSection(&pgd->csRsip);
		
	} except ( EXCEPTION_EXECUTE_HANDLER) {

		// Catch STATUS_NOMEMORY
		bReturn=FALSE;
		goto exit;
	}

	// find the default gateway
	hr = rsipFindGateway(g_inet_addr(AN_IP_ADDRESS),gwipaddr);

	if(hr!=DP_OK){

		hr = GetGatewayFromRegistry((LPGUID) (&DPSPGUID_TCPIP), gwipaddr, sizeof(gwipaddr));

		if(hr == DP_OK){
			DPF(0,"Found suggested RSIP gateway in registry %s, running on Win95?\n",gwipaddr);
		} else {
			// this is the default address of Millennium NAT gateway.
			memcpy(gwipaddr, "192.168.0.1", sizeof("192.168.0.1"));
			DPF(0,"Couldn't find regkey for gateway so trying %s, running on Win95?\n",gwipaddr);
		}

	}

	// create a SOCKADDR to address the RSIP service on the gateway
	memset(&pgd->saddrGateway, 0, sizeof(SOCKADDR_IN));
	pgd->saddrGateway.sin_family      = AF_INET;
	pgd->saddrGateway.sin_addr.s_addr = g_inet_addr(gwipaddr);
	pgd->saddrGateway.sin_port 	      = g_htons(RSIP_HOST_PORT);

	// create a datagram socket for talking to the RSIP facility on the gateway
	if((pgd->sRsip = g_socket(AF_INET,SOCK_DGRAM,0))==INVALID_SOCKET){
		DPF(0,"ERROR: rsipInit() socket call for RSIP listener failed\n");
		bReturn = FALSE;
		goto exit;
	}

	// create an address to specify the port to bind our datagram socket to.
	memset(&saddr,0,sizeof(SOCKADDR_IN));
	saddr.sin_family	  = AF_INET;
	saddr.sin_addr.s_addr = g_htonl(INADDR_ANY);
	saddr.sin_port        = g_htons(0);

	// bind the datagram socket to any local address and port.
	if(g_bind(pgd->sRsip, (PSOCKADDR)&saddr, sizeof(saddr)) != 0){
		DPF(0,"ERROR: rsipInit() bind for RSIP listener failed\n");
		bReturn=FALSE;
		goto exit;
	}

	pgd->tuRetry=12500; // start retry timer at 12.5 ms

	// find out if there is an rsip service and register with it.
	if((hr=rsipRegister())!=DP_OK){
		bReturn=FALSE;
	}

exit:

	if(bReturn==FALSE){
		 if(pgd->sRsip != INVALID_SOCKET){
		     g_closesocket(pgd->sRsip);
		     pgd->sRsip=INVALID_SOCKET;
		 }    
	}

	return bReturn;
}

/*=============================================================================

	rsipFini - Shut down RSIP support
	
	   All threads that might access RSIP MUST be stopped before this
	   is called.
	
    Description:

		Deregisters with the Rsip Agent on the gateway, and cleans up
		the list of lease records.

    Parameters:

    	pgd  - Service Provider's global data blob for this instance

    Return Values:

		None.

-----------------------------------------------------------------------------*/
VOID rsipFini()
{
	PRSIP_LEASE_RECORD pLeaseWalker, pNextLease;
	PADDR_ENTRY pAddrWalker, pNextAddr;
	
	if(pgd->sRsip!=INVALID_SOCKET){
		rsipDeregister();	
		g_closesocket(pgd->sRsip);
		pgd->sRsip=INVALID_SOCKET;
	}	
	DeleteCriticalSection(&pgd->csRsip);

	// free the leases
	pLeaseWalker=pgd->pRsipLeaseRecords;
	while(pLeaseWalker){
		pNextLease = pLeaseWalker->pNext;
		MemFree(pLeaseWalker);
		pLeaseWalker=pNextLease;
	}
	pgd->pRsipLeaseRecords=NULL;

	// free the cached address mappings
	pAddrWalker=pgd->pAddrEntry;
	while(pAddrWalker){
		pNextAddr=pAddrWalker->pNext;
		MemFree(pAddrWalker);
		pAddrWalker=pNextAddr;
	}
	pgd->pAddrEntry=NULL;
	
}


/*=============================================================================

	rsipFindGateway - find the address of the internet gateway (possibly RSIP
				  host) for this machine.

	
    Description:

		Uses the ip helper api to find the default IP gateway.

    Parameters:

		uint32 myip      - ip adapter to find default gateway for
		char   *gwipaddr - gateway address if found

    Return Values:

		DP_OK - found gateway
		DPERR_GENERIC - failed.

	Note: code stolen from Rick Lamb (rlamb)
	
-----------------------------------------------------------------------------*/

HRESULT rsipFindGateway(UINT myip,char *gwipaddr)
{
  PIP_ADAPTER_INFO pAdapterInfo = NULL,p0AdapterInfo = NULL;
  DWORD            error = 0, len = 0;
  UINT             i;
  HANDLE           hIpHlpApi;
  UINT 		   	   bindex;
  
  IP_ADAPTER_INDEX_MAP ipaim;
  LpFnGetAdaptersInfo  lpFnGetAdaptersInfo;
  LpFnGetBestInterface lpFnGetBestInterface;
  LpFnIpRenewAddress   lpFnIpRenewAddress;

 /*
   * See if there is an RSIP server running.
   * If so, we must be running on the server itself
   * so use the loopback interface.
   */
  if(gwipaddr) {
    SOCKET s;
    SOCKADDR_IN addr;

    if((s=g_socket(AF_INET,SOCK_DGRAM,0)) != INVALID_SOCKET) {
      	memset(&addr,0,sizeof(SOCKADDR_IN));
      	addr.sin_family = AF_INET;
      	addr.sin_addr.s_addr = g_inet_addr(LOOPBACK_ADDR);
      	addr.sin_port = g_htons(RSIP_HOST_PORT);
      	if(g_bind(s,(struct sockaddr *)&addr,sizeof(addr)) != 0) {
			/*
		 	* Something is there already
			*/
			memcpy(gwipaddr,LOOPBACK_ADDR,sizeof(LOOPBACK_ADDR));
			DPF(0,"USING LOOPBACK: default gateway %s\n",gwipaddr);
			g_closesocket(s);
			goto done;
      	}
      	g_closesocket(s);
    }
    
  }

  hIpHlpApi = LoadLibrary("IPHLPAPI.DLL");
  if(hIpHlpApi == NULL) {
    error = DPERR_GENERIC;
    DPF_ERR("[NET] failed to load IPHLPAIP.DLL\n");
    goto done;
  }
    
  lpFnGetAdaptersInfo = (LpFnGetAdaptersInfo) GetProcAddress(hIpHlpApi, "GetAdaptersInfo");
  if(lpFnGetAdaptersInfo == NULL) {
    DPF_ERR("[NET] failed to find GetAdaptersInfo\n");
    error = DPERR_GENERIC;
    goto done;
  }

  error = (*lpFnGetAdaptersInfo) (pAdapterInfo, &len);
  if(error != ERROR_BUFFER_OVERFLOW) {
    DPF(0,"[NET] GetAdaptersInfo failed error 0x%lx\n", error);  
    error=DPERR_GENERIC;
    goto done;
  }

  p0AdapterInfo = pAdapterInfo = (PIP_ADAPTER_INFO) MemAlloc(len);
  if(pAdapterInfo == NULL) {
    DPF_ERR("[NET] memory allocation failed\n");  
    error=DPERR_GENERIC;
    goto done;
  }

  error = (*lpFnGetAdaptersInfo) (pAdapterInfo, &len);
  if(error != 0) {
    DPF(0, "[NET] GetAdaptersInfo failed error 0x%lx\n", error);  
    error=DPERR_GENERIC;
    goto done;
  }

  lpFnIpRenewAddress = (LpFnIpRenewAddress) GetProcAddress(hIpHlpApi,"IpRenewAddress");
  if(lpFnIpRenewAddress == NULL) {
    DPF_ERR(" failed to find IpRenewAddress\n");
    error=DPERR_GENERIC;
    goto done;
  }


  lpFnGetBestInterface = (LpFnGetBestInterface) GetProcAddress(hIpHlpApi, "GetBestInterface");
  if(lpFnGetBestInterface == NULL) {
    DPF_ERR(" failed to find GetBestInterface\n");
    error=DPERR_GENERIC;
    goto done;
  }

  error = (*lpFnGetBestInterface) (myip, &bindex);
  if(error != 0) {
    DPF(0,"[NET] GetBestInterface failed error 0x%lx\n", error);  
    error=DPERR_GENERIC;
    goto done;
  }
  /*printf("Renew Interface Index = %d\n",bindex);/**/

  for(i = 0; pAdapterInfo != NULL; i++, pAdapterInfo = pAdapterInfo->Next) {
    DPF(9,"[NET] Adapter Info\n");  
    DPF(9,"[NET] \t name %s\n",pAdapterInfo->AdapterName);  
    DPF(9,"[NET] \t description %s\n",pAdapterInfo->Description);  
    DPF(9,"[NET] \t index %d\n",pAdapterInfo->Index);  
    DPF(9,"[NET] \t combo index %d\n",pAdapterInfo->ComboIndex);  
    if(pAdapterInfo->Index == bindex) break;
  }

  if(pAdapterInfo == NULL) {
    DPF(9,"No match\n");
    error=DPERR_GENERIC;
    goto done;
  }

  {
    PIP_ADDR_STRING ips;
    ips = &pAdapterInfo->GatewayList;
    if(gwipaddr) {
      strcpy(gwipaddr,ips->IpAddress.String);
      DPF(0,"default gateway %s\n",gwipaddr);
      goto done;
    }
  }

done:
  if(p0AdapterInfo) MemFree(p0AdapterInfo);
  if(hIpHlpApi) FreeLibrary(hIpHlpApi);
  DPF(9,"[NET] < FindGateway\n");

  return error;
}


/*=============================================================================

	rsipExchangeAndParse - send a request to the rsip server and 
						   wait for and parse the reply

	
    Description:

	Since there is almost no scenario where we don't immediately need to know
	the response to an rsipExchange, there is no point in doing this 
	asynchronously.  The assumption is that an RSIP server is sufficiently
	local that long retries are not necessary.  We use the approach suggested
	in the IETF draft protocol specification, that is 12.5ms retry timer
	with 7fold exponential backoff.  This can lead to up to a total 1.5 
	second wait in the worst case.  (Note this section may no longer be 
	available since the rsip working group decided to drop UDP support)

    Parameters:

		pgd		  - global data
		pRequest  - a fully formatted RSIP request buffer
		cbReq     - size of request buffer
		pRespInfo - structure that returns response parameters
		messageid - the message id of this request
		bConnect  - whether this is the register request, we use a different
					timer strategy on initial connect because we really
					don't want to miss it if there is a gateway.

    Return Values:

		DP_OK - exchange succeeded, reply is in the reply buffer.
		otw, failed, RespInfo is bubkas.

-----------------------------------------------------------------------------*/

#define MAX_RSIP_RETRY	6

struct timeval tv0={0,0};

HRESULT rsipExchangeAndParse(
	PCHAR pRequest, 
	UINT cbReq, 
	PRSIP_RESPONSE_INFO pRespInfo,
	DWORD messageid,
	BOOL bConnect)
{
	CHAR  RespBuffer[RESP_BUF_SIZE];
	DWORD dwRespLen=RESP_BUF_SIZE;
	
	struct timeval tv;
	FD_SET readfds;
	INT    nRetryCount=0;
	int    rc;
	int    cbReceived;
	HRESULT hr=DP_OK;

	DPF(9,"==>RsipExchangeAndParse msgid %d\n",messageid);

	memset(RespBuffer, 0, RESP_BUF_SIZE);
	memset(pRespInfo, 0, sizeof(RSIP_RESPONSE_INFO));

	if(!bConnect){
		tv.tv_usec = pgd->tuRetry;
		tv.tv_sec  = 0;
		nRetryCount = 0;
	} else {
		// on a connect request we try twice with a 1 second total timeout
		tv.tv_usec = 500000;	// 0.5 seconds
		tv.tv_sec  = 0;
		nRetryCount = MAX_RSIP_RETRY-2;
	}


	FD_ZERO(&readfds);
	FD_SET(pgd->sRsip, &readfds);
	
	rc=0;

	// First clear out any extraneous responses.
	while(g_select(0,&readfds,NULL,NULL,&tv0)){
		cbReceived=g_recvfrom(pgd->sRsip, RespBuffer, dwRespLen, 0, NULL, NULL);
		if(cbReceived && cbReceived != SOCKET_ERROR){
			DPF(7,"Found extra response from previous RSIP request\n");
			if(pgd->tuRetry < RSIP_tuRETRY_MAX){
				// don't re-try so quickly
				pgd->tuRetry *= 2;
				DPF(7,"rsip Set tuRetry to %d usec\n",pgd->tuRetry);
			}	
		} else {
			#ifdef DEBUG
			if(cbReceived == SOCKET_ERROR){
				rc=g_WSAGetLastError();
				DPF(0,"Got sockets error %d trying to receive (clear incoming queue) on RSIP socket\n",rc);
				hr=DPERR_GENERIC;
			}
			#endif
			break;
		}
	}


	// Now do the exchange, get a response to the request, does retries too.
	do{
	
		if(++nRetryCount > MAX_RSIP_RETRY) {
			break;
		}
		
		// First send off the request

		rc=g_sendto(pgd->sRsip, pRequest, cbReq, 0, (SOCKADDR *)&pgd->saddrGateway,sizeof(SOCKADDR) );
		
		if(rc == SOCKET_ERROR){
			rc=g_WSAGetLastError();
			DPF(0,"Got sockets error %d on sending to RSIP gateway\n",rc);
			hr=DPERR_GENERIC;
			goto exit;
		}
		if(rc != (int)cbReq){
			DPF(0,"Didn't send entire datagram?  shouldn't happen\n");
			hr=DPERR_GENERIC;
			goto exit;
		}

		// Now see if we get a response.
select_again:		
		FD_ZERO(&readfds);
		FD_SET(pgd->sRsip, &readfds);
		
		rc=g_select(0,&readfds,NULL,NULL,&tv);
		
		if(rc==SOCKET_ERROR){
			rc=g_WSAGetLastError();
			DPF(0,"Got sockets error %d trying to select on RSIP socket\n",rc);
			hr=DPERR_GENERIC;
		}

		if(g_WSAFDIsSet(pgd->sRsip, &readfds)){
			break;
		}

		if(!bConnect){  
			// don't use exponential backoff on initial connect
			tv.tv_usec *= 2;	// exponential backoff.
		}	

	} while (rc==0); // keep retrying...


	if(rc == SOCKET_ERROR){
		DPF(0,"GotSocketError on select, extended error %d\n",g_WSAGetLastError());
		hr=DPERR_GENERIC;
		goto exit;
	}

	if(rc){
		// We Got Mail, err data....
		dwRespLen=RESP_BUF_SIZE;
		cbReceived=g_recvfrom(pgd->sRsip, RespBuffer, dwRespLen, 0, NULL, NULL);

		// NOTE:Could get and check addrfrom to avoid spoofing, not that paranoid
		
		if(!cbReceived || cbReceived == SOCKET_ERROR){
			rc=g_WSAGetLastError();
			DPF(0,"Got sockets error %d trying to receive on RSIP socket\n",rc);
			hr=DPERR_GENERIC;
		} else {
			rsipParse(RespBuffer,cbReceived,pRespInfo);
			if(pRespInfo->messageid != messageid){
				// Got a dup from a previous retry, go try again.
				DPF(0,"Got messageid %d, expecting messageid %d\n",pRespInfo->messageid, messageid);
				goto select_again;
			}
		}
	}

	DPF(9,"<==RsipExchangeAndParse hr=%x, Resp msgid %d\n",hr,pRespInfo->messageid);

exit:
	return hr;
}

/*=============================================================================

	rsipParse - parses an RSIP request and puts fields into a struct.
	
    Description:

		This parser parses and RSIP request or response and extracts
		out the codes into a standard structure.  This is not completely
		general, as we know that we will only operate with v4 addresses
		and our commands will never deal with more than 1 address at a
		time.  If you need to handle multiple address requests
		and responses, then you will need to change this function.

	Limitations:

		This function only deals with single address/port responses.
		Rsip allows for multiple ports to be allocated in a single
		request, but we do not take advantage of this feature.

    Parameters:

		pBuf  		- buffer containing an RSIP request or response
		cbBuf 		- size of buffer in bytes
		pRespInfo   - a structure that is filled with the parameters
					  from the RSIP buffer.

    Return Values:

		DP_OK - connected to the RSIP server.

-----------------------------------------------------------------------------*/

HRESULT rsipParse(
	CHAR *pBuf, 
	DWORD cbBuf, 
	PRSIP_RESPONSE_INFO pRespInfo
	)
{
	// character pointer version of parameter pointer.

	BOOL bGotlAddress=FALSE;
	BOOL bGotlPort   =FALSE;

	DWORD code;
	DWORD codelen;

	PRSIP_MSG_HDR pHeader;
	PRSIP_PARAM   pParam,pNextParam;
	CHAR          *pc;
	
	CHAR *pBufEnd = pBuf+cbBuf;

	if(cbBuf < 2){
		return DPERR_GENERIC;
	}	

	pHeader=(PRSIP_MSG_HDR)pBuf;

	pRespInfo->version = pHeader->version;
	pRespInfo->msgtype = pHeader->msgtype;

	DPF(0,"rsipParse: version %d msgtype %d\n",pRespInfo->version, pRespInfo->msgtype);

	pParam = (PRSIP_PARAM)(pHeader+1);

	while((CHAR*)(pParam+1) < pBufEnd)
	{
		pc=(CHAR *)(pParam+1);
		pNextParam = (PRSIP_PARAM)(pc + pParam->len);
		
		if((CHAR *)pNextParam > pBufEnd){
			break;
		}	

		switch(pParam->code){
		
			case RSIP_ADDRESS_CODE:

				// Addresses are type[1]|addr[?]
			
				switch(*pc){
					case 1:
						if(!bGotlAddress){
							DPF(0,"rsipParse: lAddress %s\n",g_inet_ntoa(*((PIN_ADDR)(pc+1))));
							memcpy((char *)&pRespInfo->lAddressV4, pc+1, 4);
							bGotlAddress=TRUE;
						} else {	
							bGotlPort=TRUE; // just in case there wasn't a local port
							DPF(0,"rsipParse: rAddress %s,",g_inet_ntoa(*((PIN_ADDR)(pc+1))));
							memcpy((char *)&pRespInfo->rAddressV4, pc+1, 4);
						}	
						break;
					case 0:
					case 2:
					case 3:
					case 4:
					case 5:
						DPF(0,"Unexpected RSIP address code type %d\n",*pc);
					break;
				}
				break;
				
			case RSIP_PORTS_CODE:
			
				// Ports are Number[1]|Port[2]....Port[2]
				// I think ports are backwards.
				if(!bGotlPort){
					DPF(0,"rsipParse lPort: %d\n", *((WORD *)(pc+1)));
					memcpy((char *)&pRespInfo->lPort, pc+1,2);
				} else {
					DPF(0,"rsipParse rPort: %d\n", *((WORD *)(pc+1)));
					memcpy((char *)&pRespInfo->rPort, pc+1,2);
					bGotlPort=TRUE;					
				}
				break;
				
  			case RSIP_LEASE_CODE:
				if(pParam->len == 4){
					memcpy((char *)&pRespInfo->leasetime,pc,4);
					DPF(0,"rsipParse Lease: %d\n",pRespInfo->leasetime);
				}	
  				break;
  				
  			case RSIP_CLIENTID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->clientid,pc,4);
					DPF(0,"rsipParse clientid: %d\n",pRespInfo->clientid);
  				}
  				break;
  				
  			case RSIP_BINDID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->bindid,pc,4);
					DPF(0,"rsipParse bindid: %x\n",pRespInfo->bindid);
  				}
  				break;
  				
  			case RSIP_MESSAGEID_CODE:
  				if(pParam->len==4){
  					memcpy((char *)&pRespInfo->messageid,pc,4);
					DPF(0,"rsipParse messageid: %d\n",pRespInfo->messageid);
  				}
  				break;
  				
  			case RSIP_TUNNELTYPE_CODE:
  				DPF(0,"rsipParse Got Tunnel Type %d, ignoring\n",*pc);
  				break;
  				
  			case RSIP_RSIPMETHOD_CODE:
  				DPF(0,"rsipParse Got RSIP Method %d, ignoring\n",*pc);
  				break;
  				
  			case RSIP_ERROR_CODE:
  				if(pParam->len==2){
  					memcpy((char *)&pRespInfo->error,pc,2);
  				}
  				DPF(0,"rsipParse Got RSIP error %d\n",pRespInfo->error);
  				break;
  				
  			case RSIP_FLOWPOLICY_CODE:
  				DPF(0,"rsipParse Got RSIP Flow Policy local %d remote %d, ignoring\n",*pc,*(pc+1));
  				break;
  				
  			case RSIP_VENDOR_CODE:
  				break;

  			default:
  				DPF(0,"Got unknown parameter code %d, ignoring\n",pParam->code);
  				break;
		}

		pParam=pNextParam;

	}

	return DP_OK;
}

/*=============================================================================

	rsipRegister - register with the RSIP server on the gateway (if present)
	
    Description:

		Trys to contact the RSIP service on the gateway. 
		
		Doesn't require lock since this is establishing the link during
		startup.  So no-one is racing with us.

    Parameters:

    	LPGLOBALDATA lpgd = global data for the service provider instance.

    Return Values:

		DP_OK 		  - connected to the RSIP server.
		DPERR_GENERIC - can't find the RSIP service on the gateway.

-----------------------------------------------------------------------------*/
HRESULT rsipRegister()
{
	HRESULT hr;

	MSG_RSIP_REGISTER  RegisterReq;
	RSIP_RESPONSE_INFO RespInfo;

	DPF(9,"==>RSIP Register\n");

	// Initialize the message sequencing.  Each message response pair
	// is numbered sequentially to allow differentiation over UDP link.

	pgd->msgid=0;

	// Build the request

	RegisterReq.version    	= RSIP_VERSION;
	RegisterReq.command    	= RSIP_REGISTER_REQUEST;
	RegisterReq.msgid.code 	= RSIP_MESSAGEID_CODE;
	RegisterReq.msgid.len  	= sizeof(DWORD);
	RegisterReq.msgid.msgid = pgd->msgid++;

	hr=rsipExchangeAndParse((PCHAR)&RegisterReq, 
							sizeof(RegisterReq), 
							&RespInfo, 
							RegisterReq.msgid.msgid,
							TRUE);

	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_REGISTER_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	pgd->clientid=RespInfo.clientid;

	DPF(9,"<==RSIP Register, ClientId %d\n",pgd->clientid);

exit:
	return hr;

error_exit:
	DPF(9,"<==RSIP Register FAILED\n");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipDeregister - close connection to RSIP gateway.
	
    Description:

    	Shuts down the registration of this application with the RSIP
    	gateway.  All port assignments are implicitly freed as a result
    	of this operation.

		- must be called with lock held.

    Parameters:

    	LPGLOBALDATA pgd = global data for the service provider instance.

    Return Values:

		DP_OK - successfully deregistered with the RSIP service.

-----------------------------------------------------------------------------*/
HRESULT rsipDeregister()
{
	HRESULT hr;

	MSG_RSIP_DEREGISTER  DeregisterReq;
	RSIP_RESPONSE_INFO RespInfo;

	DPF(9,"==>RSIP Deregister\n");

	// Build the request

	DeregisterReq.version    	    = RSIP_VERSION;
	DeregisterReq.command    	    = RSIP_DEREGISTER_REQUEST;
	
	DeregisterReq.clientid.code     = RSIP_CLIENTID_CODE;
	DeregisterReq.clientid.len      = sizeof(DWORD);
	DeregisterReq.clientid.clientid = pgd->clientid;
	
	DeregisterReq.msgid.code 	    = RSIP_MESSAGEID_CODE;
	DeregisterReq.msgid.len  	    = sizeof(DWORD);
	DeregisterReq.msgid.msgid       = pgd->msgid++;

	hr=rsipExchangeAndParse( 
					(PCHAR)&DeregisterReq, 
					sizeof(DeregisterReq), 
					&RespInfo, 
					DeregisterReq.msgid.msgid,
					FALSE);

	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_DEREGISTER_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	DPF(9,"<==RSIP Deregister Succeeded\n");

exit:
	return hr;

error_exit:
	DPF(9,"<==RSIP Deregister Failed\n");
	return DPERR_GENERIC;

}


/*=============================================================================

	rsipExtendPort - extend a port mapping
	
    Description:

		Extends the lease on a port mapping.  

    Parameters:

    	LPGLOBALDATA pgd    - global data for the service provider instance.
    	DWORD        Bindid - binding identifier specified by the rsip service.
    	DWORD        ptExtend - amount of extra lease time granted.

    Return Values:

		DP_OK - lease extended.
		DPERR_GENERIC - couldn't extend the lease.

-----------------------------------------------------------------------------*/
HRESULT rsipExtendPort(DWORD Bindid, DWORD *ptExtend)
{
	HRESULT hr;

	MSG_RSIP_EXTEND_PORT  ExtendReq;
	RSIP_RESPONSE_INFO RespInfo;

	EnterCriticalSection(&pgd->csRsip);

	DPF(9,"==>Extend Port, Bindid %d\n",Bindid);

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipExtendPort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	// Build the request

	ExtendReq.version    		= RSIP_VERSION;
	ExtendReq.command    		= RSIP_EXTEND_REQUEST;

	ExtendReq.clientid.code 	= RSIP_CLIENTID_CODE;
	ExtendReq.clientid.len 		= sizeof(DWORD);
	ExtendReq.clientid.clientid = pgd->clientid;

	ExtendReq.bindid.code 		= RSIP_BINDID_CODE;
	ExtendReq.bindid.len 		= sizeof(DWORD);
	ExtendReq.bindid.bindid 	= Bindid;

	// Lease code, ask for an hour, but don't count on it.
	
	ExtendReq.lease.code		= RSIP_LEASE_CODE;
	ExtendReq.lease.len			= sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ExtendReq.lease.leasetime   = 3600;

	ExtendReq.msgid.code 		= RSIP_MESSAGEID_CODE;
	ExtendReq.msgid.len  		= sizeof(DWORD);
	ExtendReq.msgid.msgid   	= pgd->msgid++;

	hr=rsipExchangeAndParse(
					(PCHAR)&ExtendReq, 
					sizeof(ExtendReq), 
					&RespInfo,
					ExtendReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);
	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_EXTEND_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	*ptExtend=RespInfo.leasetime;

	DPF(9,"<==Extend Port, Bindid %d Succeeded, extra lease time %d\n",Bindid,*ptExtend);

exit:
	return hr;

error_exit:
	DPF(9,"<==Extend Port, Failed");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipFreePort - release a port binding
	
    Description:

		Removes the lease record for our port binding (so we don't renew it
		after we actually release the binding from the gateway).  Then informs
		the gateway that we are done with the binding.

    Parameters:

    	LPGLOBALDATA pgd    - global data for the service provider instance.
    	DWORD        Bindid - gateway supplied identifier for the binding

    Return Values:

		DP_OK - port binding released.
		DPERR_GENERIC - failed.

-----------------------------------------------------------------------------*/
HRESULT rsipFreePort(DWORD Bindid)
{
	HRESULT hr;

	MSG_RSIP_FREE_PORT  FreeReq;
	RSIP_RESPONSE_INFO RespInfo;

	EnterCriticalSection(&pgd->csRsip);

	DPF(9,"==>Release Port, Bindid %d\n",Bindid);

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipFreePort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	rsipRemoveLease(Bindid);
	
	FreeReq.version    			= RSIP_VERSION;
	FreeReq.command    			= RSIP_FREE_REQUEST;

	FreeReq.clientid.code 		= RSIP_CLIENTID_CODE;
	FreeReq.clientid.len 		= sizeof(DWORD);
	FreeReq.clientid.clientid 	= pgd->clientid;

	FreeReq.bindid.code 		= RSIP_BINDID_CODE;
	FreeReq.bindid.len 			= sizeof(DWORD);
	FreeReq.bindid.bindid 		= Bindid;

	FreeReq.msgid.code 			= RSIP_MESSAGEID_CODE;
	FreeReq.msgid.len  			= sizeof(DWORD);
	FreeReq.msgid.msgid   		= pgd->msgid++;

	hr=rsipExchangeAndParse(
					(PCHAR)&FreeReq, 
					sizeof(FreeReq), 
					&RespInfo, 
					FreeReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);

	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_FREE_RESPONSE){
		DPF(0,"Failing registration, response was message type %d\n",RespInfo.msgtype);
		goto error_exit;
	}

exit:
	DPF(9,"<==Release Port, Succeeded");
	return hr;

error_exit:
	DPF(9,"<==Release Port, Failed");
	return DPERR_GENERIC;

}

/*=============================================================================

	rsipListenPort - assign a port mapping with the rsip server with a fixed
					 port.
	
    Description:

		Only used for the host server port (the one that is used for enums).
		Other than the fixed port this works the same as an rsipAssignPort.

		Since the port is fixed, the local and public port address are
		obviously the same.

    Parameters:

    	LPGLOBALDATA pgd      - global data for the service provider instance.
    	WORD	     port     - local port to get a remote port for (big endian)
    	BOOL		 ftcp_udp - whether we are assigning a UDP or TCP port
    	SOCKADDR     psaddr   - place to return assigned global realm address
    	PDWORD       pBindid  - identifier for this binding, used to extend 
    							lease and/or release the binding (OPTIONAL).
    Return Values:

		DP_OK - assigned succeeded, psaddr contains public realm address,
				*pBindid is the binding identifier.
				
		DPERR_GENERIC - assignment of a public port could not be made.


-----------------------------------------------------------------------------*/
HRESULT rsipListenPort(BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid)
{
	#define psaddr_in ((SOCKADDR_IN *)psaddr)
	
	HRESULT hr;

	MSG_RSIP_LISTEN_PORT ListenReq;
	RSIP_RESPONSE_INFO RespInfo;

	EnterCriticalSection(&pgd->csRsip);

	DPF(9,"RSIP Listen Port %d\n",g_htons(port));

	if(pgd->sRsip == INVALID_SOCKET){
		DPF(0,"rsipListenPort: pgd->sRsip is invalid, bailing...\n");
		LeaveCriticalSection(&pgd->csRsip);
		return DPERR_GENERIC;
	}

	// Build the request
	
	ListenReq.version    		  = RSIP_VERSION;
	ListenReq.command    		  = RSIP_LISTEN_REQUEST;

	ListenReq.clientid.code 	  = RSIP_CLIENTID_CODE;
	ListenReq.clientid.len 		  = sizeof(DWORD);
	ListenReq.clientid.clientid   = pgd->clientid;

	// Local Address (will be returned by RSIP server, us don't care value)

	ListenReq.laddress.code		  = RSIP_ADDRESS_CODE;
	ListenReq.laddress.len		  = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.laddress.version	  = 1; // IPv4
	ListenReq.laddress.addr		  = 0; // Don't care

	// Local Port, this is a port we have opened that we are assigning a
	// global alias for.

	ListenReq.lport.code		 = RSIP_PORTS_CODE;
	ListenReq.lport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.lport.nports       = 1;
	ListenReq.lport.port		 = g_htons(port);//->little endian for wire

	// Remote Address (not used with our flow control policy, use don't care value)

	ListenReq.raddress.code		 = RSIP_ADDRESS_CODE;
	ListenReq.raddress.len		 = sizeof(RSIP_ADDRESS)-sizeof(RSIP_PARAM);
	ListenReq.raddress.version   = 1; // IPv4
	ListenReq.raddress.addr      = 0; // Don't care

	ListenReq.rport.code		 = RSIP_PORTS_CODE;
	ListenReq.rport.len			 = sizeof(RSIP_PORT)-sizeof(RSIP_PARAM);
	ListenReq.rport.nports       = 1;
	ListenReq.rport.port		 = 0; // Don't care

	// Following parameters are optional according to RSIP spec...
	
	// Lease code, ask for an hour, but don't count on it.
	
	ListenReq.lease.code		 = RSIP_LEASE_CODE;
	ListenReq.lease.len			 = sizeof(RSIP_LEASE)-sizeof(RSIP_PARAM);
	ListenReq.lease.leasetime    = 3600;
	
	// Tunnell Type is IP-IP

	ListenReq.tunnel.code		 = RSIP_TUNNELTYPE_CODE;
	ListenReq.tunnel.len		 = sizeof(RSIP_TUNNEL)-sizeof(RSIP_PARAM);
	ListenReq.tunnel.tunneltype  = TUNNEL_IP_IP;

	// Message ID is optional, but we use it since we use UDP xport it is required.
	
	ListenReq.msgid.code 		 = RSIP_MESSAGEID_CODE;
	ListenReq.msgid.len  		 = sizeof(DWORD);
	ListenReq.msgid.msgid   	 = pgd->msgid++;

	// Vendor specific - need to specify port type and no-tunneling

	ListenReq.porttype.code      = RSIP_VENDOR_CODE;
	ListenReq.porttype.len       = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.porttype.vendorid  = RSIP_MS_VENDOR_ID;
	ListenReq.porttype.option    = (ftcp_udp)?(RSIP_TCP_PORT):(RSIP_UDP_PORT);

	ListenReq.tunneloptions.code     = RSIP_VENDOR_CODE;
	ListenReq.tunneloptions.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.tunneloptions.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.tunneloptions.option   = RSIP_NO_TUNNEL;

	ListenReq.listentype.code     = RSIP_VENDOR_CODE;
	ListenReq.listentype.len      = sizeof(RSIP_MSVENDOR_CODE)-sizeof(RSIP_PARAM);
	ListenReq.listentype.vendorid = RSIP_MS_VENDOR_ID;
	ListenReq.listentype.option   = RSIP_SHARED_UDP_LISTENER;
	

	hr=rsipExchangeAndParse(
					(PCHAR)&ListenReq, 
					sizeof(ListenReq), 
					&RespInfo, 
					ListenReq.msgid.msgid,
					FALSE);

	LeaveCriticalSection(&pgd->csRsip);
	
	if(hr!=DP_OK){
		goto exit;
	}

	if(RespInfo.msgtype != RSIP_LISTEN_RESPONSE){
		DPF(0,"Assignment failed? Response was %d\n",RespInfo.msgtype);
		goto error_exit;
	}

	if(psaddr_in){
		psaddr_in->sin_family      = AF_INET;
		psaddr_in->sin_addr.s_addr = RespInfo.lAddressV4;
		psaddr_in->sin_port        = g_htons(RespInfo.lPort);// currently little endian on wire

		DEBUGPRINTADDR(9,"RSIP Listen, public address is\n",(SOCKADDR *)psaddr_in);
	}

	if(pBindid){
		*pBindid = RespInfo.bindid;
	}	

	// remember the lease so we will renew it when necessary.
	rsipAddLease(RespInfo.bindid,ftcp_udp,RespInfo.lAddressV4,g_htons(RespInfo.lPort),port,RespInfo.leasetime);

	
exit:
	DPF(9,"<==RSIP Listen succeeded\n");
	return hr;

error_exit:
	DPF(9,"<==RSIP Listen failed\n");
	return DPERR_GENERIC;

	#undef psaddr_in
}

/*=============================================================================

	rsipFindLease - see if we already have a lease for a local port.
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/


PRSIP_LEASE_RECORD rsipFindLease(BOOL ftcp_udp, WORD port)
{
	PRSIP_LEASE_RECORD pLeaseWalker;

	pLeaseWalker=pgd->pRsipLeaseRecords;
	
	while(pLeaseWalker){
		if(pLeaseWalker->ftcp_udp == ftcp_udp && 
		   pLeaseWalker->port     == port    
		)
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	return pLeaseWalker;
}

/*=============================================================================

	rsipAddLease - adds a lease record to our list of leases
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID rsipAddLease(DWORD bindid, BOOL ftcp_udp, DWORD addrV4, WORD rport, WORD port, DWORD tLease)
{
	PRSIP_LEASE_RECORD pLeaseWalker, pNewLease;
	DWORD tNow;

	tNow=timeGetTime();
	
	// First see if we already have a lease for this port;
	EnterCriticalSection(&pgd->csRsip);

	// first make sure there isn't already a lease for this port
	pLeaseWalker=pgd->pRsipLeaseRecords;
	while(pLeaseWalker){
		if(pLeaseWalker->ftcp_udp == ftcp_udp && 
		   pLeaseWalker->port     == port     && 
		   pLeaseWalker->bindid   == bindid      
		)
		{
			break;
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}

	if(pLeaseWalker){
		pLeaseWalker->dwRefCount++;
		pLeaseWalker->tExpiry = tNow+(tLease*1000);
	} else {
		pNewLease = MemAlloc(sizeof(RSIP_LEASE_RECORD));
		if(pNewLease){
			pNewLease->dwRefCount = 1;
			pNewLease->ftcp_udp   = ftcp_udp;
			pNewLease->tExpiry    = tNow+(tLease*1000);
			pNewLease->bindid     = bindid;
			pNewLease->port		  = port;
			pNewLease->rport      = rport;
			pNewLease->addrV4     = addrV4;
			pNewLease->pNext	  = pgd->pRsipLeaseRecords;
			pgd->pRsipLeaseRecords= pNewLease;
		} else {
			DPF(0,"rsip: Couldn't allocate new lease block for port %x\n",port);
		}
	}
	
	LeaveCriticalSection(&pgd->csRsip);
}

/*=============================================================================

	rsipRemoveLease - removes a lease record from our list of leases
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/
VOID rsipRemoveLease(DWORD bindid)
{
	PRSIP_LEASE_RECORD pLeaseWalker, pLeasePrev;

	DPF(7,"==>rsipRemoveLease bindid %d\n",bindid);

	EnterCriticalSection(&pgd->csRsip);

	pLeaseWalker=pgd->pRsipLeaseRecords;
	pLeasePrev=(PRSIP_LEASE_RECORD)&pgd->pRsipLeaseRecords; //sneaky.

	while(pLeaseWalker){
		if(pLeaseWalker->bindid==bindid){
			--pLeaseWalker->dwRefCount;
			if(!pLeaseWalker->dwRefCount){
				// link over it
				pLeasePrev->pNext=pLeaseWalker->pNext;
				DPF(7,"rsipRemove: removing bindid %d\n",bindid);
				MemFree(pLeaseWalker);
			} else {
				DPF(7,"rsipRemove: refcount on bindid %d is %d\n",bindid, pLeaseWalker->dwRefCount);
			}
			break;
		}
		pLeasePrev=pLeaseWalker;
		pLeaseWalker=pLeaseWalker->pNext;
	}

	LeaveCriticalSection(&pgd->csRsip);

	DPF(7,"<==rsipRemoveLease bindid %d\n",bindid);
}

/*=============================================================================

	rsipPortExtend - checks if port leases needs extension and extends 
					 them if necessary
	
    Description:

    Parameters:

    Return Values:

-----------------------------------------------------------------------------*/

VOID rsipPortExtend(DWORD time)
{
	PRSIP_LEASE_RECORD pLeaseWalker;
	DWORD tExtend;
	HRESULT hr;
	EnterCriticalSection(&pgd->csRsip);

	pLeaseWalker=pgd->pRsipLeaseRecords;
	while(pLeaseWalker){
		
		if((int)(pLeaseWalker->tExpiry - time) < 180000){
			// less than 2 minutes left on lease.
			hr=rsipExtendPort(pLeaseWalker->bindid, &tExtend);			
			if(hr != DP_OK){
				// this binding is now gone!
				DPF(0,"Couldn't renew lease on bindid %d, port %x\n",pLeaseWalker->bindid, pLeaseWalker->port);
				bRsip=FALSE;
			} else {
				pLeaseWalker->tExpiry=time+(tExtend*1000);
				DPF(9,"rsip: Extended Lease of Port %x by %d seconds\n",pLeaseWalker->bindid,tExtend);
			}
		}
		pLeaseWalker=pLeaseWalker->pNext;
	}
	
	LeaveCriticalSection(&pgd->csRsip);

	if(bRsip==FALSE){
		rsipFini();
	}
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\sources.inc ===
TARGETNAME=dplaysvr
TARGETTYPE=PROGRAM

TARGETPATH=.\obj$(BUILD_ALT_DIR)

USE_MAPSYM=1

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
             $(BASEDIR)\public\sdk\lib\*\WINMM.LIB\
	     $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	     $(BASEDIR)\public\sdk\lib\*\user32.lib \
	     $(BASEDIR)\public\sdk\lib\*\advapi32.lib \
	     $(BASEDIR)\public\sdk\lib\*\comdlg32.lib \
		 $(BASEDIR)\public\sdk\lib\*\gdi32.lib

UMTYPE=windows
UMENTRY=winmain

INCLUDES= \
	$(DXROOT)\inc;\
	..\;\
	..\..\wsock;\
	..\..\..\misc;\
	..\..\dplay;\
	..\..\common; \
	..\..\..\dpnathlp\inc; \
	..\..\..\dplobby\dplobby; \
	..\..\nmvoice;

SOURCES= \
	..\dplaysvr.c \
	..\rsip.c \
	..\nathelp.c \
	..\dphelp.c \
    ..\reliable.c \
    ..\registry.c \
    ..\dplaysvr.rc \
	memalloc.c \
	newdpf.c

NTTARGETFILE0=MISC

C_DEFINES=$(C_DEFINES) -DNO_DPF_HWND -DMSBUILD -DNEW_DPF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\rsip.h ===
/*==========================================================================
 *
 *  Copyright (C) 1999 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       rsip.h
 *  Content:	Realm Specific IP Support header
 *
 *  History:
 *  Date		By		Reason
 *  ====		==		======
 *  12/7/99		rlamb	Original
 *  12/8/99     aarono  added function prototypes for rsip support in SP
 *  1/8/2000    aarono  ported for dplaysvr
 *
 ***************************************************************************/

#ifndef _RSIP_H_
#define _RSIP_H_
/*
 * Whats implemented:
 *  as_req_rsap(localaddr=0,localports=4-a:b:c:d,
 *              remaddr=0,remports=0)
 *  as_res_rsap(localaddr=24.128.34.21,localports=4-A:B:C:D,
 *              remaddr=0,remports=0)
 *  where a,b,c,d are listening ports on the client (192.168.0.2)
 *        and A,B,C,D are the associated ports visible
 *        on the external IP address 24.128.34.21.
 * 
 * Operation: When packet from the outside is destined for
 *            24.128.34.21:A is recieved, the ip->dst and udp->dst
 *            (or tcp->dst) fields are changed to 192.168.0.2:a
 *            and then sent along - unencapsulated.
 *            When a packet is sent out from the client, the 
 *            app (e.g. dplay) uses 192.168.0.2:a as in the
 *            IP+UDP/TCP header but uses 24.128.34.21:A for
 *            any information encoded in the data portion of
 *            the packet.
 */
#define RSIP_VERSION 1
#define RSIP_HOST_PORT 2234

// How often we scan the list for liscence renewals
#define RSIP_RENEW_TEST_INTERVAL 60000

/* start RSIP retry timer at 12.5 ms */
#define RSIP_tuRETRY_START	12500
/* max starting retry is 100 ms */
#define RSIP_tuRETRY_MAX	100000

enum { /* TUNNELS */
  TUNNEL_RESERVED = 0,
  TUNNEL_IP_IP = 1,
  TUNNEL_GRE = 2, /* PPTP */
  TUNNEL_L2TP = 3,
  /*TUNNEL_NONE = 4, /* THIS IS NOT PART OR THE SPEC */
};
enum { /* METHODS */
  METHOD_RESERVED = 0,
  RSA_IP = 1,
  RSAP_IP = 2,
  RSA_IP_IPSEC = 3,
  RSAP_IP_IPSEC = 4,
};
enum { /* FLOWS */
  FLOW_RESERVED = 0,
  FLOW_MACRO = 1,
  FLOW_MICRO = 2,
  FLOW_NONE = 3,
};
enum { /* ERROR CODES */
  UNKNOWNERROR = 1,
  BADBINDID = 2,
  BADCLIENTID = 3,
  MISSINGPARAM = 4,
  DUPLICATEPARAM = 5,
  ILLEGALPARAM = 6,
  ILLEGALMESSAGE = 7,
  REGISTERFIRST = 8,
  BADMESSAGEID = 9,
  ALREADYREGISTERED = 10,
  ALREADYUNREGISTERED = 11,
  BADTUNNELTYPE = 12,
  ADDRUNAVAILABLE = 13,
  PORTUNAVAILABLE = 14,
};
#if 0
char *rsip_error_strs[]={
  "RESERVED",
  "UNKNOWNERROR",
  "BADBINDID",
  "BADCLIENTID",
  "MISSINGPARAM",
  "DUPLICATEPARAM",
  "ILLEGALPARAM",
  "ILLEGALMESSAGE",
  "REGISTERFIRST",
  "BADMESSAGEID",
  "ALREADYREGISTERED",
  "ALREADYUNREGISTERED",
  "BADTUNNELTYPE",
  "ADDRUNAVAILABLE",
  "PORTUNAVAILABLE",
  (char *)0
};
#endif
enum { /* MESSAGES */
  RSIP_ERROR_RESPONSE = 1,
  RSIP_REGISTER_REQUEST = 2,
  RSIP_REGISTER_RESPONSE = 3,
  RSIP_DEREGISTER_REQUEST = 4,
  RSIP_DEREGISTER_RESPONSE = 5,
  RSIP_ASSIGN_REQUEST_RSA_IP = 6,
  RSIP_ASSIGN_RESPONSE_RSA_IP = 7,
  RSIP_ASSIGN_REQUEST_RSAP_IP = 8,
  RSIP_ASSIGN_RESPONSE_RSAP_IP = 9,
  RSIP_EXTEND_REQUEST = 10,
  RSIP_EXTEND_RESPONSE = 11,
  RSIP_FREE_REQUEST = 12,
  RSIP_FREE_RESPONSE = 13,
  RSIP_QUERY_REQUEST = 14,
  RSIP_QUERY_RESPONSE = 15,
  RSIP_DEALLOCATE = 16,
  RSIP_OK = 17,
  RSIP_LISTEN_REQUEST = 18,
  RSIP_LISTEN_RESPONSE = 19,
};
enum { /* PARAMETERS */
  RSIP_ADDRESS_CODE = 1,
  RSIP_PORTS_CODE = 2,
  RSIP_LEASE_CODE = 3,
  RSIP_CLIENTID_CODE = 4,
  RSIP_BINDID_CODE = 5,
  RSIP_MESSAGEID_CODE = 6,
  RSIP_TUNNELTYPE_CODE = 7,
  RSIP_RSIPMETHOD_CODE = 8,
  RSIP_ERROR_CODE = 9,
  RSIP_FLOWPOLICY_CODE = 10,
  RSIP_VENDOR_CODE = 11,
};

/*
 * MS specific Vendor Codes
 */
#define RSIP_MS_VENDOR_ID 734
enum {
  RSIP_NO_TUNNEL = 1,
  RSIP_TCP_PORT = 2,
  RSIP_UDP_PORT = 3,
  RSIP_SHARED_UDP_LISTENER = 4,
  RSIP_QUERY_MAPPING = 5,
};

#pragma pack(push,1)

typedef struct _RSIP_MSG_HDR {
	CHAR	version;
	CHAR	msgtype;
} RSIP_MSG_HDR, *PRSIP_MSG_HDR;

typedef struct _RSIP_PARAM {
	CHAR	code;
	WORD	len;
} RSIP_PARAM, *PRSIP_PARAM;

typedef struct _RSIP_MESSAGEID{
	CHAR	code;
	WORD	len;
	DWORD   msgid;	
} RSIP_MESSAGEID, *PRSIP_MESSAGEID;

typedef struct _RSIP_CLIENTID {
	CHAR 	code;
	WORD	len;
	DWORD	clientid;
} RSIP_CLIENTID, *PRSIP_CLIENTID;

typedef struct _RSIP_ADDRESS {
	CHAR 	code;
	WORD	len;
	CHAR    version;	// 1==v4
	DWORD	addr;
} RSIP_ADDRESS, *PRSIP_ADDRESS;

typedef struct _RSIP_PORT {
	CHAR	code;
	WORD 	len;
	CHAR	nports;		// we only do 1 port at a time
	WORD	port;
} RSIP_PORT, *PRSIP_PORT;

typedef struct _RSIP_LEASE {
	CHAR	code;
	WORD	len;
	DWORD	leasetime;
} RSIP_LEASE, *PRSIP_LEASE;

typedef struct _RSIP_BINDID {
	CHAR	code;
	WORD	len;
	DWORD	bindid;
} RSIP_BINDID, *PRSIP_BINDID;

typedef struct _RSIP_TUNNEL {
	CHAR	code;
	WORD	len;
	CHAR	tunneltype;
} RSIP_TUNNEL, *PRSIP_TUNNEL;

// Vendor Specific structures

typedef struct _RSIP_MSVENDOR_CODE {
	CHAR	code;
	WORD	len;
	WORD	vendorid;
	WORD	option;
}RSIP_MSVENDOR_CODE, *PRSIP_MSVENDOR_CODE;

//
// RSIP Message templates
//

typedef struct _MSG_RSIP_REGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_REGISTER, *PMSG_RSIP_REGISTER;

typedef struct _MSG_RSIP_DEREGISTER {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID   clientid;
	RSIP_MESSAGEID  msgid;
} MSG_RSIP_DEREGISTER, *PMSG_RSIP_DEREGISTER;

typedef struct _MSG_RSIP_ASSIGN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;
	
	RSIP_MSVENDOR_CODE  porttype;
	RSIP_MSVENDOR_CODE  tunneloptions;
} MSG_RSIP_ASSIGN_PORT, *PMSG_RSIP_ASSIGN_PORT;

typedef struct _MSG_RSIP_LISTEN_PORT {
	CHAR 			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	laddress;	// local
	RSIP_PORT		lport;
	RSIP_ADDRESS	raddress;	// remote
	RSIP_PORT		rport;
	RSIP_LEASE		lease;
	RSIP_TUNNEL		tunnel;
	RSIP_MESSAGEID  msgid;
	
	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE tunneloptions;
	RSIP_MSVENDOR_CODE listentype;
} MSG_RSIP_LISTEN_PORT, *PMSG_RSIP_LISTEN_PORT;


typedef struct _MSG_RSIP_EXTEND_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID		bindid;
	RSIP_LEASE		lease;
	RSIP_MESSAGEID	msgid;
} MSG_RSIP_EXTEND_PORT, *PMSG_RSIP_EXTEND_PORT;

typedef struct _MSG_RSIP_FREE_PORT {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_BINDID     bindid;
	RSIP_MESSAGEID	msgid;	
} MSG_RSIP_FREE_PORT, *PMSG_RSIP_FREE_PORT;

typedef struct _MSG_RSIP_QUERY {
	CHAR			version;
	CHAR			command;
	RSIP_CLIENTID	clientid;
	RSIP_ADDRESS	address;
	RSIP_PORT		port;
	
	RSIP_MSVENDOR_CODE porttype;
	RSIP_MSVENDOR_CODE querytype;

	RSIP_MESSAGEID	msgid;
} MSG_RSIP_QUERY, *PMSG_RSIP_QUERY;

typedef struct _RSIP_RESPONSE_INFO {
	DWORD	clientid;
	DWORD	messageid;
	DWORD	bindid;
	DWORD	leasetime;
	CHAR    version;
	CHAR    msgtype;
	CHAR	tunneltype;
	CHAR	rsipmethod;
	DWORD	lAddressV4;	
	WORD	lPort;
	DWORD   rAddressV4;
	WORD    rPort;
	WORD	error;
} RSIP_RESPONSE_INFO, *PRSIP_RESPONSE_INFO;

#pragma pack(pop)

extern BOOL rsipInit();
extern VOID rsipFini();
extern HRESULT rsipFreePort(DWORD Bindid);
extern HRESULT rsipListenPort(BOOL ftcp_udp, WORD port, SOCKADDR *psaddr, DWORD *pBindid);
extern VOID rsipPortExtend(DWORD time);

extern BOOL bRsip;

#endif /* _RSIP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\killsvr\sources.inc ===
TARGETNAME=killsvr
TARGETTYPE=PROGRAM

TARGETPATH=.\obj$(BUILD_ALT_DIR)

USE_MAPSYM=1

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
	     $(BASEDIR)\public\sdk\lib\*\kernel32.lib \
	     $(BASEDIR)\public\sdk\lib\*\user32.lib \


UMTYPE=console
UMENTRY=main

INCLUDES= \
	$(DXROOT)\inc;\
	..\;\
	..\..\;\

SOURCES= \
	..\killsvr.c \


#NTTARGETFILE0=MISC

#C_DEFINES=$(C_DEFINES) -DNO_DPF_HWND -DMSBUILD -DNEW_DPF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplog\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DPLOG.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplog\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2AC80E07_F918_11D2_872F_00C04F6BC8E3__INCLUDED_)
#define AFX_STDAFX_H__2AC80E07_F918_11D2_872F_00C04F6BC8E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2AC80E07_F918_11D2_872F_00C04F6BC8E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\arpd.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ARPD.H

Abstract:

	Include file for Another Reliable Protocol internal, CPP version

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#ifndef _ARPD_H_
#define _ARPD_H_

typedef VOID (*PSEND_CALLBACK)(PVOID Context,UINT Status);

typedef struct _ASYNCSENDINFO {
	UINT            Reserved[4];
	HANDLE 			hEvent;			// Event to signal on send complete.
	PSEND_CALLBACK	SendCallBack;   // Callback to call on send complete.
	PVOID           CallBackContext;// Context for callback.
	PUINT			pStatus;        // place to put status on completion.
} ASYNCSENDINFO, *PASYNCSENDINFO;

#define SEND_STATUS_QUEUED			0x00000001
#define SEND_STATUS_TRANSMITTING	0x00000002
#define SEND_STATUS_FAILURE  		0x80000003
#define SEND_STATUS_SUCCESS			0x80000004

#endif //_ARPD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplaysvr\killsvr\killsvr.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	   killsvr.c
 *  Content:	kill dplay.exe
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   24-jun-95	craige	kill all attached processes
 *	 2-feb-97	andyco	ported for dplaysvr.exe
 *	 7-jul-97	kipo	added non-console support
 *
 ***************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "dplaysvr.h"

// only do printf's when built as a console app

#ifdef NOCONSOLE
#pragma warning(disable:4002)
#define printf()
#endif


//**********************************************************************
// Globals
//**********************************************************************
BOOL					g_fDaclInited = FALSE;
SECURITY_ATTRIBUTES		g_sa;
BYTE					g_abSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
PSECURITY_ATTRIBUTES	g_psa = NULL;



//**********************************************************************
// ------------------------------
// DNGetNullDacl - Get a SECURITY_ATTRIBUTE structure that specifies a 
//					NULL DACL which is accessible by all users.
//					Taken from IDirectPlay8 code base.
//
// Entry:		Nothing
//
// Exit:		PSECURITY_ATTRIBUTES
// ------------------------------
#undef DPF_MODNAME 
#define DPF_MODNAME "DNGetNullDacl"
PSECURITY_ATTRIBUTES DNGetNullDacl(void)
{
	// This was done to make this function independent of DNOSIndirectionInit so that the debug
	// layer can call it before the indirection layer is initialized.
	if (!g_fDaclInited)
	{
		if (!InitializeSecurityDescriptor((SECURITY_DESCRIPTOR*) g_abSD, SECURITY_DESCRIPTOR_REVISION))
		{
			printf("Failed to initialize security descriptor!\n");
		}
		else
		{
			// Add a NULL DACL to the security descriptor.
			if (!SetSecurityDescriptorDacl((SECURITY_DESCRIPTOR*) g_abSD, TRUE, (PACL) NULL, FALSE))
			{
				printf("Failed to set NULL DACL on security descriptor!\n");
			}
			else
			{
				g_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
				g_sa.lpSecurityDescriptor = g_abSD;
				g_sa.bInheritHandle = FALSE;

				g_psa = &g_sa;
			}
		}
		g_fDaclInited = TRUE;
	}
	
	return g_psa;
}
//**********************************************************************

/*
 * sendRequest
 *
 * communicate a request to DPHELP
 */
static BOOL sendRequest( LPDPHELPDATA req_phd )
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	LPDPHELPDATA	phd;
	HANDLE			hmem;
	HANDLE			hmutex;
	HANDLE			hackevent;
	HANDLE			hstartevent;
	BOOL			rc;


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			/*
			printf("Running on NT version %u.%u.%u, using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			*/
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			/*
			printf("Running on 9x version %u.%u.%u, not using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			*/
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		//printf("Could not determine OS version, assuming global namespace not needed.\n");
		fUseGlobalNamespace = FALSE;
	}


	/*
	 * get events start/ack events
	 */
	if (fUseGlobalNamespace)
	{
		hstartevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_EVENT_NAME );
	}
	else
	{
		hstartevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_EVENT_NAME );
	}
	printf( "hstartevent = %08lx\n", hstartevent );
	if( hstartevent == NULL )
	{
		return FALSE;
	}

	if (fUseGlobalNamespace)
	{
		hackevent = CreateEvent( DNGetNullDacl(), FALSE, FALSE, "Global\\" DPHELP_ACK_EVENT_NAME );
	}
	else
	{
		hackevent = CreateEvent( NULL, FALSE, FALSE, DPHELP_ACK_EVENT_NAME );
	}
	printf( "hackevent = %08lx\n", hackevent );
	if( hackevent == NULL )
	{
		CloseHandle( hstartevent );
		return FALSE;
	}

	/*
	 * create shared memory area
	 */
	if (fUseGlobalNamespace)
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, DNGetNullDacl(),
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								"Global\\" DPHELP_SHARED_NAME );
	}
	else
	{
		hmem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL,
								PAGE_READWRITE, 0, sizeof( DPHELPDATA ),
								DPHELP_SHARED_NAME );
	}
	printf( "hmem = %08lx\n", hmem );
	if( hmem == NULL )
	{
		printf( "Could not create file mapping!\n" );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	phd = (LPDPHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
	printf( "phd = %08lx\n", phd );
	if( phd == NULL )
	{
		printf( "Could not create view of file!\n" );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}

	/*
	 * wait for access to the shared memory
	 */
	if (fUseGlobalNamespace)
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, "Global\\" DPHELP_MUTEX_NAME );
	}
	else
	{
		hmutex = OpenMutex( SYNCHRONIZE, FALSE, DPHELP_MUTEX_NAME );
	}
	printf( "hmutex = %08lx\n", hmutex );
	if( hmutex == NULL )
	{
		printf( "Could not create mutex!\n" );
		UnmapViewOfFile( phd );
		CloseHandle( hmem );
		CloseHandle( hstartevent );
		CloseHandle( hackevent );
		return FALSE;
	}
	WaitForSingleObject( hmutex, INFINITE );

	/*
	 * wake up DPHELP with our request
	 */
	memcpy( phd, req_phd, sizeof( DPHELPDATA ) );
	printf( "waking up DPHELP\n" );
	if( SetEvent( hstartevent ) )
	{
		printf( "Waiting for response\n" );
		WaitForSingleObject( hackevent, INFINITE );
		memcpy( req_phd, phd, sizeof( DPHELPDATA ) );
		rc = TRUE;
		printf( "got response\n" );
	}
	else
	{
		printf("Could not signal event to notify DPHELP!\n" );
		rc = FALSE;
	}

	/*
	 * done with things
	 */
	ReleaseMutex( hmutex );
	CloseHandle( hmutex );
	CloseHandle( hstartevent );
	CloseHandle( hackevent );
	UnmapViewOfFile( phd );
	CloseHandle( hmem );
	return rc;

} /* sendRequest */


// if the main entry point is called "WinMain" we will be built
// as a windows app
#ifdef NOCONSOLE

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
				   LPSTR lpCmdLine, int nCmdShow)

#else

// if the main entry point is called "main" we will be built
// as a console app

int __cdecl main( int argc, char *argv[] )

#endif
{
	OSVERSIONINFOA	VersionInfo;
	BOOL			fUseGlobalNamespace;
	HANDLE			h;
	DPHELPDATA		hd;


	// Determine if we're running on NT.
	memset(&VersionInfo, 0, sizeof(VersionInfo));
	VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);
	if (GetVersionExA(&VersionInfo))
	{
		if (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			printf("Running on NT version %u.%u.%u, using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber);
			fUseGlobalNamespace = TRUE;
		}
		else
		{
			printf("Running on 9x version %u.%u.%u, not using global namespace.\n",
				VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, LOWORD(VersionInfo.dwBuildNumber));
			fUseGlobalNamespace = FALSE;
		}
	}
	else
	{
		printf("Could not determine OS version, assuming global namespace not needed.\n");
		fUseGlobalNamespace = FALSE;
	}

	if (fUseGlobalNamespace)
	{
		h = OpenEvent( SYNCHRONIZE, FALSE, "Global\\" DPHELP_STARTUP_EVENT_NAME );
	}
	else
	{
		h = OpenEvent( SYNCHRONIZE, FALSE, DPHELP_STARTUP_EVENT_NAME );
	}
	if( h == NULL )
	{
		printf( "Helper not running\n" );
		return 0;
	}

	printf( "*** SUICIDE ***\n" );
	hd.req = DPHELPREQ_SUICIDE;
	sendRequest( &hd );
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\dplog\dplog.cpp ===
// DPLOG.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "..\common\memlog.h"

int main(int argc, char* argv[])
{
	HANDLE hFile=0;
	HANDLE hMutex=0;
	LPVOID lpMemory=NULL;
	UINT timebase=0;
	UINT i=0;
	
	PSHARED_LOG_FILE pLogFile	=NULL;
	PLOG_ENTRY 		 pLog		=NULL;
    PLOG_ENTRY       pReadEntry =NULL;

	hFile=CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, DPLOG_SIZE, BASE_LOG_FILENAME);
	hMutex=CreateMutexA(NULL, FALSE, BASE_LOG_MUTEXNAME); 
	lpMemory=MapViewOfFile(hFile, FILE_MAP_ALL_ACCESS, 0, 0, 0);

	if(!hFile || !hMutex || !lpMemory){
		goto exit;
	}

	pLogFile=(PSHARED_LOG_FILE)lpMemory;
	pLog=(PLOG_ENTRY)(pLogFile+1);

	WaitForSingleObject(hMutex,INFINITE);

	if(pLogFile->cInUse == pLogFile->nEntries){
		// dump last half of buffer
		for(i=pLogFile->iWrite; i < pLogFile->nEntries; i++){
			pReadEntry=(PLOG_ENTRY)(((CHAR *)pLog)+(i*(pLogFile->cbLine+sizeof(LOG_ENTRY))));
			printf("%4d: %8x %6d %2x %s\n",i,pReadEntry->hThread,pReadEntry->tLogged-timebase,pReadEntry->DebugLevel, pReadEntry->str);
			timebase=pReadEntry->tLogged;
		}
	}

	// dump firt part of buffer

	for(i=0;i<pLogFile->iWrite;i++){
		pReadEntry=(PLOG_ENTRY)(((CHAR *)pLog)+(i*(pLogFile->cbLine+sizeof(LOG_ENTRY))));
		printf("%4d: %8x %6d %2x %s\n",i,pReadEntry->hThread,pReadEntry->tLogged-timebase,pReadEntry->DebugLevel, pReadEntry->str);
		timebase=pReadEntry->tLogged;
	}

	ReleaseMutex(hMutex);
	UnmapViewOfFile(lpMemory);

exit:
	if(hFile){
		CloseHandle(hFile);
	}
	if(hMutex){
		CloseHandle(hMutex);
	}
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\arpdint.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ARPDINT.H

Abstract:

	Include file for Another Reliable Protocol internal.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/16/98 aarono  Don't patch for Protocol, DPLAY now calls direct.
   6/6/98  aarono  Turn on throttling and windowing
   2/12/00 aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#ifndef _ARPDINT_H_

#define _ARPDINT_H_

#include <dplay.h>
#include "arpd.h"
#include "bilink.h"
#include "arpstruc.h"
#include "protocol.h"
#include "bufmgr.h"
#include "handles.h"

// Macros for converting too and from 24.8 fixed point.
#define Fp(_x) ((_x)<<8)
#define unFp(_x)((_x)>>8)

typedef enum _PROTOCOL_State {
	Initializing=1,
	Running,
	ShuttingDown,
	ShutDown
} PROTOCOL_State;

#define MAX_THREADS 16

typedef struct PROTOCOL {
		//
		// Service Provider info - at top so DPLAY can access easily through protocol ptr.
		//
		IDirectPlaySP   * m_lpISP;      	       	 	//  used by SP to call back into DirectPlay 

		DWORD             m_dwSPMaxFrame;
		DWORD             m_dwSPMaxGuaranteed;
		DWORD             m_dwSPHeaderSize;
		CRITICAL_SECTION  m_SPLock;						// lock calls to SP on our own, avoids deadlocks.

		//
		// Protocol Info
		//
		
VOL		UINT 	  	  	  m_cRef;		// Refcount.
		CRITICAL_SECTION  m_ObjLock;	// lock for this object.
VOL		PROTOCOL_State    m_eState;		// State of object

VOL		LPDPLAYI_DPLAY    m_lpDPlay;	// backpointer to DPLAY object.

		// Handle Table
		VOLLPMYHANDLETABLE lpHandleTable;
		CRITICAL_SECTION   csHandleTable;

		// Cached DPLAY info.
		DWORD             m_dwIDKey;    // to unlock DPID's
		
		//
		// Threads
		//
		HANDLE            m_hSendThread[MAX_THREADS];	// send thread handles (0->nSendThreads)
		DWORD             m_dwSendThreadId[MAX_THREADS];// send thread ids (0->nSendThreads)
VOL		UINT              m_nSendThreads;				// number of send threads.
VOL		HANDLE            m_hSendEvent;                 // kick send until nothing to send.

		//
		// Multi-media timer capabilities
		//
		TIMECAPS          m_timecaps;					// {.wPeriodMin .wPeriodMax (ms)}

		//
	    // SESSIONion Handles
	    //
		CRITICAL_SECTION  m_SessionLock;
VOL		UINT              m_nSessions;
VOL		UINT              m_SessionListSize;
VOL		PSESSION          (*m_pSessions)[];
VOL		PSESSION          m_pServerPlayerSession;		// Short circuit to index 0xFFFE
		
		//
		// Priority Queue
		//
VOL		DWORD             m_dwBytesPending;
VOL		DWORD             m_dwMessagesPending;
		CRITICAL_SECTION  m_SendQLock;         			// Locks the Priority Queue.
		BILINK            m_GSendQ;						// Packet Queue in priority order.
VOL		BOOL              m_bRescanQueue;               // Used for force GetNextMessageToSend to restart

		
		CRITICAL_SECTION  m_RcvQLock;           		// All completed receives lock. (locks on SESSION too).
		BILINK            m_GlobalRcvQ;					// All receives queued here, (also on each session).


		//
		// Receive Descriptor Management - per instance because of SPHeader length.
		//
		
VOL		PRECEIVE 		 pRcvDescPool;
VOL		UINT             nRcvDescsAllocated;	// Number Allocated
VOL		UINT             nRcvDescsInUse;		// Number currently in use
VOL		UINT             nMaxRcvDescsInUse;     // Maximum number in use since last TICK.

		CRITICAL_SECTION RcvDescLock;
		
VOL		LONG fInRcvDescTick;					

} PROTOCOL, *PPROTOCOL;

// PROTOCOL.C
HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData);
HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData);
HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData);
HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData);
HRESULT WINAPI ProtocolShutdown(void);
HRESULT WINAPI ProtocolShutdownEx(LPDPSP_SHUTDOWNDATA pShutdownData);

//
// SENDPOOL.CPP
//
VOID  InitSendDescs(VOID);
VOID  FiniSendDescs(VOID);
PSEND GetSendDesc(VOID);
VOID  ReleaseSendDesc(PSEND pSend);

//
// STATPOOL.CPP
//
VOID InitSendStats(VOID);
VOID FiniSendStats(VOID);
PSENDSTAT GetSendStat(VOID);
VOID ReleaseSendStat(PSENDSTAT pSendStat);

//
// RCVPOOL.CPP
//
VOID InitRcvDescs(PPROTOCOL pProtocol);
VOID FiniRcvDescs(PPROTOCOL pProtocol);
PRECEIVE GetRcvDesc(PPROTOCOL pProtocol);
VOID ReleaseRcvDesc(PPROTOCOL pProtocol, PRECEIVE pReceive);

// FRAMEBUF.CPP 
VOID InitFrameBuffers(VOID);
VOID FiniFrameBuffers(VOID);
VOID FreeFrameBuffer(PBUFFER pBuffer);
PBUFFER GetFrameBuffer(UINT MaxFrame);
VOID ReleaseFrameBufferMemory(PUCHAR pFrame);

// SEND.C
VOID UpdateSendTime(PSESSION pSession, DWORD Len, DWORD tm, BOOL fAbsolute);
HRESULT SendHandler(PPROTOCOL pProt);
VOID BuildHeader(PSEND pSend, pPacket1 pFrame, UINT shift, DWORD tm);
ULONG WINAPI SendThread(LPVOID pProt);
INT IncSendRef(PSEND pSend);
INT DecSendRef(PPROTOCOL pProt, PSEND pSend);
BOOL AdvanceSend(PSEND pSend, UINT FrameDataLen);
VOID CancelRetryTimer(PSEND pSend);
VOID DoSendCompletion(PSEND pSend, INT Status);

HRESULT Send(
	PPROTOCOL      pProtocol,
	DPID           idFrom, 
	DPID           idTo, 
	DWORD          dwSendFlags, 
	LPVOID         pBuffers,
	DWORD          dwBufferCount, 
	DWORD          dwSendPri,
	DWORD          dwTimeOut,
	LPVOID         lpvUserID,
	LPDWORD        lpdwMsgID,
	BOOL           bSendEx,		// called from SendEx.
	PASYNCSENDINFO pAsyncInfo
	);
	
HRESULT ISend(
	PPROTOCOL pProtocol,
	PSESSION pSession, 
	PSEND    pSend
	);

HRESULT QueueSendOnSession(
	PPROTOCOL pProtocol, PSESSION pSession, PSEND pSend
);

UINT CopyDataToFrame(
	PUCHAR  pFrameData, 
	UINT    FrameDataLen,
	PSEND   pSend,
	UINT    nAhead);

ULONG WINAPI SendThread(LPVOID pProt);
HRESULT ReliableSend(PPROTOCOL pProtocol, PSEND pSend);
BOOL AdvanceSend(PSEND pSend, UINT AckedLen);
HRESULT DGSend(PPROTOCOL pProtocol, PSEND  pSend);
BOOL DGCompleteSend(PSEND pSend);
HRESULT SystemSend(PPROTOCOL pProtocol, PSEND  pSend);
PSEND GetNextMessageToSend(PPROTOCOL pProtocol);
VOID TimeOutSession(PSESSION pSession);
INT AddSendRef(PSEND pSend, UINT count);

extern CRITICAL_SECTION g_SendTimeoutListLock;
extern BILINK g_BilinkSendTimeoutList;

//RECEIVE.C
UINT CommandReceive(PPROTOCOL pProt, CMDINFO *pCmdInfo, PBUFFER pBuffer);
VOID ProtocolReceive(PPROTOCOL pProtocol, WORD idFrom, WORD idTo, PBUFFER pRcvBuffer, LPVOID pvSPHeader);
VOID FreeReceive(PPROTOCOL pProtocol, PRECEIVE pReceive);
VOID InternalSendComplete(PVOID Context, UINT Status);

//SESSION.C
LPDPLAYI_PLAYER pPlayerFromId(PPROTOCOL pProtocol, DPID idPlayer);
HRESULT	CreateNewSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSysSession(PPROTOCOL pProtocol, DPID idPlayer);
PSESSION GetSysSessionByIndex(PPROTOCOL pProtocol, DWORD index);
DPID GetDPIDByIndex(PPROTOCOL pProtocol, DWORD index);
WORD GetIndexByDPID(PPROTOCOL pProtocol, DPID dpid);
INT DecSessionRef(PSESSION pSession);

//BUFGMGR.C
VOID InitBufferManager(VOID);
VOID FiniBufferManager(VOID);
UINT MemDescTotalSize(PMEMDESC pMemDesc, UINT nDesc);
PDOUBLEBUFFER GetDoubleBuffer(UINT nBytes);
PBUFFER GetDoubleBufferAndCopy(PMEMDESC pMemDesc, UINT nDesc);
VOID FreeDoubleBuffer(PBUFFER pBuffer);
PBUFFER BuildBufferChain(PMEMDESC pMemDesc, UINT nDesc);
VOID FreeBufferChain(PBUFFER pBuffer);
VOID FreeBufferChainAndMemory(PBUFFER pBuffer);
UINT BufferChainTotalSize(PBUFFER pBuffer);

//STATS.C
VOID InitSessionStats(PSESSION pSession);
VOID UpdateSessionStats(PSESSION pSession, PSENDSTAT pStat, PCMDINFO pCmdInfo, BOOL fBadDrop);
VOID UpdateSessionSendStats(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo, BOOL fBadDrop);


#define SAR_FAIL 0
#define SAR_ACK  1
#define SAR_NACK 2
UINT SendAppropriateResponse(PPROTOCOL pProt, PSESSION pSession, CMDINFO *pCmdInfo, PRECEIVE pReceive);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "newdpf.h"
#include <dplaypr.h>
#include "bilink.h"
#include "mydebug.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    if(!p && p->prev && p->next){
    	DEBUG_BREAK();
    }
    ASSERT(p->prev->next == p && p->next->prev == p);
    if(!(p->prev->next == p && p->next->prev == p)){
    	DEBUG_BREAK();
    }
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\arpstruc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ARPSTRUC.H

Abstract:

	Structure definitions for the ARP protocol implementation

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/27/97  aarono  Original
   2/18/98  aarono  Added more fields to SEND for SendEx support
   6/6/98   aarono  Turn on throttling and windowing
   2/12/00  aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#ifndef _ARPSTRUC_H_
#define _ARPSTRUC_H_

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include "arpd.h"
#include "bufpool.h"
#include "bilink.h"
#include "mydebug.h"
//#include "threads.h"

//#pragma warning( disable : 4090)

#define VOL volatile
//
// Information about sent packets, tracked for operational statistics.
//

#define SENDSTAT_SIGN SIGNATURE('S','T','A','T')

typedef struct PROTOCOL *PPROTOCOL;

typedef struct _SENDSTAT {
#ifdef SIGN
	UINT				Signature;		// Signature for SIGN
#endif
	union {
		BILINK	StatList;		// linked on Send and later SESSION.
		struct _SENDSTAT *pNext;
	};	
	UINT    messageid;   
	UINT    sequence;		// sequence number
	UINT    serial;			// serial number
	UINT    tSent;			// tick time when this packet instance sent.
	UINT    LocalBytesSent;     // number of bytes sent on session at send time.
	UINT    RemoteBytesReceived;// last remote byte report at send time.
	UINT    tRemoteBytesReceived; // remote timestamp when received.
	UINT    bResetBias;
} SENDSTAT, *PSENDSTAT;

#define SEND_SIGN SIGNATURE('S','E','N','D')

typedef enum _TRANSMITSTATE {
	Start=0,			// Never sent a packet.
	Sending=1,			// Thread to send is running and xmitting.
	Throttled=2,		// Waiting for send bandwidth.
	WaitingForAck=3,	// Timer running, listening for ACKs.
	WaitingForId=4,   	// Waiting for a Send Id.
	ReadyToSend=5,		// Have stuff to xmit, waiting for thread.
	TimedOut=6,       	// Retry timed out.
	Cancelled=7,        // User cancelled send.
	UserTimeOut=8,		// Didn't try to send until too late.
	Done=9				// Finished sending, singalled sender.
	
} TRANSMITSTATE;

struct _SESSION;

// this Send is an ACK or NACK (OR'ed into SEND.dwFlags)
#define 	ASEND_PROTOCOL 	0x80000000

#pragma pack(push,1)

typedef struct _SEND{

#ifdef SIGN
	UINT		     Signature;		    // Signature for SIGN
#endif
	CRITICAL_SECTION SendLock;          // Lock for Send Structure
	UINT             RefCount;          // @#$%! - not marked volatile since accessed only with Interlocked fns.
	
VOL	TRANSMITSTATE    SendState;			// State of this message's transmission.

	// Lists and Links...
	
	union {
		struct _SEND *pNext;			// linking on free pool
		BILINK		   SendQ;			// linking on session send queue
	};
	BILINK         m_GSendQ;			// Global Priority Queue
	BILINK         TimeoutList;			// List of sends waiting for timeout (workaround MMTIMER cancel bug).
	struct _SESSION *pSession;          // pointer to SESSIONion(gets a ref)

	PPROTOCOL      pProtocol;           // pointer to Protocol instance that created us.

	// Send Information
	
	DPID           idFrom;
	DPID           idTo;
	WORD           wIdTo;				// index in table
	WORD           wIdFrom;             // index in table
	UINT		   dwFlags;             // Send Flags (include reliable)
	PBUFFER		   pMessage;			// Buffer chain describing message.
	UINT           MessageSize;			// Total size of the message.
	UINT           FrameDataLen;        // Data area of each frame.
	UINT           nFrames;			    // Number of frames for this message.

	UINT           Priority;            // Send Priority.

	// User cancel and complete info
	DWORD          dwMsgID;             // message id given to user, for use in cancel.
	LPVOID         lpvUserMsgID;		// user's own identifier for this send.
	BOOL           bSendEx;             // called through SendEx.

	// Vars for reliability
	BOOL           fSendSmall;
VOL BOOL       	   fUpdate;             // update to NS,NR NACKMask made by receive.
	UINT		   messageid;			// Message ID number.
	UINT           serial;              // serial number.
VOL	UINT		   OpenWindow;          // Number of sends we are trying to get outstanding
VOL	UINT           NS;		        	// Sequence Sent.
VOL	UINT           NR;					// Sequence ACKED.
	UINT           SendSEQMSK; 			// Mask to use. 
VOL	UINT           NACKMask;            // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
VOL	UINT		   SendOffset;			// Current offset we are sending.
VOL	PBUFFER        pCurrentBuffer;  	// Current buffer being sent.
VOL	UINT           CurrentBufferOffset; // Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	BILINK         StatList;			// Info for packets already sent.
	DWORD          BytesThisSend;		// number of bytes being sent in the current packet.

	// Operational Characteristics

VOL	UINT_PTR       uRetryTimer;         
    UINT           TimerUnique;

	UINT           RetryCount;          // Number of times we retransmitted.
	UINT           WindowSize;          // Maximum Window Size.
	UINT           SAKInterval;         // interval (frames) at which a SAK is required.
	UINT           SAKCountDown;		// countdown to 0 from interval.
	UINT           tLastACK;            // Time we last got an ACK.

	UINT           dwSendTime;			// time we were called in send.
	UINT           dwTimeOut;			// timeout time.

	UINT           PacketSize;          // Size of packets to send.
	UINT           FrameSize;           // Size of Frames for this send.

	// Completion Vars
	HANDLE         hEvent;              // Event to wait on for internal send.
	UINT           Status;              // Send Completion Status.

	PASYNCSENDINFO pAsyncInfo;          // ptr to Info for completing Async send(NULL=>internal send)
	ASYNCSENDINFO  AsyncInfo;           // actual info (copied at send call).

	DWORD		   tScheduled;			// the time we scheduled the retry;
	DWORD          tRetryScheduled;     // expected retry timer run time.
VOL	BOOL           bCleaningUp;			// we are on the queue but don't take a ref pls.
} SEND, *PSEND;

#pragma pack(pop)

#define RECEIVE_SIGN SIGNATURE('R','C','V','_')


// Receive buffers are in reverse receive order.  When they have all
// been received, they are then put in proper order.
typedef struct _RECEIVE {
#ifdef SIGN
	UINT		    Signature;		// Signature for SIGN
#endif
	union {
		BILINK          pReceiveQ;
		struct _RECEIVE *      pNext;
	};	
	BILINK		    RcvBuffList;     // List of receive buffers that make up the message.

	CRITICAL_SECTION ReceiveLock;

	struct _SESSION *pSession;

VOL	BOOL            fBusy;		// Someone is moving this receive.
	BOOL            fReliable;		// Whether this is a reliable receive.
VOL	BOOL            fEOM;           // Whether we received the EOM bit.

	UINT            command;      
	
	UINT			messageid;
VOL	UINT			MessageSize;

VOL	UINT            iNR;			// Absolute index of first receiving packet (reliable only).
VOL	UINT            NR;				// Last in sequence packet received.
VOL	UINT            NS;				// Highest packet number received.
VOL	UINT            RCVMask;		// bitmask of received packets (NR relative)

	PUCHAR          pSPHeader;
	UCHAR           SPHeader[0];

} RECEIVE, *PRECEIVE;

#pragma pack(push,1)

typedef struct _CMDINFO {
	WORD        wIdTo;		// index
	WORD        wIdFrom;	// index
	DPID        idTo;		// actual DPID
	DPID        idFrom;		// actual DPID
	
	UINT        bytes;      // read from ACK.
	DWORD       tRemoteACK; // remote time remote ACKed/NACKed
	
	UINT        tReceived;  // timeGetTime() when received.
	UINT        command;
	UINT        IDMSK;
	USHORT      SEQMSK;
	USHORT      messageid;
	USHORT      sequence;
	UCHAR       serial;
	UCHAR		flags;
	PVOID       pSPHeader;  // used to issue a reply.
} CMDINFO, *PCMDINFO;

#pragma pack(pop)


#define SESSION_SIGN SIGNATURE('S','E','S','S')

// since we now have a full byte for messagid and sequenne in the small headers, 
// we no longer have an advantage for full headers until we apply the new
// bitmask package, then we must transit to large frame for windows > 127 messages.

#define MAX_SMALL_CSENDS 	 29UL			// Maximum Concurrent Sends when using small frame headers
#define MAX_LARGE_CSENDS	 29UL			// Maxinum Concurrent Sends when using large frame headers (could make larger except for mask bits)
#define MAX_SMALL_DG_CSENDS  16UL			// Maximum concurrent datagrams when using small frame     
#define MAX_LARGE_DG_CSENDS  16UL           // Maximum Concurrent datagrams when using large frames.
#define MAX_SMALL_WINDOW     24UL
#define MAX_LARGE_WINDOW     24UL

typedef enum _SESSION_STATE {
	Open,				// When created and Inited.
	Closing,			// Don't accept new receives/sends.
	Closed				// gone.
} SESSION_STATE;

#define SERVERPLAYER_INDEX 0xFFFE

#define SESSION_THROTTLED			0x00000001		// session throttle is on.
#define SESSION_UNTHROTTLED         0x00000002		// unthrottle is deffered to avoid confusing GetMessageQueue.

/////////////////////////////////////////////////////////////////
//
//	Transition Matrix for Throttle Adjust
// 
//  Initial State	Event:
//					No Drops	1 Drop		>1 Drop
//
//  Start			+ Start		- Meta      -- Start
//								
//  Meta			+ Meta      - Stable    -- Meta
//
//  Stable          + Stable    - Stable    -- Meta
//
//
//  Engagement of Backlog Throttle goes to MetaStable State.
///////////////////////////////////////////////////////////////////

#define METASTABLE_GROWTH_RATE      4
#define METASTABLE_ADJUST_SMALL_ERR	12
#define METASTABLE_ADJUST_LARGE_ERR 25

#define START_GROWTH_RATE      50
#define START_ADJUST_SMALL_ERR 25
#define START_ADJUST_LARGE_ERR 50

#define STABLE_GROWTH_RATE      2
#define STABLE_ADJUST_SMALL_ERR 12
#define STABLE_ADJUST_LARGE_ERR 25

typedef enum _ThrottleAdjustState
{
	Begin=0,		// At start, double until drop or backlog
	MetaStable=1,	// Meta stable, large deltas for drops
	Stable=2		// Stable, small deltas for drops
} eThrottleAdjust;

typedef struct _SESSION {
	PPROTOCOL        pProtocol;			    // back ptr to object.

#ifdef SIGN
	UINT		  	 Signature;			    // Signature for SIGN
#endif

	// Identification

	CRITICAL_SECTION SessionLock;           // Lock for the SESSIONion.
	UINT             RefCount;			    // RefCount for the SESSION. - not vol, only accessed with Interlocked
VOL	SESSION_STATE    eState;
	HANDLE           hClosingEvent;         // Delete waits on this during close.
	
	DPID			 dpid;					// The remote direct play id for this session.
	UINT             iSession;              // index in the session table
	UINT             iSysPlayer;            // index in session table of sys player.
											// NOTE: if iSysPlayer != iSession, then rest of struct not req'd.

	BILINK			 SendQ;					// Priority order sendQ;
	BOOL             fFastLink;				// set True when link > 50K/sec, set False when less than 10K/sec.
	BOOL             fSendSmall;            // Whether we are sending small reliable frames.
	BOOL             fSendSmallDG;          // Whether we are sending small datagram frames.

	BOOL             fReceiveSmall;
	BOOL             fReceiveSmallDG;
											
	UINT			 MaxPacketSize;			// Largest packet allowed on the media.

	// Operating parameters -- Send

	// Common
	
	UINT             MaxCSends;				// maximum number of concurrent sends
	UINT             MaxCDGSends;           // maximum number of concurrent datagram sends

	// Reliable

VOL	UINT			 FirstMsg;				// First message number being transmitted
VOL	UINT			 LastMsg;				// Last message number being transmitted
VOL	UINT             OutMsgMask;            // relative to FirstMsg, unacked messages

	UINT             nWaitingForMessageid;  // number of sends on queue that can't start sending because they don't have an id.

	// DataGram


VOL	UINT             DGFirstMsg;             // First message number being transmitted
VOL	UINT             DGLastMsg;              // Last message number being transmitted
VOL	UINT             DGOutMsgMask;           // relative to FirstMsg, not-fully sent messages.

	UINT             nWaitingForDGMessageid; // number of sends on queue that can't start sending because they don't have an id.

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive

	// DataGram Receive.
	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
VOL	UINT             FirstRlyReceive;
VOL	UINT             LastRlyReceive;
VOL	UINT             InMsgMask;              // mask of fully received receives, relative to FirstRlyReceive
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!! - this is because we read and write them
	//                               without a lock and assume the reads and writes are atomic (not in combination)

	UINT             WindowSize;            // Max outstanding packets on a send - reliable
	UINT             DGWindowSize;          // Max outstanding packets on a send - datagram
	
	UINT             MaxRetry;				// Usual max retries before dropping.
	UINT             MinDropTime;			// Min time to retry before dropping.
	UINT             MaxDropTime;			// After this time always drop.

VOL	UINT             LocalBytesReceived;    // Total Data Bytes received (including retries).
VOL	UINT             RemoteBytesReceived;   // Last value from remote.
VOL	DWORD            tRemoteBytesReceived;  // Remote time last value received.

	UINT			 LongestLatency;		// longest observed latency (msec)
	UINT             ShortestLatency;		// shortest observed latency(msec)
	UINT             LastLatency;           // last observed latency (msec)
	
	UINT             FpAverageLatency;		// average latency          (msec 24.8) (128 samples)
	UINT             FpLocalAverageLatency;	// Local average latency    (msec 24.8) (16 samples)

	UINT             FpAvgDeviation;        // average deviation of latency. (msec 24.8) (128 samples)
	UINT             FpLocalAvgDeviation;   // average deviation of latency. (msec 24.8) (16 samples)

	UINT             Bandwidth;				// latest observed bandwidth (bps)
	UINT			 HighestBandwidth;      // highest observed bandwidth (bps)

	// we will use changes in the remote ACK delta to isolate latency in the send direction.
	UINT             RemAvgACKDelta;		// average clock delta between our send time (local time) and remote ACK time (remote time).
	UINT             RemAvgACKDeltaResidue;
	UINT             RemAvgACKBias;			// This value is used to pull the clock delta into a safe range (not near 0 or -1)
											// that won't risk hitting the wraparound when doing calculations

	// Throttle statistics
	DWORD			 dwFlags;               // Session Flags - currently just "throttle on/off"(MUST STAY THIS WAY)
	UINT			 SendRateThrottle;	    // current rate (bps) at which we are throttling.
	DWORD            bhitThrottle;          // we hit a throttle
	DWORD            tNextSend;				// when we are allowed to send again.
	DWORD            tNextSendResidue;		// residual from calculating next send time
	DWORD_PTR		 uUnThrottle;
	DWORD            UnThrottleUnique;
	DWORD            FpAvgUnThrottleTime;   // (24.8) how late Unthrottle usually called. (throttle when send is this far ahead)
											// last 16 samples, start at 5 ms.

	DWORD            tLastSAK;				// last time we asked for an ACK

	CRITICAL_SECTION SessionStatLock;        // [locks this section ------------------------------------------- ]
	BILINK           DGStatList;             // [Send Statistics for Datagrams (for reliable they are on Sends) ]
	DWORD            BytesSent;				 // [Total Bytes Sent to this target                                ]
	DWORD			 BytesLost;				 // [Total Bytes Lost on the link.							 		]
	DWORD            bResetBias;             // [Counts down to reset latency bias								]
											 // [---------------------------------------------------------------]

	eThrottleAdjust  ThrottleState;			// ZEROINIT puts in Start
	DWORD            GrowCount;				// number of times we grew in this state
	DWORD            ShrinkCount;			// number of times we shrank in this state
	DWORD            tLastThrottleAdjust;   // remember when we last throttled to avoid overthrottling.
} SESSION, *PSESSION;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\buffer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFFER.H

Abstract:

	HEADER for buffers.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original
   2/17/98  aarono  changed memdesc to be len,ptr from ptr,len to align with sendex data.

--*/

#ifndef _BUFFER_H_
#define _BUFFER_H_
//
// Buffer is a descriptor for a chunk of data.
//

#include "bilink.h"

typedef struct _BUFFER {
	union {
		struct _BUFFER *pNext;		// Next buffer in chain
		BILINK BuffList;
	};	
	PUCHAR 		   pData;		// Data area of buffer
	UINT   		   len;         // length of data area
	DWORD          dwFlags;     // info about the data area
	PUCHAR         pCmdData;    // pointer past header to command data - used in receive path.
	DWORD          sequence;    // absolute sequence number
} BUFFER, *PBUFFER;

#define BFLAG_PROTOCOL		0x00000001	/* This buffer is for protocol information */
#define BFLAG_DOUBLE    	0x00000002	/* This buffer is a double buffer buffer   */
#define BFLAG_PROTHEADER	0x00000004  /* Room for the protocol header is at the head of the packet */
#define BFLAG_FRAME         0x00000008  /* From Frame allocator */

// PROTHEADER flag will only occur with packets that have the DOUBLE flag set 
// and only when the provider does not support multi-buffer sends and the 
// entire message and protocol header will fit in one media frame. - actually pretty often.

typedef struct _MEMDESC {
	UINT 	len;
	PUCHAR 	pData;
} MEMDESC, *PMEMDESC;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\bufmgr.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    BUFMGR.H

Abstract:

	Buffer Descriptor and Memory Manager for ARPD

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/13/97  aarono  Original

--*/

#ifndef _BUFMGR_H_
#define _BUFMGR_H_

#include "buffer.h"
#include "bufpool.h"

typedef struct _DoubleBuffer{
	union {
		BUFFER Buffer;
		struct {
			struct _DoubleBuffer *pNext;
			PVOID PAD;
			PCHAR pData;
			UINT  len;		    // length of data area used
			DWORD dwFlags;      // Packet flags, ownership and type of packet.
		};	
	};
	UINT  totlen;       // total length of data area
	UINT  tLastUsed;	// last tick count this was used
	CHAR  data[1];		// variable length data
} DOUBLEBUFFER, *PDOUBLEBUFFER;

	
VOID InitBufferManager(VOID);
VOID FiniBuffermanager(VOID);

PBUFFER GetDoubleBufferAndCopy(PMEMDESC, UINT);
VOID    FreeDoubleBuffer(PBUFFER);
PBUFFER BuildBufferChain(PMEMDESC, UINT);

VOID    FreeBufferChainAndMemory(PBUFFER); //works for either type
UINT    BufferChainTotalSize(PBUFFER);

#define GBF_ALLOC_MEM 0x00000001

// Don't pool more than 64K per channel.
#define MAX_CHANNEL_DATA 	65536
// Don't hold more than 3 free buffers per channel.
#define MAX_CHANNEL_BUFFERS 3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\bufpool.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFPOOL.H

Abstract:

	Header for buffer pool manager

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original

--*/

#ifndef _BUFPOOL_H_
#define _BUFPOOL_H_

#include <windows.h>
#include "buffer.h"

#define BUFFER_POOL_SIZE 16

//
// Buffer pools are allocated but only freed when the object is destroyed.
//

typedef struct _BUFFER_POOL {
	struct _BUFFER_POOL *pNext;
	BUFFER              Buffers[BUFFER_POOL_SIZE];
} BUFFER_POOL, *PBUFFER_POOL;


PBUFFER GetBuffer(VOID);
VOID FreeBuffer(PBUFFER);

VOID InitBufferPool(VOID);
VOID FiniBufferPool(VOID);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\command.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	COMMAND.H

Abstract:


Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   3/14/97 aarono  Original

--*/

#ifndef _COMMAND_H_

#define _COMMAND_H_

#define REQUEST_PARAMS PPROTOCOL pProtocol, DPID idFrom, DPID idTo, PCMDINFO pCmdInfo, PBUFFER pSrcBuffer
#define MAX_COMMAND 0x06

typedef UINT (*COMMAND_HANDLER)(REQUEST_PARAMS);

UINT AssertMe(REQUEST_PARAMS);
UINT Ping(REQUEST_PARAMS);
UINT PingResp(REQUEST_PARAMS);
UINT GetTime(REQUEST_PARAMS);
UINT GetTimeResp(REQUEST_PARAMS);
UINT SetTime(REQUEST_PARAMS);
UINT SetTimeResp(REQUEST_PARAMS);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\bufpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFPOOL.C

Abstract:

	Manages a pool of BUFFER descriptors (BUFFERS)
	16 at a time are allocated.  They are not freed until
	shutdown.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/27/97  aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "bufpool.h"
#include "macros.h"
#include "mydebug.h"

CRITICAL_SECTION BufferPoolLock;
PBUFFER_POOL pBufferPoolList;
PBUFFER      pBufferFreeList;

VOID InitBufferPool(VOID)
{
	pBufferPoolList=NULL;
	pBufferFreeList=NULL;
	InitializeCriticalSection(&BufferPoolLock);
}

VOID FiniBufferPool(VOID)
{
	PBUFFER_POOL pNextBufPool;
	while(pBufferPoolList){
		pNextBufPool=pBufferPoolList->pNext;
		My_GlobalFree(pBufferPoolList);
		pBufferPoolList=pNextBufPool;
	}
	DeleteCriticalSection(&BufferPoolLock);
}

PBUFFER GetBuffer(VOID)
{
	PBUFFER 	 pBuffer=NULL;
	PBUFFER_POOL pBufferPool;
	UINT i;

Top:
	if(pBufferPoolList){
	
		Lock(&BufferPoolLock);
		
		if(pBufferFreeList){
			pBuffer=pBufferFreeList;
			pBufferFreeList=pBuffer->pNext;
		} 
		
		Unlock(&BufferPoolLock);
		
		if(pBuffer){
			return pBuffer;
		}	
	} 
	
	pBufferPool=(PBUFFER_POOL)My_GlobalAlloc(GMEM_FIXED, sizeof(BUFFER_POOL));
	
	if(pBufferPool){

		// link the buffers into a chain.
		for(i=0;i<BUFFER_POOL_SIZE-1;i++){
			pBufferPool->Buffers[i].pNext=&pBufferPool->Buffers[i+1];
		}
		
		Lock(&BufferPoolLock);

		// link the pool on the pool list.
		pBufferPool->pNext=pBufferPoolList;
		pBufferPoolList=pBufferPool;

		// link the buffers on the buffer list.
		pBufferPool->Buffers[BUFFER_POOL_SIZE-1].pNext=pBufferFreeList;
		pBufferFreeList=&pBufferPool->Buffers[0];
		
		Unlock(&BufferPoolLock);
		
		goto Top;
		
	} else {
		ASSERT(0); //TRACE ALL PATHS
	
		return NULL;
		
	}
}

VOID FreeBuffer(PBUFFER pBuffer)
{
	Lock(&BufferPoolLock);
	pBuffer->pNext=pBufferFreeList;
	pBufferFreeList=pBuffer;
	Unlock(&BufferPoolLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\bufmgr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    BUFMGR.C

Abstract:

	Buffer Descriptor and Memory Manager

Author:

	Aaron Ogus (aarono)

Environment:
	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/13/97  aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "arpdint.h"
#include "bufmgr.h"
#include "mydebug.h"
#include "macros.h"
		
CRITICAL_SECTION DoubleBufferListLock;
PDOUBLEBUFFER	 pDoubleBufferList;
UINT   			 nDoubleBuffers;
UINT			 cbDoubleBuffers;

VOID InitBufferManager(VOID)
{
	pDoubleBufferList=NULL;
	nDoubleBuffers=0;
	cbDoubleBuffers=0;
	InitializeCriticalSection(&DoubleBufferListLock);
}

VOID FiniBufferManager(VOID)
{
	PDOUBLEBUFFER pDoubleBuffer = pDoubleBufferList;
	
	while(pDoubleBuffer){
		pDoubleBufferList=pDoubleBuffer->pNext;
		My_GlobalFree(pDoubleBuffer);
		pDoubleBuffer=pDoubleBufferList;
	}

	DeleteCriticalSection(&DoubleBufferListLock);
}

UINT MemDescTotalSize(PMEMDESC pMemDesc, UINT nDesc)
{
	UINT i;
	UINT cbTotalSize=0;

	for(i=0 ; i < nDesc ; i++){
		cbTotalSize+=pMemDesc->len;
		pMemDesc++;
	}
	
	return cbTotalSize;
}

// Actually get the memory block or allocate it.
PDOUBLEBUFFER GetDoubleBuffer(UINT TotalMessageSize)
{
	PDOUBLEBUFFER pDoubleBuffer=NULL;
	// First Check the FreeList for a buffer of the appropriate size.

	if(nDoubleBuffers && (cbDoubleBuffers >= TotalMessageSize)){
	
		PDOUBLEBUFFER pPrevBuffer, pCurrentBuffer;
		UINT nAllowedWaste=TotalMessageSize >> 2;
		
		Lock(&DoubleBufferListLock);

			// Search for best fit packet.  Cannot be more than 25% larger
			// than the actual required size.
			pPrevBuffer = (PDOUBLEBUFFER)&pDoubleBufferList;
			pCurrentBuffer = pPrevBuffer->pNext;
			
			while(pCurrentBuffer){
			
				if(pCurrentBuffer->totlen >= TotalMessageSize){
				
					if(pCurrentBuffer->totlen-TotalMessageSize < nAllowedWaste){
						// We have a winner, relink list over this buffer.
						pPrevBuffer->pNext = pCurrentBuffer->pNext;
						pDoubleBuffer = pCurrentBuffer;
						nDoubleBuffers--;
						cbDoubleBuffers-=pCurrentBuffer->totlen;
						break;
					}
					
				}
				pPrevBuffer = pCurrentBuffer;
				pCurrentBuffer = pCurrentBuffer->pNext; 
			}
		
		Unlock(&DoubleBufferListLock);
	}

	if(!pDoubleBuffer){
		// No Buffer Found on the FreeList, so allocate one.
		pDoubleBuffer=(PDOUBLEBUFFER)My_GlobalAlloc(GMEM_FIXED,TotalMessageSize+sizeof(DOUBLEBUFFER));
		
 		if(!pDoubleBuffer){
 			// couldn't allocate... out of memory.
 			DPF(0,"COULDN'T ALLOCATE DOUBLE BUFFER TO INDICATE RECEIVE, SIZE: %x\n",TotalMessageSize+sizeof(DOUBLEBUFFER));
 			ASSERT(0);
 			goto exit;
 		}
 		pDoubleBuffer->totlen = TotalMessageSize;
		pDoubleBuffer->dwFlags=BFLAG_DOUBLE; // double buffer buffer.
//	pDoubleBuffer->tLastUsed=GetTickCount(); only relevant when put back on list... throw this out??
	}
	
	pDoubleBuffer->pNext =  NULL;
	pDoubleBuffer->pData  = (PCHAR)&pDoubleBuffer->data;
	pDoubleBuffer->len	  = TotalMessageSize;
	
exit:
	return pDoubleBuffer;
}
/*++

	Double Buffer Management strategy.

	When the system needs to allocate buffers locally, it does it on a per
	channel basis.  A buffer of exactly the requested size is allocated and
	used to buffer the data.   When the buffer is done with, it is put on 
	the DoubleBufferList which caches the last few allocations.  Since
	most clients tend to use the same size packet over and over, this saves
	the time it takes to call GlobalAlloc and My_GlobalFree for every send.

	Aging out entries:  Every 15 seconds, a timer goes off and the system
	checks the age of each buffer on the DoubleBufferList.  Any entry 
	that has not been used in the last 15 seconds is actually freed.

	There is also a cap on the size of allocations allowed for the entire
	free list.  It never exceeds 64K.  If it does, oldest entries are 
	thrown out until the free list is less than 64K.

--*/

PBUFFER GetDoubleBufferAndCopy(PMEMDESC pMemDesc, UINT nDesc)
{
	
	UINT i;
	UINT TotalMessageSize;
	UINT WriteOffset;
	PDOUBLEBUFFER pDoubleBuffer=NULL;

	// Calculate the total size of the buffer
	TotalMessageSize=MemDescTotalSize(pMemDesc, nDesc);

	pDoubleBuffer=GetDoubleBuffer(TotalMessageSize);

	if(!pDoubleBuffer){
		goto exit;
	}

	// Scatter Gather Copy to Contiguous Local Buffer
	WriteOffset=0;
	
	for(i=0 ; i < nDesc ; i++){
		memcpy(&pDoubleBuffer->data[WriteOffset], pMemDesc->pData, pMemDesc->len);
		WriteOffset+=pMemDesc->len;
		pMemDesc++;
	}

exit:
	return (PBUFFER)pDoubleBuffer;
	
}

VOID FreeDoubleBuffer(PBUFFER pBuffer)
{
	PDOUBLEBUFFER pDoubleBuffer=(PDOUBLEBUFFER) pBuffer;
	PDOUBLEBUFFER pBufferWalker, pLargestBuffer;

	//
	// Put the local buffer on the free list.
	//
	
	pDoubleBuffer->tLastUsed = GetTickCount();
	
	Lock(&DoubleBufferListLock);

	pDoubleBuffer->pNext  = pDoubleBufferList;
	pDoubleBufferList 	  = pDoubleBuffer;
	cbDoubleBuffers      += pDoubleBuffer->totlen;
	nDoubleBuffers++;

	Unlock(&DoubleBufferListLock);


	//
	// If the free list is too large, trim it
	//

	while(cbDoubleBuffers > MAX_CHANNEL_DATA || nDoubleBuffers > MAX_CHANNEL_BUFFERS){

		Lock(&DoubleBufferListLock);

		if(cbDoubleBuffers > MAX_CHANNEL_DATA || nDoubleBuffers > MAX_CHANNEL_BUFFERS){

			//
			// Free the largest buffer.
			//

			pLargestBuffer=pDoubleBufferList;
			pBufferWalker=pLargestBuffer->pNext;

			// Find the largest buffer.
			while(pBufferWalker){
				if(pBufferWalker->totlen > pLargestBuffer->totlen){
					pLargestBuffer=pBufferWalker;
				}
				pBufferWalker=pBufferWalker->pNext;
			}

			//
			// Remove the largest buffer from the list
			//

			// Find previous element - sneaky, since ptr first in struct, 
			// take addr of list head.

			pBufferWalker=(PDOUBLEBUFFER)&pDoubleBufferList;
			while(pBufferWalker->pNext != pLargestBuffer){
				pBufferWalker=pBufferWalker->pNext;
			}

			// link over the largest buffer
			pBufferWalker->pNext=pLargestBuffer->pNext;

			// update object buffer information
			cbDoubleBuffers -= pLargestBuffer->totlen;
			nDoubleBuffers--;
			
			DPF(9,"Freeing Double Buffer Memory %x\n",pLargestBuffer->totlen);
			
			Unlock(&DoubleBufferListLock);

			My_GlobalFree(pLargestBuffer);

		}	else {
		
			Unlock(&DoubleBufferListLock);

		}
			
	}

	DPF(9,"Total Free Double Buffer Memory %x\n",cbDoubleBuffers);

}

PBUFFER BuildBufferChain(PMEMDESC pMemDesc, UINT nDesc)
{
	UINT i;
	PBUFFER pBuffer=NULL,pLastBuffer=NULL;

	ASSERT(nDesc);

	if(!nDesc){
		goto exit;
	}
	
	// walk backward through the array, allocating and linking
	// the buffers.

	i=nDesc;

	while(i){
		i--;
		
		// skip 0 length buffers 
		//if(pMemDesc[i].len){
			
			pBuffer=GetBuffer();
			
			if(!pBuffer){
				goto err_exit;
			}
			
			pBuffer->pNext   = pLastBuffer;
			pBuffer->pData   = pMemDesc[i].pData;
			pBuffer->len     = pMemDesc[i].len;
			pBuffer->dwFlags = 0;
			pLastBuffer      = pBuffer;
		//} 
	}


	// return the head of the chain to the caller

exit:
	return pBuffer;

err_exit: 
	// Couldn't allocate enough buffers, free the ones we did alloc
	// and then fail.
	while(pLastBuffer){
		pBuffer=pLastBuffer->pNext;
		FreeBuffer(pLastBuffer);
		pLastBuffer=pBuffer;
	}
	ASSERT(pBuffer==NULL);
	goto exit;
}


VOID FreeBufferChainAndMemory(PBUFFER pBuffer)
{
	PBUFFER pNext;
	while(pBuffer){
		pNext=pBuffer->pNext;
		if(pBuffer->dwFlags & BFLAG_DOUBLE){
			FreeDoubleBuffer(pBuffer);
		} else if(pBuffer->dwFlags & BFLAG_FRAME){	
			FreeFrameBuffer(pBuffer);
		} else {
			FreeBuffer(pBuffer);
		}	
		pBuffer=pNext;
	}	
}

UINT BufferChainTotalSize(PBUFFER pBuffer)
{

	UINT nTotalLen;
	
	ASSERT(pBuffer);
	
	if(!pBuffer){
		return 0;
	}
	
	nTotalLen=0;
	
	do{
		nTotalLen+=pBuffer->len;
		pBuffer=pBuffer->pNext;
	} while (pBuffer);

	return nTotalLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\framebuf.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    FRAMEBUF.CPP

Abstract:

	Manages Memory for Send/Receive Frames.
	ISSUE: when you have time do an intelligent implementation,
	for now this is just a frame cache.
	    - not likely now, DP4 is being put to bed AO 04/03/2001

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   6/6/98  aarono  More debug checks, shrink pool.

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "bufmgr.h"
#include "macros.h"

#define MAX_FRAMES_ON_LIST 16
#define MIN_FRAMES_ON_LIST 8

typedef struct _frame 
{
	BILINK Bilink;
	UINT len;
	UCHAR data[0];
} FRAME, *PFRAME;	

BILINK FrameList;
UINT   nFramesOnList=0;
UINT   TotalFrameMemory=0;
CRITICAL_SECTION FrameLock;

#ifdef DEBUG
void DebugChkFrameList()
{
	BILINK *pBilink;
	PFRAME  pFrameWalker;

	DWORD	count=0;
	DWORD	totalsize=0;
	DWORD   fBreak=FALSE;

	Lock(&FrameLock);

	pBilink=FrameList.next;
	while(pBilink != &FrameList){
		pFrameWalker=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		pBilink=pBilink->next;
		count++;
		totalsize+=pFrameWalker->len;
	}

	if(totalsize != TotalFrameMemory){
		DPF(0, "Total Frame Memory says %d but I count %d\n",TotalFrameMemory, totalsize);
		fBreak=TRUE;
	}

	if(count != nFramesOnList){
		DPF(0, "nFramesOnList %d but I count %d\n",nFramesOnList, count);
		fBreak=TRUE;
	}
	if(fBreak){
		DEBUG_BREAK();
	}
	
	Unlock(&FrameLock);
}
#else
#define DebugChkFrameList()
#endif

VOID InitFrameBuffers(VOID)
{
	InitBilink(&FrameList);
	InitializeCriticalSection(&FrameLock);
	nFramesOnList=0;
	TotalFrameMemory=0;
}

VOID FiniFrameBuffers(VOID)
{
	BILINK *pBilink;
	PFRAME  pFrame;
	
	Lock(&FrameLock);

	while(!EMPTY_BILINK(&FrameList)){
		pBilink=FrameList.next;
		pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		Delete(pBilink);
		My_GlobalFree(pFrame);
	}

	nFramesOnList=0;
	TotalFrameMemory=0;
	
	Unlock(&FrameLock);
	DeleteCriticalSection(&FrameLock);
}

VOID ReleaseFrameBufferMemory(PUCHAR pFrameData)
{
	PFRAME  pFrame;
	BILINK  FramesToFree;
	BILINK *pBilink;
	
	Lock(&FrameLock);

	DebugChkFrameList();

	InitBilink(&FramesToFree);

	pFrame=CONTAINING_RECORD(pFrameData,FRAME,data);

	InsertAfter(&pFrame->Bilink, &FrameList);
	nFramesOnList++;
	TotalFrameMemory+=pFrame->len;

	if(nFramesOnList > MAX_FRAMES_ON_LIST){
		while(nFramesOnList > MIN_FRAMES_ON_LIST){
			pBilink=FrameList.next;
			pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
			nFramesOnList--;
			TotalFrameMemory-=pFrame->len;
			Delete(pBilink);
			DebugChkFrameList();
			InsertAfter(pBilink, &FramesToFree);
		}
	}
	
	DebugChkFrameList();
	ASSERT(nFramesOnList);

	Unlock(&FrameLock);

	// Drop lock before freeing, to make more effecient.

	while(!EMPTY_BILINK(&FramesToFree)){
		pBilink=FramesToFree.next;
		pFrame=CONTAINING_RECORD(pBilink,FRAME,Bilink);
		Delete(pBilink);
		My_GlobalFree(pFrame);
	}

	DebugChkFrameList();

}

PBUFFER GetFrameBuffer(UINT FrameLen)
{
	PBUFFER pBuffer;
	PFRAME  pFrame;
	MEMDESC memdesc;

	BILINK  *pBilinkWalker;
	PFRAME  pFrameBest=NULL, pFrameWalker;
	UINT    difference=FrameLen;

	DPF(9,"==>GetFrameBuffer Len %d\n",FrameLen);

	Lock(&FrameLock);
	
	if(!EMPTY_BILINK(&FrameList)){
		ASSERT(nFramesOnList);

		pBilinkWalker=FrameList.next;
		
		while(pBilinkWalker != &FrameList){
			pFrameWalker=CONTAINING_RECORD(pBilinkWalker, FRAME, Bilink);
			if(pFrameWalker->len >= FrameLen){
				if(FrameLen-pFrameWalker->len < difference){
					difference=FrameLen-pFrameWalker->len;
					pFrameBest=pFrameWalker;
					if(!difference){
						break;
					}
				}
			}
			pBilinkWalker=pBilinkWalker->next;
		}

		if(!pFrameBest){
			goto alloc_new_frame;
		} else {
			pFrame=pFrameBest;
		}

		DebugChkFrameList();

		Delete(&pFrame->Bilink);
		nFramesOnList--;
		TotalFrameMemory-=pFrame->len;

		DebugChkFrameList();

		Unlock(&FrameLock);
		
	} else {
	
alloc_new_frame:	
		Unlock(&FrameLock);
		pFrame=(PFRAME)My_GlobalAlloc(GMEM_FIXED,FrameLen+sizeof(FRAME));
		if(!pFrame){
			return NULL;
		}
		pFrame->len=FrameLen;
	}

	memdesc.pData=&pFrame->data[0];
	memdesc.len=pFrame->len;
	
	pBuffer=BuildBufferChain((&memdesc),1);

	if(!pBuffer){
		ReleaseFrameBufferMemory(pFrame->data);
		DPF(9,"<==GetFrameBuffer FAILED returning %x\n",pBuffer);
	} else {
		pBuffer->dwFlags |= BFLAG_FRAME;
		DPF(9,"<==GetFrameBuffer %x, len %d\n",pBuffer, pFrame->len);
	}	

	DebugChkFrameList();
	
	return pBuffer;
}

// Release the buffer, put the memory back on the frame buffer list.
VOID FreeFrameBuffer(PBUFFER pBuffer)
{
	ASSERT(pBuffer->dwFlags & BFLAG_FRAME);
	ReleaseFrameBufferMemory(pBuffer->pData);
	FreeBuffer(pBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPlayProtocol"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\macros.h ===
#define Lock(_a) EnterCriticalSection(_a)
#define Unlock(_a) LeaveCriticalSection(_a)
#define CreateSem(_Initial)	CreateSemaphoreA(NULL,(_Initial),-1,NULL) 
#define DestroySem(_hSem)   CloseHandle((_hSem))
#define Wait(_A) 			WaitForSingleObject((_A),0xFFFFFFFF)
#define Signal(_A) 			ReleaseSemaphore((_A), 1, NULL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\handles.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    HANDLES.H

Abstract:

	Handle Table

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   2/16/98 aarono  Original

--*/

#ifndef _MYHANDLE_H_
#define _MYHANDLE_H_

#define LIST_END 0xFFFFFFFF

#define MYHANDLE_DEFAULT_GROWSIZE 16

#define N_UNIQUE_BITS 16
#define UNIQUE_ADD (1<<(32-N_UNIQUE_BITS))
#define CONTEXT_INDEX_MASK (UNIQUE_ADD-1)
#define CONTEXT_UNIQUE_MASK (0xFFFFFFFF-CONTEXT_INDEX_MASK)

typedef struct _myhandle {
	LPVOID lpv;
	union {
		UINT nUnique;
		UINT iNext;
	};	
} MYHANDLE, *LPMYHANDLE;

typedef struct _myhandletable {
	UINT	nUnique;
	UINT    nTableSize;
	UINT    nTableGrowSize;
	UINT    iNext;
	MYHANDLE Table[0];
} MYHANDLETABLE, *LPMYHANDLETABLE;

typedef volatile LPMYHANDLETABLE VOLLPMYHANDLETABLE, *LPVOLLPMYHANDLETABLE;

extern VOLLPMYHANDLETABLE InitHandleTable(UINT nSize, CRITICAL_SECTION *pcs, UINT nGrowSize);
extern VOID FiniHandleTable(LPMYHANDLETABLE lpTable, CRITICAL_SECTION *pcs);

extern DWORD AllocHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, LPVOID lpv);
extern LPVOID ReadHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle);
extern HRESULT FreeHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\mydebug.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mydebug.h
 ***************************************************************************/
#ifndef __MYDEBUG_H__
#define __MYDEBUG_H__


#ifdef DEBUG
HGLOBAL
My_GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    );

HGLOBAL
My_GlobalFree(
    HGLOBAL hMem
    );
#else 
#define My_GlobalAlloc(_a,_b) GlobalAlloc(_a,_b)
#define My_GlobalFree(_a) GlobalFree(_a)
#endif


#define SIGNATURE(a,b,c,d) (UINT)(a+(b<<8)+(c<<16)+(d<<24))

#ifdef DEBUG
	#define SIGN 1
	#define ASSERT_NACKMask(_a) \
	if(pSend->OpenWindow && ((_a)->NACKMask & (0xFFFFFFFF-((1<<(((_a)->OpenWindow)))-1)) ) ){ \
		DPF(0,"pSend %x OpenWindow %d NACKMask %x",pSend,pSend->OpenWindow, pSend->NACKMask);\
		DEBUG_BREAK(); \
	} else if (!(_a)->OpenWindow && (_a)->NACKMask){ \
		DPF(0,"pSend %x OpenWindow %d NACKMask %x",pSend,pSend->OpenWindow, pSend->NACKMask);\
		DEBUG_BREAK(); \
	} 
#else
	#define ASSERT_NACKMask(_a)
#endif

#ifdef SIGN
	#define SET_SIGN(a,b) ((a)->Signature=(b))
	#define UNSIGN(a) ((a)|=0x20202020);
//	#define ASSERT_SIGN(a,b) ASSERT((((UINT)(a)->Signature))==((UINT)(b)))
	#define ASSERT_SIGN(a,b) if(!((((UINT)(a)->Signature))==((UINT)(b))))DEBUG_BREAK();


#else
	#define UNSIGN(a)
	#define SET_SIGN(a,b)
	#define ASSERT_SIGN(a,b)
#endif

#ifdef DEBUG
	#if !defined(ASSERT)
		#define ASSERT DDASSERT
	#endif
#endif

#endif /* __MYDEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\mydebug.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mydebug.c
 *  Content:	debugging printf - stolen from direct draw.
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	  Reason
 *   ====	==	  ======
 *         aarono splurp.
 *  6/6/98 aarono Debug support for link statistics
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "newdpf.h"
#include "mydebug.h"
#include "bilink.h"
#include <stdarg.h>

#ifdef DEBUG

typedef struct _MEM_BLOCK {
	union {
		BILINK Bilink;
		struct _FB {
			struct _MEM_BLOCK *pNext;
			struct _MEM_BLOCK *pPrev;
		} FB;
	};	
	UINT len;
	UINT tmAlloc;
	CHAR data[4];
} MEM_BLOCK, *PMEM_BLOCK;

LONG TotalMem = 0;

struct _MEMLIST {
	union{
		BILINK Bilink;
		struct _FB FB;
	};
} MemList={(BILINK *)&MemList,(BILINK *)&MemList};

UINT nInit=0xFFFFFFFF;
CRITICAL_SECTION MEM_CS;

VOID My_GlobalAllocInit()
{
	if(!InterlockedIncrement(&nInit)){
		InitializeCriticalSection(&MEM_CS);
	}
}

VOID My_GlobalAllocDeInit()
{
	if(InterlockedDecrement(&nInit)&0x80000000){
		DeleteCriticalSection(&MEM_CS);
	}
}

HGLOBAL
My_GlobalAlloc(
    UINT uFlags,
    DWORD dwBytes
    )
{
	PMEM_BLOCK pMem;

	UINT lTotalMem;

	pMem=(PMEM_BLOCK)GlobalAlloc(uFlags,dwBytes+sizeof(MEM_BLOCK)-4);
	pMem->len=dwBytes;
	pMem->tmAlloc=GetTickCount();
	
	EnterCriticalSection(&MEM_CS);
	InsertAfter(&pMem->Bilink, &MemList.Bilink);
	TotalMem+=dwBytes;
	lTotalMem=TotalMem;
	LeaveCriticalSection(&MEM_CS);

	DPF(9,"GlobalAlloc: Allocated %d TotalMem %d\n",dwBytes, lTotalMem);
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER2=lTotalMem;
		DbgWriteStats(&InWS);
	}

	return((HGLOBAL)&pMem->data[0]);
}

HGLOBAL
My_GlobalFree(
    HGLOBAL hMem
    )
{
	PUCHAR pData=(PUCHAR)(hMem);
	PMEM_BLOCK pMem;
	UINT lTotalMem;
	UINT dwBytes;

	pMem=CONTAINING_RECORD(pData, MEM_BLOCK, data);
	EnterCriticalSection(&MEM_CS);
	Delete(&pMem->Bilink);
	TotalMem-=pMem->len;
	dwBytes=pMem->len;
	lTotalMem=TotalMem;
	LeaveCriticalSection(&MEM_CS);
	DPF(9,"GlobalFree: Freed %d TotalMem %d\n",dwBytes,lTotalMem);
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER2=lTotalMem;
		DbgWriteStats(&InWS);
	}
	return GlobalFree(pMem);
}

#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\handles.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    HANDLES.C

Abstract:

	Handle Manager

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   2/16/98 aarono  Original
   6/6/98  aarono  debug support, use My_GlobalAlloc
   7/23/00 aarono  B#40279: fix consistency in InitHandle table, implicit assumption was nSize==GrowSize


--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "handles.h"

VOLLPMYHANDLETABLE InitHandleTable(UINT nSize, CRITICAL_SECTION *pcs, UINT nUserGrowSize)
{
	LPMYHANDLETABLE lpTable;
	UINT nGrowSize;
	UINT i;

	if(nUserGrowSize){
		nGrowSize=nUserGrowSize;
	} else {
		nGrowSize=MYHANDLE_DEFAULT_GROWSIZE;
	}

	lpTable=(LPMYHANDLETABLE)My_GlobalAlloc(GPTR, sizeof(MYHANDLETABLE)+(sizeof(MYHANDLE)*nSize));

	if(lpTable){
		if(pcs){
			InitializeCriticalSection(pcs);
		}
	
		lpTable->nUnique=UNIQUE_ADD;
		lpTable->nTableSize=nSize;
		lpTable->nTableGrowSize=nGrowSize;

		lpTable->iNext=0;
		for(i=0;i < nSize-1; i++){
			lpTable->Table[i].iNext=i+1;
		}
		lpTable->Table[nSize-1].iNext = LIST_END;
	}

	return lpTable;
}

VOID FiniHandleTable(LPMYHANDLETABLE lpTable, CRITICAL_SECTION *pcs)
{
	My_GlobalFree(lpTable);
	if(pcs){
		DeleteCriticalSection(pcs);
	}	
}

DWORD AllocHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, LPVOID lpv)
{
	#define lpTable (*lplpTable)

	UINT i;
	LPMYHANDLETABLE lpNewTable;

	if(pcs){
		EnterCriticalSection(pcs);
	}

	if(lpTable->iNext==LIST_END){
		// grow the table.
		lpNewTable=(LPMYHANDLETABLE)My_GlobalAlloc(GPTR, sizeof(MYHANDLETABLE)+
					((lpTable->nTableGrowSize+lpTable->nTableSize)*sizeof(MYHANDLE)));

		if(!lpNewTable){
			return 0;
		}
		memcpy(lpNewTable, lpTable, (lpTable->nTableSize*sizeof(MYHANDLE))+sizeof(MYHANDLETABLE));

		lpNewTable->iNext=lpNewTable->nTableSize;
		lpNewTable->nTableSize=lpNewTable->nTableSize+lpNewTable->nTableGrowSize;

		for(i=lpNewTable->iNext ; i < lpNewTable->nTableSize-1 ; i++){
			lpNewTable->Table[i].iNext=i+1;
		}
		lpNewTable->Table[lpNewTable->nTableSize-1].iNext = LIST_END;

		My_GlobalFree(lpTable);
		
		*lplpTable=lpNewTable;
	}

	i=lpTable->iNext;
	lpTable->iNext=lpTable->Table[i].iNext;

	// increment uniqueness, never zero.
	do {
		lpTable->nUnique += UNIQUE_ADD;
	} while (!lpTable->nUnique);

	lpTable->Table[i].nUnique=lpTable->nUnique;
	lpTable->Table[i].lpv=lpv;

	if(pcs) {
		LeaveCriticalSection(pcs);
	}

	ASSERT((i+lpTable->Table[i].nUnique & CONTEXT_INDEX_MASK) == i);

	return i+lpTable->Table[i].nUnique;	

	#undef lpTable
}

LPVOID ReadHandleTableEntry( LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle)
{
	#define lpTable (*lplpTable)

	UINT i;
	UINT nUnique;
	LPVOID lpv;

	if(handle){

		if(pcs){
			EnterCriticalSection(pcs);
		}	

		i = handle & CONTEXT_INDEX_MASK;
		nUnique = handle - i;

		if(i < lpTable->nTableSize && nUnique == lpTable->Table[i].nUnique){
			lpv = lpTable->Table[i].lpv;
		} else {
			lpv = NULL;
		}
		
		if(pcs){
			LeaveCriticalSection(pcs);
		}	
		
	} else {
	
		lpv=NULL;

	}

	return lpv;

	#undef lpTable
}

HRESULT FreeHandleTableEntry(LPVOLLPMYHANDLETABLE lplpTable, CRITICAL_SECTION *pcs, UINT handle)
{
	#define lpTable (*lplpTable)

	HRESULT hr=DP_OK;
	UINT i;
	UINT nUnique;

	if(handle){

		if(pcs){
			EnterCriticalSection(pcs);
		}	

		i = handle & CONTEXT_INDEX_MASK;
		nUnique = handle - i;

		if(i < lpTable->nTableSize && nUnique == lpTable->Table[i].nUnique){
			lpTable->Table[i].iNext = lpTable->iNext;
			lpTable->iNext=i;
		} else {
			hr = DPERR_GENERIC;
			DPF(0,"FreeHandleTableEntry, ERROR, TRIED TO FREE INVALID HANDLE %x",handle);
			ASSERT(0);
		}

		if(pcs){
			LeaveCriticalSection(pcs);
		}	

	} else {
		hr=DPERR_GENERIC;
	}
	return hr;

	#undef lpTable
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\mytimer.h ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    MYTIMER.H

Abstract:

	Include For
	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

typedef void CALLBACK MYTIMERCALLBACK (UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2);

typedef enum _TimerState {
	NotInUse,
	WaitingForTimeout,
	QueuedForThread,
	InCallBack,
	End
} eTimerState;

typedef struct _MyTimer {
	BILINK	Bilink;
	eTimerState TimerState;
	DWORD	TimeOut;
	DWORD_PTR Context;
	MYTIMERCALLBACK *CallBack;
	DWORD   Unique;
} MYTIMER, *PMYTIMER;

DWORD_PTR SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, DWORD_PTR UserContext, PUINT pUnique);
HRESULT InitTimerWorkaround();
VOID FiniTimerWorkaround();
HRESULT CancelMyTimer(DWORD_PTR pTimer, DWORD Unique);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\protocol.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Protocol.c

Abstract:

	Another Reliable Protocol (on DirectPlay)

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
  05/11/97 aarono  convert from C++ COM object to 'C' library
   2/03/98 aarono  fixed ProtocolGetCaps for RAW
   2/18/98 aarono  changed InitProtocol to work later in connect process
                   added new API handlers SendEx, GetMessageQueue, stub Cancel
   2/18/98 aarono  added Cancel support
   2/19/98 aarono  don't hook Shutdown anymore, dplay calls us
   				   explicitly on DP_OPEN (InitProtocol) DP_CLOSE (FiniProtocol)
   2/20/98 aarono  B#18827 not pulling cancelled sends from Q properly
   3/5/98  aarono  B#18962 allow non-reliable enumsessions reply when using protocol
		   this avoids a bug where a remote on an invalid IPX net enums us
		   and we get bogged down with RIPing in the response path.  Actually hangs
		   the machine and sometimes crashes IPX.
   6/6/98  aarono  Turn on throttling and windowing
   10/8/99 aarono  Improve shutdown handling, avoid 1min hang with pending sends.

Notes:
	All direct calls from DPLAY to the PROTOCOL occur in this file.

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "handles.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

/*
	Protocol Object Life:
	=====================

	The protocol object is allocated on the DPLAY interface immediately after
	the call to SPInit. The protocol block is allocated and tacked onto the
	DPLAY interface.  If the object is not allocated, the protocol pointer
	will be NULL.

	When the SP shutdown handler is called, the protocol object is released,
	first making sure that all other structures off of the protocol have
	been freed and all memory pools have been freed.

	SESSION Life:
	=============
	Sessions are the structures that support the connection of a pair of
	PLAYERS.  For each target playerid there is a SESSION structure.
	SESSIONS are accessed by converting playerids into indices into a
	session array, valid sessions are filled in, invalid or not yet seen
	ones are NULL.  A session is allocated for every call to the SP
	CreatePlayer routine.  When a DeletePlayer is received, the session
	is freed.  There are races to create players and delete players so
	the session state is tracked.  If the session is not in the OPEN
	state, mesages for the session are ABORTED/IGNORED(?).  When the
	player is being removed, there may be stragling receives, these
	are rejected.  Any packet received for a non-existent session is
	dropped.  When a session is being closed, all pending sends are
	first completed.

	SEND Life:
	==========

		STATISTICS Life:
		================

	RECEIVE Life:
	=============


	How we hook in:
	===============

	Receive:
	--------
	HandlePacket in the ISP table has been replaced by the protocol's
	ProtocolHandlePacket routine.  Each call to HandlePacket comes along
	with a pISP, from which we derive the pProtocol.  If no pProtocol exits
	on the object, then we just call the old HandlePacket routine, otherwise
	we examine the packet and do our thing depending on what type of message
	it is and/or negotiated session parameters.

	Send/CreatePlayer/DeletePlayer/Shutdown:
	----------------------------------------
	If we install:
	We replace the interface pointers to these SP callbacks with our own and
	remember the existing ones.  When we are called we do our processing and
	then call the handler in the SP.  In the case of Send, we may not even
	call because we need to packetize the message.

	We also replace the packet size information in the SPData structure so that
	directplay's packetize and send code won't try to break up messages before
	we get them.  System messages that we don't handle hopefully don't exceed
	the actual maximum frame size, else they will fail on a non-reliable
	transport.
	
*/

#ifdef DEBUG
extern VOID My_GlobalAllocInit();
extern VOID My_GlobalAllocDeInit();
#endif

//
// Global pools should only be inited once, this counts opens.
// No lock req'd since calls to spinit serialized in DirectPlay itself.
//
UINT nInitCount = 0;

/*=============================================================================

	InitProtocol - initialize the protocol block and hook into the send path.

    Description:

    	After each SP is initialized (in SPInit) this routine is called to
    	hook the SP callbacks for the protocol.  Also the protocol information
    	for this instance of the protocol is allocated and initialized.

    Parameters:

		LPSPINITDATA pInitData - initialization block that was passed to the
			 					 SP.  We use it to hook in.

    Return Values:

		DP_OK         - successfully hooked in.
		                pProtocol on DIRECTPLAY object points to protocol obj.
		DPERR_GENERIC - didn't hook in.  Also pProtocol in the DIRECTPLAY
		                object will be NULL.

-----------------------------------------------------------------------------*/

HRESULT WINAPI InitProtocol(DPLAYI_DPLAY *lpDPlay)
{
	PPROTOCOL    pProtocol;
	HRESULT      hr;

	#define TABLE_INIT_SIZE 16
	#define TABLE_GROW_SIZE 16

	#ifdef DEBUG
	My_GlobalAllocInit();
	#endif

	// Allocate the protocol block;
	pProtocol=My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,sizeof(PROTOCOL));

	if(!pProtocol){
		hr=DPERR_NOMEMORY;
		goto exit;
	}

	//
	// Initialize protocol variables.
	//

	pProtocol->m_lpDPlay=lpDPlay;

	pProtocol->m_lpISP=lpDPlay->pISP;
	
	pProtocol->m_dwSPHeaderSize=lpDPlay->dwSPHeaderSize;
	
	pProtocol->m_nSendThreads=0;						// we support any number of send threads!
	pProtocol->m_eState=Initializing;                   // we are initing
	
	InitializeCriticalSection(&pProtocol->m_ObjLock);
	InitializeCriticalSection(&pProtocol->m_SPLock);

	// Session lookup by ID list.
	InitializeCriticalSection(&pProtocol->m_SessionLock);
	pProtocol->m_SessionListSize=0;
	pProtocol->m_pSessions=NULL;

	// GLOBAL SENDQ
	InitializeCriticalSection(&pProtocol->m_SendQLock);
	InitBilink(&pProtocol->m_GSendQ);

	//
	// Get Multi-Media Timer Information.
    //
	
	if( timeGetDevCaps(&pProtocol->m_timecaps,sizeof(TIMECAPS)) != TIMERR_NOERROR ){
		// make em up
		ASSERT(0);
		pProtocol->m_timecaps.wPeriodMin=5;
		pProtocol->m_timecaps.wPeriodMax=10000000;
	}

	// Send Thread Triggers - waits for Sends, DataGram IDs or Reliable IDs.
	
	pProtocol->m_hSendEvent=CreateEventA(NULL, FALSE, FALSE, NULL);
	
	if(!pProtocol->m_hSendEvent){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_NOMEMORY;
		goto exit1;
	}


	// Various descriptor pools.
	// These can't fail.
	if(!nInitCount){
		InitializeCriticalSection(&g_SendTimeoutListLock);
		InitBilink(&g_BilinkSendTimeoutList);
		// only allocated once per process.
		InitSendDescs();
		InitSendStats();
		InitFrameBuffers();
		InitBufferManager();
		InitBufferPool();
	}

	InitRcvDescs(pProtocol);

	nInitCount++;

	//
	// Get the datagram frame size from the SP
	//

	{
	        DPCAPS    	     Caps;
		    DPSP_GETCAPSDATA GetCapsData;

			memset(&Caps,0,sizeof(DPCAPS));

			Caps.dwMaxBufferSize = 0;
			Caps.dwSize          = sizeof(DPCAPS);
			GetCapsData.dwFlags  = 0;
			GetCapsData.lpCaps   = &Caps;
			GetCapsData.idPlayer = 0;
			GetCapsData.lpISP    = lpDPlay->pISP;
			CALLSP(lpDPlay->pcbSPCallbacks->GetCaps, &GetCapsData);
			pProtocol->m_dwSPMaxFrame=GetCapsData.lpCaps->dwMaxBufferSize;

			if(pProtocol->m_dwSPMaxFrame > 1400){
				// Necessary since UDP reports huge capacity even though no receiver can
				// successfully receive a datagram of that size without throttle.
				pProtocol->m_dwSPMaxFrame = 1400;
			}

			GetCapsData.dwFlags = DPCAPS_GUARANTEED;
			
			hr=CALLSP(lpDPlay->pcbSPCallbacks->GetCaps, &GetCapsData);

			if(hr==DP_OK){
				pProtocol->m_dwSPMaxGuaranteed=GetCapsData.lpCaps->dwMaxBufferSize;
			}	
			if(!pProtocol->m_dwSPMaxGuaranteed){
				pProtocol->m_dwSPMaxGuaranteed=pProtocol->m_dwSPMaxFrame;
			}
	}

	Lock(&pProtocol->m_ObjLock);

	//
	// Spin up the send thread
	//
	pProtocol->m_nSendThreads++;
	
	// Need for serialization starts here...
	pProtocol->m_hSendThread[0]=CreateThread( NULL,
									      4000,
									      SendThread,
							              (LPVOID)pProtocol,
							              0,
							              &pProtocol->m_dwSendThreadId[0]);
	if(!pProtocol->m_hSendThread[0]){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_NOMEMORY;
		goto exit4;
	}


	pProtocol->lpHandleTable=InitHandleTable(TABLE_INIT_SIZE,&pProtocol->csHandleTable,TABLE_GROW_SIZE);

	if(!pProtocol->lpHandleTable){
		goto exit5;
	}

	pProtocol->m_eState=Running;

	Unlock(&pProtocol->m_ObjLock);
	hr=DP_OK;
	
exit:
	if(hr==DP_OK){
		lpDPlay->pProtocol=(LPPROTOCOL_PART)pProtocol;
	} else {
		lpDPlay->pProtocol=NULL;
	}
	return hr;

//exit6: if more init written, may need this.
//	FiniHandleTable(pProtocol->lpHandleTable, &pProtocol->csHandleTable);
	

exit5:
	pProtocol->m_eState=ShuttingDown;
	SetEvent(pProtocol->m_hSendEvent);
	Unlock(&pProtocol->m_ObjLock);
	
	while(pProtocol->m_nSendThreads){
		// wait for the send thread to shut off.
		Sleep(0);
	}
	CloseHandle(pProtocol->m_hSendThread[0]);
	
	Lock(&pProtocol->m_ObjLock);
	
exit4:
	Unlock(&pProtocol->m_ObjLock);

//exit3:
	FiniRcvDescs(pProtocol);

	nInitCount--;
	if(!nInitCount){
		DeleteCriticalSection(&g_SendTimeoutListLock);
		FiniBufferPool();
		FiniBufferManager();
		FiniFrameBuffers();
		FiniSendStats();
		FiniSendDescs();
	}	
	
//exit2:
	CloseHandle(pProtocol->m_hSendEvent);
exit1:	
	DeleteCriticalSection(&pProtocol->m_SPLock);
	DeleteCriticalSection(&pProtocol->m_ObjLock);
	DeleteCriticalSection(&pProtocol->m_SessionLock);
	DeleteCriticalSection(&pProtocol->m_SendQLock);
	My_GlobalFree(pProtocol);
	goto exit;

	#undef TABLE_INIT_SIZE
	#undef TABLE_GROW_SIZE

	
}

/*=============================================================================

	FiniProtocol -
	
    Description:

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

VOID WINAPI FiniProtocol(PPROTOCOL pProtocol)
{
	DWORD tmKill;
	//
	// Kill the send thread.
	//

	DPF(1,"==>ProtShutdown\n");

	Lock(&pProtocol->m_ObjLock);
	pProtocol->m_eState=ShuttingDown;
	SetEvent(pProtocol->m_hSendEvent);
	while(pProtocol->m_nSendThreads){
		// wait for the send thread to shut off.
		Unlock(&pProtocol->m_ObjLock);
		Sleep(0);
		Lock(&pProtocol->m_ObjLock);
	}
	Unlock(&pProtocol->m_ObjLock);
	
	CloseHandle(pProtocol->m_hSendThread[0]);

	DPF(1,"SHUTDOWN: Protocol Send Thread ShutDown, waiting for sessions\n");

	tmKill=timeGetTime()+60000;

	Lock(&pProtocol->m_SessionLock);
	while(pProtocol->m_nSessions && (((INT)(tmKill-timeGetTime())) > 0)){
		UINT SendRc;
		
		Unlock(&pProtocol->m_SessionLock);
		//NOTE: race.  when m_nSessions dereffed, there
		//        is a race for the protocol to be freed.
		Sleep(55);
		do {
			SendRc=SendHandler(pProtocol);
		} while (SendRc!=DPERR_NOMESSAGES);

		Lock(&pProtocol->m_SessionLock);
	}
	DPF(1,"SHUTDOWN: Sessions All Gone Freeing other objects.\n");
	
	//
	// Free the SESSION table
	//
	if(pProtocol->m_pSessions){
		My_GlobalFree(pProtocol->m_pSessions);
		pProtocol->m_pSessions=0;
	}	
	Unlock(&pProtocol->m_SessionLock);

	DeleteCriticalSection(&pProtocol->m_SendQLock);
	DeleteCriticalSection(&pProtocol->m_SessionLock);
	DeleteCriticalSection(&pProtocol->m_SPLock);
	DeleteCriticalSection(&pProtocol->m_ObjLock);

	CloseHandle(pProtocol->m_hSendEvent);

	FiniRcvDescs(pProtocol);
	
	nInitCount--;
	if(!nInitCount){
		// Last one out, turn off the lights...
		DeleteCriticalSection(&g_SendTimeoutListLock);
		FiniBufferPool();
		FiniBufferManager();
		FiniFrameBuffers();
		FiniSendStats();
		FiniSendDescs();
	}

	FiniHandleTable(pProtocol->lpHandleTable, &pProtocol->csHandleTable);
	
	My_GlobalFree(pProtocol);
	
	#ifdef DEBUG
		My_GlobalAllocDeInit();
	#endif
}


/*=============================================================================

	ProtocolCreatePlayer - Called by DPlay when SP needs to be notified of new
		                   player creation.

    Description:

		Creates a session for the id.  OPTIMIZATION: if local, don't need this?
		Also notifies the SP.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolCreatePlayer(LPDPSP_CREATEPLAYERDATA pCreatePlayerData)
{
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;


	lpDPlay=((DPLAYI_DPLAY_INT *)pCreatePlayerData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);
	pProtocol->m_dwIDKey=(DWORD)lpDPlay->lpsdDesc->dwReserved1;

	// Creates the session and gets one refcount.
	hr=CreateNewSession(pProtocol, pCreatePlayerData->idPlayer);

	if(hr==DP_OK){
		
		// Chain the call to the real provider.
		Lock(&pProtocol->m_SPLock);
		if(lpDPlay->pcbSPCallbacks->CreatePlayer){
			hr=CALLSP(lpDPlay->pcbSPCallbacks->CreatePlayer,pCreatePlayerData);
		}
		Unlock(&pProtocol->m_SPLock);

		if(hr!=DP_OK){
			PSESSION pSession;
			pSession=GetSession(pProtocol,pCreatePlayerData->idPlayer); //adds a ref
			if(pSession){
				DecSessionRef(pSession); // unGetSession
				DecSessionRef(pSession); // blow it away, noone could access yet.
			}	
		}

	}
	return hr;

}

/*=============================================================================

	ProtocolPreNotifyDeletePlayer

	Called to tell us a DELETEPLAYER message was enqueued for a particular
	player.  We need to drop the player NOW!

	We don't notify the SP, that will happen when we are called in
	ProtocolDeletePlayer later when the pending queue is processed.
	
    Description:

		Dereference the session for the player.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolPreNotifyDeletePlayer(LPDPLAYI_DPLAY this, DPID idPlayer)
{
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;

	pProtocol=(PPROTOCOL)this->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,idPlayer);

	DPF(9,"==>Protocol Prenotify Delete Player %x, pSession %x\n",idPlayer, pSession);

	if(pSession){

		pSession->hClosingEvent=0;
#if 0	
		//NOTE: if you even think about putting this back, also do it in ProtocolDeletePlayer
		hClosingEvent=pSession->hClosingEvent=CreateEventA(NULL,FALSE,FALSE,NULL);

		if(hClosingEvent){
			ResetEvent(hClosingEvent);
		}
#endif		

		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);

		switch(pSession->eState)
		{	
			case Open:
				TimeOutSession(pSession);
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				DecSessionRef(pSession); // balance Creation - may destroy session, and signal event
				break;
				
			case Closing:
			case Closed:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				break;
		}

#if 0
		if(hClosingEvent){
		//	Wait(hClosingEvent);
			CloseHandle(hClosingEvent);
		} else {
			DPF(0,"ProtocolPreNotifyDeletePlayer: couldn't get close event handle--not waiting...\n");
			ASSERT(0);			
		}
#endif		

	} else {
		DPF(0,"ProtocolPreNotifyDeletePlayer: couldn't find session for playerid %x\n",idPlayer);
		ASSERT(0);
	}

	DPF(9,"<==Protocol Prenotify DeletePlayer, hr=%x\n",hr);

	return hr;
}

/*=============================================================================

	ProtocolDeletePlayer - Called by DPlay when SP needs to be notified of
		                   player deletion.

    Description:

		Dereference the session for the player.  Then notifies the SP.

    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolDeletePlayer(LPDPSP_DELETEPLAYERDATA pDeletePlayerData)
{

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;
	//HANDLE       hClosingEvent;

	lpDPlay=((DPLAYI_DPLAY_INT *)pDeletePlayerData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,pDeletePlayerData->idPlayer);

	DPF(9,"==>Protocol Delete Player %x, pSession %x\n",pDeletePlayerData->idPlayer, pSession);

	if(pSession){

		pSession->hClosingEvent=0;
		
	#if 0	
		//NOTE: if you even think about putting this back, also do it in ProtocolPreNotifyDeletePlayer

		hClosingEvent=pSession->hClosingEvent=CreateEventA(NULL,FALSE,FALSE,NULL);

		if(hClosingEvent){
			ResetEvent(hClosingEvent);
		}
	#endif	

		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);
		
		switch(pSession->eState)
		{	
			case Open:
				TimeOutSession(pSession);
			case Closing:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				DecSessionRef(pSession); // balance Creation - may destroy session, and signal event
				break;
				
			case Closed:
				Unlock(&pSession->SessionLock);
				Unlock(&pProtocol->m_SendQLock);
				DecSessionRef(pSession); // balance GetSession
				break;
		}

	#if 0
		if(hClosingEvent){
		//	Wait(hClosingEvent);
			CloseHandle(hClosingEvent);
		} else {
			DPF(0,"ProtocolDeletePlayer: couldn't get close event handle--not waiting...\n");
			ASSERT(0);			
		}
	#endif	

	} else {
		DPF(0,"ProtocolDeletePlayer: couldn't find session for playerid %x, ok if ProtocolPreNotifyDeletPlayer ran.\n",pDeletePlayerData->idPlayer);
	}

	DPF(9,"Protocol, deleted player id %x\n",pDeletePlayerData->idPlayer);

	DPF(9,"<==ProtocolDeletePlayer, hr=%x\n",hr);

	return hr;
}

/*=============================================================================

	ProtocolSendEx -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolSendEx(LPDPSP_SENDEXDATA pSendData)
{
	DPSP_SENDDATA sd;
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        dwCommand;
	
	PUCHAR pBuffer;

	lpDPlay=((DPLAYI_DPLAY_INT *)pSendData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	ASSERT(lpDPlay->dwFlags & DPLAYI_PROTOCOL);

	if(pSendData->lpSendBuffers->len >= 8){
		pBuffer=pSendData->lpSendBuffers->pData;

		if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
		
			dwCommand=GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pBuffer);

			switch(dwCommand){
				case DPSP_MSG_PACKET2_DATA:
				case DPSP_MSG_PACKET2_ACK:
				case DPSP_MSG_PACKET:
					goto send_non_protocol_message;
					break;
		
				default:
					break;
			}
		}
		
	}


	// OPTIMIZATION:, make Send take the SENDEXDATA struct only.
	hr=Send(pProtocol,
			pSendData->idPlayerFrom,
			pSendData->idPlayerTo,
		 	pSendData->dwFlags,
			pSendData->lpSendBuffers,
		 	pSendData->cBuffers,
		 	pSendData->dwPriority,
		 	pSendData->dwTimeout,
		 	pSendData->lpDPContext,
		 	pSendData->lpdwSPMsgID,
		 	TRUE,
			NULL);  // forces us to be called back in InternalSendComplete, if Send is ASYNC.

	return hr;
	
send_non_protocol_message:

	ENTER_DPLAY();
	
	Lock(&pProtocol->m_SPLock);
	
	if(lpDPlay->pcbSPCallbacks->SendEx){
		hr=CALLSP(lpDPlay->pcbSPCallbacks->SendEx,pSendData);	
	} else {
		hr=ConvertSendExDataToSendData(lpDPlay, pSendData, &sd);
		if(hr==DP_OK){
			hr=CALLSP(lpDPlay->pcbSPCallbacks->Send, &sd);
			MsgFree(NULL, sd.lpMessage);
		}
	}
	
	Unlock(&pProtocol->m_SPLock);
	
	LEAVE_DPLAY();

	return hr;

}

/*=============================================================================

	ProtocolGetMessageQueue -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolGetMessageQueue(LPDPSP_GETMESSAGEQUEUEDATA pGetMessageQueueData)
{
	#define pData pGetMessageQueueData
	
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	HRESULT      hr=DP_OK;

	BILINK *pBilink;
	PSEND pSend;

	DWORD dwNumMsgs;
	DWORD dwNumBytes;

	lpDPlay=((DPLAYI_DPLAY_INT *)pData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	dwNumMsgs=0;
	dwNumBytes=0;

	if(!pData->idTo && !pData->idFrom){
		// just wants totals, I know that!
		EnterCriticalSection(&pProtocol->m_SendQLock);
		dwNumMsgs  = pProtocol->m_dwMessagesPending;
		dwNumBytes = pProtocol->m_dwBytesPending;
		LeaveCriticalSection(&pProtocol->m_SendQLock);

	} else if(pData->idTo){

		// Given idTo, walk that target's sendQ

		pSession=GetSysSession(pProtocol,pData->idTo);

		if(!pSession) {
			DPF(0,"GetMessageQueue: NO SESSION for idTo %x, returning INVALIDPLAYER\n",pData->idTo);
			hr=DPERR_INVALIDPLAYER;
			goto exit;
		}
		
		EnterCriticalSection(&pSession->SessionLock);

		pBilink=pSession->SendQ.next;

		while(pBilink != &pSession->SendQ){
			pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
			pBilink=pBilink->next;

			if((pSend->idTo==pData->idTo) && (!pData->idFrom || (pSend->idFrom == pData->idFrom))){
				dwNumBytes += pSend->MessageSize;
				dwNumMsgs += 1;
			}

		}

		LeaveCriticalSection(&pSession->SessionLock);
		
		DecSessionRef(pSession);

	} else {
		ASSERT(pData->idFrom);
		// Geting Queue for a from id, this is most costly
		EnterCriticalSection(&pProtocol->m_SendQLock);
		
		pBilink=pProtocol->m_GSendQ.next;

		while(pBilink != &pProtocol->m_GSendQ){
			pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
			pBilink=pBilink->next;

			if(pData->idFrom == pSend->idFrom){
				if(!pData->idTo || pData->idTo==pSend->idTo){
					dwNumBytes += pSend->MessageSize;
					dwNumMsgs += 1;
				}
			}
		}
			
		LeaveCriticalSection(&pProtocol->m_SendQLock);
	}

	if(pData->lpdwNumMsgs){
		*pData->lpdwNumMsgs=dwNumMsgs;
	}

	if(pData->lpdwNumBytes){
		*pData->lpdwNumBytes=dwNumBytes;
	}
	
exit:
	return hr;
	
	#undef pData
}


/*=============================================================================

	ProtocolCancel -
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolCancel(LPDPSP_CANCELDATA pCancelData)
{
	#define pData pCancelData
	
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        nCancelled=0;
	BILINK       *pBilink;
	BOOL         bCancel;
	UINT         i;
	UINT         j;
	DWORD        dwContext;
	PSEND        pSend;

	lpDPlay=((DPLAYI_DPLAY_INT *)pData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	EnterCriticalSection(&pProtocol->m_SendQLock);

	if(pData->dwFlags) {

		// either cancelpriority or cancel all, either way we
		// need to scan...
	
		pBilink=pProtocol->m_GSendQ.next;

		while(pBilink!=&pProtocol->m_GSendQ){

			pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
			pBilink=pBilink->next;

			bCancel=FALSE;

			Lock(&pSend->SendLock);

			switch(pSend->SendState){
			
				case Start:
				case WaitingForId:
					if(pData->dwFlags & DPCANCELSEND_PRIORITY) {
						// Cancel sends in priority range.
						if((pSend->Priority <= pData->dwMaxPriority) &&
						   (pSend->Priority >= pData->dwMinPriority)){
						   	bCancel=TRUE;
						}
					} else if(pData->dwFlags & DPCANCELSEND_ALL) {
						// Cancel all sends that can be.
						bCancel=TRUE;
					} else {
						ASSERT(0); // Invalid flags, should never happen
					}

					if(bCancel){
						if(pSend->SendState == WaitingForId){
							if(pSend->dwFlags & DPSEND_GUARANTEED){
								InterlockedDecrement(&pSend->pSession->nWaitingForMessageid);
							} else {
								InterlockedDecrement(&pSend->pSession->nWaitingForDGMessageid);
							}
						}
						nCancelled+=1;
						pSend->SendState=Cancelled;
					}
				break;	
				
				default:
					DPF(5,"Couldn't cancel send %x in State %d, already sending...\n",pSend,pSend->SendState);
			}

			Unlock(&pSend->SendLock);
		}	

	} else {
		// No flags, therefore we have a list to cancel so lookup
		// each send and cancel rather than scanning as above.

		// Run through the list, find the sends and lock em 1st, if we find one that doesn't lookup,
		// or one not in the start state, then we bail.  We then unlock them all.

		for(i=0;i<pData->cSPMsgID;i++){

			dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[i]));
			
			pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
			
			if(pSend){
				Lock(&pSend->SendLock);
				if(pSend->SendState != Start && pSend->SendState != WaitingForId){
					Unlock(&pSend->SendLock);
					hr=DPERR_CANCELFAILED;
					break;
				}
			} else {
				hr=DPERR_CANCELFAILED;
				break;
			}

		}

		if(hr==DPERR_CANCELFAILED) {
			// release all the locks.
			for(j=0;j<i;j++){
				dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[j]));
				pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
				ASSERT(pSend);
				Unlock(&pSend->SendLock);
			}
		} else {
			// mark the sends cancelled and release all the locks.
			for(i=0;i<pData->cSPMsgID;i++){
				dwContext=(DWORD)((DWORD_PTR)((*pData->lprglpvSPMsgID)[i]));
				pSend=(PSEND)ReadHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, dwContext);
				ASSERT(pSend);
				if(pSend->SendState == WaitingForId){
					if(pSend->dwFlags & DPSEND_GUARANTEED){
						InterlockedDecrement(&pSend->pSession->nWaitingForMessageid);
					} else {
						InterlockedDecrement(&pSend->pSession->nWaitingForDGMessageid);
					}
				}
				pSend->SendState=Cancelled;
				nCancelled+=1;
				Unlock(&pSend->SendLock);
			}
		}
	}
	
	LeaveCriticalSection(&pProtocol->m_SendQLock);
	
	SetEvent(pProtocol->m_hSendEvent);
	return hr;
	
	#undef pData
}

/*=============================================================================

	ProtocolSend - Send A message synchronously.
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/
DWORD bForceDGAsync=FALSE;

HRESULT WINAPI ProtocolSend(LPDPSP_SENDDATA pSendData)
{

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;
	DWORD        dwCommand;
	DWORD		 dwPriority;
	DWORD		 dwFlags;
	
	PUCHAR pBuffer;

	MEMDESC memdesc;

	lpDPlay=((DPLAYI_DPLAY_INT *)pSendData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);
	pBuffer=&(((PUCHAR)(pSendData->lpMessage))[pProtocol->m_dwSPHeaderSize]);

	if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
	
		dwCommand=GET_MESSAGE_COMMAND((LPMSG_SYSMESSAGE)pBuffer);

		switch(dwCommand){
			case DPSP_MSG_PACKET2_DATA:
			case DPSP_MSG_PACKET2_ACK:
			case DPSP_MSG_ENUMSESSIONSREPLY:
			case DPSP_MSG_PACKET:
				goto send_non_protocol_message;
				break;
				
			default:
				break;
		}
	}

	memdesc.pData=((PUCHAR)pSendData->lpMessage)+pProtocol->m_dwSPHeaderSize;
	memdesc.len  =pSendData->dwMessageSize-pProtocol->m_dwSPHeaderSize;

	if(pSendData->dwFlags & DPSEND_HIGHPRIORITY){
		pSendData->dwFlags &= ~(DPSEND_HIGHPRIORITY);
		dwPriority=0xFFFFFFFE;
	} else {
		dwPriority=1000;
	}

	dwFlags = pSendData->dwFlags;
	if(bForceDGAsync && !(dwFlags&DPSEND_GUARANTEE)){
		// for testing old apps with protocol make datagram sends
		// async so that the application doesn't block.
		dwFlags |= DPSEND_ASYNC;
	}


	hr=Send(pProtocol,
			pSendData->idPlayerFrom,
			pSendData->idPlayerTo,
		 	dwFlags,
			&memdesc,
		 	1,
		 	dwPriority,
		 	0,
		 	NULL,
		 	NULL,
		 	FALSE,
			NULL);

	return hr;
	
send_non_protocol_message:
	if((*((DWORD *)pBuffer)) == SIGNATURE('p','l','a','y')){
		DPF(9,"Send Message %d Ver %d\n", pBuffer[4]+(pBuffer[5]<<8),pBuffer[6]+(pBuffer[7]<<8));
	}

	ENTER_DPLAY();
	Lock(&pProtocol->m_SPLock);
	hr=CALLSP(lpDPlay->pcbSPCallbacks->Send,pSendData);	
	Unlock(&pProtocol->m_SPLock);
	LEAVE_DPLAY();

	return hr;

}

/*=============================================================================

	GetPlayerLatency - Get Latency for a player
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

DWORD GetPlayerLatency(LPDPLAYI_DPLAY lpDPlay, DPID idPlayer)
{
	PPROTOCOL    pProtocol;
	PSESSION     pSession;
	DWORD        dwLatency=0;	// default, means I don't know latency

	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	pSession=GetSession(pProtocol,idPlayer);

	DPF(9,"==>Protocol GetPlayer Latency %x, pSession %x\n",idPlayer, pSession);

	if(pSession){

		Lock(&pSession->SessionLock);

		// Protocol Latency is round trip in 24.8 fixed point,
		// we net round trip latency divided by 2, so shift right 9.
		dwLatency=(pSession->FpLocalAverageLatency)>>(9);

		Unlock(&pSession->SessionLock);
	
		DecSessionRef(pSession); // balance GetSession

	}
	DPF(9,"<==Protocol GetPlayerLatency, returning dwLat=%x\n",dwLatency);

	return dwLatency;
}

/*=============================================================================

	ProtocolGetCaps - Get Service Provider Capabilities
	
    Description:


    Parameters:


    Return Values:

-----------------------------------------------------------------------------*/

HRESULT WINAPI ProtocolGetCaps(LPDPSP_GETCAPSDATA pGetCapsData)
{
	#define ALL_PROTOCOLCAPS	(DPCAPS_SENDPRIORITYSUPPORTED | \
								 DPCAPS_ASYNCSUPPORTED        | \
								 DPCAPS_SENDTIMEOUTSUPPORTED  | \
								 DPCAPS_ASYNCCANCELSUPPORTED  )

	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL    pProtocol;
	HRESULT      hr=DP_OK;

	lpDPlay=((DPLAYI_DPLAY_INT *)pGetCapsData->lpISP)->lpDPlay;
	ASSERT(lpDPlay);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;
	ASSERT(pProtocol);

	// Chain the call to the real provider.
	Lock(&pProtocol->m_SPLock);
	if(lpDPlay->pcbSPCallbacks->GetCaps){
		hr=CALLSP(lpDPlay->pcbSPCallbacks->GetCaps,pGetCapsData);
	}
	Unlock(&pProtocol->m_SPLock);

	// if it fails, this doesn't hurt
	if(lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOL)
	{
	    // 1 megabyte is lots (says Jamie Osborne)
		pGetCapsData->lpCaps->dwMaxBufferSize=0x100000;
		pGetCapsData->lpCaps->dwFlags |= ALL_PROTOCOLCAPS;
	}
	
	if(pGetCapsData->idPlayer && !pGetCapsData->lpCaps->dwLatency){
		// SP refused to guess at latency, so use ours.
		pGetCapsData->lpCaps->dwLatency=GetPlayerLatency(lpDPlay, pGetCapsData->idPlayer);
	}
	
	return hr;
	
	#undef ALL_PROTOCOLCAPS
}

DWORD ExtractProtocolIds(PUCHAR pInBuffer, PUINT pdwIdFrom, PUINT pdwIdTo)
{
	PCHAR pBuffer=pInBuffer;
	DWORD dwIdFrom=0;
	DWORD dwIdTo=0;


	dwIdFrom=*pBuffer&0x7F;
	if(*pBuffer&0x80){
		pBuffer++;
		dwIdFrom=dwIdFrom+((*pBuffer&0x7F)<<7);
		if(*pBuffer&0x80){
			pBuffer++;
			dwIdFrom=dwIdFrom+((*pBuffer&0x7F)<<14);
			if(dwIdFrom > 0xFFFF || *pBuffer&0x80){
				DPF(0,"INVALID FROM ID  %x IN MESSAGE, REJECTING PACKET\n",dwIdFrom);
				return 0;
			}
		}
	}

	if(dwIdFrom==0xFFFF){
		dwIdFrom=0x70;
	}
	
	pBuffer++;
	
	dwIdTo=*pBuffer&0x7F;
	if(*pBuffer&0x80){
		pBuffer++;
		dwIdTo=dwIdTo+((*pBuffer&0x7F)<<7);
		if(*pBuffer&0x80){
			pBuffer++;
			dwIdTo=dwIdTo+((*pBuffer&0x7F)<<14);
			if(dwIdTo > 0xFFFF || *pBuffer&0x80){
				DPF(0,"INVALID TO ID  %x IN MESSAGE, REJECTING PACKET\n",dwIdTo);
				return 0;
			}
		}
	}

	*pdwIdFrom=dwIdFrom;
	*pdwIdTo=dwIdTo;

	pBuffer++;
	
//	DPF(9, "In ExtractProtocolIds: from %x became %x\n", *(DWORD *)pInBuffer, dwIdFrom);

	return (DWORD)(pBuffer-pInBuffer);
}

/*=============================================================================

	DP_SP_ProtocolHandleMessage - Packet handler for Dplay protocol
	
	
    Description:

		All messages go through here when the protocol is active.  If the
		message is not a protocol message, this routine doesn't process
		it and returns DPERR_NOTHANDLED to let other layers (probably
		PacketizeAndSend) process it.
	

    Parameters:

		IDirectPlaySP * pISP  - pointer to pISP interface
		LPBYTE pReceiveBuffer - a single buffer of data
		DWORD dwMessageSize   - length of the buffer
		LPVOID pvSPHeader     - pointer to SP's header used in Reply

    Return Values:

	Notes:

		We don't worry about re-entering DP_SP_HandleMessage since
		we are calling only when a receive has completed and we are in the
		callback from the SP to directplay, so effectively the SP is
		serializing receives for us.

		The receive code is actually written to be re-entrant, so if we
		ever decide to allow concurrent receive processing the protocol
		can handle it.

		Protocol messages start with 'P','L','A','Y','0xFF' when not RAW.


		DPLAY gets handleMessage first, and hands off to protocol if active.
-----------------------------------------------------------------------------*/


HRESULT DPAPI DP_SP_ProtocolHandleMessage(
	IDirectPlaySP * pISP,
	LPBYTE pReceiveBuffer,
	DWORD dwMessageSize,
	LPVOID pvSPHeader)
{
	DPLAYI_DPLAY *lpDPlay;
	DWORD dwIdFrom, dwIdTo;
	PBUFFER pRcvBuffer;
	PPROTOCOL pProtocol;
	
	lpDPlay=DPLAY_FROM_INT(pISP);
	pProtocol=(PPROTOCOL)lpDPlay->pProtocol;

	if(!pProtocol){
		goto handle_non_protocol_message;
	}

	if(pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOL){

		// Running in RAW mode there is no dplay header on protocol
		// messages.  If we see one with a header or we don't receive
		// a message large enough to be a protocol message we punt it.
	
		if(dwMessageSize >= 4 &&
		  (*((DWORD *)pReceiveBuffer)) == SIGNATURE('p','l','a','y'))
		{
			// Got a system message.
		  	goto handle_non_protocol_message;
		}
		
		if( dwMessageSize < 6 ){
			goto handle_non_protocol_message;
		}

	} else {
		// this can happen when shutting down.
		DPF(0,"Protocol still up, but no bits set, not handling receive (must be shutting down?)");
		goto handle_non_protocol_message;
	}
	
	// Hey, this must be ours...

	Lock(&pProtocol->m_ObjLock);
	if(pProtocol->m_eState==Running){	// just a sanity check, we don't depend on it after dropping lock.

		DWORD idLen;
	
		Unlock(&pProtocol->m_ObjLock);

		idLen = ExtractProtocolIds(pReceiveBuffer,&dwIdFrom,&dwIdTo);

		if(!idLen){
			goto handle_non_protocol_message;
		}

		pRcvBuffer=GetFrameBuffer(dwMessageSize-idLen);
		if(!pRcvBuffer){
			// couldn't allocate a buffer, but we are allowed to drop frames, so drop it.
			return DP_OK;
		}
		pRcvBuffer->len=dwMessageSize-idLen;
		memcpy(pRcvBuffer->pData, pReceiveBuffer+idLen,pRcvBuffer->len);

		DPF(9,"DP_SP_ProtocolHandleMessage	From %x	To %x\n",dwIdFrom,dwIdTo);

		ENTER_DPLAY();

		ProtocolReceive((PPROTOCOL)lpDPlay->pProtocol, (WORD)dwIdFrom, (WORD)dwIdTo, pRcvBuffer,pvSPHeader);

		LEAVE_DPLAY();
	} else {
		Unlock(&pProtocol->m_ObjLock);
	}

	return DP_OK;
	
handle_non_protocol_message:
	return DPERR_NOTHANDLED;
}

// DP_SP_ProtocolSendComplete is the callback handler for all completions since there is no other
// way to wrap the completion. When the protocol is not present, this just calls the DPLAY handler
// immediately.

VOID DPAPI DP_SP_ProtocolSendComplete(
	IDirectPlaySP * pISP,
	LPVOID          lpvContext,
	HRESULT         CompletionStatus)
{
	DPLAYI_DPLAY *lpDPlay;
	PPROTOCOL pProtocol;

	lpDPlay=DPLAY_FROM_INT(pISP);

	if(lpDPlay->pProtocol){

		// NOTE: when SP SendEx is used, we have to patch and xlate here.
		// for now, this should never happen.

		DEBUG_BREAK(); // Shouldn't get here yet.
		
		pProtocol=(PPROTOCOL)lpDPlay->pProtocol;

		DP_SP_SendComplete(pISP, lpvContext, CompletionStatus);

	} else {

		DP_SP_SendComplete(pISP, lpvContext, CompletionStatus);
	
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\rcvpool.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    RCVPOOL.CPP

Abstract:

	Manages pool of send descriptors.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"

//
// Receive Descriptor Management.
//

VOID InitRcvDescs(PPROTOCOL this)
{
	this->pRcvDescPool=NULL;
	this->nRcvDescsAllocated=0;
	this->nRcvDescsInUse=0;
	this->nMaxRcvDescsInUse=0;
	this->fInRcvDescTick=FALSE;
	InitializeCriticalSection(&this->RcvDescLock);
}

VOID FiniRcvDescs(PPROTOCOL this)
{
	PRECEIVE pReceive;
	
	ASSERT(this->nRcvDescsInUse==0);
	
	while(this->pRcvDescPool){
		pReceive=this->pRcvDescPool;
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		this->pRcvDescPool=this->pRcvDescPool->pNext;
		DeleteCriticalSection(&pReceive->ReceiveLock);
		My_GlobalFree(pReceive);
		this->nRcvDescsAllocated--;
	}
	
	ASSERT(this->nRcvDescsAllocated==0);
	
	DeleteCriticalSection(&this->RcvDescLock);
}

PRECEIVE GetRcvDesc(PPROTOCOL this)
{
	PRECEIVE pReceive;

	Lock(&this->RcvDescLock);

	if(!this->pRcvDescPool){
	
		Unlock(&this->RcvDescLock);
		pReceive=(PRECEIVE)My_GlobalAlloc(GMEM_FIXED, sizeof(RECEIVE)+this->m_dwSPHeaderSize);
		if(pReceive){
			SET_SIGN(pReceive,RECEIVE_SIGN);			
			InitializeCriticalSection(&pReceive->ReceiveLock);
			InitBilink(&pReceive->RcvBuffList);
		}
		Lock(&this->RcvDescLock);
		if(pReceive){
			this->nRcvDescsAllocated++;
		}
	} else {
		pReceive=this->pRcvDescPool;
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		this->pRcvDescPool=this->pRcvDescPool->pNext;
		
	}

	if(pReceive){
		this->nRcvDescsInUse++;
		if( this->nRcvDescsInUse > this->nMaxRcvDescsInUse ){
			this->nMaxRcvDescsInUse = this->nRcvDescsInUse;
		}
	}

	ASSERT(this->nRcvDescsAllocated >= this->nRcvDescsInUse);

	Unlock(&this->RcvDescLock);

	return pReceive;
}

VOID ReleaseRcvDesc(PPROTOCOL this, PRECEIVE pReceive)
{
	Lock(&this->RcvDescLock);
	this->nRcvDescsInUse--;
	ASSERT(!(this->nRcvDescsInUse&0x80000000));
	pReceive->pNext=this->pRcvDescPool;
	this->pRcvDescPool=pReceive;
	Unlock(&this->RcvDescLock);

}


#if 0
// few enough of these, that we can just let virtual memory handle it. - switched off
VOID RcvDescTick(PPROTOCOL this)
{
	PRECEIVE pReceive;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&this->fInRcvDescTick, 1)){
	
		Lock(&this->RcvDescLock);
		
		while((this->nRcvDescsAllocated > this->nMaxRcvDescsInUse) && this->pRcvDescPool){
		
			pReceive=this->pRcvDescPool;
			ASSERT_SIGN(pReceive,RECEIVE_SIGN);
			this->pRcvDescPool=this->pRcvDescPool->pNext;
			Unlock(&this->RcvDescLock);
			DeleteCriticalSection(&pReceive->ReceiveLock);
			My_GlobalFree(pReceive);
			Lock(&this->RcvDescLock);
			this->nRcvDescsAllocated--;
			
		}
		this->nMaxRcvDescsInUse=this->nRcvDescsInUse;

		ASSERT(this->nMaxRcvDescsInUse <= this->nRcvDescsAllocated);
		
		Unlock(&this->RcvDescLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&this->fInRcvDescTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\protocol.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    PROTOCOL.H

Abstract:

	Another Reliable Protocol - CPP implementation

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/11/97 aarono  Removed channel from header, now rides in body of 1st packet.
   					 								along with the length field.
   3/12/97 aarono  channel is gone, not relevant to transport protocol, can be
                   prepended to messages that want it.  Length field is gone,
                   not required.
   6/6/98  aarono  Turn on throttling and windowing - fix some definitions
--*/

#ifndef _PROTOCOL_H_
#define _PROTOCOL_H_

#pragma pack(push,1)

typedef unsigned char  byte;
typedef unsigned short word;
typedef unsigned int   dword;

//
// ARP - Another Reliable Protocol - Packet Definitions
//

// Terminology
//
// message - an arbitrary sized chunk of data
// to be sent from one computer to a another over
// the available media.
//
// packet - a piece of a message broken down
// for the media, including protocol information
// to allow the message to be reconstructed at
// the other end.
//
// frame - an instance of a packet.
//
// Assumptions:
//
// All values on the wire are little endian.
//
// This protocol allows packets to arrive out of
// order but is optimized for the in-order case.
//

#define EXT 0x80    /* EXTENSION BIT            */
#define BIG 0x40    /* BIG HEADERS (FAST MEDIA) */
#define CMD 0x20    /* COMMAND FRAME            */
#define STA 0x10
#define EOM	0x08	/* END OF MESSAGE           */
#define SAK 0x04    /* SEND ME AN ACK           */
#define ACK 0x02    /* ACKNOWLEDGE FRAME        */
#define RLY 0x01    /* RELIABLE FRAME           */

// Shifts used in small extended fields.

#define nNACK_MSK   0x60
#define nNACK_SHIFT 5
#define CMD_MSK     0x1F

#define IDMSK  (pCmdInfo->IDMSK)
#define SEQMSK (pCmdInfo->SEQMSK)

// Note: abort packets contain serial numbers but no sequence numbers.
//       the nACK field can be used to abort many messages at the same
//       time. (using ABORT2 or ABORT3).  Also just the messageid is 
//       provided in the abort case.

typedef struct _Packet1 {	// simple small -I- frame
	byte	flags;
	byte    messageid;
	byte	sequence;
	byte    serial;
	byte    data[0];
} Packet1, *pPacket1;

typedef struct _Packet2 {   // simple large -I- frame
	byte	flags;
	word    messageid;
	word 	sequence;
	byte	serial;
	byte    data[0];
} Packet2, *pPacket2;	

typedef	struct {
	byte     flag1;     // header flags
	byte     flag2;     // extended flags for small hdr/command for lrg
	byte     flag3;     // nNACK for large hdr.
	byte     pad;		// make it a dword.
} FLAGS, *pFLAGS;

// different frame components that may be part of any
// frame.  type 1 - small frames, type 2 - large frames

//
// ACKNOWLEDGE information
//

typedef struct _ACK1 {
	byte    messageid;
	byte	sequence;
	byte 	serial;
	dword   bytes;		// bytes received from remote
	dword   time;		// time when bytes received was this value
} ACK1, *pACK1;

typedef struct _ACK2 {
	word    messageid;
	word    sequence;
	byte    serial;
	dword   bytes;		// bytes received from remote
	dword   time;		// remote time when bytes receive was this value
} ACK2, *pACK2;	

//
// ABORT
//

typedef struct _ABT1 {
	byte    messageid;
	byte	sequence;
} ABT1, *pABT1;	

typedef struct _ABT2 {
	word	messageid;
	word	sequence;
} ABT2, *pABT2;

//
// MISSING packet information
//

typedef struct _NACK1 {
	byte    messageid;
	byte	sequence;
	dword	bytes;		// bytes received from remote
	dword   time;		// remote time when bytes received was this value
	byte    mask[0];
} NACK1, *pNACK1;

typedef struct _NACK2 {
	word	messageid;
	word	sequence;
	dword   bytes;		// bytes received from remote
	dword   time;		// remote time when bytes received was this value
	byte    mask[0];
} NACK2, *pNACK2;

//
// COMMAND information (including -I- frames)
//

typedef struct _CMD1 {
	byte    messageid;
	byte	sequence;
	byte	serial;
	byte	data[0];
} CMD1, *pCMD1;

typedef struct _CMD2 {
	word	messageid;
	word	sequence;
	byte    serial;
	byte	data[0];
} CMD2, *pCMD2;

#pragma pack(pop)

#endif

/*==============================================================================
                       Protocol Operational description
                       ================================

    Characteristics:
    ----------------
    
	The ARP protocol provides for reliable and non-reliable packet delivery
	over an existing non-reliable (datagram) protocol.  It is assumed that
	packet length information and addressing information is carried by the
	datagram protocol and these fields are therefore ambiguous and excluded
	from ARP.

	ARP is optimized to provide a minimum of overhead in the case of low
	bandwidth links. The overhead per-packet is 3 bytes.

	ARP's default command is the delivery of I frames.  This avoids the need
	for a command field in the protocol header for the most common frame type.

	ARP does segmentation and reassembly on large datagram messages.  This
	allows for datagram delivery of messages larger than 1 packet.

	ARP does a hybrid of windowing with selective NACK of missing packets,
	allowing optimal operation on both good and weak links, regardless
	of latency.

	ARP assigns each frame a serial number that is used in the ACK responses.
	This allows the protocol to keep up to date latency information as well
	as recognize which packet is being responded to in a retry situation. 
	The serial number allows the protocol to adjust timeouts reliably.

	ARP allows multiple messages to be sent concurrently.  Having multiple 
	messages prevents the system from blocking on retry from a single packet 
	transmission failure.  It also allows better use of available bandwidth
	since the protocol does not wait for the ACK from one message before 
	sending the next.

	{FUTURE: What about packet sub-allocation?  Bandwidth allocation?}
	

	Header Description:
	-------------------

	Flags:

	+-----+-----+-----+-----+-----+-----+-----+-----+
	| EXT | BIG | CMD | STA | EOM | SAK | ACK | RLY |  
	+-----+-----+-----+-----+-----+-----+-----+-----+

	Extended Flags:

	Small:

	+-----+-----+-----+-----+-----+-----+-----+-----+
	| EXT |   nNACK   |         COMMAND             |
	+-----+-----+-----+-----+-----+-----+-----+-----+


	Big:

	+-----+-----------------------------------------+
	| EXT |              COMMAND                    | (only if CMD & BIG set)
	+-----+-----------------------------------------+
	| EXT |               nNACK                     |
	+-----+-----------------------------------------+

	Flags:

	STA   - start of a message.
	EOM   - this bit is set when the packet is the last packet of a message
	ACK   - used to signify that this is an ACK packet, otherwise a COMMAND
		    - if nACK != 0, the ACK is informative only. i.e - tells client
		      last ACKed frame that instigated the nACK to update latency
		      information.  An ACK without nACK indicates all frames up
		      to the ACK frame were successfully received.  Any bit set
		      in the nACK mask indicates a missing frame, any 0 bit indicates
		      a frame that was successfully received.
	SAK   - when this bit is set, the receiver must send an ACK packet
	        for this packet.
	RLY   - indicates that this message is being delivered reliably.
	BIG   - when this bit is set, the packets are in large format TYPE 3.
	CMD   - command frame.  When this bit is set, the packet contains a 
	        command.  If there is no COMMAND field it is an I frame.
	EXT   - when the BIG bit is not set, indicates extended flags are present.

	Extended Flags:

	nNACK - if non-zero indicates presence of nNACK byte masks.  The NACK 
			field consists of a sequence number followed by nNACK byte masks.  
			Each bit in the mask represents a packet after the packet specified
			in the sequence number.  The packet in the sequence number is also
			being NACKed.
	
	Command:

	The command field is used to specify protocol subcommands.  The following
	are defined.  Commands larger than 15 require BIG packets.  Commands that
	require responses include the response in the ACK packet.  All protocol
	commands are unreliable.  Each command has its own messageid sequence and
	serial.  This means commands can be of arbitrary length.  The Response
	to a command is also a command.

	0000  0 - Default           - I Frame or ACK/NACK (nACK != 0)
	0001  1 - ABORT
	0010  2 - Ping              - send packet back to sender.
	0011  3 - Ping Response     - a message being returned.
	0100  4 - GetTime           - Get the tick count.
	0101  5 - Get Time Response - Response to the Get Time request.
	0110  6 - SetTime           - Set the tick count.
	0111  7 - Set Time Response - Response to the Set Time request.

	Rule for processing EXT bits.  If a byte in the flags has the high
	bit set, there is one more byte.  Ignore any bits beyond what you know
	how to process.

	Sample Packets:
	===============

	Time setting algorithm?

	Bandwidth Calculations?

	Scheduling?

	Window Size?

	Interpacket wait?

	Send Queue Management?

	Command for selective NACK.

	RLY bit separates 2 streams - reliable/datagram.  For piggyback
	ACK this means reliable piggyback ACKs are only on reliable streams
	and datagram piggyback ACKs are only on non-reliable streams.

==============================================================================*/
#ifdef __DPMESS_INCLUDED__
#define MAX_SEND_HEADER (sizeof(Packet2)+sizeof(MSG_PROTOCOL))
// leave space for a 128 bit NACK message, this is the maximum window we ever allow
#define MAX_SYS_HEADER (sizeof(NACK2)+(128/8)+sizeof(MSG_PROTOCOL))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\psession.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    SESSION.C

Abstract:

	Management of the session structures

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   6/6/98  aarono  Turn on throttling and windowing
   2/12/00 aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

/*=============================================================================

  Note on Session Locking and reference counting:
  ===============================================

  Sessions have a refcount that controls their existence.  When the refcount
  is non-zero, the session continues to exist.  When the refcount hits zero,
  the session is destroyed.
	
  On creation, the refcount for a session is set to 1.  Sessions are created
  when DirectPlay calls ProtocolCreatePlayer.  The session state is set to 
  Running during creation.  Each Session created also creates a reference
  count on the Protocol object.  This is so that the protocol does not
  shut down before all Sessions have been closed.

  When DirectPlay calls ProtocolDeletePlayer, the session's state is set
  to Closing and the reference count is reduced by one.  We then must wait
  until the session has been destroyed before we return from 
  ProtocolDeletePlayer, otherwise, the id may be recycled before we have
  freed up the slot in the session.

  Sends do NOT create references on the Session.  When a send thread starts
  referencing a Send, it creates a reference on the session the send is
  on.  When the send thread is no longer referencing the send, it deletes
  its' reference on the session.  When the reference count on the session
  is 0, it is safe to complete all pending sends with an error and free
  their resources. 

  Receives do NOT create references on the Session.  When the protocol's
  receive handler is called, a reference to the Session is created on 
  behalf of the receive thread.  When the receive thread is done processing,
  the reference is removed.  This prevents the Session from going away
  while a receive thread is processing.  When the reference count on the
  session is 0, it is safe to throw out all pending receives.  Ideally an
  ABORT message of some kind should be sent to the transmitter, but this
  is optional since it should time-out the transaction.

  If the reference count on the session hits 0, the session must be shut
  down and freed.  All pending sends are completed with an error.  All
  pending receives are thrown out and cleaned up.  All pending stats are
  thrown out.


	Session States:
    ===============
	Open     - set at creation.
	
	Closing  - set when we receive a call to ProtocolDeletePlayer.
	           No new receives or sends are accepted in closing state.
	           
	Closed   - Refcount is 0, we are now freeing everything.

-----------------------------------------------------------------------------*/

/*=============================================================================

	pPlayerFromId()

    Description:

    Parameters:     

    Return Values:

-----------------------------------------------------------------------------*/

LPDPLAYI_PLAYER pPlayerFromId(PPROTOCOL pProtocol, DPID idPlayer)
{
	LPDPLAYI_PLAYER pPlayer;
	LPDPLAYI_DPLAY lpDPlay;
	UINT index;

	lpDPlay=pProtocol->m_lpDPlay;

	if(idPlayer == DPID_SERVERPLAYER){
		pPlayer = lpDPlay->pServerPlayer;
	} else {
		index   = ((idPlayer ^ pProtocol->m_dwIDKey)&INDEX_MASK);
		ASSERT(index < 65535);
		pPlayer = (LPDPLAYI_PLAYER)(lpDPlay->pNameTable[index].dwItem);	
	}
	return pPlayer;
}

/*=============================================================================

	CreateNewSession

    Description:

    Parameters:     


    Return Values:



-----------------------------------------------------------------------------*/
HRESULT	CreateNewSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	DWORD        dwUnmangledID;
	DWORD        iPlayer;
	DWORD        iSysPlayer;

	UINT         i;

	HRESULT      hr=DPERR_NOMEMORY;

	PSESSION     (*pSessionsNew)[];
	PSESSION     pSession;

	LPDPLAYI_PLAYER pPlayer;

	if(idPlayer != DPID_SERVERPLAYER) {

		// Convert the ID to an integer
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    iPlayer = dwUnmangledID & INDEX_MASK; 

		pPlayer=(LPDPLAYI_PLAYER)(pProtocol->m_lpDPlay->pNameTable[iPlayer].dwItem);
		ASSERT(pPlayer);

		// Note: System players are always created before non-system players.
		dwUnmangledID = pPlayer->dwIDSysPlayer ^ pProtocol->m_dwIDKey;
		iSysPlayer = dwUnmangledID & INDEX_MASK;

#ifdef DEBUG
		if(iSysPlayer==iPlayer){
			DPF(9,"PROTOCOL: CREATING SYSTEM PLAYER\n");
		}
#endif	

		DPF(9,"PROTOCOL: Creating Player id x%x %dd iPlayer %d iSysPlayer %d\n",idPlayer, idPlayer, iPlayer, iSysPlayer);

		if(iPlayer >= 0xFFFF){
			// use 0xFFFF to map messages starting in 'play' to 'pl'0xFFFF
			// so we can't have a real player at this iPlayer.
			DPF(0,"PROTOCOL: not allowing creation of player iPlayer %x\n",iPlayer);
			goto exit;
		}

		Lock(&pProtocol->m_SessionLock);

		//
		// Adjust session list size (if necessary).
		//
		if(pProtocol->m_SessionListSize <= iPlayer){
			// not long enough, reallocate - go over 16 to avoid thrashing on every one.
			pSessionsNew=My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,(iPlayer+16)*sizeof(PSESSION));
			if(pSessionsNew){
				// Copy the old entries to the new list.
				if(pProtocol->m_pSessions){
					for(i=0;i<pProtocol->m_SessionListSize;i++){
						(*pSessionsNew)[i]=(*pProtocol->m_pSessions)[i];
					}
					// Free the old list.
					My_GlobalFree(pProtocol->m_pSessions);
				}
				// Put the new list in its place.
				pProtocol->m_pSessions=pSessionsNew;
				pProtocol->m_SessionListSize=iPlayer+16;
				DPF(9,"PROTOCOL: Grew sessionlist to %d entries\n",pProtocol->m_SessionListSize);
			}
		}

		// Allocate a session

		pSession=(PSESSION)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));

		if(!pSession){
			goto exit2;
		}

		(*pProtocol->m_pSessions)[iPlayer]=pSession;
	
	} else {
		// SERVERPLAYER

		pPlayer = pPlayerFromId(pProtocol,idPlayer);
		iPlayer = SERVERPLAYER_INDEX;
		
		Lock(&pProtocol->m_SessionLock);
		
		pSession=(PSESSION)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SESSION));

		if(!pSession){
			goto exit2;
		}
		
		ASSERT(!pProtocol->m_pServerPlayerSession);
		pProtocol->m_pServerPlayerSession=pSession;

		ASSERT(pPlayer->dwIDSysPlayer != DPID_SERVERPLAYER);

		// Note: System players are always created before non-system players.
		dwUnmangledID = pPlayer->dwIDSysPlayer ^ pProtocol->m_dwIDKey;
		iSysPlayer = dwUnmangledID & INDEX_MASK;

		DPF(8,"PROTOCOL:CreatePlayer: Creating SERVERPLAYER: pPlayer %x iPlayer %x iSysPlayer %x\n",pPlayer,iPlayer,iSysPlayer);
	}
	
	pProtocol->m_nSessions++;
	
	//
	// Session structure initialization
	//

	SET_SIGN(pSession, SESSION_SIGN);
	
	pSession->pProtocol=pProtocol;

	InitializeCriticalSection(&pSession->SessionLock);
	pSession->RefCount=1; // One Ref for creation.
	pSession->eState=Open;
	
	// Initialize the SendQ
	InitBilink(&pSession->SendQ);
	
	pSession->dpid=idPlayer;
	pSession->iSession=iPlayer;
	pSession->iSysPlayer=iSysPlayer;

	InitializeCriticalSection(&pSession->SessionStatLock);
	InitBilink(&pSession->DGStatList);
	pSession->DGFirstMsg = 0;
	pSession->DGLastMsg = 0;
	pSession->DGOutMsgMask = 0;
	pSession->nWaitingForDGMessageid=0;
	
	pSession->FirstMsg = 0;
	pSession->LastMsg  = 0;
	pSession->OutMsgMask = 0;
	pSession->nWaitingForMessageid=0;

	// we start the connection using small headers, if we see we can
	// get better perf with a large header during operation, then we
	// switch to the large header.
	pSession->MaxCSends     = 1;/*MAX_SMALL_CSENDS	- initial values adjusted after 1st ACK*/ 
	pSession->MaxCDGSends   = 1;/*MAX_SMALL_DG_CSENDS*/
	pSession->WindowSize	= 1;/*MAX_SMALL_WINDOW*/
	pSession->DGWindowSize  = 1;/*MAX_SMALL_WINDOW*/
	pSession->fFastLink     = FALSE; // start assuming slow link.
	pSession->fSendSmall    = TRUE; 
	pSession->fSendSmallDG  = TRUE;
	pSession->fReceiveSmall = TRUE;
	pSession->fReceiveSmallDG = TRUE;

#if 0
	// use this code to START with large packet headers
	pSession->MaxCSends		= MAX_LARGE_CSENDS;
	pSession->MaxCDGSends   = MAX_LARGE_DG_CSENDS;
	pSession->WindowSize	= MAX_LARGE_WINDOW;
	pSession->DGWindowSize  = MAX_LARGE_WINDOW;
	pSession->fSendSmall    = FALSE;
	pSession->fSendSmallDG  = FALSE;
#endif

	pSession->MaxPacketSize = pProtocol->m_dwSPMaxFrame; 
	

	pSession->FirstRlyReceive=pSession->LastRlyReceive=0;
	pSession->InMsgMask = 0;
	
	InitBilink(&pSession->pRlyReceiveQ);
	InitBilink(&pSession->pDGReceiveQ);
	InitBilink(&pSession->pRlyWaitingQ);

	InitSessionStats(pSession);

	pSession->SendRateThrottle = 28800;
	pSession->FpAvgUnThrottleTime = Fp(1); // assume 1 ms to schedule unthrottle (first guess)
	pSession->tNextSend=pSession->tLastSAK=timeGetTime();
	
	Unlock(&pProtocol->m_SessionLock);

	hr=DP_OK;

exit:
	return hr;

exit2:
	hr=DPERR_OUTOFMEMORY;
	return hr;
}

/*=============================================================================

    GetDPIDIndex - lookup a session based on the Index
    
    Description:

    Parameters:     

		DWORD index	- Find the dpid for this index

    Return Values:

		DPID - dpid of the index

-----------------------------------------------------------------------------*/


DPID GetDPIDByIndex(PPROTOCOL pProtocol, DWORD index)
{
	PSESSION pSession;
	DPID     dpid;

	Lock(&pProtocol->m_SessionLock);

	if(index == SERVERPLAYER_INDEX){
		dpid=DPID_SERVERPLAYER;
	} else if(index < pProtocol->m_SessionListSize && 
	         (pSession=(*pProtocol->m_pSessions)[index]))
	{
		Lock(&pSession->SessionLock);
		dpid=pSession->dpid;
		Unlock(&pSession->SessionLock);
	} else {
		dpid=0xFFFFFFFF;
		DPF(1,"GetDPIDByIndex, no id at index %d player may me gone or not yet created locally.\n",index);
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return dpid;
}

WORD GetIndexByDPID(PPROTOCOL pProtocol, DPID dpid)
{
	DWORD dwUnmangledID;
	if(dpid == DPID_SERVERPLAYER){
		return SERVERPLAYER_INDEX;
	}
	dwUnmangledID = dpid ^ pProtocol->m_dwIDKey;
    return (WORD)(dwUnmangledID & INDEX_MASK); 
    
}
/*=============================================================================

    GetSysSessionByIndex - lookup a session based on the Index
    
    Description:

    Parameters:     

		DWORD index	- Find the session for this index

    Return Values:

    	NULL - if the SESSION is not found, 
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSysSessionByIndex(PPROTOCOL pProtocol, DWORD index)
{
	PSESSION pSession;
	
	Lock(&pProtocol->m_SessionLock);

	DPF(9,"==>GetSysSessionByIndex at index x%x\n", index);

	if( (index < pProtocol->m_SessionListSize) || (index == SERVERPLAYER_INDEX) ){

		// ptr to session at requested index.
		if(index == SERVERPLAYER_INDEX){
			pSession = pProtocol->m_pServerPlayerSession;
		} else {
			pSession = (*pProtocol->m_pSessions)[index];
		}	

		if(pSession){
			// ptr to system session for session at requested index.
			pSession=(*pProtocol->m_pSessions)[pSession->iSysPlayer];
			if(pSession){
				Lock(&pSession->SessionLock);
				if(pSession->eState==Open){
					InterlockedIncrement(&pSession->RefCount);
					Unlock(&pSession->SessionLock);
				} else {
					// Session is closing or closed, don't give ptr.
					Unlock(&pSession->SessionLock);
					pSession=NULL;
				}
			} 
		}
	} else {
		pSession=NULL;
	}

	DPF(9,"<===GetSysSessbyIndex pSession %x\n",pSession);
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

/*=============================================================================

    GetSysSession - lookup a the system session of a session based on the DPID
    
    Description:

    Parameters:     

		DPID idPlayer	- Find the session for this player.

    Return Values:

    	NULL - if the SESSION is not found, or the DPID has been re-cycled.
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSysSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	PSESSION pSession;
	DWORD    dwUnmangledID;
	DWORD    index;
	
	Lock(&pProtocol->m_SessionLock);

	if(idPlayer != DPID_SERVERPLAYER){
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    index = dwUnmangledID & INDEX_MASK; 
		pSession=(*pProtocol->m_pSessions)[index];
	} else {
		pSession=pProtocol->m_pServerPlayerSession;
	}

	if(pSession){

		if(pSession->dpid == idPlayer){
			pSession=(*pProtocol->m_pSessions)[pSession->iSysPlayer];
			if(pSession){
				Lock(&pSession->SessionLock);
				if(pSession->eState == Open){
					InterlockedIncrement(&pSession->RefCount);
					Unlock(&pSession->SessionLock);
				} else {
					// Closing, don't return value
					Unlock(&pSession->SessionLock);
					pSession=NULL;
				}
			} else {
				DPF(0,"GetSysSession: Looking on Session, Who's SysSession is gone!\n");
				ASSERT(0);
			}
			
		} else {
			DPF(1,"PROTOCOL: got dplay id that has been recycled (%x), now (%x)?\n",idPlayer,pSession->dpid);
			ASSERT(0);
			pSession=NULL;
		}
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

/*=============================================================================

    GetSession - lookup a session based on the DPID
    
    Description:

    Parameters:     

		DPID idPlayer	- Find the session for this player.

    Return Values:

    	NULL - if the SESSION is not found, or the DPID has been re-cycled.
    	else	   pointer to the Session.

	Notes:

		Adds a reference to the SESSION.  When done with the session pointer
		the caller must call DecSessionRef.

-----------------------------------------------------------------------------*/


PSESSION GetSession(PPROTOCOL pProtocol, DPID idPlayer)
{
	PSESSION pSession;
	DWORD    dwUnmangledID;
	DWORD    index;
	
	Lock(&pProtocol->m_SessionLock);

	if(idPlayer != DPID_SERVERPLAYER){
		dwUnmangledID = idPlayer ^ pProtocol->m_dwIDKey;
	    index = dwUnmangledID & INDEX_MASK; 
		pSession=(*pProtocol->m_pSessions)[index];
	} else {
		pSession=pProtocol->m_pServerPlayerSession;
	}

	if(pSession){

		if(pSession->dpid == idPlayer){
			Lock(&pSession->SessionLock);
			InterlockedIncrement(&pSession->RefCount);
			Unlock(&pSession->SessionLock);
		} else {
			DPF(1,"PROTOCOL: got dplay id that has been recycled (%x), now (%x)?\n",idPlayer,pSession->dpid);
			ASSERT(0);
			pSession=NULL;
		}
	}
	
	Unlock(&pProtocol->m_SessionLock);
	return pSession;
}

VOID ThrowOutReceiveQ(PPROTOCOL pProtocol, BILINK *pHead)
{
	PRECEIVE pReceiveWalker;
	BILINK *pBilink;
	
	pBilink = pHead->next;
	while( pBilink != pHead ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceiveWalker, RECEIVE_SIGN);
		ASSERT(!pReceiveWalker->fBusy);
		pBilink=pBilink->next;
		Lock(&pReceiveWalker->ReceiveLock);
		if(!pReceiveWalker->fBusy){
			Delete(&pReceiveWalker->pReceiveQ);
			Unlock(&pReceiveWalker->ReceiveLock);
			DPF(8,"Throwing Out Receive %x from Q %x\n",pReceiveWalker, pHead);
			FreeReceive(pProtocol,pReceiveWalker);
		} else {
			Unlock(&pReceiveWalker->ReceiveLock); 
		}	
	}	
}

/*=============================================================================

    DecSessionRef
    
    Description:

    Parameters:     

    Return Values:

-----------------------------------------------------------------------------*/

INT DecSessionRef(PSESSION pSession)
{
	PPROTOCOL pProtocol;
	INT count;

	PSEND pSendWalker;
	BILINK *pBilink;

	if(!pSession){
		return 0;
	}

	count = InterlockedDecrement(&pSession->RefCount);

	if(!count){

		// No more references!  Blow it away.
		DPF(9,"DecSessionRef:(firstchance) pSession %x, count=%d, Session Closed, called from %x \n",pSession,count,_ReturnAddress());
	
		pProtocol=pSession->pProtocol;

		Lock(&pProtocol->m_SessionLock);
		Lock(&pSession->SessionLock);
		
		if(!pSession->RefCount){
			// Remove any referece to the session from the protocol.
			if(pSession->iSession != SERVERPLAYER_INDEX){
				(*pProtocol->m_pSessions)[pSession->iSession]=NULL;
			} else {
				pProtocol->m_pServerPlayerSession=NULL;
			}
			pProtocol->m_nSessions--;
		} else {
			count=pSession->RefCount;
		}	

		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SessionLock);

		// Session is floating free and we own it.  No one can reference
		// so we can safely blow it all away, don't need to lock during
		// these ops since no-one can reference any more...

		if(!count){

			DPF(9,"DecSessionRef(second chance): pSession %x, count=%d, Session Closed, called from %x \n",pSession,count,_ReturnAddress());
			//DEBUG_BREAK();
			pSession->eState=Closed;

			if(pSession->uUnThrottle){
				//timeKillEvent(pSession->uUnThrottle);
				CancelMyTimer(pSession->uUnThrottle, pSession->UnThrottleUnique);
			}

			// Free up Datagram send statistics.
			DeleteCriticalSection(&pSession->SessionStatLock);
			pBilink=pSession->DGStatList.next;
			while(pBilink != & pSession->DGStatList){
				PSENDSTAT pStat = CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
				pBilink=pBilink->next;
				ReleaseSendStat(pStat);
			}
			
			// Complete pending sends.
			pBilink=pSession->SendQ.next;
			while(pBilink!=&pSession->SendQ){
				pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
				pBilink=pBilink->next;
				
				CancelRetryTimer(pSendWalker);
				DoSendCompletion(pSendWalker, DPERR_CONNECTIONLOST);
				DecSendRef(pProtocol, pSendWalker);
					
			}
			
			//
			// throw out pending receives.
			//

			ThrowOutReceiveQ(pProtocol, &pSession->pDGReceiveQ);
			ThrowOutReceiveQ(pProtocol, &pSession->pRlyReceiveQ);
			ThrowOutReceiveQ(pProtocol, &pSession->pRlyWaitingQ);
			
			//
			// Free the session
			//
			if(pSession->hClosingEvent){
				DPF(5,"DecSessionRef: pSession %x Told Protocol DeletePlayer to continue\n",pSession);
				SetEvent(pSession->hClosingEvent);
			}
			UNSIGN(pSession->Signature);
			DeleteCriticalSection(&pSession->SessionLock);
			My_GlobalFree(pSession);
		}
		
	} else {
		DPF(9,"DecSessionRef: pSession %x count %d, called from %x\n",pSession, count, _ReturnAddress());
	}
	
	return count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\send.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    SEND.C

Abstract:

	Send Handler and Send Thread.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
   2/18/98 aarono  added support for SendEx
   2/18/98 aarono  added support for Cancel
   2/20/98 aarono  B#18827 not pulling Cancelled sends off queue
   3/09/98 aarono  documented workaround for mmTimers on Win95, removed dead code.
   3/29/98 aarono  fixed locking for ReliableSend
   3/30/98 aarono  make sure erroring sends moved to Done state to avoid reprocess.
   4/14/98 a-peterz B#18340 DPSEND_NOCOPY subsumes DPSEND_NOBUFFERCOPY
   5/18/98 aarono  fixed SendEx with scatter gather
   6/6/98  aarono  Turn on throttling and windowing
   10/8/99 aarono  Improve shutdown handling, avoid 1min hang with pending sends.
   2/12/00 aarono  Concurrency issues, fix VOL usage and Refcount

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"

#ifdef DEBUG
VOID DQProtocolSend(PSEND pS)
{
	DPF(0,"===SEND====pSend %x=====",pS);

#ifdef SIGN
	DPF(0,"Signature           : %08x", pS->Signature);
#endif
//	CRITICAL_SECTION SendLock;          // Lock for Send Structure
	DPF(0,"RefCount            : %d", pS->RefCount);

	DPF(0,"SendState:          %08x", pS->SendState);	// State of this message's transmission.

	// Lists and Links...
	
//	union {
//		struct _SEND *pNext;			// linking on free pool
//		BILINK		   SendQ;			// linking on session send queue
//	};
//	BILINK         m_GSendQ;			// Global Priority Queue
	DPF(0,"pSession:     %08x",pS->pSession); // pointer to SESSIONion(gets a ref)

	// Send Information
	
	DPF(0,"idFrom:       %08x",pS->idFrom);
	DPF(0,"idTo:         %08x",pS->idTo);
	DPF(0,"wIdTo:        %08x",pS->wIdTo);		// index in table
	DPF(0,"wIdFrom:      %08x",pS->wIdFrom);       // index in table
	DPF(0,"dwFlags:      %08x",pS->dwFlags);       // Send Flags (include reliable)
	DPF(0,"pMessage:     %08x",pS->pMessage);	// Buffer chain describing message.
	DPF(0,"MessageSize:  %08x",pS->MessageSize);		// Total size of the message.
	DPF(0,"FrameDataLen: %08x",pS->FrameDataLen);       // Data area of each frame.
	DPF(0,"nFrames:      %08x",pS->nFrames);	    // Number of frames for this message.

	DPF(0,"Priority:     %08x",pS->Priority);       // Send Priority.

	// Vars for reliability
	DPF(0,"fSendSmall:   %08x",pS->fSendSmall);
	DPF(0,"fUpdate:      %08x",pS->fUpdate);       // update to NS,NR NACKMask made by receive.
	DPF(0,"messageid:    %08x",pS->messageid);		// Message ID number.
	DPF(0,"serial:       %08x",pS->serial);       // serial number.
	DPF(0,"OpenWindows   %08x",pS->OpenWindow);
	DPF(0,"NS:           %08x",pS->NS);    	// Sequence Sent.
	DPF(0,"NR:           %08x",pS->NR);		// Sequence ACKED.
	DPF(0,"SendSEQMSK:   %08x",pS->SendSEQMSK);		// Mask to use.
	DPF(0,"NACKMask:     %08x",pS->NACKMask);       // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
	DPF(0,"SendOffset:          %08x",pS->SendOffset);		// Current offset we are sending.
	DPF(0,"pCurrentBuffer:      %08x",pS->pCurrentBuffer);  	// Current buffer being sent.
	DPF(0,"CurrentBufferOffset: %08x",pS->CurrentBufferOffset);// Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	//BILINK         StatList:			// Info for packets already sent.
	
	// Operational Characteristics

//	DPF(0,"PendedRetryTimer:    %08x\n",pS->PendedRetryTimer);
//	DPF(0,"CancelledRetryTimer: %08x\n",pS->CancelledRetryTimer);
	DPF(0,"uRetryTimer:         %08x",pS->uRetryTimer);
	DPF(0,"RetryCount:          %08x",pS->RetryCount);// Number of times we retransmitted.
	DPF(0,"WindowSize:          %08x",pS->WindowSize);// Maximum Window Size.
	DPF(0,"tLastACK:            %08x",pS->tLastACK);// Time we last got an ACK.

	DPF(0,"PacketSize:          %08x",pS->PacketSize);// Size of packets to send.
	DPF(0,"FrameSize:           %08x",pS->FrameSize);// Size of Frames for this send.

	// Completion Vars
	DPF(0,"hEvent:              %08x",pS->hEvent);// Event to wait on for internal send.
	DPF(0,"Status:              %08x",pS->Status);// Send Completion Status.

	DPF(0,"pAsyncInfo:          %08x",pS->pAsyncInfo);// ptr to Info for completing Async send(NULL=>internal send)
//	DPF(0,"AsyncInfo:           // actual info (copied at send call).
	
} 


VOID DQProtocolSession(PSESSION pS)
{
	DPF(0,"pProtocol           : %08x", pS->pProtocol);

#ifdef SIGN
	DPF(0,"Signature           : %08x", pS->Signature);
#endif

	// Identification

//	DPF(0," SessionLock;           // Lock for the SESSIONion.
	DPF(0,"RefCount            : %d", pS->RefCount);
	DPF(0,"eState              : %d", pS->eState);
	DPF(0,"hClosingEvent       : %d", pS->hClosingEvent);

	DPF(0,"fSendSmall          : %d", pS->fSendSmall);     
	DPF(0,"fSendSmallDG        : %d", pS->fSendSmallDG);
	
	DPF(0,"dpid                : %08x",pS->dpid);
	DPF(0,"iSession;           : %d", pS->iSession);
	
	DPF(0,"MaxPacketSize       : x%08x %d",pS->MaxPacketSize,pS->MaxPacketSize);

	DPF(0,"\n Operating Parameters:SEND \n --------- --------------- \n");

	// Operating parameters -- Send

	// Common

	DPF(0,"Common:\n");
	DPF(0,"MaxCSends           : %d",pS->MaxCSends);

	DPF(0,"Reliable:\n");
	// Reliable

	DPF(0,"FirstMsg    : %08x",pS->FirstMsg);				// First message number being transmitted
	DPF(0,"LastMsg     : %08x",pS->LastMsg);				// Last message number being transmitted
	DPF(0,"OutMsgMask  : %08x",pS->OutMsgMask);           // relative to FirstMsg, unacked messages

	DPF(0,"nWaitingForMessageid: %08x", pS->nWaitingForMessageid);

	// DataGram
	DPF(0,"Datagram:\n");

	DPF(0,"DGFirstMsg    : %08x",pS->DGFirstMsg);
	DPF(0,"DGLastMsg     : %08x",pS->DGLastMsg);
	DPF(0,"DGOutMsgMask  : %08x",pS->DGOutMsgMask);

	DPF(0,"nWaitingForDGMessageid: %08x",pS->nWaitingForDGMessageid);

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive
	DPF(0,"\n Operating Parameters:RECEIVE \n --------- ------------------ \n");

	// DataGram Receive.
//	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
//	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
//	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
	DPF(0,"FirstRlyReceive : %08x",pS->FirstRlyReceive);
	DPF(0,"LastRlyReceive  : %08x",pS->LastRlyReceive);
	DPF(0,"InMsgMask       : %08x",pS->InMsgMask);

	DPF(0,"\n Operating Parameters:STATS \n --------- ---------------- \n");
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!!

	DPF(0,"WindowSize           :%d",pS->WindowSize);
	DPF(0,"DGWindowSize         :%d",pS->DGWindowSize);

	
	DPF(0,"MaxRetry             :%d",pS->MaxRetry);	// Usualy max retries before dropping.
	DPF(0,"MinDropTime          :%d",pS->MinDropTime);	// Min time to retry before dropping.
	DPF(0,"MaxDropTime          :%d",pS->MaxDropTime);	// After this time always drop.

	DPF(0,"LocalBytesReceived   :%d",pS->LocalBytesReceived);    // Total Data Bytes received (including retries).
	DPF(0,"RemoteBytesReceived  :%d",pS->RemoteBytesReceived);   // Last value from remote.

	DPF(0,"LongestLatency       :%d",pS->LongestLatency);		// longest observed latency (msec)
	DPF(0,"ShortestLatency      :%d",pS->ShortestLatency);		// shortest observed latency(msec)
	
	DPF(0,"FpAverageLatency     :%d",pS->FpAverageLatency/256);
	DPF(0,"FpLocalAverageLatency:%d",pS->FpLocalAverageLatency/256);	// Local average latency    (msec 24.8) (across fewer samples)
	
	DPF(0,"FpLocalAvgDeviation  :%d",pS->FpLocalAvgDeviation/256);   // average deviation of latency. (msec 24.8)

	DPF(0,"Bandwidth            :%d",pS->Bandwidth);				// latest observed bandwidth (bps)
	DPF(0,"HighestBandwidth     :%d",pS->HighestBandwidth);    // highest observed bandwidth (bps)

}

VOID DumpSession(SESSION *pSession)
{
	BILINK *pBilink;
	PSEND pSend;
	DWORD dwMaxDump=99;
	DQProtocolSession(pSession);

	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ)
	{
		pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
		DQProtocolSend(pSend);
		if((dwMaxDump--)==0) break; // only dump 99 sends
		pBilink=pBilink->next;
	}
}


#endif

BOOL DGCompleteSend(PSEND pSend);

// a-josbor: for debuggin purposes only
extern DWORD ExtractProtocolIds(PUCHAR pInBuffer, PUINT pdwIdFrom, PUINT pdwIdTo);

INT AddSendRef(PSEND pSend, UINT count)
{
	INT newcount;
	Lock(&pSend->SendLock);
	Lock(&g_SendTimeoutListLock);
	if(pSend->bCleaningUp){
		DPF(1,"WARNING: ADDSENDREF tried to add reference to cleaning up send %x\n",pSend);
		newcount=0;
		goto exit;
	}
	if(!pSend->RefCount){
		// Anyone calling addsend ref requires a reference on the session
		Unlock(&g_SendTimeoutListLock);
		Unlock(&pSend->SendLock);
		
		Lock(&pSend->pSession->pProtocol->m_SessionLock);
		Lock(&pSend->pSession->SessionLock);
		Lock(&pSend->SendLock);
		Lock(&g_SendTimeoutListLock);
		InterlockedIncrement((PLONG)&pSend->pSession->RefCount);
		Unlock(&pSend->pSession->SessionLock);
		Unlock(&pSend->pSession->pProtocol->m_SessionLock);
		
	} else {
		newcount=pSend->RefCount;
	}
	
	while(count--){
		newcount=InterlockedIncrement(&pSend->RefCount);
	}
	
exit:	
	Unlock(&g_SendTimeoutListLock);
	Unlock(&pSend->SendLock);
	return newcount;
}

#ifdef DEBUG
// Turn off global optimizations when building DEBUG version since the
// compiler over-writes the return address in this code.  NTB#347427
// Should be fixed in compiler post Win2K.
#if _MSC_VER < 0x1100
#pragma optimize("g", off)
#endif
#endif

// Critical Section must not be held when this is called, unless there
// is a reference for holding the critical section (ie. will not hit 0).
INT DecSendRef(PPROTOCOL pProtocol, PSEND pSend)
{
	INT      count;
	PSESSION pSession;
	
	Lock(&pSend->SendLock);
	
	count=InterlockedDecrement((PLONG)&pSend->RefCount);//count is zero if result of dec is zero, otw nonzero but not actual count.

	if(!count){
		pSession=pSend->pSession;
		pSend->bCleaningUp=TRUE;
		
		Unlock(&pSend->SendLock);
		// pull the Send off of the global queue and the session queue
		Lock(&pProtocol->m_SendQLock);
		Lock(&pSession->SessionLock);
		Lock(&pSend->SendLock);
		Lock(&g_SendTimeoutListLock);
		
		if(!pSend->RefCount){
			Delete(&pSend->TimeoutList);
			Delete(&pSend->m_GSendQ);
			Delete(&pSend->SendQ);
		} else {
			count=pSend->RefCount;
		}

		Unlock(&g_SendTimeoutListLock);
		Unlock(&pSend->SendLock);
		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SendQLock);
		
		if(!count){
			DecSessionRef(pSession);

			DPF(8,"DecSendRef: pSession %x pSend %x Freeing Send, called from %x\n",pSession, pSend, _ReturnAddress());

			FreeHandleTableEntry(&pProtocol->lpHandleTable,&pProtocol->csHandleTable,pSend->dwMsgID);
			// Free the message buffer(s) (including memory if WE allocated it).
			FreeBufferChainAndMemory(pSend->pMessage);
			// OPTIMIZATION:move any Stats we want to keep to the session.
			// free the send.(handles the stats for now).
			ReleaseSendDesc(pSend);
		}       
	} else {
		DPF(8,"DecSendRef: pSession %x pSend %x count %d, called from %x\n",pSend->pSession, pSend, count,_ReturnAddress());
		if(count&0x80000000){
			DEBUG_BREAK();
		}
		Unlock(&pSend->SendLock);
	}
	return count;
}

#ifdef DEBUG
#if _MSC_VER < 1100
#pragma optimize("", on)
#endif 
#endif

// SFLAGS_DOUBLEBUFFER - if the send is ASYNCHRONOUS, make a copy of the data
/*=============================================================================

    Send - Send a message to a client.
    
    Description:

	    Used by the client to send a message to another directplay client
	    or server.  

    Parameters:     

		ARPDID  idFrom        - who is sending this message
		ARPDID  idTo          - target
		DWORD   dwSendFlags   - specifies buffer ownership, priority, reliable
		LPVOID  pBuffers      - Array of buffer and lengths
		DWORD   dwBufferCount - number of entries in array
		PASYNCINFO pAsyncInfo - If specified, call is asynchronous

		typedef struct _ASYNCSENDINFO {
			UINT            Private[4];
			HANDLE          hEvent;
			PSEND_CALLBACK  SendCallBack;
			PVOID           CallBackContext;
			UINT            Status;
		} ASYNCSENDINFO, *PASYNCSENDINFO;

		hEvent              - event to signal when send completes.
		SendCallBack    - routine to call when send completes.
		CallBackContext - context passed to SendCallBack.
		Status          - send completion status.

    Return Values:

		DP_OK - no problem
		DPERR_INVALIDPARAMS


-----------------------------------------------------------------------------*/
HRESULT Send(
	PPROTOCOL      pProtocol,
	DPID           idFrom, 
	DPID           idTo, 
	DWORD          dwSendFlags, 
	LPVOID         pBuffers,
	DWORD          dwBufferCount, 
	DWORD          dwSendPri,
	DWORD          dwTimeOut,
	LPVOID         lpvUserMsgID,
	LPDWORD        lpdwMsgID,
	BOOL           bSendEx,
	PASYNCSENDINFO pAsyncInfo
)
{
	HRESULT hr=DP_OK;

	PSESSION    pSession;
	PBUFFER     pSendBufferChain;
	PSEND       pSend;

	pSession=GetSysSession(pProtocol,idTo);

	if(!pSession) {
		DPF(4,"NO SESSION for idTo %x, returning SESSIONLOST\n",idTo);
		hr=DPERR_CONNECTIONLOST;
		goto exit2;
	}

	pSend=GetSendDesc();
	
	if(!pSend){
		ASSERT(0); //TRACE all paths.
		hr=DPERR_OUTOFMEMORY;
		goto exit;
	}

	pSend->pProtocol=pProtocol;

	// fails by returning 0 in which case cancel won't be available for this send.
	pSend->dwMsgID=AllocHandleTableEntry(&pProtocol->lpHandleTable, &pProtocol->csHandleTable, pSend);

	if(lpdwMsgID){
		*lpdwMsgID=pSend->dwMsgID;
	}

	pSend->lpvUserMsgID = lpvUserMsgID;
	pSend->bSendEx = bSendEx;

	// if pAsyncInfo is provided, the call is asynchronous.
	// if dwFlags DPSEND_ASYNC is set, the call is async.
	// if the call is asynchronous and double buffering is
	// required, we must make a copy of the data.

	if((pAsyncInfo||(dwSendFlags & DPSEND_ASYNC)) && (!(dwSendFlags & DPSEND_NOCOPY))){
		// Need to copy the memory
		pSendBufferChain=GetDoubleBufferAndCopy((PMEMDESC)pBuffers,dwBufferCount);
		// OPTIMIZATION: if the provider requires contiguous buffers, we should
		//         break this down into packet allocations, and chain them
		//         on the send immediately.  Using the packet chain to indicate
		//         to ISend routine that the message is already broken down.
	} else {
		// Build a send buffer chain for the described buffers.
		pSendBufferChain=BuildBufferChain((PMEMDESC)pBuffers,dwBufferCount);            
	}
	
	if(!pSendBufferChain){
		ASSERT(0); //TRACE all paths.
		return DPERR_OUTOFMEMORY;
	}
	
	pSend->pSession            = pSession;     //!!! when this is dropped, deref the connection
	
	pSend->pMessage            = pSendBufferChain;
	pSend->MessageSize         = BufferChainTotalSize(pSendBufferChain);
	pSend->SendOffset          = 0;
	pSend->pCurrentBuffer      = pSend->pMessage;
	pSend->CurrentBufferOffset = 0;
	
	pSend->Priority            = dwSendPri;
	pSend->dwFlags             = dwSendFlags;
	
	if(pAsyncInfo){
		pSend->pAsyncInfo       = &pSend->AsyncInfo;
		pSend->AsyncInfo        = *pAsyncInfo; //copy Async info from client.
	} else {
		pSend->pAsyncInfo               = NULL;
		if(pSend->dwFlags & DPSEND_ASYNC){
			pSend->AsyncInfo.hEvent         = 0;
			pSend->AsyncInfo.SendCallBack   = InternalSendComplete;
			pSend->AsyncInfo.CallBackContext= pSend;
			pSend->AsyncInfo.pStatus        = &pSend->Status;
		}       
	}

	pSend->SendState            = Start;
	pSend->RetryCount           = 0;
	pSend->PacketSize           = pSession->MaxPacketSize;

	pSend->fUpdate              = FALSE;
	pSend->NR                   = 0;
	pSend->NS                   = 0;
	//pSend->SendSEQMSK			= // filled in on the fly.
	pSend->WindowSize           = pSession->WindowSize;
	pSend->SAKInterval			= (pSend->WindowSize+1)/2;
	pSend->SAKCountDown         = pSend->SAKInterval;

	pSend->uRetryTimer          = 0;
	
	pSend->idFrom               = idFrom;
	pSend->idTo                 = idTo;

	pSend->wIdFrom              = GetIndexByDPID(pProtocol, idFrom);
	pSend->wIdTo                = (WORD)pSession->iSession;
	pSend->RefCount             = 0;                        // if provider does async send counts references.

	pSend->serial               = 0;

	pSend->tLastACK             = timeGetTime();
	pSend->dwSendTime           = pSend->tLastACK;
	pSend->dwTimeOut            = dwTimeOut;

	pSend->BytesThisSend        = 0;

	pSend->messageid            = -1;  // avoid matching this send in ACK/NACK handlers
	pSend->bCleaningUp          = FALSE;

	hr=ISend(pProtocol,pSession, pSend);

exit:
	DecSessionRef(pSession);
	
exit2:
	return hr;

}

/*================================================================================
	Send Completion information matrix:
	===================================

											(pSend->dwFlags & ASEND_PROTOCOL)
							                               |
							Sync            Async   Internal (Async)
							--------------  -----   --------------------
	pSend->pAsyncInfo       0               user    0
	pSend->AI.SendCallback  0               user    InternalSendComplete
	pSend->AI.hEvent        pSend->hEvent   user    0
	pSend->AI.pStatus       &pSend->Status  user    &pSend->Status
	
 ---------------------------------------------------------------------------*/

HRESULT ISend(
	PPROTOCOL pProtocol,
	PSESSION pSession, 
	PSEND    pSend
	)
{
	HRESULT hr=DP_OK;

	DWORD_PTR fAsync;
	BOOL    fCallDirect=FALSE;

	fAsync=(DWORD_PTR)(pSend->pAsyncInfo);

	if(!fAsync && !(pSend->dwFlags & (ASEND_PROTOCOL|DPSEND_ASYNC))) {
		//Synchronous call, and not a protocol generated packet
		pSend->AsyncInfo.SendCallBack=NULL;
		//AsyncInfo.CallbackContext=0; //not required.
		pSend->AsyncInfo.hEvent=pSend->hEvent;
		pSend->AsyncInfo.pStatus=&pSend->Status;
		ResetEvent(pSend->hEvent);
	}

	// don't need to check if ref added here since the send isn't on a list yet.
	AddSendRef(pSend,2); // 1 for ISend, 1 for completion.

	DPF(9,"ISend: ==>Q\n");
	hr=QueueSendOnSession(pProtocol,pSession,pSend);
	DPF(9,"ISend: <==Q\n");

	if(hr==DP_OK){

		if(!fAsync && !(pSend->dwFlags & (ASEND_PROTOCOL|DPSEND_ASYNC))){
			// Synchronous call, and not internal, we need 
			// to wait until the send has completed.
			if(!(pSend->dwFlags & DPSEND_GUARANTEED)){
				// Non-guaranteed, need to drop dplay lock, in 
				// guaranteed case, dplay already dropped it for us.
				LEAVE_DPLAY();
			}
			
			DPF(9,"ISend: Wait==> %x\n",pSend->hEvent);
			Wait(pSend->hEvent);
			
			if(!(pSend->dwFlags & DPSEND_GUARANTEED)){
				ENTER_DPLAY();
			}

			DPF(9,"ISend: <== WAIT\n");
			hr=pSend->Status;
		} else {
			hr=DPERR_PENDING;
		}

	} else {
		DecSendRef(pProtocol, pSend); //not going to complete a send that didn't enqueue.
	}
	
	DecSendRef(pProtocol,pSend);

	return hr;
}


HRESULT QueueSendOnSession(
	PPROTOCOL pProtocol, PSESSION pSession, PSEND pSend
)
{
	BILINK *pBilink;                // walks the links scanning priority    
	BILINK *pPriQLink;      // runs links in the global priority queue.
	PSEND   pSendWalker;    // pointer to send structure
	BOOL    fFront;         // if we put this at the front of the CON SendQ
	BOOL    fSignalQ=TRUE;  // whether to signal the sendQ

	// NOTE: locking global and connection queues concurrently,
	//         -> this better be fast!
	ASSERT_SIGN(pSend, SEND_SIGN);
	
	Lock(&pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);
	Lock(&pSend->SendLock);

	if(pSession->eState != Open){
		Unlock(&pSend->SendLock);
		Unlock(&pSession->SessionLock);
		Unlock(&pProtocol->m_SendQLock);
		return DPERR_CONNECTIONLOST;
	}

	if(!(pSend->dwFlags & ASEND_PROTOCOL)){
		pProtocol->m_dwBytesPending += pSend->MessageSize;
		pProtocol->m_dwMessagesPending += 1;
	}	

	// Put on Connection SendQ

	// First Check if we are highest priority.
	pBilink = pSession->SendQ.next;
	pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
	if(pBilink == &pSession->SendQ || pSendWalker->Priority < pSend->Priority)
	{
		InsertAfter(&pSend->SendQ,&pSession->SendQ);
		fFront=TRUE;
		
	} else {

		// Scan backwards through the SendQ until we find a Send with a higher
		// or equal priority and insert ourselves afterwards.  This is optimized
		// for the same pri send case.
	
		pBilink = pSession->SendQ.prev;

		while(TRUE /*pBilink != &pSend->SendQ*/){
		
			pSendWalker = CONTAINING_RECORD(pBilink, SEND, SendQ);
			
			ASSERT_SIGN(pSendWalker, SEND_SIGN);

			if(pSend->Priority <= pSendWalker->Priority){
				InsertAfter(&pSend->SendQ, &pSendWalker->SendQ);
				fFront=FALSE;
				break;
			}
			pBilink=pBilink->prev;
		}
		
		ASSERT(pBilink != &pSend->SendQ);
	}

	//
	// Put on Global SendQ
	//

	if(!fFront){
		// We queued it not at the front, therefore there are already
		// entries in the Global Queue and we need to be inserted 
		// after the entry that we are behind, so start scanning the
		// global queue backwards from the packet ahead of us in the
		// Connection Queue until we find a lower priority packet

		// get pointer into previous packet in queue.
		pBilink=pSend->SendQ.prev;
		// get pointer to the PriorityQ record of the previous packet.
		pPriQLink = &(CONTAINING_RECORD(pBilink, SEND, SendQ))->m_GSendQ;

		while(pPriQLink != &pProtocol->m_GSendQ){
			pSendWalker = CONTAINING_RECORD(pPriQLink, SEND, m_GSendQ);
			
			ASSERT_SIGN(pSendWalker, SEND_SIGN);

			if(pSendWalker->Priority < pSend->Priority){
				InsertBefore(&pSend->m_GSendQ, &pSendWalker->m_GSendQ);
				break;
			}
			pPriQLink=pPriQLink->next;
		}
		if(pPriQLink==&pProtocol->m_GSendQ){
			// put at the end of the list.
			InsertBefore(&pSend->m_GSendQ, &pProtocol->m_GSendQ);
		}
		
	} else {
		// There was no-one in front of us on the connection.  So
		// we look at the head of the global queue first and then scan 
		// from the back.

		pBilink = pProtocol->m_GSendQ.next;
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		
		if(pBilink == &pProtocol->m_GSendQ ||  pSend->Priority > pSendWalker->Priority)
		{
			InsertAfter(&pSend->m_GSendQ,&pProtocol->m_GSendQ);
		} else {
			// Scan backwards through the m_GSendQ until we find a Send with a higher
			// or equal priority and insert ourselves afterwards.  This is optimized
			// for the same pri send case.
			
			pBilink = pProtocol->m_GSendQ.prev;

			while(TRUE){
				pSendWalker = CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
				
				ASSERT_SIGN(pSendWalker, SEND_SIGN);
				
				if(pSend->Priority <= pSendWalker->Priority){
					InsertAfter(&pSend->m_GSendQ, &pSendWalker->m_GSendQ);
					break;
				}
				pBilink=pBilink->prev;
			}
			
			ASSERT(pBilink != &pProtocol->m_GSendQ);
		}
		
	}

	// Fixup send state if we are blocking other sends on the session.

	if(pSend->dwFlags & DPSEND_GUARANTEED){
		if(pSession->nWaitingForMessageid){
			DPF(8,"pSession %x, pSend %x Waiting For Id\n",pSession,pSend);
			pSend->SendState=WaitingForId;
			InterlockedIncrement(&pSession->nWaitingForMessageid);
			#ifdef DEBUG
				if(pSession->nWaitingForMessageid > 300)
				{
					DPF(0,"Session %x nWaitingForMessageid is %d, looks like trouble, continue to dump session\n",pSession, pSession->nWaitingForMessageid);
					//DEBUG_BREAK();
					//DumpSession(pSession);
					//DEBUG_BREAK();
				}		
			#endif
			fSignalQ=FALSE;
		}
	} else {
		if(pSession->nWaitingForDGMessageid){
			DPF(8,"pSession %x, pSend %x Waiting For Id\n",pSession,pSend);
			pSend->SendState=WaitingForId;
			InterlockedIncrement(&pSession->nWaitingForDGMessageid);
			fSignalQ=FALSE;
		}       
	}


#ifdef DEBUG
	DPF(9,"SessionQ:");
	pBilink=pSession->SendQ.next;
	while(pBilink!=&pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		ASSERT_SIGN(pSendWalker,SEND_SIGN);
		DPF(9,"Send %x pSession %x Pri %x State %d\n",pSendWalker,pSendWalker->pSession,pSendWalker->Priority,pSendWalker->SendState);
		pBilink=pBilink->next;
	}
	DPF(9,"GlobalQ:");
	pBilink=pProtocol->m_GSendQ.next;
	while(pBilink!=&pProtocol->m_GSendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		ASSERT_SIGN(pSendWalker,SEND_SIGN);
		DPF(9,"Send %x pSession %x Pri %x State %d\n",pSendWalker,pSendWalker->pSession,pSendWalker->Priority,pSendWalker->SendState);
		pBilink=pBilink->next;
	}
#endif

	Unlock(&pSend->SendLock);
	Unlock(&pSession->SessionLock);
	Unlock(&pProtocol->m_SendQLock);

	if(fSignalQ){
		// tell send thread to process.
		SetEvent(pProtocol->m_hSendEvent);
	}       

	return DP_OK;
}

/*=============================================================================

	CopyDataToFrame
     
    Description:

		Copies data for a frame from the Send to the frame's data area. 

    Parameters:     

		pFrameData              - pointer to data area
		FrameDataSize   - Size of the Frame Data area
		pSend                   - send from which to get data
		nAhead          - number of frames ahead of NR to get data for.
		
    Return Values:

		Number of bytes copied.


	Notes: 

		Send must be locked across this call.
		
-----------------------------------------------------------------------------*/

UINT CopyDataToFrame(
	PUCHAR  pFrameData, 
	UINT    FrameDataLen,
	PSEND   pSend,
	UINT    nAhead)
{
	UINT    BytesToAdvance, BytesToCopy;
	UINT    FrameOffset=0;
	PUCHAR  dest,src;
	UINT    len;
	UINT    totlen=0;

	UINT    SendOffset;
	PBUFFER pSrcBuffer;
	UINT    CurrentBufferOffset;

	BytesToAdvance      = nAhead*FrameDataLen;
	SendOffset          = pSend->SendOffset;
	pSrcBuffer          = pSend->pCurrentBuffer;
	CurrentBufferOffset = pSend->CurrentBufferOffset;

	//
	// Run ahead to the buffer we start getting data from
	//

	while(BytesToAdvance){

		len = pSrcBuffer->len - CurrentBufferOffset;

		if(len > BytesToAdvance){
			CurrentBufferOffset += BytesToAdvance;
			SendOffset+=BytesToAdvance;
			BytesToAdvance=0;
		} else {
			pSrcBuffer=pSrcBuffer->pNext;
			CurrentBufferOffset = 0;
			BytesToAdvance-=len;
			SendOffset+=len;
		}
	}

	//
	// Copy the data for the Send into the frame
	//

	BytesToCopy = pSend->MessageSize - SendOffset;

	if(BytesToCopy > FrameDataLen){
		BytesToCopy=FrameDataLen;
	}

	while(BytesToCopy){

		ASSERT(pSrcBuffer);
		
		dest= pFrameData        + FrameOffset;
		src = pSrcBuffer->pData + CurrentBufferOffset;
		len = pSrcBuffer->len   - CurrentBufferOffset;

		if(len > BytesToCopy){
			len=BytesToCopy;
			CurrentBufferOffset+=len;//OPTIMIZATION?: not used after, don't need.
		} else {
			pSrcBuffer = pSrcBuffer->pNext;
			CurrentBufferOffset = 0;
		}

		BytesToCopy -= len;
		FrameOffset += len;
		totlen+=len;
		
		memcpy(dest,src,len);
	}
	
	return totlen;
}

// NOTE: ONLY 1 SEND THREAD ALLOWED.
ULONG WINAPI SendThread(LPVOID pProt)
{
	PPROTOCOL pProtocol=((PPROTOCOL)pProt);
	UINT  SendRc;

	while(TRUE){

		WaitForSingleObject(pProtocol->m_hSendEvent, INFINITE);

		Lock(&pProtocol->m_ObjLock);
		
		if(pProtocol->m_eState==ShuttingDown){
			Unlock(&pProtocol->m_ObjLock);
			// Make sure nothing is still waiting to timeout on the queue
			do {
				SendRc=SendHandler(pProtocol);
			} while (SendRc!=DPERR_NOMESSAGES);
			Lock(&pProtocol->m_ObjLock);
			pProtocol->m_nSendThreads--;
			Unlock(&pProtocol->m_ObjLock);
			ExitThread(0);
		}

		Unlock(&pProtocol->m_ObjLock);

		do {
			SendRc=SendHandler(pProtocol);
		} while (SendRc!=DPERR_NOMESSAGES);

	}
	return TRUE;
}


// Called with SendLock held.
VOID CancelRetryTimer(PSEND pSend)
{
//	UINT mmError;
	UINT retrycount=0;
	UINT_PTR uRetryTimer;
	UINT Unique;
	
	
	if(pSend->uRetryTimer){
		DPF(9,"Canceling Timer %x\n",pSend->uRetryTimer);

		// Delete it from the list first so we don't deadlock trying to kill it.
		Lock(&g_SendTimeoutListLock);

		uRetryTimer=pSend->uRetryTimer;
		Unique=pSend->TimerUnique;
		pSend->uRetryTimer=0;
	
		if(!EMPTY_BILINK(&pSend->TimeoutList)){
			Delete(&pSend->TimeoutList);
			InitBilink(&pSend->TimeoutList); // avoids DecSendRef having to know state of bilink.
			Unlock(&g_SendTimeoutListLock);

			CancelMyTimer(uRetryTimer, Unique);

		} else {
		
			Unlock(&g_SendTimeoutListLock);
		}
		
	} else {
		DPF(9,"CancelRetryTimer:No timer to cancel.\n");
	}
}

// Workaround for Win95 mmTimers:
// ==============================
//
// We cannot use a reference count for the timeouts as a result of the following Win95 bug:
//
// The cancelling of mmTimers is non-deterministic.  That is, when calling cancel, you cannot
// tell from the return code whether the timer ran, was cancelled or is still going to run.  
// Since we use the Send as the context for timeout, we cannot dereference it until we make 
// sure it is still valid, since code that cancelled the send and timer may have already freed 
// the send memory.  We place the sends being timed out on a list and scan the list for the
// send before we use it.  If we don't find the send on the list, we ignore the timeout.
//
// Also note, this workaround is not very expensive.  The linked list is in the order timeouts
// were scheduled, so generally if the links are approximately the same speed, timeouts will
// be similiar so the context being checked should be near the beginning of the list.


CRITICAL_SECTION g_SendTimeoutListLock;
BILINK g_BilinkSendTimeoutList;

void CALLBACK RetryTimerExpiry( UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2 )
{
	PSEND pSend=(PSEND)(dwUser), pSendWalker;
	UINT  tWaiting;
	BILINK *pBilink;
	UINT    bFound=FALSE;

	DPF(9,"RetryTimerExpiry: %x, expecting %x, pSend %x\n",uID, pSend->uRetryTimer, pSend);

	tWaiting=timeGetTime();

	// Scan the list of waiting sends to see if this one is still waiting for a timeout.
	Lock(&g_SendTimeoutListLock);

	pBilink=g_BilinkSendTimeoutList.next;

	while(pBilink!=&g_BilinkSendTimeoutList){
	
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, TimeoutList);
		pBilink=pBilink->next;
		
		if(pSendWalker == pSend){
			if(pSend->uRetryTimer==uID){
				Delete(&pSend->TimeoutList);
				InitBilink(&pSend->TimeoutList); // avoids DecSendRef having to know state of bilink.
				Unlock(&g_SendTimeoutListLock);
				// it is ok to call AddSendRef here without the sessionlock because
				// there is no way we could be adding the session reference.  If
				// the refcount is 0, it can only mean the send is already cleaning up
				// and we won't try to take the session locks so there is no lock
				// ordering problem.
				bFound=AddSendRef(pSend,1); // note bFound set to Refcount on send
				goto skip_unlock;
			}       
		}
	}
	
	Unlock(&g_SendTimeoutListLock);

skip_unlock:
	if(bFound){

		if(pSend->tRetryScheduled - pSend->tScheduled > 500){
			DWORD tm=timeGetTime();
			if(tm - pSend->tScheduled < 100 ){
				DPF(9,"RETRY TIMER EXPIRY IS WAY TOO EARLY, EXPECTED AT %x ACTUALLY AT %x\n",pSend->tRetryScheduled, tm);
				DEBUG_BREAK();
			}
		}
	
		DPF(9,"RetryTimerExpiry: Waiting For Send Lock...\n");

		Lock(&pSend->SendLock);

		DPF(9,"RetryTimerExpiry: Got SendLock\n");

		if(pSend->uRetryTimer==uID){ // check again, may be cancelled.
		
			pSend->uRetryTimer=0;

			switch(pSend->SendState)
			{
				case Start:             
				case Sending:   
					ASSERT(0);
				case Done:
					break;
					
				case WaitingForAck:

					pSend->RetryCount++;
					tWaiting-=pSend->tLastACK;

#ifdef DEBUG
					{
						static int retries;
						IN_WRITESTATS InWS;
						memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
					 	InWS.stat_USER1=((retries++)%20)+1;
						DbgWriteStats(&InWS);
					}
#endif

					if(tWaiting > pSend->pSession->MaxDropTime ||
					   (pSend->RetryCount > pSend->pSession->MaxRetry && tWaiting > pSend->pSession->MinDropTime)
					  )
					{
						DPF(8,"Send %x Timed Out, tWaiting: %d RetryCount: %d\n",pSend,tWaiting,pSend->RetryCount);
						pSend->SendState=TimedOut;
					} else {
						DPF(9,"Timer expired, retrying send %x RetryCount= %d\n",pSend,pSend->RetryCount);
						//pSend->NACKMask|=(1<<(pSend->NS-pSend->NR))-1;
						pSend->NACKMask |= 1; // just retry 1 frame.
						ASSERT_NACKMask(pSend);
						pSend->SendState=ReadyToSend;
					}       
					SetEvent(pSend->pSession->pProtocol->m_hSendEvent);
					break;
					
				case Throttled: 
					break;
				
				case ReadyToSend:
				default:
					break;

			}
		} 
		
		Unlock(&pSend->SendLock);
		DecSendRef(pSend->pSession->pProtocol, pSend);
	}       
}

VOID StartRetryTimer(PSEND pSend)
{
	UINT FptLatency;
	UINT tLatencyLong;
	UINT FptDev;
	UINT tRetry;

	FptLatency=max(pSend->pSession->FpLocalAverageLatency,pSend->pSession->LastLatency);
	FptDev=pSend->pSession->FpLocalAvgDeviation;
	tRetry=unFp(FptLatency+3*FptDev);//Latency +3 average deviations

	tLatencyLong=unFp(pSend->pSession->FpAverageLatency);

	// Sometimes stddev of latency gets badly skewed by the serial driver
	// taking a long time to complete locally, avoid setting retry time
	// too high by limiting to 2x the long latency average.
	if(tLatencyLong > 100 && tRetry > 2*max(tLatencyLong,unFp(FptLatency))){
		tRetry = 2*tLatencyLong;
	}

	if(pSend->RetryCount > 3){
		if(pSend->pSession->RemoteBytesReceived==0){
			// haven't spoken to remote yet, may be waiting for nametable, so back down hard.
			tRetry=5000;
		} else if (tRetry < 1000){
			// taking a lot of retries to get response, back down.
			tRetry=1000;
		}
	}

	if(tRetry < 50){
		tRetry=50;
	}
	
	ASSERT(tRetry);

	if(tRetry > 30000){
		DPF(0,"RETRY TIMER REQUESTING %d seconds?\n",tRetry);
	}
	
	if(!pSend->uRetryTimer){

		Lock(&g_SendTimeoutListLock);

		DPF(9,"Setting Retry Timer of %d ms\n", tRetry);

		pSend->uRetryTimer=SetMyTimer((tRetry)?(tRetry):1,(tRetry>>2)+1,RetryTimerExpiry,(ULONG_PTR) pSend,&pSend->TimerUnique);
		
		if(pSend->uRetryTimer){
			pSend->tScheduled = timeGetTime();
			pSend->tRetryScheduled = pSend->tScheduled+tRetry;
			InsertBefore(&pSend->TimeoutList, &g_BilinkSendTimeoutList);
		} else {
			DPF(0,"Start Retry Timer failed to schedule a timer with tRetry=%d for pSend %x\n",tRetry,pSend);
			DEBUG_BREAK();
		}
		
		DPF(9,"Started Retry Timer %x\n",pSend->uRetryTimer);                                                            

		Unlock(&g_SendTimeoutListLock);
										 
		if(!pSend->uRetryTimer){
			ASSERT(0);
		}
		
	} else {
		ASSERT(0);
	}

}

// Called with all necessary locks held.
VOID TimeOutSession(PSESSION pSession)
{
	PSEND pSend;
	BILINK *pBilink;
	UINT nSignalsRequired=0;

	// Mark Session Timed out.
	pSession->eState=Closing;
	// Mark all sends Timed out.
	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ){
	
		pSend=CONTAINING_RECORD(pBilink, SEND, SendQ);
		pBilink=pBilink->next;

		DPF(9,"TimeOutSession: Force Timing Out Send %x, State %d\n",pSend, pSend->SendState);

		switch(pSend->SendState){
		
			case Start:
			case Throttled:
			case ReadyToSend:
				DPF(9,"TimeOutSession: Moving to TimedOut, should be safe\n");
				pSend->SendState=TimedOut;
				nSignalsRequired += 1;
				break;
				
			case Sending:
				// can we even get here?  If we can this is probably not good
				// since the send will reset the retry count and tLastACK.
				DPF(9,"TimeOutSession: ALLOWING TimeOut to cancel.(could take 15 secs)\n");
				pSend->RetryCount=pSession->MaxRetry;
				pSend->tLastACK=timeGetTime()-pSession->MinDropTime;
				break;

			case WaitingForAck:
				DPF(9,"TimeOutSession: Canceling timer and making TimedOut\n");
				CancelRetryTimer(pSend);
				pSend->SendState = TimedOut;
				nSignalsRequired += 1;
				break;
				
			case WaitingForId:
				// Note, this means we can get signals for ids that aren't used.
				DPF(9,"TimeOutSession: Timing Out Send Waiting for ID, GetNextMessageToSend may fail, this is OK\n");
				pSend->SendState=TimedOut;
				if(pSend->dwFlags & DPSEND_GUARANTEED){
					InterlockedDecrement(&pSession->nWaitingForMessageid);
				} else {
					InterlockedDecrement(&pSession->nWaitingForDGMessageid);
				}
				nSignalsRequired += 1;
				break;
				
			case TimedOut:
			case Done:
				DPF(9,"TimeOutSession: Send already done or timed out, doesn't need our help\n");
				break;
				
			default:
				DPF(0,"TimeOutSession, pSession %x found Send %x in Wierd State %d\n",pSession,pSend,pSend->SendState);
				ASSERT(0);
				break;
		} /* switch */

	} /* while */

	// Create enough signals to process timed out sends.
	DPF(9,"Signalling SendQ %d items to process\n",nSignalsRequired);
	SetEvent(pSession->pProtocol->m_hSendEvent);
}

UINT WrapSend(PPROTOCOL pProtocol, PSEND pSend, PBUFFER pBuffer)
{
	PUCHAR pMessage,pMessageStart;
	DWORD dwWrapSize=0;
	DWORD dwIdTo=0;
	DWORD dwIdFrom=0;

	pMessageStart = &pBuffer->pData[pProtocol->m_dwSPHeaderSize];
	pMessage      = pMessageStart;
	dwIdFrom      = pSend->wIdFrom;
	dwIdTo        = pSend->wIdTo;
	
	if(dwIdFrom==0x70){ // avoid looking like a system message 'play'
		dwIdFrom=0xFFFF;
	}

	if(dwIdFrom){
		while(dwIdFrom){
			*pMessage=(UCHAR)(dwIdFrom & 0x7F);
			dwIdFrom >>= 7;
			if(dwIdFrom){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

	if(dwIdTo){
		while(dwIdTo){
			*pMessage=(UCHAR)(dwIdTo & 0x7F);
			dwIdTo >>= 7;
			if(dwIdTo){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

#if 0	// a-josbor: for debugging only.  I left it in in case we ever needed it again
	ExtractProtocolIds(pMessageStart, &dwIdFrom, &dwIdTo);
	ASSERT(dwIdFrom == pSend->wIdFrom);
	ASSERT(dwIdTo == pSend->wIdTo);
#endif

	return (UINT)(pMessage-pMessageStart);
}       

#define DROP 0

#if DROP
// 1 for send, 0 for drop.

char droparray[]= {
	1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0,0,0,0};

UINT dropindex=0;
#endif

VOID CALLBACK UnThrottle(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	PSESSION pSession=(PSESSION)dwUser;
	UINT tMissedBy;		// how long we missed the throttle by.
	DWORD tm;

	Lock(&pSession->SessionLock);

	tm=timeGetTime();
	tMissedBy = tm-pSession->tNextSend;

	if( (int)tMissedBy > 0){
		pSession->FpAvgUnThrottleTime -= pSession->FpAvgUnThrottleTime >> 4;
		pSession->FpAvgUnThrottleTime += (Fp(tMissedBy) >> 4);
		DPF(9,"Missed by: %d ms Avg Unthrottle Miss %d.%d ms\n", tMissedBy, pSession->FpAvgUnThrottleTime >> 8, (((pSession->FpAvgUnThrottleTime&0xFF)*100)/256) );
		
	}
	
	pSession->uUnThrottle=0;
	pSession->dwFlags |= SESSION_UNTHROTTLED; 
	pSession->pProtocol->m_bRescanQueue=TRUE;	// tell send routine to restart scan.
	DPF(9,"Unthrottling Session %x at %d\n",pSession, timeGetTime());
	Unlock(&pSession->SessionLock);
	SetEvent(pSession->pProtocol->m_hSendEvent);
	DecSessionRef(pSession);
}

VOID Throttle( PSESSION pSession, DWORD tm )
{
	DWORD tmDelta;
	Lock(&pSession->SessionLock);
		pSession->bhitThrottle=TRUE;
		pSession->dwFlags |= SESSION_THROTTLED;
		tmDelta = pSession->tNextSend - tm;
		if((INT)tmDelta < 0){
			tmDelta=1;
		}
		DPF(9,"Throttling pSession %x for %d ms (until %d)\n",pSession, tmDelta,pSession->tNextSend);
		InterlockedIncrement(&pSession->RefCount);
		pSession->uUnThrottle = SetMyTimer(tmDelta, (tmDelta>>2)?(tmDelta>>2):1, UnThrottle, (DWORD_PTR)pSession, &pSession->UnThrottleUnique);
		if(!pSession->uUnThrottle){
			DPF(0,"UH OH failed to schedule unthrottle event\n");
			DEBUG_BREAK();
		}
	Unlock(&pSession->SessionLock);
#ifdef DEBUG
	{
		static int throttlecounter;
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_USER4=((throttlecounter++)%20)+1;
		DbgWriteStats(&InWS);
	}
#endif
}	

// Given the current time, the bandwidth we are throttling to and the length of the packet we are sending,
// calculate the next time we are allowed to send.  Also keep a residue from this calculation so that
// we don't wind up using excessive bandwidth due to rounding, the residue from the last calculation is
// used in this calculation.

// Absolute flag means set the next send time relative to tm regardless

VOID UpdateSendTime(PSESSION pSession, DWORD Len, DWORD tm, BOOL fAbsolute)
{
	#define SendRate 		pSession->SendRateThrottle
	#define Residue   		pSession->tNextSendResidue
	#define tNext           pSession->tNextSend
	
	DWORD tFrame;		// amount of time this frame will take on the wire.


	tFrame = (Len+Residue)*1000 / SendRate;	// rate is bps, but want to calc bpms, so (Len+Residue)*1000
	
	Residue = (Len+Residue) - (tFrame * SendRate)/1000 ;	
	
	ASSERT(!(Residue&0x80000000)); 	// residue better be +ve

	if(fAbsolute || (INT)(tNext - tm) < 0){
		// tNext is less than tm, so calc based on tm.
		tNext = tm+tFrame;
	} else {
		// tNext is greater than tm, so add more wait.
		tNext = tNext+tFrame;
	}

	DPF(8,"UpdateSendTime time %d, tFrame %d, Residue %d, tNext %d",tm,tFrame,Residue,tNext);


	#undef SendRate
	#undef Residue
	#undef tNext
}			

//CHAR Drop[]={0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0};
//DWORD DropSize = sizeof(Drop);
//DWORD iDrop=0;

// AO - added contraint, 1 send thread per session.  Since this is not enforced by GetNextMessageToSend
// 5-21-98  we are effectively restricted to 1 send thread for the protocol.  We can fix this by adding
//      a sending state on the session and having GetNextMessageToSend skip sending sessions.
HRESULT ReliableSend(PPROTOCOL pProtocol, PSEND pSend)
{
	#define pBigFrame ((pPacket2)(pFrame))

	HRESULT  hr;
	PBUFFER  pBuffer;

	pPacket1  pFrame;
	PUCHAR   pFrameData;
	UINT     FrameDataLen;
	UINT     FrameTotalLen;
	UINT     MaxFrameLen;
	UINT     FrameHeaderLen;

	UINT     nFramesOutstanding;
	UINT     nFramesToSend;
	UINT     msk;
	UINT     shift;

	UINT     WrapSize;
	UINT     DPWrapSize;      // DirectPlay wrapping only. ([[DPLAY 0xFF]|],From,To)
	DWORD    tm=0;			  // The time, 0 if we haven't retrieved it yet.
	DWORD    tmExit=0;
	BOOL     bExitEarly=FALSE;

	DPSP_SENDDATA SendData;
	
	//
	// Sending algorithm is designed to handle NACKs only (there
	// is no special case for sending data the first time).  So
	// We send by making it look like the frames we want to send
	// have been NACKed.  Every frame we send, we clear the NACK
	// bit for.  If an actual NACK comes in, the bit is set.
	// When an ACK comes in, we shift the NACK and ACK masks
	// nACK-NR and if applicable, set new NACK bits.
	//

	Lock(&pSend->SendLock);

	if(pSend->SendState == Done){
		goto unlock_exit;
	}       


	nFramesOutstanding=(pSend->NS-pSend->NR);

	if( nFramesOutstanding < pSend->WindowSize){

		// Set NACK bits up to WindowSize (unless over nFrames);
		
		nFramesToSend=pSend->WindowSize-nFramesOutstanding;

		if(nFramesToSend > pSend->nFrames-pSend->NS){
			nFramesToSend=pSend->nFrames-pSend->NS;
		}

		pSend->NACKMask |= ((1<<nFramesToSend)-1)<<nFramesOutstanding;
		pSend->OpenWindow = nFramesOutstanding + nFramesToSend;
		DPF(9,"Send: pSend->NACKMask %x, OpenWindow %d\n",pSend->NACKMask, pSend->OpenWindow);
		
	}

	tmExit=timeGetTime()+1000; // always blow out of here in 1 second max.
	
Reload:
	msk=1;
	shift=0;
	
	MaxFrameLen=pSend->FrameSize;

	while(pSend->NACKMask){
	
		ASSERT_NACKMask(pSend);
		
		tm=timeGetTime();		// Getting the time is relatively expensive, so we do it once here and pass it around.

		if(((INT)tm - (INT)tmExit) > 0){
			DPF(0,"Breaking Out of Send Loop due to expiry of timer\n");
			bExitEarly=TRUE;
			break;
		}

	#if 1
		if((tm+unFp(pSend->pSession->FpAvgUnThrottleTime)-pSend->pSession->tNextSend) & 0x80000000){
			// we're still too early to do the next send, so throttled this session.
			goto throttle_exit;
		}
	#endif	


		if(pSend->NACKMask & msk){

			pBuffer=GetFrameBuffer(MaxFrameLen+pProtocol->m_dwSPHeaderSize+MAX_SEND_HEADER);
			
			if(!pBuffer){
    			pSend->SendState=ReadyToSend;
	    		SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
				hr=DPERR_PENDING;
				goto exit;
			}

			WrapSize=pProtocol->m_dwSPHeaderSize;              // leave space for SP header.
			DPWrapSize=WrapSend(pProtocol, pSend, pBuffer); // fill in out address wrapping
			WrapSize+=DPWrapSize;

			pFrame=(pPacket1)&pBuffer->pData[WrapSize];    // protocol header after wrapping
			
			if(pSend->fSendSmall){
				pFrameData=&pFrame->data[0];
				FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
			} else {
				pFrameData=&pBigFrame->data[0];
				FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
			}

			// For calculating nFrames, we assumed MAX_SEND_HEADER, subtract out the unused portion
			// so we don't put to much data in the frame and mess up the accounting.
			pBuffer->len-=(MAX_SEND_HEADER-(FrameHeaderLen+DPWrapSize)); 

			FrameHeaderLen += WrapSize;     // now include wrapping and SPheader space.
			
			FrameDataLen=CopyDataToFrame(pFrameData, pBuffer->len-FrameHeaderLen, pSend, shift);

			if(!pSend->FrameDataLen){
				pSend->FrameDataLen=FrameDataLen;
			}       
			
			FrameTotalLen=FrameDataLen+FrameHeaderLen;

			pSend->BytesThisSend=FrameTotalLen-WrapSize; //only counting payload

			// Do that protocol thing
			BuildHeader(pSend,pFrame,shift,tm);

			// we know we don't have to check here since we have a reference
			// from finding the send to work on ON the send queue.  So it
			// can't go away til we return from this function.
			hr=AddSendRef(pSend,1);
			ASSERT(hr);
			
			if(pSend->NR+shift >= pSend->NS){
				pSend->NS = pSend->NR+shift+1;
			}       
			pSend->NACKMask &= ~msk;
			
			DPF(9,"S %2x %2x %2x\n",pBuffer->pData[0], pBuffer->pData[1], pBuffer->pData[2]);

			// Update the next time we are allowed to send.
			UpdateSendTime(pSend->pSession, pSend->BytesThisSend, tm, FALSE);

			Unlock(&pSend->SendLock);

			ASSERT(!(FrameTotalLen &0xFFFF0000));

			
			// Send this puppy...

			SendData.dwFlags        = pSend->dwFlags & ~DPSEND_GUARANTEED;
			SendData.idPlayerTo     = pSend->idTo;
			SendData.idPlayerFrom   = pSend->idFrom;
			SendData.lpMessage      = pBuffer->pData;
			SendData.dwMessageSize  = FrameTotalLen;
			SendData.bSystemMessage = 0;
			SendData.lpISP          = pProtocol->m_lpISP;

			ENTER_DPLAY();

			Lock(&pProtocol->m_SPLock);

		//	if(!(Drop[(iDrop++)%DropSize])){//DEBUG ONLY!

				hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 
		//	}

			Unlock(&pProtocol->m_SPLock);

			LEAVE_DPLAY();

  #ifdef DEBUG
    if(hr != DPERR_PENDING && hr != DP_OK){
        DPF(0,"Wierd error %x from unreliable send in SP\n",hr);
        //DEBUG_BREAK();
    }
  #endif
			
			if(hr!=DPERR_PENDING){
				FreeFrameBuffer(pBuffer);
				if(!DecSendRef(pProtocol, pSend)){
					ASSERT(0);
					hr=DPERR_PENDING;
					goto exit;
				}
				if(hr != DP_OK){
					Lock(&pSend->SendLock);
					pSend->SendState = TimedOut; // kill the connection.
					SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
					break;
				}
			}

			Lock(&pSend->SendLock);
		
		} /* endif (pSend->NACKMask & msk) */

		if(pSend->fUpdate){
			pSend->fUpdate=FALSE;
			goto Reload;
		}

		// Check if we are past windowsize, if so roll back the mask
		// Also if there are earlier bits to ACK.
		if((msk<<=1UL) >= (1UL<<pSend->WindowSize)){
			msk=1;
			shift=0;
		} else {
			shift++;
		}
		

	} /* end while (pSend->NACKMask) */

	if(pSend->SendState != Done && pSend->SendState != TimedOut){

		if(bExitEarly){
			pSend->SendState=ReadyToSend;
			SetEvent(pSend->pSession->pProtocol->m_hSendEvent); // keep the queue rolling.
		} else {
			pSend->SendState=WaitingForAck;
			StartRetryTimer(pSend);
		}	
	} else {
		// We have timed out the send due to killing the session, or
		// we got the final ACK, either way, don't touch the SendState
	}

unlock_exit:
	Unlock(&pSend->SendLock);

	hr=DPERR_PENDING; // Reliable sends are completed by the ACK.


	
exit:
	return hr;

throttle_exit:

	hr=DPERR_PENDING;
	
	pSend->SendState=Throttled;
	Unlock(&pSend->SendLock);

	Throttle(pSend->pSession, tm);

	return hr;
	
	#undef pBigFrame        
}

// TRUE, didn't reach end, FALSE, no more to send.
BOOL AdvanceSend(PSEND pSend, UINT AckedLen)
{
	BOOL rc=TRUE;

	// quick short circuit for small messages.
	if(AckedLen+pSend->SendOffset==pSend->MessageSize){
		rc=FALSE;
		goto exit;
	}
	
	if(pSend->SendOffset+AckedLen > pSend->MessageSize){
		AckedLen=pSend->MessageSize-pSend->SendOffset;
	}
		
	pSend->SendOffset+=AckedLen;
	
	while(AckedLen){
		if(pSend->pCurrentBuffer->len-pSend->CurrentBufferOffset >= AckedLen){
			pSend->CurrentBufferOffset+=AckedLen;
			rc=TRUE;
			break;
		} else {
			AckedLen -= (pSend->pCurrentBuffer->len-pSend->CurrentBufferOffset);
			pSend->pCurrentBuffer=pSend->pCurrentBuffer->pNext;
			pSend->CurrentBufferOffset=0;
			rc=FALSE;
		}
	}

exit:
	return rc;
}

HRESULT DGSend(PPROTOCOL pProtocol, PSEND  pSend)
{
	#define pBigFrame ((pPacket2)(pFrame))
	
	PBUFFER  pBuffer;

	pPacket1 pFrame;
	PUCHAR   pFrameData;
	UINT     FrameDataLen;
	UINT     FrameHeaderLen;
	UINT     FrameTotalLen;
	UINT     MaxFrameLen;

	UINT     nFramesToSend;

	UINT     WrapSize;
	UINT     DPWrapSize;      // DirectPlay wrapping only. ([[DPLAY 0xFF]|],From,To)

	DPSP_SENDDATA SendData;

	DWORD    tm;
	HRESULT  hr;
	
	Lock(&pSend->SendLock);

	nFramesToSend=pSend->nFrames-pSend->NR;

	MaxFrameLen=pSend->FrameSize;

	while(nFramesToSend){

		tm=timeGetTime();		// Getting the time is relatively expensive, so we do it once here and pass it around.
#if 1		
		if((tm+unFp(pSend->pSession->FpAvgUnThrottleTime)-pSend->pSession->tNextSend) & 0x80000000){
			// we're still too early to do the next send, so throttled this session.
			goto throttle_exit;
		}
#endif
		pBuffer=GetFrameBuffer(MaxFrameLen+pProtocol->m_dwSPHeaderSize+MAX_SEND_HEADER);
		
		if(!pBuffer){
			hr=DPERR_PENDING;
			goto exit;
		}

		WrapSize=pProtocol->m_dwSPHeaderSize;              // leave space for SP header.
		DPWrapSize=WrapSend(pProtocol, pSend, pBuffer); // fill in out address wrapping
		WrapSize+=DPWrapSize;

		pFrame=(pPacket1)&pBuffer->pData[WrapSize];    // protocol header after wrapping
		
		if(pSend->fSendSmall){
			pFrameData=&pFrame->data[0];
			FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
		} else {
			pFrameData=&pBigFrame->data[0];
			FrameHeaderLen=(UINT)(pFrameData-(PUCHAR)pFrame);
		}

		// For calculating nFrames, we assumed MAX_SEND_HEADER, subtract out the unused portion
		// so we don't put to much data in the frame and mess up the accounting.
		pBuffer->len-=(MAX_SEND_HEADER-(FrameHeaderLen+DPWrapSize)); 

		FrameHeaderLen += WrapSize;     // now include wrapping and SPheader space.

		FrameDataLen=CopyDataToFrame(pFrameData, pBuffer->len-FrameHeaderLen, pSend, 0);

		FrameTotalLen=FrameDataLen+FrameHeaderLen;
		
		pSend->BytesThisSend=FrameTotalLen-WrapSize; //only counting payload
		
		// Do that protocol thing
		BuildHeader(pSend,pFrame,0,tm);

		//AddSendRef(pSend,1); //already locked, so just add one.
		ASSERT(pSend->RefCount); //verifies ++ below is ok.
		InterlockedIncrement((PLONG)&pSend->RefCount);  

		UpdateSendTime(pSend->pSession,pSend->BytesThisSend,tm,FALSE);
		
		Unlock(&pSend->SendLock);

		// Send this puppy...
		ASSERT(!(pSend->dwFlags & DPSEND_GUARANTEED));
		SendData.dwFlags        = pSend->dwFlags;
		SendData.idPlayerTo     = pSend->idTo;
		SendData.idPlayerFrom   = pSend->idFrom;
		SendData.lpMessage      = pBuffer->pData;
		SendData.dwMessageSize  = FrameTotalLen;
		SendData.bSystemMessage = 0;
		SendData.lpISP          = pProtocol->m_lpISP;

		ENTER_DPLAY();
		
		Lock(&pProtocol->m_SPLock);

		hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 

		Unlock(&pProtocol->m_SPLock);

		LEAVE_DPLAY();

  #ifdef DEBUG
    if(hr != DPERR_PENDING && hr != DP_OK){
        DPF(0,"Wierd error %x from unreliable send in SP\n",hr);
        //DEBUG_BREAK();
    }
  #endif
		
		if(hr!=DPERR_PENDING){
			if(!DecSendRef(pProtocol,pSend)){
				// No async send support in Dplay at lower edge,
				// so we should never get here!
				ASSERT(0);
			}
			FreeFrameBuffer(pBuffer);
		}
		
		Lock(&pSend->SendLock);
		
		nFramesToSend--;
		
		AdvanceSend(pSend,FrameDataLen);
		pSend->NR++;
		pSend->NS++;
	}
	
	Unlock(&pSend->SendLock);

	DGCompleteSend(pSend); 

	hr=DPERR_PENDING;  // everything was sent, but already completed by DGCompleteSend

exit:
	return hr;

throttle_exit:
	hr=DPERR_PENDING;

	pSend->SendState=Throttled;
	Unlock(&pSend->SendLock);

	Throttle(pSend->pSession, tm);

	return hr;
	#undef pBigFrame        
}

BOOL DGCompleteSend(PSEND pSend)
{
	UINT bit;
	UINT MsgMask;
	PSESSION pSession;
	
	pSend->SendState=Done;
	pSession=pSend->pSession;

	Lock(&pSession->SessionLock);

	if(!pSend->fSendSmall){
		MsgMask = 0xFFFF;
	} else {
		MsgMask =0xFF;
	}       

	DPF(9,"CompleteSend\n");

	//
	// Update Session information for completion of this send.
	//
	
	bit = ((pSend->messageid-pSession->DGFirstMsg) & MsgMask)-1;

	// clear the message mask bit for the completed send.
	if(pSession->DGOutMsgMask & 1<<bit){
		pSession->DGOutMsgMask &= ~(1<<bit);
	} else {
		return FALSE;
	}
	
	// slide the first message count forward for each low
	// bit clear in Message mask.
	while(pSession->DGLastMsg-pSession->DGFirstMsg){
		if(!(pSession->DGOutMsgMask & 1)){
			pSession->DGFirstMsg=(pSession->DGFirstMsg+1)&MsgMask;
			pSession->DGOutMsgMask >>= 1;
			if(pSession->nWaitingForDGMessageid){
				pSession->pProtocol->m_bRescanQueue=TRUE;
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}       
		} else {
			break;
		}
	}
	
	//
	// Return the Send to the pool and complete the waiting client.
	//

	Unlock(&pSession->SessionLock);
	
	ASSERT(pSend->RefCount);
	
	// Send completed, do completion

	DoSendCompletion(pSend, DP_OK);

	DecSendRef(pSession->pProtocol, pSend); // for completion.

	return TRUE;
}


// Send a fully formatted System packet (ACK, nACK, etc..)
HRESULT SystemSend(PPROTOCOL pProtocol, PSEND  pSend)
{
	PBUFFER  pBuffer;
	DPSP_SENDDATA SendData;
	HRESULT  hr;
	PSESSION pSession;

	pBuffer=pSend->pMessage;

	DPF(9,"System Send pBuffer %x pData %x len %d, idTo %x \n",pBuffer, pBuffer->pData, pBuffer->len, pSend->idTo);
	

	pSession=GetSysSessionByIndex(pProtocol, pSend->wIdTo); // adds a ref on session.
															//      |
	if(!pSession){											//      |
		hr=DPERR_INVALIDPLAYER;								//		|
		goto exit;											//      |
	}														//      |
															//      |
	SendData.idPlayerTo     = pSession->dpid;				//		|
	DecSessionRef(pSession); 								// <----+  frees ref here.
	
	// Send this puppy...
	SendData.dwFlags        = 0;
	SendData.idPlayerFrom   = pSend->idFrom;
	SendData.lpMessage      = pBuffer->pData;
	SendData.dwMessageSize  = pBuffer->len;
	SendData.bSystemMessage = 0;
	SendData.lpISP          = pProtocol->m_lpISP;

	ENTER_DPLAY();
	Lock(&pProtocol->m_SPLock);

	hr=CALLSP(pProtocol->m_lpDPlay->pcbSPCallbacks->Send,&SendData); 

	Unlock(&pProtocol->m_SPLock);

	LEAVE_DPLAY();

#ifdef DEBUG
	if(hr!=DP_OK){
		DPF(0,"UNSUCCESSFUL SEND in SYSTEM SEND, hr=%x\n",hr);
	}
#endif
exit:
	return hr;
	
	#undef pBigFrame        
}

VOID DoSendCompletion(PSEND pSend, INT Status)
{
	#ifdef DEBUG
	if(Status != DP_OK){
		DPF(8,"Send Error pSend %x, Status %x\n",pSend,Status);
	}
	#endif
	if(!(pSend->dwFlags & ASEND_PROTOCOL)){
		EnterCriticalSection(&pSend->pProtocol->m_SendQLock);
		pSend->pProtocol->m_dwBytesPending -= pSend->MessageSize;
		pSend->pProtocol->m_dwMessagesPending -= 1;
		DPF(8,"SC: Messages pending %d\n",pSend->pProtocol->m_dwMessagesPending);
		LeaveCriticalSection(&pSend->pProtocol->m_SendQLock);
	}	

	if(pSend->pAsyncInfo){
		// ASYNC_SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.SendCallBack){
			(*pSend->AsyncInfo.SendCallBack)(pSend->AsyncInfo.CallBackContext,Status);
		}
		if(pSend->AsyncInfo.hEvent){
			DPF(9,"ASYNC_SENDCOMPLETE: Signalling Event %x\n",pSend->AsyncInfo.hEvent);
			SetEvent(pSend->AsyncInfo.hEvent);
		}
	} else if (!(pSend->dwFlags&(ASEND_PROTOCOL|DPSEND_ASYNC))){
		// SYNC_SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.hEvent){
			DPF(9,"SYNC_SENDCOMPLETE: Signalling Event %x\n",pSend->AsyncInfo.hEvent);
			SetEvent(pSend->AsyncInfo.hEvent);
		}
	} else {
		// PROTOCOL INTERNAL ASYNC SEND
		if(pSend->AsyncInfo.pStatus){
			(*pSend->AsyncInfo.pStatus)=Status;
		}       
		if(pSend->AsyncInfo.SendCallBack){
			(*pSend->AsyncInfo.SendCallBack)(pSend->AsyncInfo.CallBackContext,Status);
		}
	}
}

/*=============================================================================

	SendHandler - Send the next message that needs to send packets.
    
    Description:

	Finds a message on the send queue that needs to send packets and deserves
	to use some bandwidth, either because it is highest priority or because
	all the higher priority messages are waiting for ACKs.  Then sends as many
	packets as possible before hitting the throttling limit.

	Returns when the throttle limit is hit, or all packets for this send have
	been sent.

    Parameters:     

		pARPD pObj - pointer to the ARPD object to send packets on.

    Return Values:


-----------------------------------------------------------------------------*/
HRESULT SendHandler(PPROTOCOL pProtocol)
{

	PSEND pSend;    
	HRESULT  hr=DP_OK;
	PSESSION pSession;

	// adds ref to send and session if found
	pSend=GetNextMessageToSend(pProtocol); 

	if(!pSend){
		goto nothing_to_send;
	}

    //DPF(4,"==>Send\n");

	switch(pSend->pSession->eState){

		case Open:
			
			switch(pSend->SendState){
			
				case Done:              // Send handlers must deal with Done.
					DPF(9,"Calling SendHandler for Done Send--should just return\n");
				case Sending:
					//
					// Send as many frames as we can given the window size.
					//

					// Send handlers dump packets on the wire, if they expect
					// to be completed later, they return PENDING in which case
					// their completion handlers must do the cleanup.  If they
					// return OK, it means everything for this send is done and
					// we do the cleanup.
				
					if(pSend->dwFlags & ASEND_PROTOCOL){
						hr=SystemSend(pProtocol, pSend);
					} else if(pSend->dwFlags & DPSEND_GUARANTEE){
						hr=ReliableSend(pProtocol, pSend);
					} else {
						hr=DGSend(pProtocol, pSend);
					}
					break;
					
				case TimedOut:
					hr=DPERR_CONNECTIONLOST;
					pSend->SendState=Done;
					break;

				case Cancelled:
					hr=DPERR_USERCANCEL;
					pSend->SendState=Done;
					break;

				case UserTimeOut:
					hr=DPERR_TIMEOUT;
					pSend->SendState=Done;
					break;

				default:        
					DPF(0,"SendHandler: Invalid pSend %x SendState: %d\n",pSend,pSend->SendState);
					ASSERT(0);
			}               
			break;

		case Closing:
			switch(pSend->SendState){
				case TimedOut:
					DPF(8,"Returning CONNECTIONLOST on timed out message %x\n",DPERR_CONNECTIONLOST);
					hr=DPERR_CONNECTIONLOST;
					break;
					
				default:	
					DPF(8,"Send for session in Closing State, returning %x\n",DPERR_INVALIDPLAYER);
					hr=DPERR_INVALIDPLAYER;
					break;
			}		
			pSend->SendState=Done;
			break;
			
		case Closed:
			DPF(8,"Send for session in Closed State, returning %x",DPERR_INVALIDPLAYER);
			hr=DPERR_INVALIDPLAYER;
			pSend->SendState=Done;
			break;
	}               

    //DPF(4,"<==Send Leaving,rc=%x\n",hr);

	if( hr != DPERR_PENDING ){
		Lock(&pSend->SendLock);
		ASSERT(pSend->RefCount);
		
		//
		// Send completed, do completion
		//
		DoSendCompletion(pSend, hr);

		Unlock(&pSend->SendLock);
		DecSendRef(pProtocol, pSend);   // for completion
	} 

	pSession=pSend->pSession;
	DecSendRef(pProtocol,pSend); // Balances GetNextMessageToSend
	DecSessionRef(pSession); // Balances GetNextMessageToSend
	return hr;

nothing_to_send:
	return DPERR_NOMESSAGES;
}

/*=============================================================================

	Build Header - fill in the frame header for a packet to be sent.
    
    Description:

	Enough space is left in the frame to go on the wire (pFrame) to fit the
	message header.  One of two types of headers is built, depending on the
	value of the fSendSmall field of the packet.  If fSendSmall is TRUE, a compact 
	header is built, this lowers overhead on slow media.  If fSendSmall is FALSE
	a larger header that can support larger windows is built.  The header
	is filled into the front of pFrame.

    Parameters:     

		pARPD pObj - pointer to the ARPD object to send packets on.

    Return Values:


-----------------------------------------------------------------------------*/

VOID BuildHeader(PSEND pSend,pPacket1 pFrame, UINT shift, DWORD tm)
{
	#define pBigFrame ((pPacket2)(pFrame))

	PSENDSTAT pStat=NULL;
	UINT      seq;

	UINT      bitEOM,bitSTA,bitSAK=0;
	DWORD     BytesSent;
	DWORD	  RemoteBytesReceived;
	DWORD     tRemoteBytesReceived;
	DWORD     bResetBias=FALSE;

	// on first frame of a message, set the start bit (STA).
	if(pSend->NR+shift==0){
		bitSTA=STA;
	} else {
		bitSTA=0;
	}

	// on the last frome of a message set the end of message bit (EOM)
	if(pSend->nFrames==pSend->NR+shift+1){
		bitEOM=EOM;
	} else {
		bitEOM=0;
	}

	// if we haven't set EOM and we haven't requested an ACK in 1/4 the
	// round trip latency, set the SAK bit, to ensure we have at least 
	// 2 ACK's in flight for feedback to the send throttle control system.
	// Don't create extra ACKs if round trip is less than 100 ms.
	if(!bitEOM || !(pSend->dwFlags & DPSEND_GUARANTEED)){
		DWORD tmDeltaSAK = tm-pSend->pSession->tLastSAK;
		if(((int)tmDeltaSAK > 50 ) &&
	       (tmDeltaSAK > (unFp(pSend->pSession->FpLocalAverageLatency)>>2))
	      )
		{
			bitSAK=SAK;
		} 
	}

	// If we re-transmitted we need to send a SAK
	// despite the SAK countdown.
	if((!bitSAK) &&
	   (pSend->dwFlags & DPSEND_GUARANTEED) &&
	   ((pSend->NACKMask & (pSend->NACKMask-1)) == 0) &&
	   (bitEOM==0)
	  )
	{
		bitSAK=SAK;
	}

	if(!(--pSend->SAKCountDown)){
		bitSAK=SAK;
	}

	if(bitSAK|bitEOM){
		pSend->pSession->tLastSAK = tm;
		pSend->SAKCountDown=pSend->SAKInterval;
		pStat=GetSendStat();
	}	
	
	if(pSend->fSendSmall){

		pFrame->flags=CMD|bitEOM|bitSTA|bitSAK;
		
		seq=(pSend->NR+shift+1) & pSend->SendSEQMSK;
		pFrame->messageid = (byte)pSend->messageid;
		pFrame->sequence  = (byte)seq;
		pFrame->serial    = (byte)(pSend->serial++);

		if(pStat){
			pStat->serial=pFrame->serial;
		}
		
	} else {
	
		pBigFrame->flags=CMD|BIG|bitEOM|bitSTA|bitSAK;
		
		seq=((pSend->NR+shift+1) & pSend->SendSEQMSK);
		pBigFrame->messageid = (word)pSend->messageid;
		pBigFrame->sequence  = (word)seq;
		pBigFrame->serial    = (byte)pSend->serial++;                           

		if(pStat){
			pStat->serial=pBigFrame->serial;
		}
		
	}

	if(pSend->dwFlags & DPSEND_GUARANTEE){
		pFrame->flags |= RLY;
	}

	// count the number of bytes we have sent.
	Lock(&pSend->pSession->SessionStatLock);
	pSend->pSession->BytesSent+=pSend->BytesThisSend;
	BytesSent=pSend->pSession->BytesSent;
	RemoteBytesReceived=pSend->pSession->RemoteBytesReceived;
	tRemoteBytesReceived=pSend->pSession->tRemoteBytesReceived;
	if(pStat && pSend->pSession->bResetBias &&
	   ((--pSend->pSession->bResetBias) == 0))
	{
		bResetBias=TRUE;			
	}
	Unlock(&pSend->pSession->SessionStatLock);

	if(pStat){
		pStat->sequence=seq;
		pStat->messageid=pSend->messageid;
		pStat->tSent=tm;
		pStat->LocalBytesSent=BytesSent;
		pStat->RemoteBytesReceived=RemoteBytesReceived;
		pStat->tRemoteBytesReceived=tRemoteBytesReceived;
		pStat->bResetBias=bResetBias;
		if(pSend->dwFlags & DPSEND_GUARANTEED){
			InsertBefore(&pStat->StatList,&pSend->StatList);
		} else {
			Lock(&pSend->pSession->SessionStatLock);
			InsertBefore(&pStat->StatList,&pSend->pSession->DGStatList);
			Unlock(&pSend->pSession->SessionStatLock);
		}
	}

	
	#undef pBigFrame
}

#if 0
// release sends waiting for an id.
VOID UnWaitSends(PSESSION pSession, DWORD fReliable)
{
	BILINK *pBilink;
	PSEND pSendWalker;

	pBilink=pSession->SendQ.next;

	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink,SEND,SendQ);
		pBilink=pBilink->next;
		if(pSendWalker->SendState==WaitingForId){
			if(fReliable){
				if(pSendWalker->dwFlags & DPSEND_GUARANTEED){
					pSendWalker->SendState=Start;
				}
			} else {
				if(!(pSendWalker->dwFlags & DPSEND_GUARANTEED)){
					pSendWalker->SendState=Start;
				}
			}
		
		}
	}
	if(fReliable){
		pSession->nWaitingForMessageid=0;
	} else {
		pSession->nWaitingForDGMessageid=0;
	}
}
#endif

// Check if a datagram send can be started, if it can update teh
// Session and the Send.
BOOL StartDatagramSend(PSESSION pSession, PSEND pSend, UINT MsgIdMask)
{
	BOOL bFoundSend;
	UINT bit;
//	BOOL bTransition=FALSE;

	if((pSession->DGLastMsg-pSession->DGFirstMsg < pSession->MaxCDGSends)){
	
		bFoundSend=TRUE;

		if(pSend->SendState==WaitingForId){
			InterlockedDecrement(&pSession->nWaitingForDGMessageid);
		}
		
		bit=(pSession->DGLastMsg-pSession->DGFirstMsg)&MsgIdMask;
		ASSERT(bit<30);
		pSession->DGOutMsgMask |= 1<<bit;
		pSession->DGLastMsg =(pSession->DGLastMsg+1)&MsgIdMask;
		
		pSend->messageid  =pSession->DGLastMsg;
		pSend->FrameSize  =pSession->MaxPacketSize-MAX_SEND_HEADER;

		// Calculate number of frames required for this send.
		pSend->nFrames    =(pSend->MessageSize/pSend->FrameSize);
		if(pSend->FrameSize*pSend->nFrames < pSend->MessageSize || !pSend->nFrames){
			pSend->nFrames++;
		}
		pSend->NR=0;
		pSend->FrameDataLen=0;// hack
		pSend->fSendSmall=pSession->fSendSmallDG;
		if(pSend->fSendSmall){
			pSend->SendSEQMSK = 0xFF;
		} else {
			pSend->SendSEQMSK = 0xFFFF;
		}
	} else {
#if 0
		if(pSession->fSendSmallDG && pSession->DGFirstMsg < 0xFF-MAX_SMALL_CSENDS) {
			// Ran out of IDs, Transition to Large headers.
			DPF(9,"OUT OF IDS, DATAGRAMS GOING TO LARGE FRAMES\n");
			pSession->MaxCDGSends   = MAX_LARGE_DG_CSENDS;
			pSession->DGWindowSize  = MAX_LARGE_WINDOW;
			pSession->fSendSmallDG  = FALSE;
			bTransition=TRUE;
		}
#endif
		bFoundSend=FALSE;
		
		if(pSend->SendState==Start){
			InterlockedIncrement(&pSession->nWaitingForDGMessageid);
			DPF(9,"StartDatagramSend: No Id's Avail: nWaitingForDGMessageid %x\n",pSession->nWaitingForDGMessageid);
			pSend->SendState=WaitingForId;
#if 0			
			if(bTransition){
				UnWaitSends(pSession,FALSE);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}
#endif			
		} else {
			DPF(9,"Couldn't start datagram send on pSend %x State %d pSession %x\n",pSend,pSend->SendState,pSession);
			if(pSend->SendState!=WaitingForId){
				ASSERT(0);
			}
		}

	}

	return bFoundSend;
}


BOOL StartReliableSend(PSESSION pSession, PSEND pSend, UINT MsgIdMask)
{
	BOOL bFoundSend;
	UINT bit;
//	BOOL bTransition=FALSE;

	ASSERT(pSend->dwFlags & DPSEND_GUARANTEED);

	if((pSession->LastMsg-pSession->FirstMsg & MsgIdMask) < pSession->MaxCSends){

		DPF(9,"StartReliableSend: FirstMsg: x%x LastMsg: x%x\n",pSession->FirstMsg, pSession->LastMsg);
	
		bFoundSend=TRUE;

		if(pSend->SendState==WaitingForId){
			InterlockedDecrement(&pSession->nWaitingForMessageid);
		}
		
		bit=(pSession->LastMsg-pSession->FirstMsg)&MsgIdMask;
		#ifdef DEBUG
		if(!(bit<pSession->MaxCSends)){
			DEBUG_BREAK();
		}
		#endif
		pSession->OutMsgMask |= 1<<bit;
		pSession->LastMsg =(pSession->LastMsg+1)&MsgIdMask;

		DPF(9,"StartReliableSend: pSend %x assigning id x%x\n",pSend,pSession->LastMsg);
		
		pSend->messageid  =pSession->LastMsg;
		pSend->FrameSize  =pSession->MaxPacketSize-MAX_SEND_HEADER;

		// Calculate number of frames required for this send.
		pSend->nFrames    =(pSend->MessageSize/pSend->FrameSize);
		if(pSend->FrameSize*pSend->nFrames < pSend->MessageSize || !pSend->nFrames){
			pSend->nFrames++;
		}
		pSend->NR=0;
		pSend->FrameDataLen=0;// hack
		pSend->fSendSmall=pSession->fSendSmall;
		if(pSend->fSendSmall){
			pSend->SendSEQMSK = 0xFF;
		} else {
			pSend->SendSEQMSK = 0xFFFF;
		}

	} else {
#if 0	
		if (pSession->fSendSmall && pSession->FirstMsg < 0xFF-MAX_SMALL_CSENDS){
			// Ran out of IDs, Transition to Large headers - but only if we aren't going
			// to confuse the wrapping code.
			DPF(8,"OUT OF IDS, RELIABLE SENDS GOING TO LARGE FRAMES\n");
			pSession->MaxCSends		= MAX_LARGE_CSENDS;
			pSession->WindowSize    = MAX_LARGE_WINDOW;
			pSession->fSendSmall    = FALSE;
			bTransition = TRUE;
		}
#endif
		bFoundSend=FALSE;
		
		if(pSend->SendState==Start){
			bFoundSend=FALSE;
			// Reliable, waiting for id.
			InterlockedIncrement(&pSession->nWaitingForMessageid);
			pSend->SendState=WaitingForId;
			DPF(9,"StartReliableSend: No Id's Avail: nWaitingForMessageid %x\n",pSession->nWaitingForMessageid);
#if 0			
			if(bTransition){
				UnWaitSends(pSession,TRUE);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}
#endif			
		} else {
			bFoundSend=FALSE;
			DPF(9,"Couldn't start reliable send on pSend %x State %d pSession %x\n",pSend,pSend->SendState,pSession);
			if(pSend->SendState!=WaitingForId){
				ASSERT(0);
			}
		}
	}
	
	return bFoundSend;
}


BOOL CheckUserTimeOut(PSEND pSend)
{
	if(pSend->dwTimeOut){
		if((timeGetTime()-pSend->dwSendTime) > pSend->dwTimeOut){
			pSend->SendState=UserTimeOut;
			return TRUE;
		} 
	}	
	return FALSE;
}
/*=============================================================================

	GetNextMessageToSend
    
    Description:

	Scans the send queue for a message that is the current priority and
	is in the ready to send state or throttled state (we shouldn't even
	get here unless the throttle was removed.)  If we find such a message
	we return a pointer to the caller.

	Adds a reference to the Send and the Session.

    Parameters:     

		PPROTOCOOL pProtocol - pointer to the PROTOCOL object to send packets on.

    Return Values:
	
		NULL  - no message should be sent.
		PSEND - message to send.

-----------------------------------------------------------------------------*/

PSEND GetNextMessageToSend(PPROTOCOL pProtocol)
{
	PSEND    pSend;
	BILINK  *pBilink;
	UINT     CurrentSendPri;
	BOOL     bFoundSend; 
	PSESSION pSession;

	UINT     MsgIdMask;

	Lock(&pProtocol->m_SendQLock);

	DPF(9,"==>GetNextMessageToSend\n");

Top:

	bFoundSend = FALSE;
	pProtocol->m_bRescanQueue=FALSE;
	
	if(EMPTY_BILINK(&pProtocol->m_GSendQ)){
		Unlock(&pProtocol->m_SendQLock);
		DPF(9,"GetNextMessageToSend: called with nothing in queue, heading for the door.\n");
		goto exit;
	}

	pBilink        = pProtocol->m_GSendQ.next;
	pSend          = CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
	CurrentSendPri = pSend->Priority;

	while(pBilink != &pProtocol->m_GSendQ){

		pSession=pSend->pSession;
		ASSERT_SIGN(pSession, SESSION_SIGN);
		Lock(&pSession->SessionLock);

		if(pProtocol->m_bRescanQueue){
			DPF(9,"RESCAN of QUEUE FORCED IN GETNEXTMESSAGETOSEND\n");
			Unlock(&pSession->SessionLock);
			goto Top;
		}

		if(pSession->dwFlags & SESSION_UNTHROTTLED){
			// unthrottle happened, so rewind.
			DPF(9,"Unthrottling Session %x\n",pSession);
			pSession->dwFlags &= ~(SESSION_THROTTLED|SESSION_UNTHROTTLED);
		}

		Lock(&pSend->SendLock);
		
		switch(pSession->eState){

			case Open:

				if((pSend->dwFlags & DPSEND_GUARANTEE)?(pSession->fSendSmall):(pSession->fSendSmallDG)){
					MsgIdMask = 0xFF;
				} else {
					MsgIdMask = 0xFFFF;
				}

	
				if(!(pSend->dwFlags & ASEND_PROTOCOL) && (pSession->dwFlags & SESSION_THROTTLED)){
					// don't do sends on a throttled session, unless they are internal sends.
					break;
				}

				switch(pSend->SendState){

				
					case Start:
					case WaitingForId:

						DPF(9,"Found Send in State %d, try Going to Sending State\n",pSend->SendState);
						// Just starting, need an id.

						if(!(pSend->dwFlags & ASEND_PROTOCOL) && CheckUserTimeOut(pSend)){
							if(pSend->SendState==WaitingForId){
								// fixup WaitingForId count on timed out send.
								if(pSend->dwFlags&DPSEND_GUARANTEED){
									InterlockedDecrement(&pSession->nWaitingForMessageid);
								} else {
									InterlockedDecrement(&pSession->nWaitingForDGMessageid);
								}
							}
							bFoundSend=TRUE;
							break;
						}
							
						if(pSend->dwFlags&ASEND_PROTOCOL){
						
							DPF(9,"System Send in Start State, Going to Sending State\n");
							bFoundSend=TRUE;
							pSend->SendState=Sending;
							break;
							
						} else if(!(pSend->dwFlags&DPSEND_GUARANTEED)) {        

							//check_datagram: 
							bFoundSend=StartDatagramSend(pSession,pSend, MsgIdMask);

						} else {

							// NOT DataGram, .: reliable...
							//check_reliable: 
							bFoundSend=StartReliableSend(pSession,pSend, MsgIdMask);
							#ifdef DEBUG
								if(bFoundSend){
									BILINK *pBiSendWalker=pSend->SendQ.prev;
									PSEND pSendWalker;
									while(pBiSendWalker != &pSession->SendQ){
										pSendWalker=CONTAINING_RECORD(pBiSendWalker,SEND,SendQ);
										pBiSendWalker=pBiSendWalker->prev;
										if((pSendWalker->SendState==Start || pSendWalker->SendState==WaitingForId)&& 
											pSendWalker->dwFlags&DPSEND_GUARANTEED && 
											!(pSendWalker->dwFlags&ASEND_PROTOCOL) && 
											pSendWalker->Priority >= pSend->Priority){
											DPF(0,"Send %x got id %x but Send %x still in state %x on Session %x\n",pSend,pSend->messageid,pSendWalker,pSendWalker->SendState,pSession);
											DEBUG_BREAK();
										}
									}
								}
							#endif
						}
						if(bFoundSend){
							if(pSession->dwFlags & SESSION_THROTTLED)
							{
								pSend->SendState=Throttled;
								bFoundSend=FALSE;
							} else {
								pSend->SendState=Sending;
							}	
						}
						break;


					case ReadyToSend:
					
						DPF(9,"Found Send in ReadyToSend State, going to Sending State\n");
						bFoundSend=TRUE;
						if(pSession->dwFlags & SESSION_THROTTLED)
						{
							pSend->SendState=Throttled;
							bFoundSend=FALSE;
						} else {
							pSend->SendState=Sending;
						}	
						break;

						
					case Throttled:
					
						ASSERT(!(pSession->dwFlags & SESSION_THROTTLED));
						DPF(9,"Found Send in Throttled State, unthrottling going to Sending State\n");
						bFoundSend=TRUE;
						pSend->SendState=Sending;
						if(pSession->dwFlags & SESSION_THROTTLED)
						{
							pSend->SendState=Throttled;
							bFoundSend=FALSE;
						} else {
							pSend->SendState=Sending;
						}	
						break;


					case TimedOut:
					
						DPF(9,"Found TimedOut Send.\n");
						TimeOutSession(pSession);
						bFoundSend=TRUE;
						break;


					case Cancelled:
					
						bFoundSend=TRUE;
						break;


					default:        
						ASSERT(pSend->SendState <= Done);
						break;
				} /* end switch(SendState) */
				break;

			default:
				switch(pSend->SendState){
					case Sending:
					case Done:
						DPF(9,"GetNextMessageToSend: Session %x was in state %d ,pSend %x SendState %d, leaving...\n",pSession, pSession->eState, pSend, pSend->SendState);
						//bFoundSend=FALSE;
						break;

					case WaitingForAck:
						CancelRetryTimer(pSend);
						pSend->SendState=TimedOut;
						DPF(9,"Moved WaitingForAck send to TimedOut and returning pSession %x was in State %d pSend %x\n",pSession,pSession->eState,pSend);
						bFoundSend=TRUE;
						break;
						
					default:
						DPF(9,"GetNextMessageToSend: Session %x was in state %d ,returning pSend %x SendState %d\n",pSession, pSession->eState, pSend, pSend->SendState);
						bFoundSend=TRUE;
						break;
				}
				break;
				
		} /* end switch pSession->eState */     
				
		if(bFoundSend){
			if(AddSendRef(pSend,1)){
				InterlockedIncrement(&pSession->RefCount);
			} else {
				bFoundSend=FALSE;
			}
		} 

		Unlock(&pSend->SendLock);
			
		Unlock(&pSession->SessionLock);

		if(bFoundSend){
			if(pSend->NS==0){
				pSend->tLastACK=timeGetTime();
			}	
			break;
		} 

		pBilink=pBilink->next;
		pSend=CONTAINING_RECORD(pBilink, SEND, m_GSendQ);
		
	} /* end while (pBilink != &pProtocol->m_GSendQ) */

	Unlock(&pProtocol->m_SendQLock);
	
exit:
    if(bFoundSend){
    	DPF(9,"<==GetNextMessageToSend %x\n",pSend);
    	return pSend;
    } else {
    	DPF(9,"<==GetNextMessageToSend NULL\n");
    	return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\sendpool.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    SENDPOOL.C

Abstract:

	Manages pool of send descriptors.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"

//
// Send Descriptor Management.
//

PSEND 			 pSendDescPool=NULL;
UINT             nSendDescsAllocated=0;	// Number Allocated
UINT             nSendDescsInUse=0;		// Number currently in use
UINT             nMaxSendDescsInUse=0;  // Maximum number in use since last TICK.

CRITICAL_SECTION SendDescLock;

VOID InitSendDescs(VOID)
{
	InitializeCriticalSection(&SendDescLock);
}

VOID FiniSendDescs(VOID)
{
	PSEND pSend;
	
	ASSERT(nSendDescsInUse==0);
	
	while(pSendDescPool){
		pSend=pSendDescPool;
		ASSERT_SIGN(pSend, SEND_SIGN);
		pSendDescPool=pSendDescPool->pNext;
		CloseHandle(pSend->hEvent);
		DeleteCriticalSection(&pSend->SendLock);
		My_GlobalFree(pSend);
		nSendDescsAllocated--;
	}
	
	ASSERT(nSendDescsAllocated==0);
	
	DeleteCriticalSection(&SendDescLock);
}

PSEND GetSendDesc(VOID)
{
	PSEND pSend;

	Lock(&SendDescLock);
	
	if(!pSendDescPool){
	
		Unlock(&SendDescLock);
		pSend=(PSEND)My_GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, sizeof(SEND));
		if(pSend){
			if(!(pSend->hEvent=CreateEventA(NULL, FALSE, FALSE, NULL))){
				My_GlobalFree(pSend);
				goto exit;
			}
			InitBilink(&pSend->StatList);
			InitializeCriticalSection(&pSend->SendLock);
		}
		Lock(&SendDescLock);
		if(pSend){
			SET_SIGN(pSend,SEND_SIGN);			
			nSendDescsAllocated++;
		}
	} else {
	
		pSend=pSendDescPool;
		ASSERT_SIGN(pSend, SEND_SIGN);
		pSendDescPool=pSendDescPool->pNext;
		
	}

	if(pSend){
		InitBilink(&pSend->TimeoutList);
		InitBilink(&pSend->m_GSendQ);
		InitBilink(&pSend->SendQ);
		nSendDescsInUse++;
		if( nSendDescsInUse > nMaxSendDescsInUse ){
			nMaxSendDescsInUse = nSendDescsInUse;
		}
	}

	ASSERT(nSendDescsAllocated >= nSendDescsInUse);

	Unlock(&SendDescLock);
	if(pSend){
		pSend->NACKMask=0;
		pSend->bCleaningUp=FALSE;
	}	

exit:	
	return pSend;
}

VOID ReleaseSendDesc(PSEND pSend)
{
	PSENDSTAT pStat;
	BILINK *pBilink;

	// Dump extra statistics.
	while(!EMPTY_BILINK(&pSend->StatList)){
		pBilink=pSend->StatList.next;
		pStat=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
		Delete(pBilink);
		ReleaseSendStat(pStat);
	}

	Lock(&SendDescLock);
	nSendDescsInUse--;
	ASSERT(!(nSendDescsInUse&0x80000000));
	pSend->pNext=pSendDescPool;
	pSendDescPool=pSend;
	Unlock(&SendDescLock);

}


#if 0
// let virtual memory handle this. - switched out.
LONG fInSendDescTick=0;

VOID SendDescTick(VOID)
{
	PSEND pSend;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&fInSendDescTick, 1)){
	
		Lock(&SendDescLock);
		
		while((nSendDescsAllocated > nMaxSendDescsInUse) && pSendDescPool){
		
			pSend=pSendDescPool;
			ASSERT_SIGN(pSend,SEND_SIGN);
			pSendDescPool=pSendDescPool->pNext;
			
			Unlock(&SendDescLock);
			CloseHandle(pSend->hEvent);
			DeleteCriticalSection(&pSend->SendLock);
			My_GlobalFree(pSend);
			Lock(&SendDescLock);
			nSendDescsAllocated--;
			
		}
		nMaxSendDescsInUse=nSendDescsInUse;

		ASSERT(nMaxSendDescsInUse <= nSendDescsAllocated);
		
		Unlock(&SendDescLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&fInSendDescTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\receive.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	RECEIVE.C

Abstract:

	Receive Handler and Receive Thread.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
  12/10/96 aarono  Original
  02/18/98 aarono  Added support for SendEx
   6/6/98  aarono  Turn on throttling and windowing
   6/10/98 aarono  Allow out of order receives when requested by application
   4/15/99 aarono  Take a Send reference in NACK and ACK handlers
--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "protocol.h"
#include "macros.h"
#include "command.h"

// Note: WaitForMultipleObjects has a bug where it restarts the wait in
//       the middle of the list and can run off the end.  We put an extra
//       entry at the end of the object list to deal with this and when
//       we get an invalid_handle error, we just re-wait.

// First object is an event that is signalled when 
// the wait list needs to be changed.


// Receive List Semantics.  The Receive thread 

VOID ProcessACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo);
VOID ProcessNACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PUCHAR pNACKmask, UINT nNACK);
VOID ProcessAbort(PPROTOCOL pProtocol, DPID idFrom, DPID idTo, pABT1 pABT, BOOL fBig);
VOID SendACK(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo);


// Function table for received commands.
UINT (*ProtocolFn[MAX_COMMAND+1])(REQUEST_PARAMS)={
	AssertMe,                                       // 0x00  
	Ping,                               // 0x01  
	PingResp,                                                       // 0x02
	GetTime,                            // 0x03  
	GetTimeResp,                                            // 0x04
	SetTime,                            // 0x05 
	SetTimeResp                                                     // 0x06
};


VOID FreeReceiveBuffers(PRECEIVE pReceive)
{
	BILINK *pBilink;
	PBUFFER pBuffer;
	pBilink=pReceive->RcvBuffList.next;
	while(pBilink != &pReceive->RcvBuffList){
		pBuffer=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		pBilink=pBilink->next;
		FreeFrameBuffer(pBuffer);
	}
}

VOID CopyReceiveBuffers(PRECEIVE pReceive,PVOID pBuffers,UINT nBuffers)
{
	#define MemDesc(_i) (*(((PMEMDESC)pBuffers)+(_i)))

	PBUFFER  pBuffer;

	UINT    BytesToCopy;
	
	UINT    BuffLen;
	UINT    BuffOffset;

	UINT    mdlen;
	UINT    mdoffset;

	UINT    i=0;

	PUCHAR  src;
	PUCHAR  dest;
	UINT    len;

	BytesToCopy=pReceive->MessageSize;

	pBuffer=(PBUFFER)pReceive->RcvBuffList.next;
	BuffLen=(UINT)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData));
	BuffOffset=0;
	
	mdlen=MemDesc(0).len;
	mdoffset=0;

	while(BytesToCopy){
		if(!mdlen){
			i++;
			mdlen=MemDesc(i).len;
			mdoffset=0;
			ASSERT(i<nBuffers);
		}
		if(!BuffLen){
			pBuffer=pBuffer->pNext;
			ASSERT(pBuffer);
			BuffLen=(UINT)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData));
			BuffOffset=0;
		}
		
		src=&pBuffer->pCmdData[BuffOffset];
		dest=&(MemDesc(i).pData[mdoffset]);

		if(BuffLen > mdlen){
			len=mdlen;
			BuffOffset+=len;
		} else {
			len=BuffLen;
			mdoffset+=len;
		}

		DPF(9,"CopyReceiveBuffers src,dest,len: %x %x %x\n",dest,src,len);

		memcpy(dest,src,len);

		BuffLen-=len;
		mdlen-=len;
		BytesToCopy-=len;
	}
	
	#undef MemDesc  
}

HRESULT _inline ParseHeader(
	FLAGS *pflags, 
	PUCHAR pData,
	UINT * pCommand, 
	UINT *piEOF, 
	UINT *piEOA, 
	UINT *piEON, 
	UINT *pnNACK)
{

	if(pflags->flag1 & BIG){
		// big frame
		if(pflags->flag1 & CMD){
			// big command frame 
			if(pflags->flag1 & EXT){
				// big command frame with explicit command
				*pCommand=pflags->flag2 & ~EXT;
				if(pflags->flag2 & EXT){
					// big command frame with explicit command and NACK
					*pnNACK=pflags->flag3 & ~EXT;
					*piEOF=3;
				} else {
					// big command frame with explicit command, no NACK
					*pnNACK=0;
					*piEOF=2;
				}
			} else {
				// big -I- frame, no NACK
				*pCommand=0;
				*pnNACK=0;
				*piEOF=1;
			}
			
		} else {
			// big supervisory (non-command) frame
			if(pflags->flag1 & EXT){
				// big supervisory frame with nNACK
				*pnNACK=pflags->flag2 & ~EXT;
				ASSERT(*pnNACK);
				*piEOF=2;
			} else {
				// big supervisory frame with no-nNACK
				*pnNACK=0;
				*piEOF=1;
			}
		}
	} else {
		// small frame
		if(pflags->flag1 & CMD){
			// small command frame
			if(pflags->flag1 & EXT){
				// small command frame (with NACK?) and explicit command
				DPF(0,"ERROR PARSING FRAME, NOT RECOGNIZED, ABORTING DECODE\n");
				return DPERR_ABORTED;
				
				*pCommand = pflags->flag2 & CMD_MSK;
				*pnNACK   = (pflags->flag2 & nNACK_MSK) >> nNACK_SHIFT;
				*piEOF = 2;
			} else {
				// small -I- frame, no NACK
				*pCommand = 0;
				*pnNACK = 0;
				*piEOF = 1;
			}
		} else {
			// small supervisory (non-command) frame
			if(pflags->flag1 & EXT){
				*pnNACK   = (pflags->flag2 & nNACK_MSK) >> nNACK_SHIFT;
				*piEOF = 2;
			} else {
				*pnNACK=0;
				*piEOF=1;
			}
		}
	}

	while(pData[(*piEOF)-1]&EXT){
		// Skip past any flags extensions we don't understand.
		// small command frame (with NACK?) and explicit command
		DPF(0,"ERROR PARSING FRAME, NOT RECOGNIZED, ABORTING DECODE\n");
		return DPERR_ABORTED;
		
		(*piEOF)++;
	}
	
	*piEOA=*piEOF;

	// Update any ACK information.
	if((pflags->flag1 & ACK)){ 
		if((pflags->flag1 & BIG)){
			// LARGE ACK
			*piEOA+=sizeof(ACK2);
		} else {
			// SMALL ACK
			*piEOA+=sizeof(ACK1);
		}
	} 

	*piEON = *piEOA;
	
	// Update any NACK information.
	
	if(*pnNACK){
		if((pflags->flag1 & BIG)){
			*piEON+=sizeof(NACK2);
		}else{
			*piEON+=sizeof(NACK1);
		}
		*piEON+=*pnNACK;
	}

	return DP_OK;
}

/*=============================================================================

	ProtocolReceive - Receive handler for protocol, called when we've
					  verified the message is a protocol message and
					  we've been able to allocate receive space for the
					  message
	
    Description:

		Cracks the protocol header on the message and fills in a CMDINFO
		structure to describe the protocol information in the frame.  Then
		dispatches the message along with the CMDINFO to the appropriate
		handler.

		A packet may have ACK or NACK information in the header and still
		be a command packet.  We do ACK/NACK processing first, then we
		do command processing.

		This routine will dispatch to

		ProcessACK
		ProcessNACK
		CommandReceive

    Parameters:     

		idFrom	  - index in player table of sending player
		idTo      - "                      " receiving player
		pBuffer   - a buffer we own with a copy of the message
		pSPHeader - if present can be used to issue a reply without an id.

    Return Values:

		None.

	Notes:
-----------------------------------------------------------------------------*/

VOID ProtocolReceive(PPROTOCOL pProtocol, WORD idFrom, WORD idTo, PBUFFER pBuffer, PVOID pSPHeader)
{
	#define pFrame      ((pPacket1)(pBuffer->pData))
	#define pBigFrame   ((pPacket2)(pBuffer->pData))

	#define pACK        ((pACK1)(&pData[iEOF]))
	#define pBigACK     ((pACK2)(&pData[iEOF]))

	#define pABT        ((pABT1)(&pData[iEOF]))
	#define pBigABT     ((pABT2)(&pData[iEOF]))

	#define pNACK       ((pNACK1)(&pData[iEOA]))
	#define pBigNACK    ((pNACK2)(&pData[iEOA]))

	#define pCMD        ((pCMD1)(&pData[iEON]))
	#define pBigCMD     ((pCMD2)(&pData[iEON]))

	PUCHAR   pData;

	FLAGS    flags;
	
	UINT     command;   // the command if a command frame.
	UINT     nNACK;     // if this is a NACK frame, sizeof bitfield
	UINT     iEOF;      // index past end of flags
	UINT     iEOA;      // index past end of any ACK or ABT information
	UINT     iEON;      // index past end of any NACK information
	UINT     rc=0;

	PUCHAR   pNACKmask;

	HRESULT  hr;

	CMDINFO  CmdInfo;
	PCMDINFO pCmdInfo=&CmdInfo;

	CmdInfo.tReceived=timeGetTime();

	pData=pBuffer->pData;
	memcpy(&flags,pData,sizeof(flags));

	hr=ParseHeader(&flags, pData, &command, &iEOF, &iEOA, &iEON, &nNACK);

	if(hr==DPERR_ABORTED){
		goto exit;
	}

	// Get the DPLAY id's for the indicies

	CmdInfo.idFrom  = GetDPIDByIndex(pProtocol, idFrom);
	if(CmdInfo.idFrom == 0xFFFFFFFF){
		DPF(1,"Rejecting packet with invalid From Id\n",idFrom);
		goto exit;
	}
	CmdInfo.idTo    = GetDPIDByIndex(pProtocol, idTo);
	if(CmdInfo.idTo == 0xFFFFFFFF){
		DPF(1,"Rejecting packet with invalid To Id\n");
		goto exit;
	}

	DPF(9,"Protocol Receive idFrom %x idTo %x\n",CmdInfo.idFrom,CmdInfo.idTo);

	
	CmdInfo.wIdFrom = idFrom;
	CmdInfo.wIdTo   = idTo;
	CmdInfo.flags   = flags.flag1;
	CmdInfo.pSPHeader = pSPHeader;

	// determine masks to use for this size frame
	if(flags.flag1 & BIG){
		IDMSK     = 0xFFFF;
		SEQMSK    = 0xFFFF;
	} else {
		IDMSK     = 0xFF;
		SEQMSK    = 0xFF;
	}

	if((flags.flag1 & ACK))
	{
		// Process the ACK field (could be piggyback).
		if(flags.flag1 & BIG){
			pCmdInfo->messageid = pBigACK->messageid;
			pCmdInfo->sequence  = pBigACK->sequence;
			pCmdInfo->serial    = pBigACK->serial;
			pCmdInfo->bytes     = pBigACK->bytes;
			pCmdInfo->tRemoteACK= pBigACK->time;
		} else {
			pCmdInfo->messageid = pACK->messageid;
			pCmdInfo->sequence  = pACK->sequence;
			pCmdInfo->serial    = pACK->serial;
			pCmdInfo->bytes     = pACK->bytes;
			pCmdInfo->tRemoteACK= pACK->time;
		}       
		DPF(9,"ACK: msgid: %d seq %d serial %d\n",CmdInfo.messageid, CmdInfo.sequence, CmdInfo.serial);
		if(CmdInfo.serial==150){
			// this is a little excessive for retries, break out so we can debug this.
			DPF(0,"ProtocolReceive: WHOOPS, 150 retries is a little excessive\n");
			ASSERT(0);
		}	
		ProcessACK(pProtocol, &CmdInfo);
	}

	if(nNACK){
		if(flags.flag1 & BIG){
			CmdInfo.messageid = pBigNACK->messageid;
			CmdInfo.sequence  = pBigNACK->sequence;
			CmdInfo.bytes     = pBigNACK->bytes;
			CmdInfo.tRemoteACK= pBigNACK->time;
			pNACKmask         = pBigNACK->mask;
		} else {
			CmdInfo.messageid = pNACK->messageid;
			CmdInfo.sequence  = pNACK->sequence;
			CmdInfo.bytes     = pNACK->bytes;
			CmdInfo.tRemoteACK= pNACK->time;
			pNACKmask         = pNACK->mask;
		}
		DPF(9,"NACK: msgid: %d seq %d\n",CmdInfo.messageid, CmdInfo.sequence);
		ProcessNACK(pProtocol, &CmdInfo, pNACKmask, nNACK);
	}

#ifdef DEBUG
	if((flags.flag1 & ACK) || nNACK)
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));
	 	InWS.stat_RemBytesReceived=CmdInfo.bytes;
		DbgWriteStats(&InWS);
	}
#endif

	if((flags.flag1 & CMD)){

		CmdInfo.command = command;
		
		if((flags.flag1 & BIG)){
			CmdInfo.messageid= pBigCMD->messageid;
			CmdInfo.sequence = pBigCMD->sequence;
			CmdInfo.serial   = pBigCMD->serial;
			pBuffer->pCmdData = pData+iEON+5;//(+5 for messageid(2), sequence(2), serial(1))
		} else {
			CmdInfo.messageid= pCMD->messageid;
			CmdInfo.sequence = pCMD->sequence;
			CmdInfo.serial   = pCMD->serial;
			pBuffer->pCmdData = pData+iEON+3;//(+3 for byte messageid,seq,serial)
		}

		rc=CommandReceive(pProtocol, &CmdInfo, pBuffer);
	}

	if(!rc){
exit:
		FreeFrameBuffer(pBuffer);
	}
	return;
	
	#undef pNACK   
	#undef pBigNACK

	#undef pCMD   
	#undef pBigCMD

	#undef pABT
	#undef pBigABT

	#undef pACK
	#undef pBigACK

	#undef pBigFrame
	#undef pFrame
}

VOID FreeReceive(PPROTOCOL pProtocol, PRECEIVE pReceive)
{
	DPF(9,"Freeing Receive %x\n",pReceive);
	FreeReceiveBuffers(pReceive);
	ReleaseRcvDesc(pProtocol, pReceive);
}

#ifdef DEBUG
VOID DebugScanForMessageId(BILINK *pBilink, UINT messageid)
{
	BILINK *pBilinkWalker;
	PRECEIVE pReceive;
	
	pBilinkWalker=pBilink->next;
	while(pBilinkWalker!=pBilink){
		pReceive=CONTAINING_RECORD(pBilinkWalker,RECEIVE,pReceiveQ);
		if(pReceive->messageid==messageid){
			DPF(0,"ERROR: MESSAGEID x%x already exists in pReceive %x\n",pReceive);
			DEBUG_BREAK();
		}
		pBilinkWalker=pBilinkWalker->next;
	}
}
#else
#define DebugScanForMessageId(_a,_b)
#endif

#ifdef DEBUG
VOID DbgCheckReceiveStart(PSESSION pSession,PRECEIVE pReceive,PBUFFER pBuffer)
{
	BILINK *pBilink;
	PBUFFER pBuffWalker;
	
	pBilink=pReceive->RcvBuffList.next;

	while(pBilink != &pReceive->RcvBuffList){
		pBuffWalker=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		pBilink=pBilink->next;
		
			if(pBuffWalker->sequence==1){
				break;
			}
	}

	if( ((pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)) != (pBuffWalker->len-(pBuffWalker->pCmdData-pBuffWalker->pData))) ||

	   (memcmp(pBuffWalker->pCmdData, 
	   		   pBuffer->pCmdData, 
	   		   (UINT32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)))) )
	{
		DPF(0,"Different retry start buffer, pSession %x, pReceive %x, pBufferOnList %x, pBuffer %x\n",pSession,pReceive,pBuffWalker,pBuffer);
		DEBUG_BREAK();
	}
	// compare the buffers
}

#else
#define DbgCheckReceiveStart
#endif

// If a receive is returned, it is locked on behalf of the caller.
/*=============================================================================

	GetReceive - for a received data message find the receive structure
	             or create one.  If this message is a retry of a completed
	             message, send an extra ACK.

    Description:

    Parameters:     
    	pProtocol
    	pSession
    	pCmdInfo

    Return Values:
    	PRECEIVE - pointer to receive for this frame

	
	Notes:
-----------------------------------------------------------------------------*/
PRECEIVE GetReceive(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	#define flags pCmdInfo->flags

	BOOL fFoundReceive=FALSE;

	BILINK *pBiHead, *pBilink;
	PRECEIVE pReceive=NULL,pReceiveWalker;

	DPF(9,"==>GetReceive pSession %x\n",pSession);

	Lock(&pSession->SessionLock);

	// Scan the queue on the SESSION for a RECEIVE with this messageid.

	if(flags & RLY){
		pBiHead = &pSession->pRlyReceiveQ;
		if(!pSession->fReceiveSmall){
			IDMSK = 0xFFFF;
		}
	} else {
		pBiHead = &pSession->pDGReceiveQ;
		if(!pSession->fReceiveSmallDG){
			IDMSK = 0xFFFF;
		}
	}
	
	pBilink = pBiHead->next;

	while(pBilink != pBiHead){

		pReceive=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		pBilink=pBilink->next;

		if(pReceive->messageid==pCmdInfo->messageid){

			Lock(&pReceive->ReceiveLock);
		
			if(!pReceive->fBusy){
			
				ASSERT(pReceive->command   == pCmdInfo->command);
				ASSERT(pReceive->fReliable == (flags & RLY));
				
				fFoundReceive=TRUE;
				break;
				
			} else {

				Unlock(&pReceive->ReceiveLock);
				// its moving, so its done.  Ignore.
				// there is probably a racing ACK already so ignore is fine.
				DPF(9,"GetReceive: Receive %x for messageid x%x is completing already, so ignoring receive\n",pReceive,pReceive->messageid);
				ASSERT(0);
				pReceive=NULL;
				goto exit;
			}
		}
	}

	if(!fFoundReceive){
		DPF(9,"GetReceive: Didn't find a receive for messageid x%x\n",pCmdInfo->messageid);
		pReceive=NULL;
	} else {
		DPF(9,"GetReceive: Found receive %x for messageid x%x\n",pReceive, pCmdInfo->messageid);
	}

	if(pReceive && ( flags & STA )){
		// Should get blown away below - this is the start frame, but we already got it
		DPF(9,"GetReceive: Got start for receive %x messageid x%x we already have going\n",pReceive, pCmdInfo->messageid);
		DbgCheckReceiveStart(pSession,pReceive,pBuffer);
		Unlock(&pReceive->ReceiveLock);
		pReceive=NULL;
		goto ACK_EXIT;
	}
	
	if(!pReceive){
		if(flags & RLY){
			UINT MsgIdDelta;
			DWORD bit;
			
			MsgIdDelta=(pCmdInfo->messageid - pSession->FirstRlyReceive)&IDMSK;
			bit=MsgIdDelta-1;

			if((bit > MAX_LARGE_CSENDS) || (pSession->InMsgMask & (1<<bit))){
				DPF(9,"GetReceive: dropping extraneous rexmit data\n");
				if(flags & (EOM|SAK)) {
					// RE-ACK the message.
					DPF(9,"GetReceive: Sending extra ACK anyway\n");
					goto ACK_EXIT;
				}
				goto exit; // Drop it, this is for an old message.
			} else {

//			if( (MsgIdDelta==0) || 
//				((pSession->fReceiveSmall)?(MsgIdDelta > MAX_SMALL_CSENDS):(MsgIdDelta > MAX_LARGE_CSENDS))){
//				DPF(5,"GetReceive: dropping extraneous rexmit data\n");
//				if(flags & EOM|SAK) {
//					// RE-ACK the message.
//					DPF(5,"GetReceive: Sending extra ACK anyway\n");
//					goto ACK_EXIT;
//				}
//				goto exit; // Drop it, this is for an old message.
//			} else {
				if(flags & STA){
					if(pSession->LastRlyReceive==pCmdInfo->messageid){
						DPF(9,"RECEIVE: dropping resend for messageid x%x, but ACKING\n",pCmdInfo->messageid);
						// RE-ACK the message.
						goto ACK_EXIT;
					}      

					if(((pSession->LastRlyReceive-pSession->FirstRlyReceive)&IDMSK)<MsgIdDelta){
						pSession->LastRlyReceive=pCmdInfo->messageid;
						DPF(9,"GetReceive: New messageid x%x FirstRcv %x LastRcv %x\n",pCmdInfo->messageid,pSession->FirstRlyReceive,pSession->LastRlyReceive);
						#ifdef DEBUG
						if(!pSession->fReceiveSmall){
							if(((pSession->LastRlyReceive-pSession->FirstRlyReceive) & 0xFFFF) > MAX_LARGE_CSENDS){
								ASSERT(0);
							}
						} else {
							if(((pSession->LastRlyReceive-pSession->FirstRlyReceive) & 0x0FF) > MAX_SMALL_CSENDS){
								ASSERT(0);
							}
						}
						#endif

					}
				}
			}
		} else {
		
			// Nonreliable, blow away any messages outside the window.
			// also blow away any residual messages with same number if we are a START.
			pBiHead = &pSession->pDGReceiveQ;
			pBilink = pBiHead->next;
			while( pBilink != pBiHead ){
			
				pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
				ASSERT_SIGN(pReceiveWalker, RECEIVE_SIGN);
				pBilink=pBilink->next;

				if(!pReceiveWalker->fBusy && 
						( (((pCmdInfo->messageid - pReceiveWalker->messageid) & IDMSK ) > ((pSession->fReceiveSmallDG)?(MAX_SMALL_DG_CSENDS):(MAX_LARGE_DG_CSENDS))) ||
						  ((flags&STA) && pCmdInfo->messageid==pReceiveWalker->messageid) 
						)
					){

					Lock(&pReceiveWalker->ReceiveLock);
					if(!pReceiveWalker->fBusy){
						DPF(9,"GetReceive: Got Id %d Throwing Out old Datagram Receive id %d\n",pCmdInfo->messageid,pReceiveWalker->messageid);
						Delete(&pReceiveWalker->pReceiveQ);
						Unlock(&pReceiveWalker->ReceiveLock);
						FreeReceive(pProtocol,pReceiveWalker);
					} else {
						ASSERT(0);
						DPF(0,"GetReceive: Got Id %d Couldn't throw out DG id %d\n",pCmdInfo->messageid,pReceiveWalker->messageid);
						Unlock(&pReceiveWalker->ReceiveLock);
					}
				}       
			}       
		}
		
		// Allocate a receive structure
		if(flags & STA){
			pReceive=GetRcvDesc(pProtocol);
			DPF(9,"allocated new receive %x messageid x%x\n",pReceive,pCmdInfo->messageid);
			if(!pReceive){
				// no memory, drop it.
				ASSERT(0);
				DPF(0,"RECEIVE: no memory! dropping packet\n");
				goto exit;
			}

			pReceive->pSession    = pSession;
			pReceive->fBusy       = FALSE;
			pReceive->fReliable   = flags&RLY;
			pReceive->fEOM        = FALSE;
			pReceive->command     = pCmdInfo->command;
			pReceive->messageid   = pCmdInfo->messageid;
			pReceive->iNR         = 0;
			pReceive->NR          = 0; 
			pReceive->NS          = 0;
			pReceive->RCVMask     = 0;
			pReceive->MessageSize = 0;
			InitBilink(&pReceive->RcvBuffList);
			Lock(&pReceive->ReceiveLock);
			
		
			if(flags & RLY){
				// Set bit in incoming receive mask;
				DebugScanForMessageId(&pSession->pRlyReceiveQ, pCmdInfo->messageid);
				InsertAfter(&pReceive->pReceiveQ,&pSession->pRlyReceiveQ);
			} else {
				DebugScanForMessageId(&pSession->pDGReceiveQ, pCmdInfo->messageid);
				InsertAfter(&pReceive->pReceiveQ,&pSession->pDGReceiveQ);
			}       
			// Save the SP header for indications
			if(pCmdInfo->pSPHeader){
				pReceive->pSPHeader=&pReceive->SPHeader[0];
				memcpy(pReceive->pSPHeader, pCmdInfo->pSPHeader, pProtocol->m_dwSPHeaderSize);
			} else {
				pReceive->pSPHeader=NULL;
			}
		}       
	}

exit:   
	Unlock(&pSession->SessionLock);

unlocked_exit:  
	DPF(9,"<==GetReceive pSession %x pReceive %x\n",pSession, pReceive);

	return pReceive;

	#undef flags

ACK_EXIT:
	Unlock(&pSession->SessionLock);
	SendACK(pProtocol,pSession,pCmdInfo);
	goto unlocked_exit;
}

VOID PutBufferOnReceive(PRECEIVE pReceive, PBUFFER pBuffer)
{
	BILINK *pBilink;
	PBUFFER pBuffWalker;
	
	pBilink=pReceive->RcvBuffList.prev;

	while(pBilink != &pReceive->RcvBuffList){
		pBuffWalker=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
		#ifdef DEBUG
			if(pBuffWalker->sequence==pBuffer->sequence){
				DPF(0,"already have sequence queued?\n");
				DEBUG_BREAK();
				break;
			}
		#endif
		if(pBuffWalker->sequence < pBuffer->sequence){
			break;
		}
		pBilink=pBilink->prev;
	}
	
	InsertAfter(&pBuffer->BuffList, pBilink);
}

// Chains receives that must be also be completed on this Receive
VOID ChainReceiveFromQueue(PSESSION pSession, PRECEIVE pReceive, UINT messageid)
{
	BOOL bFound=FALSE;
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;

	DPF(9,"==>ChainReceiveFromQueue on pReceive %x, chain messageid x%x\n",pReceive,messageid);

	ASSERT(messageid!=pReceive->messageid);
	ASSERT(!EMPTY_BILINK(&pSession->pRlyWaitingQ));

	pBilink=pSession->pRlyWaitingQ.next;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		if(pReceiveWalker->messageid==messageid){
			bFound=TRUE;
			break;
		}
		pBilink=pBilink->next;
	}

	if(bFound){
		// store in order on pReceive->pReceiveQ
		Delete(&pReceiveWalker->pReceiveQ);
		InsertBefore(&pReceiveWalker->pReceiveQ,&pReceive->pReceiveQ);
		DPF(9,"<==ChainReceiveFromQueue: Chained pReceiveWalker %x messageid x%x on pReceive %x\n",pReceiveWalker, pReceiveWalker->messageid, pReceive);
	} else {
#ifdef DEBUG
		DPF(9,"<==ChainReceiveFromQueue, messageid x%x NOT FOUND!!!, Maybe out of order receive\n",messageid);
		if(!(pSession->pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOLNOORDER)){
			DPF(0,"<==ChainReceiveFromQueue, messageid x%x NOT FOUND!!!, NOT ALLOWED with PRESERVE ORDER\n",messageid);
			DEBUG_BREAK();
		}
#endif	
	}

}

VOID BlowAwayOldReceives(PSESSION pSession, DWORD messageid, DWORD MASK)
{
	BOOL fFoundReceive=FALSE;

	BILINK *pBiHead, *pBilink;
	PRECEIVE pReceive=NULL;

	pBiHead = &pSession->pRlyReceiveQ;
	pBilink = pBiHead->next;

	while(pBilink != pBiHead){

		pReceive=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		ASSERT_SIGN(pReceive, RECEIVE_SIGN);
		pBilink=pBilink->next;

		if((int)((pReceive->messageid-messageid)&MASK) <= 0){

			Lock(&pReceive->ReceiveLock);

			if(!pReceive->fBusy){

				DPF(8,"Blowing away duplicate receive %x id\n",pReceive, pReceive->messageid);
			
				Delete(&pReceive->pReceiveQ);
				Unlock(&pReceive->ReceiveLock);
				FreeReceive(pSession->pProtocol, pReceive);
				
			} else {
				DPF(0,"Huston, we have a problem pSession %x, pReceive %x, messageid %d\n",pSession,pReceive,messageid);
				DEBUG_BREAK();
				Unlock(&pReceive->ReceiveLock);
			}
		}
	}
}


// called with receive lock held, SESSIONion lock unheld, 
// returns with receivelock unheld, but receive not on any lists.
// 0xFFFFFFFF means receive was bogus and blown away
UINT DeQueueReceive(PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	UINT bit;
	UINT nComplete=0;

	DPF(9,"==>DQReceive pReceive %x, messageid x%x\n",pReceive, pReceive->messageid);

		pReceive->fBusy=TRUE;
		Unlock(&pReceive->ReceiveLock);
		
	Lock(&pSession->SessionLock);
		Lock(&pReceive->ReceiveLock);

			// Pull off of receive Q
			Delete(&pReceive->pReceiveQ);
			InitBilink(&pReceive->pReceiveQ); // so we can chain on here.
			pReceive->fBusy=FALSE;

			bit=((pReceive->messageid-pSession->FirstRlyReceive)&IDMSK)-1;

			if(bit >= MAX_LARGE_CSENDS){
				// Duplicate receive, blow it away
				Unlock(&pReceive->ReceiveLock);
				FreeReceive(pSession->pProtocol,pReceive);
				Unlock(&pSession->SessionLock);
				return 0xFFFFFFFF;
			}

			#ifdef DEBUG
				if(pSession->InMsgMask > (UINT)((1<<((pSession->LastRlyReceive-pSession->FirstRlyReceive)&IDMSK))-1)){
					DPF(0,"Bad InMsgMask %x pSession %x\n", pSession->InMsgMask, pSession);
					DEBUG_BREAK();
				}
			#endif	

			pSession->InMsgMask |= 1<<bit;

			while(pSession->InMsgMask&1){
				nComplete++;
				pSession->FirstRlyReceive=(pSession->FirstRlyReceive+1)&IDMSK;
				BlowAwayOldReceives(pSession, pSession->FirstRlyReceive,IDMSK);
				if(nComplete > 1){
					// Chain extra receives to be indicated on this receive.
					ChainReceiveFromQueue(pSession, pReceive,pSession->FirstRlyReceive);
				}
				pSession->InMsgMask>>=1;
			}

			#ifdef DEBUG
				DPF(9,"DQ: FirstRcv %x LastRcv %x\n",pSession->FirstRlyReceive,pSession->LastRlyReceive);
				if((pSession->LastRlyReceive-pSession->FirstRlyReceive & IDMSK) > MAX_LARGE_CSENDS){
					DEBUG_BREAK();
				}
			#endif	
			
		Unlock(&pReceive->ReceiveLock);
	Unlock(&pSession->SessionLock);

	DPF(9,"<==DQReceive pReceive %x nComplete %d\n",pReceive,nComplete);
	
	return nComplete;
}

// called with receive lock held, SESSIONion lock unheld, 
// returns with receivelock unheld, but receive not on any lists.
VOID DGDeQueueReceive(PSESSION pSession, PRECEIVE pReceive)
{
		pReceive->fBusy=TRUE;
		Unlock(&pReceive->ReceiveLock);
	Lock(&pSession->SessionLock);
		Lock(&pReceive->ReceiveLock);
			// Pull off of receive Q
			Delete(&pReceive->pReceiveQ);
			InitBilink(&pReceive->pReceiveQ);
			pReceive->fBusy=FALSE;
		Unlock(&pReceive->ReceiveLock);
	Unlock(&pSession->SessionLock);
}

#ifdef DEBUG
VOID CheckWaitingQ(PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;
	UINT     iReceiveWalker; 
	UINT     iReceive;  // our index based on FirstRlyReceive 

	DPF(9,"==>Check WaitingQ\n");

	Lock(&pSession->SessionLock);

	iReceive=(pReceive->messageid-pSession->FirstRlyReceive)&IDMSK;
	
	pBilink=pSession->pRlyWaitingQ.next;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		iReceiveWalker=(pReceiveWalker->messageid-pSession->FirstRlyReceive)&IDMSK;
		
		if((int)iReceiveWalker < 0){
			DEBUG_BREAK();
		}
		
		if(iReceiveWalker == iReceive){
			DPF(9,"Found Duplicate Receive index %d on WaitingQ %x pSession %x\n",iReceiveWalker, &pSession->pRlyWaitingQ, pSession);
			// found our insert point.
			break;
		}
		pBilink=pBilink->next;
	}
	
	Unlock(&pSession->SessionLock);
	DPF(9,"<==CheckWaitingQ\n");
	
}
#else
#define CheckWaitingQ
#endif

#ifdef DEBUG
VOID DUMPBYTES(PCHAR pBytes, DWORD nBytes)
{
	UCHAR Target[16];
	INT i;

	i=0;
	while(nBytes){
	
		memset(Target,0,16);

		if(nBytes > 16){
			memcpy(Target,pBytes+i*16,16);
			nBytes-=16;
		} else {
			memcpy(Target,pBytes+i*16,nBytes);
			nBytes=0;
		}

		DPF(9,"%04x:  %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n", i*16,
		Target[0],Target[1],Target[2],Target[3],Target[4],Target[5],Target[6],Target[7],
		Target[8],Target[9],Target[10],Target[11],Target[12],Target[13],Target[14],Target[15]); 
		
		i++;
	}	

}
#else
#define DUMPBYTES(a,b)
#endif

// Out of order reliable message, queue it up on the session.
VOID QueueReceive(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PRECEIVE pReceiveWalker;
	UINT     iReceiveWalker; 
	UINT     iReceive;  // our index based on FirstRlyReceive 

	DPF(9,"==>QueueReceive Out of order pReceive %x messageid x%x\n",pReceive,pReceive->messageid);

	Lock(&pSession->SessionLock);
	// Don't need the receive lock since receive already dequeued.

	// insert the receive into the pRlyWaitingQ, in order - 
	// based pSession->FirstRlyReceive IDMSK
	// list is ordered left to right, scan from end for our slot.

	CheckWaitingQ(pSession, pReceive, pCmdInfo);

	iReceive=(pReceive->messageid-pSession->FirstRlyReceive)&IDMSK;
	
	pBilink=pSession->pRlyWaitingQ.prev;

	while(pBilink != &pSession->pRlyWaitingQ){
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);
		iReceiveWalker=(pReceiveWalker->messageid-pSession->FirstRlyReceive)&IDMSK;
		
		if((int)iReceiveWalker < 0){
			DEBUG_BREAK();
		}
		
		if(iReceiveWalker < iReceive){
			// found our insert point.
			break;
		}
		pBilink=pBilink->prev;
	}
	
	// insert in the list.

	InsertAfter(&pReceive->pReceiveQ,pBilink);
	
	Unlock(&pSession->SessionLock);
	DPF(9,"<==QueueReceive Out of order pReceive\n");
}

VOID IndicateReceive(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, UINT nToIndicate)
{
	PDOUBLEBUFFER pDoubleBuffer;
	MEMDESC memdesc;

	BILINK *pBilink, *pBilinkAnchor;
	PRECEIVE pReceiveWalker;

	DPF(9,"==>IndicateReceive pReceive %x nToIndicate %d\n",pReceive,nToIndicate);

	pBilink=pBilinkAnchor=&pReceive->pReceiveQ;
	
	do{
		pReceiveWalker=CONTAINING_RECORD(pBilink, RECEIVE, pReceiveQ);

		// Assemble the message into one frame (if it isn't already)

		if(pReceiveWalker->iNR==1){
			// one frame.
			BILINK *pBilink;
			PBUFFER pBuffer;
			
			pBilink=pReceiveWalker->RcvBuffList.next;
			
			pBuffer=CONTAINING_RECORD(pBilink, BUFFER, BuffList);
			LEAVE_DPLAY();
			DPF(9,"Single Indicating pReceive %x messageid x%x\n",pReceiveWalker, pReceiveWalker->messageid);
			DUMPBYTES(pBuffer->pCmdData, min((UINT32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)),48));
			InternalHandleMessage(pProtocol->m_lpISP,
								pBuffer->pCmdData,
								(ULONG32)(pBuffer->len-(pBuffer->pCmdData-pBuffer->pData)),
								pReceiveWalker->pSPHeader,0);
			ENTER_DPLAY();                                  
								
		} else {

			// multiple frames, copy to a contiguous chunk.
			
			pDoubleBuffer=GetDoubleBuffer(pReceiveWalker->MessageSize);
			if(pDoubleBuffer){

				memdesc.pData=pDoubleBuffer->pData;
				memdesc.len=pDoubleBuffer->len;

				CopyReceiveBuffers(pReceiveWalker,&memdesc,1);

				LEAVE_DPLAY();
				DPF(9,"Multi Indicating pReceive %x messageid x%x\n",pReceiveWalker, pReceiveWalker->messageid);
				
				DUMPBYTES(memdesc.pData, min(memdesc.len,48));
				
				InternalHandleMessage(pProtocol->m_lpISP,
									memdesc.pData,
									memdesc.len,
									pReceiveWalker->pSPHeader,0);
				ENTER_DPLAY();

				FreeDoubleBuffer((PBUFFER)pDoubleBuffer);
			} else {
				DPF(0,"NO MEMORY, MESSAGE DROPPED!\n");
				ASSERT(0);
			}
		}

		pBilink=pBilink->next;
		FreeReceive(pProtocol, pReceiveWalker);
		
	} while (pBilink != pBilinkAnchor);
	
	DPF(9,"<==IndicateReceive\n");
}

// called with receive lock held, must release
int ReliableAccept(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	int rc=0,rc2;

	UINT sequence;
	UINT bit;
	UINT bitmask;
	UINT nToIndicate;
	
	// if its moving, we already have all the data, so drop this.(OPTIMIZATION: maybe ACK again?)
	if(!pReceive->fBusy){
		
		bit=(pCmdInfo->sequence-pReceive->NR-1 ) & SEQMSK;

		if(bit < 32){

			// Calculate absolute sequence number of this packet.
			pBuffer->sequence = sequence = (bit+1) + pReceive->iNR;
			
			bitmask=1<<bit;

			if((pReceive->RCVMask & bitmask)){
			
				rc=FALSE; // already got this one - reject.
				
			} else {

				// Accept it.

				PutBufferOnReceive(pReceive,pBuffer);
				pReceive->MessageSize+=(UINT)((pBuffer->pData+pBuffer->len)-pBuffer->pCmdData);

				pReceive->RCVMask |= bitmask;

				if( ((pReceive->NS-pReceive->NR)&SEQMSK) <= bit){
					pReceive->NS=(pReceive->NR+bit+1)&SEQMSK;
				}
				
				// update NR based on set received bits.
				while(pReceive->RCVMask & 1){
					pReceive->RCVMask >>= 1;
					pReceive->iNR++;
					pReceive->NR=(pReceive->NR+1)&SEQMSK;
				}

				DPF(9,"Reliable ACCEPT: pReceive %x messageid %x iNR %8x NR %2x, NS %2x RCVMask %8x, SEQMSK %2x\n",pReceive, pReceive->messageid, pReceive->iNR, pReceive->NR,pReceive->NS,pReceive->RCVMask,SEQMSK);

				rc=TRUE; // packet accepted.
			}       
			
		} else {
			DPF(9,"Reliable ACCEPT: Rejecting Packet Seq %x, NR %x, SEQMSK %x\n",pCmdInfo->sequence, pReceive->NR, SEQMSK);
		}

		if(pCmdInfo->flags & (SAK|EOM)) {
			//ACKrc=SendAppropriateResponse, check code, if ACK on EOM, then POST receive.
			rc2=SendAppropriateResponse(pProtocol, pSession, pCmdInfo, pReceive); 
			
			if(pCmdInfo->flags & EOM){
				if(rc2==SAR_ACK){
					goto ReceiveDone;
				} else {
					pReceive->fEOM=TRUE;    
				}
			} else if(pReceive->fEOM){
				if(!pReceive->RCVMask){
					goto ReceiveDone;
				}
			}
		}
	} else  {
		ASSERT(0);
	}

	Unlock(&pReceive->ReceiveLock);
	return rc;


ReceiveDone:
	DPF(9,"++>ReceiveDone\n");
	if(nToIndicate=DeQueueReceive(pSession, pReceive, pCmdInfo)){   // unlocks pReceive->ReceiveLock
		if(nToIndicate != 0xFFFFFFFF){
			IndicateReceive(pProtocol, pSession, pReceive, nToIndicate);                    
		}	
	} else if(pProtocol->m_lpDPlay->dwFlags & DPLAYI_DPLAY_PROTOCOLNOORDER){
		// Out of order receives are OK
		IndicateReceive(pProtocol, pSession, pReceive, 1);
	} else {
		QueueReceive(pProtocol,pSession,pReceive, pCmdInfo);
	}
	DPF(9,"<--ReceiveDone\n");
	return rc;
}

// Returns highest order byte in n with set bits.
UINT SetBytes(UINT n)
{
	UINT nr;
	if(n==(n&0xFFFF)){
		if(n==(n&0xFF)){
			 nr=1;
		} else {
			 nr=2;
		}
	} else {
		if(n==(n&0xFFFFFF)){
			nr=3;
		} else {
			nr=4;
		}
	}
	return nr;
}

VOID InternalSendComplete(PVOID Context, UINT Status)
{
	PSEND pSend=(PSEND)Context;

	if(pSend->dwFlags & ASEND_PROTOCOL){
		// nothing to do?
	} else if(pSend->bSendEx){
		// send completion if required
		if(pSend->dwFlags & DPSEND_ASYNC){
			DP_SP_SendComplete(pSend->pProtocol->m_lpISP, pSend->lpvUserMsgID, Status);
		}
	}
}

// Used by internal routines for sending.
VOID FillInAndSendBuffer(
	PPROTOCOL pProtocol, 
	PSESSION pSession,
	PSEND pSend,
	PBUFFER pBuffer,
	PCMDINFO pCmdInfo)
{
	pSend->pMessage                 = pBuffer;
	pSend->MessageSize              = pBuffer->len;
	
	pSend->pSession                 = pSession;
	pSend->SendOffset               = 0;
	pSend->pCurrentBuffer           = pBuffer;
	pSend->CurrentBufferOffset      = 0;

	pSend->RefCount             	= 0;
	pSend->pProtocol                = pProtocol;
	pSend->dwMsgID                  = 0;
	pSend->bSendEx                  = FALSE;

//	pSend->BytesThisSend            = 0;

	// Internal sends MUST be highest pri - else can deadlock head to head.
	pSend->Priority                         = 0xFFFFFFFF; 
	pSend->dwFlags                          = ASEND_PROTOCOL;
	pSend->dwTimeOut                        = 0;
	pSend->pAsyncInfo                       = 0;
	pSend->AsyncInfo.hEvent     			= 0;
	pSend->AsyncInfo.SendCallBack			= InternalSendComplete;
	pSend->AsyncInfo.CallBackContext		= pSend;
	pSend->AsyncInfo.pStatus   				= &pSend->Status;
	pSend->SendState                        = Start;
	pSend->RetryCount                       = 0;
	pSend->PacketSize                       = pSession->MaxPacketSize; 

	pSend->NR                               = 0;
	pSend->NS                   			= 0;

	pSend->idFrom                           = pCmdInfo->idTo;
	pSend->idTo                             = pCmdInfo->idFrom;
	pSend->wIdTo							= pCmdInfo->wIdFrom;

	pSend->serial               			= 0;

	ISend(pProtocol,pSession,pSend);
}       


UINT WrapBuffer(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	PUCHAR pMessage,pMessageStart;
	DWORD dwWrapSize=0;
	DWORD dwIdTo=0;
	DWORD dwIdFrom=0;

	pMessageStart = &pBuffer->pData[pProtocol->m_dwSPHeaderSize];
	pMessage      = pMessageStart;
	dwIdFrom      = pCmdInfo->wIdTo;
	dwIdTo        = pCmdInfo->wIdFrom;
	
	if(dwIdFrom==0x70){ // avoid looking like a system message 'play'
		dwIdFrom=0xFFFF;
	}

	if(dwIdFrom){
		while(dwIdFrom){
			*pMessage=(UCHAR)(dwIdFrom & 0x7F);
			dwIdFrom >>= 7;
			if(dwIdFrom){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}

	if(dwIdTo){
		
		while(dwIdTo){
			*pMessage=(UCHAR)(dwIdTo & 0x7F);
			dwIdTo >>= 7;
			if(dwIdTo){
				*pMessage|=0x80;
			}
			pMessage++;
		}
	} else {
		*(pMessage++)=0;
	}
	
	return (UINT)(pMessage-pMessageStart);
}       

UINT SendAppropriateResponse(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo, PRECEIVE pReceive)
{
	#define pBigACK ((pACK2)pACK)
	#define pBigNACK ((pNACK2)pNACK)

	UINT rc=SAR_FAIL;

	PSEND pSend;

	PBUFFER pBuffer;

	pFLAGS pFlags;
	pACK1  pACK;
	pNACK1 pNACK;

	UINT   RCVMask;

	UINT   WrapSize;

	// OPTIMIZATION: piggyback ACK on pending send if available.

	pSend=GetSendDesc();

	if(!pSend){
		goto exit1;
	}
	
	pBuffer = GetFrameBuffer(pProtocol->m_dwSPHeaderSize+MAX_SYS_HEADER);
	
	if(!pBuffer){
		goto exit2;     // out of memory, bail
	}       

	WrapSize  = pProtocol->m_dwSPHeaderSize;
	WrapSize += WrapBuffer(pProtocol, pCmdInfo, pBuffer);

	pFlags=(pFLAGS)&pBuffer->pData[WrapSize];

	// See if we need to ACK or NACK.
	if(pReceive->RCVMask){
		UINT nNACK=SetBytes(pReceive->RCVMask);
		rc=SAR_NACK;
		// Send a NACK  
		if(pCmdInfo->flags & BIG){
			// BIG HEADER FORMAT NACK
			pNACK=(pNACK1)(&pFlags->flag3);
			pFlags->flag1 = EXT|BIG|RLY;
			pFlags->flag2 = (byte)nNACK;
			pBigNACK->sequence = (word)pReceive->NR;
			pBigNACK->messageid = (word)pReceive->messageid;
			pBigNACK->time = pCmdInfo->tReceived;
			pBigNACK->bytes = pSession->LocalBytesReceived;
			RCVMask=pReceive->RCVMask;
			memcpy(&pBigNACK->mask, &RCVMask, nNACK);
			pBuffer->len=WrapSize+2+sizeof(NACK2)+nNACK; //2 for flags
		} else {
			// SMALL HEADER FORMAT NACK
			pNACK=(pNACK1)(&pFlags->flag3);
			pFlags->flag1 = EXT|RLY;
			ASSERT(nNACK < 4);
			ASSERT(pReceive->NR < 32);
			pFlags->flag2 = nNACK << nNACK_SHIFT;
			pNACK->messageid=(byte)pReceive->messageid;
			pNACK->sequence=(byte)pReceive->NR;
			pNACK->time = pCmdInfo->tReceived;
			pNACK->bytes = pSession->LocalBytesReceived;
			RCVMask=pReceive->RCVMask;
			memcpy(&pNACK->mask, &RCVMask, nNACK);
			pBuffer->len=WrapSize+2+sizeof(NACK1)+nNACK; // 2 for flags
			DPF(9,"RcvMask %x Send Appropriate response nNACK=%d\n",pReceive->RCVMask,nNACK);
		}
	} else {
		// Send an ACK
		rc=SAR_ACK;
		pACK    = (pACK1)(&pFlags->flag2);

		if(pCmdInfo->flags & BIG){
			// Big packet
			pFlags->flag1     = ACK|BIG;
			pBigACK->messageid= (word)pReceive->messageid;
			pBigACK->sequence = pCmdInfo->sequence;
			pBigACK->serial   = pCmdInfo->serial;
			pBigACK->time     = pCmdInfo->tReceived;
			pBigACK->bytes    = pSession->LocalBytesReceived;
			pBuffer->len      = sizeof(ACK2)+1+WrapSize;
		} else {
			// Small packet
			pFlags->flag1   = ACK;
			pACK->messageid = (byte)pReceive->messageid;
			pACK->sequence  = (UCHAR)pCmdInfo->sequence;
			pACK->serial    = pCmdInfo->serial;
			pACK->time      = pCmdInfo->tReceived;
			pACK->bytes     = pSession->LocalBytesReceived;
			pBuffer->len    = sizeof(ACK1)+1+WrapSize;
			DPF(9,"RcvMask %x Send Appropriate response ACK seq=%x\n",pReceive->RCVMask,pACK->sequence);
		}
	}
	
	pFlags->flag1 |= (pCmdInfo->flags & RLY);

	FillInAndSendBuffer(pProtocol,pSession,pSend,pBuffer,pCmdInfo);

exit1:
	return rc;

exit2:
	ReleaseSendDesc(pSend);
	return rc;

#undef pBigACK
#undef pBigNACK
}

// ACKs CmdInfo packet.
VOID SendACK(PPROTOCOL pProtocol, PSESSION pSession, PCMDINFO pCmdInfo)
{
	#define pBigACK ((pACK2)pACK)

	PSEND pSend;

	PBUFFER pBuffer;

	pFLAGS pFlags;
	pACK1 pACK;

	UINT WrapSize;

	// OPTIMIZATION: piggyback ACK on pending send if available.

	pSend=GetSendDesc();

	if(!pSend){
		goto exit1;
	}
	
	// allocation here is bigger than necessary but should 
	// recyle ACK/NACK buffers.
	pBuffer = GetFrameBuffer(pProtocol->m_dwSPHeaderSize+MAX_SYS_HEADER);
	
	if(!pBuffer){
		goto exit2;     // out of memory, bail
	}       

	WrapSize  = pProtocol->m_dwSPHeaderSize;
	WrapSize += WrapBuffer(pProtocol, pCmdInfo, pBuffer);

	pFlags=(pFLAGS)&pBuffer->pData[WrapSize];

	pACK    = (pACK1)(&pFlags->flag2);

	if(pCmdInfo->flags & BIG){
		// Big packet
		pFlags->flag1     = ACK|BIG;
		pBigACK->sequence = pCmdInfo->sequence;
		pBigACK->serial   = pCmdInfo->serial;
		pBigACK->messageid= pCmdInfo->messageid;
		pBigACK->bytes    = pSession->LocalBytesReceived;
		pBigACK->time     = pCmdInfo->tReceived;
		pBuffer->len    = sizeof(ACK2)+1+WrapSize;
	} else {
		// Small packet
		pFlags->flag1   = ACK;
		pACK->messageid = (UCHAR)pCmdInfo->messageid;
		pACK->sequence  = (UCHAR)pCmdInfo->sequence;
		pACK->serial    = pCmdInfo->serial;
		pACK->bytes     = pSession->LocalBytesReceived;
		pACK->time      = pCmdInfo->tReceived;
		pBuffer->len    = sizeof(ACK1)+1+WrapSize;
		DPF(9,"Send Extra ACK seq=%x, serial=%x\n",pACK->sequence,pACK->serial);
	}

	pFlags->flag1 |= (pCmdInfo->flags & RLY);
	
	FillInAndSendBuffer(pProtocol,pSession,pSend,pBuffer,pCmdInfo);
	
exit1:
	return;

exit2:
	ReleaseSendDesc(pSend);
	return;
}

// Called with receive lock.  Returns without lock.
UINT DGAccept(PPROTOCOL pProtocol, PSESSION pSession, PRECEIVE pReceive, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	
	ASSERT(!pReceive->fBusy);
	//if(!pReceive->fBusy){

		// Allows datagram receive to start on any serial.
		if(pCmdInfo->flags & STA){
			pReceive->NR=pCmdInfo->serial;
		}
	
		if(pReceive->NR == pCmdInfo->serial){

			pReceive->iNR++;        //really unnecessary, but interesting.

			pReceive->NR = (pReceive->NR+1) & SEQMSK;

			// Add the buffer to the receive buffer list.
			InsertBefore(&pBuffer->BuffList, &pReceive->RcvBuffList);
			pReceive->MessageSize+=(UINT)((pBuffer->pData+pBuffer->len)-pBuffer->pCmdData);

			if(pCmdInfo->flags & EOM){
				DGDeQueueReceive(pSession, pReceive); //unlock's receive.
				IndicateReceive(pProtocol, pSession, pReceive,1);                       
			} else {
				Unlock(&pReceive->ReceiveLock);
			}

			return TRUE; // ate the buffer.
			
		} else {
			// Throw this puppy out.
			ASSERT(!pReceive->fBusy);
			DGDeQueueReceive(pSession, pReceive);
			FreeReceive(pProtocol, pReceive);
		}

	//}
	return FALSE;
}

UINT CommandReceive(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PBUFFER pBuffer)
{
	#define flags pCmdInfo->flags
	PSESSION      pSession;
	UINT          rc=0;             // by default, buffer not accepted.
	PRECEIVE      pReceive;

	pSession=GetSysSessionByIndex(pProtocol, pCmdInfo->wIdFrom);

	if(!pSession) {
		DPF(9,"CommandReceive: Throwing out receive for gone session\n");
		goto drop_exit;
	}
	
	if(flags & BIG){
		if(flags & RLY) {
			pSession->fReceiveSmall=FALSE;
		} else {
			pSession->fReceiveSmallDG=FALSE;
		}
	}

	// See if this receive is already ongoing - if found, it is locked.
	pReceive=GetReceive(pProtocol, pSession, pCmdInfo, pBuffer);

	if(pCmdInfo->command==0){
		pSession->LocalBytesReceived+=pBuffer->len;
	}

	if(!(flags & RLY)){
		if(flags & (SAK|EOM)) {
			SendACK(pProtocol, pSession, pCmdInfo);
		}
	}

	if(pReceive){
		if(flags & RLY){
			// unlocks receive when done.
			rc=ReliableAccept(pProtocol, pSession, pReceive, pCmdInfo, pBuffer);
		} else {
			rc=DGAccept(pProtocol, pSession, pReceive, pCmdInfo, pBuffer);
		}
	}


	DecSessionRef(pSession);
	
drop_exit:
	return rc;

	#undef flags
}


BOOL CompleteSend(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo)
{
	UINT bit;
	UINT MsgMask;

	pSend->SendState=Done;

	if(pCmdInfo->flags & BIG){
		MsgMask = 0xFFFF;
	} else {
		MsgMask = 0xFF;
	}       

	DPF(9,"CompleteSend, pSession %x pSend %x\n",pSession,pSend);

	//
	// Update Session information for completion of this send.
	//
	
	bit = ((pCmdInfo->messageid-pSession->FirstMsg) & MsgMask)-1;

	// clear the message mask bit for the completed send.
	if(pSession->OutMsgMask & 1<<bit){
		pSession->OutMsgMask &= ~(1<<bit);
	} else {
		Unlock(&pSession->SessionLock);
		return TRUE;
	}

	// slide the first message count forward for each low
	// bit clear in Message mask.
	while(pSession->LastMsg-pSession->FirstMsg){
		if(!(pSession->OutMsgMask & 1)){
			pSession->FirstMsg=(pSession->FirstMsg+1)&MsgMask;
			pSession->OutMsgMask >>= 1;
			if(pSession->nWaitingForMessageid){
				pSession->pProtocol->m_bRescanQueue=TRUE;
				DPF(9,"Signalling reliable ID Sem, nWaitingForMessageid was %d\n",pSession->nWaitingForMessageid);
				SetEvent(pSession->pProtocol->m_hSendEvent);
			}       
		} else {
			break;
		}
	}
	
	//
	// Return the Send to the pool and complete the waiting client.
	//

	Unlock(&pSession->SessionLock);
	
	ASSERT(pSend->RefCount);

	// Send completed, do completion
	DoSendCompletion(pSend, DP_OK);

	DecSendRef(pSession->pProtocol, pSend); // for completion.

	return TRUE;
}

// called with session lock held
VOID ProcessDGACK(PSESSION pSession, PCMDINFO pCmdInfo)
{
	BILINK *pBilink;
	PSENDSTAT pStatWalker,pStat=NULL;

	Lock(&pSession->SessionStatLock);
	
	pBilink=pSession->DGStatList.next;
	
	while(pBilink != &pSession->DGStatList){
		pStatWalker=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
		if((pStatWalker->messageid == pCmdInfo->messageid) && 	// correct messageid
		   (pStatWalker->sequence  == pCmdInfo->sequence)       // correct sequence
		   // don't check serial, since datagrams are always serial 0, never retried.
		  )
		{  
			pStat=pStatWalker;
			break;
		}
		pBilink=pBilink->next;
	}


	if(pStat){
	
		UpdateSessionStats(pSession,pStat,pCmdInfo,FALSE);

		// Unlink All Previous SENDSTATS;
		pStat->StatList.next->prev=&pSession->DGStatList;
		pSession->DGStatList.next=pStat->StatList.next;

		// Put the SENDSTATS back in the pool.
		while(pBilink != &pSession->DGStatList){
			pStatWalker=CONTAINING_RECORD(pBilink, SENDSTAT, StatList);
			pBilink=pBilink->prev;
			ReleaseSendStat(pStatWalker);
		}

	}	
	
	Unlock(&pSession->SessionStatLock);

}

// update a send's information for an ACK.
// called with SESSIONion lock held.
// now always drops the sessionlock
BOOL ProcessReliableACK(PSESSION pSession, PCMDINFO pCmdInfo)
{
	PSEND pSend=NULL, pSendWalker;
	BILINK *pBilink;
	UINT nFrame;
	UINT nAdvance;

	Unlock(&pSession->SessionLock);
	Lock(&pSession->pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);
	
	pBilink=pSession->SendQ.next;
	
	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		if((pSendWalker->messageid == pCmdInfo->messageid) && 	// correct messageid
		   (!(pSendWalker->dwFlags & ASEND_PROTOCOL)) &&		// not and internal message
		   (pSendWalker->dwFlags & DPSEND_GUARANTEED)){         // guaranteed
			pSend=pSendWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	// need a reference to avoid processing a send as 
	// it is being recycled for another send.
	if(pSend){
		if(!AddSendRef(pSend,1)){
			pSend=NULL;
		}
	}

	Unlock(&pSession->pProtocol->m_SendQLock);
	// SessionLock still held.

	if(pSend){

		Lock(&pSend->SendLock);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo,FALSE);

		// we need to make sure this send isn't already finished.
		switch(pSend->SendState){
		
			case    Sending:
			case 	Throttled:
			case	WaitingForAck:
			case	WaitingForId:
			case 	ReadyToSend:
				break;

			case Start:		// shouldn't be getting an ACK for a send in the start state.
			case TimedOut:
			case Cancelled:
			case UserTimeOut:
			case Done:
				// this send is already done, don't do processing on it.
				DPF(4,"PRACK:Not processing ACK on send in State (B#22359 avoided)%x\n",pSend->SendState);
				Unlock(&pSend->SendLock);
				Unlock(&pSession->SessionLock);
				DecSendRef(pSession->pProtocol,pSend); // balances AddSendRef in this fn
				return TRUE; // SessionLock dropped
				break;
				
			default:
				break;
		}

		pSend->fUpdate=TRUE;

		nFrame=(pCmdInfo->sequence-pSend->NR)&pSend->SendSEQMSK;
		
		if(nFrame > (pSend->NS - pSend->NR)){
			// Out of range.
			DPF(9,"ReliableACK:Got out of range ACK, SQMSK=%x NS=%d NR=%d ACK=%d\n",pSend->SendSEQMSK,pSend->NS&pSend->SendSEQMSK, pSend->NR&pSend->SendSEQMSK, (pSend->NR+nFrame)&pSend->SendSEQMSK);
			Unlock(&pSend->SendLock);
			Unlock(&pSession->SessionLock);
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE; // SessionLock dropped
		}

		CancelRetryTimer(pSend);

		DPF(9,"ProcessReliableACK (before): pSend->NR %x pSend->OpenWindow %x, pSend->NACKMask %x\n",pSend->NR, pSend->OpenWindow, pSend->NACKMask);

		pSend->NR=(pSend->NR+nFrame);
		pSend->OpenWindow -= nFrame;
		pSend->NACKMask >>= nFrame;
		ASSERT_NACKMask(pSend);
		AdvanceSend(pSend,pSend->FrameDataLen*nFrame); // can put us past on the last frame, but that's ok.

		DPF(9,"ProcessReliableACK: Send->nFrames %2x NR %2x NS %2x nFrame %2x NACKMask %x\n",pSend->nFrames,pSend->NR, pSend->NS, nFrame, pSend->NACKMask);

		if(pSend->NR==pSend->nFrames){
			// LAST ACK, we're done!
			pSend->SendState=Done;
			Unlock(&pSend->SendLock);
			// SessionLock still held
			CompleteSend(pSession, pSend, pCmdInfo);// drops SessionLock
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE;
		} else {
			// set new "NACK bits" for extra window opening
			if(pSend->NR+pSend->OpenWindow+nFrame > pSend->nFrames){
				nAdvance=pSend->nFrames-(pSend->NR+pSend->OpenWindow);
				DPF(9,"A nAdvance %d\n",nAdvance);
			} else {
				nAdvance=nFrame;
				DPF(9,"B nAdvance %d\n",nAdvance);
			}
			pSend->NACKMask |= ((1<<nAdvance)-1)<<pSend->OpenWindow;
			pSend->OpenWindow += nAdvance;
			DPF(9,"pSend->NACKMask=%x\n",pSend->NACKMask);
			ASSERT_NACKMask(pSend);
		}

		switch(pSend->SendState){

			case Start:
				DPF(1,"ERROR, ACK ON UNSTARTED SEND!\n");
				ASSERT(0);
				break;

			case Done:
				DPF(1,"ERROR, ACK ON DONE SEND!\n");
				ASSERT(0);
				break;
				
			case WaitingForAck:
				pSend->SendState=ReadyToSend;
				SetEvent(pSession->pProtocol->m_hSendEvent);
				break;

			case ReadyToSend:
			case Sending:
			case Throttled:
			default:
				break;
		}

		Unlock(&pSend->SendLock);
	} else {        
		DPF(9,"ProcessReliableACK: dup ACK ignoring\n");
	}
	Unlock(&pSession->SessionLock);
	
	if(pSend){
		DecSendRef(pSession->pProtocol, pSend);
	}	
	return TRUE; // SessionLock dropped
}

//called with session lock held, always drops lock.
BOOL ProcessReliableNACK(PSESSION pSession, PCMDINFO pCmdInfo,PUCHAR pNACKmask, UINT nNACK)
{
	UINT NACKmask=0;
	UINT NACKshift=0;

	PSEND pSend=NULL, pSendWalker;
	BILINK *pBilink;
	UINT nFrame;
	UINT nAdvance;
	UINT nAdvanceShift;

	DWORD nDropped=0;

	DPF(9,"==>ProcessReliableNACK\n");

	Unlock(&pSession->SessionLock);
	Lock(&pSession->pProtocol->m_SendQLock);
	Lock(&pSession->SessionLock);

	pBilink=pSession->SendQ.next;
	
	while(pBilink != &pSession->SendQ){
		pSendWalker=CONTAINING_RECORD(pBilink, SEND, SendQ);
		if(pSendWalker->dwFlags & DPSEND_GUARANTEE && 
		   pSendWalker->messageid == pCmdInfo->messageid){
			pSend=pSendWalker;
			break;
		}
		pBilink=pBilink->next;
	}

	// need a reference to avoid processing a send as 
	// it is being recycled for another send.
	if(pSend){
		if(!AddSendRef(pSend,1)){
			pSend=NULL;
		}
	}	
	
	Unlock(&pSession->pProtocol->m_SendQLock);
	// SessionLock still held.

	if(pSend){

		Lock(&pSend->SendLock);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo,FALSE);

		// we need to make sure this send isn't already finished.
		switch(pSend->SendState){
		
			case    Sending:
			case 	Throttled:
			case	WaitingForAck:
			case	WaitingForId:
			case 	ReadyToSend:
				break;

			case Start:		// shouldn't be getting an ACK for a send in the start state.
			case TimedOut:
			case Cancelled:
			case UserTimeOut:
			case Done:
				// this send is already done, don't do processing on it.
				DPF(4,"PRNACK:Not processing NACK on send in State (B#22359 avoided)%x\n",pSend->SendState);
				Unlock(&pSend->SendLock);
				Unlock(&pSession->SessionLock);
				DecSendRef(pSession->pProtocol,pSend); // balances AddSendRef in this fn
				return TRUE; // SessionLock dropped
				break;
				
			default:
				break;
		}

		DPF(9,"Reliable NACK for Send %x, pCmdInfo %x\n",pSend, pCmdInfo);
		
		pSend->fUpdate=TRUE;
		// Do regular NR updates (OPTIMIZATION: fold with process reliable ACK)
		nFrame=(pCmdInfo->sequence-pSend->NR) & pSend->SendSEQMSK;
		
		if(nFrame > (pSend->NS - pSend->NR)){
			// Out of range.
			DPF(9,"ReliableNACK:Got out of range NACK, SQMSK=%x NS=%d NR=%d ACK=%d\n",pSend->SendSEQMSK,pSend->NS&pSend->SendSEQMSK, pSend->NR&pSend->SendSEQMSK, (pSend->NR+nFrame)&pSend->SendSEQMSK);
			Unlock(&pSend->SendLock);
			Unlock(&pSession->SessionLock);
			DecSendRef(pSession->pProtocol,pSend);
			return TRUE;
		}

		CancelRetryTimer(pSend);

		DPF(9,"NACK0: pSend->NACKMask %x, OpenWindow %d\n",pSend->NACKMask, pSend->OpenWindow);

		pSend->NR=(pSend->NR+nFrame);
		pSend->OpenWindow -= nFrame;
		pSend->NACKMask >>= nFrame;
		ASSERT_NACKMask(pSend);
		AdvanceSend(pSend,pSend->FrameDataLen*nFrame);

		DPF(9,"ProcessReliableNACK: Send->nFrames %2x NR %2x NS %2x nFrame %2x NACKMask %x\n",pSend->nFrames,pSend->NR, pSend->NS, nFrame, pSend->NACKMask);

		ASSERT(pSend->NR != pSend->nFrames);
		// set new "NACK bits" for extra window opening
		if(pSend->NR+pSend->OpenWindow+nFrame > pSend->nFrames){
			nAdvance=pSend->nFrames-(pSend->NR+pSend->OpenWindow);
			DPF(9, "NACK: 1 nAdvance %d\n",nAdvance);
		} else {
			nAdvance=nFrame;
			DPF(9, "NACK: 2 nAdvance %d\n",nAdvance);
		}
		pSend->NACKMask |= ((1<<nAdvance)-1)<<pSend->OpenWindow;

		DPF(9, "NACK Mask %x\n",pSend->NACKMask);
		pSend->OpenWindow += nAdvance;
		ASSERT_NACKMask(pSend);


		while(nNACK--){
			NACKmask |= (*(pNACKmask++))<<NACKshift;
			NACKshift+=8;
		}

		DPF(9,"NACKmask in NACK %x\n",NACKmask);

		// set the NACK mask.
		nAdvanceShift=0;
		while(NACKmask){
			if(NACKmask&1){
				// set bits are ACKs.
				pSend->NACKMask&=~(1<<nAdvanceShift);
			} else {
				// clear bits are NACKs.
				pSend->NACKMask|=1<<nAdvanceShift;
				nDropped++;
			}
			NACKmask >>= 1;
			nAdvanceShift++;
		}
		DPF(9,"ProcessReliableNACK: pSend->NACKMask=%x\n",pSend->NACKMask);
		ASSERT_NACKMask(pSend);

		UpdateSessionSendStats(pSession,pSend,pCmdInfo, ((nDropped > 1) ? TRUE:FALSE) );
	
		switch(pSend->SendState){

			case Start:
				DPF(5,"ERROR, NACK ON UNSTARTED SEND!\n");
				ASSERT(0);
				break;

			case Done:
				DPF(5,"ERROR, NACK ON DONE SEND!\n");
				ASSERT(0);
				break;
				
			case WaitingForAck:
				pSend->SendState=ReadyToSend;
				SetEvent(pSession->pProtocol->m_hSendEvent);
				break;

			case ReadyToSend:
			case Sending:
			case Throttled:
			default:
				break;
		}
		Unlock(&pSend->SendLock);
	} else {
		// OPTIMIZATION: reliable NACK for send we aren't doing? Ignore or send abort?
		DPF(0,"Reliable NACK for send we aren't doing? Ignore?\n");
	}

	Unlock(&pSession->SessionLock);
	
	if(pSend){
		DecSendRef(pSession->pProtocol,pSend);
	}
	return TRUE;
	
	#undef pBigNACK
}

VOID ProcessACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo)
{
	PSESSION      pSession;
	UINT          rc=0;             // by default, buffer not accepted.
	BOOL          fUnlockedSession=FALSE;

	// Find the Send for this ACK.

	DPF(9,"ProcessACK\n");

	pSession=GetSysSessionByIndex(pProtocol,pCmdInfo->wIdFrom);

	if(!pSession) {
		goto exit;
	}
	
	Lock(&pSession->SessionLock);

	// Find the message with the id, make sure its the same type of send.
	if(pCmdInfo->flags & RLY){
		if(pCmdInfo->flags & BIG){
			//NOTE: if messageid, FirstMsg and LastMsg are SHORT, no masking req'd
			if((pCmdInfo->messageid==pSession->FirstMsg)||((pCmdInfo->messageid-pSession->FirstMsg)&0xFFFF) > ((pSession->LastMsg-pSession->FirstMsg)&0xFFFF)){
				DPF(9,"Ignoring out of range ACK\n");
				goto exit1;
			}
		} else {
			if((pCmdInfo->messageid==pSession->FirstMsg)||((pCmdInfo->messageid-pSession->FirstMsg)&0xFF) > ((pSession->LastMsg-pSession->FirstMsg)&0xFF)){
				// out of range, ignore
				DPF(9,"Ignoring out of range ACK\n");
				goto exit1;
			} 
		}
		ProcessReliableACK(pSession,pCmdInfo); //now always unlocks session.
		fUnlockedSession=TRUE;
	} else {
		ProcessDGACK(pSession,pCmdInfo);
	}

exit1:  
	if(!fUnlockedSession){  
		Unlock(&pSession->SessionLock);
	}
	
	DecSessionRef(pSession);

exit:
	return;

	#undef pBigACK
}

VOID ProcessNACK(PPROTOCOL pProtocol, PCMDINFO pCmdInfo, PUCHAR pNACKmask, UINT nNACK)
{
	#define pBigNACK ((pNACK2)pNACK)

	PSESSION      pSession;

	pSession=GetSysSessionByIndex(pProtocol, pCmdInfo->wIdFrom);

	if(!pSession) {
		ASSERT(0);
		goto exit;
	}

	Lock(&pSession->SessionLock);

	if(pCmdInfo->flags & RLY){
		ProcessReliableNACK(pSession,pCmdInfo,pNACKmask, nNACK); // drops SessionLock
	} else {
		Unlock(&pSession->SessionLock);
		DPF(0,"FATAL: non-reliable NACK???\n");
		ASSERT(0);
	}

	DecSessionRef(pSession);
	
exit:
	return;
}


UINT AssertMe(REQUEST_PARAMS)
{
	DEBUG_BREAK();
	return TRUE;
}

UINT Ping(REQUEST_PARAMS){return TRUE;}
UINT PingResp(REQUEST_PARAMS){return TRUE;}
UINT GetTime(REQUEST_PARAMS){return TRUE;}
UINT GetTimeResp(REQUEST_PARAMS){return TRUE;}
UINT SetTime(REQUEST_PARAMS){return TRUE;}
UINT SetTimeResp(REQUEST_PARAMS){return TRUE;}

VOID ProcessAbort(PPROTOCOL pProtocol, DPID idFrom, DPID idTo, pABT1 pABT, BOOL fBig){}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=w32
USE_MAPSYM=1

#SYNCHRONIZE_BLOCK=1

TARGETNAME=protocol
TARGETPATH=.\obj$(BUILD_ALT_DIR)
#$(BASEDIR)\public\sdk\lib\$(ALT_PROJECT_TARGET)
TARGETTYPE=LIBRARY

INCLUDES= \
    $(DXROOT)\inc; \
    ..\;\
    ..\..\..\dplay\dplay;\
    ..\..\..\dplay\common;\
    ..\..\..\misc; \
    ..\..\..\dplobby\dplobby; \
    ..\..\..\dvoice\inc;

#SYNCHRONIZE_DRAIN=1

C_DEFINES=$(C_DEFINES) -DWINVER=0x0400

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES)	-DUNICODE -D_UNICODE -DNEW_DPF -DSECURITY_WIN32


NTPROFILEINPUT=yes


SOURCES= \
		..\HANDLES.C     \
        ..\PROTOCOL.C    \
        ..\PSESSION.C    \
        ..\SEND.C        \
        ..\RECEIVE.C     \
        ..\STATS.C       \
        ..\BUFMGR.C      \
        ..\FRAMEBUF.C    \
        ..\SENDPOOL.C    \
        ..\BUFPOOL.C     \
        ..\RCVPOOL.C     \
        ..\STATPOOL.C    \
        ..\BILINK.C      \
		..\TIMER.C       \
        ..\MYDEBUG.C     


#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\statpool.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    STATPOOL.CPP

Abstract:

	Maintains pool of Stat structures.

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date    Author  Description
   =======  ======  ============================================================
   1/30/97  aarono  Original

--*/

#include <windows.h>
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"


PSENDSTAT		 pSendStatPool=NULL;
UINT             nSendStatsAllocated=0;	// Number Allocated
UINT             nSendStatsInUse=0;		    // Number currently in use
UINT             nMaxSendStatsInUse=0;      // Maximum number in use since last TICK.

CRITICAL_SECTION SendStatLock;

VOID InitSendStats(VOID)
{
	InitializeCriticalSection(&SendStatLock);
}

VOID FiniSendStats(VOID)
{
	PSENDSTAT pSendStat;
	
	ASSERT(nSendStatsInUse==0);
	
	while(pSendStatPool){
		pSendStat=pSendStatPool;
		ASSERT_SIGN(pSendStat, SENDSTAT_SIGN);
		pSendStatPool=pSendStatPool->pNext;
		My_GlobalFree(pSendStat);
		nSendStatsAllocated--;
	}
	
	ASSERT(nSendStatsAllocated==0);
	
	DeleteCriticalSection(&SendStatLock);
}

PSENDSTAT GetSendStat(VOID)
{
	PSENDSTAT pSendStat;

	Lock(&SendStatLock);
	
	if(!pSendStatPool){
	
		Unlock(&SendStatLock);
		pSendStat=(PSENDSTAT)My_GlobalAlloc(GMEM_FIXED, sizeof(SENDSTAT));
		Lock(&SendStatLock);
		if(pSendStat){
			SET_SIGN(pSendStat,SENDSTAT_SIGN);			
			nSendStatsAllocated++;
		}
	} else {
		pSendStat=pSendStatPool;
		ASSERT_SIGN(pSendStat, SENDSTAT_SIGN);
		pSendStatPool=pSendStatPool->pNext;
		
	}

	if(pSendStat){
		nSendStatsInUse++;
		if( nSendStatsInUse > nMaxSendStatsInUse ){
			nMaxSendStatsInUse = nSendStatsInUse;
		}
	}

	ASSERT(nSendStatsAllocated >= nSendStatsInUse);

	Unlock(&SendStatLock);

	return pSendStat;
}

VOID ReleaseSendStat(PSENDSTAT pSendStat)
{
	Lock(&SendStatLock);
	nSendStatsInUse--;
	ASSERT(!(nSendStatsInUse&0x80000000));
	pSendStat->pNext=pSendStatPool;
	pSendStatPool=pSendStat;
	Unlock(&SendStatLock);

}

#if 0
// let virtual memory handle this.
LONG fInSendStatTick=0;

VOID SendStatTick(VOID)
{
	PSENDSTAT pSendStat;
#ifdef DEBUG
	LONG fLast; 
#endif
	// Adjusts Number of allocated buffers to 
	// highwater mark over the last ticks.
	// Call once per delta t (around a minute).
	DEBUG_BREAK(); //TRACE all paths.

	if(!InterlockedExchange(&fInSendStatTick, 1)){
	
		Lock(&SendStatLock);
		
		while((nSendStatsAllocated > nMaxSendStatsInUse) && pSendStatPool){
		
			pSendStat=pSendStatPool;
			ASSERT_SIGN(pSendStat,SENDSTAT_SIGN);
			pSendStatPool=pSendStatPool->pNext;
			
			Unlock(&SendStatLock);
			My_GlobalFree(pSendStat);
			Lock(&SendStatLock);
			nSendStatsAllocated--;
			
		}
		nMaxSendStatsInUse=nSendStatsInUse;

		ASSERT(nMaxSendStatsInUse <= nSendStatsAllocated);
		
		Unlock(&SendStatLock);
#ifdef DEBUG
		fLast=
#endif
		InterlockedExchange(&fInSendStatTick, 0);
#ifdef DEBUG
		ASSERT(fLast==1);
#endif
	}	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\timer.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

    TIMER.C

Abstract:

	Handle adjusting timer resolution for throttling and do thread pool

Author:

	Aaron Ogus (aarono)

Environment:

	Win32

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   6/04/98 aarono  Original

--*/

#include <windows.h>
#include "newdpf.h"
#include <mmsystem.h>
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "macros.h"
#include "mytimer.h"


#define DEFAULT_TIME_RESOLUTION 20	/* ms */
#define MIN_TIMER_THREADS	1
#define MAX_TIMER_THREADS 5


VOID QueueTimeout(PMYTIMER pTimer);
DWORD WINAPI TimerWorkerThread(LPVOID foo);


// Timer Resolution adjustments;
DWORD dwOldPeriod=DEFAULT_TIME_RESOLUTION; 
DWORD dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
DWORD dwPeriodInUse=DEFAULT_TIME_RESOLUTION;


BILINK MyTimerList={&MyTimerList, &MyTimerList};
CRITICAL_SECTION MyTimerListLock;

LPFPOOL pTimerPool=NULL;
DWORD uWorkaroundTimerID;

DWORD twInitCount=0;	//number of times init called, only inits on 0->1, deinit on 1->0

DWORD Unique=0;


CRITICAL_SECTION ThreadListLock;		// locks ALL this stuff.

BILINK ThreadList={&ThreadList,&ThreadList};	// ThreadPool grabs work from here.

DWORD nThreads=0;		// number of running threads.
DWORD ActiveReq=0;		// number of requests being processed.
DWORD PeakReqs=0;
DWORD bShutDown=FALSE;
DWORD bAlreadyCleanedUp=FALSE;
DWORD KillCount=0;
DWORD ExtraSignals=0;

HANDLE hWorkToDoSem;
HANDLE hShutDownPeriodicTimer;

DWORD_PTR uAdjustResTimer=0;
DWORD AdjustResUnique=0;

DWORD_PTR uAdjustThreadsTimer=0;
DWORD AdjustThreadsUnique=0;

// Sometimes scheduled retry timers don't run.  This runs every 10 seconds to catch
// timers that should have been expired.
void CALLBACK PeriodicTimer (UINT uID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2)
{
	DWORD  time;
	PMYTIMER  pTimerWalker;
	BILINK *pBilink;
	DWORD dwReleaseCount=0;
	DWORD slowcount=0;

	if(bShutDown){
		if(!InterlockedExchange(&bAlreadyCleanedUp,1)){
			while(nThreads && slowcount < (60000/50)){	// don't wait more than 60 seconds.
				slowcount++;
				Sleep(50);
			}
			if(!nThreads){ // better to leak than to crash.
				DeleteCriticalSection(&MyTimerListLock);
				DeleteCriticalSection(&ThreadListLock);
			}	
			timeKillEvent(uID);
			ASSERT(hShutDownPeriodicTimer);
			SetEvent(hShutDownPeriodicTimer);
		}	
		return;
	}

	time=timeGetTime()+(dwCurrentPeriod/2);
		
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	pBilink=MyTimerList.next;

	while(pBilink!=&MyTimerList){
	
		pTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pBilink=pBilink->next;

		if(((INT)(time-pTimerWalker->TimeOut) > 0)){
			Delete(&pTimerWalker->Bilink);
			InsertBefore(&pTimerWalker->Bilink, &ThreadList);
			pTimerWalker->TimerState=QueuedForThread;
			dwReleaseCount++;
		} else {
			break;
		}

	}

	ActiveReq += dwReleaseCount;
	if(ActiveReq > PeakReqs){
		PeakReqs=ActiveReq;
	}
	
	ReleaseSemaphore(hWorkToDoSem,dwReleaseCount,NULL);

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);

}

#define min(a,b)            (((a) < (b)) ? (a) : (b))

VOID CALLBACK AdjustTimerResolution(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	DWORD dwWantPeriod;

	dwWantPeriod=min(dwCurrentPeriod,dwOldPeriod);
	dwOldPeriod=dwCurrentPeriod;
	dwCurrentPeriod=DEFAULT_TIME_RESOLUTION;
	
	if(dwPeriodInUse != dwWantPeriod){
		dwPeriodInUse=dwWantPeriod;
		timeKillEvent(uWorkaroundTimerID);
		uWorkaroundTimerID=timeSetEvent(dwPeriodInUse, dwPeriodInUse, PeriodicTimer, 0, TIME_PERIODIC); 
	}
	uAdjustResTimer=SetMyTimer(1000,500,AdjustTimerResolution,0,&AdjustResUnique);
}

VOID CALLBACK AdjustThreads(UINT_PTR uID, UINT uMsg, DWORD_PTR dwUser, DWORD dw1, DWORD dw2)
{
	Lock(&ThreadListLock);
	if((PeakReqs < nThreads) && nThreads){
		KillCount=nThreads-PeakReqs;
		ReleaseSemaphore(hWorkToDoSem, KillCount, NULL);
	}
	PeakReqs=0;
	Unlock(&ThreadListLock);
	
	uAdjustThreadsTimer=SetMyTimer(60000,500,AdjustThreads,0,&AdjustThreadsUnique);
}

VOID SetTimerResolution(UINT msResolution)
{

	if(!msResolution || msResolution >= 20){
		return;
	}

	if(msResolution < dwCurrentPeriod){
		dwCurrentPeriod=msResolution;
	}
	
}

DWORD_PTR SetMyTimer(DWORD dwTimeOut, DWORD TimerRes, MYTIMERCALLBACK TimerCallBack, DWORD_PTR UserContext, PUINT pUnique)
{

	BILINK *pBilink;
	PMYTIMER pMyTimerWalker,pTimer;
	DWORD time;
	BOOL bInserted=FALSE;

	pTimer=pTimerPool->Get(pTimerPool);
	
	if(!pTimer){
		*pUnique=0;
		return 0;
	}

	pTimer->CallBack=TimerCallBack;
	pTimer->Context=UserContext;

	SetTimerResolution(TimerRes);
	
	Lock(&MyTimerListLock);
	
		++Unique;
		if(Unique==0){
			++Unique;
		}
		*pUnique=Unique;

		pTimer->Unique=Unique;
	
		time=timeGetTime();
		pTimer->TimeOut=time+dwTimeOut;
		pTimer->TimerState=WaitingForTimeout;
	

		// Insert this guy in the list by timeout time.
		pBilink=MyTimerList.prev;
		while(pBilink != &MyTimerList){
			pMyTimerWalker=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
			pBilink=pBilink->prev;
			
			if((int)(pTimer->TimeOut-pMyTimerWalker->TimeOut) > 0 ){
				InsertAfter(&pTimer->Bilink, &pMyTimerWalker->Bilink);
				bInserted=TRUE;
				break;
			}
		}

		if(!bInserted){
			InsertAfter(&pTimer->Bilink, &MyTimerList);
		}
	
	Unlock(&MyTimerListLock);

	return (DWORD_PTR)pTimer;
}


HRESULT CancelMyTimer(DWORD_PTR dwTimer, DWORD Unique)
{
	PMYTIMER pTimer=(PMYTIMER)dwTimer;
	HRESULT hr=DPERR_GENERIC;
	
	Lock(&MyTimerListLock);
	Lock(&ThreadListLock);

	if(pTimer->Unique == Unique){
		switch(pTimer->TimerState){
			case WaitingForTimeout:
				Delete(&pTimer->Bilink);
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				hr=DP_OK;
				break;

			case QueuedForThread:
				Delete(&pTimer->Bilink);
				pTimer->TimerState=End;
				pTimer->Unique=0;
				pTimerPool->Release(pTimerPool, pTimer);
				if(ActiveReq)ActiveReq--;
				ExtraSignals++;
				hr=DP_OK;
				break;

			default:
				break;
		}
	}

	Unlock(&ThreadListLock);
	Unlock(&MyTimerListLock);
	return hr;
}

HRESULT InitTimerWorkaround()
{
	DWORD dwJunk;
	HANDLE hWorker=NULL;

	if(twInitCount++){//DPLAY LOCK HELD DURING CALL
		return DP_OK;
	}
	
    pTimerPool=NULL;
    nThreads=0;		// number of running threads.
    ActiveReq=0;		// number of requests being processed.
    PeakReqs=0;
    bShutDown=FALSE;
    KillCount=0;
	ExtraSignals=0;
	bAlreadyCleanedUp=FALSE;
	hWorkToDoSem=0;
	hShutDownPeriodicTimer=0;
	uAdjustResTimer=0;
	uAdjustThreadsTimer=0;
	uWorkaroundTimerID=0;

	hWorkToDoSem=CreateSemaphoreA(NULL,0,65535,NULL);
	hShutDownPeriodicTimer=CreateEventA(NULL,FALSE,FALSE,NULL);

	InitializeCriticalSection(&MyTimerListLock);
	InitializeCriticalSection(&ThreadListLock);

	pTimerPool=FPM_Init(sizeof(MYTIMER),NULL,NULL,NULL);
	
	
	if(!hWorkToDoSem || !pTimerPool || !hShutDownPeriodicTimer){
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}

	uWorkaroundTimerID=timeSetEvent(DEFAULT_TIME_RESOLUTION, DEFAULT_TIME_RESOLUTION, PeriodicTimer, 0, TIME_PERIODIC); 

	if(!uWorkaroundTimerID){
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}

	nThreads=1;
	hWorker=CreateThread(NULL,4096, TimerWorkerThread, NULL, 0, &dwJunk);
	if(!hWorker){
		nThreads=0;
		FiniTimerWorkaround();
		return DPERR_OUTOFMEMORY;
	}
	CloseHandle(hWorker);

	uAdjustResTimer=SetMyTimer(1000,500,AdjustTimerResolution,0,&AdjustResUnique);
	uAdjustThreadsTimer=SetMyTimer(60000,500,AdjustThreads,0,&AdjustThreadsUnique);
	
	
	return DP_OK;

}

VOID FiniTimerWorkaround()
{
	UINT slowcount=0;
	BILINK *pBilink;
	PMYTIMER pTimer;

	if(--twInitCount){ //DPLAY LOCK HELD DURING CALL
		return;
	}

	if(uAdjustResTimer){
		CancelMyTimer(uAdjustResTimer, AdjustResUnique);
	}
	if(uAdjustThreadsTimer){
		CancelMyTimer(uAdjustThreadsTimer, AdjustThreadsUnique);
	}	
	//ASSERT_EMPTY_BILINK(&MyTimerList);
	//ASSERT_EMPTY_BILINK(&ThreadList);
	bShutDown=TRUE;
	ReleaseSemaphore(hWorkToDoSem,10000,NULL);
	while(nThreads && slowcount < (60000/50)){	// don't wait more than 60 seconds.
		slowcount++;
		Sleep(50);
	}
	
	if(uWorkaroundTimerID){
		if(hShutDownPeriodicTimer){
			WaitForSingleObject(hShutDownPeriodicTimer,INFINITE);
		}	
	} else {
		DeleteCriticalSection(&MyTimerListLock);
		DeleteCriticalSection(&ThreadListLock);
	}	

	if(hShutDownPeriodicTimer){
		CloseHandle(hShutDownPeriodicTimer);
		hShutDownPeriodicTimer=0;
	}

	CloseHandle(hWorkToDoSem);

	while(!EMPTY_BILINK(&MyTimerList)){
		pBilink=MyTimerList.next;
		pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		Delete(&pTimer->Bilink);
		pTimerPool->Release(pTimerPool, pTimer);
	}

	while(!EMPTY_BILINK(&MyTimerList)){
		pBilink=ThreadList.next;
		pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);
		pTimer->Unique=0;
		pTimer->TimerState=End;
		Delete(&pTimer->Bilink);
		pTimerPool->Release(pTimerPool, pTimer);
	}
	
	if(pTimerPool){
		pTimerPool->Fini(pTimerPool,FALSE);
		pTimerPool=NULL;
	}
}


DWORD WINAPI TimerWorkerThread(LPVOID foo)
{
	BILINK *pBilink;
	PMYTIMER pTimer;
	HANDLE hNewThread;
	DWORD dwJunk;
	
	while (1){
	
		WaitForSingleObject(hWorkToDoSem, INFINITE);

		Lock(&ThreadListLock);

			if(bShutDown || (KillCount && nThreads > 1)){
				nThreads--;
				if(KillCount && !bShutDown){
					KillCount--;
				}	
				Unlock(&ThreadListLock);
				break;	
			}

			if(ExtraSignals){
				ExtraSignals--;
				Unlock(&ThreadListLock);
				continue;
			}

			if(KillCount){
				KillCount--;
				Unlock(&ThreadListLock);
				continue;
			}

			if(ActiveReq > nThreads && nThreads < MAX_TIMER_THREADS){
				nThreads++;
				hNewThread=CreateThread(NULL,4096, TimerWorkerThread, NULL, 0, &dwJunk);
				if(hNewThread){
					CloseHandle(hNewThread);
				} else {
					nThreads--;
				}
			}

			
			pBilink=ThreadList.next;

			if(pBilink == &ThreadList) {
				Unlock(&ThreadListLock);
				continue;
			};
			
			Delete(pBilink);	// pull off the list.
			
			pTimer=CONTAINING_RECORD(pBilink, MYTIMER, Bilink);

			// Call a callback

			pTimer->TimerState=InCallBack;
		
		Unlock(&ThreadListLock);
		
		(pTimer->CallBack)((UINT_PTR)pTimer, 0, pTimer->Context, 0, 0);

		pTimer->Unique=0;
		pTimer->TimerState=End;
		pTimerPool->Release(pTimerPool, pTimer);

		Lock(&ThreadListLock);
			
		if(ActiveReq)ActiveReq--;

		Unlock(&ThreadListLock);
	}	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\comport.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comport.h
 *  Content:	Routines for COM port I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/15/96 kipo	added msinternal
 *	5/22/96	kipo	added support for RTSDTR flow control
 *	6/10/96	kipo	added modem support
 *	6/22/96	kipo	added support for EnumConnectionData().
 *  7/13/96	kipo	added GetComPortAddress()
 *  8/15/96	kipo	added CRC
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  1/30/98 kipo	added hTerminateThreadEvent to fix bugs #15220 & #15228
 ***************************************************************************/

#ifndef __COMPORT_INCLUDED__
#define __COMPORT_INCLUDED__

#include <windows.h>
#include <windowsx.h>
#include <objbase.h>

#include "dplay.h"
#include "dplaysp.h"
#include "bilink.h"

typedef struct _DPCOMPORT DPCOMPORT;
typedef			DPCOMPORT *LPDPCOMPORT;

typedef HRESULT (*LPDISPOSECOMPORT)(LPDPCOMPORT globals);
typedef HRESULT (*LPCONNECTCOMPORT)(LPDPCOMPORT globals, BOOL bWaitForConnection, BOOL bReturnStatus);
typedef HRESULT (*LPDISCONNECTCOMPORT)(LPDPCOMPORT globals);
typedef HRESULT (*LPSETUPCOMPORT)(LPDPCOMPORT globals, HANDLE hCom);
typedef HRESULT (*LPSHUTDOWNCOMPORT)(LPDPCOMPORT globals);
typedef DWORD	(*LPREADCOMPORT)(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength);
typedef DWORD	(*LPWRITECOMPORT)(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwLength, BOOLEAN bQueueOnReenter);
typedef HRESULT (*LPGETCOMPORTBAUDRATE)(LPDPCOMPORT globals, LPDWORD lpdwBaudRate);
typedef HANDLE  (*LPGETCOMPORTHANDLE)(LPDPCOMPORT globals);
typedef HRESULT (*LPGETCOMPORTADDRESS)(LPDPCOMPORT globals, DWORD dwPlayerFlags, LPVOID lpAddress, LPDWORD lpdwAddressSize);
typedef HRESULT (*LPGETCOMPORTADDRESSCHOICES)(LPDPCOMPORT globals, LPVOID lpAddress, LPDWORD lpdwAddressSize);

typedef void (*LPREADROUTINE)(LPDIRECTPLAYSP);

// struct used for pending sends.
typedef struct _PENDING_SEND {
	BILINK Bilink;
	DWORD  dwBytesToWrite;
	UCHAR  Data[0];
} PENDING_SEND, *LPPENDING_SEND;

struct _DPCOMPORT {
	// com port globals
	HANDLE					hCom;			// handle to comm object

	HANDLE					hIOThread;		// handle to read thread
	DWORD					IOThreadID;		// ID of read thread
	HANDLE					hTerminateThreadEvent; // signalled to terminate the thread

	OVERLAPPED				readOverlapped;	// overlapped sections for asynch I/O
	OVERLAPPED				writeOverlapped;
	LPREADROUTINE			lpReadRoutine;	// routine to call when read is ready
	LPDIRECTPLAYSP			lpDPlay;		// pointer to IDirectPlaySP needed to call back into DPlay

	// need to queue sends if we are in the middle of writing and drain queue when done writing.
	CRITICAL_SECTION        csWriting;		// locks pending list and bWriting
	BILINK                  PendingSends;   // bilink list of pending sends
	BOOL                    bWriting;		// guards re-entry to WriteComPort()

	// com port methods
	LPDISPOSECOMPORT		Dispose;		// dispose
	LPCONNECTCOMPORT		Connect;		// connect
	LPDISCONNECTCOMPORT		Disconnect;		// disconnect
	LPSETUPCOMPORT			Setup;			// setup com port
	LPSHUTDOWNCOMPORT		Shutdown;		// shutdown com port
	LPREADCOMPORT			Read;			// read
	LPWRITECOMPORT			Write;			// write
	LPGETCOMPORTBAUDRATE	GetBaudRate;	// get baud rate
	LPGETCOMPORTHANDLE		GetHandle;		// get com port handle
	LPGETCOMPORTADDRESS		GetAddress;		// get address
	LPGETCOMPORTADDRESSCHOICES GetAddressChoices; // get address choices
};

extern HRESULT NewComPort(DWORD dwObjectSize,
						  LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						  LPDPCOMPORT *lplpObject);
extern HRESULT NewModem(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
						LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						LPDPCOMPORT *storage);
extern HRESULT NewSerial(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
						 LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
						 LPDPCOMPORT *storage);

extern DWORD GenerateCRC(LPVOID pBuffer, DWORD dwBufferSize);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\protocol\stats.c ===
/*++

Copyright (c) 1996,1997  Microsoft Corporation

Module Name:

	STATS.C

Abstract:

	Session Statistics routines

Author:

	Aaron Ogus (aarono)

Environment:

	Win32/COM

Revision History:

	Date   Author  Description
   ======  ======  ============================================================
   7/30/97 aarono  Original
   6/6/98  aarono  Turn on throttling and windowing

--*/

#include <windows.h>
#include "newdpf.h"
#include <dplay.h>
#include <dplaysp.h>
#include <dplaypr.h>
#include "mydebug.h"
#include "arpd.h"
#include "arpdint.h"
#include "protocol.h"
#include "macros.h"
#include "command.h"

#define STARTING_LONG_LATENCY 			1  /*  1  ms (intentionally low so first sample fills)      */
#define STARTING_SHORT_LATENCY 		15000  /* 15 seconds (intentionally high so first sample fills) */
#define STARTING_AVERAGE_LATENCY 	 2000  /*  2 seconds (good start for internet) */
#define STARTING_AVERAGE_DEVIATION      0  

#define STARTING_MAXRETRY                16  /* Maximum number of retries */
#define STARTING_MINDROPTIME          15000  /* Minimum time to retry before dropping connection (ms) */
#define STARTING_MAXDROPTIME          60000  /* Maximum time to retry before dropping connection (ms) */

#define STARTING_BANDWIDTH          (28800/10) /* 28 kbps modem */

#define LATENCY_SHORT_BITS				4
#define LATENCY_LONG_BITS               7

#define STAT_LOCAL_LATENCY_SAMPLES 		2^(LATENCY_SHORT_BITS) /* 2^4 */
#define STAT_LONG_LATENCY_SAMPLES       2^(LATENCY_LONG_BITS)  /* 2^7 */

#define TARGET_CLOCK_OFFSET 		10000000


#define Fp(_x) ((_x)<<8)
#define unFp(_x)((_x)>>8)

// Latency Averages and deviation averages are stored as fixed point 24.8

VOID InitSessionStats(PSESSION pSession)
{
	pSession->ShortestLatency     = STARTING_SHORT_LATENCY;
	pSession->LongestLatency      = STARTING_LONG_LATENCY;
	
	pSession->FpAverageLatency      = 1000;
	pSession->FpLocalAverageLatency = 1000;

	pSession->FpLocalAvgDeviation   = 300;
	pSession->FpAvgDeviation        = 300;

	pSession->Bandwidth = 28800/10;
	pSession->HighestBandwidth=28800/10;
	
	pSession->MaxRetry    = STARTING_MAXRETRY;
	pSession->MinDropTime = STARTING_MINDROPTIME;
	pSession->MaxDropTime = STARTING_MAXDROPTIME;
}


// called with SESSIONLOCK.
VOID UpdateSessionStats(PSESSION pSession, PSENDSTAT pStat, PCMDINFO pCmdInfo, BOOL fBadDrop)
{
	DWORD tLatency;
	DWORD nBytesReceived;
	DWORD tDeviation;
	DWORD BytesLost=0;
	DWORD BackLog=0;

	DWORD fThrottleAdjusted=FALSE;

	DWORD tRemoteDelta; // change in time on remote from last received ACK until this was ACKed.
	
	DWORD tBiasedDelta; // a biased difference in local and remote clocks.
	INT   tDelta; // the unbiased difference (signed)
	static DWORD cBiasReset;

	
	// Get the statistics information we need.
	tLatency = pCmdInfo->tReceived-pStat->tSent;

	ASSERT((int)tLatency >= 0);
	if(!tLatency){
		DPF(8,"0ms observed latency, using 1ms\n");
		tLatency=1;
	}	

	Lock(&pSession->SessionStatLock);
	
		// Calculates the number of bytes received at remote since this send was done.
		pSession->RemoteBytesReceived = pCmdInfo->bytes;
		pSession->tRemoteBytesReceived = pCmdInfo->tRemoteACK;
		nBytesReceived = pSession->RemoteBytesReceived - pStat->RemoteBytesReceived;

		BytesLost = pStat->LocalBytesSent-(pSession->RemoteBytesReceived+pSession->BytesLost);

		if((int)BytesLost >= 0){
		
			pSession->BytesLost += BytesLost;

			// Note, Backlog may be as little as 1/2 this value.
			BackLog = pSession->BytesSent -( pSession->RemoteBytesReceived + pSession->BytesLost );

			if((int)BackLog < 0){
				DPF(8,"Hmmm, upside down backlog?\n");
				DPF(8,"pSession->BytesSent             %d\n",pSession->BytesSent);
				DPF(8,"pSession->RemoteBytesReceived   %d\n",pSession->RemoteBytesReceived); 
				DPF(8,"pSession->BytesLost             %d\n",pSession->BytesLost);
				DPF(8,"Calculated BackLog              %d\n",BackLog);
				BackLog=0;
			}
			
		} else if((int)BytesLost < 0){
			// Can be caused by out of order receives
			DPF(1,"Out of order remote receive lots of these may affect throttling...\n");
			DPF(8,"Hmmm, upside down byte counting?\n"); 
			DPF(8,"pStat->LocalBytesSent           %d\n",pStat->LocalBytesSent);
			DPF(8,"pSession->RemoteBytesReceived   %d\n",pSession->RemoteBytesReceived); 
			DPF(8,"pSession->BytesLost             %d\n",pSession->BytesLost);
			DPF(8,"Calculated Bytes Lost           %d\n",BytesLost);
			BytesLost=0;
			// fixup lost count.
			pSession->BytesLost=pSession->RemoteBytesReceived-pStat->LocalBytesSent;
		}

	Unlock(&pSession->SessionStatLock);

	if(pSession->MaxCSends==1){
	
		DWORD Bias;
		
		// 1st ACK, adjust windows to normal operation.
		pSession->MaxCSends     = MAX_SMALL_CSENDS;	 
		pSession->MaxCDGSends   = MAX_SMALL_DG_CSENDS;
		pSession->WindowSize	= MAX_SMALL_WINDOW;
		pSession->DGWindowSize  = MAX_SMALL_WINDOW;

		pSession->FpAverageLatency      = 2*tLatency; // start high to avoid overthrottle
		pSession->FpLocalAverageLatency = 2*tLatency;

		pSession->FpLocalAvgDeviation   = 1+tLatency/3;
		pSession->FpAvgDeviation        = 1+tLatency/3;



		Bias = pCmdInfo->tRemoteACK - pStat->tSent;

		if(Bias > TARGET_CLOCK_OFFSET){
			Bias = -1*(Bias-TARGET_CLOCK_OFFSET);
		} else {
			Bias = TARGET_CLOCK_OFFSET - Bias;
		}

		pSession->RemAvgACKBias = Bias;
		
		pSession->RemAvgACKDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;

		ASSERT(pSession->RemAvgACKDelta == TARGET_CLOCK_OFFSET);
	}

	//
	// Calculate shift in outbound latency.
	//
	tBiasedDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;
	tDelta = tBiasedDelta-TARGET_CLOCK_OFFSET;

	if(tDelta < 0 || pStat->bResetBias || tDelta > (int)tLatency){
		DWORD Bias;

		// Either clock drift or lower server load shows latency down, so reset baseline.
		
		Bias = pCmdInfo->tRemoteACK - pStat->tSent;

		if(Bias > TARGET_CLOCK_OFFSET){
			Bias = -1*(Bias-TARGET_CLOCK_OFFSET);
		} else {
			Bias = TARGET_CLOCK_OFFSET - Bias;
		}
		cBiasReset++;

		pSession->RemAvgACKBias = Bias;
		tBiasedDelta = (pCmdInfo->tRemoteACK - pStat->tSent)+pSession->RemAvgACKBias;
		tDelta = tBiasedDelta-TARGET_CLOCK_OFFSET;
	}

	pSession->RemAvgACKDelta -= pSession->RemAvgACKDelta >> 7; // -1/128th
	pSession->RemAvgACKDelta += tBiasedDelta >> 7;			   // +1/128th of new value 

	// keep the residue so we don't creep down due to rounding error.
	pSession->RemAvgACKDeltaResidue += tBiasedDelta & 0x7f;
	if(pSession->RemAvgACKDeltaResidue>>7){
		pSession->RemAvgACKDelta += pSession->RemAvgACKDeltaResidue>>7;
		pSession->RemAvgACKDeltaResidue &= 0x7f;
	}


	DPF(8,"tRemoteACK %d tSent %d Bias %d tBiasedDelta %d tDelta %d\n", pCmdInfo->tRemoteACK, pStat->tSent, 
		pSession->RemAvgACKBias, tBiasedDelta, tDelta);
	
	
	//
	// Update latency statistics
	//
	
	ASSERT(!(nBytesReceived & 0x80000000)); // received in interval +ve
	ASSERT(!(tLatency & 0x80000000));       // latency is +ve

	if(tLatency < pSession->ShortestLatency){
		pSession->ShortestLatency=tLatency;
		DPF(8,"Shortest Latency %d ms\n",tLatency);
	}

	if(tLatency > pSession->LongestLatency){
		pSession->LongestLatency=tLatency;
		DPF(8,"Longest Latency %d ms\n", tLatency);
	}

	pSession->LastLatency=tLatency;

	// Throw out 1/16 of local latency and add in the new statistic.
	// Note we only use local latency for retry calculations.

	if(pSession->FpLocalAverageLatency){
		if(Fp(tLatency) > pSession->FpAverageLatency){
			pSession->FpLocalAverageLatency -= (pSession->FpLocalAverageLatency >> LATENCY_SHORT_BITS);
			pSession->FpLocalAverageLatency += (tLatency << (8-LATENCY_SHORT_BITS));
		} else {
			// Ratched down when we get a latency that is below average, so we can better
			// detect backlog due to latency.
			pSession->FpLocalAverageLatency = Fp(tLatency);
		}
	} else {
		// this only happens once at startup.
		pSession->FpLocalAverageLatency = Fp(tLatency);
		pSession->FpAverageLatency = Fp(tLatency);
	}

	if(Fp(tLatency) > pSession->FpAverageLatency){

		// Thow out 1/128 of average latency and add in the new statistic.
		pSession->FpAverageLatency -= (pSession->FpAverageLatency >> LATENCY_LONG_BITS);
		pSession->FpAverageLatency += (tLatency << (8-LATENCY_LONG_BITS));

	} else {
		// Ratched down when we get a latency that is below average, so we can better
		// detect backlog due to latency.
		pSession->FpAverageLatency = Fp(tLatency);
	}
	
	tDeviation=unFp(pSession->FpLocalAverageLatency)-tLatency;
	if((int)tDeviation < 0){
		tDeviation = 0-tDeviation;
	}

	pSession->FpLocalAvgDeviation -= (pSession->FpLocalAvgDeviation >> LATENCY_SHORT_BITS);
	pSession->FpLocalAvgDeviation += (tDeviation << (8-LATENCY_SHORT_BITS));

	pSession->FpAvgDeviation -= (pSession->FpAvgDeviation >> LATENCY_LONG_BITS);
	pSession->FpAvgDeviation += (tDeviation << (8-LATENCY_LONG_BITS));


	DPF(8,"Got ACK, tLat: %d Avg: %d.%d Dev:  %d AvgDev: %d.%d \n",
			tLatency, pSession->FpLocalAverageLatency >> 8, ((pSession->FpLocalAverageLatency&0xFF)*100)/256,
			tDeviation, pSession->FpLocalAvgDeviation >> 8, ((pSession->FpLocalAvgDeviation&0xFF)*100)/256);


	//
	// Do Bandwidth calculations
	//
	
   	tRemoteDelta= pCmdInfo->tRemoteACK - pStat->tRemoteBytesReceived;
   	if(!tRemoteDelta){
   		tRemoteDelta=1;
   	}

	if(pStat->tRemoteBytesReceived){
		pSession->Bandwidth = (1000*nBytesReceived)/(tRemoteDelta);
		// could adjust throttle here if Bandwidth is higher, but this
		// might pimp high speed links. OPTIMIZATION.
	} else {
		// backup calculation, not as good.  Only used early in the link
		// before we have received an ACK from the remote prior to issuing
		// a send.
		pSession->Bandwidth = (2000*nBytesReceived)/tLatency;	// 2000, not 1000 since tLatency is round trip.
	}	
	if(pSession->Bandwidth > pSession->HighestBandwidth){
		pSession->HighestBandwidth = pSession->Bandwidth;
	}


	DPF(8,"tRemoteDelta %d Remote bytes Received %d\n",tRemoteDelta,nBytesReceived);

	// Adjust sending...
	
	if ( BackLog && pSession->Bandwidth)
	{

		DWORD tAvgLat;
		DWORD tBackLog;
		DWORD ExcessBackLog; // amount of backlog (bytes) we need to clear before hitting avg latency again.
		DWORD tLatCheck;
		DWORD AvgLat133; // 133% of local average latency (tolerance for slow links)
		DWORD AvgLat200; // 200% of local average latency (tolerance for fast links)


		if(pSession->fFastLink){
			tAvgLat=unFp(pSession->FpAverageLatency);
			tLatCheck = (tAvgLat*3)/2;
			AvgLat133 = max(100,3*unFp(pSession->FpAvgDeviation)+(unFp(pSession->FpAverageLatency)*4)/3); // don't throttle <100ms lat
			AvgLat200 = max(100,3*unFp(pSession->FpAvgDeviation)+unFp(pSession->FpAverageLatency)*2);
		} else {
			tAvgLat=unFp(pSession->FpLocalAverageLatency);
			tLatCheck = (tAvgLat*3)/2;
			AvgLat133 = max(100,3*unFp(pSession->FpLocalAvgDeviation)+(unFp(pSession->FpLocalAverageLatency)*4)/3); // don't throttle <100ms lat
			AvgLat200 = max(100,3*unFp(pSession->FpLocalAvgDeviation)+unFp(pSession->FpLocalAverageLatency)*2);
		}
		
		if(tLatCheck < AvgLat133){
			tLatCheck = AvgLat133; 
		}

		if(tLatency > tLatCheck){
			// check link speed
			if(pSession->fFastLink){
				if(pSession->Bandwidth <= 10000){
					pSession->fFastLink=FALSE;
				}
			} else {
				if(pSession->Bandwidth >= 25000){
					pSession->fFastLink=TRUE;
				}
			}
		}

		if(pSession->fFastLink && tLatCheck < AvgLat200){
			tLatCheck=AvgLat200;
		}

		DPF(8,"tLat %d, tLatCheck %d, tDelta %d, tLat/3 %d\n",tLatency,tLatCheck,tDelta,tLatency/3); 
		DPF(8,"pSession->ShortestLatency %d, Shortest+MaxPacketTime %d\n",pSession->ShortestLatency,
			pSession->ShortestLatency+(pSession->MaxPacketSize*1000)/pSession->Bandwidth);

		
		if((tLatency > tLatCheck && tDelta > (int)(tLatency/3)) ||
		    ((!pSession->fFastLink)&&
		     (tLatency > pSession->ShortestLatency+((pSession->MaxPacketSize*2000)/pSession->Bandwidth))
		    )
		  )
		{
				
			#ifdef DEBUG
			if(pSession->SendRateThrottle){
				DPF(8,"BackLog %d, SendRate %d BackLog ms %d, tLatency %d tAvgLat %d Used Bandwidth %d tBacklog %d \n",
						BackLog,
						pSession->SendRateThrottle, 
						(BackLog*1000 / pSession->SendRateThrottle),
						tLatency, 
						tAvgLat, 
						pSession->Bandwidth,
						((BackLog*1000) / pSession->Bandwidth)
						);
			}	
			#endif

			tBackLog = (BackLog * 1000)/pSession->Bandwidth;
			
			if(tBackLog > 4*tLatency){
				DPF(8,"1: tBackLog %d was >> tLatency %d, using 4*tLatency instead\n",tBackLog,tLatency);
				tBackLog=4*tLatency; //never wait more than 4 latency periods
			}
			if(tBackLog > 8000){
				DPF(8,"Disalowing backlog > 8 seconds, using 8 instead\n");
				tBackLog=8000;
			}

			// if the backlog is greater than the bandwidth*latency, then we need to slow down our sending.
			// don't slow down due to backlog until we are over 100ms on way latency (200 round trip)
		
			if((tBackLog > 200) && (tBackLog > tAvgLat)){
			
				BOOL fWait=TRUE;

				// at max we cut send rate in 1/2.

				if(pSession->SendRateThrottle/2 > pSession->Bandwidth){
					DPF(8,"Asked for too aggresive throttle adjust %d, going from %d to %d\n",pSession->Bandwidth,pSession->SendRateThrottle,pSession->SendRateThrottle/2);
					pSession->SendRateThrottle /= 2;
					// Recheck if we are really backlogged at the new rate
					tBackLog = (BackLog * 1000)/pSession->SendRateThrottle;
					if(tBackLog > tLatency){
						DPF(8,"2: tBackLog %d was > tLatency %d, using tLatency instead\n",tBackLog,tLatency);
						tBackLog=tLatency;// never wait more than last latency period
					}
				} else {
					// set new throttle rate and current observed bandwidth (+5% to avoid overthrottle)
					pSession->SendRateThrottle=pSession->Bandwidth+pSession->Bandwidth/16;
				}

				// don't adjust for a while.
				pSession->bhitThrottle=FALSE;
				pSession->tLastThrottleAdjust = pCmdInfo->tReceived;

				if(fWait && (tBackLog > tAvgLat)){
				
					ExcessBackLog = ((tBackLog-tAvgLat)*pSession->Bandwidth)/1000;
					
					DPF(8,"Throttling back due to BACKLOG, excess = %d\n",ExcessBackLog);

					#ifdef DEBUG
					if(tBackLog-tAvgLat > 30000){
						DPF(5,"WARNING: BACKLOG THROTTLE %d ms seems kinda large\n",tBackLog-tAvgLat);
					}
					#endif

					// wait until backlog is down to avg latency before sending again
					Lock(&pSession->SessionStatLock);
					pSession->bResetBias = 2; // could be in the middle of a send, so count down from 2.
					Unlock(&pSession->SessionStatLock);
					UpdateSendTime(pSession,ExcessBackLog,timeGetTime(),TRUE);
				} else {
					DPF(8,"Not throttling due to BACKLOG because of smaller adjustment\n");
				}
				
			} else {
				DPF(8,"NOT Throttling back due to BACKLOG\n");
				
			}
		}		

	} else if(tDelta > (int)tLatency) {
		// tDelta is bogus due to clock drift, force throttle so we can correct.
		Lock(&pSession->SessionStatLock);
		pSession->bResetBias=2;
		Unlock(&pSession->SessionStatLock);
		pSession->tNextSend=timeGetTime()+2*tLatency;
		DPF(8,"tDelta %d > tLatency %d, need to correct for clock drift, time %d set next send time to %d\n", tDelta, tLatency,timeGetTime(),pSession->tNextSend);
	}	



	//
	// Adjust Throttle if not already adjusted.
	//
	
	if((pSession->ThrottleState==Begin) || 
	   (pCmdInfo->tReceived-pSession->tLastThrottleAdjust) > (1+1*pSession->fFastLink)*unFp(pSession->FpLocalAverageLatency) )
	{
		if(!fThrottleAdjusted){
			DPF(8,"Current Send Rate %d\n", pSession->SendRateThrottle);
			if(!BytesLost && pSession->bhitThrottle){
				pSession->bhitThrottle=FALSE;
				pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
				// Good Send, push up send rate if we hit throttle.
				switch(pSession->ThrottleState){
					case Begin:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+START_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						break;
						
					case MetaStable:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+METASTABLE_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						break;
						
					case Stable:
						pSession->SendRateThrottle = (pSession->SendRateThrottle*(100+STABLE_GROWTH_RATE))/100;
						pSession->GrowCount++;
						pSession->ShrinkCount=0;
						if(pSession->GrowCount > (UINT)(20+60*pSession->fFastLink)){
							pSession->ThrottleState = MetaStable;
							pSession->GrowCount=0;
						}
						break;
					default:	
						DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
						break;
				}	
				DPF(8,"Successful Send Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
			} else if(BytesLost){
				// Figure out how much we dropped
				if(fBadDrop || (BytesLost > pSession->pProtocol->m_dwSPMaxFrame)){
					// Very bad send, back off
					pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
					switch(pSession->ThrottleState){
						case Begin:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-START_ADJUST_LARGE_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount++;
							break;
						case MetaStable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-METASTABLE_ADJUST_LARGE_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount++;
							break;
						case Stable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-STABLE_ADJUST_LARGE_ERR))/100;
							pSession->ShrinkCount++;
							if(pSession->ShrinkCount > 1){
								pSession->ShrinkCount=0;
								pSession->GrowCount=0;
								pSession->ThrottleState=MetaStable;
							}
							break;
						default:
							DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
							break;
					}	
					DPF(8,"VERY BAD SEND Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
				} else {
					// Bad send, back off a bit
					pSession->tLastThrottleAdjust = pCmdInfo->tReceived;
					switch(pSession->ThrottleState){
						case Begin:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-START_ADJUST_SMALL_ERR))/100;
							pSession->GrowCount=0;
							pSession->ShrinkCount=0;
							pSession->ThrottleState = MetaStable;
							break;
						case MetaStable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-METASTABLE_ADJUST_SMALL_ERR))/100;
							pSession->ShrinkCount++;
							pSession->GrowCount=0;
							break;
						case Stable:
							pSession->SendRateThrottle = (pSession->SendRateThrottle*(100-STABLE_ADJUST_SMALL_ERR))/100;
							pSession->ShrinkCount++;
							pSession->GrowCount=0;
							if(pSession->ShrinkCount > 2){
								pSession->ShrinkCount=0;
								pSession->ThrottleState = MetaStable;
							}	
							break;
						default:
							DPF(0,"Session in wierd ThrottleState %d\n",pSession->ThrottleState);
							break;
					}
					DPF(8,"BAD SEND Adjusted Throttle, SendRate %d\n",pSession->SendRateThrottle);
				} /* if (BadDrop... ) */
				
			} /* if (BytesLost ...) */
			
		}/*if (ThrottleAdjusted) */

	}

	if(!BytesLost && pSession->Bandwidth && pSession->SendRateThrottle < pSession->Bandwidth){
		DPF(8,"Avoid goofyness, throttle was %d, setting to observed bandwidth %d\n",pSession->SendRateThrottle,pSession->Bandwidth);
		pSession->SendRateThrottle=pSession->Bandwidth;
	}
	if(pSession->SendRateThrottle < 100){
		DPF(8,"WARNING: SendRateThrottle %d below 100, keeping at 100 to avoid starvation\n",pSession->SendRateThrottle);
		pSession->SendRateThrottle=100;
	}

#ifdef DEBUG
	{
		IN_WRITESTATS InWS;
		memset((PVOID)&InWS,0xFF,sizeof(IN_WRITESTATS));

	   	InWS.stat_ThrottleRate = pSession->SendRateThrottle;
		InWS.stat_BytesSent	   = pSession->BytesSent;
		InWS.stat_BackLog      = BackLog;      
	 	InWS.stat_BytesLost    = pSession->BytesLost;
	 	//InWS.stat_RemBytesReceived;
		InWS.stat_Latency = tLatency;
		InWS.stat_MinLatency=pSession->ShortestLatency;
		InWS.stat_AvgLatency=unFp(pSession->FpLocalAverageLatency);
		InWS.stat_AvgDevLatency=unFp(pSession->FpLocalAvgDeviation);
		//InWS.stat_USER1=
		//InWS.stat_USER2=
		//InWS.stat_USER3=
		InWS.stat_USER5 = tDelta;
		InWS.stat_USER6 = cBiasReset;
	
		DbgWriteStats(&InWS);
	}
#endif
	
	DPF(8,"Bandwidth %d, Highest %d\n",pSession->Bandwidth, pSession->HighestBandwidth);
	
}

// Called with SessionLock and SendLock
// Statistics are stored on the send in send order on a BILINK.
// most recent sends are at the end of the list.  We scan from
// the end of the list to the beginning until we find the SENDSTAT
// that records the sequence and serial we got ACKED.  We then 
// update our statistics and throw out all SENDSTATs
// before this entry.
VOID UpdateSessionSendStats(PSESSION pSession, PSEND pSend, PCMDINFO pCmdInfo, BOOL fBadDrop)
{
	PSENDSTAT pStatWalker,pStat=NULL;
	BILINK    *pStatBilink;

	pSend->tLastACK=pCmdInfo->tReceived;
	pSend->RetryCount=0;
	// Find the last STAT for this ACK.
	pStatBilink=pSend->StatList.prev;

	while(pStatBilink != &pSend->StatList){
		pStatWalker=CONTAINING_RECORD(pStatBilink, SENDSTAT, StatList);
		if(pStatWalker->serial==pCmdInfo->serial &&
			pStatWalker->sequence==pCmdInfo->sequence)
		{
			ASSERT(pStatWalker->messageid==pSend->messageid);
			ASSERT(pSend->messageid==pCmdInfo->messageid);
			pStat=pStatWalker;
			break;
		}
		pStatBilink=pStatBilink->prev;
	}

	if(pStat){
		UpdateSessionStats(pSession,pStat,pCmdInfo,fBadDrop);

		// Unlink All Previous SENDSTATS;
		pStat->StatList.next->prev=&pSend->StatList;
		pSend->StatList.next=pStat->StatList.next;

		// Put the SENDSTATS back in the pool.
		while(pStatBilink != &pSend->StatList){
			pStatWalker=CONTAINING_RECORD(pStatBilink, SENDSTAT, StatList);
			pStatBilink=pStatBilink->prev;
			ReleaseSendStat(pStatWalker);
		}

	}	

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPSERIAL"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\comport.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       comport.c
 *  Content:	Routines for COM port I/O
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/12/96 kipo	use GlobalAllocPtr to create memory
 *  4/15/96 kipo	added msinternal
 *	5/22/96	kipo	added support for RTSDTR flow control
 *	6/10/96	kipo	added modem support
 *	6/22/96	kipo	added support for EnumConnectionData(); added methods
 *					to NewComPort().
 *  7/13/96	kipo	added GetComPortAddress()
 *  8/15/96	kipo	added CRC
 *  8/16/96	kipo	loop on WriteFile to send large buffers
 *  8/19/96	kipo	update thread interface
 *  1/06/97 kipo	updated for objects
 *  2/18/97 kipo	allow multiple instances of service provider
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/23/97 kipo	added support return status codes
 * 11/24/97 kipo	better error messages
 *  1/30/98 kipo	added hTerminateThreadEvent to fix bugs #15220 & #15228
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "comport.h"
#include "dpf.h"
#include "macros.h"

// constants

#define READTIMEOUT			5000		// ms to wait before read times out
#define WRITETIMEOUT		5000		// ms to wait before write times out
#define WRITETOTALTIMEOUT	5000		// total ms to wait before write times out
#define IOBUFFERSIZE		4096		// size of read/write buffers in bytes

// prototypes

static HRESULT		SetupComPort(LPDPCOMPORT globals, HANDLE hCom);
static HRESULT		ShutdownComPort(LPDPCOMPORT globals);
static DWORD		ReadComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength);
static DWORD		WriteComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwBytesToWrite, BOOLEAN bQueueOnReenter);
static HRESULT		GetComPortBaudRate(LPDPCOMPORT globals, LPDWORD lpdwBaudRate);
static HANDLE		GetComPortHandle(LPDPCOMPORT globals);

static DWORD WINAPI	IOThread(LPVOID lpvParam1);

/*
 * NewComPort
 *
 * Creates a com port object of the given size. The readRoutine is called whenever
 * a byte is received in the input thread.
 */

HRESULT NewComPort(DWORD dwObjectSize,
				   LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				   LPDPCOMPORT *lplpObject)
{
	LPDPCOMPORT		globals;
	DWORD			dwError;

	// allocate space for base object and our globals
	globals =(LPDPCOMPORT) SP_MemAlloc(dwObjectSize);
	if (globals == NULL)
	{
		dwError = GetLastError();
		return (HRESULT_FROM_WIN32(dwError));
	}

	// store read routine pointer and IDirectPlaySP pointer
	globals->lpReadRoutine = lpReadRoutine;
	globals->lpDPlay = lpDPlay;

	// fill in base methods
	globals->Dispose = NULL;
	globals->Connect = NULL;
	globals->Disconnect = NULL;
	globals->Setup = SetupComPort;
	globals->Shutdown = ShutdownComPort;
	globals->Read = ReadComPort;
	globals->Write = WriteComPort;
	globals->GetBaudRate = GetComPortBaudRate;
	globals->GetHandle = GetComPortHandle;
	globals->GetAddress = NULL;
	globals->GetAddressChoices = NULL;

	// return base object
	*lplpObject = globals;

	return (DP_OK);
}

/*
 * SetupComPort
 *
 * Sets up the COM port for overlapped I/O with a read thread.
 */

static HRESULT SetupComPort(LPDPCOMPORT globals, HANDLE hCom)
{
	COMMTIMEOUTS	timoutInfo;
	DWORD			dwError;

	// store com port handle
	globals->hCom = hCom;
	
	// wake up read thread when a byte arrives
	SetCommMask(globals->hCom, EV_RXCHAR);

	// setup read/write buffer for I/O
	SetupComm(globals->hCom, IOBUFFERSIZE, IOBUFFERSIZE);

	// set time outs
	timoutInfo.ReadIntervalTimeout = MAXDWORD;
	timoutInfo.ReadTotalTimeoutMultiplier = 0;
	timoutInfo.ReadTotalTimeoutConstant = 0;
	timoutInfo.WriteTotalTimeoutMultiplier = 0;
	timoutInfo.WriteTotalTimeoutConstant = WRITETOTALTIMEOUT;

	if (!SetCommTimeouts(globals->hCom, &timoutInfo))
		goto Failure;

	// create I/O event used for overlapped read

	ZeroMemory(&globals->readOverlapped, sizeof(OVERLAPPED));
	globals->readOverlapped.hEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->readOverlapped.hEvent == NULL)
		goto Failure;

	// create I/O event used for overlapped write

	ZeroMemory(&globals->writeOverlapped, sizeof(OVERLAPPED));
	globals->writeOverlapped.hEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->writeOverlapped.hEvent == NULL)
		goto Failure;

	// create event used to signal I/O thread to exit

	globals->hTerminateThreadEvent = CreateEvent(	NULL,	// no security
													TRUE,	// explicit reset req
													FALSE,	// initial event reset
													NULL );	// no name
	if (globals->hTerminateThreadEvent == NULL)
		goto Failure;

	// Init vars for pending queue
	InitializeCriticalSection(&globals->csWriting);
	InitBilink(&globals->PendingSends);
	globals->bWriting=FALSE;

	// create read thread

	globals->hIOThread = CreateThread(
								NULL,			// default security
								0,				// default stack size
								IOThread,		// pointer to thread routine
								globals,		// argument for thread
								0,				// start it right away
								&globals->IOThreadID);
	if (globals->hIOThread == NULL)
		goto Failure;

	// adjust thread priority to be higher than normal or the serial port will
	// back up and the game will slow down or lose messages.

	SetThreadPriority(globals->hIOThread, THREAD_PRIORITY_ABOVE_NORMAL);
	ResumeThread(globals->hIOThread);

	// assert DTR

	EscapeCommFunction(globals->hCom, SETDTR);

	return (DP_OK);

Failure:
	dwError = GetLastError();
	ShutdownComPort(globals);

	return (HRESULT_FROM_WIN32(dwError));
}

/*
 * ShutdownComPort
 *
 * Stop's all I/O on COM port and releases allocated resources.
 */

static HRESULT ShutdownComPort(LPDPCOMPORT globals)
{
	if (globals->hIOThread)
	{
		// the thread will wake up if we disable event notifications using
		// SetCommMask. Need to set the hTerminateThread event before doing
		// this so the thread will know to exit

		SetEvent(globals->hTerminateThreadEvent);
		SetCommMask(globals->hCom, 0);
		WaitForSingleObject(globals->hIOThread, INFINITE);

        CloseHandle (globals->hIOThread);
		globals->hIOThread = NULL;

		// purge any outstanding reads/writes

		EscapeCommFunction(globals->hCom, CLRDTR);
		PurgeComm(globals->hCom, PURGE_TXABORT | PURGE_RXABORT |
								 PURGE_TXCLEAR | PURGE_RXCLEAR );
	}

	if (globals->hTerminateThreadEvent)
	{
		CloseHandle(globals->hTerminateThreadEvent);
		globals->hTerminateThreadEvent = NULL;
	}

	if (globals->readOverlapped.hEvent)
	{
		CloseHandle(globals->readOverlapped.hEvent);
		globals->readOverlapped.hEvent = NULL;
	}

	if (globals->writeOverlapped.hEvent)
	{
		CloseHandle(globals->writeOverlapped.hEvent);
		globals->writeOverlapped.hEvent = NULL;
	}

	// the com port is shut down
	globals->hCom = NULL;

	// Free resources for pending queue
	DeleteCriticalSection(&globals->csWriting);

	return (DP_OK);
}

/*
 * ReadComPort
 *
 * Read bytes from COM port. Will block until all bytes have been read.
 */

static DWORD ReadComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD nMaxLength)
{
	COMSTAT		ComStat;
	DWORD		dwErrorFlags, dwLength, dwError;

	ClearCommError(globals->hCom, &dwErrorFlags, &ComStat);

	dwLength = min(nMaxLength, ComStat.cbInQue);
	if (dwLength == 0)
		return (0);

	if (ReadFile(globals->hCom, lpvBuffer, dwLength, &dwLength, &globals->readOverlapped))
		return (dwLength);

	// deal with error
	dwError = GetLastError();
	if (dwError != ERROR_IO_PENDING)
	{
		DPF(0, "Error reading from com port: 0x%8X", dwError);
		return (0);
	}

	// wait for this transmission to complete

	if (WaitForSingleObject(globals->readOverlapped.hEvent, READTIMEOUT) != WAIT_OBJECT_0)
	{
		DPF(0, "Timed out reading com port after waiting %d ms", READTIMEOUT);
		return (0);
	}

	GetOverlappedResult(globals->hCom, &globals->readOverlapped, &dwLength, FALSE);
	globals->readOverlapped.Offset += dwLength;

   return (dwLength);
}

/*
 * WriteComPort
 *
 * Write bytes to COM port. Will block until all bytes have been written.
 */

static DWORD WriteComPort(LPDPCOMPORT globals, LPVOID lpvBuffer, DWORD dwBytesToWrite, BOOLEAN bQueueOnReenter)
{
	DWORD	dwLength;
	DWORD	dwBytesWritten;
	LPBYTE	lpData;
	DWORD	dwError;

	EnterCriticalSection(&globals->csWriting);
	
	if(!globals->bWriting || !bQueueOnReenter){
		globals->bWriting=TRUE;
		LeaveCriticalSection(&globals->csWriting);

		lpData = lpvBuffer;
		dwBytesWritten = 0;
		while (dwBytesWritten < dwBytesToWrite)
		{
			dwLength = dwBytesToWrite - dwBytesWritten;
			if (WriteFile(globals->hCom, lpData, dwLength, &dwLength, &globals->writeOverlapped))
			{
				dwBytesWritten += dwLength;
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

			dwError = GetLastError();
			if (dwError != ERROR_IO_PENDING)
			{
				DPF(0, "Error writing to com port: 0x%8X", dwError);
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

	 		// wait for this transmission to complete

			if (WaitForSingleObject(globals->writeOverlapped.hEvent, WRITETIMEOUT) != WAIT_OBJECT_0)
			{
				DPF(0, "Timed out writing to com port after waiting %d ms", WRITETIMEOUT);
				globals->bWriting = FALSE;
				return (dwBytesWritten);
			}

			if (GetOverlappedResult(globals->hCom, &globals->writeOverlapped, &dwLength, TRUE) == 0)
			{
				dwError = GetLastError();
				DPF(0, "Error writing to com port: 0x%8X", dwError);
				/*
				// a-josbor: this probably should return, but I'm unwilling to make the change so close to ship...
				globals->bWriting = FALSE;
				return (dwBytesWritten);
				*/
			}
			globals->writeOverlapped.Offset += dwLength;

			lpData += dwLength;
			dwBytesWritten += dwLength;
		}

		if(bQueueOnReenter){ // don't drain queue recurrsively.
			// Drain any pending sends.
			EnterCriticalSection(&globals->csWriting);
			while(!EMPTY_BILINK(&globals->PendingSends)){
			
				LPPENDING_SEND lpPendingSend;
				
				lpPendingSend=CONTAINING_RECORD(globals->PendingSends.next,PENDING_SEND,Bilink);
				Delete(&lpPendingSend->Bilink);
				
				LeaveCriticalSection(&globals->csWriting);
				WriteComPort(globals,lpPendingSend->Data,lpPendingSend->dwBytesToWrite,FALSE);
				SP_MemFree(lpPendingSend);
				EnterCriticalSection(&globals->csWriting);	
			}
			globals->bWriting=FALSE;
			LeaveCriticalSection(&globals->csWriting);
		}
		
	} else {
	
		LPPENDING_SEND lpPendingSend;
		
		// we are in the middle of writing, so copy this to the pending queue and it will get
		// sent after the current write.
		
		lpPendingSend = (LPPENDING_SEND) SP_MemAlloc(dwBytesToWrite+sizeof(PENDING_SEND));
		if(lpPendingSend){
			memcpy(lpPendingSend->Data,lpvBuffer,dwBytesToWrite);
			lpPendingSend->dwBytesToWrite=dwBytesToWrite;
			InsertBefore(&lpPendingSend->Bilink, &globals->PendingSends);

		}
		LeaveCriticalSection(&globals->csWriting);
		dwBytesWritten=dwBytesToWrite;
	}
	
	return (dwBytesWritten);
}

/*
 * GetComPortBaudRate
 *
 * Get baud rate of com port.
 */

static HRESULT GetComPortBaudRate(LPDPCOMPORT globals, LPDWORD lpdwBaudRate)
{
	DCB			dcb;
	DWORD		dwError;

	ZeroMemory(&dcb, sizeof(DCB));
	dcb.DCBlength = sizeof(DCB);

	if (!GetCommState(globals->hCom, &dcb))
		goto Failure;

	*lpdwBaudRate = dcb.BaudRate;

	return (DP_OK);

Failure:	
	dwError = GetLastError();

	return (HRESULT_FROM_WIN32(dwError));
}

/*
 * GetComPortHandle
 *
 * Get handle of com port.
 */

static HANDLE GetComPortHandle(LPDPCOMPORT globals)
{
	return (globals->hCom);
}

/*
 * IOThread
 *
 * Thread to wait for events from COM port. Will call the read routine if an byte
 * is received.
 */

DWORD WINAPI IOThread(LPVOID lpvParam1)
{
	LPDPCOMPORT	globals = (LPDPCOMPORT) lpvParam1;
	DWORD		dwTransfer, dwEvtMask;
	OVERLAPPED	os;
	HANDLE		events[3];
	DWORD		dwResult;

	// create I/O event used for overlapped read

	ZeroMemory(&os, sizeof(OVERLAPPED));
	os.hEvent = CreateEvent(NULL,	// no security
							TRUE,	// explicit reset req
							FALSE,	// initial event reset
							NULL );	// no name
	if (os.hEvent == NULL)
		goto CreateEventFailed;

	if (!SetCommMask(globals->hCom, EV_RXCHAR))
		goto SetComMaskFailed;

	// events to use when waiting for overlapped I/O to complete
	events[0] = globals->hTerminateThreadEvent;
	events[1] = os.hEvent;
	events[2] = (HANDLE) -1;		// work around Win95 bugs in WaitForMultipleObjects

	// spin until this event is signaled during Close.

	while (WaitForSingleObject(globals->hTerminateThreadEvent, 0) == WAIT_TIMEOUT)
	{
		dwEvtMask = 0;

		// wait for COM port event
		if (!WaitCommEvent(globals->hCom, &dwEvtMask, &os))
		{
			if (GetLastError() == ERROR_IO_PENDING)
			{
				// wait for overlapped I/O to complete or the terminating event
				// to be set. This lets us terminate this thread even if the I/O
				// never completes, which fixes a bug on NT 4.0

				dwResult = WaitForMultipleObjects(2, events, FALSE, INFINITE);
				
				// terminating event was set
				if (dwResult == WAIT_OBJECT_0)
				{
					break;		// exit the thread
				}

				// I/O completed
				else if (dwResult == (WAIT_OBJECT_0 + 1))
				{
					GetOverlappedResult(globals->hCom, &os, &dwTransfer, TRUE);
					os.Offset += dwTransfer;
				}
			}
		}

		// was a read event
		if (dwEvtMask & EV_RXCHAR)
		{
			if (globals->lpReadRoutine)
				globals->lpReadRoutine(globals->lpDPlay);	// call read routine
		}
	}

SetComMaskFailed:
	CloseHandle(os.hEvent);

CreateEventFailed:
	ExitThread(0);

	return (0);
}

/*
  Name   : "CRC-32"
   Width  : 32
   Poly   : 04C11DB7
   Init   : FFFFFFFF
   RefIn  : True
   RefOut : True
   XorOut : FFFFFFFF
   Check  : CBF43926

  This is supposedly what Ethernet uses
*/

#if 0
#define WIDTH		32
#define POLY		0x04C11DB7
#define INITVALUE	0xFFFFFFFF
#define REFIN		TRUE
#define XOROUT		0xFFFFFFFF
#define CHECK		0xCBF43926
#define WIDMASK		0xFFFFFFFF		// value is (2^WIDTH)-1
#endif

/*
  Name   : "CRC-16"
   Width  : 16
   Poly   : 8005
   Init   : 0000
   RefIn  : True
   RefOut : True
   XorOut : 0000
   Check  : BB3D
*/

#if 1
#define WIDTH		16
#define POLY		0x8005
#define INITVALUE	0
#define REFIN		TRUE
#define XOROUT		0
#define CHECK		0xBB3D
#define WIDMASK		0x0000FFFF		// value is (2^WIDTH)-1
#endif

#define BITMASK(X) (1L << (X))

DWORD crc_normal(LPBYTE blk_adr, DWORD blk_len, DWORD crctable[])
{
	DWORD	crc = INITVALUE;

	while (blk_len--)
		crc = crctable[((crc>>24) ^ *blk_adr++) & 0xFFL] ^ (crc << 8);

	return (crc ^ XOROUT);
}

DWORD crc_reflected(LPBYTE blk_adr, DWORD blk_len, DWORD crctable[])
{
	DWORD	crc = INITVALUE;

	while (blk_len--)
		crc = crctable[(crc ^ *blk_adr++) & 0xFFL] ^ (crc >> 8);

	return (crc ^ XOROUT);
}

DWORD reflect(DWORD v, int b)
/* Returns the value v with the bottom b [0,32] bits reflected. */
/* Example: reflect(0x3e23L,3) == 0x3e26                        */
{
	int		i;
	DWORD	t = v;

	for (i = 0; i < b; i++)
	{
		if (t & 1L)
			v |=  BITMASK((b-1)-i);
		else
			v &= ~BITMASK((b-1)-i);
		t >>= 1;
	}
	return v;
}

DWORD cm_tab (int index)
{
	int   i;
	DWORD r;
	DWORD topbit = (DWORD) BITMASK(WIDTH-1);
	DWORD inbyte = (DWORD) index;

	if (REFIN)
		inbyte = reflect(inbyte, 8);

	r = inbyte << (WIDTH-8);
	for (i = 0; i < 8; i++)
	{
		if (r & topbit)
			r = (r << 1) ^ POLY;
		else
			r <<= 1;
	}

	if (REFIN)
		r = reflect(r, WIDTH);

	return (r & WIDMASK);
}

void generate_table(DWORD dwTable[])
{
	int	i;

	for (i = 0; i < 256; i++)
	{
		dwTable[i] = cm_tab(i);
	}
}

// todo - make this a static table
DWORD	gCRCTable[256];
BOOL	gTableCreated = FALSE;

DWORD GenerateCRC(LPVOID pBuffer, DWORD dwBufferSize)
{
	if (!gTableCreated)
	{
		generate_table(gCRCTable);
		gTableCreated = TRUE;
	}

	return (crc_reflected(pBuffer, dwBufferSize, gCRCTable));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\dial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dial.c
 *  Content:	Wrappers for TAPI routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	close com port when disconnected; allow checking for
 *					valid TAPI lines during NewComPort().
 *	7/08/96 kipo	added support for new dialogs
 *	8/10/96 kipo	added support for dialing location
 *  1/06/97 kipo	updated for objects
 *  1/24/97 kipo	bug #5400: Compaq Presario was overwriting the dev caps
 *					buffer, causing a crash. Fixed to allocated a larger
 *					buffer with some slop as a workaround.
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  4/21/98 a-peterz #22920 Handle LINE_CLOSE message
 *  5/07/98 a-peterz #15251 Track call errors in DPDIAL
 * 10/13/99	johnkan	#413516 - Mismatch between modem dialog selection and TAPI device ID
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dputils.h"
#include "macros.h"
#include "dial.h"

void FAR PASCAL LineCallBackProc(DWORD hDevice, DWORD dwMessage, DWORD_PTR dwInstance,
								 DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3);
void		ProcessConnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessDisconnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessIdleState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege);
void		ProcessOfferingState(LPDPDIAL globals, HCALL hCall, DWORD dwCallPrivilege);
void		ProcessReplyMessage(LPDPDIAL globals, DWORD asyncID, LINERESULT lResult);
LINERESULT dialGetDevCaps(LPDPDIAL globals, DWORD dwLine, DWORD dwAPIVersion, LPLINEDEVCAPS	*lpDevCapsRet);
LINERESULT dialGetCommHandle(LPDPDIAL globals);
LINERESULT dialCloseCommHandle(LPDPDIAL globals);
LINERESULT dialTranslateAddress(LPDPDIAL globals, DWORD dwDeviceID, DWORD dwAPIVersion,
								LPCSTR lpszDialAddress,
								LPLINETRANSLATEOUTPUT *lpLineTranslateOutputRet);
LPSTR		GetLineErrStr(LONG err);
LPSTR		GetCallStateStr(DWORD callState);
LPSTR		GetLineMsgStr(DWORD msg);

#ifdef DEBUG
extern LONG lineError(LONG err, LPSTR modName, DWORD lineNum);
#define LINEERROR(err)	(lineError(err, DPF_MODNAME, __LINE__))
#else
#define LINEERROR(err)	(err)
#endif

/* dial initialize */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialInitialize"

LINERESULT dialInitialize(HINSTANCE hInst, LPTSTR szAppName,
						  LPDPCOMPORT lpComPort, LPDPDIAL *storage)
{
	LPDPDIAL		globals;
	LINERESULT		lResult;				/* Stores return code from TAPI calls */

	// create globals
	globals =(LPDPDIAL) SP_MemAlloc(sizeof(DPDIAL));
	FAILWITHACTION(globals == NULL, lResult = LINEERR_NOMEM, Failure);

	DPF(3, "lineInitialize");
	DPF(3, ">  hInstance: %08X", hInst);
	DPF(3, ">  szAppName: %s", szAppName);

	// init the line
	lResult = lineInitialize(&globals->hLineApp,
							 hInst,
							 LineCallBackProc,
							 szAppName,
							 &globals->dwNumLines);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "<   hLineApp: %08X", globals->hLineApp);
	DPF(3, "< dwNumLines: %d", globals->dwNumLines);

	// no lines available
	FAILWITHACTION(globals->dwNumLines == 0, lResult = LINEERR_NODEVICE, Failure);

	// store pointer to com port object
	globals->lpComPort = lpComPort;

	*storage = globals;
	return (SUCCESS);

Failure:
	dialShutdown(globals);

	return (lResult);
}

/* dial shutdown */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialShutdown"

LINERESULT dialShutdown(LPDPDIAL globals)
{
	LINERESULT	lResult;

	if (globals == NULL)
		return (SUCCESS);

	if (globals->hLineApp)
	{
		dialDropCall(globals);
		dialDeallocCall(globals);
		dialLineClose(globals);

		DPF(3, "lineShutdown");
		DPF(3, ">   hLineApp: %08X", globals->hLineApp);

		lResult = lineShutdown(globals->hLineApp);
		LINEERROR(lResult);
	}

	SP_MemFree(globals);

	return (SUCCESS);
}

/* dialLineOpen - wrapper for lineOpen */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialLineOpen"

LINERESULT dialLineOpen(LPDPDIAL globals, DWORD dwLine)
{
	LINEEXTENSIONID lineExtensionID;		// Will be set to 0 to indicate no known extensions
    LPLINEDEVCAPS	lpLineDevCaps = NULL;
	LINERESULT		lResult;

	// fail if line is already open
	FAILWITHACTION(globals->hLine != 0, lResult = LINEERR_INVALLINEHANDLE, Failure);

	/* negotiate API version for each line */
	lResult = lineNegotiateAPIVersion(globals->hLineApp, dwLine,
					TAPIVERSION, TAPIVERSION,
					&globals->dwAPIVersion, &lineExtensionID);
	FAILIF(LINEERROR(lResult), Failure);

	lResult = dialGetDevCaps(globals, dwLine, globals->dwAPIVersion, &lpLineDevCaps);
	FAILIF(LINEERROR(lResult), Failure);

	/* check for supported media mode.  If not datamodem, continue to next line */
	FAILWITHACTION(!(lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM),
					lResult = LINEERR_NODEVICE, Failure);

	DPF(3, "lineOpen");
	DPF(3, ">   hLineApp: %08X", globals->hLineApp);
	DPF(3, "> dwDeviceID: %d", dwLine);

	// reset error tracking
	globals->dwCallError = CALL_OK;

	/* open the line that supports data modems */
	lResult = lineOpen( globals->hLineApp, dwLine, &globals->hLine,
						globals->dwAPIVersion, 0L,
						(DWORD_PTR) globals,
						LINECALLPRIVILEGE_OWNER, LINEMEDIAMODE_DATAMODEM,
						NULL);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "<      hLine: %08X", globals->hLine);

	/* if we are here then we found a compatible line */
	globals->dwLineID = dwLine;
	globals->dwCallState = LINECALLSTATE_IDLE;	// line is now idle and ready to make/receive calls
	lResult = SUCCESS;

Failure:
	if (lpLineDevCaps)
		SP_MemFree(lpLineDevCaps);
	return (lResult);
}

/* dialLineClose - wrapper for lineClose */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialLineClose"

LINERESULT dialLineClose(LPDPDIAL globals)
{
	LINERESULT	lResult;

	// fail if line is already closed
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);

	DPF(3, "lineClose");
	DPF(3, ">      hLine: %08X", globals->hLine);

	lResult = lineClose(globals->hLine);
	LINEERROR(lResult);

	globals->hLine = 0;

Failure:
	return (lResult);
}

/* dialMakeCall - wrapper for lineMakeCall */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialMakeCall"

LINERESULT dialMakeCall(LPDPDIAL globals, LPTSTR szDestination)
{
	LINECALLPARAMS			callparams;
	LINERESULT				lResult;

	// fail if line not open or if call is already open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall != 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	// set call parameters
	ZeroMemory(&callparams, sizeof(LINECALLPARAMS));
	callparams.dwBearerMode = LINEBEARERMODE_VOICE;
	callparams.dwMediaMode = LINEMEDIAMODE_DATAMODEM;
	callparams.dwTotalSize = sizeof(LINECALLPARAMS);

	DPF(3, "lineMakeCall");
	DPF(3, ">      hLine: %08X", globals->hLine);
	DPF(3, "> szDestAddr: \"%s\"", szDestination);

	lResult = lineMakeCall(globals->hLine, &globals->hCall, szDestination, 0, &callparams);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	DPF(3, "<      hCall: %08X", globals->hCall);
	DPF(3, "<  dwAsyncID: %d", lResult);

	globals->dwAsyncID = lResult;			// store async ID
	lResult = SUCCESS;

Failure:
	return (lResult);
}

/* dialDropCall - wrapper for lineDrop */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialDropCall"

LINERESULT dialDropCall(LPDPDIAL globals)
{
	MSG			msg;
	DWORD		dwStopTicks;
	LINERESULT	lResult;

	// fail if line not open or if call not open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall == 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	DPF(3, "lineDrop");
	DPF(3, ">      hCall: %08X", globals->hCall);

	lResult = lineDrop(globals->hCall, NULL, 0);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	DPF(3, "<  dwAsyncID: %d", lResult);

	globals->dwAsyncID = lResult;			// store async ID

	// wait for call to get dropped
	dwStopTicks = GetTickCount() + LINEDROPTIMEOUT;
	while (GetTickCount() < dwStopTicks)
	{
		// see if reply has occured and we are idle
		if ((globals->dwAsyncID == 0) &&
			(globals->dwCallState == LINECALLSTATE_IDLE))
		{
			break;
		}

		// give TAPI a chance to call our callback
        if (PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
	}

	lResult = SUCCESS;

Failure:
	return (lResult);
}

/* dialDeallocCall - wrapper for lineDeallocCall */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialDeallocCall"

LINERESULT dialDeallocCall(LPDPDIAL globals)
{
	LINERESULT	lResult;

	// fail if line not open or if call not open
	FAILWITHACTION(globals->hLine == 0, lResult = LINEERR_INVALLINEHANDLE, Failure);
	FAILWITHACTION(globals->hCall == 0, lResult = LINEERR_INVALCALLHANDLE, Failure);

	// close the com port
	dialCloseCommHandle(globals);

	DPF(3, "lineDeallocateCall");
	DPF(3, ">      hCall: %08X", globals->hCall);

	lResult = lineDeallocateCall(globals->hCall);
	LINEERROR(lResult);

	globals->hCall = 0;

Failure:
	return (lResult);
}

/* dialIsConnected- returns TRUE if call is connected */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialIsConnected"

BOOL dialIsConnected(LPDPDIAL globals)
{
	// connected if we have a call handle and the state is connected
	if ((globals->hCall) &&
		(globals->dwCallState == LINECALLSTATE_CONNECTED))
		return (TRUE);
	else
		return (FALSE);
}

/* callback function */

#undef DPF_MODNAME
#define DPF_MODNAME	"LineCallBackProc"

void FAR PASCAL LineCallBackProc(DWORD hDevice, DWORD dwMessage, DWORD_PTR dwInstance,
								 DWORD_PTR dwParam1, DWORD_PTR dwParam2, DWORD_PTR dwParam3)
{
	LPDPDIAL	globals = (LPDPDIAL) dwInstance;

	DPF(3, "Line message: %s", GetLineMsgStr(dwMessage));

    switch (dwMessage)
	{
	case LINE_LINEDEVSTATE:
		break;

	case LINE_CALLSTATE:

		globals->dwCallState = dwParam1;

		DPF(3, "  call state: %s", GetCallStateStr((DWORD)globals->dwCallState));

		switch (globals->dwCallState)
		{
		case LINECALLSTATE_OFFERING:
			ProcessOfferingState(globals, (HCALL) hDevice, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_CONNECTED:
			ProcessConnectedState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_DISCONNECTED:
			ProcessDisconnectedState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_IDLE:
			ProcessIdleState(globals, (HCALL) hDevice, (DWORD)dwParam2, (DWORD)dwParam3);
			break;

		case LINECALLSTATE_BUSY:
			break;
		}
		break;

	case LINE_REPLY:
		ProcessReplyMessage(globals, (DWORD)dwParam1, (LINERESULT) dwParam2);
		break;

	/* other messages that can be processed */
	case LINE_CLOSE:
		// the line has shut itself down
		globals->hLine = 0;
		globals->dwCallError = CALL_CLOSED;
		break;
	case LINE_ADDRESSSTATE:
		break;
	case LINE_CALLINFO:
		break;
	case LINE_DEVSPECIFIC:
		break;
	case LINE_DEVSPECIFICFEATURE:
		break;
	case LINE_GATHERDIGITS:
		break;
	case LINE_GENERATE:
		break;
	case LINE_MONITORDIGITS:
		break;
	case LINE_MONITORMEDIA:
		break;
	case LINE_MONITORTONE:
		break;
	} /* switch */

} /* LineCallBackProc */

/* ProcessOfferingState - handler for LINECALLSTATE_OFFERING state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessOfferingState"

void ProcessOfferingState(LPDPDIAL globals, HCALL hCall, DWORD dwCallPrivilege)
{
	LINERESULT	lResult;

	DDASSERT(hCall);
	DDASSERT(globals->hCall == 0);
	DDASSERT(globals->dwAsyncID == 0);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", (DWORD)dwCallPrivilege);

	// fail if we don't own the call
	FAILIF(dwCallPrivilege != LINECALLPRIVILEGE_OWNER, Failure);

	// answer the call
	lResult = lineAnswer(hCall, NULL, 0);

	// lResult will be > 0 if call is asynchronous
	FAILWITHACTION(lResult < 0, LINEERROR(lResult), Failure);
	FAILMSG(lResult == 0);

	globals->hCall = hCall;					// store call handle
	globals->dwAsyncID = lResult;			// store async ID

Failure:
	return;
}

/* ProcessConnectedState - handler for LINECALLSTATE_CONNECTED state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessConnectedState"

void ProcessConnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	LINERESULT		lResult;
	HRESULT			hr;

	DDASSERT(hCall);
	DDASSERT(globals->hCall);
	DDASSERT(globals->hCall == hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);

	// get the id of the COM device connected to the modem
	// NOTE: once we get the handle, it is our responsibility to close it
	lResult = dialGetCommHandle(globals);
	FAILIF(LINEERROR(lResult), Failure);

	DPF(3, "    hComPort: %08X", globals->hComm);

	// setup com port
	hr = globals->lpComPort->Setup(globals->lpComPort, globals->hComm);
	FAILIF(FAILED(hr), Failure);		

	{
		DWORD	dwBaudRate;

		lResult = dialGetBaudRate(globals, &dwBaudRate);
	}

Failure:
	return;
}

/* ProcessDisconnectedState - handler for LINECALLSTATE_DISCONNECTED state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessDisconnectedState"

void ProcessDisconnectedState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	LINERESULT		lResult;

	DDASSERT(hCall);
	DDASSERT(globals->hCall);
	DDASSERT(globals->hCall == hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);

	// record error
	globals->dwCallError = CALL_DISCONNECTED;

	// shutdown com port and deallocate call handle
	lResult = dialDeallocCall(globals);
	FAILMSG(LINEERROR(lResult));
}

/* ProcessIdleState - handler for LINECALLSTATE_IDLE state */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessIdleState"

void ProcessIdleState(LPDPDIAL globals, HCALL hCall, DWORD dwCallStateDetail, DWORD dwCallPrivilege)
{
	DDASSERT(hCall);

	DPF(3, "       hCall: %08X", hCall);
	DPF(3, "   privilege: %08X", dwCallPrivilege);
	DPF(3, "      detail: %08X", dwCallStateDetail);
}

/* ProcessReplyMessage - handler for LINE_REPLY message */

#undef DPF_MODNAME
#define DPF_MODNAME	"ProcessReplyMessage"

void ProcessReplyMessage(LPDPDIAL globals, DWORD dwAsyncID, LINERESULT lResult)
{
	DDASSERT(dwAsyncID);
	DDASSERT(globals->dwAsyncID);
	DDASSERT(globals->dwAsyncID == dwAsyncID);

	DPF(3, "   dwAsyncID: %d", dwAsyncID);
	DPF(3, "       error: %d", lResult);

	// check for an error
	if (LINEERROR(lResult))
		globals->dwCallError = CALL_LINEERROR;


	// reset field so we know reply happened
	globals->dwAsyncID = 0;
}

/* dialGetDevCaps - wrapper for lineGetDevCaps */

/*	Bug #5400

	My trusty Compaq Presario returns two line devices. The second device says it
	needs 555 bytes for dev caps, but when you give it a pointer to a 555-byte block
	it actually writes 559 (!) bytes into the buffer! Whoah, Bessy!

	This makes Windows very unhappy in strange and magical ways.

	The fix is to start with a very large buffer (1024 bytes?) like all the samples do
	and then leave some slop in subsequent reallocs, which should hopefully clean up
	after these messy critters.
*/

#define DEVCAPSINITIALSIZE	1024		// size of first alloc
#define DEVCAPSSLOP			100			// extra space that loser service providers can party on

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetDevCaps"

LINERESULT dialGetDevCaps(LPDPDIAL globals, DWORD dwLine, DWORD dwAPIVersion, LPLINEDEVCAPS	*lpDevCapsRet)
{
	LPLINEDEVCAPS	lpDevCaps;
	LINERESULT		lResult;
	LPVOID			lpTemp;

	// create a buffer for dev caps
	lpDevCaps = (LPLINEDEVCAPS) SP_MemAlloc(DEVCAPSINITIALSIZE + DEVCAPSSLOP);
	FAILWITHACTION(lpDevCaps == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpDevCaps->dwTotalSize = DEVCAPSINITIALSIZE;

	while (TRUE)
	{
		// get device caps
		lResult = lineGetDevCaps(globals->hLineApp, dwLine,
								 dwAPIVersion, 0, lpDevCaps);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpDevCaps->dwNeededSize <= lpDevCaps->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpDevCaps, lpDevCaps->dwNeededSize + DEVCAPSSLOP);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpDevCaps = lpTemp;
		lpDevCaps->dwTotalSize = lpDevCaps->dwNeededSize;
	}

	*lpDevCapsRet = lpDevCaps;
	return (SUCCESS);

Failure:
	if (lpDevCaps)
		SP_MemFree(lpDevCaps);
	return (lResult);
}

/* dialGetCallInfo - wrapper for lineGetCallInfo */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetCallInfo"

LINERESULT dialGetCallInfo(LPDPDIAL globals, LPLINECALLINFO *lpCallInfoRet)
{
	LPLINECALLINFO	lpCallInfo;
	LINERESULT		lResult;
	LPVOID			lpTemp;

	// create a buffer for call info
	lpCallInfo = (LPLINECALLINFO) SP_MemAlloc(sizeof(LINECALLINFO));
	FAILWITHACTION(lpCallInfo == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpCallInfo->dwTotalSize = sizeof(LINECALLINFO);

	while (TRUE)
	{
		// get device info
		lResult = lineGetCallInfo(globals->hCall, lpCallInfo);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpCallInfo->dwNeededSize <= lpCallInfo->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpCallInfo, lpCallInfo->dwNeededSize);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpCallInfo = lpTemp;
		lpCallInfo->dwTotalSize = lpCallInfo->dwNeededSize;
	}

	*lpCallInfoRet = lpCallInfo;
	return (SUCCESS);

Failure:
	if (lpCallInfo)
		SP_MemFree(lpCallInfo);
	return (lResult);
}

/* dialGetBaudRate - get baud rate of current connecton */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetBaudRate"

LINERESULT dialGetBaudRate(LPDPDIAL globals, LPDWORD lpdwBaudRate)
{
	LPLINECALLINFO	lpCallInfo;
	LINERESULT		lResult;

	lResult = dialGetCallInfo(globals, &lpCallInfo);
	if LINEERROR(lResult)
		return (lResult);

	*lpdwBaudRate = lpCallInfo->dwRate;

	SP_MemFree(lpCallInfo);

	return (SUCCESS);
}

/* dialGetTranslateCaps - wrapper for lineGetTranslateCaps */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetTranslateCaps"

LINERESULT dialGetTranslateCaps(LPDPDIAL globals, DWORD dwAPIVersion, LPLINETRANSLATECAPS *lpTranslateCapsRet)
{
	LPLINETRANSLATECAPS	lpTranslateCaps;
	LPVOID				lpTemp;
	LINERESULT			lResult;

	// create a buffer for translate caps
	lpTranslateCaps = (LPLINETRANSLATECAPS) SP_MemAlloc(sizeof(LINETRANSLATECAPS));
	FAILWITHACTION(lpTranslateCaps == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpTranslateCaps->dwTotalSize = sizeof(LINETRANSLATECAPS);

	while (TRUE)
	{
		// get translate caps
		lResult = lineGetTranslateCaps(globals->hLineApp, dwAPIVersion, lpTranslateCaps);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpTranslateCaps->dwNeededSize <= lpTranslateCaps->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpTranslateCaps, lpTranslateCaps->dwNeededSize);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpTranslateCaps = lpTemp;
		lpTranslateCaps->dwTotalSize = lpTranslateCaps->dwNeededSize;
	}

	*lpTranslateCapsRet = lpTranslateCaps;
	return (SUCCESS);

Failure:
	if (lpTranslateCaps)
		SP_MemFree(lpTranslateCaps);
	return (lResult);
}

/* dialGetCommHandle - wrapper for lineGetID */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialGetCommHandle"

/* structure returned by Unimodem which contains device handle and name */
typedef struct {
	HANDLE			hComm;
	CHAR			szDeviceName[1];
} COMMID, *LPCOMMID;

LINERESULT dialGetCommHandle(LPDPDIAL globals)
{
	LPCOMMID	lpCommID;
	VARSTRING	*vs, *temp;
	LINERESULT	lResult;

    vs = (VARSTRING *) SP_MemAlloc(sizeof(VARSTRING));
	FAILWITHACTION(vs == NULL, lResult = LINEERR_NOMEM, Failure);

    vs->dwTotalSize = sizeof(VARSTRING);
    vs->dwStringFormat = STRINGFORMAT_BINARY;

	while (TRUE)
	{
		// get line ID
		lResult = lineGetID(0, 0L, globals->hCall, LINECALLSELECT_CALL, vs, "comm/datamodem");

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (vs->dwNeededSize <= vs->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		temp = SP_MemReAlloc(vs, vs->dwNeededSize);
		FAILWITHACTION(temp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		vs = temp;
		vs->dwTotalSize = vs->dwNeededSize;
	}

    lpCommID = (LPCOMMID) ((LPSTR)vs + vs->dwStringOffset);
//    lstrcpy(globals->szDeviceName, cid->szDeviceName);
	globals->hComm = lpCommID->hComm;

Failure:
	if (vs)
		SP_MemFree(vs);
	return (lResult);
}

/*	dialCloseCommHandle - make sure com port is closed */

/*	NOTE: As per the docs for the "comm/datamodem" device class,
	the handle to the com port returned by lineGetID() MUST be explictly
	closed using CloseHandle() or you will not be able to to open this
	line again!
*/

#undef DPF_MODNAME
#define DPF_MODNAME	"dialCloseCommHandle"

LINERESULT dialCloseCommHandle(LPDPDIAL globals)
{
	HANDLE	hCom;

	// make sure the com port globals are available
	if (globals->lpComPort)
	{
			// get handle to com port
			hCom = globals->lpComPort->GetHandle(globals->lpComPort);

			// make sure its closed down
			if (hCom)
			{
				globals->lpComPort->Shutdown(globals->lpComPort);
				CloseHandle(hCom);
			}
	}

	return (SUCCESS);
}

/* dialTranslateAddress - wrapper for lineTranslateAddress */

#undef DPF_MODNAME
#define DPF_MODNAME	"dialTranslateAddress"

LINERESULT dialTranslateAddress(LPDPDIAL globals, DWORD dwDeviceID, DWORD dwAPIVersion,
								LPCSTR lpszDialAddress,
								LPLINETRANSLATEOUTPUT *lpLineTranslateOutputRet)
{
	LPLINETRANSLATEOUTPUT	lpLineTranslateOutput;
	LPVOID					lpTemp;
	LINERESULT				lResult;

	// create a buffer for translate caps
	lpLineTranslateOutput = (LPLINETRANSLATEOUTPUT) SP_MemAlloc(sizeof(LINETRANSLATEOUTPUT));
	FAILWITHACTION(lpLineTranslateOutput == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);
	lpLineTranslateOutput->dwTotalSize = sizeof(LINETRANSLATEOUTPUT);

	while (TRUE)
	{
		// translate address
		lResult = lineTranslateAddress(globals->hLineApp, dwDeviceID, dwAPIVersion,
									   lpszDialAddress, 0, LINETRANSLATEOPTION_CANCELCALLWAITING,
									   lpLineTranslateOutput);

		if (lResult == SUCCESS)
		{
			// make sure there is enough space
			if (lpLineTranslateOutput->dwNeededSize <= lpLineTranslateOutput->dwTotalSize)
				break;		// there is enough space, so exit
		}
		else if (lResult != LINEERR_STRUCTURETOOSMALL)
		{
			LINEERROR(lResult);
			goto Failure;
		}

		// reallocate buffer if not big enough */

		lpTemp = SP_MemReAlloc(lpLineTranslateOutput, lpLineTranslateOutput->dwNeededSize);
		FAILWITHACTION(lpTemp == NULL, lResult = LINEERROR(LINEERR_NOMEM), Failure);

		lpLineTranslateOutput = lpTemp;
		lpLineTranslateOutput->dwTotalSize = lpLineTranslateOutput->dwNeededSize;
	}

	*lpLineTranslateOutputRet = lpLineTranslateOutput;
	return (SUCCESS);

Failure:
	if (lpLineTranslateOutput)
		SP_MemFree(lpLineTranslateOutput);
	return (lResult);
}

LINERESULT dialTranslateDialog(LPDPDIAL globals, HWND hWnd,
							   DWORD dwDeviceID, LPTSTR szPhoneNumber)
{
	LINERESULT	lResult;

	lResult = lineTranslateDialog(globals->hLineApp, dwDeviceID,
		TAPIVERSION, hWnd, szPhoneNumber);

	return (lResult);
}

//
//  FUNCTION: void dialFillModemComboBox(HWND)
//
//  PURPOSE: Fills the modem control with the available line devices.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//    This function enumerates through all the TAPI line devices and
//    queries each for the device name.  The device name is then put into
//    the 'TAPI Line' control.  These device names are kept in order rather
//    than sorted.  This allows "Dial" to know which device ID the user
//    selected just by the knowing the index of the selected string.
//
//    There are default values if there isn't a device name, if there is
//    an error on the device, or if the device name is an empty string.
//    The device name is also checked to make sure it is null terminated.
//
//    Note that a Legacy API Version is negotiated.  Since the fields in
//    the LINEDEVCAPS structure that we are interested in haven't moved, we
//    can negotiate a lower API Version than this sample is designed for
//    and still be able to access the necessary structure members.
//
//    The first line that is usable by TapiComm is selected as the 'default'
//    line.  Also note that if there was a previously selected line, this
//    remains the default line.  This would likely only occur if this
//    function is called after the dialog has initialized once; for example,
//    if a new line is added.
//
//

LINERESULT dialGetModemName(LPDPDIAL globals, DWORD dwDeviceID,
						 LPSTR lpszModemName, DWORD dwModemNameSize)
{
    LPLINEDEVCAPS	lpLineDevCaps = NULL;
    LPSTR			lpszLineName;
	LINEEXTENSIONID lineExtensionID;	// Will be set to 0 to indicate no known extensions
	DWORD			dwAPIVersion;       // api version
	DWORD			dwStrSize;
	LINERESULT		lResult;

	/* negotiate API version for each line */
	lResult = lineNegotiateAPIVersion(globals->hLineApp, dwDeviceID,
					TAPIVERSION, TAPIVERSION,
					&dwAPIVersion, &lineExtensionID);
	if LINEERROR(lResult)
		goto FAILURE;

	lResult = dialGetDevCaps(globals, dwDeviceID, dwAPIVersion, &lpLineDevCaps);
	if LINEERROR(lResult)
		goto FAILURE;

    if ((lpLineDevCaps->dwLineNameSize) &&
        (lpLineDevCaps->dwLineNameOffset) &&
        (lpLineDevCaps->dwStringFormat == STRINGFORMAT_ASCII) &&
        (lpLineDevCaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM))
    {
        // This is the name of the device.
        lpszLineName = ((char *) lpLineDevCaps) + lpLineDevCaps->dwLineNameOffset;

        if (lpszLineName[0] != '\0')
        {
			// Reverse indented to make this fit

			// Make sure the device name is null terminated.
			if (lpszLineName[lpLineDevCaps->dwLineNameSize -1] != '\0')
			{
				// If the device name is not null terminated, null
				// terminate it.  Yes, this looses the end character.
				// Its a bug in the service provider.
				lpszLineName[lpLineDevCaps->dwLineNameSize-1] = '\0';
				DPF(0, "Device name for device 0x%lx is not null terminated.", dwDeviceID);
			}
        }
        else // Line name started with a NULL.
		{
			lResult = LINEERR_OPERATIONFAILED;
            goto FAILURE;
		}
    }
    else  // DevCaps doesn't have a valid line name.  Unnamed.
	{
		lResult = LINEERR_OPERATIONFAILED;
        goto FAILURE;
	}

	// return modem name (make sure it fits)
	dwStrSize = strlen(lpszLineName) + 1;
	if (dwStrSize <= dwModemNameSize)
		CopyMemory(lpszModemName, lpszLineName, dwStrSize);
	else
	{
		CopyMemory(lpszModemName, lpszLineName, dwModemNameSize - 1);
		lpszModemName[dwModemNameSize - 1] = '\0';
	}

FAILURE:
	if (lpLineDevCaps)
		SP_MemFree(lpLineDevCaps);

	return (lResult);
}

LINERESULT dialGetModemList(LPDPDIAL globals, BOOL bAnsi, LPVOID *lplpData, LPDWORD lpdwDataSize)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LPBYTE			lpData;
	DWORD			dwDataSize, dwStrBytes, dwStrLen;
	LINERESULT		lResult;

	// make space for all possible strings plus terminating null
	lpData = (LPBYTE) SP_MemAlloc(globals->dwNumLines * MAXSTRINGSIZE * sizeof(WCHAR) + sizeof(WCHAR));
	FAILWITHACTION(lpData == NULL, lResult = LINEERR_NOMEM, Failure);

	dwDataSize = 0;
    for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if LINEERROR(lResult)
			continue;

		if (bAnsi)
		{
			dwStrBytes = (lstrlen(szModemName) + 1) * sizeof(CHAR);
			memcpy(lpData + dwDataSize, szModemName, dwStrBytes);
		}
		else
		{
			// NOTE: AnsiToWide returns the character count INCLUDING the terminating null character
			dwStrLen = AnsiToWide((LPWSTR) (lpData + dwDataSize), szModemName, MAXSTRINGSIZE * sizeof(WCHAR));
			dwStrBytes = dwStrLen * sizeof(WCHAR);
		}

		dwDataSize += dwStrBytes;
	}

	// put a null at end of list to terminate it
	if (bAnsi)
	{
		*(lpData + dwDataSize) = 0;
		dwDataSize += sizeof(CHAR);
	}
	else
	{
		*((LPWSTR) (lpData + dwDataSize)) = 0;
		dwDataSize += sizeof(WCHAR);
	}

	// return buffer pointer and size
	*lplpData = lpData;
	*lpdwDataSize = dwDataSize;

	return (SUCCESS);

Failure:
	return (lResult);
}

void dialFillModemComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultDevice)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LINERESULT		lResult;


	for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		//
		// Attempt to get the modem name.  If this fails, don't add the modem
		// to the dialog.
		//
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if ( LINEERROR(lResult) == FALSE )
		{
			//
			// This line appears to be usable, put the device name into the
			// dialog control and associate the TAPI modem ID with it
			//
			lResult = (DWORD) SendDlgItemMessage(hwndDlg, item,
				CB_ADDSTRING, 0, (LPARAM) szModemName);

			if ( lResult != CB_ERRSPACE )
			{
				DWORD_PTR	TempReturn;


				//
				// We've managed to get this entry into the control, make sure
				// we associate the proper TAPI modem ID with this item.  This
				// should never fail.
				//
				TempReturn = SendDlgItemMessage( hwndDlg, item, CB_SETITEMDATA, lResult, dwDeviceID );
				DDASSERT( TempReturn != CB_ERR );

				// If this line is usable and we don't have a default initial
				// line yet, make this the initial line.
				if (dwDefaultDevice == MAXDWORD)
					dwDefaultDevice = lResult;
			}
		}
	}

    if (dwDefaultDevice == MAXDWORD)
        dwDefaultDevice = 0;

    // Set the initial default line
    SendDlgItemMessage(hwndDlg, item,
        CB_SETCURSEL, dwDefaultDevice, 0);
}

LRESULT dialGetDeviceIDFromName(LPDPDIAL globals, LPCSTR szTargetName, DWORD *lpdwDeviceID)
{
    DWORD			dwDeviceID;
	CHAR			szModemName[MAXSTRINGSIZE];
	LINERESULT		lResult;

    for (dwDeviceID = 0; dwDeviceID < globals->dwNumLines; dwDeviceID ++)
    {
		lResult = dialGetModemName(globals, dwDeviceID, szModemName, MAXSTRINGSIZE);
		if LINEERROR(lResult)
			continue;

		if (strcmp(szModemName, szTargetName) == 0)
		{
			*lpdwDeviceID = dwDeviceID;
			return (SUCCESS);
		}
	}

	return (LINEERR_OPERATIONFAILED);
}

//
//  FUNCTION: void dialFillLocationComboBox(HWND)
//
//  PURPOSE: Fills the control with the available calling from locations.
//
//  PARAMETERS:
//    hwndDlg - handle to the current "Dial" dialog
//
//  RETURN VALUE:
//    none
//
//  COMMENTS:
//
//

void dialFillLocationComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultLocation)
{
    LPLINETRANSLATECAPS	lpTranslateCaps = NULL;
	LPLINELOCATIONENTRY lpLocationEntry;
	DWORD				dwCounter;
	LONG				index;
	LINERESULT			lResult;

	// get translate caps
	lResult = dialGetTranslateCaps(globals, TAPIVERSION, &lpTranslateCaps);
	if LINEERROR(lResult)
		return;

    // Find the location information in the TRANSLATECAPS
    lpLocationEntry = (LPLINELOCATIONENTRY)
        (((LPBYTE) lpTranslateCaps) + lpTranslateCaps->dwLocationListOffset);

    // First empty the combobox
    SendDlgItemMessage(hwndDlg, item, CB_RESETCONTENT, (WPARAM) 0, (LPARAM) 0);

    // enumerate all the locations
    for (dwCounter = 0; dwCounter < lpTranslateCaps->dwNumLocations; dwCounter++)
    {
        // Put each one into the combobox
        index = (DWORD)SendDlgItemMessage(hwndDlg, item,
						CB_ADDSTRING,
						(WPARAM) 0,
						(LPARAM) (((LPBYTE) lpTranslateCaps) +
						lpLocationEntry[dwCounter].dwLocationNameOffset));

        // Is this location the 'current' location?
        if (lpLocationEntry[dwCounter].dwPermanentLocationID ==
            lpTranslateCaps->dwCurrentLocationID)
        {
            // Set this to be the active location.
            SendDlgItemMessage(hwndDlg, item, CB_SETCURSEL, (WPARAM) index, (LPARAM) 0);
        }
    }

	if (lpTranslateCaps)
		SP_MemFree(lpTranslateCaps);
}


char	gTempStr[200];

LONG lineError(LONG err, LPSTR modName, DWORD lineNum)
{
	if (err)
		DPF(0, "TAPI line error in %s at line %d : %s", modName, lineNum, GetLineErrStr(err));

	return (err);
}

LPSTR GetCallStateStr(DWORD callState)
{
	switch (callState)
	{
	case LINECALLSTATE_IDLE: return ("LINECALLSTATE_IDLE");
	case LINECALLSTATE_OFFERING: return ("LINECALLSTATE_OFFERING");
	case LINECALLSTATE_ACCEPTED: return ("LINECALLSTATE_ACCEPTED");
	case LINECALLSTATE_DIALTONE: return ("LINECALLSTATE_DIALTONE");
	case LINECALLSTATE_DIALING: return ("LINECALLSTATE_DIALING");
	case LINECALLSTATE_RINGBACK: return ("LINECALLSTATE_RINGBACK");
	case LINECALLSTATE_BUSY: return ("LINECALLSTATE_BUSY");
	case LINECALLSTATE_SPECIALINFO: return ("LINECALLSTATE_SPECIALINFO");
	case LINECALLSTATE_CONNECTED: return ("LINECALLSTATE_CONNECTED");
	case LINECALLSTATE_PROCEEDING: return ("LINECALLSTATE_PROCEEDING");
	case LINECALLSTATE_ONHOLD: return ("LINECALLSTATE_ONHOLD");
	case LINECALLSTATE_CONFERENCED: return ("LINECALLSTATE_CONFERENCED");
	case LINECALLSTATE_ONHOLDPENDCONF: return ("LINECALLSTATE_ONHOLDPENDCONF");
	case LINECALLSTATE_ONHOLDPENDTRANSFER: return ("LINECALLSTATE_ONHOLDPENDTRANSFER");
	case LINECALLSTATE_DISCONNECTED: return ("LINECALLSTATE_DISCONNECTED");
	case LINECALLSTATE_UNKNOWN: return ("LINECALLSTATE_UNKNOWN");
	}

	wsprintf(gTempStr, "UNKNOWN CALL STATE = %lu", callState);
	return (gTempStr);
}

LPSTR GetLineMsgStr(DWORD msg)
{
	switch (msg)
	{
	case LINE_ADDRESSSTATE: return ("LINE_ADDRESSSTATE");
	case LINE_CALLINFO: return ("LINE_CALLINFO");
	case LINE_CALLSTATE: return ("LINE_CALLSTATE");
	case LINE_CLOSE: return ("LINE_CLOSE");
	case LINE_DEVSPECIFIC: return ("LINE_DEVSPECIFIC");
	case LINE_DEVSPECIFICFEATURE: return ("LINE_DEVSPECIFICFEATURE");
	case LINE_GATHERDIGITS: return ("LINE_GATHERDIGITS");
	case LINE_GENERATE: return ("LINE_GENERATE");
	case LINE_LINEDEVSTATE: return ("LINE_LINEDEVSTATE");
	case LINE_MONITORDIGITS: return ("LINE_MONITORDIGITS");
	case LINE_MONITORMEDIA: return ("LINE_MONITORMEDIA");
	case LINE_MONITORTONE: return ("LINE_MONITORTONE");
	case LINE_REPLY: return ("LINE_REPLY");
	case LINE_REQUEST: return ("LINE_REQUEST");
	}

	wsprintf(gTempStr, "UNKNOWN LINE MESSAGE = %lu", msg);
	return (gTempStr);
}


LPSTR GetLineErrStr(LONG err)
{
	switch (err)
	{
	case LINEERR_ADDRESSBLOCKED: return ("LINEERR_ADDRESSBLOCKED");
	case LINEERR_ALLOCATED: return ("LINEERR_ALLOCATED");
	case LINEERR_BADDEVICEID: return ("LINEERR_BADDEVICEID");
	case LINEERR_BEARERMODEUNAVAIL: return ("LINEERR_BEARERMODEUNAVAIL");
	case LINEERR_CALLUNAVAIL: return ("LINEERR_CALLUNAVAIL");
	case LINEERR_COMPLETIONOVERRUN: return ("LINEERR_COMPLETIONOVERRUN");
	case LINEERR_CONFERENCEFULL: return ("LINEERR_CONFERENCEFULL");
	case LINEERR_DIALBILLING: return ("LINEERR_DIALBILLING");
	case LINEERR_DIALQUIET: return ("LINEERR_DIALQUIET");
	case LINEERR_DIALDIALTONE: return ("LINEERR_DIALDIALTONE");
	case LINEERR_DIALPROMPT: return ("LINEERR_DIALPROMPT");
	case LINEERR_INCOMPATIBLEAPIVERSION: return ("LINEERR_INCOMPATIBLEAPIVERSION");
	case LINEERR_INCOMPATIBLEEXTVERSION: return ("LINEERR_INCOMPATIBLEEXTVERSION");
	case LINEERR_INIFILECORRUPT: return ("LINEERR_INIFILECORRUPT");
	case LINEERR_INUSE: return ("LINEERR_INUSE");
	case LINEERR_INVALADDRESS: return ("LINEERR_INVALADDRESS");
	case LINEERR_INVALADDRESSID: return ("LINEERR_INVALADDRESSID");
	case LINEERR_INVALADDRESSMODE: return ("LINEERR_INVALADDRESSMODE");
	case LINEERR_INVALADDRESSSTATE: return ("LINEERR_INVALADDRESSSTATE");
	case LINEERR_INVALAPPHANDLE: return ("LINEERR_INVALAPPHANDLE");
	case LINEERR_INVALAPPNAME: return ("LINEERR_INVALAPPNAME");
	case LINEERR_INVALBEARERMODE: return ("LINEERR_INVALBEARERMODE");
	case LINEERR_INVALCALLCOMPLMODE: return ("LINEERR_INVALCALLCOMPLMODE");
	case LINEERR_INVALCALLHANDLE: return ("LINEERR_INVALCALLHANDLE");
	case LINEERR_INVALCALLPARAMS: return ("LINEERR_INVALCALLPARAMS");
	case LINEERR_INVALCALLPRIVILEGE: return ("LINEERR_INVALCALLPRIVILEGE");
	case LINEERR_INVALCALLSELECT: return ("LINEERR_INVALCALLSELECT");
	case LINEERR_INVALCALLSTATE: return ("LINEERR_INVALCALLSTATE");
	case LINEERR_INVALCALLSTATELIST: return ("LINEERR_INVALCALLSTATELIST");
	case LINEERR_INVALCARD: return ("LINEERR_INVALCARD");
	case LINEERR_INVALCOMPLETIONID: return ("LINEERR_INVALCOMPLETIONID");
	case LINEERR_INVALCONFCALLHANDLE: return ("LINEERR_INVALCONFCALLHANDLE");
	case LINEERR_INVALCONSULTCALLHANDLE: return ("LINEERR_INVALCONSULTCALLHANDLE");
	case LINEERR_INVALCOUNTRYCODE: return ("LINEERR_INVALCOUNTRYCODE");
	case LINEERR_INVALDEVICECLASS: return ("LINEERR_INVALDEVICECLASS");
	case LINEERR_INVALDIGITLIST: return ("LINEERR_INVALDIGITLIST");
	case LINEERR_INVALDIGITMODE: return ("LINEERR_INVALDIGITMODE");
	case LINEERR_INVALDIGITS: return ("LINEERR_INVALDIGITS");
	case LINEERR_INVALFEATURE: return ("LINEERR_INVALFEATURE");
	case LINEERR_INVALGROUPID: return ("LINEERR_INVALGROUPID");
	case LINEERR_INVALLINEHANDLE: return ("LINEERR_INVALLINEHANDLE");
	case LINEERR_INVALLINESTATE: return ("LINEERR_INVALLINESTATE");
	case LINEERR_INVALLOCATION: return ("LINEERR_INVALLOCATION");
	case LINEERR_INVALMEDIALIST: return ("LINEERR_INVALMEDIALIST");
	case LINEERR_INVALMEDIAMODE: return ("LINEERR_INVALMEDIAMODE");
	case LINEERR_INVALMESSAGEID: return ("LINEERR_INVALMESSAGEID");
	case LINEERR_INVALPARAM: return ("LINEERR_INVALPARAM");
	case LINEERR_INVALPARKMODE: return ("LINEERR_INVALPARKMODE");
	case LINEERR_INVALPOINTER: return ("LINEERR_INVALPOINTER");
	case LINEERR_INVALPRIVSELECT: return ("LINEERR_INVALPRIVSELECT");
	case LINEERR_INVALRATE: return ("LINEERR_INVALRATE");
	case LINEERR_INVALREQUESTMODE: return ("LINEERR_INVALREQUESTMODE");
	case LINEERR_INVALTERMINALID: return ("LINEERR_INVALTERMINALID");
	case LINEERR_INVALTERMINALMODE: return ("LINEERR_INVALTERMINALMODE");
	case LINEERR_INVALTIMEOUT: return ("LINEERR_INVALTIMEOUT");
	case LINEERR_INVALTONE: return ("LINEERR_INVALTONE");
	case LINEERR_INVALTONELIST: return ("LINEERR_INVALTONELIST");
	case LINEERR_INVALTONEMODE: return ("LINEERR_INVALTONEMODE");
	case LINEERR_INVALTRANSFERMODE: return ("LINEERR_INVALTRANSFERMODE");
	case LINEERR_LINEMAPPERFAILED: return ("LINEERR_LINEMAPPERFAILED");
	case LINEERR_NOCONFERENCE: return ("LINEERR_NOCONFERENCE");
	case LINEERR_NODEVICE: return ("LINEERR_NODEVICE");
	case LINEERR_NODRIVER: return ("LINEERR_NODRIVER");
	case LINEERR_NOMEM: return ("LINEERR_NOMEM");
	case LINEERR_NOMULTIPLEINSTANCE: return ("LINEERR_NOMULTIPLEINSTANCE");
	case LINEERR_NOREQUEST: return ("LINEERR_NOREQUEST");
	case LINEERR_NOTOWNER: return ("LINEERR_NOTOWNER");
	case LINEERR_NOTREGISTERED: return ("LINEERR_NOTREGISTERED");
	case LINEERR_OPERATIONFAILED: return ("LINEERR_OPERATIONFAILED");
	case LINEERR_OPERATIONUNAVAIL: return ("LINEERR_OPERATIONUNAVAIL");
	case LINEERR_RATEUNAVAIL: return ("LINEERR_RATEUNAVAIL");
	case LINEERR_REINIT: return ("LINEERR_REINIT");
	case LINEERR_RESOURCEUNAVAIL: return ("LINEERR_RESOURCEUNAVAIL");
	case LINEERR_STRUCTURETOOSMALL: return ("LINEERR_STRUCTURETOOSMALL");
	case LINEERR_TARGETNOTFOUND: return ("LINEERR_TARGETNOTFOUND");
	case LINEERR_TARGETSELF: return ("LINEERR_TARGETSELF");
	case LINEERR_UNINITIALIZED: return ("LINEERR_UNINITIALIZED");
	case LINEERR_USERUSERINFOTOOBIG: return ("LINEERR_USERUSERINFOTOOBIG");
	}

	wsprintf(gTempStr, "UNKNOWN LINE ERROR = %ld", err);
	return (gTempStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\dial.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dial.c
 *  Content:	Header for TAPI  routines
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *	7/08/96 kipo	added support for new dialogs
 *	8/10/96 kipo	added support for dialing location
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 * 11/25/97 kipo	set TAPI_CURRENT_VERSION to 1.4 so the NT build won't
 *					use NT-only features (15209)
 *  5/07/98 a-peterz Track call errors in DPDIAL
 *@@END_MSINTERNAL
 ***************************************************************************/

// need to add this line so that NT builds won't define Tapi 2.0 by default,
// which causes it to link with ANSI versions of Tapi functions that are not
// available on Win 95, causing LoadLibrary to fail.

#define TAPI_CURRENT_VERSION 0x00010004

#include "tapi.h"
#include "comport.h"

#define TAPIVERSION			0x00010003	// TAPI version to require
#define LINEDROPTIMEOUT		5000		// ms to wait for call to drop
#define SUCCESS				0
#define MAXSTRINGSIZE		400

// DPDIAL.dwCallError values
enum { CALL_OK, CALL_LINEERROR, CALL_DISCONNECTED, CALL_CLOSED };

typedef LONG	LINERESULT;

typedef struct {
	HLINEAPP		hLineApp;			// handle to line application
	HLINE			hLine;				// handle to the line device
	HCALL			hCall;				// handle to the call
	HANDLE			hComm;				// handle to com port
	LPDPCOMPORT		lpComPort;			// pointer to com port object
	DWORD			dwAPIVersion;       // api version
	DWORD			dwNumLines;			// number of line devices supported by the service provider
	DWORD           dwLineID;			// line id of open line
	DWORD_PTR   	dwCallState;		// current call state of session
	DWORD			dwAsyncID;			// id of pending async operation
	DWORD			dwCallError;		// last error
} DPDIAL, *LPDPDIAL;

extern LINERESULT dialInitialize(HINSTANCE hInst, LPTSTR szAppName, LPDPCOMPORT lpComPort, LPDPDIAL *storage);
extern LINERESULT dialShutdown(LPDPDIAL globals);
extern LINERESULT dialLineOpen(LPDPDIAL globals, DWORD dwLine);
extern LINERESULT dialLineClose(LPDPDIAL globals);
extern LINERESULT dialMakeCall(LPDPDIAL globals, LPTSTR szDestination);
extern LINERESULT dialDropCall(LPDPDIAL globals);
extern LINERESULT dialDeallocCall(LPDPDIAL globals);
extern BOOL		  dialIsConnected(LPDPDIAL globals);
extern LINERESULT dialGetBaudRate(LPDPDIAL globals, LPDWORD lpdwBaudRate);
extern LRESULT	  dialGetDeviceIDFromName(LPDPDIAL globals, LPCSTR szTargetName, DWORD *lpdwDeviceID);
extern LINERESULT dialGetModemList(LPDPDIAL globals, BOOL bAnsi, LPVOID *lplpData, LPDWORD lpdwDataSize);
extern void		  dialFillModemComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultDevice);
extern void		  dialFillLocationComboBox(LPDPDIAL globals, HWND hwndDlg, int item, DWORD dwDefaultLocation);
extern LINERESULT dialTranslateDialog(LPDPDIAL globals, HWND hWnd,
							   DWORD dwDeviceID, LPTSTR szPhoneNumber);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\macros.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       macros.c
 *  Content:	debugging macros
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 *@@END_MSINTERNAL
 ***************************************************************************/

#include "dpf.h"
#include "memalloc.h"

#define FAILMSG(condition) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
	}

#define FAILERR(err, label) \
	if ((err)) { \
		DPF(0, DPF_MODNAME " line %d : Error = %d", __LINE__, (err)); \
		goto label; \
	}

#define FAILIF(condition, label) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
		goto label; \
	}

#define FAILWITHACTION(condition, action, label) \
	if ((condition)) { \
		DPF(0, DPF_MODNAME " line %d : Failed because " #condition "", __LINE__); \
		{ action; } \
		goto label; \
	}

extern CRITICAL_SECTION csMem;
#define INIT_DPSP_CSECT() InitializeCriticalSection(&csMem);
#define FINI_DPSP_CSECT() DeleteCriticalSection(&csMem);

// Wrap Malloc
void _inline __cdecl SP_MemFree( LPVOID lptr )
{
	EnterCriticalSection(&csMem);
	MemFree(lptr);
	LeaveCriticalSection(&csMem);
}

LPVOID _inline __cdecl SP_MemAlloc(UINT size)
{
	LPVOID lpv;
	EnterCriticalSection(&csMem);
	lpv = MemAlloc(size);
	LeaveCriticalSection(&csMem);
	return lpv;
}

LPVOID _inline __cdecl SP_MemReAlloc(LPVOID lptr, UINT size)
{
	EnterCriticalSection(&csMem);
	lptr = MemReAlloc(lptr, size);
	LeaveCriticalSection(&csMem);
	return lptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\daytona\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllmain.c
 *  Content:	Main entry point for the DLL.
 *  History:
 *@@BEGIN_MSINTERNAL
 *   Date	By	Reason
 *   ====	==	======
 *  4/10/96	kipo	created it
 *  4/15/96 kipo	added msinternal
 *  6/18/96 kipo	changed ghInstance to be an HINSTANCE
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 *@@END_MSINTERNAL
 ***************************************************************************/

#include <windows.h>

#include "dpf.h"
#include "macros.h"

DWORD		gdwRefCount = 0;		// no. of attached processes
HINSTANCE	ghInstance = NULL;		// instance of our DLL

/*
 * DllMain
 *
 * Main entry point for DLL.
 */

#undef DPF_MODNAME
#define DPF_MODNAME "DllMain"

BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
	switch( dwReason )
	{
	case DLL_PROCESS_ATTACH:

		DisableThreadLibraryCalls( hmod );
		DPFINIT(); // bugbug : dpfinit for every proc?

		DPF( 0, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
				GetCurrentProcessId(), GetCurrentThreadId() );
			
		// initialize memory
		if( gdwRefCount == 0 )
		{
			DPF(0,"dllmain - starting up!");

			// do one-time initializations
			INIT_DPSP_CSECT();	

	        if( !MemInit() )
	        {
		        DPF( 0, "LEAVING, COULD NOT MemInit" );
		        return FALSE;
	        }

			// save the instance
			ghInstance = hmod;
		}

		gdwRefCount++;
		break;

	case DLL_PROCESS_DETACH:

		DPF( 2, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
			DllMain, GetCurrentProcessId(), GetCurrentThreadId() );
		
		gdwRefCount--;        
		if (gdwRefCount == 0) 
		{
			DPF(0,"DPMODEMX - dllmain - going away!");
			
		    #ifdef DEBUG
	    	    MemState();
		    #endif // debug
	    
	        MemFini(); 

		    FINI_DPSP_CSECT();

		} 
		break;

	default:
		break;
	}

    return TRUE;

} // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\win9x\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>
#include <memlog.h>

#ifdef __cplusplus
	extern "C" {
#endif
#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && !defined(WINNT)
	#define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
	#define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

    /*
     * Debugging output/flow-control calls
     */
    typedef struct {
    	UINT stat_ThrottleRate;
		UINT stat_BytesSent;
		UINT stat_BackLog;
	 	UINT stat_BytesLost;
	 	UINT stat_RemBytesReceived;
		UINT stat_Latency; 
		UINT stat_MinLatency;
		UINT stat_AvgLatency;
		UINT stat_AvgDevLatency;
		UINT stat_USER1;
		UINT stat_USER2;
		UINT stat_USER3;
		UINT stat_USER4;
		UINT stat_USER5;	// remote tDelta
		UINT stat_USER6;	// Remote tDelta sign (0=+ve, 1=-ve)
	} IN_WRITESTATS, *PIN_WRITESTATS;

	typedef struct {
		UINT	hr;
	} OUT_WRITESTATS, *POUT_WRITESTATS;

   extern void DbgWriteStats(PIN_WRITESTATS pIn);
  
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(volatile DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
 
    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}


#else
    #pragma warning(disable:4002)
    #define DbgWriteStats()
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()

#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD myclockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD myclock()	 {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= myclock(), t ## N ++
    #define TIMESTOP(t)   t ## T += myclock()
    #define TIMEFMT(t)	  ((DWORD)(t) / myclockrate()), (((DWORD)(t) * 1000 / myclockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#ifdef __cplusplus
}
#endif

#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\serial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       serial.c
 *  Content:	Routines for serial I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	added support for EnumConnectionData()
 *	6/25/96	kipo	updated for DPADDRESS
 *  7/13/96	kipo	added GetSerialAddress()
 *	7/16/96	kipo	changed address types to be GUIDs instead of 4CC
 *	8/21/96	kipo	move comport address into dplobby.h
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/17/97 kipo	deal with errors returned by DialogBoxParam()
 *  5/07/97 kipo	added support for modem choice list
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dplaysp.h"
#include "comport.h"
#include "resource.h"
#include "macros.h"

// constants

typedef enum {
	ASCII_XON = 0x11,
	ASCII_XOFF = 0x13
};

// serial object
typedef struct {
	DPCOMPORT			comPort;		// base object globals
	BOOL				bHaveSettings;	// set to TRUE after settings dialog has been displayed
	DPCOMPORTADDRESS	settings;		// settings to use
} DPSERIAL, *LPDPSERIAL;

// dialog choices for serial port settings

static DWORD	gComPorts[] =		{ 1, 2, 3, 4 };

static DWORD	gBaudRates[] =		{ CBR_110, CBR_300, CBR_600, CBR_1200, CBR_2400,
									  CBR_4800, CBR_9600, CBR_14400, CBR_19200, CBR_38400,
									  CBR_56000, CBR_57600, CBR_115200, CBR_128000, CBR_256000 };

static DWORD	gStopBits[] =		{ ONESTOPBIT, ONE5STOPBITS, TWOSTOPBITS };

static DWORD	gParities[] =		{ NOPARITY, EVENPARITY, ODDPARITY, MARKPARITY };

static DWORD	gFlowControls[] =	{ DPCPA_NOFLOW, DPCPA_XONXOFFFLOW, DPCPA_RTSFLOW, DPCPA_DTRFLOW, DPCPA_RTSDTRFLOW };

// globals

// this is defined in dllmain.c
extern HINSTANCE		ghInstance;

// this is defined in dpserial.c
extern GUID				DPSERIAL_GUID;

// prototypes

static HRESULT			DisposeSerial(LPDPCOMPORT baseObject);
static HRESULT			ConnectSerial(LPDPCOMPORT baseObject, BOOL bWaitForConnection, BOOL bReturnStatus);
static HRESULT			DisconnectSerial(LPDPCOMPORT baseObject);
static HRESULT			GetSerialAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
										 LPVOID lpAddress, LPDWORD lpdwAddressSize);
static HRESULT			GetSerialAddressChoices(LPDPCOMPORT baseObject,
									     LPVOID lpAddress, LPDWORD lpdwAddressSize);

static BOOL				SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings);
static BOOL FAR PASCAL	EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
										LPCVOID lpData, LPVOID lpContext);
static BOOL				GetSerialSettings(HINSTANCE hInstance, HWND hWndParent, LPDPSERIAL globals);
static UINT_PTR CALLBACK SettingsDialog(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
static void				InitDialog(HWND hDlg, LPDPCOMPORTADDRESS settings);
static void				GetSettingsFromDialog(HWND hDlg, LPDPCOMPORTADDRESS settings);
static int				ValueToIndex(LPDWORD buf, int bufLen, DWORD value);
static void				FillComboBox(HWND hDlg, int dlgItem, int startStr, int stopStr);

/*
 * NewSerial
 *
 * Create new serial port object.
 */
HRESULT NewSerial(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
				  LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				  LPDPCOMPORT *storage)
{
	LPDPCOMPORT baseObject;
	LPDPSERIAL	globals;
	HRESULT		hr;

	// create base object with enough space for our globals
	hr = NewComPort(sizeof(DPSERIAL), lpDPlay, lpReadRoutine, &baseObject);
	if FAILED(hr)
		return (hr);

	// fill in methods we implement
	baseObject->Dispose = DisposeSerial;
	baseObject->Connect = ConnectSerial;
	baseObject->Disconnect = DisconnectSerial;
	baseObject->GetAddress = GetSerialAddress;
	baseObject->GetAddressChoices = GetSerialAddressChoices;

	// setup default settings
	globals = (LPDPSERIAL) baseObject;
	globals->settings.dwComPort = 1;					// COM port to use (1-4)
	globals->settings.dwBaudRate = CBR_57600;			// baud rate (100-256k)
	globals->settings.dwStopBits = ONESTOPBIT;			// no. stop bits (1-2)
	globals->settings.dwParity = NOPARITY;				// parity (none, odd, even, mark)
	globals->settings.dwFlowControl = DPCPA_RTSDTRFLOW;	// flow control (none, xon/xoff, rts, dtr)

	// check for valid connection data
	if (lpConnectionData)
	{
		baseObject->lpDPlay->lpVtbl->EnumAddress(baseObject->lpDPlay, EnumAddressData, 
									lpConnectionData, dwConnectionDataSize,
									globals);
	}

	// return object pointer
	*storage = baseObject;

	return (DP_OK);
}

/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

static BOOL FAR PASCAL EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPDPSERIAL			globals = (LPDPSERIAL) lpContext;
	LPDPCOMPORTADDRESS	settings = (LPDPCOMPORTADDRESS) lpData;

	// this is a com port chunk
	if ( IsEqualGUID(lpguidDataType, &DPAID_ComPort) &&
		 (dwDataSize == sizeof(DPCOMPORTADDRESS)) )
	{
		// make sure it's valid!
		if ((ValueToIndex(gComPorts, sizeof(gComPorts), settings->dwComPort) >= 0) &&
			(ValueToIndex(gBaudRates, sizeof(gBaudRates), settings->dwBaudRate) >= 0) &&
			(ValueToIndex(gStopBits, sizeof(gStopBits), settings->dwStopBits) >= 0) &&
			(ValueToIndex(gParities, sizeof(gParities), settings->dwParity) >= 0) &&
			(ValueToIndex(gFlowControls, sizeof(gFlowControls), settings->dwFlowControl) >= 0))
		{
			globals->settings = *settings;		// copy the data
			globals->bHaveSettings = TRUE;		// we have valid settings
		}
	}

	return (TRUE);
}

/*
 * DisposeSerial
 *
 * Dispose serial port object.
 */

static HRESULT DisposeSerial(LPDPCOMPORT baseObject)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;

	// make sure we are disconnected
	DisconnectSerial(baseObject);

	// free object
	SP_MemFree((HGLOBAL) baseObject);

	return (DP_OK);
}

/*
 * ConnectSerial
 *
 * Open serial port and configure based on user settings.
 */

static HRESULT ConnectSerial(LPDPCOMPORT baseObject,
							 BOOL bWaitForConnection, BOOL bReturnStatus)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;
	HANDLE		hCom;
	TCHAR		portName[10];
	HRESULT		hr;

	// see if com port is already connected
	hCom = baseObject->GetHandle(baseObject);
	if (hCom)
		return (DP_OK);

	// ask user for settings if we have not already
	if (!globals->bHaveSettings)
	{
		if (!GetSerialSettings(ghInstance, GetForegroundWindow(), globals))
		{
			hr = DPERR_USERCANCEL;
			goto Failure;
		}

		globals->bHaveSettings = TRUE;
	}

	// open specified com port
	CopyMemory(portName, "COM0", 5);
	portName[3] += (BYTE) globals->settings.dwComPort;

	hCom = CreateFile(	portName,
						GENERIC_READ | GENERIC_WRITE,
						0,    /* comm devices must be opened w/exclusive-access */
						NULL, /* no security attrs */
						OPEN_EXISTING, /* comm devices must use OPEN_EXISTING */
						FILE_ATTRIBUTE_NORMAL | 
						FILE_FLAG_OVERLAPPED, // overlapped I/O
						NULL  /* hTemplate must be NULL for comm devices */
						);

	if (hCom == INVALID_HANDLE_VALUE)
	{
		hCom = NULL;
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Failure;
	}

	// configure com port to proper settings
	if (!SetupConnection(hCom, &globals->settings))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto Failure;
	}

	// setup com port
	hr = baseObject->Setup(baseObject, hCom);
	if FAILED(hr)
		goto Failure;

	return (DP_OK);

Failure:
	if (hCom)
		CloseHandle(hCom);

	return (hr);
}

/*
 * DisconnectSerial
 *
 * Close serial port.
 */

static HRESULT DisconnectSerial(LPDPCOMPORT baseObject)
{
	HANDLE		hCom;
	HRESULT		hr;

	hCom = baseObject->GetHandle(baseObject);

	// com port is already disconnected
	if (hCom == NULL)
		return (DP_OK);

	// shut down com port
	hr = baseObject->Shutdown(baseObject);

	// close com port
	CloseHandle(hCom);

	return (hr);
}

/*
 * SetupConnection
 *
 * Configure serial port with specified settings.
 */

static BOOL SetupConnection(HANDLE hCom, LPDPCOMPORTADDRESS portSettings)
{
	DCB		dcb;

	dcb.DCBlength = sizeof(DCB);
	if (!GetCommState(hCom, &dcb))
		return (FALSE);

	// setup various port settings

	dcb.fBinary = TRUE;
	dcb.BaudRate = portSettings->dwBaudRate;
	dcb.ByteSize = 8;
	dcb.StopBits = (BYTE) portSettings->dwStopBits;

	dcb.Parity = (BYTE) portSettings->dwParity;
	if (portSettings->dwParity == NOPARITY)
		dcb.fParity = FALSE;
	else
		dcb.fParity = TRUE;

	// setup hardware flow control

	if ((portSettings->dwFlowControl == DPCPA_DTRFLOW) ||
		(portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
	{
		dcb.fOutxDsrFlow = TRUE;
		dcb.fDtrControl = DTR_CONTROL_HANDSHAKE;
	}
	else
	{
		dcb.fOutxDsrFlow = FALSE;
		dcb.fDtrControl = DTR_CONTROL_ENABLE;
	}

	if ((portSettings->dwFlowControl == DPCPA_RTSFLOW) ||
		(portSettings->dwFlowControl == DPCPA_RTSDTRFLOW))
	{
		dcb.fOutxCtsFlow = TRUE;
		dcb.fRtsControl = RTS_CONTROL_HANDSHAKE;
	}
	else
	{
		dcb.fOutxCtsFlow = FALSE;
		dcb.fRtsControl = RTS_CONTROL_ENABLE;
	}

	// setup software flow control

	if (portSettings->dwFlowControl == DPCPA_XONXOFFFLOW)
	{
		dcb.fInX = TRUE;
		dcb.fOutX = TRUE;
	}
	else
	{
		dcb.fInX = FALSE;
		dcb.fOutX = FALSE;
	}

	dcb.XonChar = ASCII_XON;
	dcb.XoffChar = ASCII_XOFF;
	dcb.XonLim = 100;
	dcb.XoffLim = 100;

	if (!SetCommState( hCom, &dcb ))
	   return (FALSE);

	return (TRUE);
}

/*
 * GetSerialAddress
 *
 * Return current serial port info if available.
 */

static HRESULT GetSerialAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
								LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;
	HRESULT		hResult;

	// no settings yet
	if (!globals->bHaveSettings)
		return (DPERR_UNAVAILABLE);

	hResult = baseObject->lpDPlay->lpVtbl->CreateAddress(baseObject->lpDPlay,
						&DPSERIAL_GUID, &DPAID_ComPort,
						&globals->settings, sizeof(DPCOMPORTADDRESS),
						lpAddress, lpdwAddressSize);

	return (hResult);
}

/*
 * GetSerialAddressChoices
 *
 * Return current serial address choices
 */

static HRESULT GetSerialAddressChoices(LPDPCOMPORT baseObject,
									   LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPSERIAL	globals = (LPDPSERIAL) baseObject;

	// currently the serial provider does not support any choices
	return (E_NOTIMPL);
}

/*
 * GetComPortSettings
 *
 * Displays a dialog to gather and return the COM port settings.
 */

static BOOL GetSerialSettings(HINSTANCE hInstance, HWND hWndParent, LPDPSERIAL globals)
{
	INT_PTR	iResult;

    iResult = (INT_PTR)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SETTINGSDIALOG), hWndParent, SettingsDialog, (LPARAM) globals);
	return (iResult > 0);
}

/*
 * SettingsDialog
 *
 * The dialog callback routine to display and edit the COM port settings.
 */

static UINT_PTR CALLBACK SettingsDialog(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
	LPDPSERIAL			globals = (LPDPSERIAL) GetWindowLongPtr(hDlg, DWLP_USER);
	HWND				hWndCtl;
	BOOL				msgHandled = FALSE;
    
	switch (msg)
	{
	case WM_INITDIALOG:
		// serial info pointer passed in lParam
		globals = (LPDPSERIAL) lParam;

         // save the globals with the window
		SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) globals);

		hWndCtl = GetDlgItem(hDlg, IDC_COMPORT);

		// make sure our dialog item is there
		if (hWndCtl == NULL)
		{
			EndDialog(hDlg, FALSE);
			msgHandled = TRUE;
		}
		else
		{
			InitDialog(hDlg, &globals->settings);	// setup our dialog
			SetFocus(hWndCtl);				// focus on com port combo box
			msgHandled = FALSE;				// keep windows from setting input focus for us
		}
		break;

    case WM_COMMAND:

		if (HIWORD(wParam) == 0)
		{
			switch (LOWORD(wParam))
			{
			case IDOK:						// return settings
				GetSettingsFromDialog(hDlg, &globals->settings);
				EndDialog(hDlg, TRUE);
				msgHandled = TRUE;
 				break;

			case IDCANCEL:					// cancel
				EndDialog(hDlg, FALSE);
				msgHandled = TRUE;
 				break;
			}
		}
		break;
    }

    return (msgHandled);
}

/*
 * InitDialog
 *
 * Initialize the dialog controls to display the given COM port settings.
 */

static void InitDialog(HWND hDlg, LPDPCOMPORTADDRESS settings)
{
	// fill dialog combo boxes with items from string table
	FillComboBox(hDlg, IDC_COMPORT, IDS_COM1, IDS_COM4);
	FillComboBox(hDlg, IDC_BAUDRATE, IDS_BAUD1, IDS_BAUD15);
	FillComboBox(hDlg, IDC_STOPBITS, IDS_STOPBIT1, IDS_STOPBIT3);
	FillComboBox(hDlg, IDC_PARITY, IDS_PARITY1, IDS_PARITY4);
	FillComboBox(hDlg, IDC_FLOW, IDS_FLOW1, IDS_FLOW5);

	// select default values in combo boxes
	SendDlgItemMessage(hDlg, IDC_COMPORT, CB_SETCURSEL,
					   ValueToIndex(gComPorts, sizeof(gComPorts), settings->dwComPort), 0);
	SendDlgItemMessage(hDlg, IDC_BAUDRATE, CB_SETCURSEL,
					   ValueToIndex(gBaudRates, sizeof(gBaudRates), settings->dwBaudRate), 0);
	SendDlgItemMessage(hDlg, IDC_STOPBITS, CB_SETCURSEL,
					   ValueToIndex(gStopBits, sizeof(gStopBits), settings->dwStopBits), 0);
	SendDlgItemMessage(hDlg, IDC_PARITY, CB_SETCURSEL,
					   ValueToIndex(gParities, sizeof(gParities), settings->dwParity), 0);
	SendDlgItemMessage(hDlg, IDC_FLOW, CB_SETCURSEL,
					   ValueToIndex(gFlowControls, sizeof(gFlowControls), settings->dwFlowControl), 0);
}

/*
 * GetSettingsFromDialog
 *
 * Get the COM port settings from the dialog controls.
 */

static void GetSettingsFromDialog(HWND hDlg, LPDPCOMPORTADDRESS settings)
{
	INT_PTR		index;

	index = SendDlgItemMessage(hDlg, IDC_COMPORT, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwComPort = gComPorts[index];

	index = SendDlgItemMessage(hDlg, IDC_BAUDRATE, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwBaudRate = gBaudRates[index];

	index = SendDlgItemMessage(hDlg, IDC_STOPBITS, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwStopBits = gStopBits[index];

	index = SendDlgItemMessage(hDlg, IDC_PARITY, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwParity = gParities[index];

	index = SendDlgItemMessage(hDlg, IDC_FLOW, CB_GETCURSEL, 0, 0);
	if (index == CB_ERR)
		return;

	settings->dwFlowControl = gFlowControls[index];
}

/*
 * FillComboBox
 *
 * Add the specified strings to the combo box.
 */

#define MAXSTRINGSIZE	200

static void FillComboBox(HWND hDlg, int dlgItem, int startStr, int stopStr)
{
	int		i;
	TCHAR	str[MAXSTRINGSIZE];

	for (i = startStr; i <= stopStr; i++)
	{
		if (LoadString(ghInstance, i, str, MAXSTRINGSIZE))
			SendDlgItemMessage(hDlg, dlgItem, CB_ADDSTRING, (WPARAM) 0, (LPARAM) str);
	}
}

/*
 * ValueToIndex
 *
 * Convert a settings value to a combo box selection index.
 */

static int ValueToIndex(LPDWORD buf, int bufLen, DWORD value)
{
	int		i;

	bufLen /= sizeof(DWORD);
	for (i = 0; i < bufLen; i++)
		if (buf[i] == value)
			return (i);

	return (-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\sources.inc ===
MAJORCOMP=windows
MINORCOMP=GDI
UMTYPE=windows

TARGETNAME=dpmodemx
TARGETTYPE=DYNLINK

USE_MAPSYM=1

INCLUDES= \
	$(DXROOT)\inc; \
	 ..\..\..\misc; \
	 ..\; \
	 ..\..\dplay; \
	 ..\..\..\dplobby\dplobby; \
	 ..\..\common; \
	 $(BASEDIR)\public\sdk\inc\mfc42;

TARGETPATH=obj

PASS1_PUBLISH={ $(O)\dpmodemx.lib = $(SDK_LIB_PATH)\dpmodemx.lib }

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(BASEDIR)\public\sdk\lib\*\libc.lib    \
	   $(BASEDIR)\public\sdk\lib\*\user32.lib    \
	   $(BASEDIR)\public\sdk\lib\*\kernel32.lib  \
	   $(BASEDIR)\public\sdk\lib\*\tapi32.lib \
	   $(BASEDIR)\public\sdk\lib\*\winmm.lib \
	   ..\..\dplay\$(PLAT_DIR)\obj$(BUILD_ALT_DIR)\*\dplayx.lib

DLLENTRY=DllMain

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

C_DEFINES=$(C_DEFINES) -DUSE_CRITSECTS -DWIN16_SEPARATE -DNEW_DPF

LINKER_FLAGS=-SECTION:share,RWS

#LINKLIBS= \

SOURCES= \
	..\dllmain.c \
	..\dpserial.c \
	..\comport.c \
	..\serial.c \
	..\modem.c \
	..\dial.c \
	..\bilink.c \
	..\dpserial.rc \
	memalloc.c \
	newdpf.c \
	dputils.c


DLLDEF=..\dpserial.def

NTTARGETFILE0=MISC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\dpserial.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpserial.c
 *  Content:	Implementation of serial port service provider
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *	4/10/96	kipo	created it
 *	4/12/96 kipo	updated for new interfaces
 *	4/15/96 kipo	added msinternal
 *	5/22/96	kipo	updated for new interfaces
 *	6/10/96	kipo	updated for new interfaces
 *	6/10/96	kipo	added modem support
 *	6/18/96 kipo	use guid to choose serial/modem connection
 *	6/20/96 kipo	updated for new interfaces
 *	6/21/96 kipo	Bug #2078. Changed modem service provider GUID so it's not the
 *					same as the DPlay 1.0 GUID, so games that are checking won't
 *					put up their loopy modem-specific UI.
 *	6/21/96	kipo	updated for latest interfaces; return error if message size is too big.
 *	6/22/96	kipo	updated for latest interfaces; use connection data; return version
 *	6/23/96	kipo	updated for latest service provider interfaces.
 *	6/24/96	kipo	divide baud rate by 100 to conform to DPlay 1.0 usage.
 *	6/25/96	kipo	added WINAPI prototypes and updated for DPADDRESS
 *  7/13/96	kipo	added support for GetAddress() method.
 *  7/13/96	kipo	don't print as many errors for invalid messages.
 *  8/10/96	kipo	return DPERR_SESSIONLOST on write failures
 *	8/13/96 kipo	added CRC
 *	8/21/96 kipo	return a value for dwHeaderLength in caps 
 *	9/07/96	kip		changed latency and timeout values
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/11/97 kipo	SPInit was needlessly clearing the dwFlags field of the
 *					callback table.
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/04/97 kipo	updated debug output; make sure we linke with dplayx.dll
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  5/15/98 a-peterz When Write fails, return DPERR_NOCONNECTION (#23745)
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 ***************************************************************************/

#define INITGUID
#include <windows.h>
#include <windowsx.h>

#include <objbase.h>
#include <initguid.h>

#include "dpf.h"
#include "dplaysp.h"
#include "comport.h"
#include "macros.h"

// macros

#ifdef DEBUG
	#define DPF_ERRVAL(a, b)  DPF( 0, DPF_MODNAME ": " a, b );
#else
	#define DPF_ERRVAL(a, b)
#endif

// constants

#define SPMINORVERSION      0x0000				// service provider-specific version number
#define VERSIONNUMBER		(DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

#define MESSAGETOKEN		0x2BAD				// token to signify start of message
#define MESSAGEHEADERLEN	sizeof(MESSAGEHEADER) // size of message header
#define MESSAGEMAXSIZEINT	0x0000FFFF			// maximum size of an internal message
#define MESSAGEMAXSIZEEXT	(MESSAGEMAXSIZEINT - MESSAGEHEADERLEN)	// maximum size of an external message

typedef enum {
	NEWMESSAGESTATE = 0,						// start reading a new message
	READHEADERSTATE,							// read the message header
	READDATASTATE,								// read the message data
	SKIPDATASTATE								// skip the message data
} MESSAGESTATE;

// structures

// message header
typedef struct {
	WORD	wToken;								// message token
	WORD	wMessageSize;						// length of message
	WORD	wMessageCRC;						// CRC checksum value for message body
	WORD	wHeaderCRC;							// CRC checksum value for header
} MESSAGEHEADER, *LPMESSAGEHEADER;

// service provider context
typedef struct {
	LPDPCOMPORT		lpComPort;					// pointer to com port data structure
	MESSAGESTATE	msReadState;				// current read state
	BYTE			lpReadHeader[MESSAGEHEADERLEN];	// buffer for message header
	LPBYTE			lpReadBuffer;				// buffer for message data
	DWORD			dwReadBufferSize;			// size of message buffer in bytes
	DWORD			dwReadCount;				// no. bytes read into message buffer
	DWORD			dwReadTotal;				// no. total bytes to read into message buffer
	DWORD			dwSkipCount;				// no. bytes skipped to find message header
	LPDIRECTPLAYSP	lpDPlay;					// pointer to IDirectPlaySP needed to call back into DPlay
} SPCONTEXT, *LPSPCONTEXT;

// {0F1D6860-88D9-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPSERIAL_GUID,						// GUID for serial service provider
0xf1d6860, 0x88d9, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

// {44EAA760-CB68-11cf-9C4E-00A0C905425E}
DEFINE_GUID(DPMODEM_GUID,						// GUID for modem service provider
0x44eaa760, 0xcb68, 0x11cf, 0x9c, 0x4e, 0x0, 0xa0, 0xc9, 0x5, 0x42, 0x5e);

CRITICAL_SECTION csMem;

/*
 * GetSPContext
 *
 * Get service provider context from DirectPlay.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"GetSPContext"

LPSPCONTEXT GetSPContext(LPDIRECTPLAYSP lpDPlay)
{
	LPSPCONTEXT	lpContext = NULL;
	DWORD		dwContextSize = 0;
	HRESULT		hr;

	// no dplay interface?
	if (lpDPlay == NULL)
	{
		DPF_ERR("DPlaySP interface is NULL!");
		goto FAILURE;
	}

	// get pointer to context from DPlay
	hr = lpDPlay->lpVtbl->GetSPData(lpDPlay, &lpContext, &dwContextSize, DPGET_LOCAL);
	if FAILED(hr)
	{
		DPF_ERRVAL("could not get context: 0x%08X", hr);
		goto FAILURE;
	}

	// make sure size is correct
	if (dwContextSize != sizeof(SPCONTEXT))
	{
		DPF_ERR("invalid context size!");
		goto FAILURE;
	}

	return (lpContext);

FAILURE:
	return (NULL);
}

/*
 * SetupMessageHeader
 *
 * Initialize the service provider-specific header put
 * in front of every message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupMessageHeader"

HRESULT SetupMessageHeader(LPVOID pvMessage, DWORD dwMessageSize)
{
	LPMESSAGEHEADER	pMessageHeader = (LPMESSAGEHEADER) pvMessage;

	// make sure message will fit in header
	if (dwMessageSize > MESSAGEMAXSIZEINT)
		return (DPERR_SENDTOOBIG);

	// set message header
	pMessageHeader->wToken = (WORD) MESSAGETOKEN;

	// set message size
	pMessageHeader->wMessageSize = (WORD) dwMessageSize;

	// generate CRC for message body
	pMessageHeader->wMessageCRC = (WORD) GenerateCRC(((LPBYTE) pvMessage) + MESSAGEHEADERLEN,
										dwMessageSize - MESSAGEHEADERLEN);

	// generate CRC for message header
	pMessageHeader->wHeaderCRC = (WORD) GenerateCRC(pvMessage, MESSAGEHEADERLEN - sizeof(pMessageHeader->wHeaderCRC));

	return (DP_OK);
}

/*
 * GetMessageLength
 *
 * Check for valid message header and return length of message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"GetMessageLength"

DWORD GetMessageLength(LPBYTE header)
{
	LPMESSAGEHEADER	pMessageHeader = (LPMESSAGEHEADER) header;
	DWORD			byteCount;

	// check for token we put in front of every message
	if (pMessageHeader->wToken != MESSAGETOKEN)
		goto FAILURE;

	// check CRC for message header
	if (pMessageHeader->wHeaderCRC != (WORD) GenerateCRC(header, MESSAGEHEADERLEN - sizeof(pMessageHeader->wHeaderCRC)))
		goto FAILURE;

	// get length of message
	byteCount = pMessageHeader->wMessageSize;
	if (byteCount <= MESSAGEHEADERLEN)
	{
		DPF_ERRVAL("bad message size: %d", byteCount);
		goto FAILURE;
	}

	return (byteCount);

FAILURE:
	return (0);
}

/*
 * SetupToReadMessage
 *
 * Create/resize buffer to fit length of message and initialize header.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SetupToReadMessage"

BOOL SetupToReadMessage(LPSPCONTEXT lpContext)
{
	// no buffer, so create one
	if (lpContext->lpReadBuffer == NULL)
	{
		lpContext->lpReadBuffer = SP_MemAlloc(lpContext->dwReadTotal);
		if (lpContext->lpReadBuffer == NULL)
		{
			DPF_ERRVAL("could not create message buffer: %d", GetLastError());
			goto FAILURE;
		}
		lpContext->dwReadBufferSize = lpContext->dwReadTotal;
	}

	// existing buffer not big enough, so resize
	else if (lpContext->dwReadBufferSize < lpContext->dwReadTotal)
	{
		HANDLE	h;
		h = SP_MemReAlloc(lpContext->lpReadBuffer, lpContext->dwReadTotal);
		if (h == NULL)
		{
			DPF_ERRVAL("could not reallocate message buffer: %d", GetLastError());
			goto FAILURE;
		}
		lpContext->lpReadBuffer = h;
		lpContext->dwReadBufferSize = lpContext->dwReadTotal;
	}

	// copy message header to buffer
	CopyMemory(lpContext->lpReadBuffer, lpContext->lpReadHeader, lpContext->dwReadCount);

	return (TRUE);

FAILURE:
	return (FALSE);
}

/*
 * ReadRoutine
 *
 * Read bytes from COM port using a state machine to assemble a message.
 * When message is assembled, call back to DirectPlay to deliver it.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"ReadRoutine"

void ReadRoutine(LPDIRECTPLAYSP	lpDPlay)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	    
	// get service provider context
	lpContext = GetSPContext(lpDPlay);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		return;
	}

	while (1)
	{
		switch (lpContext->msReadState)
		{
		// start reading a new message
		case NEWMESSAGESTATE:
			lpContext->dwReadCount = 0;
			lpContext->dwReadTotal = MESSAGEHEADERLEN;
			lpContext->msReadState = READHEADERSTATE;
			lpContext->dwSkipCount = 0;
			break;

		// read message header
		case READHEADERSTATE:
			byteCount = lpContext->lpComPort->Read(lpContext->lpComPort,
									&lpContext->lpReadHeader[lpContext->dwReadCount],
									lpContext->dwReadTotal - lpContext->dwReadCount);
			if (byteCount == 0)
				return;

			lpContext->dwReadCount += byteCount;
			if (lpContext->dwReadCount == lpContext->dwReadTotal) // got enough for a header
			{
				lpContext->dwReadTotal = GetMessageLength(lpContext->lpReadHeader);	// see if it's real
				if (lpContext->dwReadTotal)
				{
					if (lpContext->dwSkipCount)
						DPF_ERRVAL("%d bytes skipped", lpContext->dwSkipCount);

					if (SetupToReadMessage(lpContext))	// prepare to read message
						lpContext->msReadState = READDATASTATE;
					else
						lpContext->msReadState = SKIPDATASTATE;
				}
				else									// bad message header - reset
				{
					DWORD	i;

					if (lpContext->dwSkipCount == 0)
						DPF_ERR("invalid message header - skipping bytes");		

					lpContext->dwReadCount = MESSAGEHEADERLEN - 1; // throw away first byte and try again
					lpContext->dwReadTotal = MESSAGEHEADERLEN;
					lpContext->dwSkipCount += 1;

					for (i = 0; i < lpContext->dwReadCount; i++)	// shuffle down one byte
						lpContext->lpReadHeader[i] = lpContext->lpReadHeader[i + 1];
				}
			}
			break;

		// read message data
		case READDATASTATE:
			byteCount = lpContext->lpComPort->Read(lpContext->lpComPort,
									&lpContext->lpReadBuffer[lpContext->dwReadCount],
									lpContext->dwReadTotal - lpContext->dwReadCount);
			if (byteCount == 0)
				return;

			lpContext->dwReadCount += byteCount;
			if (lpContext->dwReadCount == lpContext->dwReadTotal)	// have read entire message
			{
				LPMESSAGEHEADER		pMessageHeader;

				// check for CRC errors
				pMessageHeader = (LPMESSAGEHEADER) lpContext->lpReadBuffer;
				if (pMessageHeader->wMessageCRC != (WORD) GenerateCRC(lpContext->lpReadBuffer + MESSAGEHEADERLEN, lpContext->dwReadTotal - MESSAGEHEADERLEN))
				{
					DPF_ERR("Message dropped - CRC did not match!");
				}
				else
				{
					DPF(5, "%d byte message received", lpContext->dwReadTotal);

					// deliver message to DirectPlay
					lpContext->lpDPlay->lpVtbl->HandleMessage(lpContext->lpDPlay,		// DirectPlay instance
										  lpContext->lpReadBuffer + MESSAGEHEADERLEN,	// pointer to message data
										  lpContext->dwReadTotal - MESSAGEHEADERLEN,	// length of message data
										  NULL);										// pointer to header (unused here)
				}
				lpContext->msReadState = NEWMESSAGESTATE;		// go read next message
			}
			break;

		// skip message data
		case SKIPDATASTATE:
			DPF_ERR("Skipping data!");
			while (lpContext->lpComPort->Read(lpContext->lpComPort, &lpContext->lpReadHeader[0], 1))	// spin until entire message discarded
			{
				lpContext->dwReadCount += 1;
				if (lpContext->dwReadCount == lpContext->dwReadTotal)
				{
					lpContext->msReadState = NEWMESSAGESTATE;
					break;
				}
			}
			break;

		default:
			DPF_ERRVAL("bad read state: %d", lpContext->msReadState);
			break;
		}
	}
}

/*
 * SP_EnumSessions
 *
 * Broadcast a message to the network.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_EnumSessions"

HRESULT WINAPI SP_EnumSessions(LPDPSP_ENUMSESSIONSDATA ped) 
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering SP_EnumSessions");
    
	// get service provider context
	lpContext = GetSPContext(ped->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make connection
	hr = lpContext->lpComPort->Connect(lpContext->lpComPort, FALSE, ped->bReturnStatus);
	if FAILED(hr)
	{
		if (hr != DPERR_CONNECTING)
			DPF_ERRVAL("error making connection: 0x%08X", hr);
		goto FAILURE;
	}

	// see if connection has been lost
   	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}

	// setup the message
	hr = SetupMessageHeader(ped->lpMessage, ped->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, ped->lpMessage, ped->dwMessageSize, TRUE);
	if (byteCount != ped->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", ped->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte enum sessions message sent", byteCount);

	return (DP_OK);

FAILURE:
	return (hr);

} // EnumSessions

/*
 * SP_Send
 *
 * Send a message to a particular player or group.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Send"

HRESULT WINAPI SP_Send(LPDPSP_SENDDATA psd)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering SP_Send");

	// get service provider context
	lpContext = GetSPContext(psd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// see if connection has been lost
   	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}

	// setup the message
	hr = SetupMessageHeader(psd->lpMessage, psd->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, psd->lpMessage, psd->dwMessageSize, TRUE);
	if (byteCount != psd->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", psd->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte message sent", byteCount);

    return (DP_OK);

FAILURE:
	return (hr);

} // Send

/*
 * SP_Reply
 *
 * Send a reply to a message.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Reply"

HRESULT WINAPI SP_Reply(LPDPSP_REPLYDATA prd)
{
	LPSPCONTEXT	lpContext;
	DWORD		byteCount;
	HRESULT		hr;

	DPF(5,"entering Reply");
    
	// get service provider context
	lpContext = GetSPContext(prd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// see if connection has been lost
	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort) == NULL)
	{
		DPF_ERR("connection lost!");
		hr = DPERR_SESSIONLOST;
		goto FAILURE;
	}
	
	// setup the message
	hr = SetupMessageHeader(prd->lpMessage, prd->dwMessageSize);
	if FAILED(hr)
	{
		DPF_ERR("message too large!");
		goto FAILURE;
	}

	// send message
	byteCount = lpContext->lpComPort->Write(lpContext->lpComPort, prd->lpMessage, prd->dwMessageSize, TRUE);
	if (byteCount != prd->dwMessageSize)
	{
		DPF(0, "error writing message: %d requested, %d actual", prd->dwMessageSize, byteCount);
		hr = DPERR_CONNECTIONLOST;
		goto FAILURE;
	}

	DPF(5, "%d byte reply message sent", byteCount);

    return (DP_OK);

FAILURE:
	return (hr);

} // Reply

/*
 * SP_Open
 *
 * Open the service provider.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Open"

HRESULT WINAPI SP_Open(LPDPSP_OPENDATA pod) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;

	DPF(5,"entering Open");
    
	// get service provider context
	lpContext = GetSPContext(pod->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make connection
	hr = lpContext->lpComPort->Connect(lpContext->lpComPort, pod->bCreate, pod->bReturnStatus);
	if FAILED(hr)
	{
		DPF_ERRVAL("error making connection: 0x%08X", hr);
		goto FAILURE;
	}

	return (DP_OK);

FAILURE:
	return (hr);

} // Open

/*
 * SP_GetCaps
 *
 * Return capabilities of service provider.
 *
 * Only the fields that matter to this service provider have
 * to be set here, since all the fields are preset to
 * default values.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetCaps"

HRESULT WINAPI SP_GetCaps(LPDPSP_GETCAPSDATA pcd) 
{
	LPSPCONTEXT	lpContext;
	LPDPCAPS	lpCaps;
	HRESULT		hr;
    
	DPF(5,"entering GetCaps");

	// get service provider context
	lpContext = GetSPContext(pcd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	// make sure caps buffer is large enough
	lpCaps = pcd->lpCaps;
	if (lpCaps->dwSize < sizeof(DPCAPS))
	{
		DPF_ERR("caps buffer too small");
		hr = DPERR_BUFFERTOOSMALL;
		goto FAILURE;
	}

	// don't zero out caps as DPlay has pre-initialized some default caps for us
	lpCaps->dwSize = sizeof(DPCAPS);
	lpCaps->dwMaxBufferSize = MESSAGEMAXSIZEEXT;	// return maximum external message size
	lpCaps->dwHeaderLength = MESSAGEHEADERLEN;		// return size of message header
	lpCaps->dwFlags = 0;							// have DPlay do the keep-alives
	lpCaps->dwLatency = 250;						// todo - base these on baud rate ACK!!!
	lpCaps->dwTimeout = 2500; 
	
	// if we have connected we can get the baud rate
	if (lpContext->lpComPort->GetHandle(lpContext->lpComPort))
	{
		DWORD	dwBaudRate;

		// try to get baud rate
		hr = lpContext->lpComPort->GetBaudRate(lpContext->lpComPort, &dwBaudRate);
		if SUCCEEDED(hr)
		{
			lpCaps->dwHundredBaud = dwBaudRate / 100;	// return baud rate in hundreds of baud
		}
	}

	return (DP_OK);

FAILURE:
	return (hr);

} // GetCaps

/*
 * SP_GetAddress
 *
 * Return network address of a given player.
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddress"

HRESULT WINAPI SP_GetAddress(LPDPSP_GETADDRESSDATA pga) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;
    
	DPF(5,"entering GetAddress");

	// get service provider context
	lpContext = GetSPContext(pga->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	hr = lpContext->lpComPort->GetAddress(lpContext->lpComPort, pga->dwFlags, pga->lpAddress, pga->lpdwAddressSize);

FAILURE:
	return (hr);

} // GetAddress

/*
 * SP_GetAddressChoices
 *
 * Return address choices for this service provider
 *
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_GetAddressChoices"

HRESULT WINAPI SP_GetAddressChoices(LPDPSP_GETADDRESSCHOICESDATA pga) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;
    
	DPF(5,"entering GetAddressChoices");

	// get service provider context
	lpContext = GetSPContext(pga->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	hr = lpContext->lpComPort->GetAddressChoices(lpContext->lpComPort, pga->lpAddress, pga->lpdwAddressSize);

FAILURE:
	return (hr);

} // GetAddressChoices

/*
 * SP_Shutdown
 *
 * Turn off all I/O on service provider and release all allocated
 * memory and resources.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SP_Shutdown"

HRESULT WINAPI SP_ShutdownEx(LPDPSP_SHUTDOWNDATA psd) 
{
	LPSPCONTEXT	lpContext;
	HRESULT		hr;

	DPF(5,"entering Shutdown");
    
	// get service provider context
	lpContext = GetSPContext(psd->lpISP);
	if (lpContext == NULL)
	{
		DPF_ERR("invalid context!");
		hr = DPERR_NOINTERFACE;
		goto FAILURE;
	}

	if (lpContext->lpComPort)
	{
		lpContext->lpComPort->Dispose(lpContext->lpComPort);
		lpContext->lpComPort = NULL;
	}

	if (lpContext->lpReadBuffer)
	{
		SP_MemFree(lpContext->lpReadBuffer);
		lpContext->lpReadBuffer = NULL;
	}

	lpContext->lpDPlay = NULL;

	// OK to release DPLAYX.DLL
	gdwDPlaySPRefCount++;

    return (DP_OK);

FAILURE:
	return (hr);

} // Shutdown

/*
 * SPInit
 *
 * This is the main entry point for the service provider. This should be
 * the only entry point exported from the DLL.
 *
 * Allocate any needed resources and return the supported callbacks.
 */

#undef DPF_MODNAME
#define DPF_MODNAME	"SPInit"

HRESULT WINAPI SPInit(LPSPINITDATA pid) 
{
	SPCONTEXT			context;
	LPSPCONTEXT			lpContext;
	LPDPSP_SPCALLBACKS	lpcbTable;
	HRESULT				hr;

	DPF(5,"entering SPInit");

	// check to make sure table is big enough
	lpcbTable = pid->lpCB;
	if (lpcbTable->dwSize < sizeof(DPSP_SPCALLBACKS))		// table not big enough
	{
		DPF_ERR("callback table too small");
		hr = DPERR_BUFFERTOOSMALL;
		goto FAILURE;
	}

	// initialize context
	ZeroMemory(&context, sizeof(SPCONTEXT));
	lpContext = &context;
	lpContext->msReadState = NEWMESSAGESTATE;
	lpContext->lpDPlay = pid->lpISP;					// save pointer to IDPlaySP so we can pass it back later

	// check for correct GUID
	if (IsEqualGUID(pid->lpGuid, &DPSERIAL_GUID))
	{
		hr = NewSerial(pid->lpAddress, pid->dwAddressSize,
					   lpContext->lpDPlay, ReadRoutine,
					   &lpContext->lpComPort);
	}
	else if (IsEqualGUID(pid->lpGuid, &DPMODEM_GUID))
	{
		hr = NewModem(pid->lpAddress, pid->dwAddressSize,
					  lpContext->lpDPlay, ReadRoutine,
					  &lpContext->lpComPort);
	}
	else
	{
		DPF_ERR("unknown service provider GUID");
		hr = DPERR_INVALIDPARAM;
	}

	if FAILED(hr)
	{
		DPF_ERRVAL("error opening com port: 0x%08X", hr);
		goto FAILURE;
	}

	// return size of header we need on every message so
	// DirectPlay will leave room for it.
 	pid->dwSPHeaderSize = MESSAGEHEADERLEN;

	// return version number so DirectPlay will treat us with respect
	pid->dwSPVersion = VERSIONNUMBER;

	// set up callbacks
    lpcbTable->dwSize = sizeof(DPSP_SPCALLBACKS);			// MUST set the return size of the table
    lpcbTable->Send = SP_Send;
    lpcbTable->EnumSessions = SP_EnumSessions;
    lpcbTable->Reply = SP_Reply;
	lpcbTable->GetCaps = SP_GetCaps;
	lpcbTable->GetAddress = SP_GetAddress;
	lpcbTable->GetAddressChoices = SP_GetAddressChoices;
    lpcbTable->Open = SP_Open;
	lpcbTable->ShutdownEx = SP_ShutdownEx;

	// save context with DPlay so we can get it later
	hr = lpContext->lpDPlay->lpVtbl->SetSPData(lpContext->lpDPlay, lpContext, sizeof(SPCONTEXT), DPSET_LOCAL);
	if FAILED(hr)
	{
		DPF_ERRVAL("could not store context: 0x%08X", hr);
		goto FAILURE;
	}

	// make sure DPLAYX.DLL sticks around
	gdwDPlaySPRefCount++;

	return (DP_OK);

FAILURE:
	return (hr);

} // SPInit
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\modem.c ===
/*==========================================================================
 *
 *  Copyright (C) 1996-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       modem.c
 *  Content:	Routines for modem I/O
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  6/10/96	kipo	created it
 *  6/22/96	kipo	added support for EnumConnectionData(); dim "OK" button
 *					until user types at least one character.
 *	6/25/96	kipo	updated for DPADDRESS
 *	7/08/96 kipo	added support for new dialogs
 *  7/13/96	kipo	added GetModemAddress()
 *	7/16/96	kipo	changed address types to be GUIDs instead of 4CC
 *	8/10/96 kipo	added support for dialing location
 *	8/15/96 kipo	commented out support for dialing location
 *  9/04/96 dereks  fixed focus in dial/answer dialogs
 *  1/06/97 kipo	updated for objects
 *  2/11/97 kipo	pass player flags to GetAddress()
 *  2/18/97 kipo	allow multiple instances of service provider
 *	3/04/97 kipo	close com port handle when deallocating call; use string
 *					table for modem strings; updated debug output.
 *	3/17/97 kipo	added support for Unicode phone numbers
 *	3/24/97 kipo	added support for specifying which modem to use
 *  4/08/97 kipo	added support for separate modem and serial baud rates
 *  5/07/97 kipo	added support for modem choice list
 *  5/23/97 kipo	added support return status codes
 *  5/25/97 kipo	use DPERR_CONNECTING error to return status; set focus
 *					on cancel button in status window
 *  6/03/97 kipo	really make the cancel button work with return
 *  2/01/98 kipo	Display an error string in status dialog if line goes
 *					idle while dialing. Fixes bug #15251
 *  5/08/98 a-peterz #15251 - Better error state detection
 * 10/13/99	johnkan	#413516 - Mismatch between modem dialog selection and TAPI device ID
 * 12/22/00 aarono   #190380 - use process heap for memory allocation
 ***************************************************************************/

#include <windows.h>
#include <windowsx.h>

#include "dplaysp.h"
#include "dputils.h"
#include "dial.h"
#include "dpf.h"
#include "resource.h"
#include "macros.h"

// constants

enum {
	PHONENUMBERSIZE = 200,				// size of phone number string
	MODEMNAMESIZE = 200,				// size of modem name string
	TEMPSTRINGSIZE = 300,				// size of temporary strings
	MODEMTIMEOUT = 30 * 1000,			// milliseconds to wait for phone to connect
	MODEMSLEEPTIME = 50,				// milliseconds to sleep while waiting for modem
	TIMERINTERVAL = 100,
	MAXPHONENUMBERS = 10
};

// bit masks used to select connection actions
enum {
	DIALCALL		= (0 << 0),			// make a call
	ANSWERCALL		= (1 << 0),			// answer a call

	NOSETTINGS		= (0 << 1),			// no phone settings are set
	HAVESETTINGS	= (1 << 1),			// phone settings are set

	STATUSDIALOG	= (0 << 2),			// show a connection status dialog
	RETURNSTATUS	= (1 << 2)			// return status to app
};

#define MRU_SP_KEY			L"Modem Connection For DirectPlay"
#define MRU_NUMBER_KEY		L"Phone Number"

// structures

// modem object
typedef struct {
	DPCOMPORT	comPort;				// base object globals
	LPDPDIAL	lpDial;					// dialing globals
	BOOL		bHaveSettings;			// set to TRUE if we have settings
	BOOL		bAnswering;				// set to TRUE if we are answering
	DWORD		dwDeviceID;				// device id to use
	DWORD		dwLocation;				// location to use
	TCHAR		szPhoneNumber[PHONENUMBERSIZE];	// phone number to use
} DPMODEM, *LPDPMODEM;

// globals

// this is defined in dllmain.c
extern HINSTANCE		ghInstance;

// this is defined in dpserial.c
extern GUID				DPMODEM_GUID;

// prototypes

static HRESULT			DisposeModem(LPDPCOMPORT baseObject);
static HRESULT			ConnectModem(LPDPCOMPORT baseObject, BOOL bWaitForConnection, BOOL bReturnStatus);
static HRESULT			DisconnectModem(LPDPCOMPORT baseObject);
static HRESULT			GetModemBaudRate(LPDPCOMPORT baseObject, LPDWORD lpdwBaudRate);
static HRESULT			GetModemAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
										LPVOID lpAddress, LPDWORD lpdwAddressSize);

static BOOL FAR PASCAL	EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
										LPCVOID lpData, LPVOID lpContext);
static HRESULT			GetModemAddressChoices(LPDPCOMPORT baseObject,
								LPVOID lpAddress, LPDWORD lpdwAddressSize);
static BOOL FAR PASCAL	EnumMRUPhoneNumbers(LPCVOID lpData, DWORD dwDataSize, LPVOID lpContext);
static void				UpdateButtons(HWND hWnd);

BOOL					DoDialSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoDial(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoAnswerSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
BOOL					DoAnswer(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals);
HRESULT					DoDialStatus(LPDPMODEM globals);
HRESULT					DoAnswerStatus(LPDPMODEM globals);

/*
 * NewModem
 *
 * Create new modem object. Open TAPI and verify there are lines available.
 */

HRESULT NewModem(LPVOID lpConnectionData, DWORD dwConnectionDataSize,
				 LPDIRECTPLAYSP lpDPlay, LPREADROUTINE lpReadRoutine,
				 LPDPCOMPORT *storage)
{
	LPDPCOMPORT baseObject;
	LPDPMODEM	globals;
	LINERESULT	lResult;
	HRESULT		hr;

	// create base object with enough space for our globals
	hr = NewComPort(sizeof(DPMODEM), lpDPlay, lpReadRoutine, &baseObject);
	if FAILED(hr)
		return (hr);

	// fill in methods we implement
	baseObject->Dispose = DisposeModem;
	baseObject->Connect = ConnectModem;
	baseObject->Disconnect = DisconnectModem;
	baseObject->GetBaudRate = GetModemBaudRate;
	baseObject->GetAddress = GetModemAddress;
	baseObject->GetAddressChoices = GetModemAddressChoices;

	globals = (LPDPMODEM) baseObject;

	// initialize TAPI
	lResult = dialInitialize(ghInstance, TEXT("TapiSP"), (LPDPCOMPORT) globals, &globals->lpDial);
	if (lResult)
	{
		hr = DPERR_UNAVAILABLE;
		goto Failure;
	}

	// check for valid connection data
	if (lpConnectionData)
	{
		baseObject->lpDPlay->lpVtbl->EnumAddress(baseObject->lpDPlay, EnumAddressData,
									lpConnectionData, dwConnectionDataSize,
									globals);
	}

	// return object pointer
	*storage = baseObject;

	return (DP_OK);

Failure:
	DisposeModem(baseObject);

	return (hr);
}

/*
 * EnumConnectionData
 *
 * Search for valid connection data
 */

static BOOL FAR PASCAL EnumAddressData(REFGUID lpguidDataType, DWORD dwDataSize,
							LPCVOID lpData, LPVOID lpContext)
{
	LPDPMODEM	globals = (LPDPMODEM) lpContext;
	CHAR		szModemName[MODEMNAMESIZE];

	// this is an ANSI phone number
	if ((IsEqualGUID(lpguidDataType, &DPAID_Phone)) &&
		(dwDataSize) )
	{
		// make sure there is room (for terminating null too)
		if (dwDataSize > (PHONENUMBERSIZE - 1))
			dwDataSize = (PHONENUMBERSIZE - 1);
		CopyMemory(globals->szPhoneNumber, lpData, dwDataSize);

		globals->bHaveSettings = TRUE;		// we have a phone number
	}

	// this is an UNICODE phone number
	else if ((IsEqualGUID(lpguidDataType, &DPAID_PhoneW)) &&
			 (dwDataSize) )
	{
		if (WideToAnsi(globals->szPhoneNumber, (LPWSTR) lpData, PHONENUMBERSIZE))
			globals->bHaveSettings = TRUE;	// we have a phone number
	}

	// this is an ANSI modem name
	else if ((IsEqualGUID(lpguidDataType, &DPAID_Modem)) &&
			 (dwDataSize) )
	{
		// search modem list for this name
		if (dialGetDeviceIDFromName(globals->lpDial, lpData, &globals->dwDeviceID) == SUCCESS)
			globals->bHaveSettings = TRUE;	// can answer the phone
	}

	// this is a UNICODE modem name
	else if ((IsEqualGUID(lpguidDataType, &DPAID_ModemW)) &&
			 (dwDataSize) )
	{
		// search modem list for this name
		if (WideToAnsi(szModemName, (LPWSTR) lpData, MODEMNAMESIZE))
		{
			if (dialGetDeviceIDFromName(globals->lpDial, szModemName, &globals->dwDeviceID) == SUCCESS)
				globals->bHaveSettings = TRUE;	// we have a phone number
		}
	}

	return (TRUE);
}

/*
 * DisposeModem
 *
 * Dispose modem object.
 */

static HRESULT DisposeModem(LPDPCOMPORT baseObject)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	LINERESULT	lResult;

	// shut down modem
	if (lpDial)
		lResult = dialShutdown(lpDial);

	// free object
	SP_MemFree((HGLOBAL) baseObject);

	return (DP_OK);
}

/*
 * ConnectModem
 *
 * Dial number based on user settings.
 */

static HRESULT ConnectModem(LPDPCOMPORT baseObject,
							BOOL bWaitForConnection, BOOL bReturnStatus)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	DWORD		dwFeatures;
	BOOL		bResult;
	HRESULT		hr;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_INVALIDPARAM);

	// are we already connected?
	if (dialIsConnected(lpDial))
		return (DP_OK);

	// remember if we are answering or not
	globals->bAnswering = bWaitForConnection;

	dwFeatures = 0;

	if (globals->bAnswering)
		dwFeatures |= ANSWERCALL;

	if (globals->bHaveSettings)
		dwFeatures |= HAVESETTINGS;

	if (bReturnStatus)
		dwFeatures |= RETURNSTATUS;

	hr = DP_OK;

	switch (dwFeatures)
	{
		case (STATUSDIALOG | NOSETTINGS   | DIALCALL):

			bResult = DoDialSetup(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;

			globals->bHaveSettings = TRUE;
			break;

		case (STATUSDIALOG | NOSETTINGS   | ANSWERCALL):

			bResult = DoAnswerSetup(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;

			globals->bHaveSettings = TRUE;
			break;

		case (STATUSDIALOG | HAVESETTINGS | DIALCALL):

			bResult = DoDial(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;
			break;

		case (STATUSDIALOG | HAVESETTINGS | ANSWERCALL):

			bResult = DoAnswer(ghInstance, GetForegroundWindow(), globals);
			if (!bResult)
				goto FAILURE;
			break;

		case (RETURNSTATUS   | NOSETTINGS   | DIALCALL):
		case (RETURNSTATUS   | NOSETTINGS   | ANSWERCALL):

			DPF(0, "Invalid flags - no phone number or modem specified");
			hr = DPERR_INVALIDPARAM;
			break;

		case (RETURNSTATUS   | HAVESETTINGS | DIALCALL):

			hr = DoDialStatus(globals);
			break;

		case (RETURNSTATUS   | HAVESETTINGS | ANSWERCALL):

			hr = DoAnswerStatus(globals);
			break;
	}

	return (hr);

FAILURE:
	DisconnectModem(baseObject);

	return (DPERR_USERCANCEL);
}

/*
 * DisconnectModem
 *
 * Hang up any call in progress.
 */

static HRESULT DisconnectModem(LPDPCOMPORT baseObject)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_INVALIDPARAM);

	// disconnect the call
	dialDropCall(lpDial);
	dialDeallocCall(lpDial);
	dialLineClose(lpDial);

	return (DP_OK);
}

/*
 * GetModemAddress
 *
 * Return current modem address if available.
 */

static HRESULT GetModemAddress(LPDPCOMPORT baseObject, DWORD dwPlayerFlags,
							   LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPMODEM					globals = (LPDPMODEM) baseObject;
	LPDPDIAL					lpDial = globals->lpDial;
	WCHAR						szPhoneNumberW[PHONENUMBERSIZE];
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	HRESULT						hr;

	// no settings?
	if (!globals->bHaveSettings)
		return (DPERR_UNAVAILABLE);

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_UNAVAILABLE);

	// not connected?
	if (!dialIsConnected(lpDial))
		return (DPERR_UNAVAILABLE);

	// if we answered there is no way for us to know a phone number
	if (globals->bAnswering)
		return (DPERR_UNAVAILABLE);

	// we can't know the phone number of local players, only remote players
	if (dwPlayerFlags & DPLAYI_PLAYER_PLAYERLOCAL)
		return (DPERR_UNAVAILABLE);

	// get UNICODE version of phone number
	if (!AnsiToWide(szPhoneNumberW, globals->szPhoneNumber, PHONENUMBERSIZE))
		return (DPERR_GENERIC);

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = &DPMODEM_GUID;

	// ANSI phone number
	addressElements[1].guidDataType = DPAID_Phone;
	addressElements[1].dwDataSize = lstrlen(globals->szPhoneNumber) + 1;
	addressElements[1].lpData = globals->szPhoneNumber;

	// UNICODE phone number
	addressElements[2].guidDataType = DPAID_PhoneW;
	addressElements[2].dwDataSize = (lstrlen(globals->szPhoneNumber) + 1) * sizeof(WCHAR);
	addressElements[2].lpData = szPhoneNumberW;

	// create the address
	hr = baseObject->lpDPlay->lpVtbl->CreateCompoundAddress(baseObject->lpDPlay,
						addressElements, 3,
						lpAddress, lpdwAddressSize);
	return (hr);
}

/*
 * GetModemAddressChoices
 *
 * Return modem address choices
 */

static HRESULT GetModemAddressChoices(LPDPCOMPORT baseObject,
					LPVOID lpAddress, LPDWORD lpdwAddressSize)
{
	LPDPMODEM					globals = (LPDPMODEM) baseObject;
	LPDPDIAL					lpDial = globals->lpDial;
	DPCOMPOUNDADDRESSELEMENT	addressElements[3];
	LINERESULT					lResult;
	HRESULT						hr;

	// dial object has not been created?
	if (lpDial == NULL)
		return (DPERR_UNAVAILABLE);

	ZeroMemory(addressElements, sizeof(addressElements));

	// service provider chunk
	addressElements[0].guidDataType = DPAID_ServiceProvider;
	addressElements[0].dwDataSize = sizeof(GUID);
	addressElements[0].lpData = &DPMODEM_GUID;

	// get ANSI modem name list
	addressElements[1].guidDataType = DPAID_Modem;
	lResult = dialGetModemList(lpDial, TRUE,
					&addressElements[1].lpData,
					&addressElements[1].dwDataSize);
	if (lResult)
	{
		hr = DPERR_OUTOFMEMORY;
		goto Failure;
	}

	// Unicode modem name list
	addressElements[2].guidDataType = DPAID_ModemW;
	lResult = dialGetModemList(lpDial, FALSE,
					&addressElements[2].lpData,
					&addressElements[2].dwDataSize);
	if (lResult)
	{
		hr = DPERR_OUTOFMEMORY;
		goto Failure;
	}

	// create the address
	hr = baseObject->lpDPlay->lpVtbl->CreateCompoundAddress(baseObject->lpDPlay,
						addressElements, 3,
						lpAddress, lpdwAddressSize);

Failure:
	if (addressElements[1].lpData)
		SP_MemFree(addressElements[1].lpData);
	if (addressElements[2].lpData)
		SP_MemFree(addressElements[2].lpData);

	return (hr);

}

/*
 * GetModemBaudRate
 *
 * Get baud rate of modem connnection.
 */

static HRESULT GetModemBaudRate(LPDPCOMPORT baseObject, LPDWORD lpdwBaudRate)
{
	LPDPMODEM	globals = (LPDPMODEM) baseObject;
	LPDPDIAL	lpDial = globals->lpDial;
	LINERESULT	lResult;

	lResult = dialGetBaudRate(lpDial, lpdwBaudRate);

	if (lResult == SUCCESS)
		return (DP_OK);
	else
		return (DPERR_UNAVAILABLE);
}

// Local prototypes
INT_PTR CALLBACK DialSetupWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK AnswerSetupWndProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ModemStatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void ChangeDialingProperties(HWND hWnd, LPDPDIAL lpDial);
void ConfigureModem(HWND hWnd);
void CenterWindow(HWND, HWND);


// ---------------------------------------------------------------------------
// DoDialSetup
// ---------------------------------------------------------------------------
// Description:             Gets modem setup information from the user.
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoDialSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_DIAL), hWndParent, DialSetupWndProc, (LPARAM) globals);
	return (iResult > 0);
}


// ---------------------------------------------------------------------------
// DialSetupWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for dial setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK DialSetupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM	globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch(uMsg)
    {
        case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR)globals);

			// Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

/*			gDPlay->lpVtbl->EnumMRUEntries(gDPlay,
								MRU_SP_KEY, MRU_NUMBER_KEY,
								EnumMRUPhoneNumbers, (LPVOID) hWnd);
*/
			if (lstrlen(globals->szPhoneNumber))
				SetDlgItemText(hWnd, IDC_NUMBER, globals->szPhoneNumber);
/*			else
				SendDlgItemMessage(hWnd,
									IDC_NUMBER,
									CB_SETCURSEL,
									(WPARAM) 0,
									(LPARAM) 0);
*/
/*			SendDlgItemMessage(hWnd,
							   IDC_NUMBER,
							   CB_SETCURSEL,
							   (WPARAM) 0,
							   (LPARAM) 0);
*/
            // initialize the modem selection combo box
			dialFillModemComboBox(globals->lpDial, hWnd, IDC_MODEM, globals->dwDeviceID);

			// initialize location combo box
//			dialFillLocationComboBox(lpModemInfo->lpDial, hWnd, IDC_DIALINGFROM, gModemSettings.dwLocation);
			UpdateButtons(hWnd);

            // Set focus so Derek won't have a cow
            SetFocus(GetDlgItem(hWnd, IDC_NUMBER));

            break;

        case WM_DESTROY:
            // Return failure
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_NUMBER:
					switch (HIWORD(wParam))
					{
					case EN_CHANGE:
//					case CBN_EDITCHANGE:
						UpdateButtons(hWnd);
						break;
					}
                    break;
/*
                case IDC_DIALPROPERTIES:

					ChangeDialingProperties(hWnd, lpModemInfo->lpDial);
					dialFillLocationComboBox(lpModemInfo->lpDial, hWnd, IDC_DIALINGFROM, gModemSettings.dwLocation);

                    break;
*/
                case IDC_CONFIGUREMODEM:

					ConfigureModem(hWnd);

                    break;

				case IDOK:
				{
					DWORD	dwModemSelection;


                    // Gather dialing info

					// Get phone number
					GetDlgItemText(hWnd, IDC_NUMBER, globals->szPhoneNumber, PHONENUMBERSIZE);

					//
					// get current modem selection and then get the assoicated
					// TAPI modem ID
					//
					dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETCURSEL,
													(WPARAM) 0,
													(LPARAM) 0);
					DDASSERT( dwModemSelection != CB_ERR );

					globals->dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETITEMDATA,
													(WPARAM) dwModemSelection,
													(LPARAM) 0);
					DDASSERT( globals->dwDeviceID != CB_ERR );

/*					if (lstrlen(gModemSettings.szPhoneNumber))
					{
						gDPlay->lpVtbl->AddMRUEntry(gDPlay,
											MRU_SP_KEY, MRU_NUMBER_KEY,
											gModemSettings.szPhoneNumber, lstrlen(gModemSettings.szPhoneNumber),
											MAXPHONENUMBERS);
					}
*/
                    // Dial...
					if (DoDial(ghInstance, hWnd, globals))
	                    EndDialog(hWnd, TRUE);

					break;
				}

                case IDCANCEL:
                    // Return failure
                    EndDialog(hWnd, FALSE);

                    break;
            }

            break;
    }

    // Allow for default processing
    return FALSE;
}

// ---------------------------------------------------------------------------
// DoDial
// ---------------------------------------------------------------------------
// Description:             Dials the modem
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoDial(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_STATUS), hWndParent, ModemStatusWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// DoAnswerSetup
// ---------------------------------------------------------------------------
// Description:             Gets modem setup information from the user.
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoAnswerSetup(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

	iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_ANSWER), hWndParent, AnswerSetupWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// AnswerSetupWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for modem setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK AnswerSetupWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM	globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);

    switch(uMsg)
    {
		case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) globals);

            // Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

            // Initialize the modem selection combo box
			dialFillModemComboBox(globals->lpDial, hWnd, IDC_MODEM, globals->dwDeviceID);

            // Set focus so Derek won't have a cow
            SetFocus(GetDlgItem(hWnd, IDC_MODEM));

            break;

        case WM_DESTROY:
            // Return failure
            EndDialog(hWnd, FALSE);

            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_CONFIGUREMODEM:
					ConfigureModem(hWnd);

                    break;

				case IDOK:
				{
					DWORD	dwModemSelection;


					//
					// Get the current selection and then the associated TAPI
					// modem ID.
					//
					dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETCURSEL,
													(WPARAM) 0,
													(LPARAM) 0);

					globals->dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
													IDC_MODEM,
													CB_GETITEMDATA,
													(WPARAM) dwModemSelection,
													(LPARAM) 0);

                    // Answer...
					if (DoAnswer(ghInstance, hWnd, globals))
	                    EndDialog(hWnd, TRUE);

                    break;
				}

                case IDCANCEL:
                    // Return failure
                    EndDialog(hWnd, FALSE);

                    break;
            }

            break;
    }

    // Allow for default processing
    return FALSE;
}


// ---------------------------------------------------------------------------
// DoAnswer
// ---------------------------------------------------------------------------
// Description:             Answers the modem
// Arguments:
//  HINSTANCE               [in] Instance handle to load resources from.
//  HWND                    [in] Parent window handle.
//  LPDPMODEM				[in] modem globals
// Returns:
//  BOOL                    TRUE on success.
BOOL DoAnswer(HINSTANCE hInstance, HWND hWndParent, LPDPMODEM globals)
{
	INT_PTR	iResult;

    iResult = DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_MODEM_STATUS), hWndParent, ModemStatusWndProc, (LPARAM) globals);
	return (iResult > 0);
}

// ---------------------------------------------------------------------------
// ModemStatusWndProc
// ---------------------------------------------------------------------------
// Description:             Message callback function for dial setup dialog.
// Arguments:
//  HWND                    [in] Dialog window handle.
//  UINT                    [in] Window message identifier.
//  WPARAM                  [in] Depends on message.
//  LPARAM                  [in] Depends on message.
// Returns:
//  BOOL                    TRUE if message was processed internally.
INT_PTR CALLBACK ModemStatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	LPDPMODEM		globals = (LPDPMODEM) GetWindowLongPtr(hWnd, DWLP_USER);
	static UINT_PTR	uTimer = 0; /* timer identifier */
	LINERESULT		lResult;
	TCHAR			szStr[TEMPSTRINGSIZE];	// temp string
	TCHAR			szTableStr[TEMPSTRINGSIZE];	// temp string

    switch(uMsg)
    {
        case WM_INITDIALOG:
			// modem info pointer passed in lParam
			globals = (LPDPMODEM) lParam;

             // save the globals with the window
			SetWindowLongPtr(hWnd, DWLP_USER, (LONG_PTR) globals);

            // Center over the parent window
            CenterWindow(hWnd, GetParent(hWnd));

			// Set focus so Allen won't have a cow
            SetFocus(GetDlgItem(hWnd, IDCANCEL));

			// make sure line is closed
			if (globals->lpDial->hLine)
				dialLineClose(globals->lpDial);

			// open a line
			lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
			if (lResult)
			{
				// line would not open, so show an error
				if (LoadString(ghInstance, IDS_COULDNOTOPENLINE, szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
				break;
			}

			if (globals->bAnswering)
			{
				// already have settings, so just exit
				if (globals->bHaveSettings)
					EndDialog(hWnd, TRUE);

				// display "please wait" string
				if (LoadString(ghInstance, IDS_WAITINGFORCONNECTION, szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
			}
			else
			{
				if (LoadString(ghInstance, IDS_DIALING, szTableStr, sizeof(szTableStr)))
				{
					wsprintf(szStr, szTableStr, globals->szPhoneNumber);
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
				}

				// dial phone number
				lResult = dialMakeCall(globals->lpDial, globals->szPhoneNumber);
				if (lResult < 0)
				{
					// could not dial call, so show an error
					if (LoadString(ghInstance, IDS_COULDNOTDIAL, szStr, sizeof(szStr)))
						SetDlgItemText(hWnd, IDC_STATUS, szStr);
					break;
				}

				// reset to zero so that we don't get a false no connection below
				globals->lpDial->dwCallState = 0;
			}

			uTimer = SetTimer(hWnd, 1, TIMERINTERVAL, NULL);
			break;

		case WM_TIMER:

			if (dialIsConnected(globals->lpDial))
			{
				if (uTimer)
				{
					KillTimer(hWnd, uTimer);
					uTimer = 0;
				}

				// give the other side some time to set up
				Sleep(500);

	            EndDialog(hWnd, TRUE);
			}

			// see if line has failed
			else if (globals->lpDial->dwCallError != CALL_OK)
			{
				// show an error
				if (LoadString(ghInstance,
							   globals->bAnswering ? IDS_COULDNOTOPENLINE : IDS_COULDNOTDIAL,
							   szStr, sizeof(szStr)))
					SetDlgItemText(hWnd, IDC_STATUS, szStr);
			}
			break;

        case WM_DESTROY:
			if (uTimer)
			{
				KillTimer(hWnd, uTimer);
				uTimer = 0;
			}
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
					// disconnect the call
					dialDropCall(globals->lpDial);
					dialDeallocCall(globals->lpDial);
					dialLineClose(globals->lpDial);

					// Return failure
					EndDialog(hWnd, FALSE);
                    break;
            }
            break;
    }

    // Allow for default processing
    return FALSE;
}

HRESULT DoDialStatus(LPDPMODEM globals)
{
	LINERESULT		lResult;


	// see if line had an error or went idle
	if ((globals->lpDial->dwCallError != CALL_OK) ||
		((globals->lpDial->hLine) &&
		 (globals->lpDial->dwCallState == LINECALLSTATE_IDLE)))
	{
		DPF(3, "DoDialStatus error recovery");
		// some errors don't close the line so we will
		if (globals->lpDial->hLine)
			dialLineClose(globals->lpDial);
		// reset the error state
		globals->lpDial->dwCallError = CALL_OK;
		return (DPERR_NOCONNECTION);
	}

	// line is not open
	if (!globals->lpDial->hLine)
	{
		lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
		if (lResult)
			return (DPERR_NOCONNECTION);

		lResult = dialMakeCall(globals->lpDial, globals->szPhoneNumber);
		if (lResult < 0)
		{
			dialLineClose(globals->lpDial);
			return (DPERR_NOCONNECTION);
		}

		// reset to zero so that we don't get a false "no connection" before we dial
		globals->lpDial->dwCallState = 0;
	}

	// if we got here then call is in progress
	return (DPERR_CONNECTING);
}

HRESULT DoAnswerStatus(LPDPMODEM globals)
{
	LINERESULT		lResult;

	// see if line had an error
	if (globals->lpDial->dwCallError != CALL_OK)
	{
		// some errors don't close the line so we will
		if (globals->lpDial->hLine)
			dialLineClose(globals->lpDial);
		// reset the error state
		globals->lpDial->dwCallError = CALL_OK;
		return (DPERR_NOCONNECTION);
	}

	// open a line
	if (!globals->lpDial->hLine)
	{
		lResult = dialLineOpen(globals->lpDial, globals->dwDeviceID);
		if (lResult)
			return (DPERR_NOCONNECTION);
	}

	// if we got here then we are ready to answer a call
	return (DP_OK);
}

static BOOL FAR PASCAL EnumMRUPhoneNumbers(LPCVOID lpData, DWORD dwDataSize, LPVOID lpContext)
{
	HWND	hWnd = (HWND) lpContext;

	SendDlgItemMessage(hWnd,
						IDC_NUMBER,
						CB_ADDSTRING,
						(WPARAM) 0,
						(LPARAM) lpData);
	return (TRUE);
}

static void UpdateButtons(HWND hWnd)
{
	LONG_PTR	len;

	// see how much text has been typed into number edit
    len = SendDlgItemMessage(hWnd,
							IDC_NUMBER,
							WM_GETTEXTLENGTH,
							(WPARAM) 0,
							(LPARAM) 0);

	// only enable "Connect" button if text has been entered
	EnableWindow(GetDlgItem(hWnd, IDOK), (len == 0) ? FALSE : TRUE);
}

void ChangeDialingProperties(HWND hWnd, LPDPDIAL lpDial)
{
	TCHAR		szPhoneNumber[PHONENUMBERSIZE];
	DWORD		dwModemSelection;
	DWORD		dwDeviceID;
	LINERESULT	lResult;



	dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETCURSEL,
								(WPARAM) 0,
								(LPARAM) 0);
	DDASSERT( dwModemSelection != CB_ERR );

	dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETITEMDATA,
								(WPARAM) dwModemSelection,
								(LPARAM) 0);
	DDASSERT( dwDeviceID != CB_ERR );
	if (dwDeviceID == CB_ERR)
		return;

	GetDlgItemText(hWnd, IDC_NUMBER, szPhoneNumber, PHONENUMBERSIZE);

	lResult = dialTranslateDialog(lpDial, hWnd, dwDeviceID, szPhoneNumber);
}

void ConfigureModem(HWND hWnd)
{
	DWORD		dwDeviceID;
	DWORD		dwModemSelection;
	LINERESULT	lResult;


	//
	// get the current modem selection and then get the associated TAPI modem ID
	//
	dwModemSelection = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETCURSEL,
								(WPARAM) 0,
								(LPARAM) 0);
	DDASSERT( dwModemSelection != CB_ERR );

	dwDeviceID = (DWORD)SendDlgItemMessage(hWnd,
								IDC_MODEM,
								CB_GETITEMDATA,
								(WPARAM) dwModemSelection,
								(LPARAM) 0);
	DDASSERT( dwDeviceID != CB_ERR );
	if (dwDeviceID != CB_ERR)
		lResult = lineConfigDialog(dwDeviceID, hWnd, "comm/datamodem");
}

// ---------------------------------------------------------------------------
// CenterWidow
// ---------------------------------------------------------------------------
// Description:             Centers one window over another.
// Arguments:
//  HWND                    [in] Window handle.
//  HWND                    [in] Parent window handle.  NULL centers the
//                               window over the desktop.
// Returns:
//  void
void CenterWindow(HWND hWnd, HWND hWndParent)
{
    RECT                    rcWindow, rcParent;
    int                     x, y;

    // Get child window rect
    GetWindowRect(hWnd,  &rcWindow);

    // Get parent window rect
//    if(!hWndParent || !IsWindow(hWndParent))
    {
        hWndParent = GetDesktopWindow();
    }

    GetWindowRect(hWndParent, &rcParent);

    // Calculate XY coordinates
    x = ((rcParent.right - rcParent.left) - (rcWindow.right - rcWindow.left)) / 2;
    y = ((rcParent.bottom - rcParent.top) - (rcWindow.bottom - rcWindow.top)) / 2;

    // Center the window
    SetWindowPos(hWnd, NULL, x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dpserial.rc
//
#define IDS_COM1                        1
#define IDS_COM2                        2
#define IDS_COM3                        3
#define IDS_COM4                        4
#define IDS_BAUD1                       16
#define IDS_BAUD2                       17
#define IDS_BAUD3                       18
#define IDS_BAUD4                       19
#define IDS_BAUD5                       20
#define IDS_BAUD6                       21
#define IDS_BAUD7                       22
#define IDS_BAUD8                       23
#define IDS_BAUD9                       24
#define IDS_BAUD10                      25
#define IDS_BAUD11                      26
#define IDS_BAUD12                      27
#define IDS_BAUD13                      28
#define IDS_BAUD14                      29
#define IDS_BAUD15                      30
#define IDS_STOPBIT1                    32
#define IDS_STOPBIT2                    33
#define IDS_STOPBIT3                    34
#define IDS_PARITY1                     35
#define IDS_PARITY2                     36
#define IDS_PARITY3                     37
#define IDS_PARITY4                     38
#define IDS_FLOW1                       39
#define IDS_FLOW2                       40
#define IDS_FLOW3                       41
#define IDS_FLOW4                       42
#define IDS_FLOW5                       43
#define IDS_COULDNOTOPENLINE            44
#define IDS_WAITINGFORCONNECTION        45
#define IDS_DIALING                     46
#define IDS_COULDNOTDIAL                47
#define IDD_MODEM_DIAL                  101
#define IDD_MODEM_STATUS                102
#define IDD_MODEMDIALOG                 103
#define IDD_SETTINGSDIALOG              300
#define IDD_MODEM_ANSWER                301
#define IDI_MODEM                       701
#define IDC_BAUDRATE                    1000
#define IDC_NUMBEREDIT                  1000
#define IDC_STOPBITS                    1001
#define IDC_PARITY                      1002
#define IDC_COMPORT                     1003
#define IDC_FLOW                        1009
#define IDC_NUMBER                      1009
#define IDC_DIALPROPERTIES              1010
#define IDC_DIALINGFROM                 1012
#define IDC_MODEM                       1013
#define IDC_CONFIGUREMODEM              1014
#define IDC_STATUS                      1017

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\serial\win9x\makefile.inc ===
misc :
	copy ..\..\common\newdpf.h .
	copy ..\..\common\newdpf.c .
	copy ..\..\common\dputils.c .
	copy ..\..\common\memalloc.c .
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\vxd\dbgprint.c ===
// DbgPrint - does debug prints to Out_Debug_String.  This allows messages to be
//            printed when using SOFT-ICE/W to debug VxDs.
//
//      File courtesy Hans Hurvig.
//

void DbgPrint(char *afmt, ...);

#include <basedef.h>
#include <vmm.h>
#include <stdarg.h>


#define DBGPRINT_BUFFER_SIZE 1024
UCHAR    DbgBuf [DBGPRINT_BUFFER_SIZE+1];
PUCHAR   pDbgBuf = DbgBuf;
PUCHAR   pDbgBufEnd = DbgBuf+DBGPRINT_BUFFER_SIZE;

UCHAR DbgHexChars[] = "0123456789ABCDEF";

#ifdef DBCS_SUPPORT
UCHAR    DbgLeadByte=0; // Nonzero lead byte if in the middle of outputting a DBCS char
#endif

_inline void DbgFlush(void)
{
    if (pDbgBuf != DbgBuf) {
        *pDbgBuf = 0;
        VMM_Out_Debug_String ( pDbgBuf = DbgBuf );
    }
}

_inline void DbgPutcLiteral(UCHAR c)
{
    if (pDbgBuf >= pDbgBufEnd) {
        DbgFlush();
    }
    *(pDbgBuf++) = c;
}

_inline void DbcPutHexByteLiteral(UCHAR c)
{
    DbgPutcLiteral(DbgHexChars[c >> 4]);
    DbgPutcLiteral(DbgHexChars[c & 0x0F]);
}

void _fastcall DbgPutc(UCHAR c)
{
#ifdef DBCS_SUPPORT
    if (DbgLeadByte != 0) {
        UCHAR c1 = DbgLeadByte;

        DbgLeadByte = 0;
        DbgPutcLiteral('<');
        DbcPutHexByteLiteral(c1);
        DbcPutHexByteLiteral(c);
        DbgPutcLiteral('>');
    } else if (c == '\0') {
        DbgPutcLiteral('<');
        DbcPutHexByteLiteral('N');
        DbcPutHexByteLiteral('U');
        DbcPutHexByteLiteral('L');
        DbgPutcLiteral('>');
    } else if (IsDBCSLeadByte(c)) {
        DbgLeadByte = c;
    } else
#endif
    
    if (c == '\n') {
        DbgPutcLiteral('\r');
        DbgPutcLiteral('\n');
    } else if (c >= 0x7f || c < ' ') {
        DbgPutcLiteral('<');
        DbcPutHexByteLiteral(c);
        DbgPutcLiteral('>');
    } else {
        DbgPutcLiteral(c);
    }

}

void
putl(unsigned long ul, unsigned short base, short mindig, UCHAR pad)
{
    static UCHAR buf[12];
    register UCHAR *cp = buf;

    buf[0] = 0;
    do {
        --mindig;
        *++cp = DbgHexChars[ul % base];
    } while ((ul /= base) != 0);

    for ( ; mindig > 0 ; --mindig)
        DbgPutc(pad);

    do {
        DbgPutc(*cp);
    } while (*--cp);
}

void DbgPrint(char *afmt, ...)
{
    register int c;
    PUCHAR psz;
    unsigned short base;
    /** va_list list; **/
    PUCHAR list;
    PUCHAR oldfmt;
    register UCHAR *fmt = afmt;

    va_start(list, afmt);

    for (; (c = *fmt) != 0 ; ++fmt) {
        oldfmt = fmt;
        if (c != '%') {
            DbgPutc((UCHAR)c);
#ifdef DBCS_SUPPORT
            if (IsDBCSLeadByte(c)) {
                c = *(++fmt);
                if (c == '\0')
                    goto endloop;
                DbgPutc((UCHAR)c);
            }
#endif
        } else {
            char fLong = 0;
            char fFar = 0;
            unsigned short minchr = 0, maxchr = 0xffff;
            char fLJ = 0;
            char pad = ' ';
            
            base = 10;
            if (fmt[1] == '-') {
                fLJ++;
                fmt++;
            }

            if (fmt[1] == '0')
                pad = '0';

            while ((c = *++fmt) >= '0' && c <= '9')
                minchr = minchr*10 + c - '0';

            if (c == '.') {
                maxchr = 0;
                while ((c = *++fmt) >= '0' && c <= '9')
                    maxchr = maxchr*10 + c - '0';
            }

            if (c == 'l') {
                fLong = 1;
                c = *++fmt;
            }
            if (c == 'F') {
                fFar = 1;
                c = *++fmt;
            }

            switch (c) {
            case 'c':
                DbgPutc((char) va_arg(list, int));
                break;

            case 'p':
            case 'P':
                if (fLong) {
                    DbgFlush();
                    if (fFar)
                        VMM_Out_Debug_Data_Label( va_arg(list, void *) );
                    else
                        VMM_Out_Debug_Code_Label( va_arg(list, void *) );
                    break;
                }

                // not a "long" pointer; treat like 'X'

            case 'x':
            case 'X':
                base = 16;
            case 'd':
                putl(va_arg(list, unsigned long), base, minchr, pad);
                break;

            case 's':
                psz = va_arg(list, char *);
                {
                    unsigned   sln;
                    unsigned   i;

                    if (!fLong)
                        sln = strlen(psz);
                    else {
                        sln = *(unsigned char *)psz;         // Treat "l" attrib on string as PSTRING
                        psz++;
                    }

                    if (maxchr) {
                        if (sln > maxchr)
                            sln = maxchr;
                    }

                    if (minchr && !fLJ) {
                        while (minchr-- > sln)
                            DbgPutc(' ');
                    }

                    for (i=0;i<sln;i++)
                        DbgPutc(*psz++);
                    while (i++ < minchr)
                        DbgPutc(' ');
                }
                break;

            case '%':
                DbgPutc('%');
                break;

            default:
                DbgPutc('%');
                fmt = oldfmt;
                break;
            }
        }
    }

endloop:
    va_end(list);
    DbgFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\bilink.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.H

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/// BILINK.H

#ifndef _BILINK_

#define _BILINK_

#if !defined(offsetof)
	#define offsetof(type, field) ((int)(&((type *)0)->field))
#endif	

typedef struct BILINK {
    struct BILINK *next;
    struct BILINK *prev;
} BILINK;

/* XLATOFF */

#define EMPTY_BILINK(_pBilink) ((_pBilink)->next==(_pBilink))

#ifdef DEBUG
    #define ASSERT_EMPTY_BILINK(_b) ASSERT((_b)->next==(_b))
#else
    #define ASSERT_EMPTY_BILINK(_b)
#endif

// This only works for BILINKS that are the first item in a structure.
#define BilinkToList( _pBilink ) \
	(_pBilink)->prev->next=NULL;

#define InitBilink( _pBilink ) \
    (_pBilink)->prev=(_pBilink)->next=(_pBilink);

#ifdef DEBUG

int FindObject(
    BILINK *link,
    BILINK *list
    );
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    );

void InsertBefore(
     BILINK *in,
     BILINK *before
    );

void Delete(
     BILINK *p
);

/* XLATON */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\vxd\messages.asm ===
;*****************************************************************************
;
;	(C) Copyright MICROSOFT  Corp, 1994
;
;       Title:      MESSAGES.ASM
;                             
;       Version:    1.00
;
;       Date:       07-Jul-1994
;
;       Author:     
;
;-----------------------------------------------------------------------------
;
;       Change log:
;
;          Date     Rev Description
;       ----------- --- ------------------------------------------------------
;
;=============================================================================
	.386

	include vmm.inc
	
	CREATE_MESSAGES EQU TRUE

	include msgmacro.inc
	include messages.inc

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\vxd\messages.inc ===
;*****************************************************************************
;
;	(C) Copyright MICROSOFT  Corp, 1994
;
;       Title:      MESSAGES.INC
;                             
;       Version:    1.00
;
;       Date:       07-Jul-1994
;
;       Author:     
;
;-----------------------------------------------------------------------------
;
;       Change log:
;
;          Date     Rev Description
;       ----------- --- ------------------------------------------------------
;
;=============================================================================
;
; Init segment messages.


VxD_IMESSAGE_SEG

        DECLARE_MESSAGE <PerfName>, \
                <"DirectPlay Protocol">
        DECLARE_MESSAGE <PerfNodeName>, \
                <"DPPROT">

        DECLARE_MESSAGE <PerfThrottleNam>, \       
                <"Throttle (bytes/sec)">
        DECLARE_MESSAGE <PerfThrottleNodeNam>, \
                <"ThrottleBPSec">
        DECLARE_MESSAGE <PerfThrottleDsc>, \
                <"Upper Limit Protocol will send at">

        DECLARE_MESSAGE <PerfBWNam>, \       
                <"Bytes sent/second">
        DECLARE_MESSAGE <PerfBWNodeNam>, \
                <"BWritSec">
        DECLARE_MESSAGE <PerfBWDsc>, \
                <"Bytes sent by the protocol per second">

        DECLARE_MESSAGE <PerfBackLogNam>, \       
                <"Bytes backlog">
        DECLARE_MESSAGE <PerfBackLogNodeNam>, \
                <"BBackLog">
        DECLARE_MESSAGE <PerfBackLogDsc>, \
                <"Bytes unacked in pipe">

        DECLARE_MESSAGE <PerfBytesLostNam>, \       
                <"Bytes dropped/second">
        DECLARE_MESSAGE <PerfBytesLostNodeNam>, \
                <"BDroppedSec">
        DECLARE_MESSAGE <PerfBytesLostDsc>, \
                <"Bytes dropped/wasted per second">

        DECLARE_MESSAGE <PerfLocThroughputNam>, \
                <"Bytes received by remote/second">
        DECLARE_MESSAGE <PerfLocThroughputNodeNam>, \
                <"ThroughputSecRoundTrip">
        DECLARE_MESSAGE <PerfThroughputDsc>, \
                <"Total received at remote (delayed by latency)">

        DECLARE_MESSAGE <PerfLastLatNam>, \
                <"Last Latency">
        DECLARE_MESSAGE <PerfLastLatNodeNam>, \
                <"LastLat">
        DECLARE_MESSAGE <PerfLastLatDsc>, \
                <"Last round trip latency">
                
        DECLARE_MESSAGE <PerfMinLatNam>, \
                <"Min observed Latency (ms)">
        DECLARE_MESSAGE <PerfMinLatNodeNam>, \
                <"MinLatency">
        DECLARE_MESSAGE <PerfMinLatDsc>, \
                <"Minimum observed Round Trip Latency (ms)">

        DECLARE_MESSAGE <PerfAvgLatNam>, \
                <"Average Latency">
        DECLARE_MESSAGE <PerfAvgLatNodeNam>, \
                <"AvgLat">
        DECLARE_MESSAGE <PerfAvgLatDsc>, \
                <"Average latency, last 16 samples">

        DECLARE_MESSAGE <PerfAvgDevLatNam>, \
                <"Average Dev Latency">
        DECLARE_MESSAGE <PerfAvgDevLatNodeNam>, \
                <"AvgDevLat">
        DECLARE_MESSAGE <PerfAvgDevLatDsc>, \
                <"Average Deviation latency, 16 samples">

        DECLARE_MESSAGE <PerfUSER1Nam>, \
                <"Retries mod 20">
        DECLARE_MESSAGE <PerfUSER1NodeNam>, \
                <"USER1">
        DECLARE_MESSAGE <PerfUSER1Dsc>, \
                <"Retries mod 20">

        DECLARE_MESSAGE <PerfUSER2Nam>, \
                <"Protocol Memory In Use">
        DECLARE_MESSAGE <PerfUSER2NodeNam>, \
                <"USER2">
        DECLARE_MESSAGE <PerfUSER2Dsc>, \
                <"Protocol Memory In Use">

        DECLARE_MESSAGE <PerfUSER3Nam>, \
                <"Dplay Memory In Use">
        DECLARE_MESSAGE <PerfUSER3NodeNam>, \
                <"USER3">
        DECLARE_MESSAGE <PerfUSER3Dsc>, \
                <"Dplay Memory In Use">

        DECLARE_MESSAGE <PerfUSER4Nam>, \
                <"Throttle waits mod 20">
        DECLARE_MESSAGE <PerfUSER4NodeNam>, \
                <"USER4">
        DECLARE_MESSAGE <PerfUSER4Dsc>, \
                <"Throttle waits mod 20">

        DECLARE_MESSAGE <PerfUSER5Nam>, \
                <"Remote Clock Delta">
        DECLARE_MESSAGE <PerfUSER5NodeNam>, \
                <"USER5">
        DECLARE_MESSAGE <PerfUSER5Dsc>, \
                <"Remote Clock Delta Change">

        DECLARE_MESSAGE <PerfUSER6Nam>, \
                <"Remote Clock Bias Reset Mod 10">
        DECLARE_MESSAGE <PerfUSER6NodeNam>, \
                <"USER6">
        DECLARE_MESSAGE <PerfUSER6Dsc>, \
                <"Remote Clock Bias Reset Mod 10">
                
VxD_IMESSAGE_ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\vxd\debug.c ===
#define UINT_PTR UINT
#define DWORD_PTR DWORD


#include <dplay.h>
#include <dplaypr.h>
#include <arpdint.h>
#include <mcontext.h>

//#include <basedef.h>
#include <vmm.h>


/*
    GetArg - Gets a command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
    Returns     Pointer to uppercase ASCIZ argument with delimeters stripped, 
or NULL if
                no more arguments.

    Note        Not reentrant

*/
#define MAX_ARG_LEN 30

UCHAR CmdArg[MAX_ARG_LEN+1] = {0};

PUCHAR GetArg(PUCHAR *ppArg)
{
    // Note - Always returns at least one blank argument if string is valid, even
    //        if the string is empty.

    PUCHAR pDest = CmdArg;
    UCHAR c;
    UINT i;

    #define pArg (*ppArg)

    // If end of command already reached, fail

    if (!pArg)
        return NULL;

    // Skip leading whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // Copy the argument

    for (i = 0; i < MAX_ARG_LEN; i++) {
        if ((c = *pArg) == 0 || c == '\t' || c == ' ' || c == ';' ||
                          c == '\n' || c == ',')
            break;
        if (c >= 'a' && c <= 'z')
            c -= ('a' - 'A');
        *(pDest++) = c;
        pArg++;
    }

    // Null terminate the result

    *pDest = '\0';

    // Skip trailing whitespace

    while (*pArg == ' ' || *pArg == '\t')
        pArg++;

    // strip up to one comma

    if (*pArg == ',')
        pArg++;

    // If end of command reached, make next request fail

    else if (*pArg == 0 || *pArg == ';' || *pArg == '\n')
        pArg = NULL;

    // return copy

    return CmdArg;

    #undef pArg
}
/*
    AtoI - Convert a string to a signed or unsigned integer

    IN          pStr = ASCIZ representation of number with optional leading/trailing
                       whitespace and optional leading '-'.
                Radix = Radix to use for conversion (2, 8, 10, or 16)
    OUT        *pResult = Numeric result, or unchanged on failure
    Returns     1 on success, 0 if malformed string.

    Note        Not reentrant

*/
UINT AtoI(PUCHAR pStr, UINT Radix, PUINT pResult)
{
    UINT r = 0;
    UINT Sign = 0;
    UCHAR c;
    UINT d;

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr == '-') {
        Sign = 1;
        pStr++;
    }

    if (*pStr == 0)
        return 0;                   // Empty string!

    while ((c = *pStr) != 0 && c != ' ' && c != '\t') {
        if (c >= '0' && c <= '9')
            d = c - '0';
        else if (c >= 'A' && c <= 'F')
            d = c - ('A' - 10);
        else if (c >= 'a' && c <= 'f')
            d = c - ('a' - 10);
        else
            return 0;               // Not a digit
        if (d >= Radix)
            return 0;               // Not in radix
        r = r*Radix+d;
        pStr++;
    }

    while (*pStr == ' ' || *pStr == '\t')
        pStr++;

    if (*pStr != 0)
        return 0;                   // Garbage at end of string

    if (Sign)
        r = (UINT)(-(INT)r);
    *pResult = r;

    return 1;                       // Success!

}

/*
    GetNumericArg - Gets a numeric command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
                Radix = radix to use for conversion (2, 8, 10, or 16)
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
               *pResult = numeric result on success; unchanged on failure
    Returns     1 on success, 0 on malformed string or no more arguments

    Note        Not reentrant

*/
UINT GetNumericArg(PUCHAR *ppArg, UINT Radix, PVOID pResult)
{
    PUCHAR pA = GetArg(ppArg);
    UINT rc;

    if (!pA)
        return 0;           // No argument

    rc = AtoI(pA, Radix, (PUINT)pResult);

    if (!rc)
        DbgPrint("? Invalid base-%d value, %s\n", Radix, pA);

    return rc;
}

/*
    GetDecimalArg - Gets a decimal command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
               *pResult = numeric result on success; unchanged on failure
    Returns     1 on success, 0 on malformed string or no more arguments

    Note        Not reentrant

*/
UINT GetDecimalArg(PUCHAR *ppArg, PVOID pResult)
{
    return GetNumericArg(ppArg, 10, pResult);
}

/*
    GetHexArg - Gets a hexadecimal command line argument from a string.

    IN          ppArg = pointer to pointer to argument string
    OUT        *ppArg = pointer to next argument, or NULL if this was the last.
               *pResult = numeric result on success; unchanged on failure
    Returns     1 on success, 0 on malformed string or no more arguments

    Note        Not reentrant

*/
UINT GetHexArg(PUCHAR *ppArg, PVOID pResult)
{
    return GetNumericArg(ppArg, 16, pResult);
}

extern VOID DumpLog(UINT start);
extern VOID DumpWholeLog(VOID);
extern SetLogLevel(UINT level, UINT fExact);

VOID DQLog(PUCHAR pArgs)
{
	UINT record;
	
	if(!GetDecimalArg(&pArgs, &record)){
		DumpWholeLog();
	} else {
		DumpLog(record);
	}
}

VOID DQLogLast(PUCHAR pArgs)
{
	UINT nDump;
	if(!GetDecimalArg(&pArgs, &nDump)){
		DumpLogLast(50);
	} else {
		DumpLogLast(nDump);
	}
}

VOID DQLogLevel(PUCHAR pArgs)
{
	UINT level;
	
	if (!GetDecimalArg(&pArgs, &level))
		return;

	SetLogLevel(level,FALSE);	
}

VOID DQLogExact(PUCHAR pArgs)
{
	UINT level;
	
	if (!GetDecimalArg(&pArgs, &level))
		return;

	SetLogLevel(level,TRUE);	
}

VOID PrintThisFlags(DWORD dwFlags)
{
	DWORD	dwMask, dwField, dwBitCount;

	dwBitCount = 0;
	dwMask = 1;
	while (dwMask)
	{
		dwField = dwFlags & dwMask;
		if (dwField)
		{
			if (dwBitCount == 0)
				DbgPrint("                         (");
			else
				DbgPrint(" |\n                          ");

			switch (dwField)
			{
			case DPLAYI_DPLAY_PENDING:
				DbgPrint("DPLAYI_DPLAY_PENDING");
				break;

			case DPLAYI_DPLAY_SESSIONLOST:
				DbgPrint("DPLAYI_DPLAY_SESSIONLOST");
				break;

			case DPLAYI_DPLAY_CLOSED:
				DbgPrint("DPLAYI_DPLAY_CLOSED");
				break;

			case DPLAYI_DPLAY_DX3INGAME:
				DbgPrint("DPLAYI_DPLAY_DX3INGAME");
				break;

			case DPLAYI_DPLAY_EXECUTINGPENDING:
				DbgPrint("DPLAYI_DPLAY_EXECUTINGPENDING");
				break;

			case DPLAYI_DPLAY_DX3SP:
				DbgPrint("DPLAYI_DPLAY_DX3SP");
				break;

			case DPLAYI_DPLAY_UNINITIALIZED:
				DbgPrint("DPLAYI_DPLAY_UNINITIALIZED");
				break;

			case DPLAYI_DPLAY_ENUM:
				DbgPrint("DPLAYI_DPLAY_ENUM");
				break;

			case DPLAYI_DPLAY_KEEPALIVE:
				DbgPrint("DPLAYI_DPLAY_KEEPALIVE");
				break;

			case DPLAYI_DPLAY_LOBBYOWNS:
				DbgPrint("DPLAYI_DPLAY_LOBBYOWNS");
				break;

			case DPLAYI_DPLAY_SECURITY:
				DbgPrint("DPLAYI_DPLAY_SECURITY");
				break;

			case DPLAYI_DPLAY_ENUMACTIVE:
				DbgPrint("DPLAYI_DPLAY_ENUMACTIVE");
				break;

			case DPLAYI_DPLAY_ENCRYPTION:
				DbgPrint("DPLAYI_DPLAY_ENCRYPTION");
				break;

			case DPLAYI_DPLAY_SPSECURITY:
				DbgPrint("DPLAYI_DPLAY_SPSECURITY");
				break;

			case DPLAYI_DPLAY_HANDLEMULTICAST:
				DbgPrint("DPLAYI_DPLAY_HANDLEMULTICAST");
				break;

			case DPLAYI_DPLAY_SPUNRELIABLE:
				DbgPrint("DPLAYI_DPLAY_SPUNRELIABLE");
				break;

			case DPLAYI_DPLAY_PROTOCOL:
				DbgPrint("DPLAYI_DPLAY_PROTOCOL");
				break;

			case DPLAYI_DPLAY_PROTOCOLNOORDER:
				DbgPrint("DPLAYI_DPLAY_PROTOCOLNOORDER");
				break;
				
			default:
				DbgPrint("unknown: %08x", dwField);
				break;
			}

			dwBitCount++;
		}
		dwMask <<= 1;
	}

	if (dwBitCount)
		DbgPrint(")\n");
}


VOID DQThis(PUCHAR pArgs)
{
	DPLAYI_DPLAY	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nThis\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("pInterfaces             : %08x\n", this->pInterfaces);
	DbgPrint("dwRefCnt                : %d\n", this->dwRefCnt);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintThisFlags(this->dwFlags);
	DbgPrint("pcbSPCallbacks          : %08x\n", this->pcbSPCallbacks);
	DbgPrint("pPlayers                : %08x\n", this->pPlayers);
	DbgPrint("pGroups                 : %08x\n", this->pGroups);
	DbgPrint("pSysPlayer              : %08x\n", this->pSysPlayer);
	DbgPrint("pNameTable              : %08x\n", this->pNameTable);
	DbgPrint("nGroups                 : %d\n", this->nGroups);
	DbgPrint("nPlayers                : %d\n", this->nPlayers);
	DbgPrint("uiNameTableSize         : %d\n", this->uiNameTableSize);
	DbgPrint("uiNameTableLastUsed     : %d\n", this->uiNameTableLastUsed);
	DbgPrint("lpsdDesc                : %08x\n", this->lpsdDesc);
	DbgPrint("pMessageList            : %08x\n", this->pMessageList);
	DbgPrint("pLastMessage		  : %08x\n", this->pLastMessage);
	DbgPrint("nMessages               : %d\n", this->nMessages);
	DbgPrint("dwSPHeaderSize          : %d\n", this->dwSPHeaderSize);
	DbgPrint("pMessagesPending        : %08x\n", this->pMessagesPending);
	DbgPrint("pLastPendingMessage	  : %08x\n", this->pLastPendingMessage);
	DbgPrint("nMessagesPending        : %d\n", this->nMessagesPending);
	DbgPrint("dwSPMaxMessage          : %d\n", this->dwSPMaxMessage);
	DbgPrint("dwSPMaxMessageGuaranteed: %d\n", this->dwSPMaxMessageGuaranteed);
	DbgPrint("pPacketList             : %08x\n", this->pPacketList);
	DbgPrint("hDPlayThread            : %08x\n", this->hDPlayThread);
	DbgPrint("hSPModule               : %08x\n", this->hSPModule);
	DbgPrint("hDPlayThreadEvent       : %08x\n", this->hDPlayThreadEvent);
	DbgPrint("pNameServer             : %08x\n", this->pNameServer);
	DbgPrint("pSysGroup               : %08x\n", this->pSysGroup);
	DbgPrint("pServerPlayer           : %08x\n", this->pServerPlayer);
	DbgPrint("pPerfData               : %08x\n", this->pPerfData);
	DbgPrint("pPerfThread             : %08x\n", this->hPerfThread);
	DbgPrint("hPerfEvent              : %08x\n", this->hPerfEvent);
	DbgPrint("pSecurityDesc           : %08x\n", this->pSecurityDesc);
	DbgPrint("ulMaxContextBufferSize  : %d\n", this->ulMaxContextBufferSize);
	DbgPrint("ulMaxSignatureSize      : %d\n", this->ulMaxSignatureSize);
	DbgPrint("hCSP                    : %08x\n", this->hCSP);
	DbgPrint("hPublicKey              : %08x\n", this->hPublicKey);
	DbgPrint("pPublicKey              : %08x\n", this->pPublicKey);
	DbgPrint("dwPublicKeySize         : %d\n", this->dwPublicKeySize);
	DbgPrint("pUserCredentials        : %08x\n", this->pUserCredentials);
	DbgPrint("LoginState              : %d\n", this->LoginState);
	DbgPrint("phCredential            : %08x\n", this->phCredential);
	DbgPrint("phContext               : %08x\n", this->phContext);
	DbgPrint("hEncryptionKey          : %08x\n", this->hEncryptionKey);
	DbgPrint("hDecryptionKey          : %08x\n", this->hDecryptionKey);
	DbgPrint("hServerPublicKey        : %08x\n", this->hServerPublicKey);
	DbgPrint("pspNode                 : %08x\n", this->pspNode);
	DbgPrint("pvSPLocalData           : %08x\n", this->pvSPLocalData);
	DbgPrint("dwSPLocalDataSize       : %d\n", this->dwSPLocalDataSize);
	DbgPrint("pISP                    : %08x\n", this->pISP);
	DbgPrint("pNextObject             : %08x\n", this->pNextObject);
	DbgPrint("dwLastEnum              : %d\n", this->dwLastEnum);
	DbgPrint("dwLastPing              : %d\n", this->dwLastPing);
	DbgPrint("dwEnumTimeout           : %d\n", this->dwEnumTimeout);
	DbgPrint("pbAsyncEnumBuffer       : %08x\n", this->pbAsyncEnumBuffer);
	DbgPrint("dwEnumBufferSize        : %d\n", this->dwEnumBufferSize);
	DbgPrint("lpLobbyObject           : %08x\n", this->lpLobbyObject);
	DbgPrint("lpLaunchingLobbyObject  : %08x\n", this->lpLaunchingLobbyObject);
	DbgPrint("pSessionList            : %08x\n", this->pSessionList);
	DbgPrint("dwMinVersion            : %d\n", this->dwMinVersion);
	DbgPrint("pAddForwardList         : %08x\n", this->pAddForwardList);
	DbgPrint("pProtocol               : %08x\n", this->pProtocol);
	DbgPrint("lpPlayerMsgPool         : %08x\n", this->lpPlayerMsgPool);
	DbgPrint("lpSendParmsPool         : %08x\n", this->lpSendParmsPool);
	DbgPrint("dwPlayerReservations    : %08x\n", this->dwPlayerReservations);
	DbgPrint("dwLastReservationTime   : %08x\n", this->dwLastReservationTime);
	DbgPrint("dwSPVersion             : %08x\n", this->dwSPVersion);
	DbgPrint("dwZombieCount           : %08x\n", this->dwZombieCount);
}

VOID DQContextPool(PUCHAR pArgs)
{
	DPLAYI_DPLAY	*this;
	UINT iNext;
	UINT i=0,j=0;
	PVOID pv;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("Dumping Message Context Pool\n");
	DbgPrint("----------------------------\n");

	for(i=0;i<MSG_FAST_CONTEXT_POOL_SIZE+1;i++)
	{
		DbgPrint("[%d]",i);
		if(this->GrpMsgContextPool[i]){
			pv=this->GrpMsgContextPool;
			while(pv){
				DbgPrint("(%x)->\n",pv);
				pv=*((LPVOID *)pv);
				j++;
				if(j==10){
					DbgPrint("\n");
					j=0;
				}
			}
		} 
		DbgPrint("\n");
	}
}

VOID DQContextList(PUCHAR pArgs)
{
	DPLAYI_DPLAY	*pIDP;
	PMSGCONTEXTTABLE this;
	UINT iNext;
	UINT i=0,j;

	if (!GetHexArg(&pArgs, &pIDP))
		return;

	this=pIDP->pMsgContexts;

	DbgPrint("Dumping pMsgContexts at %x off of IDplay %x:\n",this,pIDP);
	DbgPrint("------------------------------------------------------------\n");
	DbgPrint("nUnique 		: %x\n",this->nUnique);
	DbgPrint("nTableSize    : %d\n",this->nTableSize);
	DbgPrint("FreeList:\n");
	iNext=this->iNextAvail;
	while(iNext != LIST_END){
		DbgPrint("[%d]->",iNext);
		iNext=this->MsgContextEntry[iNext].iNextAvail;
		i++;
		if(i==10){
			DbgPrint("\n");
			i=0;
		}
	}
	DbgPrint("\nFull Dump:\n");
	for(i=0;i<this->nTableSize;i++){
		DbgPrint("[%d] psp %x nUnique %x nContexts %d",i,
				this->MsgContextEntry[i].psp,this->MsgContextEntry[i].nUnique,
				this->MsgContextEntry[i].nContexts);
		if(this->MsgContextEntry[i].nUnique){
			DbgPrint(" Context List @ %x:\n",this->MsgContextEntry[i].papv);
			for(j=0;j<this->MsgContextEntry[i].nContexts;j++){
				DbgPrint("[%x] %x\n", j, *(((PVOID *)this->MsgContextEntry[i].papv)+j));
			}
		} else {
			DbgPrint(" NONE\n");
		}
	}

}

VOID PrintPlayerFlags(DWORD dwFlags)
{
	DWORD	dwMask, dwField, dwBitCount;

	dwBitCount = 0;
	dwMask = 1;
	while (dwMask)
	{
		dwField = dwFlags & dwMask;
		if (dwField)
		{
			if (dwBitCount == 0)
				DbgPrint("                         (");
			else
				DbgPrint(" |\n                          ");

			switch (dwField)
			{
			case DPLAYI_PLAYER_SYSPLAYER:
				DbgPrint("DPLAYI_PLAYER_SYSPLAYER");
				break;

			case DPLAYI_PLAYER_NAMESRVR:
				DbgPrint("DPLAYI_PLAYER_NAMESRVR");
				break;

			case DPLAYI_PLAYER_PLAYERINGROUP:
				DbgPrint("DPLAYI_PLAYER_PLAYERINGROUP");
				break;

			case DPLAYI_PLAYER_PLAYERLOCAL:
				DbgPrint("DPLAYI_PLAYER_PLAYERLOCAL");
				break;

			case DPLAYI_PLAYER_CREATEDPLAYEREVENT:
				DbgPrint("DPLAYI_PLAYER_CREATEDPLAYEREVENT");
				break;

			case DPLAYI_GROUP_SYSGROUP:
				DbgPrint("DPLAYI_GROUP_SYSGROUP");
				break;

			case DPLAYI_GROUP_DPLAYOWNS:
				DbgPrint("DPLAYI_GROUP_DPLAYOWNS");
				break;

			case DPLAYI_PLAYER_APPSERVER:
				DbgPrint("DPLAYI_PLAYER_APPSERVER");
				break;

			case DPLAYI_GROUP_STAGINGAREA:
				DbgPrint("DPLAYI_GROUP_STAGINGAREA");
				break;

			case DPLAYI_GROUP_HIDDEN:
				DbgPrint("DPLAYI_GROUP_HIDDEN");
				break;

			case DPLAYI_PLAYER_OWNER:
				DbgPrint("DPLAYI_PLAYER_OWNER");
				break;

			case DPLAYI_DPLAY_SPUNRELIABLE: 
				DbgPrint("DPLAYI_DPLAY_SPUNRELIABLE\n");
				break;

			case DPLAYI_DPLAY_PROTOCOL:
				DbgPrint("DPLAYI_DPLAY_PROTOCOL\n");
				break;
				
			case DPLAYI_DPLAY_PROTOCOLNOORDER:
				DbgPrint("DPLAYI_DPLAY_PROTOCOLNOORDER\n");
				break;

			case DPLAYI_PLAYER_ON_DEATH_ROW:
				DbgPrint("DPLAYI_PLAYER_ON_DEATH_ROW");
				break;

			case DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE:
				DbgPrint("DPLAYI_PLAYER_DOESNT_HAVE_NAMETABLE");
				break;

			case DPLAYI_PLAYER_CONNECTION_LOST:
				DbgPrint("DPLAYI_PLAYER_CONNECTION_LOST");
				break;

			case DPLAYI_PLAYER_BEING_DESTROYED:
				DbgPrint("DPLAYI_PLAYER_BEING_DESTROYED");
				break;
				
			default:
				DbgPrint("unknown: %08x", dwField);
				break;
			}

			dwBitCount++;
		}
		dwMask <<= 1;
	}

	if (dwBitCount)
		DbgPrint(")\n");
}

VOID DQFixedMemPool(PUCHAR pArgs)
{
	void *pv;
	PFPOOL pPool;
	UINT i;

	if (!GetHexArg(&pArgs, &pPool))
		return;

	DbgPrint("MemoryPool @ (%x) : ItemSize (%d)\n",pPool,pPool->cbItemSize);
	DbgPrint("-------------------------------------------------\n");
	DbgPrint("nAllocated : %d\n",pPool->nAllocated);
	DbgPrint("nInUse     : %d\n",pPool->nInUse);
	DbgPrint("nMaxInUse  : %d\n",pPool->nMaxInUse);

	DbgPrint("\nfnGet      : %x\n",pPool->Get);
	DbgPrint(  "fnRelease  : %x\n",pPool->Release);
	DbgPrint(  "fnScale    : %x\n",pPool->Scale);
	DbgPrint(  "fnFini     : %x\n",pPool->Fini);

	DbgPrint("fnBlockInitAlloc  :%x\n",pPool->fnBlockInitAlloc);
	DbgPrint("fnBlockInit       :%x\n",pPool->fnBlockInit);
	DbgPrint("fnBlockFini       :%x\n",pPool->fnBlockFini);

	DbgPrint("FreeList->");
	pv=pPool->pPool;
	i=0;
	while(pv){
		DbgPrint("(%x)->",pv);
		pv=*((void **)pv);
		i++;
		if(i==6){
			i=0;
			DbgPrint("\n");
		}
	}
	DbgPrint("NULL");
	
}

VOID DQSendParms(PUCHAR pArgs)
{
	PSENDPARMS psp;
	UINT i;

	if (!GetHexArg(&pArgs, &psp))
		return;

	DbgPrint( "SENDPARMS @ (%x)\n",psp);
	DbgPrint( "----------------------\n");
	DbgPrint( "idFrom %x   pPlayerFrom:%x\n",psp->idFrom,psp->pPlayerFrom);
	
	if(psp->pPlayerTo){
		DbgPrint( "  idTo %x   pPlayerTo  :%x\n",psp->idTo, psp->pPlayerTo);
	}
	if(psp->pGroupTo){
		DbgPrint( "  idTo %x   pGroupTo  :%x\n",psp->idTo, psp->pGroupTo);
	}	
	DbgPrint( "RefCount   :%d\n",psp->RefCount);
	DbgPrint( "lpData     :%x\n",psp->lpData);
	DbgPrint( "dwDataSize :%d\n",psp->dwDataSize);
	DbgPrint( "dwFlags    :%x\n",psp->dwFlags);
	DbgPrint( "dwPriority :%x\n",psp->dwPriority);
	DbgPrint( "dwTimeout  :%d\n",psp->dwTimeout);
	DbgPrint( "hContext   :%x\n",psp->hContext);
	DbgPrint( "nContext   :%d\n",psp->nContext);
	DbgPrint( "nComplete  :%d\n",psp->nComplete);
	DbgPrint( "hr         :%x\n",psp->hr);
	DbgPrint( "dwSendTime :%x\n",psp->dwSendTime);
	DbgPrint( "dwCompTime :%x\n",psp->dwSendCompletionTime);
	DbgPrint( "\nSG Buffers:\n-----------\n");

	for(i=0;i<psp->cBuffers;i++){
		DbgPrint("Addr %x Len %d fnFree %x\n",psp->Buffers[i].pData,psp->Buffers[i].len,psp->BufFree[i].fnFree);
	}
	DbgPrint( "dwTotalSize:%d\n",psp->dwTotalSize);
}

VOID DQProtocolReceive(PUCHAR pArgs)
{
	PRECEIVE pR;

	if (!GetHexArg(&pArgs, &pR))
		return;

#ifdef SIGN
	DbgPrint("Signature       : %08x\n",	    pR->Signature);		// Signature for SIGN
#endif
	DbgPrint("pNext           : %08x\n",	    pR->pNext);
/*	
	union {
		BILINK          pReceiveQ;
		struct _RECEIVE *      pNext;
	};	
	BILINK		    RcvBuffList;     // List of receive buffers that make up the message.
	CRITICAL_SECTION ReceiveLock;
*/

	DbgPrint("pSession          : %08x\n",	    pR->pSession);

        DbgPrint("fBusy             : %08x\n",      pR->fBusy);
	
	DbgPrint("fReliable         : %08x\n",	    pR->fReliable);
	DbgPrint("fEOM              : %08x\n",	    pR->fEOM);
	DbgPrint("command           : %08x\n",	    pR->command);
	DbgPrint("messageid         : %08x\n",	    pR->messageid);
	DbgPrint("MessageSize       : %08x\n\n",	pR->MessageSize);
	DbgPrint("iNR               : %08x\n",	    pR->iNR);
	DbgPrint("NR                : %08x\n",	    pR->NR);
	DbgPrint("NS                : %08x\n",	    pR->NS);
	DbgPrint("RCVMask           : %08x\n",	    pR->RCVMask);
	DbgPrint("pSPHeader         : %08x\n",	    pR->pSPHeader);

	//UCHAR           SPHeader[0];

}


VOID DQProtocolSend(PUCHAR pArgs)
{
	PSEND	pS;

	if (!GetHexArg(&pArgs, &pS))
		return;
		
#ifdef SIGN
	DbgPrint("Signature           : %08x\n", pS->Signature);
#endif
//	CRITICAL_SECTION SendLock;          // Lock for Send Structure
	DbgPrint("RefCount            : %d\n", pS->RefCount);

	DbgPrint("SendState:          %08x\n", pS->SendState);	// State of this message's transmission.

	// Lists and Links...
	
//	union {
//		struct _SEND *pNext;			// linking on free pool
//		BILINK		   SendQ;			// linking on session send queue
//	};
//	BILINK         m_GSendQ;			// Global Priority Queue
	DbgPrint("pSession:     %08x\n",pS->pSession); // pointer to SESSIONion(gets a ref)

	// Send Information
	
	DbgPrint("idFrom:       %08x\n",pS->idFrom);
	DbgPrint("idTo:         %08x\n",pS->idTo);
	DbgPrint("wIdTo:        %08x\n",pS->wIdTo);		// index in table
	DbgPrint("wIdFrom:      %08x\n",pS->wIdFrom);       // index in table
	DbgPrint("dwFlags:      %08x\n",pS->dwFlags);       // Send Flags (include reliable)
	DbgPrint("pMessage:     %08x\n",pS->pMessage);	// Buffer chain describing message.
	DbgPrint("MessageSize:  %08x\n",pS->MessageSize);		// Total size of the message.
	DbgPrint("FrameDataLen: %08x\n",pS->FrameDataLen);       // Data area of each frame.
	DbgPrint("nFrames:      %08x\n",pS->nFrames);	    // Number of frames for this message.

	DbgPrint("Priority:     %08x\n",pS->Priority);       // Send Priority.

	// Vars for reliability
	DbgPrint("fSendSmall:   %08x\n",pS->fSendSmall);
	DbgPrint("fUpdate:      %08x\n",pS->fUpdate);       // update to NS,NR NACKMask made by receive.
	DbgPrint("messageid:    %08x\n",pS->messageid);		// Message ID number.
	DbgPrint("serial:       %08x\n",pS->serial);       // serial number.
	DbgPrint("OpenWindows   %08x\n",pS->OpenWindow);
	DbgPrint("NS:           %08x\n",pS->NS);    	// Sequence Sent.
	DbgPrint("NR:           %08x\n",pS->NR);		// Sequence ACKED.
	DbgPrint("SendSEQMSK:   %08x\n",pS->SendSEQMSK);		// Mask to use. - BUGBUG: determine speed at start
	DbgPrint("NACKMask:     %08x\n",pS->NACKMask);       // Bit pattern of NACKed frames.
	

	// These are the values at NR - updated by ACKs
	DbgPrint("SendOffset:          %08x\n",pS->SendOffset);		// Current offset we are sending.
	DbgPrint("pCurrentBuffer:      %08x\n",pS->pCurrentBuffer);  	// Current buffer being sent.
	DbgPrint("CurrentBufferOffset: %08x\n",pS->CurrentBufferOffset);// Offset in the current buffer of next packet.

	// info to update link characteristics when ACKs come in.
	
	//BILINK         StatList:			// Info for packets already sent.
	
	// Operational Characteristics

//	DbgPrint("PendedRetryTimer:    %08x\n",pS->PendedRetryTimer);
//	DbgPrint("CancelledRetryTimer: %08x\n",pS->CancelledRetryTimer);
	DbgPrint("uRetryTimer:         %08x\n",pS->uRetryTimer);
	DbgPrint("RetryCount:          %08x\n",pS->RetryCount);// Number of times we retransmitted.
	DbgPrint("WindowSize:          %08x\n",pS->WindowSize);// Maximum Window Size.
	DbgPrint("tLastACK:            %08x\n",pS->tLastACK);// Time we last got an ACK.

	//BUGBUG:
	DbgPrint("PacketSize:          %08x\n",pS->PacketSize);// Size of packets to send.
	DbgPrint("FrameSize:           %08x\n",pS->FrameSize);// Size of Frames for this send.

	// Completion Vars
	DbgPrint("hEvent:              %08x\n",pS->hEvent);// Event to wait on for internal send.
	DbgPrint("Status:              %08x\n",pS->Status);// Send Completion Status.

	DbgPrint("pAsyncInfo:          %08x\n",pS->pAsyncInfo);// ptr to Info for completing Async send(NULL=>internal send)
//	DbgPrint("AsyncInfo:           // actual info (copied at send call).
	
} 


VOID DQProtocolSession(PUCHAR pArgs)
{
	PSESSION	pS;

	if (!GetHexArg(&pArgs, &pS))
		return;

	DbgPrint("pProtocol           : %08x\n", pS->pProtocol);

#ifdef SIGN
	DbgPrint("Signature           : %08x\n", pS->Signature);
#endif

	// Identification

//	DbgPrint(" SessionLock;           // Lock for the SESSIONion.
	DbgPrint("RefCount            : %d\n", pS->RefCount);
	DbgPrint("eState              : %d\n", pS->eState);
	DbgPrint("hClosingEvent       : %d\n", pS->hClosingEvent);

	DbgPrint("fSendSmall          : %d\n", pS->fSendSmall);     
	DbgPrint("fSendSmallDG        : %d\n", pS->fSendSmallDG);
	
	DbgPrint("dpid                : %08x\n",pS->dpid);
	DbgPrint("iSession;           : %d\n", pS->iSession);
	
	DbgPrint("MaxPacketSize       : x%08x %d\n",pS->MaxPacketSize,pS->MaxPacketSize);

	DbgPrint("\n Operating Parameters:SEND \n --------- --------------- \n");

	// Operating parameters -- Send

	// Common

	DbgPrint("Common:\n");
	DbgPrint("MaxCSends           : %d\n",pS->MaxCSends);

	DbgPrint("Reliable:\n");
	// Reliable

	DbgPrint("FirstMsg    : %08x\n",pS->FirstMsg);				// First message number being transmitted
	DbgPrint("LastMsg     : %08x\n",pS->LastMsg);				// Last message number being transmitted
	DbgPrint("OutMsgMask  : %08x\n",pS->OutMsgMask);           // relative to FirstMsg, unacked messages

	DbgPrint("nWaitingForMessageid: %08x\n", pS->nWaitingForMessageid);

	// DataGram
	DbgPrint("Datagram:\n");

	DbgPrint("DGFirstMsg    : %08x\n",pS->DGFirstMsg);
	DbgPrint("DGLastMsg     : %08x\n",pS->DGLastMsg);
	DbgPrint("DGOutMsgMask  : %08x\n",pS->DGOutMsgMask);

	DbgPrint("nWaitingForDGMessageid: %08x\n",pS->nWaitingForDGMessageid);

	// Send stats are tracked seperately since sends may
	// no longer be around when completions come in.
	
	//BILINK           OldStatList;		
	

	// Operating parameters -- Receive
	DbgPrint("\n Operating Parameters:RECEIVE \n --------- ------------------ \n");

	// DataGram Receive.
//	BILINK           pDGReceiveQ;            // queue of ongoing datagram receives

	// Reliable Receive.
//	BILINK	         pRlyReceiveQ;			 // queue of ongoing reliable receives
//	BILINK           pRlyWaitingQ;           // Queue of out of order reliable receives waiting.
											 // only used when PROTOCOL_NO_ORDER not set.
	DbgPrint("FirstRlyReceive : %08x\n",pS->FirstRlyReceive);
	DbgPrint("LastRlyReceive  : %08x\n",pS->LastRlyReceive);
	DbgPrint("InMsgMask       : %08x\n",pS->InMsgMask);

	DbgPrint("\n Operating Parameters:STATS \n --------- ---------------- \n");
 

	// Operational characteristics - MUST BE DWORD ALIGNED!!!

	DbgPrint("WindowSize           :%d\n",pS->WindowSize);
	DbgPrint("DGWindowSize         :%d\n",pS->DGWindowSize);

	
	DbgPrint("MaxRetry             :%d\n",pS->MaxRetry);	// Usualy max retries before dropping.
	DbgPrint("MinDropTime          :%d\n",pS->MinDropTime);	// Min time to retry before dropping.
	DbgPrint("MaxDropTime          :%d\n",pS->MaxDropTime);	// After this time always drop.

	DbgPrint("LocalBytesReceived   :%d\n",pS->LocalBytesReceived);    // Total Data Bytes received (including retries).
	DbgPrint("RemoteBytesReceived  :%d\n",pS->RemoteBytesReceived);   // Last value from remote.

	DbgPrint("LongestLatency       :%d\n",pS->LongestLatency);		// longest observed latency (msec)
	DbgPrint("ShortestLatency      :%d\n",pS->ShortestLatency);		// shortest observed latency(msec)
	
	DbgPrint("FpAverageLatency     :%d\n",pS->FpAverageLatency/256);
	DbgPrint("FpLocalAverageLatency:%d\n",pS->FpLocalAverageLatency/256);	// Local average latency    (msec 24.8) (across fewer samples)
	
	DbgPrint("FpLocalAvgDeviation  :%d\n",pS->FpLocalAvgDeviation/256);   // average deviation of latency. (msec 24.8)

	DbgPrint("Bandwidth            :%d\n",pS->Bandwidth);				// latest observed bandwidth (bps)
	DbgPrint("HighestBandwidth     :%d\n",pS->HighestBandwidth);    // highest observed bandwidth (bps)

}


void PrintWideString(LPWSTR lpwStr, LONG lFieldWidth)
{
	if (lpwStr)
	{
		while (*lpwStr)
		{
			DbgPrint("%c", *lpwStr);
			lpwStr++;
			lFieldWidth--;
		}
	}
	while (lFieldWidth > 0)
	{
		DbgPrint(" ");
		lFieldWidth--;
	}
}

void PrintNameString(LPWSTR lpwStr)
{
	if (lpwStr)
	{
		DbgPrint(" \"");
		PrintWideString(lpwStr, 0);
		DbgPrint("\"\n");
	}
	else
		DbgPrint("\n");
}

// this is from the winsock file dpsp.h
typedef struct _SPPLAYERDATA 
{
	SOCKADDR saddrStream,saddrDatagram;
}SPPLAYERDATA,*LPSPPLAYERDATA;

void PrintSocketInfo(SOCKADDR *lpSockAddr)
{
	switch (lpSockAddr->sa_family)
	{
	case AF_INET:
		DbgPrint("port = %d, ip = %d.%d.%d.%d",
			*((u_short *)&lpSockAddr->sa_data[0]),
			(BYTE) lpSockAddr->sa_data[2],
			(BYTE) lpSockAddr->sa_data[3],
			(BYTE) lpSockAddr->sa_data[4],
			(BYTE) lpSockAddr->sa_data[5]);
		break;

	case AF_IPX:
		DbgPrint("IPX");
		break;

	default:
		DbgPrint("Unknown");
		break;
	}
}

void PrintAddress(LPVOID lpData, DWORD dwDataSize)
{
	if ((lpData) && (dwDataSize == sizeof(SPPLAYERDATA)))
	{
		LPSPPLAYERDATA	this = (LPSPPLAYERDATA) lpData;

		DbgPrint("                         (Stream  : ");
		PrintSocketInfo(&this->saddrStream);
		DbgPrint("\n                          Datagram: ");
		PrintSocketInfo(&this->saddrDatagram);
		DbgPrint(")\n");
	}
}

VOID DQPlayer(PUCHAR pArgs)
{
	DPLAYI_PLAYER	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nPlayer\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintPlayerFlags(this->dwFlags);
	DbgPrint("dwID                    : %08x\n", this->dwID);
	DbgPrint("lpszShortName           : %08x", this->lpszShortName);
	PrintNameString(this->lpszShortName);
	DbgPrint("lpszLongName            : %08x", this->lpszLongName);
	PrintNameString(this->lpszLongName);
	DbgPrint("pvPlayerData            : %08x\n", this->pvPlayerData);
	DbgPrint("dwPlayerDataSize        : %d\n", this->dwPlayerDataSize);
	DbgPrint("pvPlayerLocalData       : %08x\n", this->pvPlayerLocalData);
	DbgPrint("dwPlayerLocalDataSize   : %d\n", this->dwPlayerLocalDataSize);
	DbgPrint("pvSPData                : %08x\n", this->pvSPData);
	PrintAddress(this->pvSPData, this->dwSPDataSize);
	DbgPrint("dwSPDataSize            : %d\n", this->dwSPDataSize);
	DbgPrint("pvSPLocalData           : %08x\n", this->pvSPLocalData);
	DbgPrint("dwSPLocalDataSize       : %d\n", this->dwSPLocalDataSize);
	DbgPrint("dwIDSysPlayer           : %08x\n", this->dwIDSysPlayer);
	DbgPrint("dwVersion               : %08x\n", this->dwVersion);
	DbgPrint("lpDP                    : %08x\n", this->lpDP);
	DbgPrint("nGroups                 : %d\n", this->nGroups);
	DbgPrint("dwIDParent              : %08x\n", this->dwIDParent);
	DbgPrint("pNextPlayer:            : %08x\n", this->pNextPlayer);
	DbgPrint("hEvent                  : %08x\n", this->hEvent);
	DbgPrint("dwNPings                : %d\n", this->dwNPings);
	DbgPrint("nPendingSends           : %d\n", this->nPendingSends);
	DbgPrint("dwChatterCount          : %d\n", this->dwChatterCount);
	DbgPrint("dwUnansweredPings       : %d\n", this->dwUnansweredPings);
	DbgPrint("dwProtLastSendBytes     : %d\n", this->dwProtLastSendBytes);
	DbgPrint("dwProtLastRcvdBytes     : %d\n", this->dwProtLastRcvdBytes);
	DbgPrint("dwTimeToDie		      : %d\n", this->dwTimeToDie);
	DbgPrint("pClientInfo             : %08x\n", this->pClientInfo);
	DbgPrint("pOwnerGroupList         : %08x\n", this->pOwnerGroupList);
}

VOID DQPlayerList(PUCHAR pArgs)
{
	DPLAYI_PLAYER	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nPlayer List\n\n");
	DbgPrint(" pPlayer  dwFlags   dwID  dwVersion short name      long name       address\n");
//            00000000 00000000 00000000 00000000 123456789012345 123456789012345

	while (this)
	{
		DbgPrint("%08x %08x %08x %08x ",
			this, this->dwFlags, this->dwID, this->dwVersion);
		
		PrintWideString(this->lpszShortName, 16);
		PrintWideString(this->lpszLongName, 16);

		if ((this->pvSPData) && (this->dwSPDataSize == sizeof(SPPLAYERDATA)))
		{
			LPSPPLAYERDATA	lpSocketAddr = (LPSPPLAYERDATA) this->pvSPData;

			PrintSocketInfo(&lpSocketAddr->saddrStream);
		}

		DbgPrint("\n");

		this = this->pNextPlayer;
	}
}

VOID DQGroup(PUCHAR pArgs)
{
	DPLAYI_GROUP	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nGroup\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintPlayerFlags(this->dwFlags);
	DbgPrint("dwID                    : %08x\n", this->dwID);
	DbgPrint("lpszShortName           : %08x", this->lpszShortName);
	PrintNameString(this->lpszShortName);
	DbgPrint("lpszLongName            : %08x", this->lpszLongName);
	PrintNameString(this->lpszLongName);
	DbgPrint("pvPlayerData            : %08x\n", this->pvPlayerData);
	DbgPrint("dwPlayerDataSize        : %d\n", this->dwPlayerDataSize);
	DbgPrint("pvPlayerLocalData       : %08x\n", this->pvPlayerLocalData);
	DbgPrint("dwPlayerLocalDataSize   : %d\n", this->dwPlayerLocalDataSize);
	DbgPrint("pvSPData                : %08x\n", this->pvSPData);
	PrintAddress(this->pvSPData, this->dwSPDataSize);
	DbgPrint("dwSPDataSize            : %d\n", this->dwSPDataSize);
	DbgPrint("pvSPLocalData           : %08x\n", this->pvSPLocalData);
	DbgPrint("dwSPLocalDataSize       : %d\n", this->dwSPLocalDataSize);
	DbgPrint("dwIDSysPlayer           : %08x\n", this->dwIDSysPlayer);
	DbgPrint("dwVersion               : %08x\n", this->dwVersion);
	DbgPrint("lpDP                    : %08x\n", this->lpDP);
	DbgPrint("nGroups                 : %d\n", this->nGroups);
	DbgPrint("dwIDParent              : %08x\n", this->dwIDParent);
	DbgPrint("pGroupnodes:            : %08x\n", this->pGroupnodes);
	DbgPrint("pSysPlayerGroupnodes    : %08x\n", this->pSysPlayerGroupnodes);
	DbgPrint("pNextGroup              : %08x\n", this->pNextGroup);
	DbgPrint("nPlayers                : %d\n", this->nPlayers);
	DbgPrint("pSubgroups              : %08x\n", this->pSubgroups);
	DbgPrint("nSubgroups              : %d\n", this->nSubgroups);
	DbgPrint("dwOwnerID               : %08x\n", this->dwOwnerID);
}

VOID DQGroupList(PUCHAR pArgs)
{
	DPLAYI_GROUP	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nGroup List\n\n");
	DbgPrint("  pGroup  dwFlags   dwID  dwVersion nPlr nGrp nSubGrp short name      long name\n");
//            00000000 00000000 00000000 00000000    4    4       4 123456789012345

	while (this)
	{
		DbgPrint("%08x %08x %08x %08x %4d %4d %7d ",
			this, this->dwFlags, this->dwID, this->dwVersion,
			this->nPlayers, this->nGroups, this->nSubgroups);

		PrintWideString(this->lpszShortName, 16);
		PrintWideString(this->lpszLongName, 16);
		DbgPrint("\n");

		this = this->pNextGroup;
	}
}

VOID PrintSessionDescFlags(DWORD dwFlags)
{
	DWORD	dwMask, dwField, dwBitCount;

	dwBitCount = 0;
	dwMask = 1;
	while (dwMask)
	{
		dwField = dwFlags & dwMask;
		if (dwField)
		{
			if (dwBitCount == 0)
				DbgPrint("                         (");
			else
				DbgPrint(" |\n                          ");

			switch (dwField)
			{
			case DPSESSION_NEWPLAYERSDISABLED:
				DbgPrint("DPSESSION_NEWPLAYERSDISABLED");
				break;

			case DPSESSION_MIGRATEHOST:
				DbgPrint("DPSESSION_MIGRATEHOST");
				break;

			case DPSESSION_NOMESSAGEID:
				DbgPrint("DPSESSION_NOMESSAGEID");
				break;

			case DPSESSION_NOPLAYERMGMT:
				DbgPrint("DPSESSION_NOPLAYERMGMT");
				break;

			case DPSESSION_JOINDISABLED:
				DbgPrint("DPSESSION_JOINDISABLED");
				break;

			case DPSESSION_KEEPALIVE:
				DbgPrint("DPSESSION_KEEPALIVE");
				break;

			case DPSESSION_NODATAMESSAGES:
				DbgPrint("DPSESSION_NODATAMESSAGES");
				break;

			case DPSESSION_SECURESERVER:
				DbgPrint("DPSESSION_SECURESERVER");
				break;

			case DPSESSION_PRIVATE:
				DbgPrint("DPSESSION_PRIVATE");
				break;

			case DPSESSION_PASSWORDREQUIRED:
				DbgPrint("DPSESSION_PASSWORDREQUIRED");
				break;


			case DPSESSION_MULTICASTSERVER:
				DbgPrint("DPSESSION_MULTICASTSERVER");
				break;


			case DPSESSION_CLIENTSERVER:
				DbgPrint("DPSESSION_CLIENTSERVER");
				break;

			default:
				DbgPrint("unknown: %08x", dwField);
				break;
			}

			dwBitCount++;
		}
		dwMask <<= 1;
	}

	if (dwBitCount)
		DbgPrint(")\n");
}

VOID DQSessionDesc(PUCHAR pArgs)
{
	DPSESSIONDESC2	*this;

	if (!GetHexArg(&pArgs, &this))
		return;

	DbgPrint("\nSession Desc\n\n");
	DbgPrint("dwSize                  : %d\n", this->dwSize);
	DbgPrint("dwFlags                 : %08x\n", this->dwFlags);
	PrintSessionDescFlags(this->dwFlags);
	DbgPrint("guidInstance            : %08x %08x %08x %08x\n",
		*((LPDWORD)(&this->guidInstance) + 0),
		*((LPDWORD)(&this->guidInstance) + 1),
		*((LPDWORD)(&this->guidInstance) + 2),
		*((LPDWORD)(&this->guidInstance) + 3));
	DbgPrint("guidApplication         : %08x %08x %08x %08x\n",
		*((LPDWORD)(&this->guidApplication) + 0),
		*((LPDWORD)(&this->guidApplication) + 1),
		*((LPDWORD)(&this->guidApplication) + 2),
		*((LPDWORD)(&this->guidApplication) + 3));
	DbgPrint("dwMaxPlayers            : %d\n", this->dwMaxPlayers);
	DbgPrint("dwCurrentPlayers        : %d\n", this->dwCurrentPlayers);
	DbgPrint("lpszSessionName         : %08x", this->lpszSessionName);
	PrintNameString(this->lpszSessionName);
	DbgPrint("lpszPassword            : %08x", this->lpszPassword);
	PrintNameString(this->lpszPassword);
	DbgPrint("dwReserved1             : %08x\n", this->dwReserved1);
	DbgPrint("dwReserved2             : %08x\n", this->dwReserved2);
	DbgPrint("dwUser1                 : %08x\n", this->dwUser1);
	DbgPrint("dwUser2                 : %08x\n", this->dwUser2);
	DbgPrint("dwUser3                 : %08x\n", this->dwUser3);
	DbgPrint("dwUser4                 : %08x\n", this->dwUser4);
}

/*
    DQInfo - handles dot-commands of the form:

        .NWSERVER INFO

*/
VOID DQInfo(PUCHAR pArgs)
{
	DbgPrint("Hello World!\n");
}


UINT RequestTraceLevel = 0;

VOID DQTraceRequestsOn(PUCHAR pArgs)
{
    RequestTraceLevel = 1;
}

VOID DQTraceRequestsOff(PUCHAR pArgs)
{
    RequestTraceLevel = 0;
}

VOID DQTraceRequestsBreak(PUCHAR pArgs)
{
    RequestTraceLevel = 2;
}


typedef VOID (*pQDHandler)(PUCHAR pCmd);

typedef struct {
    PUCHAR  pName;      // Command name (unique part uppercase, optional lowercase)
    pQDHandler pHandler;
} QD, *pQD;

QD QueryDispatch[] = {
	{ "L"            , DQLog                   },
	{ "LL"           , DQLogLast               },
	{ "LV"           , DQLogLevel              },
	{ "LE"			 , DQLogExact              },
    { "Info"         , DQInfo                  },
    { "t"			 , DQThis                  },
    { "p"			 , DQPlayer                },
    { "pl"			 , DQPlayerList            },
    { "pr"           , DQProtocolReceive       },
    { "ps"           , DQProtocolSession       },
    { "psp"          , DQSendParms             },
    { "pool"         , DQFixedMemPool          },
    { "g"			 , DQGroup                 },
    { "gl"			 , DQGroupList             },
    { "ss"           , DQProtocolSend          },
    { "sd"			 , DQSessionDesc           },
    { "cl"           , DQContextList           },
    { "cp"           , DQContextPool           },
    { ""             , 0   }
};

QD TraceDispatch[] = {
    { ""            , 0   }
};

QD TraceRequestDispatch[] = {
    { "ON"    , DQTraceRequestsOn       },
    { "OFf"   , DQTraceRequestsOff      },
    { "Break" , DQTraceRequestsBreak    },
    { ""            , 0   }
};

UINT QDMatch(PUCHAR pU, PUCHAR pT)
{
    while (*pU == *pT) {
        if (*pU == 0)
            return 1;
        pU++;
        pT++;
    }

    if (*pT < 'a')
        return 0;

    while (*pT != 0 && *pU == (*pT - ('a' - 'A'))) {
        pU++;
        pT++;
    }

    if (*pU != 0)
        return 0;

    return 1;
}

pQD LookUpQD(PUCHAR pCmd, pQD pTable)
{
    UINT i;

    if (!pCmd)
        return NULL;

    for (i = 0; pTable[i].pHandler != NULL; i++) {
        if (QDMatch(pCmd, pTable[i].pName))
            return &(pTable[i]);
    }
    return NULL;
}

#define MAX_DEBUG_QUERY_COMMAND_LENGTH 100

UCHAR DebugQueryCmdStr[MAX_DEBUG_QUERY_COMMAND_LENGTH+1] = "";
UINT DebugQueryCmdStrLen = MAX_DEBUG_QUERY_COMMAND_LENGTH;

void DQparse ( PUCHAR pCmd, pQD pqt )
{

    UCHAR c;
    PUCHAR pCmdName;
    pQD pq;

    pCmdName = GetArg(&pCmd);

    if ( (pq = LookUpQD(pCmdName, pqt)) ) {
        (*pq->pHandler)(pCmd);
    } else {
        DbgPrint("====== DPLAY Debugging VXD (DPLAY.VXD) ======\n\n");
        DbgPrint("    t  <addr>                               - dump this pointer\n");
        DbgPrint("    p  <addr>                               - dump player\n");
        DbgPrint("    pl <addr>                               - dump player list\n");
        DbgPrint("    g  <addr>                               - dump group\n");
        DbgPrint("    gl <addr>                               - dump group list\n");
        DbgPrint("    sd <addr>                               - dump session desc\n");
        DbgPrint("    psp <addr>                              - dump SENDPARMS\n");
        DbgPrint("    cl  <addr-this>                         - dump context list off of this\n");
        DbgPrint("    cp  <addr-this>                         - dump context pool off of this\n");
        DbgPrint("    L  <record>                             - dump log starting at record#\n");
        DbgPrint("    LL <numrecords>                         - dump the last numrecords\n");
        DbgPrint("    LV <level>                              - set log debug level (<=)\n");
        DbgPrint("    LE <level>                              - set log debug level (equal only)\n");
        DbgPrint("    ps <addr>                               - dump protocol session\n");
        DbgPrint("    ss <addr>                               - dump protocol send\n");
        DbgPrint("    pr <addr>                               - dump protocol receive\n");
        DbgPrint("\n");
    }
}

VOID DQTrace(PUCHAR pArgs)
{
    DQparse(pArgs, TraceDispatch);
}

VOID DQTraceRequests(PUCHAR pArgs)
{
    DQparse(pArgs, TraceRequestDispatch);
}

void Debug_Query ( PUCHAR pCmd )
{
    DQparse(pCmd, QueryDispatch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\bilink.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    BILINK.C

Abstract:

    Management for doubly linked lists

Author:

    George Joy

Environment:

    32-bit 'C'

Revision History:

--*/
#include <windows.h>
#include "dpsp.h"
#include <dpf.h>
#include "bilink.h"

// Note: serialization of access to BILINK structures must 
//       take place in the calling code.  Operations are
//       not intrinsically atomic.

#ifdef DEBUG
int FindObject(
    BILINK *link,
    BILINK *list
    )
{
    BILINK *p = list->next;
    while(p != link && p != list)
        p= p->next;
    return (p==link);
}
#endif

void InsertAfter(
    BILINK *in,
    BILINK *after
    )
/*=========================================================================
 *  Description:
 *      Insert an object after a specified object in the doubly linked list.
 *      The after object could be the Head BILINK for adding to the head of a
 *      queue.
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,after)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = after->next;
    in->prev = after;
    after->next->prev = in;
    after->next = in;
}

void InsertBefore(
     BILINK *in,
     BILINK *before
    )
/*=========================================================================
 *  Description:
 * Inserts an  object before a specified object in the doubly linked list.
 * The before object could be the Head BILINK for adding to the end
 * of the queue
 * CALLED WITH INTERRUPTS_OFF
 *
 *  Returns:
 *
 */
{
    #ifdef DEBUG
    if(FindObject(in,before)) {
        DPF(0,"Attempt to re-insert object in BILINK queue\n");
        DEBUG_BREAK();
    }
    #endif
    in->next = before;
    in->prev = before->prev;
    before->prev->next = in;
    before->prev = in;
}

void Delete(
     BILINK *p
)
/*=========================================================================
 *  Description:
 *
 * Delete a  object from a doubly linked list. Make sure it IS on a list!
 * CALLED WITH INTERRUPTS OFF (must be atomic).
 *
 *  Returns:
 *
 */
{
    ASSERT(p && p->prev && p->next);
    ASSERT(p->prev->next == p && p->next->prev == p);
    p->next->prev = p->prev;
    p->prev->next = p->next;
    // p->next = p->prev = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\vxd\debugext.asm ===
.LALL
;*****************************************************************************
;
;	(C) Copyright MICROSOFT  Corp, 1993
;
;       Title:      DPLAY.ASM
;                             
;       Version:    1.00
;
;       Date:       16-Mar-1993
;
;       Author:     AaronO (mostly stolen from SnowBall vxdinit.asm)
;
;-----------------------------------------------------------------------------
;
;       Change log:
;
;          Date     Rev Description
;       ----------- --- ------------------------------------------------------
;       16-Mar-1993 AWO Original (splurped from SnowBall vxdinit.asm)
;
;=============================================================================
;
; 	Main VxD module for the NWSERVER NCP server:
;
;		Real mode initialization
;		VxD Initialization, including server VM creation
;		VxD PM API support
;		ServerStarvation checker
;
;-----------------------------------------------------------------------------
; BUGBUG: make sure everything is cleaned up from getting rid of VM here.
;-----------------------------------------------------------------------------
        TITLE $DEBUG
        .386P


include vmm.inc
include debug.inc
include shell.inc

include perf.inc        ;performance monitor
include msgmacro.inc
include messages.inc

MASM=1


ifdef DEBUG
extrn  _Debug_Query : near
extrn  _DebugQueryCmdStr : byte
extrn  _DebugQueryCmdStrLen : dword
endif

VxD_LOCKED_CODE_SEG

DPLAY_Device_Id equ 444h

Declare_Virtual_Device DPLAY, 1, 0, DPLAY_Control, DPLAY_Device_Id, \
                        Undefined_Init_Order, 0, 0


;=============================================================================
; 			VxD Control Dispatch table
;-----------------------------------------------------------------------------

Begin_Control_Dispatch DPLAY
;   Control_Dispatch Set_Device_Focus,     SERVER_Set_Device_Focus
;   Control_Dispatch QUERY_DESTROY,        NWSERVER_Query_Destroy
;    Control_Dispatch SYS_CRITICAL_INIT,    NWSERVER_Critical_Init
    Control_Dispatch DEVICE_INIT,          DPLAY_Device_Init
;    Control_Dispatch INIT_COMPLETE,        NWSERVER_Init_Complete
    Control_Dispatch DEBUG_QUERY,          DPLAY_Debug_Query
;   Control_Dispatch Create_VM, 	   SERVER_Create_VM
;   Control_Dispatch SYS_VM_TERMINATE,     NWSERVER_Exit
;   Control_Dispatch SYS_CRITICAL_EXIT,    NWSERVER_Critical_Exit
;   Control_Dispatch VM_NOT_EXECUTEABLE,   NWSERVER_VM_Not_Exec
;   Control_Dispatch END_PM_APP, 	   NWSERVER_End_PM_App
;   Control_Dispatch Device_Reboot_Notify, NWSERVER_Reboot
;    Control_Dispatch DESTROY_THREAD,       NWSERVER_Destroy_Thread
;   Control_Dispatch BEGIN_PM_APP,         NWSERVER_Begin_PM_App
;    Control_Dispatch KERNEL32_INITIALIZED, NWSERVER_Kernel32Initialized
;    Control_Dispatch KERNEL32_SHUTDOWN,    NWSERVER_Kernel32Shutdown
;    Control_Dispatch W32_DeviceIoControl,  NWSERVER_Win32_API
;PNP_NEW_DEVNODE	     EQU 22h
;    Control_Dispatch PNP_NEW_DEVNODE,      NWSERVER_PNPNewDevNode
;    Control_Dispatch System_Exit,          NWSERVER_System_Exit
    Control_Dispatch W32_DEVICEIOCONTROL,     DPLAY_W32_DeviceIOControl, sCall, <ecx, ebx, edx, esi>

End_Control_Dispatch DPLAY

;
; DbgPrint is defined in DbgPrint.c in this case.
;
_VMM_Out_Debug_String PROC NEAR PUBLIC
        push    esi
        mov     esi, [esp].8
        VMMcall Out_Debug_String
        pop     esi
        ret
_VMM_Out_Debug_String ENDP

; VOID VMM_Out_Debug_Code_Label(PVOID Address)
;
; Outputs a flat pointer as a symbolic label
;
_VMM_Out_Debug_Code_Label PROC NEAR PUBLIC
        mov     eax, [esp].4
	mov	dx, cs
	Trace_Out	"?DX:EAX", nocrlf
        ret
_VMM_Out_Debug_Code_Label ENDP

; VOID VMM_Out_Debug_Data_Label(PVOID Address)
;
; Outputs a flat pointer as a symbolic label
;
_VMM_Out_Debug_Data_Label PROC NEAR PUBLIC
        mov     eax, [esp].4
	mov	dx, ds
	Trace_Out	"?DX:EAX", nocrlf
        ret
_VMM_Out_Debug_Data_Label ENDP


_VMM_Get_Sys_VM_Handle	proc public
	push	ebx
	VMMcall	Get_Sys_VM_Handle
	mov	eax, ebx
	pop	ebx
	ret
_VMM_Get_Sys_VM_Handle	endp

_VMM_Get_Profile_String	proc public
	push	ebp
	mov	ebp, esp

	push	esi
	push	edi

	mov	esi, [ebp+8]		; Section name
	mov	edi, [ebp+12]		; Key name
	mov	edx, [ebp+16]		; default
	VMMcall	Get_Profile_String
	mov	eax, edx

	pop	edi
	pop	esi

	pop	ebp
	ret
_VMM_Get_Profile_String	endp

_VMM_Get_Profile_Hex_Int	proc public
	push	ebp
	mov	ebp, esp

	push	esi
	push	edi

	mov	esi, [ebp+8]		; Section name
	mov	edi, [ebp+12]		; Key name
	mov	eax, [ebp+16]		; default
	VMMcall	Get_Profile_Hex_Int

	pop	edi
	pop	esi

	pop	ebp
	ret
_VMM_Get_Profile_Hex_Int	endp

_C_HeapAllocate PROC NEAR PUBLIC
	mov     eax,ss:[esp+8]
	mov     edx,ss:[esp+4]
	push    eax
	push    edx
	VMMCall _HeapAllocate
	add     esp,8
	ret
_C_HeapAllocate ENDP

_C_HeapFree PROC NEAR PUBLIC
	mov     edx,ss:[esp+4]
	push    0
	push    edx
	VMMcall _HeapFree
	add     esp,8
	ret
_C_HeapFree ENDP

_GetThreadHandle PROC NEAR PUBLIC
	push	edi
	VMMcall Get_Cur_Thread_Handle
	mov     eax,edi
	pop 	edi
	ret
_GetThreadHandle ENDP

_VMM_Create_Semaphore		proc public
	mov	ecx, [esp+4]		; First arg = Initial token count
	VMMCall	Create_Semaphore
	jnc	vcs_1
	xor	eax, eax
vcs_1:
	ret
_VMM_Create_Semaphore		endp

_VMM_Destroy_Semaphore		proc public
	mov	eax, [esp+4]		; First arg = Semaphore handle
	VMMJmp	Destroy_Semaphore
_VMM_Destroy_Semaphore		endp

_VMM_Signal_Semaphore		proc public
	mov	eax, [esp+4]		; First arg = Semaphore handle
	VMMJmp	Signal_Semaphore
_VMM_Signal_Semaphore		endp

; VMM_Wait_Semaphore_Ints - Waits on a semaphore, allowing ints to be processed in this thread
;
_VMM_Wait_Semaphore_Ints	proc public
	mov	eax, [esp+4]		; First arg = Semaphore handle
    mov	ecx, Block_Force_Svc_Ints+Block_Svc_Ints
	VMMJmp	Wait_Semaphore
_VMM_Wait_Semaphore_Ints		endp

;Get system time in milliseconds
_VMM_Get_System_Time		proc public
	VMMJmp Get_System_Time
_VMM_Get_System_Time		endp

;**************************************************************************
;
; MAP_Client_Ptr - convert a pointer to a 0:32 flat pointer
;
; IN  eax = client Segment/Selector
; IN  ebx = client Offset
; IN  edi = points o Client Reg Structure
;
; OUT edx = flat client ptr
;**************************************************************************
MAP_Client_Ptr proc near uses ecx

        ;borrow the client DS:DX
        movzx ecx, [edi].Client_DS
        push ecx
        movzx ecx, [edi].Client_DX
        push ecx

        mov [edi].Client_DS, ax
        mov [edi].Client_DX, bx
        Client_Ptr_Flat edx, DS, DX

        ;restore the contents of the client regs
        pop ecx
        mov [edi].Client_DX, cx
        pop ecx
        mov [edi].Client_DS, cx

        RET

MAP_Client_Ptr ENDP

;*****************************************************************************
;    DPLAYGetVersion - returns the version number of DPLAY DEBUG module
;
;    ENTRY:
;
;    EXIT: Carry is clear, ax=DPLAYVXD version <AH=Major AL = Minor>
;=============================================================================

BeginProc DPLAYGetVersion Service
    mov  eax, 001h
    clc
    ret
EndProc DPLAYGetVersion


; NOTE: The following assumes (craftily) that the command tail for the debug query
;       dot-command is passed in by VMM in FS:[ESI].
;
BeginProc   DPLAY_Debug_Query

	xor	ebx, ebx
	mov	ax, fs
	test	ax, ax
	jz	dq1

	push	esi
	push	ds

	lea	edi, _DebugQueryCmdStr
	mov	ecx, _DebugQueryCmdStrLen
	mov	ds, ax
	cld
	rep	movsb
	xor	eax, eax
	stosb

	pop	ds
	pop	esi

	lea	ebx, _DebugQueryCmdStr

dq1:
	push	ebx
        call    _Debug_Query
	add	esp, 4
	ret
EndProc     DPLAY_Debug_Query

VxD_LOCKED_CODE_ENDS

VxD_LOCKED_DATA_SEG

;====================================================================
; STATISTICS for performance monitor
;--------------------------------------------------------------------
	public hPerfId
hPerfId					dd	?


	public _stat_ThrottleRate
_stat_ThrottleRate		dd	?	

	public _stat_BytesSent
_stat_BytesSent			dd	?

	public _stat_BackLog
_stat_BackLog			dd	?

	public	_stat_BytesLost
_stat_BytesLost			dd	?	

	public  _stat_RemBytesReceived
_stat_RemBytesReceived	dd	?

	public	_stat_Latency
_stat_Latency			dd	?

	public	_stat_MinLatency
_stat_MinLatency		dd	?

	public	_stat_AvgLatency
_stat_AvgLatency		dd	?

	public	_stat_AvgDevLatency
_stat_AvgDevLatency		dd	?

	public	_stat_USER1
_stat_USER1				dd	?	

	public	_stat_USER2
_stat_USER2				dd	?	

	public	_stat_USER3
_stat_USER3				dd	?	

	public  _stat_USER4
_stat_USER4				dd 	?

	public  _stat_USER5
_stat_USER5				dd 	?

	public  _stat_USER6
_stat_USER6				dd 	?

Vxd_LOCKED_DATA_ENDS


VXD_ICODE_SEG

DPLAY_Device_Init proc near public

	LocalVar hStatNULL, DWORD
	LocalVar hStat2, DWORD
	LocalVar hStat1, DWORD

        ; Do STATISTICS VxD stuff

    GET_MESSAGE_PTR <PerfName>, ebx
    GET_MESSAGE_PTR <PerfNodeName>, ecx
        Reg_Perf_Srv 0,0,ebx,ecx,0
        or      eax, eax        ; Q: perf.386 around?
        jz      ir0             ; N: skip it
        mov     hPerfId, eax

    GET_MESSAGE_PTR <PerfThrottleNam>, ebx
    GET_MESSAGE_PTR <PerfThrottleNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfThrottleDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_ThrottleRate

    GET_MESSAGE_PTR <PerfBWNam>, ebx
    GET_MESSAGE_PTR <PerfBWNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfBWDsc>, edx         
        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BytesSent

    GET_MESSAGE_PTR <PerfBackLogNam>, ebx
    GET_MESSAGE_PTR <PerfBackLogNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfBackLogDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_BackLog

    GET_MESSAGE_PTR <PerfBytesLostNam>, ebx
    GET_MESSAGE_PTR <PerfBytesLostNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfBytesLostDsc>, edx         
        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BytesLost

    GET_MESSAGE_PTR <PerfLocThroughputNam>, ebx
    GET_MESSAGE_PTR <PerfLocThroughputNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfThroughputDsc>, edx         
        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_RemBytesReceived

    GET_MESSAGE_PTR <PerfLastLatNam>, ebx
    GET_MESSAGE_PTR <PerfLastLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfLastLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_Latency

    GET_MESSAGE_PTR <PerfMinLatNam>, ebx
    GET_MESSAGE_PTR <PerfMinLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfMinLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_MinLatency

    GET_MESSAGE_PTR <PerfAvgLatNam>, ebx
    GET_MESSAGE_PTR <PerfAvgLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfAvgLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_AvgLatency

    GET_MESSAGE_PTR <PerfAvgDevLatNam>, ebx
    GET_MESSAGE_PTR <PerfAvgDevLatNodeNam>, ecx     
    GET_MESSAGE_PTR <PerfAvgDevLatDsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_AvgDevLatency
        
    GET_MESSAGE_PTR <PerfUSER1Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER1NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER1Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER1

    GET_MESSAGE_PTR <PerfUSER2Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER2NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER2Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER2

    GET_MESSAGE_PTR <PerfUSER3Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER3NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER3Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER3

    GET_MESSAGE_PTR <PerfUSER4Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER4NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER4Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER4

    GET_MESSAGE_PTR <PerfUSER5Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER5NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER5Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER5

    GET_MESSAGE_PTR <PerfUSER6Nam>, ebx
    GET_MESSAGE_PTR <PerfUSER6NodeNam>, ecx     
    GET_MESSAGE_PTR <PerfUSER6Dsc>, edx         
        Reg_Perf_Stat hPerfId,0,0,ebx,ecx,0,edx,_stat_USER6
;
;    GET_MESSAGE_PTR <PerfTPSNam>, ebx
;    GET_MESSAGE_PTR <PerfTPSNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfTPSDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_Transactions
;
;
;    GET_MESSAGE_PTR <PerfBReadNam>, ebx
;    GET_MESSAGE_PTR <PerfBReadNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfBReadDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BRead
;	mov	[hStat1], eax
;
;    GET_MESSAGE_PTR <PerfBWriteNam>, ebx
;    GET_MESSAGE_PTR <PerfBWriteNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfBWriteDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_RATE>,ebx,ecx,0,edx,_stat_BWrite
;	mov	[hStat2], eax
;	mov	[hStatNull],0
;
;	lea	eax,hStat1
;    GET_MESSAGE_PTR <PerfThroughputNam>, ebx
;    GET_MESSAGE_PTR <PerfThroughputNodeNam>, ecx     
;    GET_MESSAGE_PTR <PerfThroughputDsc>, edx         
;        Reg_Perf_Stat hPerfId,0,<PSTF_COMPLEX OR PSTF_RATE>,ebx,ecx,0,edx,eax

ir0:
	clc
ir1:
	LeaveProc
	Return

DPLAY_Device_Init endp

VXD_ICODE_ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\fpm.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.h
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#ifndef _FPM_H_
#define _FPM_H_

typedef struct FPOOL *PFPOOL, *LPFPOOL;

typedef BOOL (*FN_BLOCKINITALLOC)(void * pvItem);
typedef VOID (*FN_BLOCKINIT)(void * pvItem);
typedef VOID (*FN_BLOCKFINI)(void *pvItem);

LPFPOOL FPM_Init(
	unsigned int size,						// size of blocks in pool
	FN_BLOCKINITALLOC fnBlockInitAlloc,     // fn called for each new alloc
	FN_BLOCKINIT      fnBlockInit,          // fn called each time block used
	FN_BLOCKFINI      fnBlockFini           // fn called before releasing mem
	);

typedef void * (*FPM_GET)(LPFPOOL pPool);
typedef void   (*FPM_RELEASE)(LPFPOOL pPool, void *pvItem);
typedef void   (*FPM_SCALE)(LPFPOOL pPool);
typedef void   (*FPM_FINI)(LPFPOOL pPool, int bFORCE);

typedef struct FPOOL {
	// external
	FPM_GET		Get;
	FPM_RELEASE Release;
	FPM_SCALE   Scale;
	FPM_FINI    Fini;
	
	// internal
	FN_BLOCKINITALLOC fnBlockInitAlloc;
	FN_BLOCKINIT      fnBlockInit;
	FN_BLOCKFINI      fnBlockFini;
	
	int    cbItemSize;
	void * pPool;
	int    nAllocated;
	int    nInUse;
	int    nMaxInUse;
	int    bInScale;
	
	CRITICAL_SECTION cs;
	
} FPOOL, *LPFPOOL, *PFPOOL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\dbgtopic.h ===
DEBUG_TOPIC(B,"&Blting")
DEBUG_TOPIC(C,"&Clipping")
DEBUG_TOPIC(D,"&DDraw Object")
DEBUG_TOPIC(F,"&Focus Changes")
DEBUG_TOPIC(H,"&HAL/HEL Calls")
DEBUG_TOPIC(I,"Internal Fn Entered")
DEBUG_TOPIC(K,"NT Kernel Calls")
DEBUG_TOPIC(L,"&Locking/Ownership")
DEBUG_TOPIC(O,"M&odes")
DEBUG_TOPIC(M,"&Memory")
DEBUG_TOPIC(P,"API &Parameters")
DEBUG_TOPIC(R,"&Reference Counting")
DEBUG_TOPIC(S,"&Surface Objects")
DEBUG_TOPIC(T,"Fil&ters")
DEBUG_TOPIC(V,"&Video Memory allocation")
DEBUG_TOPIC(W,"&Windows and Handles")
DEBUG_TOPIC(X,"Ad-Hoc Message &X")

#undef PROF_SECT
#define PROF_SECT "DirectPlay"

#undef DPF_MODULE_NAME
#ifdef START_STR
	#define DPF_MODULE_NAME START_STR
#else
	#define DPF_MODULE_NAME "DPWSOCK"
#endif


/*
 * Use this identifier to define which line in WIN.INI [DirectX] denotes the
 * debug control string
 */
#undef DPF_CONTROL_LINE
#define DPF_CONTROL_LINE "DPlayDebug"

/*
 * It is important that the first DEBUG_TOPIC appear at the top line of this
 * file, and that no other lines are interspersed between DEBUG_TOPIC lines.
 * (The debug system uses the __LINE__ pseudo-variable to identify topics)
 */

/*
 * Definitions for DPF detail levels:
 *
 * 0: Error useful for application developers.
 * 1: Warning useful for application developers.
 * 2: API Entered
 * 3: API parameters, API return values
 * 4: Driver conversation
 *
 * 5: Deeper program flow notifications
 * 6: Dump structures 
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\vxd\w32ioctl.c ===
//***************************************************************************
//
//
//
//***************************************************************************

// Macros:

#define CreateSemaphore()       (VMM_Create_Semaphore(0))
#define DestroySemaphore(_s)    (VMM_Destroy_Semaphore(_s))

#define signal(_s)              (VMM_Signal_Semaphore(_s))
#define wait(_s)                (VMM_Wait_Semaphore_Ints(_s))
#define wait_idle(_s)           (VMM_Wait_Semaphore_Idle(_s))

#define CreateResourceLock()    (VMM_Create_Semaphore(1))
#define DestroyResourceLock(_s) (VMM_Destroy_Semaphore(_s))
#define lock(_s)                (VMM_Wait_Semaphore_Ints(_s))
#define unlock(_s)              (VMM_Signal_Semaphore(_s))

#define WANTVXDWRAPS

#include <basedef.h>
#include <vmm.h>
#include <vcomm.h>
#include <debug.h>
#include <vxdwraps.h>
#include <configmg.h>  
#include <vwin32.h>
#include <winerror.h>

typedef DIOCPARAMETERS *LPDIOC;

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#define ASSERT(_A) if(!(_A)){_asm int 3}

DWORD _stdcall LogInit(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams);
DWORD _stdcall LogWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams);
DWORD _stdcall StatsWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams);

#define FIRST_DEBUG_PROC 100

DWORD ( _stdcall *DebugProcs[] )(DWORD, DWORD, LPDIOC) = {
	LogInit,
	LogWrite,
	StatsWrite
};

#define MAX_DEBUG_PROC (sizeof(DebugProcs)/sizeof(DWORD)+FIRST_DEBUG_PROC-1)

typedef struct _LOGENTRY {
	DWORD   ThreadHandle;
	DWORD   tLogged;
	CHAR	debuglevel;
	CHAR    str[1];
} LOGENTRY, *PLOGENTRY;

PUCHAR pLog=NULL;
UINT   nCharsPerLine;
UINT   nLogEntries;

UINT   iLogWritePos;
UINT   nLogEntriesInUse;

UINT   LogInitCount=0;

UINT   LogLevel=255;
UINT   LogExact=FALSE;

UINT   LogLock=0;

#define Entry(_i) ((PLOGENTRY)(pLog+((sizeof(LOGENTRY)+nCharsPerLine)*_i)))

typedef struct {
	UINT	nLogEntries;
	UINT    nCharsPerLine;
} IN_LOGINIT, *PIN_LOGINIT;

typedef struct {
	UINT    hr;
} OUT_LOGINIT, *POUT_LOGINIT;

typedef struct {
	CHAR	debuglevel;
	CHAR    str[1];
} IN_LOGWRITE, *PIN_LOGWRITE;

typedef struct {
	UINT	hr;
} OUT_LOGWRITE, *POUT_LOGWRITE;

extern	UINT stat_ThrottleRate;
extern	UINT stat_BytesSent;
extern	UINT stat_BackLog;
extern	UINT stat_BytesLost;
extern	UINT stat_RemBytesReceived;
extern	UINT stat_Latency; 
extern	UINT stat_MinLatency;
extern	UINT stat_AvgLatency;
extern  UINT stat_AvgDevLatency;
extern	UINT stat_USER1;
extern	UINT stat_USER2;
extern	UINT stat_USER3;
extern  UINT stat_USER4;
extern  UINT stat_USER5;
extern  UINT stat_USER6;

typedef struct {
	UINT stat_ThrottleRate;
	UINT stat_BytesSent;
	UINT stat_BackLog;
 	UINT stat_BytesLost;
 	UINT stat_RemBytesReceived;
	UINT stat_Latency; 
	UINT stat_MinLatency;
	UINT stat_AvgLatency;
	UINT stat_AvgDevLatency;
	UINT stat_USER1;
	UINT stat_USER2;
	UINT stat_USER3;
	UINT stat_USER4;
	UINT stat_USER5;	// remote clock delta change from average
	UINT stat_USER6;    // sign of change
} IN_WRITESTATS, *PIN_WRITESTATS;

typedef struct {
	UINT	hr;
} OUT_WRITESTATS, *POUT_WRITESTATS;

VOID _stdcall ZeroStats();

/****************************************************************************
                  DPLAY_W32_DeviceIOControl
****************************************************************************/
DWORD _stdcall DPLAY_W32_DeviceIOControl(DWORD  dwService,
                                         DWORD  dwDDB,
                                         DWORD  hDevice,
                                         LPDIOC lpDIOCParms)
{
    DWORD dwRetVal = 0;

    if ( dwService == DIOC_OPEN )
    {
      dwRetVal = 0;	// I/F supported!
    }
    else if ( dwService == DIOC_CLOSEHANDLE )
    {
      if(LogInitCount)
      {
      	if(!(--LogInitCount)){
      		DestroyResourceLock(LogLock);
      		LogLock=0;
	      	C_HeapFree(pLog);
	      	pLog=NULL;
	      	ZeroStats();
	    }  	
      }	
      dwRetVal = VXD_SUCCESS;	// ok, we're closed.
    }
    else if ((dwService >= FIRST_DEBUG_PROC) && (dwService <= MAX_DEBUG_PROC))
    {
      dwRetVal = (DebugProcs[dwService-FIRST_DEBUG_PROC])
                 (dwDDB, hDevice, lpDIOCParms);
    }
    else
    {
      dwRetVal = ERROR_NOT_SUPPORTED;
    }
    return(dwRetVal);
}

DWORD _stdcall LogInit(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams)
{
	PIN_LOGINIT  pIn;
	POUT_LOGINIT pOut;
	UINT hr=0;

	pIn=(PIN_LOGINIT)lpDIOCParams->lpvInBuffer;
	pOut=(POUT_LOGINIT)lpDIOCParams->lpvOutBuffer;

	ASSERT(lpDIOCParams->cbInBuffer>=sizeof(IN_LOGINIT));
	ASSERT(lpDIOCParams->cbOutBuffer>=sizeof(OUT_LOGINIT));

	if(!LogInitCount){

		if(!pLog){
		
			LogLock=CreateResourceLock();
			nCharsPerLine	 = pIn->nCharsPerLine;
			nLogEntries   	 = pIn->nLogEntries;
			iLogWritePos 	 = 0;
			nLogEntriesInUse = 0;

			pLog=(CHAR *)C_HeapAllocate(pIn->nLogEntries*(sizeof(LOGENTRY)+pIn->nCharsPerLine),HEAPZEROINIT);
		}

		if(!pLog){
			pOut->hr=ERROR_NOT_ENOUGH_MEMORY;
		} else	{
			DbgPrint("DPLAYVXD: Logging on, allocated %d entries of length %d each\n",pIn->nLogEntries,pIn->nCharsPerLine);
			pOut->hr=ERROR_SUCCESS;
			LogInitCount=1;
		}	
		lpDIOCParams->lpcbBytesReturned=sizeof(OUT_LOGINIT);

	} else {
		pOut->hr=ERROR_SUCCESS;
		LogInitCount++;
	}
    return NO_ERROR;
}

DWORD _stdcall LogWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams)
{
	PIN_LOGWRITE pIn;
	POUT_LOGWRITE pOut;
	
	pIn=(PIN_LOGWRITE)lpDIOCParams->lpvInBuffer;
	pOut=(POUT_LOGWRITE)lpDIOCParams->lpvOutBuffer;

	ASSERT(lpDIOCParams->cbInBuffer>=sizeof(IN_LOGWRITE));
	ASSERT(lpDIOCParams->cbOutBuffer>=sizeof(OUT_LOGWRITE));

	if(LogInitCount){
		UINT BytesToCopy;
		PLOGENTRY pLogEntry;
		
		// make sure NULL terminated string
		BytesToCopy=lpDIOCParams->cbInBuffer-sizeof(IN_LOGWRITE)+1;
		if(BytesToCopy > nCharsPerLine){
			BytesToCopy=nCharsPerLine;
		}
		pIn->str[BytesToCopy-1]=0;

		lock(LogLock);
		
		pLogEntry=Entry(iLogWritePos);
		
		if(iLogWritePos+1 > nLogEntriesInUse){
			nLogEntriesInUse+=1;
		}
		iLogWritePos=(iLogWritePos+1)%nLogEntries;
		
		pLogEntry->ThreadHandle=GetThreadHandle();
		pLogEntry->tLogged=VMM_Get_System_Time();
		memcpy(&pLogEntry->debuglevel,pIn,BytesToCopy+sizeof(IN_LOGWRITE)-1);

		unlock(LogLock);
		
		pOut->hr=ERROR_SUCCESS;
	} else {
		pOut->hr=0x80000008;//E_FAIL
	}
	
	return NO_ERROR;
}

VOID SetLogLevel(UINT level, UINT fExact)
{
	LogExact=fExact;
	LogLevel=level;
	if(LogExact)
	{
		DbgPrint("DPLAY VXD: Log printing is Exact at level %d\n",LogLevel);
	} else {	
		DbgPrint("DPLAY VXD: Log printing is level %d and below\n",LogLevel);
	}	
}

DumpLogEntry(PLOGENTRY pLogEntry, UINT i, BOOL fResetTimeBase)
{
	static UINT timebase=0;
	if(pLogEntry){
		DbgPrint("%4d: %8x %6d %2x %s\n",i,pLogEntry->ThreadHandle, pLogEntry->tLogged-timebase,pLogEntry->debuglevel, pLogEntry->str);
		timebase=pLogEntry->tLogged;
	}	
	if(fResetTimeBase){
		timebase=0;
	}
}

VOID DumpLog(UINT relstart)
{
	UINT nToDump=50;
	UINT c=0,i;
	PLOGENTRY pLogEntry;
	UINT start;

	start=relstart;
	
	if(nLogEntriesInUse==nLogEntries){
		start=(iLogWritePos+start)%nLogEntries;
	}

	DumpLogEntry(NULL, 0, TRUE);

	DbgPrint("Total Entries: %d, Current Position %d, dumping from record %d, %d ahead of start\n",nLogEntriesInUse,iLogWritePos,start,relstart);

	for(i=start;i<nLogEntries && c<nToDump;i++){
		pLogEntry=Entry(i);
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	// Dump from beginning to current pos.
	for(i=0;i<iLogWritePos && c<nToDump;i++,c++){
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	
}

VOID DumpLogLast(UINT nToDump)
{
	UINT c=0,i;
	PLOGENTRY pLogEntry;
	UINT start;

	//BUGBUG: only works when all debug levels being dumped.
	if(iLogWritePos > nToDump){
		start=(iLogWritePos-nToDump);
	}else{
		start=(nLogEntries-(nToDump-iLogWritePos));
	}	

	DumpLogEntry(NULL,0,TRUE);
	
	DbgPrint("Total Entries: %d, Current Position %d, dumping from record %d\n",nLogEntriesInUse,iLogWritePos,start);

	for(i=start;i<nLogEntries && c<nToDump;i++){
		pLogEntry=Entry(i);
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	// Dump from beginning to current pos.
	for(i=0;i<iLogWritePos && c<nToDump;i++,c++){
		pLogEntry=Entry(i);
		if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
			c++;
			DumpLogEntry(pLogEntry,i,FALSE);
		}	
	}
	
}

VOID DumpWholeLog(VOID)
{
	UINT i;
	PLOGENTRY pLogEntry;

	DumpLogEntry(NULL,0,TRUE);

	// Dump from 1 after current pos to end.
	if(nLogEntriesInUse==nLogEntries){
		for(i=iLogWritePos;i<nLogEntries;i++){
			pLogEntry=Entry(i);
			if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
				DumpLogEntry(pLogEntry,i,FALSE);
			}	
		}
	}
	// Dump from beginning to current pos.
	for(i=0;i<iLogWritePos;i++){
			pLogEntry=Entry(i);
			if((LogExact)?(pLogEntry->debuglevel==LogLevel):(pLogEntry->debuglevel<=LogLevel)){
				DumpLogEntry(pLogEntry,i,FALSE);
			}	
	}
}

DWORD _stdcall StatsWrite(DWORD dwDDB, DWORD hDevice, LPDIOC lpDIOCParams)
{
	PIN_WRITESTATS  pIn;
	POUT_WRITESTATS pOut;
	UINT hr=0;
	DWORD cbInBuffer;
	
	pIn=(PIN_WRITESTATS)lpDIOCParams->lpvInBuffer;
	pOut=(POUT_WRITESTATS)lpDIOCParams->lpvOutBuffer;

	ASSERT(lpDIOCParams->cbInBuffer>=sizeof(DWORD));
	ASSERT(lpDIOCParams->cbOutBuffer>=sizeof(OUT_WRITESTATS));

	cbInBuffer=lpDIOCParams->cbInBuffer;
	
	if(pIn->stat_ThrottleRate!=0xFFFFFFFF)stat_ThrottleRate=pIn->stat_ThrottleRate;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_BytesSent!=0xFFFFFFFF)stat_BytesSent=pIn->stat_BytesSent;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_BackLog!=0xFFFFFFFF)stat_BackLog=pIn->stat_BackLog;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
 	if(pIn->stat_BytesLost!=0xFFFFFFFF)stat_BytesLost=pIn->stat_BytesLost;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
 	if(pIn->stat_RemBytesReceived!=0xFFFFFFFF)stat_RemBytesReceived=pIn->stat_RemBytesReceived;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_Latency!=0xFFFFFFFF)stat_Latency=pIn->stat_Latency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_MinLatency!=0xFFFFFFFF)stat_MinLatency=pIn->stat_MinLatency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_AvgLatency!=0xFFFFFFFF)stat_AvgLatency=pIn->stat_AvgLatency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_AvgDevLatency!=0xFFFFFFFF)stat_AvgDevLatency=pIn->stat_AvgDevLatency;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER1!=0xFFFFFFFF)stat_USER1=pIn->stat_USER1;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER2!=0xFFFFFFFF)stat_USER2=pIn->stat_USER2;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER3!=0xFFFFFFFF)stat_USER3=pIn->stat_USER3;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER4!=0xFFFFFFFF)stat_USER4=pIn->stat_USER4;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER5!=0xFFFFFFFF)stat_USER5=pIn->stat_USER5;
	cbInBuffer-=sizeof(DWORD);if(!cbInBuffer)goto end;
	if(pIn->stat_USER6!=0xFFFFFFFF)stat_USER6=pIn->stat_USER6;
end:
	pOut->hr=ERROR_SUCCESS;
	return NO_ERROR;	
}

VOID _stdcall ZeroStats()
{
	stat_ThrottleRate=0;
	stat_BytesSent=0;
	stat_BackLog=0;
 	stat_BytesLost=0;
 	stat_RemBytesReceived=0;
	stat_Latency=0; 
	stat_MinLatency=0;
	stat_AvgLatency=0;
	stat_AvgDevLatency=0;
	stat_USER1=0;
	stat_USER2=0;
	stat_USER3=0;
	stat_USER4=0;
	stat_USER5=0;
	stat_USER6=0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\fpm.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 - 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       fpm.c
 *  Content:	fixed size pool manager
 *
 *  History:
 *   Date		By		Reason
 *   ======		==		======
 *  12-18-97  aarono    Original
 ***************************************************************************/

#include "windows.h"
#include "dpsp.h"
#include "fpm.h"

#ifdef SENDEX

BOOL FN_BOOL_DUMMY(void *pvItem)
{
	return TRUE;
}

VOID FN_VOID_DUMMY(void *pvItem)
{
	return;
}

void * FPM_Get(LPFPOOL this)
{
	void * pvItem;

	EnterCriticalSection(&this->cs);
	
	if(!this->pPool){
	
		LeaveCriticalSection(&this->cs);
		pvItem = SP_MemAlloc(this->cbItemSize);

		if((pvItem) && !(*this->fnBlockInitAlloc)(pvItem) ){
			SP_MemFree(pvItem);
			pvItem=NULL;
		}

		EnterCriticalSection(&this->cs);

		if(pvItem){	
			this->nAllocated++;
		}
		
	} else {
		pvItem=this->pPool;
		this->pPool=*((void **)pvItem);
	}

	if(pvItem){
	
		(*this->fnBlockInit)(pvItem);
		
		this->nInUse++;
		if(this->nInUse > this->nMaxInUse){
			this->nMaxInUse = this->nInUse;
		}
	}

	LeaveCriticalSection(&this->cs);

	return pvItem;
}

#ifdef DEBUG
void DebugCheckList(void *pvList, void *pvItem)
{
	void *pvWalker;
	DWORD n=0;
	pvWalker=pvList;

	while(pvWalker){
		if(pvWalker==pvItem){
			DPF(0,"ERROR: Found Item %x in List %x, item # %d\n",pvList,pvItem,n);
			DEBUG_BREAK();
		}
		n++;
		pvWalker=*((void **)pvWalker);
	}
}
#else
#define DebugCheckList()
#endif

void FPM_Release(LPFPOOL this, void *pvItem)
{
	EnterCriticalSection(&this->cs);
	DebugCheckList(this->pPool, pvItem); //NOTE: debug only.
	this->nInUse--;
	*((void**)pvItem)=this->pPool;
	this->pPool=pvItem;
	LeaveCriticalSection(&this->cs);
	
}

void FPM_Scale(LPFPOOL this)
{
	void * pvItem;

	if(!InterlockedExchange(&this->bInScale,1)){

		EnterCriticalSection(&this->cs);

		while((this->nAllocated > this->nMaxInUse) && this->pPool){
			pvItem = this->pPool;
			this->pPool=*((void **)pvItem);
			LeaveCriticalSection(&this->cs);
			(*this->fnBlockFini)(pvItem);
			SP_MemFree(pvItem);
			EnterCriticalSection(&this->cs);
			this->nAllocated--;
		}
		
		this->nMaxInUse=this->nInUse;

		LeaveCriticalSection(&this->cs);

		InterlockedExchange(&this->bInScale,0);
	}
}

VOID FPM_Fini(LPFPOOL this, int bFORCE)
{
	void *pvItem;

	while(this->pPool){
		pvItem = this->pPool;
		this->pPool=*((void **)pvItem);
		(*this->fnBlockFini)(pvItem);
		SP_MemFree(pvItem);
		this->nAllocated--;
	}
	if(this->nAllocated){
		DPF(0,"WSOCK: Exiting with unfreed FPM pool items\n");
	}
	DeleteCriticalSection(&this->cs);
	SP_MemFree(this);
}

LPFPOOL FPM_Init(
	unsigned int size, 
	FN_BLOCKINITALLOC fnBlockInitAlloc,
	FN_BLOCKINIT      fnBlockInit, 
	FN_BLOCKFINI      fnBlockFini)
{
	LPFPOOL pPool;
	
	if(!(pPool=(LPFPOOL)SP_MemAlloc(sizeof(FPOOL))))
	{
	  return NULL;
	}

	InitializeCriticalSection(&pPool->cs);
	
	// by zero init.
	//pPool.pPool      = NULL;
	//pPool.nAllocated = 0;
	//pPool.nInUse     = 0;
	//pPool.nMaxInUse  = 0;
	//pPool.bInScale   = FALSE;

	if(fnBlockInitAlloc){
		pPool->fnBlockInitAlloc = fnBlockInitAlloc;
	} else {
		pPool->fnBlockInitAlloc = FN_BOOL_DUMMY;
	}
	if(fnBlockInit){
		pPool->fnBlockInit      = fnBlockInit;
	} else {
		pPool->fnBlockInit      = FN_VOID_DUMMY;
	}
	if(fnBlockFini){
		pPool->fnBlockFini      = fnBlockFini;
	} else {
		pPool->fnBlockFini      = FN_VOID_DUMMY;
	}

	pPool->Get    = FPM_Get;
	pPool->Release= FPM_Release;
	pPool->Scale  = FPM_Scale;
	pPool->Fini   = FPM_Fini;

	pPool->cbItemSize = size;
	
	return pPool;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dplay\dplay\wsock\dpsp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dplayi.h
 *  Content:	DirectPlay data structures
 *  History:
 *   Date		By	Reason
 *   ====		==	======
 *	1/96		andyco	created it
 *  1/26/96		andyco	list data structures
 *	4/10/96		andyco	removed dpmess.h
 *	4/23/96		andyco	added ipx support
 *	4/25/96		andyco	messages now have blobs (sockaddr's) instead of dwReserveds  
 *	8/10/96		kipo	update max message size to be (2^20) - 1
 *	8/15/96		andyco	added local data
 *	8/30/96		andyco	clean it up b4 you shut it down! added globaldata.
 *	9/3/96		andyco	bagosockets
 *	12/18/96	andyco	de-threading - use a fixed # of prealloced threads.
 *						cruised the enum socket / thread - use the system
 *						socket / thread instead. updated global struct.
 *	2/7/97		andyco	moved all per IDirectPlay globals into globaldata
 *	3/17/97		kipo	GetServerAddress() now returns an error so that we can
 *						return DPERR_USERCANCEL from the EnumSessions dialog
 *	3/25/97		andyco	dec debug lock counter b4 dropping lock! 
 *	4/11/97		andyco	added saddrControlSocket
 *	5/12/97		kipo	added ADDR_BUFFER_SIZE constant and removed unused variables
 *	5/15/97		andyco	added ipx spare thread to global data - used when nameserver 
 *						migrates to this host to make sure that old system receive 
 *						thread shuts down 
 *	6/22/97		kipo	include wsnwlink.h
 *	7/11/97		andyco	added support for ws2 + async reply thread
 *	8/25/97		sohailm	added DEFAULT_RECEIVE_BUFFERSIZE
 *	12/5/97		andyco	voice support
 *	01/5/97		sohailm	added fd big set related definitions and macros (#15244).
 *	1/20/98		myronth	#ifdef'd out voice support
 *	1/27/98		sohailm	added firewall support
 *  2/13/98     aarono  added async support
 *	2/18/98    a-peterz Comment byte order mess-up with SERVER_xxx_PORT constants
 *  3/3/98      aarono  Bug#19188 remove accept thread 
 *  12/15/98    aarono  make async enum run async
 *  01/12/2000  aarono  added rsip support
 *  09/12/2000  aarono  workaround winsock bug, only allow 1 pending async send per socket
 *                       otherwise data can get misordered. (MB#43990)
 **************************************************************************/

#ifndef __DPSP_INCLUDED__
#define __DPSP_INCLUDED__
#include "windows.h"
#include "windowsx.h"
#include "wsipx.h"
#include "wsnwlink.h"
#include "dplaysp.h"
#include "bilink.h"
#include "fpm.h"
#include "dpf.h"
#include "dputils.h"
#include "memalloc.h"
#include "resource.h"
#include <winsock.h>

// to turn off SendEx support, comment this flag out.
#define SENDEX 1

// NOTE! USE_RSIP and USE_NATHLP should be mutually exclusive
// to turn off RSIP support, comment this flag out.
//#define USE_RSIP 1

// turn ON to use NATHLP helper DLL 
#define USE_NATHELP 1

#if USE_NATHELP
#include "dpnathlp.h"
#endif

// use ddraw's assert code (see orion\misc\dpf.h)
#define ASSERT DDASSERT

typedef WORD PORT;
typedef UINT SOCKERR;

// server ports
// Oops! We forgot to convert these constants to net byte order in the code so we
// are really using port 47624 (0xBA08) instead of 2234 (0x08BA)
// We are living with the mistake.
#define SERVER_STREAM_PORT 2234
#define SERVER_DGRAM_PORT 2234

// range of ports used by sp (these are properly converted in the code)
#define DPSP_MIN_PORT	2300
#define DPSP_MAX_PORT	2400
#define DPSP_NUM_PORTS   ((DPSP_MAX_PORT - DPSP_MIN_PORT)+1)

#define SPMESSAGEHEADERLEN (sizeof(DWORD))
#define DEFAULT_RECEIVE_BUFFERSIZE	(4*1024)	// default receive buffer size per connection

// token means this message was received from a remote
// dplay.  
#define TOKEN 0xFAB00000

// helper_token means this message was forwarded by our server helper (host)
#define HELPER_TOKEN 0xCAB00000

// server_token means this message is exchanged with dplaysvr (needed to distinguish 
// messages from a remote dpwsockx)
#define SERVER_TOKEN 0xBAB00000

// tells receiver to reuse the connection for replies (needed to support fullduplex
// connections)
#define REUSE_TOKEN 0xAAB00000

// we linger on async sends for 2.5 seconds before hard closing them
// this avoids letting the socket get into the TIME_WAIT state for 4 minutes.
// essentially we are doing a close with linger for 2.5 secs followed by an abort.
#define LINGER_TIME 2500

// masks
#define TOKEN_MASK 0xFFF00000
#define SIZE_MASK (~TOKEN_MASK)

// maxmessagelen = 2^20 (need 12 bits for token)
#define SPMAXMESSAGELEN ( 1048576 - 1)
#define VALID_SP_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == TOKEN ? TRUE : FALSE)
#define VALID_HELPER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == HELPER_TOKEN ? TRUE : FALSE)
#define VALID_REUSE_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == REUSE_TOKEN ? TRUE : FALSE)
#define VALID_SERVER_MESSAGE(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK) == SERVER_TOKEN ? TRUE : FALSE)
#define SP_MESSAGE_SIZE(pMsg) ( (*((DWORD *)pMsg) & SIZE_MASK))
#define SP_MESSAGE_TOKEN(pMsg) ( (*((DWORD *)pMsg) & TOKEN_MASK))

#define VALID_DPWS_MESSAGE(pMsg) (  VALID_SP_MESSAGE(pMsg) || VALID_HELPER_MESSAGE(pMsg) || \
									VALID_SERVER_MESSAGE(pMsg) || VALID_REUSE_MESSAGE(pMsg) )
#define VALID_DPLAYSVR_MESSAGE(pMsg) (	VALID_SP_MESSAGE(pMsg) || VALID_SERVER_MESSAGE(pMsg) || \
										VALID_REUSE_MESSAGE(pMsg) )

// the actual value is ~ 1500 bytes.
// we use 1024 to be safe (IPX won't packetize for us - it can only 
// send what the underlying net can handle (MTU))
#define IPX_MAX_DGRAM 1024

// relation of timeout to latency
#define TIMEOUT_SCALE 10
#define SPTIMEOUT(latency) (TIMEOUT_SCALE * latency)

// the default size of the socket cache (gBagOSockets)
#define MAX_CONNECTED_SOCKETS 64

// the initial size of the receive list
#define INITIAL_RECEIVELIST_SIZE 16

// version number for service provider
#define SPMINORVERSION      0x0000				// service provider-specific version number
#define VERSIONNUMBER		(DPSP_MAJORVERSION | SPMINORVERSION) // version number for service provider

// biggest user enterable addess
#define ADDR_BUFFER_SIZE 128
								 
// macro picks the service socket depending on ipx vs. tcp
// ipx uses dgram, tcp uses stream
#define SERVICE_SOCKET(pgd) ( (pgd->AddressFamily == AF_IPX) \
	? pgd->sSystemDGramSocket : pgd->sSystemStreamSocket)

#if USE_RSIP

#define SERVICE_SADDR_PUBLIC(pgd)( (pgd->sRsip == INVALID_SOCKET) \
	? (NULL) : (&pgd->saddrpubSystemStreamSocket) )

#define DGRAM_SADDR_RSIP(pgd) ( (pgd->sRsip == INVALID_SOCKET) \
	? (NULL) : (&pgd->saddrpubSystemDGramSocket) )

#elif USE_NATHELP

#define SERVICE_SADDR_PUBLIC(pgd)( (pgd->pINatHelp) \
	? (&pgd->saddrpubSystemStreamSocket):NULL )

#define DGRAM_SADDR_RSIP(pgd) ( (pgd->pINatHelp) \
	? (&pgd->saddrpubSystemDGramSocket):NULL )

#else

#define SERVICE_SADDR_PUBLIC(pgd) NULL
#define DGRAM_SADDR_RSIP(pgd) NULL
#endif

//
// In order to listen to any number of sockets we need our own version
// of fd_set and FD_SET().  We call them fd_big_set and FD_BIG_SET().
//
typedef struct fd_big_set {
    u_int   fd_count;           // how many are SET?   
    SOCKET  fd_array[0];        // an array of SOCKETs 
} fd_big_set;

// stolen from winsock2.h

#ifndef _WINSOCK2API_

typedef HANDLE WSAEVENT;

typedef struct _WSAOVERLAPPED {
    DWORD        Internal;
    DWORD        InternalHigh;
    DWORD        Offset;
    DWORD        OffsetHigh;
    WSAEVENT     hEvent;
} WSAOVERLAPPED, FAR * LPWSAOVERLAPPED;

typedef struct _WSABUF {
    u_long      len;     /* the length of the buffer */
    char FAR *  buf;     /* the pointer to the buffer */
} WSABUF, FAR * LPWSABUF;
 
#endif // _WINSOCK2API_

#define MAX_SG 9
typedef WSABUF SENDARRAY[MAX_SG];
typedef SENDARRAY *PSENDARRAY;

#define SI_RELIABLE 0x0000001
#define SI_DATAGRAM 0x0000002
#define SI_INTERNALBUFF 0x00000004

typedef struct _SENDINFO {
	WSAOVERLAPPED wsao;
	SENDARRAY     SendArray;	// Array of buffers
	DWORD         dwFlags;
	DWORD         dwSendFlags;  // DPLAY Send Flags.
	UINT          iFirstBuf;	// First buffer in array to use
	UINT          cBuffers;		// number of buffers to send (starting at iFirstBuf)
	BILINK        PendingSendQ; // when we're pending
	BILINK		  PendingConnSendQ; // send queue for pending connections, also for pending when an async send is outstanding.
	BILINK        ReadyToSendQ; // still waiting to send on this queue.
	DPID          idTo;
	DPID          idFrom;
	SOCKET        sSocket;		// reliable sends
	SOCKADDR      sockaddr;		// datagram sends
	DWORD_PTR     dwUserContext;
	DWORD         dwMessageSize;
	DWORD         RefCount;
	LONG          Status;
	struct _PLAYERCONN *pConn;
	struct _GLOBALDATA *pgd;
	IDirectPlaySP * lpISP;			//  indication interface
} SENDINFO, *PSENDINFO, FAR *LPSENDINFO;

//
// This code is stolen from winsock.h.  It does the same thing as FD_SET()
// except that it assumes the fd_array is large enough.  AddSocketToReceiveList()
// grows the buffer as needed, so this better always be true.
//

#define FD_BIG_SET(fd, address) do { \
    ASSERT((address)->dwArraySize > (address)->pfdbigset->fd_count); \
    (address)->pfdbigset->fd_array[(address)->pfdbigset->fd_count++]=(fd);\
} while(0)

typedef struct fds {
	DWORD		dwArraySize;	// # of sockets that can be stored in pfdbigset->fd_array buffer
	fd_big_set	*pfdbigset;		
} FDS;

typedef struct _CONNECTION
{
	SOCKET	socket;				// socket we can receive off of
	DWORD	dwCurMessageSize;	// current message size
	DWORD	dwTotalMessageSize;	// total message size
	SOCKADDR sockAddr;			// addresses connected to
	LPBYTE	pBuffer;			// points to either default or temporary receive buffer
	LPBYTE	pDefaultBuffer;		// default receive buffer (pBuffer points to this by default)
	// added in DX6
	DWORD	dwFlags;			// connection attributes e.g. SP_CONNECION_FULLDUPLEX
} CONNECTION, *LPCONNECTION;

typedef struct _RECEIVELIST
{
	UINT nConnections;			// how many peers are we connected to
	LPCONNECTION pConnection;// list of connections
} RECEIVELIST;

typedef struct _REPLYLIST * LPREPLYLIST;
typedef struct _REPLYLIST
{
	LPREPLYLIST pNextReply; // next reply in list
	LPVOID	lpMessage; // bufffer to send
	SOCKADDR sockaddr;  // addr to send to
	DWORD dwMessageSize;
	SOCKET sSocket; // socket to send on
	LPBYTE pbSend; // index into message pointing to next byte to send
	DWORD  dwBytesLeft; // how many bytes are left to send
	DWORD  dwPlayerTo; // dpid of to player, 0=>not in use.
	DWORD  tSent;	// time we sent the last bit of reply.
} REPLYLIST;

// w store one of these w/ each sys player
typedef struct _SPPLAYERDATA 
{
	SOCKADDR saddrStream,saddrDatagram;
}SPPLAYERDATA,*LPSPPLAYERDATA;

	
// the message header
typedef struct _MESSAGEHEADER
{
	DWORD dwMessageSize; // size of message
	SOCKADDR sockaddr;
} MESSAGEHEADER,*LPMESSAGEHEADER;


// this is one element in our bagosockets
typedef struct _PLAYERSOCK
{
	SOCKET sSocket;
	DPID dwPlayerID;
	// added in DX6
	SOCKADDR sockaddr;
	DWORD dwFlags;			// SP_CONNECTION_FULLDUPLEX, etc.
} PLAYERSOCK,*LPPLAYERSOCK;

// PLAYERCONN structure is used for describing the reliable connection between
// this node and the remote player ID.
#define PLAYER_HASH_SIZE	256
#define SOCKET_HASH_SIZE  256

#define PLYR_CONN_PENDING		0x00000001	// connection pending.
#define PLYR_ACCEPT_PENDING		0x00000002  // expecting an accept(got WSAEISCONN on connect attempt).
#define PLYR_CONNECTED       	0x00000004  // connection has succeeded.
#define PLYR_ACCEPTED 			0x00000008
// players using old dpwsockx will use seperate inbound/outbound connections.
#define PLYR_NEW_CLIENT			0x00000010  // player uses just 1 socket.
#define PLYR_SOCKHASH			0x00000020
#define PLYR_DPIDHASH			0x00000040
#define PLYR_PENDINGLIST      0x00000080
#define PLYR_OLD_CLIENT			0x00000100

#define PLYR_DESTROYED        0x80000000	// already Dumped existence ref.

typedef struct _PLAYERCONN {
	struct _PLAYERCONN *pNextP;			// dwPlayerId hash table list.
	struct _PLAYERCONN *pNextS;			// IOSock hash table list.
	DWORD       dwRefCount;				// References.
	DPID		dwPlayerID;
	SOCKET		sSocket;
	DWORD		lNetEventsSocket;
	SOCKET		sSocketIn;				// they may have a different inbound socket.
	DWORD		lNetEventsSocketIn;
	DWORD		dwFlags;
VOL	BOOL		bSendOutstanding;		// if we have a send in process.  only 1 at a time per connection.
	BILINK		PendingConnSendQ;			// Sends waiting for connection to complete, and now also for