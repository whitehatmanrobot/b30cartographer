OR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 4, 4, 17, 17, hdc4Lines, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 25, 25, hdc4Lines, 3, 3, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 26, 26, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 288, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test 4 to 8 blting generally.

**************************************************************************/

    if(!BitBlt(hdc8Lines, 4,4, 16, 16, hdc4Lines, 4, 4, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 4, 4, 17, 17, hdc4Lines, 4, 4, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 25, 25, hdc4Lines, 3, 3, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 26, 26, hdc4Lines, 0, 0, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, 0x00010000))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 320, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*********************************************************************

    MaskBlt solid brush on 8 tests

***********************************************************************/

    PatBlt(hdcClone, 0, 0, 320, 320, WHITENESS);

    MaskBlt(hdcClone, 32, 32, 32, 32, hdc8Lines, 0, 0, hbm1Cat, 0, 0,
		      0xAACC0000);

    BitBlt(hdcScreen, 0, 0, 66, 66, hdcClone, 0, 0, SRCCOPY);

    if(!BitBlt(hdcScreen, 0, 400, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

// Clean up time, delete it all.

    if (SelectPalette(hdcScreen, hpalOld, 0) != hpalVGA)
	DbgPrint("hpalVGA not given back\n");

    if (!DeleteObject(hpalVGA))
	DbgPrint("failed to delete hpalVGA\n");

    if (hbmClone != SelectObject(hdcClone, hbmDefault))
	DbgPrint("Cleanup hbm 1 wrong\n");
    if (hbm1Cat != SelectObject(hdc1Cat, hbmDefault))
	DbgPrint("Cleanup hbm 2 wrong\n");
    if (hbm1Cat0 != SelectObject(hdc1Cat0, hbmDefault))
	DbgPrint("Cleanup hbm 3 wrong\n");
    if (hbm4Lines != SelectObject(hdc4Lines, hbmDefault))
	DbgPrint("Cleanup hbm 4 wrong\n");
    if (hbm4Lines0 != SelectObject(hdc4Lines0, hbmDefault))
	DbgPrint("Cleanup hbm 5 wrong\n");
    if (hbm8Lines != SelectObject(hdc8Lines, hbmDefault))
	DbgPrint("Cleanup hbm 6 wrong\n");
    if (hbm8Lines0 != SelectObject(hdc8Lines0, hbmDefault))
	DbgPrint("Cleanup hbm 7 wrong\n");
    if (hbm1BigCat != SelectObject(hdc1BigCat, hbmDefault))
	DbgPrint("Cleanup hbm 8 wrong\n");
    if (hbm1BigCat0 != SelectObject(hdc1BigCat0, hbmDefault))
	DbgPrint("Cleanup hbm 9 wrong\n");

    SelectObject(hdc1Cat,hbrDefault);
    SelectObject(hdc1Cat0,hbrDefault);
    SelectObject(hdc4Lines,hbrDefault);
    SelectObject(hdc4Lines0,hbrDefault);
    SelectObject(hdc8Lines,hbrDefault);
    SelectObject(hdc8Lines0,hbrDefault);
    SelectObject(hdc1BigCat,hbrDefault);
    SelectObject(hdc1BigCat0,hbrDefault);
    SelectObject(hdcClone,hbrDefault);
    SelectObject(hdcScreen,hbrDefault);

// Delete DC's

    if (!DeleteDC(hdc1BigCat))
	DbgPrint("Failed to delete hdc 1\n");
    if (!DeleteDC(hdc1BigCat0))
	DbgPrint("Failed to delete hdc 2\n");
    if (!DeleteDC(hdc1Cat))
	DbgPrint("Failed to delete hdc 3\n");
    if (!DeleteDC(hdc1Cat0))
	DbgPrint("Failed to delete hdc 4\n");
    if (!DeleteDC(hdc4Lines))
	DbgPrint("Failed to delete hdc 5\n");
    if (!DeleteDC(hdc4Lines0))
	DbgPrint("Failed to delete hdc 6\n");
    if (!DeleteDC(hdc8Lines))
	DbgPrint("Failed to delete hdc 7\n");
    if (!DeleteDC(hdc8Lines0))
	DbgPrint("Failed to delete hdc 8\n");
    if (!DeleteDC(hdcClone))
	DbgPrint("Failed to delete hdc 9\n");

// Delete Bitmaps

    if (!DeleteObject(hbm1Cat))
	DbgPrint("ERROR failed to delete 1\n");
    if (!DeleteObject(hbm1Cat0))
	DbgPrint("ERROR failed to delete 2\n");
    if (!DeleteObject(hbm4Lines))
	DbgPrint("ERROR failed to delete 3\n");
    if (!DeleteObject(hbm4Lines0))
	DbgPrint("ERROR failed to delete 4\n");
    if (!DeleteObject(hbm8Lines))
	DbgPrint("ERROR failed to delete 5\n");
    if (!DeleteObject(hbm8Lines0))
	DbgPrint("ERROR failed to delete 6\n");
    if (!DeleteObject(hbm1BigCat))
	DbgPrint("ERROR failed to delete 7\n");
    if (!DeleteObject(hbm1BigCat0))
	DbgPrint("ERROR failed to delete 8\n");
    if (!DeleteObject(hbmClone))
	DbgPrint("ERROR failed to delete 9\n");

    if (!DeleteObject(hbmDefault))
	DbgPrint("ERROR deleted default bitmap\n");

// Delete the brushes

    if (!DeleteObject(hbr1))
	DbgPrint("failed to delete pattern brush 1\n");

    if (!DeleteObject(hbr4))
	DbgPrint("failed to delete pattern brush 2\n");

    if (!DeleteObject(hbr8))
	DbgPrint("failed to delete pattern brush 3\n");

    if (!DeleteObject(hbrushGreen))
	DbgPrint("failed to delete pattern brush 4\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftbm4.c ===
/******************************Module*Header*******************************\
* Module Name: genblt.c
*
* This is a test of the genblt functions
*
* Created: 8-NOV-1990 12:52:00
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

// This is to create a bitmapinfo structure

typedef struct _BITMAPINFOPAT2
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[20];
} BITMAPINFOPAT2;

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFOPAT;

static BITMAPINFOPAT bmiPat =
{
    {
        sizeof(BITMAPINFOHEADER),
        32,
        32,
        1,
        1,
        BI_RGB,
        (32 * 32),
        0,
        0,
        2,
        2
    },

    {                               // B    G    R
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0,   0 },       // 0
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
        { 0xC0,0xC0,0xC0,0 },       // 7

        { 0x80,0x80,0x80,0 },       // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};


static BITMAPINFOPAT bmiPat1 =
{
    {
        sizeof(BITMAPINFOHEADER),
        64,
        64,
        1,
        4,
        BI_RGB,
        (64 * 64 / 2),
        0,
        0,
        16,
        16
    },

    {                               // B    G    R
        { 0xFF,0xFF,0xFF,0 },       // 15
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0,   0,   0 },       // 12
        { 0,   0xFF,0xFF,0 },       // 11
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0,   0xFF,0 },       // 9
        { 0x80,0x80,0x80,0 },       // 8

        { 0xC0,0xC0,0xC0,0 },       // 7
        { 0x80,0x80,0,   0 },       // 6
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0,   0,   0 },       // 4
        { 0,   0x80,0x80,0 },       // 3
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0x80,0 },       // 1
        { 0,   0,   0,   0 }        // 0
    }
};


static BYTE abBitCat[] = {0xFF, 0xFF, 0xFF, 0xFF,
                          0x80, 0xA2, 0x45, 0x01,
                          0x80, 0xA2, 0x45, 0x01,
                          0x80, 0xA2, 0x45, 0xE1,
                          0x80, 0xA2, 0x45, 0x11,
                          0x80, 0xA2, 0x45, 0x09,
                          0x80, 0x9C, 0x39, 0x09,
                          0x80, 0xC0, 0x03, 0x05,

                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x10, 0x08, 0x05,
                          0x80, 0x10, 0x08, 0x09,

                          0x80, 0x10, 0x08, 0x11,
                          0x80, 0x08, 0x10, 0x21,
                          0x80, 0x08, 0x10, 0xC1,
                          0x80, 0x08, 0x10, 0x09,
                          0x80, 0x07, 0xE0, 0x09,
                          0x80, 0x08, 0x10, 0x09,
                          0x80, 0xFC, 0x3F, 0x09,
                          0x80, 0x09, 0x90, 0x09,

                          0x80, 0xFC, 0x3F, 0x01,
                          0x80, 0x08, 0x10, 0x01,
                          0x80, 0x1A, 0x58, 0x01,
                          0x80, 0x28, 0x14, 0x01,
                          0x80, 0x48, 0x12, 0x01,
                          0x80, 0x8F, 0xF1, 0x01,
                          0x81, 0x04, 0x20, 0x81,
                          0xFF, 0xFF, 0xFF, 0xFF } ;

static BYTE abBigCat[] = {
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;


/**************************************************************************\
           Couple of models for of 4 bpp bitmaps to be used as brushes

 cx = 17 , cy = 11

00000000000000000  // 10
00000000ff0000000  // 9
000000ff00ff00000  // 8
00000ff0000ff0000  // 7
0000ff000000ff000  // 6
000ff00000000ff00  // 5
000ffffffffffff00  // 4
000ff00000000ff00  // 3
000ff00000000ff00  // 2
00ffff000000ffff0  // 1
00000000000000000  // 0

00000000000000000  // 0
00ffff000000ffff0  // 1
000ff00000000ff00  // 2
000ff00000000ff00  // 3
0000ffffffffff000  // 4
0000ffffffffff000  // 5
0000ff000000ff000  // 6
00000ff0000ff0000  // 7
000000ffffff00000  // 8
00000000ff0000000  // 9
00000000000000000  // 10


\**************************************************************************/



BYTE ajA[] =
{

0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  // 0
0x00, 0xff, 0xff, 0x00,  0x00, 0x00, 0xff, 0xff,  0x00, 0x00, 0x00, 0x00,  // 1
0x00, 0x0f, 0xf0, 0x00,  0x00, 0x00, 0x0f, 0xf0,  0x00, 0x00, 0x00, 0x00,  // 2
0x00, 0x0f, 0xf0, 0x00,  0x00, 0x00, 0x0f, 0xf0,  0x00, 0x00, 0x00, 0x00,  // 3
0x00, 0x00, 0xff, 0xff,  0xff, 0xff, 0xff, 0x00,  0x00, 0x00, 0x00, 0x00,  // 4
0x00, 0x00, 0xff, 0xff,  0xff, 0xff, 0xff, 0x00,  0x00, 0x00, 0x00, 0x00,  // 5
0x00, 0x00, 0xff, 0x00,  0x00, 0x00, 0xff, 0x00,  0x00, 0x00, 0x00, 0x00,  // 6
0x00, 0x00, 0x0f, 0xf0,  0x00, 0x0f, 0xf0, 0x00,  0x00, 0x00, 0x00, 0x00,  // 7
0x00, 0x00, 0x00, 0xff,  0xff, 0xff, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  // 8
0x00, 0x00, 0x00, 0x00,  0xff, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  // 9
0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00   // 10


};



BITMAPINFOPAT bmiLetterA =
{
    {
        sizeof(BITMAPINFOHEADER),
        17,         // cx
        11,         // cy
        1,          // biPlanes
        4,          // 4bpp
        BI_RGB,     // not compressed
        (12 * 11),  // bytes used
        0,          // x resolution (pel/meter) ignored
        0,          // x resolution (pel/meter) ignored
        16,         // 2 colors used
        16          // 2 important colors
    },

    {                               // B    G    R
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0,   0 },       // 0
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
        { 0xC0,0xC0,0xC0,0 },       // 7

        { 0x80,0x80,0x80,0 },       // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};


/**************************************************************************\

 cx = 15 , cy = 11;

000000000000000
000cc00cccccc00
000cc00cccccc00
00ccc00cc000000
0cccc00ccccc000
000cc00cc00cc00
000cc000000cc00
000cc00cc00cc00
000cc000cccc000
000cc0000cc0000
000000000000000

\**************************************************************************/

BYTE ajNo15[] =
{

0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00,  // 10
0x00, 0x0c, 0xc0, 0x00,  0x0c, 0xc0, 0x00, 0x00,  // 9
0x00, 0x0c, 0xc0, 0x00,  0xcc, 0xcc, 0x00, 0x00,  // 8
0x00, 0x0c, 0xc0, 0x0c,  0xc0, 0x0c, 0xc0, 0x00,  // 7
0x00, 0x0c, 0xc0, 0x00,  0x00, 0x0c, 0xc0, 0x00,  // 6
0x00, 0x0c, 0xc0, 0x0c,  0xc0, 0x0c, 0xc0, 0x00,  // 5
0x0c, 0xcc, 0xc0, 0x0c,  0xcc, 0xcc, 0x00, 0x00,  // 4
0x00, 0xcc, 0xc0, 0x0c,  0xc0, 0x00, 0x00, 0x00,  // 3
0x00, 0x0c, 0xc0, 0x0c,  0xcc, 0xcc, 0xc0, 0x00,  // 2
0x00, 0x0c, 0xc0, 0x0c,  0xcc, 0xcc, 0xc0, 0x00,  // 1
0x00, 0x00, 0x00, 0x00,  0x00, 0x00, 0x00, 0x00   // 0

};

BITMAPINFOPAT bmiNo15 =
{
    {
        sizeof(BITMAPINFOHEADER),
        15,         // cx
        11,         // cy
        1,          // biPlanes
        4,          // 4bpp
        BI_RGB,     // not compressed
        (8 * 11),   // bytes used
        0,          // x resolution (pel/meter) ignored
        0,          // x resolution (pel/meter) ignored
        16,          // 2 colors used
        16           // 2 important colors
    },

    {                               // B    G    R
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0,   0 },       // 0
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
        { 0xC0,0xC0,0xC0,0 },       // 7

        { 0x80,0x80,0x80,0 },       // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};


/**************************************************************************\
   dimensions   14 X 20

00000000000000   19
00000aaaa00000   18
0000aaaaaa0000   17
000aa0000aa000   16
00aa000000aa00   15
0aa00000000aa0   14
0aa00000000aa0   13
00aa000000aa00   12
000aa0000aa000   11
0000aaaaaa0000   10
0000aaaaaa0000   9
000aa0000aa000   8
00aa000000aa00   7
0aa00000000aa0   6
0aa00000000aa0   5
00aa000000aa00   4
000aa0000aa000   3
0000aaaaaa0000   2
00000aaaa00000   1
00000000000000   0

\**************************************************************************/


BYTE aj8[] =
{
 0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0x0, 0xa, 0xa, 0xa,  0xa, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0xa, 0xa, 0xa, 0xa,  0xa, 0xa, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,  0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,
 0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,
 0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,  0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0xa, 0xa, 0xa, 0xa,  0xa, 0xa, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0xa, 0xa, 0xa, 0xa,  0xa, 0xa, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,  0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,
 0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,
 0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,
 0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0xa, 0xa,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0xa,  0xa, 0x0, 0x0, 0x0,  0x0, 0xa, 0xa, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0xa, 0xa, 0xa, 0xa,  0xa, 0xa, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0x0, 0xa, 0xa, 0xa,  0xa, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,
 0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0,  0x0, 0x0, 0x0, 0x0

};

BITMAPINFOPAT2 bmi8 =
{
    {
        sizeof(BITMAPINFOHEADER),
        14,
        20,
        1,
        8,
        BI_RGB,
        16 * 20,
        0,
        0,
        20,
        20
    },

    {                               // B    G    R
        { 0xFF,0xFF,0xFF,0 },       // 15
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0,   0,   0 },       // 12
        { 0,   0xFF,0xFF,0 },       // 11
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0,   0xFF,0 },       // 9
        { 0x80,0x80,0x80,0 },       // 8

        { 0xC0,0xC0,0xC0,0 },       // 7
        { 0x80,0x80,0,   0 },       // 6
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0,   0,   0 },       // 4
        { 0,   0x80,0x80,0 },       // 3
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0x80,0 },       // 1
        { 0,   0,   0,   0 },       // 0

        { 0,   0,   0x80,0 },       // 1
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0,   0xFF,0 },       // 9
        { 0xFF,0,   0xFF,0 }        // 13
    }
};



/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  22-Jul-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vTestStink4(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    HBITMAP hbm1Cat,  hbm1Cat0;
    HBITMAP hbm4Clone, hbmDefault;

    HDC hdc4Clone;
    HDC hdc1Cat;

    HBRUSH hbrushGreen, hbrDefault;

    ULONG ScreenWidth, ScreenHeight;
    ULONG cx, cy;

// bodin added these

    HBITMAP hbm8;

    HBITMAP hbm4LetterA, hbm4No15;
    HDC     hdc4LetterA, hdc4No15, hdc8;
    HBRUSH  hbr4LetterA,  hbr4No15;

    hwnd = hwnd;
    prcl = prcl;

    DbgBreakPoint();

    ScreenWidth  = GetDeviceCaps(hdcScreen, HORZRES);
    ScreenHeight = GetDeviceCaps(hdcScreen, VERTRES);

// We create 6 formats of bitmaps for testing.  2 of each. 1 backup
// so we can refresh after every draw.  The ****0 is the backup.

    hdc4Clone   =   CreateCompatibleDC(hdcScreen);

    hdc1Cat  =     CreateCompatibleDC(hdcScreen);

    hdc4LetterA =  CreateCompatibleDC(hdcScreen);

    hdc4No15 =     CreateCompatibleDC(hdcScreen);

    hdc8      =    CreateCompatibleDC(hdcScreen);

    if ((hdc4LetterA == 0) || (hdc4No15 == 0))
        DbgPrint("ERROR hdc creation hdcA = %lu, hdc15 = %lu \n", hdc4LetterA, hdc4No15);

    bmiPat.bmiHeader.biWidth = 32;

    hbm1Cat = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmiPat,
                          CBM_INIT,
                          abBitCat,
			  (BITMAPINFO *) &bmiPat,
                          DIB_RGB_COLORS);

    hbm4LetterA = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmiLetterA,
                          CBM_INIT,
                          ajA,
			  (BITMAPINFO *) &bmiLetterA,
                          DIB_RGB_COLORS);

    hbm4No15 = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmiNo15,
                          CBM_INIT,
                          ajNo15,
			  (BITMAPINFO *) &bmiNo15,
                          DIB_RGB_COLORS);

    hbm8 = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmi8,
                          CBM_INIT,
                          aj8,
			  (BITMAPINFO *) &bmi8,
                          DIB_RGB_COLORS);

    bmiNo15.bmiHeader.biWidth = cx = ScreenWidth / 2;
    bmiNo15.bmiHeader.biHeight = cy = ScreenHeight / 2;

    hbm4Clone = CreateDIBitmap(hdcScreen,
			  (BITMAPINFOHEADER *) &bmiNo15,
                          0,        // uninitialized
                          NULL,     // pBits uninitialized
			  (BITMAPINFO *) &bmiNo15,
                          DIB_RGB_COLORS);

    if ((hbm1Cat == 0) || (hbm4LetterA == 0) || (hbm4No15 == 0) || (hbm8 == 0))
        DbgPrint("ERROR: bitmaps\n");

    hbmDefault = SelectObject(hdc4Clone, hbm4Clone);

    if (hbmDefault == (HBITMAP) 0)
	DbgPrint("hbm Old is invalid\n");

    if (hbmDefault != SelectObject(hdc1Cat, hbm1Cat))
	DbgPrint("hbmDefault wrong hbm4Clone\n");

    if (hbmDefault != SelectObject(hdc4LetterA, hbm4LetterA))
	DbgPrint("hbmDefault wrong 2\n");

    if (hbmDefault != SelectObject(hdc4No15, hbm4No15))
	DbgPrint("hbmDefault wrong 3\n");

    if (hbmDefault != SelectObject(hdc8, hbm8))
	DbgPrint("hbmDefault wrong hbm8\n");

    {
        DbgPrint("blting hdc1Cat\n");

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc1Cat, 0, 0, SRCCOPY);


     // try to get to my code using Patrick's hack

        DbgPrint("blting hdc1Cat using my code\n");

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);

        // this gets to my code

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, hdc1Cat, 0, 0, 0x00010000);
        // use different phase to see if the things work
        BitBlt(hdc4Clone, 15, 40, ScreenWidth, ScreenHeight, hdc1Cat, 0, 0, 0x00010000);

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc4Clone, 0, 0, SRCCOPY); // srccopy

    }

    {
        DbgPrint("blting hdc8\n");

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc8, 0, 0, SRCCOPY);

     // try to get to my code using Patrick's hack

        DbgPrint("blting hdc8 using my code\n");

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);

        // this gets to my code

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, hdc8, 0, 0, 0x00010000);
        BitBlt(hdc4Clone, 7, 40, ScreenWidth, ScreenHeight, hdc8, 0, 0, 0x00010000);

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc4Clone, 0, 0, SRCCOPY); // srccopy

    }


    {
        DbgPrint("blting hdc4LetterA \n");

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc4LetterA, 0, 0, SRCCOPY);

    // try to get to my code using Patrick's hack

        DbgPrint("blting hdc4LetterA using my code\n");
        DbgBreakPoint();

    // clear

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, hdc4LetterA, 0, 0, 0x00010000);
        BitBlt(hdc4Clone, 5, 40, ScreenWidth, ScreenHeight, hdc4LetterA, 0, 0, 0x00010000);

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc4Clone, 0, 0, SRCCOPY);
    }

    {
        DbgPrint("blting hdc4No15 \n");

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc4No15, 0, 0, SRCCOPY);

        DbgPrint("blting hdc4No15 using my code\n");
        DbgBreakPoint();

    // clear

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);

        BitBlt(hdc4Clone, 0, 0, ScreenWidth, ScreenHeight, hdc4No15, 0, 0, 0x00010000);
        BitBlt(hdc4Clone, 11, 40, ScreenWidth, ScreenHeight, hdc4No15, 0, 0, 0x00010000);

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, hdc4Clone, 0, 0, SRCCOPY);
    }

// finally create some  brushes

    hbrushGreen  = CreateSolidBrush(RGB(0x00,0xff,0x00));

    hbrDefault = SelectObject(hdc4Clone, hbrushGreen);

    hbr4LetterA = CreatePatternBrush(hbm4LetterA);
    hbr4No15 = CreatePatternBrush(hbm4No15);

// let us first demonstrate that all of our bitmaps and brushes work


    {
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, cx, cy, (HDC) 0, 0, 0, 0);

        DbgPrint("hbr4LetterA\n");

        SelectObject(hdc4Clone, hbr4LetterA);

    // this should force it into my code

        PatBlt(hdc4Clone, 0,0, cx, cy/2 - 10, 0x00020000);  // patcopy
        PatBlt(hdc4Clone, 17, cy/2 + 10, cx, cy, 0x00020000);  // patcopy

        BitBlt(hdcScreen, 0, 0, cx, cy, (HDC) hdc4Clone, 0, 0, SRCCOPY);
    }



    {

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, cx, cy, (HDC) 0, 0, 0, 0);

        DbgPrint("hbr4No15 \n");

        SelectObject(hdc4Clone, hbr4No15);

    // this should force it into my code

        PatBlt(hdc4Clone, 0,0, cx, cy/2 - 10, 0x00020000);
        PatBlt(hdc4Clone, 17,cy/2 + 10, cx, cy/2 + 1, 0x00020000);

        BitBlt(hdcScreen, 0, 0, cx, cy, (HDC) hdc4Clone, 0, 0, SRCCOPY);

    }

// this is masked blt test

    {
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, cx, cy, (HDC) 0, 0, 0, 0);

        DbgPrint("masked blt with cat as a mask \n");

        //  hbr4No15 is selected as a brush

    // this should force it into my code

        MaskBlt(hdc4Clone, 0,0, cx, 45,
                (HDC)0, 0, 0,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x00020000                // fore = blackness, back = patlbt
                );

        MaskBlt(hdc4Clone, 11, 50, cx, 45,
                (HDC)0, 0, 0,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x00020000                // fore = blackness, back = patlbt
                );

        MaskBlt(hdc4Clone, 0, 100, cx, 45,
                (HDC)0, 0, 0,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 7, 0,            // hbmMsk, xMsk, yMsk
                0x00020000                // fore = blackness, back = patlbt
                );

        MaskBlt(hdc4Clone, 11,150, cx, 45,
                (HDC)0, 0, 0,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 17, 5,            // hbmMsk, xMsk, yMsk
                0x00020000                // fore = blackness, back = patlbt
                );

        BitBlt(hdcScreen, 0, 0, cx, cy, (HDC) hdc4Clone, 0, 0, SRCCOPY);
    }

    {
        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, cx, cy, (HDC) 0, 0, 0, 0);

        DbgPrint("masked blt with cat as a mask \n");

        //  hbr4No15 is selected as a brush

    // this should force it into my code

        MaskBlt(hdc4Clone, 0,0, cx, cy,
                (HDC)0, 0, 0,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x02000000                // fore = Patblt, back = blackness
                );

        BitBlt(hdcScreen, 0, 0, cx, cy, (HDC) hdc4Clone, 0, 0, SRCCOPY);
    }

// do some testing for xDir < 0 now

    {

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, cx, cy, (HDC) 0, 0, 0, 0);

        DbgPrint("xDir < 0 \n");

        // already in SelectObject(hdc4Clone, hbr4No15);

    // this should force it into my code

        PatBlt(hdc4Clone, 0,0, cx, cy, 0x00020000);

        // do a simple srccopy first to see if everything works

        MaskBlt(hdc4Clone, 40,0, cx, cy/2 - 10,
                hdc4Clone, 0, 0,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x00010000                // fore = black  back = srccopy
                );

        MaskBlt(hdc4Clone, 45,cy/2, cx, cy/2,
                hdc4Clone, 0, cy/2,          // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x00010000                // fore = black  back = srccopy
                );

        BitBlt(hdcScreen, 0, 0, cx, cy, (HDC) hdc4Clone, 0, 0, SRCCOPY);

    }

    {

        BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, 0);
        BitBlt(hdc4Clone, 0, 0, cx, cy, (HDC) 0, 0, 0, 0);

        DbgPrint("xDir < 0 \n");

        SelectObject(hdc4Clone, hbrushGreen);
        PatBlt(hdc4Clone, 0,0, cx, cy, 0x00020000);

        SelectObject(hdc4Clone, hbr4No15);

    // this should force it into my code

        // put a source in to impose xDir < 0,
        // but choose a rop that does not involve src

        MaskBlt(hdc4Clone, 40,0, cx, cy/2 - 10,
                hdc4Clone, 0, 0,          // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x01020000                // fore =  srccopy back =patcopy
                );

        MaskBlt(hdc4Clone, 45,cy/2, cx, cy/2,
                hdc4Clone, 0, cy/2,             // hdcSrc, xSrc, ySrc
                hbm1Cat, 0, 0,            // hbmMsk, xMsk, yMsk
                0x01020000                // fore =  srccopy back =patcopy
                );                        // green cats on the back of 15's

        BitBlt(hdcScreen, 0, 0, cx, cy, (HDC) hdc4Clone, 0, 0, SRCCOPY);

    }


// Clean up time, delete it all.

    SelectObject(hdc4Clone, hbmDefault)       ;
    SelectObject(hdc1Cat, hbmDefault)        ;
    SelectObject(hdc4LetterA, hbmDefault)      ;
    SelectObject(hdc4No15 , hbmDefault)     ;
    SelectObject(hdc8, hbmDefault)      ;

    SelectObject(hdc4Clone, hbrDefault)       ;
    SelectObject(hdc1Cat, hbrDefault)        ;
    SelectObject(hdc4LetterA, hbrDefault)      ;
    SelectObject(hdc4No15 , hbrDefault)     ;


// Delete DC's

    if (!DeleteDC(hdc1Cat))
	DbgPrint("Failed to delete hdc 3\n");

    if (!DeleteDC(hdc4LetterA))
	DbgPrint("Failed to delete hdc 5\n");

    if (!DeleteDC(hdc4No15))
	DbgPrint("Failed to delete hdc 7\n");

    if (!DeleteDC(hdc4Clone))
	DbgPrint("Failed to delete hdc 9\n");

    if (!DeleteDC(hdc8))
	DbgPrint("Failed to delete hdc8\n");

// Delete Bitmaps

    if (!DeleteObject(hbm1Cat))
	DbgPrint("ERROR failed to delete  hbm1Cat\n");
    if (!DeleteObject(hbm4LetterA))
	DbgPrint("ERROR failed to delete hbm4LetterA\n");
    if (!DeleteObject(hbm4No15))
	DbgPrint("ERROR failed to delete 5\n");
    if (!DeleteObject(hbm4Clone))
	DbgPrint("ERROR failed to delete 9\n");
    if (!DeleteObject(hbm8))
	DbgPrint("ERROR failed to delete hbm8\n");

    if (DeleteObject(hbmDefault))
	DbgPrint("ERROR deleted default bitmap\n");

// Delete the brushes

    if (!DeleteObject(hbr4LetterA))
	DbgPrint("failed to delete pattern brush 2\n");

    if (!DeleteObject(hbr4No15))
	DbgPrint("failed to delete pattern brush 3\n");

    if (!DeleteObject(hbrushGreen))
	DbgPrint("failed to delete pattern brush 4\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftbmtext.c ===
/******************************Module*Header*******************************\
* Module Name: ftbmtext.c
*
* Tests text to 1,4,8,24,32 BPP bitmaps
*
* Created: 12-Jun-1991 10:12:58
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID vBuginText(HDC hdcScreen);
VOID vTestBitmapText(HDC hdcScreen);
VOID vTestDIBPALCOLORS(HDC hdc);

/******************************Public*Routine******************************\
* Test AddFontModule
*
*
* History:
*  29-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestAddFontResource(HWND hwnd, HDC hdc)
{
    ULONG   ul;
    HFONT   hfontP,hfontG,hfontOld;

    ul = AddFontResource((LPSTR) "ft.exe");

    if (ul != 2)
        DbgPrint("GetModuleHandle failed\n");

    hfontP = CreateFont(-24, 0, 0, 0, 0, 0, 0, 0, ANSI_CHARSET,
                       OUT_RASTER_PRECIS, CLIP_DEFAULT_PRECIS,
                       DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                       "patrickh");

    if (hfontP == 0)
        DbgPrint("AddFontResource failed CreateFont\n");

    hfontG = CreateFont(-24, 0, 0, 0, 0, 0, 0, 0, ANSI_CHARSET,
                       OUT_RASTER_PRECIS, CLIP_DEFAULT_PRECIS,
                       DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                       "gilmanw");

    if (hfontG == 0)
        DbgPrint("AddFontResource failed CreateFontG\n");

    hfontOld = SelectObject(hdc, hfontP);

    TextOut(hdc, 500, 0, "AAAAAAPH", 8);

    SelectObject(hdc, hfontOld);

    hfontOld = SelectObject(hdc, hfontG);

    TextOut(hdc, 500, 100, "AAAAAAGW", 8);

    SelectObject(hdc, hfontOld);

    DeleteObject(hfontP);
    DeleteObject(hfontG);

    RemoveFontResource((LPSTR) "ft.exe");

    hfontP = CreateFont(-24, 0, 0, 0, 0, 0, 0, 0, ANSI_CHARSET,
                       OUT_RASTER_PRECIS, CLIP_DEFAULT_PRECIS,
                       DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                       "patrickh");

    if (hfontP == 0)
        DbgPrint("AddFontResource failed CreateFont\n");

    hfontOld = SelectObject(hdc, hfontP);

    TextOut(hdc, 500, 200, "AAAAAAPH", 8);

    SelectObject(hdc, hfontOld);

    DeleteObject(hfontP);
}

/******************************Public*Routine******************************\
* vTestAddFontModule
*
* History:
*  01-Apr-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
#if 0
VOID vTestAddFontModule(HWND hwnd, HDC hdc)
{
    DWORD ul;
    HFONT hfontP,hfontOld;
    HINSTANCE hMyInst;

    if ((hMyInst = LoadLibrary("patrickh.fon")) == 0)
    {
        DbgPrint("Load Library failed\n");
        return;
    }

    ul = AddFontModule(hMyInst);

    SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);

    if (ul != 1)
        DbgPrint("ul not 1\n");

    hfontP = CreateFont(-24, 0, 0, 0, 0, 0, 0, 0, ANSI_CHARSET,
                       OUT_RASTER_PRECIS, CLIP_DEFAULT_PRECIS,
                       DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                       "patrickh");

    hfontOld = SelectObject(hdc, hfontP);
    TextOut(hdc, 600, 300, "AAAAAAPPP", 8);
    SelectObject(hdc, hfontOld);
    DeleteObject(hfontP);
    RemoveFontModule((LPSTR) hMyInst);
    SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
    FreeLibrary(hMyInst);
}
#endif

/******************************Public*Routine******************************\
* vTestBMText
*
* Test text.
*
* History:
*  Wed 11-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vTestBMText(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    ULONG ulTemp;

    hwnd;
    prcl;
    vBuginText(hdcScreen);
    vTestBitmapText(hdcScreen);

    for (ulTemp = 0; ulTemp < 3; ulTemp++)
        vTestAddFontResource(hwnd, hdcScreen);

#if 0
    for (ulTemp = 0; ulTemp < 3; ulTemp++)
        vTestAddFontModule(hwnd, hdcScreen);
#endif

    vTestDIBPALCOLORS(hdcScreen);
}

/******************************Public*Routine******************************\
* vBuginText
*
* Test that text to 1X1 bitmap doesn't gp-fault
*
* History:
*  26-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vBuginText(HDC hdcScreen)
{
    HDC hdcMono;

    hdcMono = CreateCompatibleDC(hdcScreen);
    PatBlt(hdcMono, 0, 0, 1000, 1000, BLACKNESS);
    BitBlt(hdcMono, 0, 0, 0, 0, hdcScreen, 0, 0, SRCCOPY);
    BitBlt(hdcMono, 0, 0, 1, 1, hdcScreen, 1, 1, SRCCOPY);
    BitBlt(hdcMono, 0, 0, 100, 100, hdcScreen, 10, 10, SRCCOPY);
    BitBlt(hdcMono, 0, 0, 10000, 10000, hdcScreen, 10, 10, SRCCOPY);
    ExtTextOut(hdcMono, 0, 0, 0, NULL, "Hello World", 11, NULL);
    ExtTextOut(hdcMono, 0, 0, 0, NULL, "Hello WorldabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 37, NULL);
    DeleteDC(hdcMono);
}

/******************************Public*Routine******************************\
* vTestBitmapText
*
* Test text out to a bitmap.
*
* History:
*  11-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestBitmapText(HDC hdcScreen)
{
    HBITMAP hbm1,hbm4,hbm8,hbm16,hbm24,hbm32,hbmDefault;
    HDC     hdc1,hdc4,hdc8,hdc16,hdc24,hdc32;
    ULONG   ScreenWidth, ScreenHeight;
    HFONT   hfItalic, hf1,hf4,hf8,hf16,hf24,hf32;
    LOGFONT lfItalic;


    lfItalic.lfHeight =  16;
    lfItalic.lfWidth =  8;
    lfItalic.lfEscapement =  0;
    lfItalic.lfOrientation =  0;
    lfItalic.lfWeight =  700;
    lfItalic.lfItalic =  1;
    lfItalic.lfUnderline =  0;
    lfItalic.lfStrikeOut =  0;
    lfItalic.lfCharSet =  ANSI_CHARSET;
    lfItalic.lfOutPrecision =  OUT_DEFAULT_PRECIS;
    lfItalic.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    lfItalic.lfQuality =  DEFAULT_QUALITY;
    lfItalic.lfPitchAndFamily =  (FIXED_PITCH | FF_DONTCARE);

    strcpy(lfItalic.lfFaceName, "System");

    hfItalic = CreateFontIndirect(&lfItalic);

    if (hfItalic == (HFONT)0)
    {
        DbgPrint("CreateFontIndirect failed\n");
    }

    ScreenWidth  = GetDeviceCaps(hdcScreen, HORZRES);
    ScreenHeight = GetDeviceCaps(hdcScreen, VERTRES);

    hdc1  = CreateCompatibleDC(hdcScreen);
    hdc4  = CreateCompatibleDC(hdcScreen);
    hdc8  = CreateCompatibleDC(hdcScreen);
    hdc16 = CreateCompatibleDC(hdcScreen);
    hdc24 = CreateCompatibleDC(hdcScreen);
    hdc32 = CreateCompatibleDC(hdcScreen);

    if ((hdc1 == (HDC) 0) || (hdc4 == (HDC) 0) || (hdc32 == (HDC) 0))
	DbgPrint("ERROR hdc creation %lu %lu %lu \n", hdc8, hdc4, hdc1);

// Clear the screen

    BitBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight,
	  (HDC) 0, 0, 0, WHITENESS);

// Ok let's throw in some CreateCompatible calls.

    hbm1  = hbmCreateDIBitmap(hdcScreen, 500, 100, 1);
    hbm4  = hbmCreateDIBitmap(hdcScreen, 500, 100, 4);
    hbm8  = hbmCreateDIBitmap(hdcScreen, 500, 100, 8);
    hbm16 = hbmCreateDIBitmap(hdcScreen, 500, 100, 16);
    hbm24 = hbmCreateDIBitmap(hdcScreen, 500, 100, 24);
    hbm32 = hbmCreateDIBitmap(hdcScreen, 500, 100, 32);

    hf1 = SelectObject(hdc1, hfItalic);
    hf4 = SelectObject(hdc4, hfItalic);
    hf8 = SelectObject(hdc8, hfItalic);
    hf16 = SelectObject(hdc16, hfItalic);
    hf24 = SelectObject(hdc24, hfItalic);
    hf32 = SelectObject(hdc32, hfItalic);

    hbmDefault = SelectObject(hdc1,hbm1);

    if (hbmDefault == (HBITMAP) 0)
	DbgPrint("hbmDefault hd1 select bad\n");

    if (hbmDefault != SelectObject(hdc4,hbm4))
	DbgPrint("hbmDefault hd4 select bad\n");

    if (hbmDefault != SelectObject(hdc8,hbm8))
	DbgPrint("hbmDefault hd8 select bad\n");

    SelectObject(hdc16,hbm16);
    SelectObject(hdc24,hbm24);
    SelectObject(hdc32,hbm32);

    PatBlt(hdc1, 0, 0, 500, 100, WHITENESS);
    PatBlt(hdc4, 0, 0, 500, 100, WHITENESS);
    PatBlt(hdc8, 0, 0, 500, 100, WHITENESS);
    PatBlt(hdc16, 0, 0, 500, 100, WHITENESS);
    PatBlt(hdc24, 0, 0, 500, 100, WHITENESS);
    PatBlt(hdc32, 0, 0, 500, 100, WHITENESS);

    TextOut(hdc1, 5, 5, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc1, 5, 30, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);

    if(!BitBlt(hdcScreen, 0, 0, 500, 100, hdc1, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    TextOut(hdc4, 5, 5, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc4, 5, 30, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);

    if(!BitBlt(hdcScreen, 0, 80, 500, 100, hdc4, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    TextOut(hdc8, 5, 5, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc8, 5, 30, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);

    if(!BitBlt(hdcScreen, 0, 160, 500, 100, hdc8, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    TextOut(hdc16, 5, 5, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc16, 5, 30, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);

    if(!BitBlt(hdcScreen, 0, 240, 500, 100, hdc16, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    TextOut(hdc24, 5, 5, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc24, 5, 30, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);

    if(!BitBlt(hdcScreen, 0, 320, 500, 100, hdc24, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    TextOut(hdc32, 5, 5, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc32, 5, 30, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);

    if(!BitBlt(hdcScreen, 0, 400, 500, 100, hdc32, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    SelectObject(hdc1,hf1);
    SelectObject(hdc4,hf4);
    SelectObject(hdc8,hf8);
    SelectObject(hdc16,hf16);
    SelectObject(hdc24,hf24);
    SelectObject(hdc32,hf32);

    if (!DeleteObject(hfItalic))
	DbgPrint("Failed to delete hfItalic \n");

// Delete DC's

    if (!DeleteDC(hdc1))
	DbgPrint("Failed to delete hdc 11\n");
    if (!DeleteDC(hdc4))
	DbgPrint("Failed to delete hdc 15\n");
    if (!DeleteDC(hdc8))
	DbgPrint("Failed to delete hdc 16\n");
    if (!DeleteDC(hdc16))
	DbgPrint("Failed to delete hdc 166\n");
    if (!DeleteDC(hdc24))
	DbgPrint("Failed to delete hdc 18\n");
    if (!DeleteDC(hdc32))
	DbgPrint("Failed to delete hdc 19\n");

// Delete Bitmaps

    if (!DeleteObject(hbm1))
	DbgPrint("ERROR failed to delete 11\n");
    if (!DeleteObject(hbm4))
	DbgPrint("ERROR failed to delete 13\n");
    if (!DeleteObject(hbm8))
	DbgPrint("ERROR failed to delete 14\n");
    if (!DeleteObject(hbm16))
	DbgPrint("ERROR failed to delete 14\n");
    if (!DeleteObject(hbm24))
	DbgPrint("ERROR failed to delete 14\n");
    if (!DeleteObject(hbm32))
	DbgPrint("ERROR failed to delete 14\n");

    if (!DeleteObject(hbmDefault))
	DbgPrint("ERROR deleted default bitmap\n");
}

typedef struct _BITMAPINFO1
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[2];
} BITMAPINFO1;

typedef struct _BITMAPINFO4
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFO4;

typedef struct _BITMAPINFO8
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[256];
} BITMAPINFO8;

typedef struct _BITMAPINFO16
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO16;

typedef struct _BITMAPINFO32
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO32;

/******************************Public*Routine******************************\
* hbmCreateDIBitmap
*
* Returns x X y bitmap of iBitsPixel depth.
*
* History:
*  29-Mar-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HBITMAP hbmCreateDIBitmap(HDC hdc, ULONG x, ULONG y, ULONG nBitsPixel)
{
    HBITMAP hbmReturn;
    ULONG ulTemp;
    BITMAPINFO *pbmi;

// These are the n-bpp sources.

    BITMAPINFO1 bmi1 = {{40,32,32,1,1,BI_RGB,0,0,0,0,0}, {{0,0,0,0}, {0xff,0xff,0xff,0}}};

    BITMAPINFO4 bmi4 =
    {
        {
            sizeof(BITMAPINFOHEADER),
            64,
            64,
            1,
            4,
            BI_RGB,
            0,
            0,
            0,
            0,
            0
        },

        {                               // B    G    R
            { 0,   0,   0,   0 },       // 0
            { 0,   0,   0x80,0 },       // 1
            { 0,   0x80,0,   0 },       // 2
            { 0,   0x80,0x80,0 },       // 3
            { 0x80,0,   0,   0 },       // 4
            { 0x80,0,   0x80,0 },       // 5
            { 0x80,0x80,0,   0 },       // 6
            { 0x80,0x80,0x80,0 },       // 7

            { 0xC0,0xC0,0xC0,0 },       // 8
            { 0,   0,   0xFF,0 },       // 9
            { 0,   0xFF,0,   0 },       // 10
            { 0,   0xFF,0xFF,0 },       // 11
            { 0xFF,0,   0,   0 },       // 12
            { 0xFF,0,   0xFF,0 },       // 13
            { 0xFF,0xFF,0,   0 },       // 14
            { 0xFF,0xFF,0xFF,0 }        // 15
        }
    };

    BITMAPINFO8 bmi8;
    BITMAPINFO16 bmi16 = {{40,32,32,1,16,BI_BITFIELDS,0,0,0,0,0},
                          {0x00007C00, 0x000003E0, 0x0000001F}};

    BITMAPINFOHEADER bmi24 = {40,32,32,1,24,BI_RGB,0,0,0,0,0};

    BITMAPINFO32 bmi32 = {{40,32,32,1,32,BI_BITFIELDS,0,0,0,0,0},
                          {0x00FF0000, 0x0000FF00, 0x000000FF}};

// Initialize the 8BPP DIB.

    bmi8.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi8.bmiHeader.biWidth         = 32;
    bmi8.bmiHeader.biHeight        = 32;
    bmi8.bmiHeader.biPlanes        = 1;
    bmi8.bmiHeader.biBitCount      = 8;
    bmi8.bmiHeader.biCompression   = BI_RGB;
    bmi8.bmiHeader.biSizeImage     = 0;
    bmi8.bmiHeader.biXPelsPerMeter = 0;
    bmi8.bmiHeader.biYPelsPerMeter = 0;
    bmi8.bmiHeader.biClrUsed       = 0;
    bmi8.bmiHeader.biClrImportant  = 0;

// Generate 256 (= 8*8*4) RGB combinations to fill
// in the palette.

    {
        BYTE red, green, blue, unUsed;
        unUsed = red = green = blue = 0;

        for (ulTemp = 0; ulTemp < 256; ulTemp++)
        {
            bmi8.bmiColors[ulTemp].rgbRed      = red;
            bmi8.bmiColors[ulTemp].rgbGreen    = green;
            bmi8.bmiColors[ulTemp].rgbBlue     = blue;
            bmi8.bmiColors[ulTemp].rgbReserved = 0;

            if (!(red += 32))
            if (!(green += 32))
            blue += 64;
        }

        for (ulTemp = 248; ulTemp < 256; ulTemp++)
        {
            bmi8.bmiColors[ulTemp].rgbRed      = bmi4.bmiColors[ulTemp - 240].rgbRed;
            bmi8.bmiColors[ulTemp].rgbGreen    = bmi4.bmiColors[ulTemp - 240].rgbGreen;
            bmi8.bmiColors[ulTemp].rgbBlue     = bmi4.bmiColors[ulTemp - 240].rgbBlue;
            bmi8.bmiColors[ulTemp].rgbReserved = 0;

            if (!(red += 32))
            if (!(green += 32))
            blue += 64;
        }
    }

// Start Drawing

    switch (nBitsPixel)
    {
    case 1:
        pbmi = (BITMAPINFO *) &bmi1;
        break;
    case 4:
        pbmi = (BITMAPINFO *) &bmi4;
        break;
    case 8:
        pbmi = (BITMAPINFO *) &bmi8;
        break;
    case 16:
        pbmi = (BITMAPINFO *) &bmi16;
        break;
    case 24:
        pbmi = (BITMAPINFO *) &bmi24;
        break;
    case 32:
        pbmi = (BITMAPINFO *) &bmi32;
        break;
    default:
        DbgPrint("Not a valid format passed to hbmCreateDIB\n");
        return(0);
    }

    pbmi->bmiHeader.biWidth = x;
    pbmi->bmiHeader.biHeight = y;

    return(CreateDIBitmap(hdc, NULL, CBM_CREATEDIB, NULL, pbmi, DIB_RGB_COLORS));
}

typedef struct _LOGPALETTE256
{
    USHORT palVersion;
    USHORT palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

/******************************Public*Routine******************************\
* vTestDIBPALCOLORS
*
* Test a couple blts with DIB_PAL_COLORS.
*
* History:
*  15-Apr-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestDIBPALCOLORS(HDC hdc)
{
    BITMAPINFO8 bmi8;
    LOGPALETTE256 logpal;
    BYTE ajBytes[256];
    PUSHORT pusIndices;
    HPALETTE hpal,hpalOld;
    HBITMAP hbm;
    ULONG ulTemp;

// Initialize the 8BPP DIB.

    bmi8.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi8.bmiHeader.biWidth         = 16;
    bmi8.bmiHeader.biHeight        = 16;
    bmi8.bmiHeader.biPlanes        = 1;
    bmi8.bmiHeader.biBitCount      = 8;
    bmi8.bmiHeader.biCompression   = BI_RGB;
    bmi8.bmiHeader.biSizeImage     = 0;
    bmi8.bmiHeader.biXPelsPerMeter = 0;
    bmi8.bmiHeader.biYPelsPerMeter = 0;
    bmi8.bmiHeader.biClrUsed       = 0;
    bmi8.bmiHeader.biClrImportant  = 0;

    pusIndices = (PUSHORT) (&(bmi8.bmiColors));
    logpal.palVersion = 0x300;
    logpal.palNumEntries = 256;

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
        logpal.palPalEntry[ulTemp].peRed   = (BYTE) ulTemp;
        logpal.palPalEntry[ulTemp].peGreen = (BYTE) 0;
        logpal.palPalEntry[ulTemp].peBlue  = (BYTE) 0;
        logpal.palPalEntry[ulTemp].peFlags = (BYTE) 0;
        pusIndices[ulTemp] = (USHORT) ulTemp;
        ajBytes[ulTemp] = (BYTE) ulTemp;
    }

    hpal = CreatePalette((LOGPALETTE *) &logpal);
    hbm  = CreateCompatibleBitmap(hdc, 16, 16);

    if ((hpal == 0) || (hbm == 0))
    {
        DbgPrint("hpal or hbm is 0 vTestDIB\n");
        return;
    }

    hpalOld = SelectPalette(hdc, hpal, 0);
    RealizePalette(hdc);

    if (16 != StretchDIBits(hdc, 0, 0, 32, 32, 0, 0, 16, 16, ajBytes, (BITMAPINFO *) &bmi8, DIB_PAL_COLORS, 0x00660000))
    {
        DbgPrint("StretchDIBits failed in DIBPALCOLOR\n");
    }

    if (16 != SetDIBits(hdc, hbm, 0, 16, ajBytes, (BITMAPINFO *) &bmi8, DIB_PAL_COLORS))
    {
        DbgPrint("SetDIBits failed in DIBPALCOLOR\n");
    }

    SelectPalette(hdc, hpalOld, 0);
    DeleteObject(hpal);
    DeleteObject(hbm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftcsr.c ===
/******************************Module*Header*******************************\
* Module Name: ftcsr.c
*
* (Brief description)
*
* Created: 02-Apr-1992 11:14:23
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define KB  * 1024
#define MB  * (1024 * 1024)
#define REP * gulCsrRep

PULONG gpul;
ULONG gulCSRMax = 1 MB - 1;
ULONG gulCsrRep = 100;

VOID vTestWindow(ULONG c, ULONG cj)
{
    int i;
    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;

    if (cj > gulCSRMax)
        return;

    NtQuerySystemTime(&time);

#ifdef TESTENABLED
    for (i = 0; i <c; ++i)
        if (!TestWindow(cj,gpul))
        {
            DbgPrint("-0,");
            return;
        }
#endif

    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;
//    DbgPrint("\nulTime %lx - %lx = %lx - ",time.LowPart,timeEnd.LowPart,ulTime);
    ulTime = ulTime / 10 / c;
    DbgPrint("%ld, ",ulTime);
}

VOID vTestSection(ULONG c, ULONG cj, BOOL bCopy)
{
    int i;
    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;

    if (cj > gulCSRMax)
        return;

    NtQuerySystemTime(&time);

#ifdef TESTENABLED
    for (i = 0; i <c; ++i)
        if (!TestSection(cj,gpul, bCopy))
        {
            DbgPrint("-0,");
            return;
        }
#endif

    NtQuerySystemTime(&timeEnd);
    ulTime = timeEnd.LowPart - time.LowPart;
    //DbgPrint("\nulTime %lx - %lx = %lx - ",time.LowPart,timeEnd.LowPart,ulTime);
    ulTime = ulTime / 10 / c;
    DbgPrint("%ld, ",ulTime);
}

VOID vTestRead(ULONG c, ULONG cj)
{
    int i;
    ULONG ulTime;
    LARGE_INTEGER  time, timeEnd;

    if (cj > gulCSRMax)
        return;

    NtQuerySystemTime(&time);

#ifdef TESTENABLED
    for (i = 0; i <c; ++i)
        if (!TestRead(cj,gpul))
        {
            DbgPrint("-0,");
            return;
        }
#endif

    NtQuerySystemTime(&timeEnd);
    ulTime = timeEnd.LowPart - time.LowPart;
    //DbgPrint("\nulTime %lx - %lx = %lx - ",time.LowPart,timeEnd.LowPart,ulTime);
    ulTime = ulTime / 10 / c;
    DbgPrint("%ld, ",ulTime);
}


VOID vTestCSR(HWND hwnd, HDC hdc, RECT* prcl)
{
    ULONG i;
    PBYTE pj;

    gpul = (PULONG)LocalAlloc(LMEM_FIXED,gulCSRMax);
    pj = (PBYTE)gpul;

    for (i = 0; i < gulCSRMax; ++i)
        pj[i] = (BYTE)i;

    if (gpul == NULL)
    {
        DbgPrint("couldn't allocate memory\n");
        return;
    }

    DbgPrint("Testing CSR timeings\n");
    DbgPrint("All numbers are in micro seconds\n\n");

    DbgPrint("intevals: 1Byte, 1K, 10K, 30K, 60K, 120K, 500K, 1MB, 2MB, 3MB, 5MB\n\n");

    DbgPrint("\nTestWindow:   ");
    vTestWindow(200 REP,  1);
    vTestWindow(150 REP,  1 KB);
    vTestWindow( 50 REP, 10 KB);
    vTestWindow( 20 REP, 30 KB);
    vTestWindow( 10 REP, 60 KB);
    vTestWindow(  7 REP,120 KB);
    vTestWindow(  7 REP,500 KB);
    vTestWindow(  5 REP,  1 MB);
    vTestWindow(  2 REP,  2 MB);
    vTestWindow(  1 REP,  3 MB);
    vTestWindow(  1 REP,  5 MB);

    DbgPrint("\nTestSection0: ");
    vTestSection(40 REP,  1   , FALSE);
    vTestSection(40 REP,  1 KB, FALSE);
    vTestSection(40 REP, 10 KB, FALSE);
    vTestSection(40 REP, 30 KB, FALSE);
    vTestSection(40 REP, 60 KB, FALSE);
    vTestSection(40 REP,120 KB, FALSE);
    vTestSection(40 REP,500 KB, FALSE);
    vTestSection(30 REP,  1 MB, FALSE);
    vTestSection(25 REP,  2 MB, FALSE);
    vTestSection(15 REP,  3 MB, FALSE);
    vTestSection(15 REP,  5 MB, FALSE);

    DbgPrint("\nTestSection1: ");
    vTestSection(35 REP,  1   , TRUE);
    vTestSection(35 REP,  1 KB, TRUE);
    vTestSection(35 REP, 10 KB, TRUE);
    vTestSection(35 REP, 30 KB, TRUE);
    vTestSection(20 REP, 60 KB, TRUE);
    vTestSection(10 REP,120 KB, TRUE);
    vTestSection( 3 REP,500 KB, TRUE);
    vTestSection( 2 REP,  1 MB, TRUE);
    vTestSection( 1 REP,  2 MB, TRUE);
    vTestSection( 1 REP,  3 MB, TRUE);
    vTestSection( 1 REP,  5 MB, TRUE);

    DbgPrint("\nTestRead:     ");
    vTestRead(200 REP,  1);
    vTestRead(200 REP,  1 KB);
    vTestRead(200 REP, 10 KB);
    vTestRead(200 REP, 30 KB);
    vTestRead(200 REP, 60 KB);
    vTestRead(100 REP,120 KB);
    vTestRead( 20 REP,500 KB);
    vTestRead( 10 REP,  1 MB);
    vTestRead(  3 REP,  2 MB);
    vTestRead(  1 REP,  3 MB);
    vTestRead(  1 REP,  5 MB);

    DbgPrint("\n\n");

    LocalFree(gpul);

    return;
    hdc;
    hwnd;
    prcl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftcolor.c ===
/******************************Module*Header*******************************\
* Module Name: ftcolor.c
*
* Test the use of color:
*   1. mono -> color conversion
*   2. color dithers.
*
* Created: 13-Jun-1991 14:11:34
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

typedef union _PAL_ULONG
{
    PALETTEENTRY pal;
    ULONG ul;
} PAL_ULONG;

typedef struct _BITMAPINFOPAT2
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[20];
} BITMAPINFOPAT2;

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFOPAT;

extern BITMAPINFOPAT bmiPat;
extern BYTE abColorLines[64 * 64 / 2];
extern BITMAPINFOPAT bmiPat1;
extern BITMAPINFOPAT2 bmiPat2;
extern BYTE abColorLines2[32 * 32];

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;

extern VGALOGPALETTE logPalVGA;

static BYTE abArrow[] = {0xFF, 0xFF,
			 0x81, 0x81,
			 0x81, 0x81,
			 0x81, 0x81,
			 0xFF, 0xFF,
			 0x81, 0x81,
			 0x81, 0x81,
			 0x81, 0x81,

			 0xFF, 0xFF,
			 0x80, 0x01,
			 0x80, 0x01,
			 0x80, 0x01,
			 0x80, 0x01,
			 0x80, 0x01,
			 0x80, 0x01,
			 0xFF, 0xFF };

static BYTE abCatMono[] = {0xFF, 0xFF, 0xFF, 0xFF,
			    0x80, 0xA2, 0x45, 0x01,
			    0x80, 0xA2, 0x45, 0x01,
			    0x80, 0xA2, 0x45, 0xE1,
			    0x80, 0xA2, 0x45, 0x11,
			    0x80, 0xA2, 0x45, 0x09,
			    0x80, 0x9C, 0x39, 0x09,
			    0x80, 0xC0, 0x03, 0x05,

			    0x80, 0x40, 0x02, 0x05,
			    0x80, 0x40, 0x02, 0x05,
			    0x80, 0x40, 0x02, 0x05,
			    0x80, 0x20, 0x04, 0x05,
			    0x80, 0x20, 0x04, 0x05,
			    0x80, 0x20, 0x04, 0x05,
			    0x80, 0x10, 0x08, 0x05,
			    0x80, 0x10, 0x08, 0x09,

			    0x80, 0x10, 0x08, 0x11,
			    0x80, 0x08, 0x10, 0x21,
			    0x80, 0x08, 0x10, 0xC1,
			    0x80, 0x08, 0x10, 0x09,
			    0x80, 0x07, 0xE0, 0x09,
			    0x80, 0x08, 0x10, 0x09,
			    0x80, 0xFC, 0x3F, 0x09,
			    0x80, 0x09, 0x90, 0x09,

			    0x80, 0xFC, 0x3F, 0x01,
			    0x80, 0x08, 0x10, 0x01,
			    0x80, 0x1A, 0x58, 0x01,
			    0x80, 0x28, 0x14, 0x01,
			    0x80, 0x48, 0x12, 0x01,
			    0x80, 0x8F, 0xF1, 0x01,
			    0x81, 0x04, 0x20, 0x81,
			    0xFF, 0xFF, 0xFF, 0xFF };

/******************************Public*Routine******************************\
* vTestDither
*
* This tests some dithering
*
* History:
*  15-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void vTestDithering(HDC hdcScreen)
{
    HDC hdc8, hdcClone, hdc1;
    HBITMAP hbmClone, hbmDefault, hbm8, hbm1;
    HBRUSH hbrDither, hbrDefault, hbrTemp;
    HPALETTE hpalVGA, hpalOld;
    ULONG x;

    hdc8 = CreateCompatibleDC(hdcScreen);
    hdcClone = CreateCompatibleDC(hdcScreen);
    hdc1 = CreateCompatibleDC(hdcScreen);

    if ((hdc8 == (HDC) 0) || (hdcClone == (HDC) 0))
	DbgPrint("vTestDithering failed DC creation\n");

    hbm8 = CreateBitmap(300, 300, 1, 4, (PBYTE) NULL);
    hbmClone = CreateCompatibleBitmap(hdcScreen, 300, 300);
    hbm1 = CreateBitmap(300, 300, 1, 1, (PBYTE) NULL);

    if (hbm8 == (HBITMAP) 0)
	DbgPrint("vTestDithering failed hbm creation\n");

    hbmDefault = SelectObject(hdc8, hbm8);
    hbmClone = SelectObject(hdcClone,hbmClone);
    SelectObject(hdc1,hbm1);

    SelectPalette(hdcClone, GetStockObject(DEFAULT_PALETTE), 0);
    RealizePalette(hdcClone);

    hpalVGA = CreatePalette((LOGPALETTE *) &logPalVGA);
    hpalOld = SelectPalette(hdc8, hpalVGA, 0);
    RealizePalette(hdc8);

// First do Red

    for (x = 0; x < 256; x = x + 8)
    {
	hbrDither = CreateSolidBrush(RGB(((BYTE) x), 0, 0));

	if (hbrDither == (HBRUSH) 0)
	    DbgPrint("vTestDithering brush create failed\n");

	hbrDefault = SelectObject(hdc8, hbrDither);
	SelectObject(hdcClone, hbrDither);

	if (hbrDither == (HBRUSH) 0)
	    DbgPrint("vTestDithering brush select failed\n");

	PatBlt(hdc8, 0, x, 150, 8, PATCOPY);
	PatBlt(hdcClone, 0, x, 150, 8, PATCOPY);

	hbrTemp = SelectObject(hdc8, hbrDefault);
	SelectObject(hdcClone,hbrDefault);

	if (hbrDither != hbrTemp)
	    DbgPrint("ERROR vTestDithering brush de-select failed\n");

	if (!DeleteObject(hbrDither))
	    DbgPrint("ERROR vTestDithering failed to delete brush\n");
    }

// Next do Gray

    for (x = 0; x < 256; x = x + 8)
    {
	hbrDither = CreateSolidBrush(RGB(((BYTE) x),
					 ((BYTE) x),
					 ((BYTE) x)));

	if (hbrDither == (HBRUSH) 0)
	    DbgPrint("vTestDithering brush create failed\n");

	hbrDefault = SelectObject(hdc8, hbrDither);
	SelectObject(hdcClone, hbrDither);
	SelectObject(hdc1, hbrDither);

	if (hbrDefault == (HBRUSH) 0)
	    DbgPrint("vTestDithering brush select failed\n");

	PatBlt(hdc8, 150, x, 150, 8, PATCOPY);
	PatBlt(hdc1, 0, x, 100, 8, PATCOPY);
	PatBlt(hdcClone, 150, x, 150, 8, PATCOPY);

	hbrTemp = SelectObject(hdc8, hbrDefault);
	SelectObject(hdcClone, hbrDefault);
	SelectObject(hdc1, hbrDefault);

	if (hbrDither != hbrTemp)
	    DbgPrint("ERROR vTestDithering brush de-select failed\n");

	if (!DeleteObject(hbrDither))
	    DbgPrint("ERROR vTestDithering failed to delete brush\n");
    }

    BitBlt(hdcScreen, 300, 0, 300, 300, hdc8, 0, 0, SRCCOPY);
    BitBlt(hdcScreen, 0, 0, 300, 300, hdcClone, 0, 0, SRCCOPY);
    BitBlt(hdcScreen, 500, 0, 100, 300, hdc1, 0, 0, SRCCOPY);

// Last do Red to the screen

    for (x = 0; x < 256; x = x + 8)
    {
	hbrDither = CreateSolidBrush(RGB(((BYTE) x), 0, 0));

	if (hbrDither == (HBRUSH) 0)
	    DbgPrint("vTestDithering brush create failed\n");

	hbrDefault = SelectObject(hdcScreen, hbrDither);

	if (hbrDither == (HBRUSH) 0)
	    DbgPrint("vTestDithering brush select failed\n");

	PatBlt(hdcScreen, 400, x + 300, 80, 8, PATCOPY);

	hbrTemp = SelectObject(hdcScreen, hbrDefault);

	if (hbrDither != hbrTemp)
	    DbgPrint("ERROR vTestDithering brush de-select failed\n");

	if (!DeleteObject(hbrDither))
	    DbgPrint("ERROR vTestDithering failed to delete brush\n");
    }

    hbmClone = SelectObject(hdcClone,hbmClone);

    DeleteDC(hdc8);
    DeleteDC(hdc1);
    DeleteDC(hdcClone);
    DeleteObject(hbm8);
    DeleteObject(hbm1);
    DeleteObject(hbmClone);
    DeleteObject(hpalVGA);
}

/******************************Public*Routine******************************\
* vTestMonoToColor
*
* This tests blting a 16*16 and a 32*32 monochrome bitmap to the screen.
* The colors are dependant on the text color and background color.
*
* History:
*  15-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestMonoToColor(HDC hdcScreen)
{
    HDC hdcCat, hdcArrow;
    HBITMAP hbmCat, hbmArrow, hbmDefault;

    hdcCat   = CreateCompatibleDC(hdcScreen);
    hdcArrow = CreateCompatibleDC(hdcScreen);

    if (hdcCat == (HDC) 0)
	DbgPrint("ERROR hdc creation\n");

    hbmCat   = CreateBitmap(32, 32, 1, 1, abCatMono);
    hbmArrow = CreateBitmap(16, 16, 1, 1, abArrow);

    if (hbmCat == (HBITMAP) 0)
	DbgPrint("ERROR hbmCat creation\n");

    if (hbmArrow == (HBITMAP) 0)
	DbgPrint("ERROR hbmArrow creation\n");

    hbmDefault = SelectObject(hdcCat, hbmCat);

    if (hbmDefault != SelectObject(hdcArrow, hbmArrow))
	DbgPrint("ERROR Select of hdcArrow\n");

// Default

    if(!StretchBlt(hdcScreen, 0, 120, 32, 32, hdcCat, 0, 0, 32, 32, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 120, 32, 32, hdcCat, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!StretchBlt(hdcScreen, 40, 120, 16, 16, hdcArrow, 0, 0, 16, 16, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 100, 120, 16, 16, hdcArrow, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

// Red/Green

    SetBkColor(hdcScreen, RGB(0xFF,0,0));
    SetTextColor(hdcScreen, RGB(0,0xFF,0));

    if(!StretchBlt(hdcScreen, 0, 40, 32, 32, hdcCat, 0, 0, 32, 32, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 40, 32, 32, hdcCat, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!StretchBlt(hdcScreen, 128, 0, 64, 64, hdcCat, 0, 0, 32, 32, SRCCOPY))
	DbgPrint("ERROR: StretchBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 40, 40, 16, 16, hdcArrow, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 100, 40, 16, 16, hdcArrow, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

// Blue/Red

    SetBkColor(hdcScreen, RGB(0,0,0xFF));
    SetTextColor(hdcScreen, RGB(0xFF,0,0));

    if(!BitBlt(hdcScreen, 0, 80, 32, 32, hdcCat, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!StretchBlt(hdcScreen, 64, 80, 32, 32, hdcCat, 0, 0, 32, 32, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 40, 80, 16, 16, hdcArrow, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 100, 80, 16, 16, hdcArrow, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

// Black/White

    SetBkColor(hdcScreen, RGB(0xFF,0xFF,0xFF));
    SetTextColor(hdcScreen, RGB(0,0,0));

    if(!BitBlt(hdcScreen, 0, 0, 32, 32, hdcCat, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 0, 32, 32, hdcCat, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 40, 0, 16, 16, hdcArrow, 0, 0, SRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 100, 0, 16, 16, hdcArrow, 0, 0, NOTSRCCOPY))
	DbgPrint("ERROR: BitBlt returned FALSE\n");

// Clean up time, delete it all.

    if (hbmCat != SelectObject(hdcCat, hbmDefault))
	DbgPrint("Cleanup hbmCat wrong\n");

    if (hbmArrow != SelectObject(hdcArrow, hbmDefault))
	DbgPrint("Cleanup hbmArrow wrong\n");

// Delete DC's

    if (!DeleteDC(hdcCat))
	DbgPrint("Failed to delete hdcCat\n");

    if (!DeleteDC(hdcArrow))
	DbgPrint("Failed to delete hdcArrow\n");

// Delete Bitmaps

    if (!DeleteObject(hbmCat))
	DbgPrint("ERROR failed to delete hbmCat\n");

    if (!DeleteObject(hbmArrow))
	DbgPrint("ERROR failed to delete hbmArrow\n");
}

/******************************Public*Routine******************************\
* vTestSaveRestore()
*
* Test some simple save/restore.
*
* History:
*  25-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestSaveRestore(HDC hdcScreen)
{
    HDC hdcMem;
    LOGPALETTE lpal;
    HPALETTE hOld, hpal, hpalS;

    hdcMem = CreateCompatibleDC(hdcScreen);
    SaveDC(hdcMem);
    RestoreDC(hdcMem, -1);
    DeleteDC(hdcMem);

// This is to test fix for bug #842

    hdcMem = CreateCompatibleDC(hdcScreen);

    if (hdcMem == (HDC) 0)
    {
	DbgPrint("Failed DC create\n");
	return;
    }

    lpal.palVersion = 0x300;
    lpal.palNumEntries = 1;
    lpal.palPalEntry[0].peFlags = 0;
    hpalS = CreatePalette(&lpal);

    if (hpalS == (HPALETTE) 0)
    {
	DbgPrint("Failed hpalS create133343\n");
	goto exit;
    }

    hOld = SelectPalette(hdcMem, hpalS, FALSE);
    RealizePalette(hdcMem);

    SaveDC(hdcMem);
    hpal = SelectPalette(hdcMem, GetStockObject(DEFAULT_PALETTE), FALSE);
    SelectPalette(hdcMem,hpal,FALSE);
    RestoreDC(hdcMem, -1);

    SelectPalette(hdcMem, hOld, FALSE);

    DeleteObject(hpalS);

exit:

    DeleteDC(hdcMem);

// Let's try that again with the deviceDC

    lpal.palVersion = 0x300;
    lpal.palNumEntries = 1;
    lpal.palPalEntry[0].peFlags = 0;
    hpalS = CreatePalette(&lpal);

    if (hpalS == (HPALETTE) 0)
    {
	DbgPrint("Failed hpalS create133343\n");
	return;
    }

    hOld = SelectPalette(hdcScreen, hpalS, FALSE);
    RealizePalette(hdcScreen);

    SaveDC(hdcScreen);
    hpal = SelectPalette(hdcScreen, GetStockObject(DEFAULT_PALETTE), FALSE);
    SelectPalette(hdcScreen,hpal,FALSE);
    RestoreDC(hdcScreen, -1);

    SelectPalette(hdcScreen, hOld, FALSE);

    DeleteObject(hpalS);
}

/******************************Public*Routine******************************\
* vTest23
*
* This test is to assure byrond this code sequence does the right thing.
*
* History:
*  26-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTest23(HDC hdcScreen)
{
    HDC hdcMem;
    HBITMAP hbmMem;
    HBRUSH hbr;

    hdcMem = CreateCompatibleDC(hdcScreen);
    hbmMem = CreateBitmap(100, 100, 4, 1, NULL);
    hbr = CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF));
    SelectObject(hdcMem, hbmMem);
    SelectObject(hdcMem, hbr);
    PatBlt(hdcMem, 0, 0, 100, 100, PATCOPY);
    BitBlt(hdcScreen, 0, 0, 100, 100, hdcMem, 0, 0, SRCCOPY);
    DeleteDC(hdcMem);
    DeleteObject(hbmMem);
    DeleteObject(hbr);
}

/******************************Public*Routine******************************\
* vBugFix901
*
* demo bug 901 and it's fix.
*
* History:
*  16-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void vBugFix901(HDC hdcScreen)
{
    static BYTE  ajPat[16] = { 0xFF, 0x00,
			       0x81, 0x00,
			       0x81, 0x00,
			       0xFF, 0x00,
			       0x81, 0x00,
			       0x81, 0x00,
			       0x81, 0x00,
			       0xFF, 0x00 };

    BYTE ajTemp[32];

    HBRUSH hbrPat, hbrDefault;
    HBITMAP hbmdel;
    HBITMAP hbm4;
    HDC hdc4;
    HDC hdcTemp;
    UINT uiCount;

    hbmdel = CreateBitmap(8, 8, 1, 1, (LPSTR)ajPat);

    for (uiCount = 0; uiCount < 16; uiCount++)
	ajTemp[uiCount] = 0;

    GetBitmapBits(hbmdel, 16, ajTemp);

    for (uiCount = 0; uiCount < 16; uiCount++)
    {
        if (ajPat[uiCount] != ajTemp[uiCount])
            DbgPrint("vBugFix901 GetBitmapBits failed %lu\n", uiCount);
    }

    hbrPat = CreatePatternBrush(hbmdel);
    hbm4 =   CreateBitmap(100, 100, 1, 8, NULL);

    hdcTemp = CreateCompatibleDC(hdcScreen);
    hdc4    = CreateCompatibleDC(hdcScreen);

    SelectObject(hdcTemp, hbmdel);
    SelectObject(hdc4, hbm4);

    hbrDefault = SelectObject(hdcScreen, hbrPat);
    SelectObject(hdc4, hbrPat);

// Blue/Red

    SetBkColor(hdcScreen, RGB(0,0,0xFF));
    SetTextColor(hdcScreen, RGB(0xFF,0,0));

    PatBlt(hdcScreen, 0, 160, 100, 100, PATCOPY);

// Black/White

    SetBkColor(hdcScreen, RGB(0xFF,0xFF,0xFF));
    SetTextColor(hdcScreen, RGB(0,0,0));

    PatBlt(hdc4, 0, 0, 100, 100, PATCOPY);
    BitBlt(hdcScreen, 0, 260, 100, 100, hdc4, 0, 0, SRCCOPY);

    DeleteDC(hdcTemp);
    DeleteDC(hdc4);
    SelectObject(hdcScreen, hbrDefault);
    DeleteObject(hbrPat);
    DeleteObject(hbm4);
    DeleteObject(hbmdel);
}

/******************************Public*Routine******************************\
* vTestScrBlt
*
* Test blting from the screen.
*
* History:
*  21-Aug-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestSrcBlt(HDC hdc)
{
    BitBlt(hdc, 0, 300, 32, 32, hdc, 0, 40, SRCCOPY);
    BitBlt(hdc, 0, 332, 32, 32, hdc, 0, 40, NOTSRCCOPY);
    StretchBlt(hdc, 32, 300, 64, 64, hdc, 0, 40, 32, 32, SRCCOPY);
}

/******************************Public*Routine******************************\
* vTest1327
*
*
*
* History:
*  22-Aug-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTest1327(HDC hdc)
{
    HBITMAP hbm;
    HBITMAP hbmOld;
    HDC hdcMem;
    BYTE ajPat4[6 * 4] = {0x00,0x00,0x00,0x00,
                          0x02,0x22,0x20,0x00,
                          0x02,0x22,0x20,0x00,
                          0x02,0x22,0x20,0x00,
                          0x02,0x22,0x20,0x00,
			  0x00,0x00,0x00,0x00 };

    BYTE ajPat8[6 * 6] = {0x00,0x00,0x00,0x00,0x00,0x00,
			  0x00,0x02,0x02,0x02,0x02,0x00,
			  0x00,0x02,0x02,0x02,0x02,0x00,
			  0x00,0x02,0x02,0x02,0x02,0x00,
			  0x00,0x02,0x02,0x02,0x02,0x00,
			  0x00,0x00,0x00,0x00,0x00,0x00 };


    hbm = CreateBitmap(6,6,1,4,ajPat4);
    hdcMem = CreateCompatibleDC(hdc);

    hbmOld = SelectObject(hdcMem,hbm);
    if (hbmOld)
    {
        PatBlt(hdc, 100, 300, 100, 100, WHITENESS);

        BitBlt(hdc, 110, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 130, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 141, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 151, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 163, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);

        BitBlt(hdc, 110, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 130, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 141, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 151, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 163, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);

        hbm = CreateBitmap(6,6,1,8,ajPat8);
        SelectObject(hdcMem,hbm);
        DeleteObject(hbm);

        PatBlt(hdc, 100+120, 300, 100, 100, WHITENESS);

        BitBlt(hdc, 110+120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 120+120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 130+120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 141+120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 151+120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 163+120, 310, 6, 6, hdcMem, 0, 0, SRCCOPY);

        BitBlt(hdc, 110+120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 120+120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 130+120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 141+120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 151+120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);
        BitBlt(hdc, 163+120, 340, 6, 6, hdcMem, 0, 0, SRCCOPY);

        SelectObject(hdcMem,hbmOld);
    }
    DeleteObject(hbm);
    DeleteDC(hdcMem);
}

/******************************Public*Routine******************************\
* vTestColorMatching
*
* Test the color matching.
*
* History:
*  19-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFO256
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD			     bmiColors[256];
} BITMAPINFO256;

BYTE ajBuffer[256*40];

VOID vTestColorMatching(HDC hdcScreen)
{
    BITMAPINFO256 bmi256;
    ULONG ulX,ulY;

    bmi256.bmiHeader.biSize	       = sizeof(BITMAPINFOHEADER);
    bmi256.bmiHeader.biWidth	       = 40;
    bmi256.bmiHeader.biHeight	       = 256;
    bmi256.bmiHeader.biPlanes	       = 1;
    bmi256.bmiHeader.biBitCount        = 8;
    bmi256.bmiHeader.biCompression     = BI_RGB;
    bmi256.bmiHeader.biSizeImage       = 40 * 256;
    bmi256.bmiHeader.biXPelsPerMeter   = 0;
    bmi256.bmiHeader.biYPelsPerMeter   = 0;
    bmi256.bmiHeader.biClrUsed	       = 256;
    bmi256.bmiHeader.biClrImportant    = 256;

    ulY = 0;

    while (ulY < 256)
    {
	bmi256.bmiColors[ulY].rgbRed	   = (BYTE) ulY;
	bmi256.bmiColors[ulY].rgbGreen	   = (BYTE) ulY;
	bmi256.bmiColors[ulY].rgbBlue	   = (BYTE) ulY;
	bmi256.bmiColors[ulY].rgbReserved  = 0;

	ulX = 0;

	while (ulX < 40)
	{
	    ajBuffer[(ulY * 40) + ulX] = (BYTE) ulY;
	    ulX++;
	}

	ulY++;
    }

    SetDIBitsToDevice(hdcScreen, 200, 0, 40, 256, 0, 0, 0, 256,
		      ajBuffer, (BITMAPINFO *) &bmi256, DIB_RGB_COLORS);

    bmi256.bmiHeader.biHeight = -bmi256.bmiHeader.biHeight;

    SetDIBitsToDevice(hdcScreen, 240, 0, 40, 256, 0, 0, 0, 256,
		      ajBuffer, (BITMAPINFO *) &bmi256, DIB_RGB_COLORS);

    bmi256.bmiHeader.biHeight = -bmi256.bmiHeader.biHeight;

    ulY = 0;

    while (ulY < 256)
    {
	bmi256.bmiColors[ulY].rgbRed	   = (BYTE) ulY;
	bmi256.bmiColors[ulY].rgbGreen	   = 0;
	bmi256.bmiColors[ulY].rgbBlue	   = 0;
	bmi256.bmiColors[ulY].rgbReserved  = 0;

	ulY++;
    }

    SetDIBitsToDevice(hdcScreen, 280, 0, 40, 256, 0, 0, 0, 256,
		      ajBuffer, (BITMAPINFO *) &bmi256, DIB_RGB_COLORS);
}

/******************************Public*Routine******************************\
* vTestColorMatching1
*
* Test color matching.	This shows the error introduced when going from
* Grey --> 8 --> 4.  Grey --> 4 does what is expected, it finds only greys
* in the 4.  But adding the intermediate 8 allows the colors to deviate
* from grey to get a closer match and then deviate furter when coming to
* 4.
*
* History:
*  20-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestColorMatching1(HDC hdcScreen)
{
    ULONG ulY;
    PAL_ULONG pal1, pal2, pal3;
    HDC hdc8,hdc4;
    HBITMAP hbm8,hbm4;

    hbm4 = CreateBitmap(10,10,1,4,NULL);
    hdc4 = CreateCompatibleDC(hdcScreen);
    SelectObject(hdc4,hbm4);

    hbm8 = CreateBitmap(10,10,1,8,NULL);
    hdc8 = CreateCompatibleDC(hdcScreen);
    SelectObject(hdc8,hbm8);

    ulY = 0;

    while (ulY < 256)
    {
	pal1.pal.peRed	 = (BYTE) ulY;
	pal1.pal.peGreen = (BYTE) ulY;
	pal1.pal.peBlue  = (BYTE) ulY;
	pal1.pal.peFlags = 0;

	pal2.ul = GetNearestColor(hdc4, pal1.ul);

	if ((pal2.pal.peRed != pal2.pal.peBlue)   ||
	    (pal2.pal.peRed != pal2.pal.peGreen))
	{
	    DbgPrint("4 pal Original %lx pal Result %lx \n",
		      pal1.ul, pal2.ul);
	}

	ulY++;
    }

    ulY = 0;

    while (ulY < 256)
    {
	pal1.pal.peRed	 = (BYTE) ulY;
	pal1.pal.peGreen = (BYTE) ulY;
	pal1.pal.peBlue  = (BYTE) ulY;
	pal1.pal.peFlags = 0;

	pal3.ul = GetNearestColor(hdc8, pal1.ul);
	pal2.ul = GetNearestColor(hdc4, pal3.ul);

	if ((pal2.pal.peRed != pal2.pal.peBlue)   ||
	    (pal2.pal.peRed != pal2.pal.peGreen))
	{
	    DbgPrint("8 to 4 pal Original %lx pal Result on 8 %lx Result on 4 %lx\n",
		      pal1.ul, pal3.ul, pal2.ul);
	}

	ulY++;
    }

    ulY = 0;

    while (ulY < 256)
    {
	pal1.pal.peRed	 = (BYTE) ulY;
	pal1.pal.peGreen = (BYTE) ulY;
	pal1.pal.peBlue  = (BYTE) ulY;
	pal1.pal.peFlags = 0;

	pal2.ul = GetNearestColor(hdc8, pal1.ul);

	if ((pal2.pal.peRed != pal2.pal.peBlue)   ||
	    (pal2.pal.peRed != pal2.pal.peGreen))
	{
	    DbgPrint("8 pal Original %lx pal Result %lx \n",
		      pal1.ul, pal2.ul);
	}

	ulY++;
    }

    DeleteDC(hdc8);
    DeleteObject(hbm8);
}

/******************************Public*Routine******************************\
* vTestCompatDC
*
* Test creating compatible DC's and selection of bitmaps.
*
* History:
*  23-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestCompatDC(HDC hdcScreen)
{
    HDC hdc1, hdc2, hdc3;
    HBITMAP hbm1, hbm2, hbm3, hbmDefault;

    hbm1 = CreateBitmap(10, 10, 1, 1, NULL);
    hbm2 = CreateBitmap(10, 10, 1, 4, NULL);
    hbm3 = CreateCompatibleBitmap(hdcScreen, 10, 10);

    if ((hbm1 == (HBITMAP) 0) ||
	(hbm1 == (HBITMAP) 0) ||
	(hbm1 == (HBITMAP) 0))
    {
	DbgPrint("vTestCompatDC failed bitmap creation\n");
	goto vTestCompatDCend;
    }

    hdc1 = CreateCompatibleDC(NULL);

    if (hdc1 == (HDC) 0)
    {
	DbgPrint("vTestCompatDC failed hdc1 creation\n");
	goto vTestCompatDCend;
    }

    hbmDefault = SelectObject(hdc1, hbm1);

    if (hbmDefault == (HBITMAP) 0)
	DbgPrint("vTestCompatDC failed select11\n");

    hdc2 = CreateCompatibleDC(hdc1);

    if (hdc2 == (HDC) 0)
    {
	DbgPrint("vTestCompatDC failed hdc2 creation\n");
	goto vTestCompatDCend;
    }

    hbmDefault = SelectObject(hdc1, hbm3);

    if (hbmDefault == (HBITMAP) 0)
	DbgPrint("vTestCompatDC failed select22\n");

    hdc3 = CreateCompatibleDC(hdc1);

    if (hdc3 == (HDC) 0)
    {
	DbgPrint("vTestCompatDC failed hdc3 creation\n");
	goto vTestCompatDCend;
    }

    hbmDefault = SelectObject(hdc1, hbm1);

    if (hbmDefault == (HBITMAP) 0)
	DbgPrint("vTestCompatDC failed select1\n");

    hbmDefault = SelectObject(hdc2, hbm1);

    if (hbmDefault != (HBITMAP) 0)
	DbgPrint("vTestCompatDC error select2\n");

vTestCompatDCend:

    DeleteObject(hdc1);
    DeleteObject(hdc2);
    DeleteObject(hdc3);
    DeleteObject(hbm1);
    DeleteObject(hbm2);
    DeleteObject(hbm3);
}

/******************************Public*Routine******************************\
* vTestBWBug
*
* Test if SetDIBits,GetDIBits preserves Black and White.
*
* History:
*  03-Oct-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFO2
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD			     bmiColors[2];
} BITMAPINFO2;

BYTE ajBufMono[32*4] =
{
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,

    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,

    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,

    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF
};

BYTE ajBufTemp[32*4];

VOID vTestBWBug(HDC hdcScreen)
{
    BITMAPINFO2 bmi2, bmiTemp;
    ULONG ulX;
    HDC hdc1;
    HBITMAP hbm1;
    PBYTE pj1,pjTemp;

    hdc1   = CreateCompatibleDC(hdcScreen);
    hbm1   = CreateBitmap(32, 32, 1, 1, NULL);

    bmi2.bmiHeader.biSize	     = sizeof(BITMAPINFOHEADER);
    bmi2.bmiHeader.biWidth	     = 32;
    bmi2.bmiHeader.biHeight	     = 32;
    bmi2.bmiHeader.biPlanes	     = 1;
    bmi2.bmiHeader.biBitCount	     = 1;
    bmi2.bmiHeader.biCompression     = BI_RGB;
    bmi2.bmiHeader.biSizeImage	     = 32 * 4;
    bmi2.bmiHeader.biXPelsPerMeter   = 0;
    bmi2.bmiHeader.biYPelsPerMeter   = 0;
    bmi2.bmiHeader.biClrUsed	     = 2;
    bmi2.bmiHeader.biClrImportant    = 2;

    bmi2.bmiColors[0].rgbRed	   = 0;
    bmi2.bmiColors[0].rgbGreen	   = 0;
    bmi2.bmiColors[0].rgbBlue	   = 0;
    bmi2.bmiColors[0].rgbReserved  = 0;

    bmi2.bmiColors[1].rgbRed	   = 0xFF;
    bmi2.bmiColors[1].rgbGreen	   = 0xFF;
    bmi2.bmiColors[1].rgbBlue	   = 0xFF;
    bmi2.bmiColors[1].rgbReserved  = 0;

    SelectObject(hdc1, hbm1);
    SetDIBits(hdcScreen, hbm1, 0, 32, ajBufMono, (BITMAPINFO *) &bmi2, DIB_RGB_COLORS);
    BitBlt(hdcScreen, 300, 300, 32, 32, hdc1, 0, 0, SRCCOPY);

    SetDIBitsToDevice(hdcScreen, 332, 300, 32, 32, 0, 0, 0, 32,
		      ajBufMono, (BITMAPINFO *) &bmi2, DIB_RGB_COLORS);

    for (ulX = 0; ulX < (32*4); ulX++)
    {
	ajBufTemp[ulX] = 0;
    }

    pjTemp = (PBYTE) &bmiTemp;
    pj1 = (PBYTE) &bmi2;

    for (ulX = 0; ulX < sizeof(BITMAPINFO2); ulX++)
    {
	pjTemp[ulX] = 0;
    }

    bmiTemp.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

    GetDIBits(hdcScreen, hbm1, 0, 32, NULL,
			 (BITMAPINFO *) &bmiTemp,
			 DIB_RGB_COLORS);

    for (ulX = 0; ulX < sizeof(BITMAPINFOHEADER); ulX++)
    {
	if (pjTemp[ulX] != pj1[ulX])
	{
	    DbgPrint("ftColor vTestBWBug GetDIBits failed to get header %lu\n", ulX);
	    break;
	}
    }

    GetDIBits(hdcScreen, hbm1, 0, 32, NULL,
			 (BITMAPINFO *) &bmiTemp,
			 DIB_RGB_COLORS);

    for (ulX = 0; ulX < offsetof(BITMAPINFOHEADER,biClrUsed); ulX++)
    {
	if (pjTemp[ulX] != pj1[ulX])
	{
	    DbgPrint("ftColor vTestBWBug failed to get color table %lu\n", ulX);
      	    break;
	}
    }

    GetDIBits(hdcScreen, hbm1, 0, 32, ajBufTemp,
			 (BITMAPINFO *) &bmiTemp,
			 DIB_RGB_COLORS);

    for (ulX = 0; ulX < (32*4); ulX++)
    {
	if (ajBufTemp[ulX] != ajBufMono[ulX])
	{
	    DbgPrint("ftColor vTestBWBug failed to get bits %lu\n", ulX);
	    break;
	}
    }

    SetDIBitsToDevice(hdcScreen, 364, 300, 32, 32, 0, 0, 0, 32,
		      ajBufTemp, (BITMAPINFO *) &bmiTemp, DIB_RGB_COLORS);

    DeleteDC(hdc1);
    DeleteObject(hbm1);
}

/******************************Public*Routine******************************\
* vTestGetColor
*
* Test a bug Chi Yin at SGI found.
*
* History:
*  01-Oct-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestGetColor(HDC hdcScreen)
{

    if (GetDeviceCaps(hdcScreen,BITSPIXEL) == 24)
    {

    // this test only makes sence on a 24 bpp device

        HDC hdc24;
        HBITMAP hbm24;

        hdc24 = CreateCompatibleDC(hdcScreen);
        hbm24 = CreateBitmap(100, 100, 1, 24, NULL);
        SelectObject(hdc24, hbm24);

        if (GetNearestColor(hdc24, 0x00123456) != 0x00123456)
            DbgPrint("Error mismatch vTestGetColor1\n");

        if (GetNearestColor(hdc24, 0x00FFFFFF) != 0x00FFFFFF)
            DbgPrint("Error mismatch vTestGetColor2\n");

        if (GetNearestColor(hdc24, 0) != 0)
            DbgPrint("Error mismatch vTestGetColor3\n");

        if (GetNearestColor(hdc24, 0x00808080) != 0x00808080)
            DbgPrint("Error mismatch vTestGetColor4\n");

        if (GetNearestColor(hdc24, PALETTEINDEX(0)) != 0)
            DbgPrint("Error mismatch vTestGetColor5\n");

        if (GetNearestColor(hdc24, PALETTEINDEX(19)) != 0x00FFFFFF)
            DbgPrint("Error mismatch vTestGetColor6\n");

        DeleteObject(hdc24);
        DeleteObject(hbm24);
    }
}

/******************************Public*Routine******************************\
* vTestGetNearestColor
*
* This tests GetNearestColor
*
* History:
*  22-Sep-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestGetNearestColor(HDC hdc, ULONG crColor)
{
    ULONG crNearest,crClrSet,crNstSet;
    HDC hMemDC;
    HBITMAP hSurface,hSave;

    crNearest = GetNearestColor(hdc,crColor);

    if (hMemDC = CreateCompatibleDC(hdc))
    {
	if (hSurface = CreateCompatibleBitmap(hdc,1,1))
	{
	    if (hSave = SelectObject(hMemDC, hSurface))
	    {
		crClrSet = SetPixel(hMemDC,0,0,crColor);
		crNstSet = SetPixel(hMemDC,0,0,crNearest);

		// DbgPrint("crColor %lx crNearest %lx crClrSet %lx crNstSet %lx\n",
		//	     crColor,	 crNearest,    crClrSet,    crNstSet);

		SelectObject(hMemDC, hSave);
	    }

	    DeleteObject(hSurface);
	}

	DeleteObject(hMemDC);
    }
}

VOID vTestColorReturns(HDC hdc)
{
    vTestGetNearestColor(hdc, 0);
    vTestGetNearestColor(hdc, 0x500000);
    vTestGetNearestColor(hdc, 0x600000);
    vTestGetNearestColor(hdc, 0x700000);
    vTestGetNearestColor(hdc, 0x900000);
    vTestGetNearestColor(hdc, 0xa00000);
    vTestGetNearestColor(hdc, 0xb00000);
    vTestGetNearestColor(hdc, 0xc00000);
    vTestGetNearestColor(hdc, 0xd00000);
    vTestGetNearestColor(hdc, 0xe00000);
    vTestGetNearestColor(hdc, 0xf00000);
    vTestGetNearestColor(hdc, 0x202020);
    vTestGetNearestColor(hdc, 0x003000);
    vTestGetNearestColor(hdc, 0x303030);
}

/******************************Public*Routine******************************\
* vTestColor
*
* Tests some color mapping and dithering stuff.
*
* History:
*  15-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestColor(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    hwnd = hwnd;
    prcl = prcl;

// Clear the screen

    BitBlt(hdcScreen, -20, -20, 30000, 30000, (HDC) 0, 0, 0, WHITENESS);

    vTest23(hdcScreen);
    vTestDithering(hdcScreen);
    vTestMonoToColor(hdcScreen);
    vTestSaveRestore(hdcScreen);
    vBugFix901(hdcScreen);
    vTestSrcBlt(hdcScreen);
    vTest1327(hdcScreen);
    vTestColorMatching(hdcScreen);
    // vTestColorMatching1(hdcScreen);
    vTestGetColor(hdcScreen);
    vTestCompatDC(hdcScreen);
    vTestBWBug(hdcScreen);
    vTestColorReturns(hdcScreen);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftdib.c ===
/******************************Module*Header*******************************\
* Module Name: ftdib.c
*
* This is a hacked up test for the DIB functions that should be rewritten.
*
* Created: 01-Jun-1991 20:55:57
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

typedef struct _BMI_CLRTABLE{
BITMAPINFOHEADER bminfo;
RGBQUAD          bmrgb[4];
}BMI_CLRTABLE;

BMI_CLRTABLE bmiCT = {{sizeof(BITMAPINFOHEADER), 100, 100, 1, 8, BI_RGB, 10000, 0, 0, 4, 4},
       {{0, 0, 0xff, 0}, {0, 0xff, 0, 0},{0xff, 0, 0, 0},{0, 0, 0, 0} }}; // red,green,blue,black

typedef struct _BITMAPINFOPAT2
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[20];
} BITMAPINFOPAT2;

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFOPAT;

BITMAPINFOPAT _bmiPat =
{
    {
        sizeof(BITMAPINFOHEADER),
        32,
        32,
        1,
        1,
        BI_RGB,
    0,
        0,
        0,
        2,
        2
    },

    {                               // B    G    R
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0,   0 },       // 0
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
    { 0x80,0x80,0,   0 },       // 6
    { 0x80,0x80,0x80,0 },       // 7

    { 0xC0,0xC0,0xC0,0 },       // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

BYTE _abColorLines[64 * 64 / 2] =
{
// 0
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 8
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 16
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 24
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 32
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 40
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 48
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
// 56
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,
     0x00,0x00,0x11,0x11,0x22,0x22,0x33,0x33,0x44,0x44,0x55,0x55,0x66,0x66,0x77,0x77,0x88,0x88,0x99,0x99,0xAA,0xAA,0xBB,0xBB,0xCC,0xCC,0xDD,0xDD,0xEE,0xEE,0xFF,0xFF,

     0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
     0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
     0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,
     0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11
// 64
};

BITMAPINFOPAT _bmiPat1 =
{
    {
        sizeof(BITMAPINFOHEADER),
        64,
        64,
        1,
        4,
        BI_RGB,
    0,
        0,
        0,
        0,
        0
    },

    {                               // B    G    R
        { 0xFF,0xFF,0xFF,0 },       // 15
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0,   0,   0 },       // 12
        { 0,   0xFF,0xFF,0 },       // 11
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0,   0xFF,0 },       // 9
    { 0xC0,0xC0,0xC0,0 },       // 8

    { 0x80,0x80,0x80,0 },       // 7
        { 0x80,0x80,0,   0 },       // 6
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0,   0,   0 },       // 4
        { 0,   0x80,0x80,0 },       // 3
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0x80,0 },       // 1
        { 0,   0,   0,   0 }        // 0
    }
};

BITMAPINFOPAT2 _bmiPat2 =
{
    {
        sizeof(BITMAPINFOHEADER),
        32,
        32,
        1,
        8,
        BI_RGB,
        32*32,
        0,
        0,
        20,
        20
    },

    {                               // B    G    R
        { 0xFF,0xFF,0xFF,0 },       // 15
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0,   0,   0 },       // 12
        { 0,   0xFF,0xFF,0 },       // 11
        { 0,   0xFF,0,   0 },       // 10
    { 0,   0,   0xFF,0 },       // 9
    { 0xC0,0xC0,0xC0,0 },       // 8

    { 0x80,0x80,0x80,0 },       // 7
        { 0x80,0x80,0,   0 },       // 6
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0,   0,   0 },       // 4
        { 0,   0x80,0x80,0 },       // 3
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0x80,0 },       // 1
        { 0,   0,   0,   0 },       // 0

        { 0,   0,   0x80,0 },       // 1
        { 0x80,0,   0x80,0 },       // 5
        { 0,   0,   0xFF,0 },       // 9
        { 0xFF,0,   0xFF,0 }        // 13
    }
};

BYTE _abColorLines2[32 * 32] =
{
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,
    16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16, 16,16,16,16,16,16,16,16,

    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,
    17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17, 17,17,17,17,17,17,17,17,

    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,
    18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18, 18,18,18,18,18,18,18,18,

    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19,
    19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19, 19,19,19,19,19,19,19,19
};

static BYTE abBitCat[] = {0xFF, 0xFF, 0xFF, 0xFF,
                          0x80, 0xA2, 0x45, 0x01,
                          0x80, 0xA2, 0x45, 0x01,
                          0x80, 0xA2, 0x45, 0xE1,
                          0x80, 0xA2, 0x45, 0x11,
                          0x80, 0xA2, 0x45, 0x09,
                          0x80, 0x9C, 0x39, 0x09,
                          0x80, 0xC0, 0x03, 0x05,

                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x40, 0x02, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x20, 0x04, 0x05,
                          0x80, 0x10, 0x08, 0x05,
                          0x80, 0x10, 0x08, 0x09,

                          0x80, 0x10, 0x08, 0x11,
                          0x80, 0x08, 0x10, 0x21,
                          0x80, 0x08, 0x10, 0xC1,
                          0x80, 0x08, 0x10, 0x09,
                          0x80, 0x07, 0xE0, 0x09,
                          0x80, 0x08, 0x10, 0x09,
                          0x80, 0xFC, 0x3F, 0x09,
                          0x80, 0x09, 0x90, 0x09,

                          0x80, 0xFC, 0x3F, 0x01,
                          0x80, 0x08, 0x10, 0x01,
                          0x80, 0x1A, 0x58, 0x01,
                          0x80, 0x28, 0x14, 0x01,
                          0x80, 0x48, 0x12, 0x01,
                          0x80, 0x8F, 0xF1, 0x01,
                          0x81, 0x04, 0x20, 0x81,
                          0xFF, 0xFF, 0xFF, 0xFF } ;

static BYTE abBigCat[] = {
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;

extern VGALOGPALETTE logPalVGA;

VGALOGPALETTE palExplicit =
{

0x300,  // driver version
16,     // num entries
{
    { 0,   0,   0,    PC_EXPLICIT },       // 0
    { 1,   0,   0,    PC_EXPLICIT },       // 1
    { 2,   0,   0,    PC_EXPLICIT },       // 2
    { 3,   0,   0,    PC_EXPLICIT },       // 3
    { 4,   0,   0,    PC_EXPLICIT },       // 4
    { 5,   0,   0,    PC_EXPLICIT },       // 5
    { 6,   0,   0,    PC_EXPLICIT },       // 6
    { 7,   0,   0,    PC_EXPLICIT },       // 7

    { 8,   0,   0,    PC_EXPLICIT },       // 8
    { 9,   0,   0,    PC_EXPLICIT },       // 9
    { 10,  0,   0,    PC_EXPLICIT },       // 10
    { 11,  0,   0,    PC_EXPLICIT },       // 11
    { 12,  0,   0,    PC_EXPLICIT },       // 12
    { 13,  0,   0,    PC_EXPLICIT },       // 13
    { 14,  0,   0,    PC_EXPLICIT },       // 14
    { 15,  0,   0,    PC_EXPLICIT }    // 15
}
};

BYTE gajTemp[64 * 64];

VOID vTestDIB(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    HBITMAP hbm1Cat, hbm1Cat0, hbm4Lines, hbm4Lines0, hbm8Lines, hbm8Lines0;
    HBITMAP hbm1, hbm2, hbm1BigCat, hbm1BigCat0;
    HDC hdc1Cat, hdc1Cat0, hdc4Lines, hdc4Lines0, hdc8Lines, hdc8Lines0;
    HDC hdc1BigCat, hdc1BigCat0, hbmDefault;
    BYTE *pjTmpBuffer1, *pjTmpBuffer2;
    ULONG ScreenWidth, ScreenHeight;
    SIZE size;
    HPALETTE hpalDefault, hpalVGA, hpalExplicit;
    ULONG ulTemp;

    hwnd = hwnd;
    prcl = prcl;

    if (sizeof(int) != sizeof(LONG))
    DbgPrint("Error sizes of int vTEstDIB\n");

    hpalVGA = CreatePalette((LOGPALETTE *) &logPalVGA);
    hpalDefault = SelectPalette(hdcScreen, hpalVGA, 0);
    RealizePalette(hdcScreen);

    ScreenWidth  = GetDeviceCaps(hdcScreen, HORZRES);
    ScreenHeight = GetDeviceCaps(hdcScreen, VERTRES);

// We create 6 formats of bitmaps for testing.  2 of each. 1 backup
// so we can refresh after every draw.  The ****0 is the backup.

    hbm1 = CreateCompatibleBitmap(hdcScreen, 100, 100);
    hbm2 = CreateCompatibleBitmap(hdcScreen, 200,200);

    GetBitmapDimensionEx(hbm1,&size);

    if ((size.cx != 0) || (size.cy != 0))
        DbgPrint("Error GEtBimdim");

    SetBitmapDimensionEx(hbm1, 100, 100, &size);

    if ((size.cx != 0) || (size.cy != 0))
        DbgPrint("Error GEtBimdim1");

    GetBitmapDimensionEx(hbm1, &size);

    if ((size.cx != 100) || (size.cy != 100))
        DbgPrint("Error GEtBimdim2");

    DeleteObject(hbm1);
    DeleteObject(hbm2);

    hdc1BigCat =   CreateCompatibleDC(hdcScreen);
    hdc1BigCat0 =  CreateCompatibleDC(hdcScreen);
    hdc1Cat  =     CreateCompatibleDC(hdcScreen);
    hdc1Cat0 =     CreateCompatibleDC(hdcScreen);
    hdc4Lines =    CreateCompatibleDC(hdcScreen);
    hdc4Lines0 =   CreateCompatibleDC(hdcScreen);
    hdc8Lines =    CreateCompatibleDC(hdcScreen);
    hdc8Lines0 =   CreateCompatibleDC(hdcScreen);

    if ((hdc1Cat == 0) || (hdc8Lines0 == 0) || (hdcScreen == 0))
        DbgPrint("ERROR hdc creation %lu %lu %lu \n", hdcScreen, hdc8Lines0, hdc1Cat);

// Clear the screen

    BitBlt(hdcScreen, 0, 0, 640, 480, (HDC) 0, 0, 0, 0);

    _bmiPat.bmiHeader.biWidth = 32;

    hbm1Cat = CreateDIBitmap(0,
              (BITMAPINFOHEADER *) &_bmiPat,
              CBM_INIT,
                          abBitCat,
              (BITMAPINFO *) &_bmiPat,
              DIB_RGB_COLORS);

    if (hbm1Cat == 0)
    DbgPrint("hbm1Cat failed\n");

    _bmiPat.bmiHeader.biWidth = 128;

    hbm1BigCat = CreateDIBitmap(0,
              (BITMAPINFOHEADER *) &_bmiPat,
              CBM_INIT,
                          abBigCat,
              (BITMAPINFO *) &_bmiPat,
              DIB_RGB_COLORS);

    if (hbm1BigCat == 0)
    DbgPrint("hbm1BigCat failed\n");

    hbm4Lines = CreateDIBitmap(hdcScreen,
              (BITMAPINFOHEADER *) &_bmiPat1,
              CBM_INIT | CBM_CREATEDIB,
                          _abColorLines,
              (BITMAPINFO *) &_bmiPat1,
              DIB_RGB_COLORS);

    if (hbm4Lines == 0)
    DbgPrint("hbm4Lines failed\n");

    hbm8Lines = CreateDIBitmap(hdcScreen,
              (BITMAPINFOHEADER *) &_bmiPat2,
              CBM_INIT | CBM_CREATEDIB,
                          _abColorLines2,
              (BITMAPINFO *) &_bmiPat2,
              DIB_RGB_COLORS);

    if (hbm8Lines == 0)
    DbgPrint("hbm8Lines failed\n");

    hbmDefault = SelectObject(hdc1Cat, hbm1Cat);
    SelectObject(hdc1BigCat, hbm1BigCat);
    SelectObject(hdc4Lines, hbm4Lines);
    SelectObject(hdc8Lines, hbm8Lines);

    if(!BitBlt(hdcScreen, 0, 200, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 200, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 196, 200, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 300, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// Let's do some CreateCompatibleBitmap calls

    hbm1 = CreateCompatibleBitmap(hdcScreen, 100, 100);
    hbm2 = CreateCompatibleBitmap(hdcScreen, 128,128);

    SelectObject(hdc8Lines0,hbm1);

    BitBlt(hdc8Lines0, 0,0,64,64, hdc4Lines, 0, 0, SRCCOPY);
    BitBlt(hdc8Lines0, 0,64,32,32, hdc1Cat, 0,0, SRCCOPY);
    BitBlt(hdc8Lines0, 0,0, 30,30, (HDC) 0, 0, 0, PATCOPY);

    SelectObject(hdc4Lines0, hbm2);

    BitBlt(hdc4Lines0, 0, 0, 100, 100, hdc8Lines0, 0, 0, SRCCOPY);

    BitBlt(hdcScreen, 400,200, 100, 100, hdc4Lines0, 0, 0, SRCCOPY);

// Ok let's throw in some CreateCompatible calls.

    hbm1Cat0 =    CreateCompatibleBitmap(hdc1Cat, 32, 32);
    hbm1BigCat0 = CreateCompatibleBitmap(hdc1BigCat, 128, 32);
    hbm4Lines0 =  CreateCompatibleBitmap(hdc4Lines, 64, 64);
    hbm8Lines0 =  CreateCompatibleBitmap(hdc8Lines, 32, 32);

// Ok do a SetDibBits on them to see if that works.

    SetDIBits(hdcScreen, hbm8Lines0, 0, 32, _abColorLines2,
          (BITMAPINFO *) &_bmiPat2, DIB_RGB_COLORS);
    SetDIBits(hdcScreen, hbm8Lines0, 0, 32, _abColorLines2,
          (BITMAPINFO *) &_bmiPat2, DIB_RGB_COLORS);
    SelectObject(hdc8Lines0, hbm8Lines0);
    if(!BitBlt(hdcScreen, 228, 200, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    SetDIBits(hdcScreen, hbm4Lines0, 0, 64, _abColorLines,
          (BITMAPINFO *) &_bmiPat1, DIB_RGB_COLORS);
    SetDIBits(hdcScreen, hbm4Lines0, 0, 64, _abColorLines,
          (BITMAPINFO *) &_bmiPat1, DIB_RGB_COLORS);
    SelectObject(hdc4Lines0, hbm4Lines0);
    if(!BitBlt(hdcScreen, 128, 200, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// Lets test RLE8 compression to see if we get round trip conversion with
// SetDIBits:NON_RLE -> GetDIBits:RLE -> SetDIB:RLE -> GetDIBits:NON_RLE

    _bmiPat2.bmiHeader.biCompression = BI_RGB;
    _bmiPat2.bmiHeader.biSizeImage = 0;
    _bmiPat2.bmiHeader.biBitCount = 8;

    if( !GetDIBits( hdcScreen, hbm8Lines, 0, 0, NULL, (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES ))
    {
        DbgPrint( "RLE: GetDIBits hbmLines failed\n" );
    }

    if( ( pjTmpBuffer1 = LocalAlloc( LMEM_FIXED, _bmiPat2.bmiHeader.biSizeImage )) == NULL )
    {
        DbgPrint( "Local Alloc Failed\n");
    }

    if( !GetDIBits( hdcScreen, hbm8Lines, 0, _bmiPat2.bmiHeader.biHeight,
                    pjTmpBuffer1, (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbm8Lines failed\n" );
    }

    _bmiPat2.bmiHeader.biCompression = BI_RLE8;
    _bmiPat2.bmiHeader.biSizeImage = 0;
    _bmiPat2.bmiHeader.biBitCount = 8;

    if( !GetDIBits( hdcScreen, hbm8Lines, 0, 0, NULL, (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES ))
    {
        DbgPrint( "RLE: GetDIBits hbmLines failed\n" );
    }

    if( _bmiPat2.bmiHeader.biCompression != BI_RLE8 )
    {
        DbgPrint( "GetDIBits failed to return BI_RLE8\n" );
    }

    if( ( pjTmpBuffer2 = LocalAlloc( LMEM_FIXED, _bmiPat2.bmiHeader.biSizeImage )) == NULL )
    {
        DbgPrint( "Local Alloc Failed\n");
    }

    if( !GetDIBits( hdcScreen, hbm8Lines, 0, _bmiPat2.bmiHeader.biHeight,
                    pjTmpBuffer2, (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES ))
    {
        DbgPrint( "RLE8: GetDIBits hbmLines failed\n" );
    }

    SetDIBits(hdcScreen, hbm8Lines, 0, 64, pjTmpBuffer2,
          (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES);

    LocalFree( pjTmpBuffer2 );

    _bmiPat2.bmiHeader.biCompression = BI_RGB;
    _bmiPat2.bmiHeader.biSizeImage = 0;

    if( !GetDIBits( hdcScreen, hbm8Lines, 0, 0, NULL, (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES ))
    {
        DbgPrint( "RLE: GetDIBits hbm8Lines failed\n" );
    }

    if( ( pjTmpBuffer2 = LocalAlloc( LMEM_FIXED, _bmiPat2.bmiHeader.biSizeImage )) == NULL )
    {
        DbgPrint( "RLE: Local Alloc Failed\n");
    }

    if( !GetDIBits( hdcScreen, hbm8Lines, 0, _bmiPat2.bmiHeader.biHeight,
                    pjTmpBuffer2, (BITMAPINFO *) &_bmiPat2, DIB_PAL_INDICES ))
    {
        DbgPrint( "RLE8: GetDIBits hbmLines failed\n" );
    }

    if( _bmiPat2.bmiHeader.biSizeImage != 32 * 32 )
    {
        DbgPrint( "RLE8: Get/Set DIBits fails.  bmiHeader.biSize != 32 * 32\n");
    }
    else
    {
        int ii;

        for( ii = 0; ii < 32 * 32; ii ++ )
            if( pjTmpBuffer1[ii] !=  pjTmpBuffer2[ii] )
                DbgPrint( "RLE8: Get/Set DIBits byte %d doesn't match.\n", ii );
    }

    LocalFree( pjTmpBuffer1 );
    LocalFree( pjTmpBuffer2 );

// Lets test RLE4 compression to see if we get round trip conversion with
// SetDIBits:NON_RLE -> GetDIBits:RLE -> SetDIB:RLE -> GetDIBits:NON_RLE

    _bmiPat.bmiHeader.biCompression = BI_RGB;
    _bmiPat.bmiHeader.biSizeImage = 0;
    _bmiPat.bmiHeader.biBitCount = 4;

    if( !GetDIBits( hdcScreen, hbm4Lines, 0, 0, NULL, (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbm4Lines failed\n" );
    }

    if( ( pjTmpBuffer1 = LocalAlloc( LMEM_FIXED, _bmiPat.bmiHeader.biSizeImage )) == NULL )
    {
        DbgPrint( "Local Alloc Failed\n");
    }

    if( !GetDIBits( hdcScreen, hbm4Lines, 0, _bmiPat.bmiHeader.biHeight,
                    pjTmpBuffer1, (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbm4Lines failed\n" );
    }

    _bmiPat.bmiHeader.biCompression = BI_RLE4;
    _bmiPat.bmiHeader.biSizeImage = 0;
    _bmiPat.bmiHeader.biBitCount = 4;

    if( !GetDIBits( hdcScreen, hbm4Lines, 0, 0, NULL, (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbm4Lines failed\n" );
    }

    if( _bmiPat.bmiHeader.biCompression != BI_RLE4 )
    {
        DbgPrint( "RLE4: GetDIBits failed to return BI_RLE4 in biCompression\n" );
    }

    if( ( pjTmpBuffer2 = LocalAlloc( LMEM_FIXED, _bmiPat.bmiHeader.biSizeImage )) == NULL )
    {
        DbgPrint( "Local Alloc Failed\n");
    }

    if( !GetDIBits( hdcScreen, hbm4Lines, 0, _bmiPat.bmiHeader.biHeight,
                    pjTmpBuffer2, (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbm4Lines failed\n" );
    }

    SetDIBits(hdcScreen, hbm4Lines, 0, 64, pjTmpBuffer2,
              (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES);

    LocalFree( pjTmpBuffer2 );

    _bmiPat.bmiHeader.biCompression = BI_RGB;
    _bmiPat.bmiHeader.biSizeImage = 0;

    if( !GetDIBits( hdcScreen, hbm4Lines, 0, 0, NULL, (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbm4Lines failed\n" );
    }

    if( ( pjTmpBuffer2 = LocalAlloc( LMEM_FIXED, _bmiPat.bmiHeader.biSizeImage )) == NULL )
    {
        DbgPrint( "Local Alloc Failed\n");
    }

    if( !GetDIBits( hdcScreen, hbm4Lines, 0, _bmiPat.bmiHeader.biHeight,
                    pjTmpBuffer2, (BITMAPINFO *) &_bmiPat, DIB_PAL_INDICES ))
    {
        DbgPrint( "GetDIBits hbmLines failed\n" );
    }

    if( _bmiPat.bmiHeader.biSizeImage != 64 * 32)
    {
        DbgPrint( "RLE4: Get/Set DIBits fails.  bmiHeader.biSize != 64 * 32\n");
    }
    else
    {
        int ii;

        for( ii = 0; ii < 64 * 32; ii ++ )
            if( pjTmpBuffer1[ii] !=  pjTmpBuffer2[ii] )
                DbgPrint( "RLE4 Get/Set DIBits byte %d doesn't match.\n", ii );
    }

    LocalFree( pjTmpBuffer1 );
    LocalFree( pjTmpBuffer2 );

    _bmiPat.bmiHeader.biWidth = 32;
    SetDIBits(hdcScreen, hbm1Cat0, 0, 32, abBitCat,
           (BITMAPINFO *) &_bmiPat, DIB_RGB_COLORS);
    SelectObject(hdc1Cat0, hbm1Cat0);
    if(!BitBlt(hdcScreen, 32, 200, 32, 32, hdc1Cat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    _bmiPat.bmiHeader.biWidth = 128;
    SetDIBits(hdcScreen, hbm1BigCat0, 0, 32, abBigCat,
          (BITMAPINFO *) &_bmiPat, DIB_RGB_COLORS);
    SelectObject(hdc1BigCat0, hbm1BigCat0);
    if(!BitBlt(hdcScreen, 128, 300, 128, 32, hdc1BigCat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    DeleteObject(hbm1);
    DeleteObject(hbm2);

    StretchBlt(hdcScreen, 0, 0, 100, 100, hdc1Cat, 0, 0, 32, 32,  SRCCOPY);
    StretchBlt(hdcScreen, 0, 0, 0, 0, hdc1Cat, 0, 0, 32, 32,  SRCCOPY);
    StretchBlt(hdcScreen, 0, 0, 100, 100, hdc1Cat, 0, 0, 0, 0,  SRCCOPY);
    StretchBlt(hdcScreen, 100, 0, 100, 100, hdc4Lines, 0, 0, 64, 64, SRCCOPY);
    StretchBlt(hdcScreen, 200, 0, 100, 100, hdc8Lines, 0, 0, 32, 32,  SRCCOPY);
    StretchBlt(hdcScreen, 0, 100, 10, 10, hdc1Cat, 0, 0, 32, 32,  SRCCOPY);
    StretchBlt(hdcScreen, 100, 100, 10, 10, hdc4Lines, 0, 0, 64, 64, SRCCOPY);
    StretchBlt(hdcScreen, 200, 100, 10, 10, hdc8Lines, 0, 0, 32, 32,  SRCCOPY);
    StretchBlt(hdc1BigCat0, 0, 0, 128, 32, hdc1Cat, 0, 0, 32, 32,  SRCCOPY);
    if(!BitBlt(hdcScreen, 256, 300, 128, 32, hdc1BigCat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// Now try and initialize them with srccopy.

    if(!BitBlt(hdc1Cat0, 0, 0, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc1BigCat0, 0, 0, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines0, 0, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines0, 0, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// Ok real quick here let's test if CreateCompatible Bitmap does an
// identity blt to the screen.

    if(!BitBlt(hdcScreen, 32, 200, 32, 32, hdc1Cat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 200, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 228, 200, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 300, 128, 32, hdc1BigCat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*********************************************************************

    4 on 4 tests

***********************************************************************/

    // Now let's test the 4 to 4 case even odd.

        if(!BitBlt(hdc4Lines, 0, 0, 8, 8, hdc4Lines, 23, 23, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 0, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 56, 56, 8, 8, hdc4Lines, 15, 15, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 64, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 56, 0, 8, 8, hdc4Lines, 15, 15, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 128, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 0, 56, 8, 8, hdc4Lines, 23, 23, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 192, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 15, 15, 10, 10, hdc4Lines, 15, 15, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 256, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 320, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

    // Now let's test the 4 to 4 case even.

        if(!BitBlt(hdc4Lines, 0, 0, 8, 8, hdc4Lines, 24, 24, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 384, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 56, 56, 8, 8, hdc4Lines, 16, 16, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 448, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 56, 0, 8, 8, hdc4Lines, 16, 16, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 512, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 0, 56, 8, 8, hdc4Lines, 24, 24, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 576, 0, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 16, 16, 8, 14, hdc4Lines, 16, 16, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 0, 64, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 64, 64, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

/**************************************************************************

    Now do the 8 on 4 tests

**************************************************************************/

    if(!BitBlt(hdc4Lines, 16, 16, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 128, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc4Lines, 15, 15, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 128, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc4Lines, 15, 15, 31, 31, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 128, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc4Lines, 16, 16, 31, 31, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 192, 128, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 256, 128, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/************************************************************************

    Now let's try the 1 on 4 tests

*************************************************************************/

    if(!BitBlt(hdc4Lines, 16, 16, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 192, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc4Lines, 15, 15, 32, 32, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 192, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc4Lines, 15, 15, 31, 31, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 192, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc4Lines, 16, 16, 31, 31, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 192, 192, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdcScreen, 256, 192, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*********************************************************************

    8 on 8 tests

***********************************************************************/

    if(!BitBlt(hdc8Lines, 16, 16, 8, 8, hdc8Lines0, 16, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 1, 1, 29, 29, hdc8Lines0, 1, 1, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 24, 24, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 24, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 24, 0, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 16, 16, 8, 8, hdc8Lines, 16, 16, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 160, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/************************************************************************

    Test 1 to 8 blting

*************************************************************************/

    if(!BitBlt(hdc8Lines, 4,4, 16, 16, hdc1Cat, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 192, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 4, 4, 17, 17, hdc1Cat, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 224, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 25, 25, hdc1Cat, 3, 3, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 256, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 26, 26, hdc1Cat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 288, 256, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 320, 256, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test 4 to 8 blting

**************************************************************************/

    if(!BitBlt(hdc8Lines, 4,4, 16, 16, hdc4Lines, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 0, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 4, 4, 17, 17, hdc4Lines, 4, 4, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 32, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 25, 25, hdc4Lines, 3, 3, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 64, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 3, 3, 26, 26, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 96, 288, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 288, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Solid Brush Output to 8

**************************************************************************/

    PatBlt(hdcScreen, 0, 0, 100, 99, PATCOPY);

    PatBlt(hdc8Lines, 1, 0, 17, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 0, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 0, 8, 8, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 32, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 1, 16, 2, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 64, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 4, 24, 8, 8, PATCOPY);

    if(!BitBlt(hdcScreen, 96, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Xor Output to 8

**************************************************************************/

    PatBlt(hdc8Lines, 1, 0, 17, 8, DSTINVERT);

    if(!BitBlt(hdcScreen, 200, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 0, 8, 8, 8, DSTINVERT);

    if(!BitBlt(hdcScreen, 232, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 1, 16, 2, 8, DSTINVERT);

    if(!BitBlt(hdcScreen, 264, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");


    PatBlt(hdc8Lines, 4, 24, 8, 8, DSTINVERT);

    if(!BitBlt(hdcScreen, 296, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc8Lines, 0, 0, 32, 32, hdc8Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 328, 320, 32, 32, hdc8Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Solid Brush Output to 4

**************************************************************************/

    BitBlt(hdcScreen, 0, 0, 32, 32, (HDC) 0, 0, 0, PATCOPY);

    BitBlt(hdc4Lines, 0, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY);

    BitBlt(hdc4Lines, 1, 0, 17, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 0, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdc4Lines, 0, 8, 8, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 32, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdc4Lines, 1, 16, 2, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 64, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdc4Lines, 4, 24, 8, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 96, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 32, 32, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 128, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Xor Output to 4

**************************************************************************/

    BitBlt(hdc4Lines, 0, 0, 32, 32, hdc8Lines, 0, 0, SRCCOPY);

    BitBlt(hdc4Lines, 1, 0, 17, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 200, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdc4Lines, 0, 8, 8, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 232, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdc4Lines, 1, 16, 2, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 264, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    BitBlt(hdc4Lines, 4, 24, 8, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 296, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdc4Lines, 0, 0, 32, 32, hdc4Lines0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 328, 352, 32, 32, hdc4Lines, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Solid Brush Output to 1

**************************************************************************/

    BitBlt(hdcScreen, 0, 384, 640, 95, (HDC) 0, 0, 0, WHITENESS);

// 2 masks no middle

    BitBlt(hdc1BigCat, 1, 0, 62, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 0, 385, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// no masks 4 middle

    BitBlt(hdc1BigCat, 0, 8, 128, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 129, 385, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// 1 mask, no middle

    BitBlt(hdc1BigCat, 5, 16, 22, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 258, 385, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// 2 mask, 2 middle

    BitBlt(hdc1BigCat, 4, 24, 120, 8, (HDC) 0, 0, 0, PATCOPY);

    if(!BitBlt(hdcScreen, 387, 385, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    Test Xor Output to 1

**************************************************************************/

// 2 masks no middle

    BitBlt(hdc1BigCat, 1, 0, 62, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 0, 418, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// no masks 4 middle

    BitBlt(hdc1BigCat, 0, 8, 128, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 129, 418, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// 1 mask, no middle

    BitBlt(hdc1BigCat, 5, 16, 22, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 258, 418, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// 2 mask, 2 middle

    BitBlt(hdc1BigCat, 4, 24, 120, 8, (HDC) 0, 0, 0, DSTINVERT);

    if(!BitBlt(hdcScreen, 387, 418, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

// clean up

    if(!BitBlt(hdc1BigCat, 0, 0, 128, 32, hdc1BigCat0, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

    if(!BitBlt(hdcScreen, 400, 352, 128, 32, hdc1BigCat, 0, 0, SRCCOPY))
        DbgPrint("ERROR: BitBlt returned FALSE\n");

/*************************************************************************

    SetDIBitsToDevice calls

**************************************************************************/

    // DbgBreakPoint();

    PatBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, WHITENESS);

    _bmiPat.bmiHeader.biWidth = 32;

    SetDIBitsToDevice(hdcScreen, 0, 0, 32, 32,
                      0, 0, 0, 32,
                      abBitCat, (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    _bmiPat.bmiHeader.biWidth = 128;

    SetDIBitsToDevice(hdcScreen, 32, 0, 128, 32,
                      0, 0, 0, 32,
                      abBigCat, (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 160, 0, 64, 64,
                      0, 0, 0, 64,
                      _abColorLines, (LPBITMAPINFO) &_bmiPat1, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 224, 0, 32, 32,
                      0, 0, 0, 32,
                      _abColorLines2, (LPBITMAPINFO) &_bmiPat2, DIB_RGB_COLORS);


    _bmiPat.bmiHeader.biWidth = 32;

    SetDIBitsToDevice(hdcScreen, 0, 100, 32, 32,
                      0, 0, 0, 16,
                      abBitCat, (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 0, 100, 32, 32,
                      0, 0, 16, 16,
                      &abBitCat[16 * 4], (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);



    SetDIBitsToDevice(hdcScreen, 0, 200, 32, 32,
                      0, 0, 16, 16,
              &abBitCat[16 * 4], (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    // DbgBreakPoint();

    SetDIBitsToDevice(hdcScreen, 0, 200, 32, 32,
                      0, 0, 0, 16,
                      abBitCat, (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    _bmiPat.bmiHeader.biWidth = 128;

    SetDIBitsToDevice(hdcScreen, 32, 100, 128, 32,
                      0, 0, 0, 16,
                      abBigCat, (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 32, 100, 128, 32,
                      0, 0, 16, 16,
              &abBigCat[16 * 16], (LPBITMAPINFO) &_bmiPat, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen,
                      160, 100, 64, 64,
                      0, 0, 0, 32,
                      _abColorLines,
                      (LPBITMAPINFO) &_bmiPat1, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen,
                      160, 100, 64, 64,
                      0, 0, 32, 32,
                      &_abColorLines[64 * 16],
                      (LPBITMAPINFO) &_bmiPat1, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 224, 100, 32, 32,
                      0, 0, 0, 16,
                      _abColorLines2, (LPBITMAPINFO) &_bmiPat2, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 224, 100, 32, 32,
                      0, 0, 16, 16,
                      &_abColorLines2[32 * 16], (LPBITMAPINFO) &_bmiPat2, DIB_RGB_COLORS);

/******************************Public*Routine******************************\
*
* SetPixel testing.
*
* History:
*  21-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
    {
    ULONG xDst;

    // DbgBreakPoint();

    // First Black out the screen.

    BitBlt(hdcScreen, 0, 0, 640, 480, (HDC) 0, 0, 0, WHITENESS);

        for (xDst = 0; xDst < 10; xDst++)
        {
              SetPixel(hdcScreen, xDst, 10, RGB(0xFF, 0, 0));
              SetPixel(hdcScreen, xDst, 11, RGB(0xFF, 0, 0));
              SetPixel(hdcScreen, xDst, 12, RGB(0xFF, 0, 0));
              SetPixel(hdcScreen, xDst, 13, RGB(0xFF, 0, 0));
              SetPixel(hdcScreen, xDst, 14, RGB(0xFF, 0, 0));

              SetPixel(hdcScreen, xDst, 20, RGB(0, 0xFF, 0));
              SetPixel(hdcScreen, xDst, 21, RGB(0, 0xFF, 0));
              SetPixel(hdcScreen, xDst, 22, RGB(0, 0xFF, 0));
              SetPixel(hdcScreen, xDst, 23, RGB(0, 0xFF, 0));
              SetPixel(hdcScreen, xDst, 24, RGB(0, 0xFF, 0));

              SetPixel(hdcScreen, xDst, 30, RGB(0, 0, 0xFF));
              SetPixel(hdcScreen, xDst, 31, RGB(0, 0, 0xFF));
              SetPixel(hdcScreen, xDst, 32, RGB(0, 0, 0xFF));
              SetPixel(hdcScreen, xDst, 33, RGB(0, 0, 0xFF));
              SetPixel(hdcScreen, xDst, 34, RGB(0, 0, 0xFF));

              SetPixel(hdcScreen, xDst, 40, RGB(0xFF, 0xFF, 0xFF));
              SetPixel(hdcScreen, xDst, 41, RGB(0xFF, 0xFF, 0xFF));
              SetPixel(hdcScreen, xDst, 42, RGB(0xFF, 0xFF, 0xFF));
              SetPixel(hdcScreen, xDst, 43, RGB(0xFF, 0xFF, 0xFF));
              SetPixel(hdcScreen, xDst, 44, RGB(0xFF, 0xFF, 0xFF));

              SetPixel(hdcScreen, xDst, 50, PALETTEINDEX(0));
              SetPixel(hdcScreen, xDst, 51, PALETTEINDEX(0));
              SetPixel(hdcScreen, xDst, 52, PALETTEINDEX(0));
              SetPixel(hdcScreen, xDst, 53, PALETTEINDEX(0));
              SetPixel(hdcScreen, xDst, 54, PALETTEINDEX(0));

              SetPixel(hdcScreen, xDst, 61, PALETTEINDEX(1));
              SetPixel(hdcScreen, xDst, 62, PALETTEINDEX(1));
              SetPixel(hdcScreen, xDst, 63, PALETTEINDEX(1));
              SetPixel(hdcScreen, xDst, 64, PALETTEINDEX(1));
              SetPixel(hdcScreen, xDst, 65, PALETTEINDEX(1));

              SetPixel(hdcScreen, xDst, 70, PALETTEINDEX(2));
              SetPixel(hdcScreen, xDst, 71, PALETTEINDEX(2));
              SetPixel(hdcScreen, xDst, 72, PALETTEINDEX(2));
              SetPixel(hdcScreen, xDst, 73, PALETTEINDEX(2));
              SetPixel(hdcScreen, xDst, 74, PALETTEINDEX(2));

              SetPixel(hdcScreen, xDst, 80, PALETTEINDEX(3));
              SetPixel(hdcScreen, xDst, 81, PALETTEINDEX(3));
              SetPixel(hdcScreen, xDst, 82, PALETTEINDEX(3));
              SetPixel(hdcScreen, xDst, 83, PALETTEINDEX(3));
              SetPixel(hdcScreen, xDst, 84, PALETTEINDEX(3));

              SetPixel(hdcScreen, xDst, 90, PALETTEINDEX(4));
              SetPixel(hdcScreen, xDst, 91, PALETTEINDEX(4));
              SetPixel(hdcScreen, xDst, 92, PALETTEINDEX(4));
              SetPixel(hdcScreen, xDst, 93, PALETTEINDEX(4));
              SetPixel(hdcScreen, xDst, 94, PALETTEINDEX(4));

        }

        BitBlt(hdc4Lines, 0, 0, 64, 64, (HDC) 0, 0, 0, BLACKNESS);

        for (xDst = 0; xDst < 16; xDst++)
        {
            if (0x000000FF != SetPixel(hdc4Lines, xDst, 0, RGB(0xFF, 0, 0)))
                DbgPrint("Wrong return value1\n");

            ulTemp = GetPixel(hdc4Lines, xDst, 0);

            if (0x000000FF != ulTemp)
                DbgPrint("Wrong return value1.5 %lx\n", ulTemp);

            SetPixel(hdc4Lines, xDst, 1, RGB(0xFF, 0, 0));
            SetPixel(hdc4Lines, xDst, 2, RGB(0xFF, 0, 0));
            SetPixel(hdc4Lines, xDst, 3, RGB(0xFF, 0, 0));
            SetPixel(hdc4Lines, xDst, 4, RGB(0xFF, 0, 0));

            if (0x0000FF00 != SetPixel(hdc4Lines, xDst, 10, RGB(0, 0xFF, 0)))
                DbgPrint("Wrong return value2\n");

            ulTemp = GetPixel(hdc4Lines, xDst, 10);

            if (0x0000FF00 != ulTemp)
                DbgPrint("Wrong return value2.5 %lx \n", ulTemp);

            SetPixel(hdc4Lines, xDst, 11, RGB(0, 0xFF, 0));
            SetPixel(hdc4Lines, xDst, 12, RGB(0, 0xFF, 0));
            SetPixel(hdc4Lines, xDst, 13, RGB(0, 0xFF, 0));
            SetPixel(hdc4Lines, xDst, 14, RGB(0, 0xFF, 0));

            if (0x00FF0000 != SetPixel(hdc4Lines, xDst, 20, RGB(0, 0, 0xFF)))
                    DbgPrint("Wrong value returned3\n");
            if (0x00FF0000 != GetPixel(hdc4Lines, xDst, 20))
                DbgPrint("Wrong return value3.5\n");

            SetPixel(hdc4Lines, xDst, 21, RGB(0, 0, 0xFF));
            SetPixel(hdc4Lines, xDst, 22, RGB(0, 0, 0xFF));
            SetPixel(hdc4Lines, xDst, 23, RGB(0, 0, 0xFF));
            SetPixel(hdc4Lines, xDst, 24, RGB(0, 0, 0xFF));

            SetPixel(hdc4Lines, xDst, 30, RGB(0xFF, 0xFF, 0xFF));
            SetPixel(hdc4Lines, xDst, 31, RGB(0xFF, 0xFF, 0xFF));
            SetPixel(hdc4Lines, xDst, 32, RGB(0xFF, 0xFF, 0xFF));
            SetPixel(hdc4Lines, xDst, 33, RGB(0xFF, 0xFF, 0xFF));
            SetPixel(hdc4Lines, xDst, 34, RGB(0xFF, 0xFF, 0xFF));

            SetPixel(hdc4Lines, xDst, 40, PALETTEINDEX(0));
            SetPixel(hdc4Lines, xDst, 41, PALETTEINDEX(0));
            SetPixel(hdc4Lines, xDst, 42, PALETTEINDEX(0));
            SetPixel(hdc4Lines, xDst, 43, PALETTEINDEX(0));
            SetPixel(hdc4Lines, xDst, 44, PALETTEINDEX(0));

            SetPixel(hdc4Lines, xDst, 45, PALETTEINDEX(1));
            SetPixel(hdc4Lines, xDst, 46, PALETTEINDEX(1));
            SetPixel(hdc4Lines, xDst, 47, PALETTEINDEX(1));
            SetPixel(hdc4Lines, xDst, 48, PALETTEINDEX(1));
            SetPixel(hdc4Lines, xDst, 49, PALETTEINDEX(1));

            SetPixel(hdc4Lines, xDst, 50, PALETTEINDEX(2));
            SetPixel(hdc4Lines, xDst, 51, PALETTEINDEX(2));
            SetPixel(hdc4Lines, xDst, 52, PALETTEINDEX(2));
            SetPixel(hdc4Lines, xDst, 53, PALETTEINDEX(2));
            SetPixel(hdc4Lines, xDst, 54, PALETTEINDEX(2));

            SetPixel(hdc4Lines, xDst, 55, PALETTEINDEX(3));
            SetPixel(hdc4Lines, xDst, 56, PALETTEINDEX(3));
            SetPixel(hdc4Lines, xDst, 57, PALETTEINDEX(3));
            SetPixel(hdc4Lines, xDst, 58, PALETTEINDEX(3));
            SetPixel(hdc4Lines, xDst, 59, PALETTEINDEX(3));

            SetPixel(hdc4Lines, xDst, 60, PALETTEINDEX(4));
            SetPixel(hdc4Lines, xDst, 61, PALETTEINDEX(4));
            SetPixel(hdc4Lines, xDst, 62, PALETTEINDEX(4));
            SetPixel(hdc4Lines, xDst, 63, PALETTEINDEX(4));
        }

        if(!BitBlt(hdcScreen, 0, 100, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdc4Lines, 0, 0, 64, 64, hdc4Lines0, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");

        if(!BitBlt(hdcScreen, 0, 200, 64, 64, hdc4Lines, 0, 0, SRCCOPY))
            DbgPrint("ERROR: BitBlt returned FALSE\n");
    }

// Time for GetDIBits tests

    {
    BITMAPINFOPAT bmiPatTemp;
    ULONG ulTemp;
    PUSHORT pusTemp;
    PBYTE pjTemp;

    pjTemp = (PBYTE) &bmiPatTemp;
    bmiPatTemp.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmiPatTemp.bmiHeader.biBitCount = 0;

    // First let's see if it fills in the header correctly.

    if (!GetDIBits(hdcScreen, hbm4Lines,
          0, 64,
          NULL, (BITMAPINFO *) &bmiPatTemp, DIB_RGB_COLORS))
    {
        DbgPrint("GetDIBits returned False0\n");
    }

    // First let's see if it fills in a header and rgbquads correctly

    if (!GetDIBits(hdcScreen, hbm4Lines,
          0, 64,
          NULL, (BITMAPINFO *) &bmiPatTemp, DIB_RGB_COLORS))
    {
        DbgPrint("GetDIBits returned False0\n");
    }

    // Ok let's see if it returned what we expected

    if (bmiPatTemp.bmiHeader.biSize != sizeof(BITMAPINFOHEADER))
        DbgPrint("Error GetDIBits returned wrong info1\n");
    if (bmiPatTemp.bmiHeader.biWidth != _bmiPat1.bmiHeader.biWidth)
        DbgPrint("Error GetDIBits returned wrong info2\n");

    if (bmiPatTemp.bmiHeader.biHeight != _bmiPat1.bmiHeader.biHeight)
    {
        if (bmiPatTemp.bmiHeader.biHeight == -_bmiPat1.bmiHeader.biHeight)
        {
           bmiPatTemp.bmiHeader.biHeight = -bmiPatTemp.bmiHeader.biHeight;
        }
        else
        {
           DbgPrint("Error GetDIBits returned wrong info3\n");
        }
    }

    if (bmiPatTemp.bmiHeader.biPlanes != 1)
        DbgPrint("Error GetDIBits returned wrong info4\n");
    if (bmiPatTemp.bmiHeader.biCompression != BI_RGB)
        DbgPrint("Error GetDIBits returned wrong info5\n");
    if (bmiPatTemp.bmiHeader.biBitCount != _bmiPat1.bmiHeader.biBitCount)
        DbgPrint("Error GetDIBits returned wrong info6\n");
    if (bmiPatTemp.bmiHeader.biXPelsPerMeter != 0)
        DbgPrint("Error GetDIBits returned wrong info8\n");
    if (bmiPatTemp.bmiHeader.biYPelsPerMeter != 0)
        DbgPrint("Error GetDIBits returned wrong info9\n");
    if (bmiPatTemp.bmiHeader.biClrUsed != _bmiPat1.bmiHeader.biClrUsed)
        DbgPrint("Error GetDIBits returned wrong info10\n");
    if (bmiPatTemp.bmiHeader.biClrImportant != _bmiPat1.bmiHeader.biClrImportant)
        DbgPrint("Error GetDIBits returned wrong info11\n");

    // Ok let's get studly.  Let's get the whole mofo bitmap

    if (!GetDIBits(hdcScreen, hbm4Lines,
          0, 64,
          gajTemp, (BITMAPINFO *) &bmiPatTemp, DIB_RGB_COLORS))
    {
        DbgPrint("GetDIBits returned False1\n");
    }

    // How about the color table.

    for (ulTemp = 0; ulTemp < 16; ulTemp++)
    {
        if (_bmiPat1.bmiColors[ulTemp].rgbRed !=
        bmiPatTemp.bmiColors[ulTemp].rgbRed)
        {
        DbgPrint("Error Red is wrong555\n");
        }

        if (_bmiPat1.bmiColors[ulTemp].rgbBlue !=
        bmiPatTemp.bmiColors[ulTemp].rgbBlue)
        {
        DbgPrint("Error Blue is wrong5555\n");
        }

        if (_bmiPat1.bmiColors[ulTemp].rgbGreen !=
        bmiPatTemp.bmiColors[ulTemp].rgbGreen)
        {
        DbgPrint("Error Green is wrong5555\n");
        }

        if (_bmiPat1.bmiColors[ulTemp].rgbReserved !=
        bmiPatTemp.bmiColors[ulTemp].rgbReserved)
        {
        DbgPrint("Error Reserved is wrong5555\n");
        }
    }

    // Compare the bits

    for (ulTemp = 0; ulTemp < 64 * 32; ulTemp++)
    {
        if (gajTemp[ulTemp] != _abColorLines[ulTemp])
        DbgPrint("1Error unmatching bytes %lu (%x vs %x)\n", ulTemp, gajTemp[ulTemp], _abColorLines[ulTemp]);
    }

    // Ok let's see if it returned header and colors we expected

    if (bmiPatTemp.bmiHeader.biSize != sizeof(BITMAPINFOHEADER))
        DbgPrint("Error GetDIBits returned wrong info1\n");
    if (bmiPatTemp.bmiHeader.biWidth != _bmiPat1.bmiHeader.biWidth)
        DbgPrint("Error GetDIBits returned wrong info2\n");
    if (bmiPatTemp.bmiHeader.biHeight != _bmiPat1.bmiHeader.biHeight)
    {
        if (bmiPatTemp.bmiHeader.biHeight == -_bmiPat1.bmiHeader.biHeight)
        {

        }
        else
        {
           DbgPrint("Error GetDIBits returned wrong info3\n");
        }
    }
    if (bmiPatTemp.bmiHeader.biPlanes != 1)
        DbgPrint("Error GetDIBits returned wrong info4\n");
    if (bmiPatTemp.bmiHeader.biCompression != BI_RGB)
        DbgPrint("Error GetDIBits returned wrong info5\n");
    if (bmiPatTemp.bmiHeader.biBitCount != _bmiPat1.bmiHeader.biBitCount)
        DbgPrint("Error GetDIBits returned wrong info6\n");
    if (bmiPatTemp.bmiHeader.biXPelsPerMeter != 0)
        DbgPrint("Error GetDIBits returned wrong info8\n");
    if (bmiPatTemp.bmiHeader.biYPelsPerMeter != 0)
        DbgPrint("Error GetDIBits returned wrong info9\n");
    if (bmiPatTemp.bmiHeader.biClrUsed != _bmiPat1.bmiHeader.biClrUsed)
        DbgPrint("Error GetDIBits returned wrong info10\n");
    if (bmiPatTemp.bmiHeader.biClrImportant != _bmiPat1.bmiHeader.biClrImportant)
        DbgPrint("Error GetDIBits returned wrong info11\n");

    // How about the color table.

    for (ulTemp = 0; ulTemp < 16; ulTemp++)
    {
        if (_bmiPat1.bmiColors[ulTemp].rgbRed !=
        bmiPatTemp.bmiColors[ulTemp].rgbRed)
        {
        DbgPrint("Error Red is wrong\n");
        }

        if (_bmiPat1.bmiColors[ulTemp].rgbBlue !=
        bmiPatTemp.bmiColors[ulTemp].rgbBlue)
        {
        DbgPrint("Error Blue is wrong\n");
        }

        if (_bmiPat1.bmiColors[ulTemp].rgbGreen !=
        bmiPatTemp.bmiColors[ulTemp].rgbGreen)
        {
        DbgPrint("Error Green is wrong\n");
        }

        if (_bmiPat1.bmiColors[ulTemp].rgbReserved !=
        bmiPatTemp.bmiColors[ulTemp].rgbReserved)
        {
        DbgPrint("Error Reserved is wrong\n");
        }
    }

    // DbgPrint("Passed GetDIBits PAL_RGB_COLORS\n");

    for (ulTemp = 16; ulTemp < (sizeof(BITMAPINFOPAT) - 16); ulTemp++)
    {
        pjTemp[ulTemp] = 0;
    }

    // Ok let's get studly.  Let's get the whole mofo bitmap

    if (!GetDIBits(hdcScreen, hbm4Lines,
          0, 64,
          gajTemp, (BITMAPINFO *) &bmiPatTemp, DIB_PAL_COLORS))
    {
        DbgPrint("GetDIBits returned False2\n");
    }

    // Ok let's see if it returned header and colors we expected

    if (bmiPatTemp.bmiHeader.biSize != sizeof(BITMAPINFOHEADER))
        DbgPrint("Error GetDIBits returned wrong info1\n");
    if (bmiPatTemp.bmiHeader.biWidth != _bmiPat1.bmiHeader.biWidth)
        DbgPrint("Error GetDIBits returned wrong info2\n");
    if (bmiPatTemp.bmiHeader.biHeight != _bmiPat1.bmiHeader.biHeight)
        DbgPrint("Error GetDIBits returned wrong info3\n");
    if (bmiPatTemp.bmiHeader.biPlanes != 1)
        DbgPrint("Error GetDIBits returned wrong info4\n");
    if (bmiPatTemp.bmiHeader.biCompression != BI_RGB)
        DbgPrint("Error GetDIBits returned wrong info5\n");
    if (bmiPatTemp.bmiHeader.biBitCount != _bmiPat1.bmiHeader.biBitCount)
        DbgPrint("Error GetDIBits returned wrong info6\n");
    if (bmiPatTemp.bmiHeader.biXPelsPerMeter != 0)
        DbgPrint("Error GetDIBits returned wrong info8\n");
    if (bmiPatTemp.bmiHeader.biYPelsPerMeter != 0)
        DbgPrint("Error GetDIBits returned wrong info9\n");
    if (bmiPatTemp.bmiHeader.biClrUsed != _bmiPat1.bmiHeader.biClrUsed)
        DbgPrint("Error GetDIBits returned wrong info10\n");
    if (bmiPatTemp.bmiHeader.biClrImportant != _bmiPat1.bmiHeader.biClrImportant)
        DbgPrint("Error GetDIBits returned wrong info11\n");

    // DbgPrint("The header was correct for DIB_PAL_COLORS\n");

    // How about the color table.

        pusTemp = (PUSHORT) bmiPatTemp.bmiColors;

    // Now see that SetDIBitsToDevice works

    PatBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, WHITENESS);

    SetDIBitsToDevice(hdcScreen, 0, 0, 64, 64,
              0, 0, 0, 64,
              _abColorLines, (LPBITMAPINFO) &_bmiPat1,
              DIB_RGB_COLORS);

    SetDIBitsToDevice(hdcScreen, 64, 0, 64, 64,
                     0, 0, 0, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
               DIB_PAL_COLORS);

    SetDIBitsToDevice(hdcScreen, 128, 0, 64, 64,
                     0, 0, 0, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
                       DIB_PAL_COLORS);

    // DbgPrint("Now trying StretchDIBits calls\n");

    StretchDIBits(hdcScreen, 0, 100, 128, 128,
              0, 0, 64, 64,
              _abColorLines, (LPBITMAPINFO) &_bmiPat1,
              DIB_RGB_COLORS, SRCCOPY);

    StretchDIBits(hdcScreen, 128, 100, 128, 128,
                     0, 0, 64, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
               DIB_PAL_COLORS, SRCCOPY);

    StretchDIBits(hdcScreen, 256, 100, 128, 128,
                     0, 0, 64, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
                       DIB_PAL_COLORS, SRCCOPY);

// Try doing a stretch that flips

    StretchDIBits(hdcScreen, 0, 232, 128, 128,
                     0, 0, 64, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
                       DIB_PAL_COLORS, SRCCOPY);
    StretchDIBits(hdcScreen, 256, 232, -128, 128,
                     0, 0, 64, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
                       DIB_PAL_COLORS, SRCCOPY);
    StretchDIBits(hdcScreen, 256, 360, 128, -128,
                     0, 0, 64, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
                       DIB_PAL_COLORS, SRCCOPY);
    StretchDIBits(hdcScreen, 512, 360, -128, -128,
                     0, 0, 64, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
                       DIB_PAL_COLORS, SRCCOPY);

    // DbgPrint("Now trying PC_EXPLICIT stuff\n");

    hpalExplicit = CreatePalette((LOGPALETTE *) &palExplicit);

    if (hpalExplicit == (HPALETTE) 0)
        DbgPrint("hpalExplicit creation failed\n");

    SelectPalette(hdcScreen, hpalExplicit, 0);
    RealizePalette(hdcScreen);

    SetDIBitsToDevice(hdcScreen, 192, 0, 64, 64,
                     0, 0, 0, 64,
               gajTemp, (LPBITMAPINFO) &bmiPatTemp,
               DIB_PAL_COLORS);

    }

    {
    BITMAP bm;

    ulTemp = GetObject(hbm8Lines, 0, (LPSTR) NULL);

    if (ulTemp != sizeof(BITMAP))
        DbgPrint("Error in GetObject\n");

    ulTemp = GetObject(hbm8Lines, sizeof(BITMAP), (LPSTR) &bm);

    if (ulTemp != sizeof(BITMAP))
        DbgPrint("Error in GetObject\n");

    if (bm.bmType != 0)
        DbgPrint("ERROR1\n");

    if (bm.bmWidth != 32)
        DbgPrint("ERROR2\n");

    if (bm.bmHeight != 32)
        DbgPrint("ERROR3\n");

    if (bm.bmWidthBytes != 32)
        DbgPrint("ERROR4\n");

    if (bm.bmBitsPixel != 8)
        DbgPrint("ERROR5\n");

    if (bm.bmPlanes != 1)
        DbgPrint("ERROR6\n");

    if (bm.bmBits != (LPSTR) NULL)
        DbgPrint("ERROR7\n");

    // DbgPrint("Passed GetObject\n");
    }

#if 0

// CreateDIBSection tests

    {
        HDC hdcdib;
        HBITMAP hbm, hdib, hbmOld, hdibSection, hbmComp;
        HBRUSH  hbr, hbrOld;
        int c;
        ULONG  aRGB[4];
        DIBSECTION dib;
        HANDLE hApp;
        PBYTE pjBits, pjBitsComp;
        PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER)&bmiCT;
        PBITMAPINFO pbmi = (PBITMAPINFO)&bmiCT;

    // Clear Screen

        PatBlt(hdcScreen, 0, 0, ScreenWidth, ScreenHeight, WHITENESS);
        SelectPalette(hdcScreen,GetStockObject(DEFAULT_PALETTE),FALSE);
        RealizePalette(hdcScreen);

    // CreateDIBitmap with CBM_CREATEDIB, Green circle on red background

        hdcdib = CreateCompatibleDC(hdcScreen);
        hdib = CreateDIBitmap(hdcScreen,pbmih,CBM_CREATEDIB,NULL,pbmi,DIB_RGB_COLORS);
        hbmOld = SelectObject(hdcdib, hdib);
        hbr = CreateSolidBrush(RGB(0,255,0));
        hbrOld = SelectObject(hdcdib, hbr);
        Ellipse(hdcdib, 10, 10, 30, 30);
        BitBlt(hdcScreen, 0, 0, 100, 100, hdcdib, 0, 0, SRCCOPY);
        TextOut(hdcScreen,0, 110, "green on red",12);
        SelectObject(hdcdib,hbmOld);
        DeleteObject(hdib);

    // DIB section created by GDI.  Green circle on red background

        hdibSection = CreateDIBSection(hdcScreen,pbmi,DIB_RGB_COLORS,&pjBits,0,0);
        hbmOld = SelectObject(hdcdib, hdibSection);
        Ellipse(hdcdib, 10, 10, 30, 30);
        for (c = 100*2; c < 100*6; c++)
            *(pjBits + c) = 2;
        BitBlt(hdcScreen, 200, 0, 100, 100, hdcdib, 0, 0, SRCCOPY);
        TextOut(hdcScreen,200, 110, "green on red w blue lines",25);

    // Should get 2 entries back -- blue (0xff), green(0xff00)

        c = GetDIBColorTable(hdcdib,2,3,(RGBQUAD *)&aRGB);
        if (c != 3)
            DbgPrint("GetDIBColorTable returns %x, should return 2\n",c);
        if (aRGB[0] != 0xff)
            DbgPrint("GetDIBColorTable: aRGB[0] = %x, should be 0xff\n",aRGB[0]);
        if (aRGB[1] != 0)
            DbgPrint("GetDIBColorTable: aRGB[1] = %x, should be 0xff00\n",aRGB[1]);

    // Change the color table of the DIB section to cyan and yellow.
    // SetColorTable should return 2.

        aRGB[0] = 0x0ffff;
        aRGB[1] = 0x0ffff00;
        c = SetDIBColorTable(hdcdib,0,2,(RGBQUAD *)&aRGB);
        if (c != 2)
            DbgPrint("SetDIBColorTable returns %lx, should be 2\n",c);
        BitBlt(hdcScreen, 400, 0, 100, 100, hdcdib, 0, 0, SRCCOPY);
        TextOut(hdcScreen,400, 110, "yellow on cyan w blue lines",27);

    // CreateCompatibleBitmap for a dc that has a dibsection selected into.

        hbmComp = CreateCompatibleBitmap(hdcdib, 80, 80);
        if (hbmComp == NULL)
        {
            DbgPrint("couldn't create compatible bitmap\n");
        }
        else
        {
            c = GetObject(hbmComp, sizeof(DIBSECTION), &dib);
            if (c != sizeof(DIBSECTION))
                DbgPrint("GetObject2 returns %ld, should be sizeof(DIBSECTION)\n", c);
            if (dib.dsBm.bmBits == 0)
                DbgPrint("GetObject2 returns wrong pjBits = %lx\n", dib.dsBm.bmBits);
            if (dib.dsBmih.biWidth != 80)
                DbgPrint("GetObject2 returns wrong biWidth = %lx\n", dib.dsBmih.biWidth);
            if (dib.dshSection != 0)
                DbgPrint("GetObject2 returns wrong hSection = %lx\n", dib.dshSection);
            if (dib.dsOffset != 0)
                DbgPrint("GetObject2 returns wrong dwOffset = %lx\n", dib.dsOffset);

        // Draw into the compatible bitmap and blt to the screen.

            SelectObject(hdcdib,hbmComp);
            BitBlt(hdcScreen, 600, 0, 80, 80, hdcdib, 0, 0, SRCCOPY);
            TextOut(hdcScreen,600, 110, "solid cyan box",14);
            pjBitsComp = dib.dsBm.bmBits;
            SelectObject(hdcdib, GetStockObject(BLACK_BRUSH));
            Ellipse(hdcdib, 10, 10, 30, 30);
            for (c = 80*2; c < 80*6; c++)
                *(pjBitsComp + c) = 2;
            BitBlt(hdcScreen, 600, 150, 80, 80, hdcdib, 0, 0, SRCCOPY);
            TextOut(hdcScreen,600, 260, "black on cyan w blue lines",26);
            SelectObject(hdcdib, hdibSection);
            DeleteObject(hbmComp);
       }

    // GetObject for a DIB section.

        c = GetObject(hdibSection, sizeof(BITMAP), &dib);
        if (c != sizeof(BITMAP))
            DbgPrint("GetObject1 returns %ld, should be sizeof(BITMAP)\n", c);
        if (dib.dsBm.bmBits != pjBits)
            DbgPrint("GetObject1 returns wrong pjBits = %lx\n", dib.dsBm.bmBits);

        c = GetObject(hdibSection, sizeof(DIBSECTION), &dib);
        if (c != sizeof(DIBSECTION))
            DbgPrint("GetObject3 returns %ld, should be sizeof(DIBSECTION)\n", c);
        if (dib.dsBm.bmBits != pjBits)
            DbgPrint("GetObject3 returns wrong pjBits = %lx\n", dib.dsBm.bmBits);
        if (dib.dsBmih.biWidth != 100)
            DbgPrint("GetObject3 returns wrong biWidth = %lx\n", dib.dsBmih.biWidth);
        if (dib.dshSection != 0)
            DbgPrint("GetObject3 returns wrong hSection = %lx\n", dib.dshSection);
        if (dib.dsOffset != 0)
            DbgPrint("GetObject3 returns wrong dwOffset = %lx\n", dib.dsOffset);

        SelectObject(hdcdib, hbmOld);
        DeleteObject(hdibSection);

    // App creates the section handle for CreateDIBSection, dwOffset == 0.

        hApp = CreateFileMapping((HANDLE)INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE|SEC_COMMIT,0,10000,NULL);
        hdibSection = CreateDIBSection(hdcScreen,pbmi,DIB_RGB_COLORS,&pjBits,hApp,0);
        hbmOld = SelectObject(hdcdib, hdibSection);
        SelectObject(hdcdib,hbr);
        Ellipse(hdcdib, 10, 10, 30, 30);
        for (c = 100*2; c < 100*6; c++)
            *(pjBits + c) = 2;
        BitBlt(hdcScreen, 0, 150, 100, 100, hdcdib, 0, 0, SRCCOPY);
        TextOut(hdcScreen,0, 260, "green on red w blue lines",25);

    // GetObject for the DIB section.

        c = GetObject(hdibSection, sizeof(DIBSECTION), &dib);
        if (c != sizeof(DIBSECTION))
            DbgPrint("GetObject4 returns %ld, should be sizeof(DIBSECTION)\n", c);
        if (dib.dsBm.bmBits != pjBits)
            DbgPrint("GetObject4 returns wrong pjBits = %lx\n", dib.dsBm.bmBits);
        if (dib.dsBmih.biWidth != 100)
            DbgPrint("GetObject4 returns wrong biWidth = %lx\n", dib.dsBmih.biWidth);
        if (dib.dshSection != hApp)
            DbgPrint("GetObject4 returns wrong hSection = %lx\n", dib.dshSection);
        if (dib.dsOffset != 0)
            DbgPrint("GetObject4 returns wrong dwOffset = %lx\n", dib.dsOffset);

        SelectObject(hdcdib, hbmOld);
        DeleteObject(hdibSection);

        CloseHandle(hApp);

    // App creates the section handle for CreateDIBSection, dwOffset != 0.

        hApp = CreateFileMapping((HANDLE)INVALID_HANDLE_VALUE,NULL,PAGE_READWRITE|SEC_COMMIT,0,0x13000,NULL);
        hdibSection = CreateDIBSection(hdcScreen,pbmi,DIB_RGB_COLORS,&pjBits,hApp,0x10080);
        hbmOld = SelectObject(hdcdib, hdibSection);
        Ellipse(hdcdib, 10, 10, 30, 30);
        for (c = 100*2; c < 100*6; c++)
            *(pjBits + c) = 2;
        BitBlt(hdcScreen, 200, 150, 100, 100, hdcdib, 0, 0, SRCCOPY);
        TextOut(hdcScreen,200, 260, "green on red w blue lines",25);

    // GetObject for the DIB section.

        c = GetObject(hdibSection, sizeof(DIBSECTION), &dib);
        if (c != sizeof(DIBSECTION))
            DbgPrint("GetObject5 returns %ld, should be sizeof(DIBSECTION)\n", c);
        if (dib.dsBm.bmBits != pjBits)
            DbgPrint("GetObject5 returns wrong pjBits = %lx\n", dib.dsBm.bmBits);
        if (dib.dsBmih.biWidth != 100)
            DbgPrint("GetObject5 returns wrong biWidth = %lx\n", dib.dsBmih.biWidth);
        if (dib.dshSection != hApp)
            DbgPrint("GetObject5 returns wrong hSection = %lx\n", dib.dshSection);
        if (dib.dsOffset != 0x10080)
            DbgPrint("GetObject5 returns wrong dwOffset = %lx\n", dib.dsOffset);

        SelectObject(hdcdib, hbmOld);
        DeleteObject(hdibSection);

        CloseHandle(hApp);

    // DIB bitmap without CREATEDIB flag.  Green circle on black background

        hbm = CreateDIBitmap(hdcScreen,pbmih,0,NULL,pbmi,DIB_RGB_COLORS);
        hbmOld = SelectObject(hdcdib, hbm);
        Ellipse(hdcdib, 10, 10, 30, 30);
        BitBlt(hdcScreen, 400, 150, 100, 100, hdcdib, 0, 0, SRCCOPY);
        TextOut(hdcScreen,400, 260, "green on black",14);

        SelectObject(hdcdib, hbmOld);
        DeleteObject(hbm);

        SelectObject(hdcdib,hbrOld);
        DeleteObject(hbr);
        DeleteDC(hdcdib);

    }
#endif

// Clean up time, delete it all.

    if (SelectPalette(hdcScreen, hpalDefault, 0) != hpalExplicit)
    DbgPrint("hpalExplicit not given back\n");

    if (!DeleteObject(hpalVGA))
    DbgPrint("failed to delete hpalVGA\n");
    if (!DeleteObject(hpalExplicit))
    DbgPrint("failed to delete hpalExplicit\n");

    if (hbm1Cat != SelectObject(hdc1Cat, hbmDefault))
    DbgPrint("Cleanup hbm 2 wrong\n");
    if (hbm1Cat0 != SelectObject(hdc1Cat0, hbmDefault))
    DbgPrint("Cleanup hbm 3 wrong\n");
    if (hbm4Lines != SelectObject(hdc4Lines, hbmDefault))
    DbgPrint("Cleanup hbm 4 wrong\n");
    if (hbm4Lines0 != SelectObject(hdc4Lines0, hbmDefault))
    DbgPrint("Cleanup hbm 5 wrong\n");
    if (hbm8Lines != SelectObject(hdc8Lines, hbmDefault))
    DbgPrint("Cleanup hbm 6 wrong\n");
    if (hbm8Lines0 != SelectObject(hdc8Lines0, hbmDefault))
    DbgPrint("Cleanup hbm 7 wrong\n");
    if (hbm1BigCat != SelectObject(hdc1BigCat, hbmDefault))
    DbgPrint("Cleanup hbm 8 wrong\n");
    if (hbm1BigCat0 != SelectObject(hdc1BigCat0, hbmDefault))
    DbgPrint("Cleanup hbm 9 wrong\n");

// Delete DC's

    if (!DeleteDC(hdc1BigCat))
    DbgPrint("Failed to delete hdc 1\n");
    if (!DeleteDC(hdc1BigCat0))
    DbgPrint("Failed to delete hdc 2\n");
    if (!DeleteDC(hdc1Cat))
    DbgPrint("Failed to delete hdc 3\n");
    if (!DeleteDC(hdc1Cat0))
    DbgPrint("Failed to delete hdc 4\n");
    if (!DeleteDC(hdc4Lines))
    DbgPrint("Failed to delete hdc 5\n");
    if (!DeleteDC(hdc4Lines0))
    DbgPrint("Failed to delete hdc 6\n");
    if (!DeleteDC(hdc8Lines))
    DbgPrint("Failed to delete hdc 7\n");
    if (!DeleteDC(hdc8Lines0))
    DbgPrint("Failed to delete hdc 8\n");

// Delete Bitmaps

    if (!DeleteObject(hbm1Cat))
    DbgPrint("ERROR failed to delete 1\n");
    if (!DeleteObject(hbm1Cat0))
    DbgPrint("ERROR failed to delete 2\n");
    if (!DeleteObject(hbm4Lines))
    DbgPrint("ERROR failed to delete 3\n");
    if (!DeleteObject(hbm4Lines0))
    DbgPrint("ERROR failed to delete 4\n");
    if (!DeleteObject(hbm8Lines))
    DbgPrint("ERROR failed to delete 5\n");
    if (!DeleteObject(hbm8Lines0))
    DbgPrint("ERROR failed to delete 6\n");
    if (!DeleteObject(hbm1BigCat))
    DbgPrint("ERROR failed to delete 7\n");
    if (!DeleteObject(hbm1BigCat0))
    DbgPrint("ERROR failed to delete 8\n");
    if (!DeleteObject(hbmDefault))
    DbgPrint("ERROR deleted default bitmap\n");
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftchar.c ===
/******************************Module*Header*******************************\
* Module Name: ftchar.c
*
* Test all the characters in a font at all sizes to see if any of them
* fault the system.  This is meant to be a very long extensive test to
* validate a font in NT.  Please add more tests if you like.
*
* Created: 22-Mar-1994 13:21:30
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// tt stuff

#include "tt.h"

#define SIZEOF_CMAPTABLE  (3 * sizeof(uint16))

#define OFF_segCountX2  6
#define OFF_endCount    14



#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) if(!(x)) RIP(y)



/******************************Public*Routine******************************\
* BYTE * pjMapTable(FILEVIEW  *pfvw)
*
* History:
*  25-Mar-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BYTE * pjMapTable(sfnt_char2IndexDirectory * pcmap, BOOL *pbSymbol)
{
    BYTE *pjMap = NULL;
    sfnt_platformEntry * pplat, * pplatEnd;

    if (pcmap->version != 0) // no need to swap bytes, 0 == be 0
    {
        DbgPrint("ft! CMAP version number\n");
        return NULL;
    }

// find the first sfnt_platformEntry with platformID == PLAT_ID_MS,
// if there was no MS mapping table, we are out of here.

    pplat = &pcmap->platform[0];
    pplatEnd = pplat + SWAPW(pcmap->numTables);

    for ( ; pplat < pplatEnd; pplat++)
    {
        if ((pplat->platformID == 0x300) && (pplat->specificID == 0x100))
        {
            pjMap = (BYTE *)pcmap + SWAPL(pplat->offset);
            *pbSymbol = FALSE;
            break;
        }
    }

    if (!pjMap)
    {
    // reinit and try as symbol font:

        pplat = &pcmap->platform[0];
        pplatEnd = pplat + SWAPW(pcmap->numTables);

        for ( ; pplat < pplatEnd; pplat++)
        {
            if ((pplat->platformID == 0x300) && (pplat->specificID == 0x0000))
            {
                pjMap = (BYTE *)pcmap + SWAPL(pplat->offset);
                *pbSymbol = TRUE;
                break;
            }
        }
    }

    return pjMap;
}



void vTestChar(HWND hwnd)
{
    CHOOSEFONT cf;      /* common dialog box structure */
    LOGFONT lf;         /* logical-font structure */
    HDC hdc;            /* display DC handle */
    HFONT hfont;        /* new logical-font handle */
    HFONT hfontOld;     /* original logical-font handle */
    COLORREF crOld;     /* original text color */

    UINT ulSize, ulSizeMax;
    TEXTMETRICW tmw;
    DWORD cjCMAP,cjCMAP1;
    DWORD dwCMAP = 0;
    BYTE *pjCMAP, *pjMap;


    WCHAR wcFirst, wcLast;

    uint16 * pstartCount, *ps, *pe, *peEnd;
    uint16 * pendCount;
    uint16 * pendCountEnd;
    uint16   cRuns, cRunsDbg;
    ULONG    cGlyphs;
    BOOL     bSymbol;
    WCHAR    wcBias;

    memcpy((char *)&dwCMAP, "cmap", 4);

    cf.lStructSize = sizeof (CHOOSEFONT);
    cf.hwndOwner = hwnd;
    cf.lpLogFont = &lf;

    cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_FORCEFONTEXIST;
    cf.rgbColors = RGB(255, 0, 0);
    cf.nFontType = SCREEN_FONTTYPE;

    /*
     * Display the dialog box, allow the user to
     * choose a font, and render the text in the
     * window with that selection.
     */

    if (!ChooseFont(&cf))
    {
        DbgPrint("Font selection failed\n");
        return;
    }

    hdc = GetDC(hwnd);
    GdiSetBatchLimit(1);
    crOld = SetTextColor(hdc, cf.rgbColors);


//!!!!!!!!!!!!!!!!!!
// Hack, the way to specify the size

    ulSizeMax = labs(lf.lfHeight);


    hfont = CreateFontIndirect(&lf);
    hfontOld = SelectObject(hdc, hfont);

    GetTextMetricsW(hdc,&tmw);

    cjCMAP = GetFontData(hdc, dwCMAP,0,NULL,0);
    if (cjCMAP == -1)
    {
        DbgPrint("ft:GetFontData, get size failed\n");
        return;
    }

    if (!(pjCMAP = malloc(cjCMAP)))
    {
        DbgPrint("ft:malloc\n");
        return;
    }

    cjCMAP1 = GetFontData(hdc, dwCMAP,0,pjCMAP,cjCMAP);
    if ((cjCMAP1 == -1) || (cjCMAP != cjCMAP1))
    {
        DbgPrint("ft:GetFontData, get cmap table  failed\n");
        free(pjCMAP);
        return;
    }

// see if the unicode cmap table exists :

    pjMap = pjMapTable((sfnt_char2IndexDirectory *)pjCMAP, &bSymbol);
    if (!pjMap)
    {
        DbgPrint("ft: no Unicode cmap table  failed\n");
        free(pjCMAP);
        return;
    }

    wcBias = (WCHAR)(bSymbol ? 0xf000 : 0);

    SelectObject(hdc, hfontOld);
    DeleteObject(hfont);

    cRuns = BE_UINT16(pjMap + OFF_segCountX2) >> 1;

// get the pointer to the beginning of the array of endCount code points

    pendCount = (uint16 *)(pjMap + OFF_endCount);

// the final endCode has to be 0xffff;
// if this is not the case, there is a bug in the tt file or in our code:

    ASSERTGDI(pendCount[cRuns - 1] == 0xFFFF,
              "TTFD! pendCount[cRuns - 1] != 0xFFFF\n");

// Get the pointer to the beginning of the array of startCount code points
// For resons known only to tt designers, startCount array does not
// begin immediately after the end of endCount array, i.e. at
// &pendCount[cRuns]. Instead, they insert an uint16 padding which has to
// set to zero and the startCount array begins after the padding. This
// padding in no way helps alignment of the structure

//    ASSERTGDI(pendCount[cRuns] == 0, "TTFD!_padding != 0\n");

    pstartCount = &pendCount[cRuns + 1];

// here we shall check if the last run is just a terminator for the
// array of runs or a real nontrivial run. If just a terminator, there is no
// need to report it. This will save some memory in the cache plus
// pifi->wcLast will represent the last glyph that is truly supported in
// font:

    if ((pstartCount[cRuns-1] == 0xffff) && (cRuns > 1))
        cRuns -= 1; // do not report trivial run


    pendCountEnd = &pendCount[cRuns];

// print cmap table summary

// reset these for every size

    DbgPrint("\n\n cmap table summary: cRuns = %ld\n\n", cRuns);

    ps    = pstartCount;
    pe    = pendCount;
    peEnd = pendCountEnd;
    cGlyphs = 0;
    cRunsDbg = 0;

    for ( ; pe < peEnd; ps++, pe++, cRunsDbg++) // loop over ranges
    {
        ULONG cGlyphsInRun;
        wcFirst = SWAPW(*ps);
        wcLast  = SWAPW(*pe);

        DbgPrint("Run %ld: wcFirst = %d, wcLast = %d \n",cRunsDbg,wcFirst,wcLast);

        cGlyphsInRun = (ULONG)(wcLast - wcFirst + 1);
        cGlyphs += cGlyphsInRun;

    }

    DbgPrint("Glyphs in font: %ld\n", cGlyphs);

// loop through the sizes:

    for (ulSize = 1; ulSize < ulSizeMax; ulSize++)
    {
        lf.lfHeight = -(LONG)ulSize;
        hfont = CreateFontIndirect(&lf);
        hfontOld = SelectObject(hdc, hfont);

        // DbgPrint("Doing size %ld pixels per Em\n", ulSize);

    // reset these for every size

        ps    = pstartCount;
        pe    = pendCount;
        peEnd = pendCountEnd;
        cGlyphs = 0;
        cRunsDbg = 0;

        for ( ; pe < peEnd; ps++, pe++, cRunsDbg++) // loop over ranges
        {
            ULONG cGlyphsInRun;
            WCHAR wc;
            wcFirst = SWAPW(*ps);
            wcLast  = SWAPW(*pe);

            cGlyphsInRun = (ULONG)(wcLast - wcFirst + 1);
            cGlyphs += cGlyphsInRun;

            for ( ; wcFirst <= wcLast; wcFirst++)
            {
                wc = wcFirst - wcBias;
                if (!TextOutW(hdc,0,0,&wc,1))
                {
                    DbgPrint("ft: Bad glyph 0x%d, size = %ld ppem\n",wcFirst,ulSize);
                }
            }
        }

        SelectObject(hdc, hfontOld);
        DeleteObject(hfont);
    }

    ReleaseDC(hwnd, hdc);
    free(pjCMAP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftbrush.c ===
/******************************Module*Header*******************************\
* Module Name: ftbrush.c
*
* Brush Tests
*
* Created: 26-May-1991 13:07:35
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID vStressBrushes(HDC hdc);
VOID vStressBrushes1(HDC hdc);
VOID vStressBrushes2(HDC hdc);
VOID vStressBrushes3(HDC hdc);
VOID vStressBrushes4(HDC hdc);
VOID vStressBrushes5(HDC hdc);
VOID vStressBrushes6(HDC hdc);
VOID vStressBrushes7(HDC hdc);
VOID vTestPatCopyROPs(HDC hdc);
void vBrushRealDIB(HDC hdc);

/******************************Public*Routine******************************\
* vTestBrush
*
* Does a fairly thourough test of brush fuctionality.
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestBrush(HWND hwnd, HDC hdc, RECT* prcl)
{
// First let's stress it a little bit.

    hwnd = hwnd;

    PatBlt(hdc, 0, 0, prcl->right, prcl->bottom, WHITENESS);

// Do the 100 creation/selection/deletion stress test.

    vStressBrushes(hdc);

// Do the 10000 SelectObject, PatBlt

    vStressBrushes1(hdc);

// Do the 10000 PatBlt test.

    vStressBrushes2(hdc);

// Test CreateDIBPatternBrush

    vStressBrushes3(hdc);

// Test SetBkMode and SetBkColor and hatch brushes

    vStressBrushes4(hdc);
    vStressBrushes5(hdc);
    vStressBrushes6(hdc);
    vStressBrushes7(hdc);

// Test all 16 PatCopy ROPs on black/white patterns:

    vTestPatCopyROPs(hdc);

// Test Real DIB brushes

    vBrushRealDIB(hdc);
}

/******************************Public*Routine******************************\
* vStressBrushes
*
* Do a ton of creation selection and deletion.
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vStressBrushes(HDC hdc)
{
    HBRUSH hbrDefault, hbrR, hbrG, hbrB, hbrTemp;
    ULONG ulCount;

// Stress Test time

    ulCount = 100;

    while (ulCount--)
    {
	hbrR = CreateSolidBrush(RGB(0xFF, 0   ,0   ));
	hbrG = CreateSolidBrush(RGB(0	, 0xFF,0   ));
	hbrB = CreateSolidBrush(RGB(0	, 0   ,0xFF));

	if ((hbrR == (HBRUSH) 0) ||
	    (hbrG == (HBRUSH) 0) ||
	    (hbrB == (HBRUSH) 0))
	{
	    DbgPrint("ERROR hbrR %lu hbrG %lu hbrB %lu\n", hbrR, hbrG, hbrB);
	    return;
	}

	hbrDefault = SelectObject(hdc, hbrR);

	hbrTemp = SelectObject(hdc, hbrG);

	if (hbrR != hbrTemp)
	    DbgPrint("Error vStressBrushes1");

	hbrTemp = SelectObject(hdc, hbrB);

	if (hbrG != hbrTemp)
	    DbgPrint("Error vStressBrushes2");

	hbrTemp = SelectObject(hdc, hbrDefault);

	if (hbrB != hbrTemp)
	    DbgPrint("Error vStressBrushes3");

	if ((!DeleteObject(hbrR)) ||
	    (!DeleteObject(hbrG)) ||
	    (!DeleteObject(hbrB)))
	{
	    DbgPrint("ERROR vStressBrushes delete object failed");
	}
    }
}

/******************************Public*Routine******************************\
* vStressBrushes1
*
* Do a ton of selection and output.
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vStressBrushes1(HDC hdc)
{
    HBRUSH hbrDefault, hbrR, hbrG, hbrB, hbrTemp;
    ULONG ulCount;

    hbrR = CreateSolidBrush(RGB(0xFF, 0   ,0   ));
    hbrG = CreateSolidBrush(RGB(0   , 0xFF,0   ));
    hbrB = CreateSolidBrush(RGB(0   , 0   ,0xFF));

    if ((hbrR == (HBRUSH) 0) ||
	(hbrG == (HBRUSH) 0) ||
	(hbrB == (HBRUSH) 0))
    {
	DbgPrint("ERROR hbrR %lu hbrG %lu hbrB %lu\n", hbrR, hbrG, hbrB);
	return;
    }

// Stress Test time

    ulCount = 100;

    while (ulCount--)
    {
	hbrDefault = SelectObject(hdc, hbrR);

	PatBlt(hdc, 10, 10, 20, 20, PATCOPY);

	hbrTemp = SelectObject(hdc, hbrG);

	if (hbrR != hbrTemp)
	    DbgPrint("Error vStressBrushes1");

	PatBlt(hdc, 10, 10, 20, 20, PATCOPY);

	hbrTemp = SelectObject(hdc, hbrB);

	if (hbrG != hbrTemp)
	    DbgPrint("Error vStressBrushes2");

	PatBlt(hdc, 10, 10, 20, 20, PATCOPY);

	hbrTemp = SelectObject(hdc, hbrDefault);

	if (hbrB != hbrTemp)
	    DbgPrint("Error vStressBrushes3");
    }

    if ((!DeleteObject(hbrR)) ||
	(!DeleteObject(hbrG)) ||
	(!DeleteObject(hbrB)))
    {
	DbgPrint("ERROR vStressBrushes delete object failed");
    }
}

/******************************Public*Routine******************************\
* vStressBrushes2
*
* Do a ton of selection and output.
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vStressBrushes2(HDC hdc)
{
    HBRUSH hbrDefault, hbrR, hbrG, hbrB, hbrTemp;
    ULONG ulCount;

    hbrR = CreateSolidBrush(RGB(0xFF, 0   ,0   ));
    hbrG = CreateSolidBrush(RGB(0   , 0xFF,0   ));
    hbrB = CreateSolidBrush(RGB(0   , 0   ,0xFF));

    if ((hbrR == (HBRUSH) 0) ||
	(hbrG == (HBRUSH) 0) ||
	(hbrB == (HBRUSH) 0))
    {
	DbgPrint("ERROR hbrR %lu hbrG %lu hbrB %lu\n", hbrR, hbrG, hbrB);
	return;
    }

// Stress Test time

    ulCount = 100;
    hbrDefault = SelectObject(hdc, hbrR);

    while (ulCount--)
    {
	PatBlt(hdc, 10, 10, 20, 20, PATCOPY);
	PatBlt(hdc, 10, 10, 20, 20, PATCOPY);
	PatBlt(hdc, 10, 10, 20, 20, PATCOPY);
    }

    hbrTemp = SelectObject(hdc, hbrDefault);

    if (hbrR != hbrTemp)
	DbgPrint("Error vStressBrushes3");

    if ((!DeleteObject(hbrR)) ||
	(!DeleteObject(hbrG)) ||
	(!DeleteObject(hbrB)))
    {
	DbgPrint("ERROR vStressBrushes delete object failed");
    }
}

/******************************Public*Routine******************************\
* vStressBrushes3
*
* Test CreateDIBPatternBrush, see if it works.
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD			     bmiColors[16];
    DWORD			     dw[8];
} BITMAPINFOPAT;

BITMAPINFOPAT bmi400 =
{
    {
	sizeof(BITMAPINFOHEADER),
	8,
	8,
	1,
	4,
	BI_RGB,
	32,
	0,
	0,
	16,
	16
    },

    {				    // B    G	 R
	{ 0,   0,   0,	 0 },	    // 0
	{ 0,   0,   0x80,0 },	    // 1
	{ 0,   0x80,0,	 0 },	    // 2
	{ 0,   0x80,0x80,0 },	    // 3
	{ 0x80,0,   0,	 0 },	    // 4
	{ 0x80,0,   0x80,0 },	    // 5
	{ 0x80,0x80,0,	 0 },	    // 6
	{ 0x80,0x80,0x80,0 },	    // 7
	{ 0xC0,0xC0,0xC0,0 },	    // 8
	{ 0,   0,   0xFF,0 },	    // 9
	{ 0,   0xFF,0,	 0 },	    // 10
	{ 0,   0xFF,0xFF,0 },	    // 11
	{ 0xFF,0,   0,	 0 },	    // 12
	{ 0xFF,0,   0xFF,0 },	    // 13
	{ 0xFF,0xFF,0,	 0 },	    // 14
	{ 0xFF,0xFF,0xFF,0 }	    // 15
    },

    {
	0xAAAAAAAA,
	0xAAAAAAAA,
	0xAACCCCCC,
	0xAACCCCCC,
	0xAACCCCCC,
	0xCCCCCCCC,
	0xCCCCCCCC,
	0xAAAAAAAA
    }
};

VOID vStressBrushes3(HDC hdc)
{
    HBRUSH hbrDefault, hbrR;
    HDC hdc4;
    HBITMAP hbm4;

    PatBlt(hdc, 0, 0, 200, 300, WHITENESS);
    hbrR = CreateDIBPatternBrushPt(&bmi400, DIB_RGB_COLORS);

    if (hbrR == (HBRUSH) 0)
    {
	DbgPrint("vStressBrushes2 failed to CreateDIBPatternBrush\n");
	return;
    }

    hdc4 = CreateCompatibleDC(hdc);
    hbm4 = CreateBitmap(100, 100, 1, 4, (LPBYTE) NULL);
    SelectObject(hdc4, hbm4);

    hbrDefault = SelectObject(hdc4, hbrR);
    SelectObject(hdc, hbrR);

    PatBlt(hdc, 0, 0, 100, 100, PATCOPY);
    PatBlt(hdc4, 0, 0, 100, 100, PATCOPY);
    BitBlt(hdc, 100, 0, 100, 100, hdc4, 0, 0, SRCCOPY);

    SelectObject(hdc, hbrDefault);
    SelectObject(hdc4, hbrDefault);

    DeleteDC(hdc4);
    DeleteObject(hbrR);
    DeleteObject(hbm4);
}

/******************************Public*Routine******************************\
* vStressBrushes4
*
* Test SetBkMode to screen and to a bitmap.
*
* History:
*  Sat 07-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vStressBrushes4(HDC hdc)
{
    HBRUSH hbrDefault, hbrHatch;
    HDC hdc8;
    HBITMAP hbm8;

    hbrHatch = CreateHatchBrush(HS_BDIAGONAL, RGB(0xFF, 0, 0));

    if (hbrHatch == (HBRUSH) 0)
    {
	DbgPrint("vStressBrushes2 failed to CreateDIBPatternBrush\n");
	return;
    }

    hdc8 = CreateCompatibleDC(hdc);
    hbm8 = CreateBitmap(100, 100, 1, 8, (LPBYTE) NULL);
    SelectObject(hdc8, hbm8);
    SelectObject(hdc8, GetStockObject(NULL_PEN));

    hbrDefault = SelectObject(hdc8, hbrHatch);
    SelectObject(hdc, hbrHatch);

    SetBkColor(hdc, RGB(0, 0xFF, 0));
    SetBkColor(hdc8, RGB(0, 0xFF, 0));

    SetBkMode(hdc, TRANSPARENT);
    SetBkMode(hdc8, TRANSPARENT);
    PatBlt(hdc, 0, 100, 100, 100, BLACKNESS);
    PatBlt(hdc8, 0, 0, 100, 100, BLACKNESS);
    Rectangle(hdc8, 0, 0, 100, 100);
    Rectangle(hdc, 0, 100, 100, 200);
    Rectangle(hdc8, 21, 1, 31,	41);
    Rectangle(hdc8, 23, 15, 43, 41);
    Rectangle(hdc8, 25, 29, 51, 53);
    Rectangle(hdc8, 27, 46, 45, 48);
    BitBlt(hdc, 100, 100, 100, 100, hdc8, 0, 0, SRCCOPY);

    SetBkMode(hdc, OPAQUE);
    SetBkMode(hdc8, OPAQUE);
    PatBlt(hdc, 0, 200, 100, 100, BLACKNESS);
    PatBlt(hdc8, 0, 0, 100, 100, BLACKNESS);
    Rectangle(hdc8, 0, 0, 100, 100);
    Rectangle(hdc8, 21, 1, 31,	41);
    Rectangle(hdc8, 23, 15, 43, 41);
    Rectangle(hdc8, 25, 29, 51, 53);
    Rectangle(hdc8, 27, 46, 45, 48);
    Rectangle(hdc, 0, 200, 100, 300);
    BitBlt(hdc, 100, 200, 100, 100, hdc8, 0, 0, SRCCOPY);

    SetBkColor(hdc, RGB(0xFF, 0xFF, 0xFF));
    SelectObject(hdc, hbrDefault);
    SelectObject(hdc8, hbrDefault);

    DeleteDC(hdc8);
    DeleteObject(hbrHatch);
    DeleteObject(hbm8);
}

/******************************Public*Routine******************************\
* vStressBrushes5
*
* Test SetBkMode to screen and to a bitmap.
*
* History:
*  Sat 07-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vStressBrushes5(HDC hdc)
{
    // HBITMAP hbm4;
    HBRUSH hbrRed, hbrOld;
    // HDC hdc4;

    HDC hdc8;
    HBITMAP hbm8;

    SetROP2(hdc, R2_COPYPEN);
    hdc8 = CreateCompatibleDC(hdc);
    hbm8 = CreateBitmap(100, 100, 1, 4, (LPBYTE) NULL);
    SelectObject(hdc8, hbm8);
    SetBkMode(hdc, TRANSPARENT);
    SetBkMode(hdc8, TRANSPARENT);

    hbrRed = CreateSolidBrush(RGB(0x88, 0, 0));
    hbrOld = SelectObject(hdc, hbrRed);
    SelectObject(hdc8,hbrRed);
    Rectangle(hdc8, 0, 0, 100, 100);
    PatBlt(hdc8, 50, 0, 100, 100,PATCOPY);
    Rectangle(hdc, 200, 0, 300, 100);
    SelectObject(hdc, hbrOld);
    SelectObject(hdc8, hbrOld);
    DeleteObject(hbrRed);

    BitBlt(hdc, 200, 100, 100, 100, hdc8, 0, 0, SRCCOPY);

    hbrRed = CreateSolidBrush(RGB(0x80, 0, 0));
    hbrOld = SelectObject(hdc, hbrRed);
    SelectObject(hdc8, hbrRed);
    Rectangle(hdc8, 0, 0, 100, 100);
    PatBlt(hdc8, 50, 0, 100, 100,PATCOPY);
    Rectangle(hdc, 300, 0, 400, 100);
    SelectObject(hdc, hbrOld);
    SelectObject(hdc8, hbrOld);
    DeleteObject(hbrRed);

    BitBlt(hdc, 300, 100, 100, 100, hdc8, 0, 0, SRCCOPY);

    DeleteDC(hdc8);
    DeleteObject(hbm8);
    SetBkMode(hdc, OPAQUE);

#if 0
    hdc4 = CreateCompatibleDC(hdc);
    hbm4 = CreateCompatibleBitmap(hdc,
#endif
}

/******************************Public*Routine******************************\
* vStressBrushes6
*
* Test imagedit dither bug
*
* History:
*  Sat 07-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vStressBrushes6(HDC hdc)
{
    HBRUSH hbrDefault, hbr;
    HDC hdc8;
    HBITMAP hbm8;

    hbr= CreateSolidBrush(RGB(210, 192, 192));

    if (hbr == (HBRUSH) 0)
    {
	DbgPrint("vStressBrushes4 failed to CreateDIBPatternBrush\n");
	return;
    }

    hdc8 = CreateCompatibleDC(hdc);
    hbm8 = CreateCompatibleBitmap(hdc,100, 100);
    SelectObject(hdc8, hbm8);

    hbrDefault = SelectObject(hdc8, hbr);
    SelectObject(hdc, hbr);

    SetBkMode(hdc, OPAQUE);
    SetBkMode(hdc8, OPAQUE);

    PatBlt(hdc, 400, 0, 100, 100,PATCOPY);
    PatBlt(hdc8, 0, 0, 100, 100,PATCOPY);
    BitBlt(hdc, 500, 0, 100, 100, hdc8, 0, 0, SRCCOPY);

    SetBkMode(hdc, TRANSPARENT);
    SetBkMode(hdc8, TRANSPARENT);

    Rectangle(hdc, 400, 100, 500, 200);
    Rectangle(hdc8, 0, 0, 100, 100);
    BitBlt(hdc, 500, 100, 100, 100, hdc8, 0, 0, SRCCOPY);

    SelectObject(hdc, hbrDefault);
    SelectObject(hdc8, hbrDefault);

    DeleteDC(hdc8);
    DeleteObject(hbr);
    DeleteObject(hbm8);
}

/******************************Public*Routine******************************\
* vStressBrushes7
*
* Test CreateDIBPatternBrush, see if it works for DIB_PAL_COLORS.
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFOPATI
{
    BITMAPINFOHEADER                 bmiHeader;
    SHORT			     bmiColors[16];
    DWORD			     dw[8];
} BITMAPINFOPATI;

BITMAPINFOPATI bmi500 =
{
    {
	sizeof(BITMAPINFOHEADER),
	8,
	8,
	1,
	4,
	BI_RGB,
	32,
	0,
	0,
	16,
	16
    },

    { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 },
#if 1
    {
	0xAAAAAAAA,
	0xAAAAAAAA,
	0xAACCCCCC,
	0xAACCCCCC,
	0xAACCCCCC,
	0xCCCCCCCC,
	0xCCCCCCCC,
	0xAAAAAAAA
    }
#else
    {
	0x11111111,
	0x11111111,
	0x11222222,
	0x11222222,
	0x11222222,
	0x22222222,
	0x22222222,
	0x11111111
    }
#endif
};

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;

extern VGALOGPALETTE logPalVGA;

VOID vStressBrushes7(HDC hdc)
{
    HBRUSH hbrDefault, hbrR;
    HDC hdc4;
    HBITMAP hbm4;
    HPALETTE hpal,hpalTemp;

    hbrR = CreateDIBPatternBrushPt(&bmi500, DIB_PAL_COLORS);

    if (hbrR == (HBRUSH) 0)
    {
	DbgPrint("vStressBrushes2 failed to CreateDIBPatternBrush\n");
	return;
    }

    hdc4 = CreateCompatibleDC(hdc);
    hbm4 = CreateBitmap(100, 100, 1, 8, (LPBYTE) NULL);
    SelectObject(hdc4, hbm4);
    hpal = CreatePalette((LOGPALETTE *) &logPalVGA);
    hpalTemp = SelectPalette(hdc4, hpal,0);
    SelectPalette(hdc, hpal,0);

    hbrDefault = SelectObject(hdc4, hbrR);
    SelectObject(hdc, hbrR);

    PatBlt(hdc, 200, 200, 100, 100, PATCOPY);
    PatBlt(hdc4, 0, 0, 100, 100, PATCOPY);
    BitBlt(hdc, 300, 200, 100, 100, hdc4, 0, 0, SRCCOPY);

    SelectObject(hdc, hbrDefault);
    SelectObject(hdc4, hbrDefault);
    SelectPalette(hdc4, hpalTemp, 0);
    SelectPalette(hdc, hpalTemp, 0);

    DeleteDC(hdc4);
    DeleteObject(hbrR);
    DeleteObject(hbm4);
    DeleteObject(hpal);
}

VOID vTestPatCopyROPs(HDC hdc)
{
    #define YSTART      400     // y start position
    #define DIM         50      // dimension of each box
    #define BIGDIM      70      //
    #define BIGOFFSET   10      //

// This test displays a black/white pattern on black and white strips,
// excercising all the possible Rop2/mix modes possible.
//
// They are shown on the screen in the following ROP2 order:
//
//      1  2  3  4
//      5  6  7  8
//      9 10 11 12
//     13 14 15 16
//
// (So, for example, the top left pattern is done with Rop2 1 = R2_BLACKNESS.)

    static DWORD adwRop3[] = { 0x000000, 0x050000, 0x0a0000, 0x0f0000,
                               0x500000, 0x550000, 0x5a0000, 0x5f0000,
                               0xa00000, 0xa50000, 0xaa0000, 0xaf0000,
                               0xf00000, 0xf50000, 0xfa0000, 0xff0000 };
    LONG   i;
    LONG   j;
    HBRUSH hbrush;
    HBRUSH hbrushOld;

// Run black strips down each side:

    for (i = 0; i < 4; i++)
    {
        PatBlt(hdc, i*BIGDIM, YSTART, BIGDIM/2, BIGDIM*4, BLACKNESS);
    }

    hbrush = CreateHatchBrush(HS_DIAGCROSS, RGB(0, 0, 0));

    hbrushOld = SelectObject(hdc, hbrush);

// Run through each mix mode:

    for (j = 0; j < 4; j++)
    {
        for (i = 0; i < 4; i++)
        {
            PatBlt(hdc, i*BIGDIM + BIGOFFSET, YSTART + j*BIGDIM + BIGOFFSET,
                        DIM, DIM, adwRop3[j*4+i]);
        }
    }

    SelectObject(hdc, hbrushOld);

    DeleteObject(hbrush);
}

HBITMAP hbmCreateDIBitmap(HDC hdc, ULONG x, ULONG y, ULONG nBitsPixel);

typedef struct _LOGPALETTE256
{
    USHORT palVersion;
    USHORT palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

HPALETTE CreateGreyPalette(void)
{
    LOGPALETTE256 logpal256;
    ULONG ulTemp;

    logpal256.palVersion = 0x300;
    logpal256.palNumEntries = 256;

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
        logpal256.palPalEntry[ulTemp].peRed   = (BYTE)ulTemp;
        logpal256.palPalEntry[ulTemp].peGreen = (BYTE)ulTemp;
        logpal256.palPalEntry[ulTemp].peBlue  = (BYTE)ulTemp;
        logpal256.palPalEntry[ulTemp].peFlags = 0;
    }

    return(CreatePalette((LOGPALETTE *) &logpal256));
}

/******************************Public*Routine******************************\
* vBrushRealDIB
*
* This is to repo a bug that Chriswil finds painting with real-DIB's
*
* History:
*  24-May-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void vBrushRealDIB(HDC hdc)
{
    HPALETTE hpalGrey, hpalOld;
    HBITMAP hbm;
    HDC hdcMem;

    hdcMem = CreateCompatibleDC(hdc);
    hbm = hbmCreateDIBitmap(hdc, 100, 100, 8);
    SelectObject(hdcMem,hbm);

    hpalGrey = CreateGreyPalette();

    if (hpalGrey == 0)
        DbgPrint("Failed hpalette creation\n");

    hpalOld = SelectPalette(hdc, hpalGrey, 0);
    RealizePalette(hdc);

    PatBlt(hdcMem, 0, 0, 100, 100, WHITENESS);
    TextOut(hdcMem, 0, 0, "Hello", 5);

    BitBlt(hdc, 0, 0, 100, 100, hdcMem, 0, 0, SRCCOPY);

    SelectPalette(hdc, hpalOld, 0);
    DeleteDC(hdcMem);
    DeleteObject(hbm);
    DeleteObject(hpalGrey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftfill.c ===
/******************************Module*Header*******************************\
* Module Name: ftfill.c
*
* Filling tests
*
* Created: 26-May-1991 13:07:35
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFOPAT;

BITMAPINFOPAT bmi4 =
{
    {
        sizeof(BITMAPINFOHEADER),
        64,
        64,
        1,
	4,
        BI_RGB,
	(64 * 64) / 2,
        0,
        0,
        16,
        16
    },
    {                               // B    G    R
        { 0,   0,   0,   0 },       // 0
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
        { 0xC0,0xC0,0xC0,0 },       // 7

        { 0x80,0x80,0x80,0 },       // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

BYTE abColorLinesFill[64 * 64 / 2] =
{
// 0
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
// 8
     0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
// 16
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
// 24
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
// 32
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
// 40
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
// 48
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xAA,0xAA,0xAA,0xAA,

// 56
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,

     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
     0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,
// 64
};


VOID vTestFilling(HWND hwnd, HDC hdc, RECT* prcl)
{
    HBRUSH hbrushRed, hbrushCyan, hbrushYellow, hbrushPink, hbrushOld;
    HBRUSH hbrSave;
    HDC hdcComp;
    HBITMAP hbm,hbmDefault;
    ULONG ScreenWidth, ScreenHeight;
    POINT ptl[20];
    int   aint[10];

// Create the brush

    ScreenWidth  = GetDeviceCaps(hdc, HORZRES);
    ScreenHeight = GetDeviceCaps(hdc, VERTRES);

    BitBlt(hdc, 0, 0, ScreenWidth, ScreenHeight, (HDC) 0, 0, 0, WHITENESS);

    hbrushRed = CreateSolidBrush(RGB(0xff,0x00,0x00));
    hbrushCyan = CreateSolidBrush(RGB(0x00,0xff,0xff));
    hbrushYellow = CreateSolidBrush(RGB(0xff,0xff,0x00));
    hbrushPink = CreateSolidBrush(RGB(0xff,0x00,0xff));

    hbm = CreateDIBitmap(hdc,
                        (LPBITMAPINFOHEADER)&bmi4,
			CBM_INIT,
			abColorLinesFill,
                        (LPBITMAPINFO)&bmi4,
                        DIB_RGB_COLORS);

    hdcComp = CreateCompatibleDC(hdc);
    hbmDefault = SelectObject(hdcComp, hbm);

    BitBlt(hdc, 100, 100, 64, 64, hdcComp, 0, 0, SRCCOPY);

// Red: 0xFF, Blue 0xFF0000

    hbrushOld = SelectObject(hdcComp,hbrushRed);
    FloodFill(hdcComp, 23, 46, 0x0FF0000);
    BitBlt(hdc, 200, 100, 64, 64, hdcComp, 0, 0, SRCCOPY);

    SelectObject(hdcComp,hbrushYellow);
    ExtFloodFill(hdcComp, 23, 46, 0x0FF, FLOODFILLSURFACE);
    BitBlt(hdc, 300, 100, 64, 64, hdcComp, 0, 0, SRCCOPY);

    SelectObject(hdcComp,hbrushCyan);
    ExtFloodFill(hdcComp, 23, 46, 0x0FF0000, FLOODFILLBORDER);
    BitBlt(hdc, 400, 100, 64, 64, hdcComp, 0, 0, SRCCOPY);

    hbrSave = SelectObject(hdc,hbrushPink);

    ptl[0].x = 100;
    ptl[0].y = 200;
    ptl[1].x = 100+70;
    ptl[1].y = 200;
    ptl[2].x = 100;
    ptl[2].y = 200+70;
    ptl[3].x = 100+80;
    ptl[3].y = 200+80;
    ptl[4].x = 100;
    ptl[4].y = 200;

    ptl[5].x = 130;
    ptl[5].y = 210;
    ptl[6].x = 130+20;
    ptl[6].y = 210;
    ptl[7].x = 130-10;
    ptl[7].y = 210+50;
    ptl[8].x = 130+10;
    ptl[8].y = 210+50;
    ptl[9].x = 130;
    ptl[9].y = 210;

    aint[0] = 5;
    aint[1] = 5;

    PolyPolygon(hdc, (LPPOINT)&ptl, (LPINT)&aint, 2);

    Ellipse(hdc, 200, 200, 300, 250);

    ptl[0].x = 400;
    ptl[0].y = 200;
    ptl[1].x = 400-40;
    ptl[1].y = 200+40;
    ptl[2].x = 400+40;
    ptl[2].y = 200+35;
    ptl[3].x = 400-30;
    ptl[3].y = 200+5;
    ptl[4].x = 400-5;
    ptl[4].y = 200+80;

    Polygon(hdc, (LPPOINT)&ptl, 5);

    ptl[0].x = 500;
    ptl[0].y = 200;
    ptl[1].x = 500-40;
    ptl[1].y = 200+40;
    ptl[2].x = 500+40;
    ptl[2].y = 200+35;
    ptl[3].x = 500-30;
    ptl[3].y = 200+5;
    ptl[4].x = 500-5;
    ptl[4].y = 200+80;

    SetPolyFillMode(hdc, WINDING);
    Polygon(hdc, (LPPOINT)&ptl, 5);

    SelectObject(hdc,hbrSave);
    SelectObject(hdcComp,hbrushOld);
    SelectObject(hdcComp, hbmDefault);
    DeleteDC(hdcComp);
    DeleteObject(hbm);
    DeleteObject(hbrushRed);
    DeleteObject(hbrushPink);
    DeleteObject(hbrushCyan);
    DeleteObject(hbrushYellow);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftesc.c ===
/******************************Module*Header*******************************\
* Module Name: ext.c
*
* ExtTextOut test program
*
* Created: 05-Mar-1991 15:38:56
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.h"
#pragma hdrstop

#define MAX_CX     640    // VGA
#define MAX_CY     480    // VGA

void    ExtTest(HDC hdc);
void    vPrintThoseMothers(HDC hdc);
void    vDoIt(HDC hdc, LOGFONT *plfnt, int iEsc);
void    vOpaqueTest(HDC hdc);
void    vStar(HDC hdc,char * psz, LOGFONT *plfnt);

extern HANDLE hEvent;
extern ULONG  iWaitLevel;

VOID vDoPause(ULONG i)
{
    if (i < iWaitLevel)
    {
	GdiFlush();
	WaitForSingleObject(hEvent,-1);
    }
}

#define C_HEIGHT  6

short     alfHeight[C_HEIGHT] =
{
13,
16,
19,
23,
27,
35
};

PSZ apszFaces[] =
{
  "Tms Rmn"
, "Helv"
, "Courier"
, "System"
// , "Terminal"
};

VOID vTestEscapement(HWND hwnd, HDC hdc, RECT* prcl)
{
    hwnd; prcl;
//    DbgBreakPoint();	// when stop here set a brk point af vDbgBreak to stop at every page

    SetGraphicsMode(hdc, GM_ADVANCED);

    ExtTest(hdc);

    SetGraphicsMode(hdc, GM_COMPATIBLE);
}

void    ExtTest (HDC hdc)
{
    LOGFONT lfntDummy;                  // dummy logical font description
    int     iHt,iEsc;                       // escapements in tenths of degrees

#ifndef DOS_PLATFORM
    memset(&lfntDummy, 0, sizeof (lfntDummy));	// zero out the structure
#else
    memzero(&lfntDummy, sizeof (lfntDummy));	// zero out the structure
#endif  //DOS_PLATFORM

    lfntDummy.lfItalic    = 0;
    strcpy(lfntDummy.lfFaceName, "Courier");

    SetTextColor(hdc,RGB(255,0,0));
    SetBkColor(hdc,RGB(0,255,0));

    vOpaqueTest(hdc);

    for (iHt = 0L; iHt < C_HEIGHT; iHt++)
    {
        HFONT hfontHt;

	lfntDummy.lfUnderline = (iHt & 1) ? 1 : 0;
	lfntDummy.lfStrikeOut = (iHt & 2) ? 1 : 0;
        lfntDummy.lfHeight = alfHeight[iHt];
        lfntDummy.lfEscapement = 0;

        if ((hfontHt = CreateFontIndirect(&lfntDummy)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }
        SelectObject(hdc,hfontHt);

        vStar(hdc,"This is a STAR",&lfntDummy);

        for (iEsc = 0; iEsc < 3600; iEsc += 300)
            vDoIt(hdc,&lfntDummy,iEsc);
    }
}

void vDoIt(HDC hdc, LOGFONT *plfnt, int iEsc)
{
    HFONT hfontDummy, hfontOld;

    plfnt->lfEscapement = (LONG)iEsc;

// Create a logical font

    if ((hfontDummy = CreateFontIndirect(plfnt)) == NULL)
    {
        DbgPrint("  Data: CreateFontIndirect returned NULL.  Logical font creation failed.  Exiting FONT1, Captain.\n\n");
        DbgPrint("\n  BORG: LOGICAL FONTS ARE IRRELEVENT.  EXIT AND SERVICE THE BORG.\n\n");
        return;
    }

// Select font into DC

    hfontOld=SelectObject(hdc, hfontDummy);

    SetBkMode(hdc,TRANSPARENT);

    vPrintThoseMothers(hdc);

    SetBkMode(hdc,OPAQUE);

    vPrintThoseMothers(hdc);

    SelectObject(hdc, hfontOld);

    DeleteObject(hfontOld);
}




void vPrintThoseMothers
(
HDC hdc
)
{
    BOOL   bOk;
    char * psz;
    int     i;
    int     cx, cy;
    int     x,y;
    RECT    rc;
    int     adx[80];
    SIZE    size;

// Print those mothers!

    vDoPause(0);

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

// do the text rectangle stuff

    bOk = GetTextExtentPoint(hdc,"TextOut: Stiggy was here!", 25,&size);
    cx = size.cx;
    cy = 25; // size.cy;  //!!! hack

    SetTextAlign(hdc, TA_LEFT);

    vDoPause(1);

    bOk = TextOut(hdc, 20, 30, "TextOut: Stiggy was here!", 25);

// ext text out test really begins here

    psz = "Stghyg";

// spread chars

    for (i = 0; i < (int)strlen(psz); i++)
        adx[i] = 30 + 10 * i;

    SetTextAlign(hdc, TA_LEFT);

    x = 200; y  = 100;

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0L,
    (LPRECT)NULL,
    psz, strlen(psz),
    adx
    );

    y+=(cy + 5);

    SetTextAlign(hdc, TA_RIGHT);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0L,
    (LPRECT)NULL,
    psz, strlen(psz),
    adx
    );

    y+=(cy + 5);

    SetTextAlign(hdc, TA_CENTER);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0L,
    (LPRECT)NULL,
    psz, strlen(psz),
    adx
    );

    y+=(cy + 5);


// print chars one on the top of another

    for (i = 0; i < (int)strlen(psz); i++)
        adx[i] = 5;

    SetTextAlign(hdc, TA_LEFT);


    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0L,
    (LPRECT)NULL,
    psz, strlen(psz),
    adx
    );

    y+=(cy + 5);

    SetTextAlign(hdc, TA_RIGHT);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0L,
    (LPRECT)NULL,
    psz, strlen(psz),
    adx
    );

    y+=(cy + 5);

    SetTextAlign(hdc, TA_CENTER);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0L,
    (LPRECT)NULL,
    psz, strlen(psz),
    adx
    );

// use default incs

    y+= 2 * (cy + 5);

    SetTextAlign(hdc, TA_LEFT);

    x = 10;

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    0,                  // flags
    (LPRECT)NULL,
    psz, strlen(psz),
    (LPINT)NULL        // default spacing
    );

    x += 150;

//  check clipping to the rectangle


    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;


    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    ETO_CLIPPED,
    (LPRECT)&rc,
    psz, strlen(psz),
    (LPINT)NULL        // default spacing
    );

// try to get the opaqueing to work

    x += 150;

    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;


    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    ETO_CLIPPED | ETO_OPAQUE,
    (LPRECT)&rc,
    psz, strlen(psz),
    (LPINT)NULL        // default spacing
    );

    x += 150;

    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;

    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(1);

    ExtTextOut
    (
    hdc,
    x,y,
    ETO_OPAQUE,
    (LPRECT)&rc,
    psz, strlen(psz),
    (LPINT)NULL        // default spacing
    );

// check how allignment works for ordinary text out call

    SetTextAlign(hdc, TA_LEFT);

    y+=(cy + 5);
    x = 200;

    vDoPause(1);

    TextOut
    (
    hdc,
    x,y,
    psz, strlen(psz)
    );

    y+=(cy + 5);

    SetTextAlign(hdc, TA_RIGHT);

    vDoPause(1);

    TextOut
    (
    hdc,
    x,y,
    psz, strlen(psz)
    );

    y+=(cy + 5);

    SetTextAlign(hdc, TA_CENTER);

    vDoPause(1);

    TextOut
    (
    hdc,
    x,y,
    psz, strlen(psz)
    );

    MoveToEx(hdc,0,0,NULL);
}

/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  14-Mar-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

void    vStar(HDC hdc,char * psz, LOGFONT *plfnt)
{
    HFONT hfontDummy, hfontOld;
    int iEsc;
    int cch = strlen(psz);

    vDoPause(0);
    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

    for (iEsc = 0; iEsc < 3600; iEsc += 300)
    {

        plfnt->lfEscapement = iEsc;

    // Create a logical font

        if ((hfontDummy = CreateFontIndirect(plfnt)) == NULL)
        {
            DbgPrint(" CreateFontIndirect returned NULL. \n\n");
            return;
        }

    // Select font into DC

        hfontOld = SelectObject(hdc, hfontDummy);
        SetBkMode(hdc,TRANSPARENT);
        SetTextAlign(hdc, TA_TOP | TA_LEFT);
        TextOut(hdc, MAX_CX / 2, MAX_CY / 2, psz,cch);
        SelectObject(hdc, hfontOld);
        DeleteObject(hfontDummy);
    }

}


void    vOpaqueTest(HDC hdc)
{
    BOOL   bOk;
    int    x,y;
    char * psz;
    RECT    rc;

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, BLACKNESS);

    psz = (char *) NULL;      // "String";

    x = 10; y = MAX_CY / 2;

// nothing should happen

    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;

    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(0);
    bOk = ExtTextOut
    (
    hdc,
    x,y,
    0,                  // flOpts
    (LPRECT)&rc,
    psz, 0L,
    (LPINT)NULL        // default spacing
    );

    x += 150;

    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;

//  check clipping to the rectangle

    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(1);
    bOk = ExtTextOut
    (
    hdc,
    x,y,
    ETO_CLIPPED,
    (LPRECT)&rc,
    psz, 0L,
    (LPINT)NULL        // default spacing
    );

// try to get the opaqueing to work

    x += 150;

    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;


    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(1);
    bOk = ExtTextOut
    (
    hdc,
    x,y,
    ETO_CLIPPED | ETO_OPAQUE,
    (LPRECT)&rc,
    psz, 0L,
    (LPINT)NULL        // default spacing
    );

    x += 150;

    rc.left   = x + 5;
    rc.top    = y - 5;
    rc.right  = x + 45;
    rc.bottom = y + 40;

    // Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

    vDoPause(1);
    bOk = ExtTextOut
    (
    hdc,
    x,y,
    ETO_OPAQUE,
    (LPRECT)&rc,
    psz, 0L,
    (LPINT)NULL        // default spacing
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftfntspd.c ===
/******************************Module*Header*******************************\
* Module Name: ftfntspd.c
*
* Used to measure font performance on both NT and Windows.
*
* This is written to compile on both platforms.
*
* Created: 09-Sep-1993 09:19:21
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if 0
    // comment out the 3 lines above for win16
    #include "windows.h"
    #include <stdio.h>
    #include <string.h>
#else
    #define WIN32_TEST  1
#endif


typedef VOID (*PFN_TEST)(HDC);
#define LOOP 1  // defines the number of times to loop through a test.

/******************************Public*Routine******************************\
* vTimeTest
*
* Given an HDC and a function that takes an HDC, return the average time to
* execute the function and the average error.
*
* History:
*  19-Sep-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTimeTest(PFN_TEST pfn, HDC hdc, DWORD *pTime, DWORD *pError)
{
    DWORD adwTime[LOOP];
    DWORD dwTemp,dwTime,dwError;
    DWORD dwStartTime, dwEndTime;

// Get the per test time and the total for all tests.

    dwTime = 0;
    for (dwTemp = 0; dwTemp < LOOP; dwTemp++)
    {
        #if WIN32_TEST
        GdiFlush();
        #endif
        dwStartTime = GetTickCount();
        (*pfn)(hdc);
        #if WIN32_TEST
        GdiFlush();
        #endif
        dwEndTime = GetTickCount();
        adwTime[dwTemp] = dwEndTime - dwStartTime;
        dwTime += adwTime[dwTemp];
    }

// Compute the Average Time.

    dwTime = dwTime / LOOP;

// Compute the Error.

    dwError = 0;
    for (dwTemp = 0; dwTemp < LOOP; dwTemp++)
    {
        if (adwTime[dwTemp] > dwTime)
            dwError += (adwTime[dwTemp] - dwTime);
        else
            dwError += (dwTime - adwTime[dwTemp]);
    }

    dwError = dwError / LOOP;

// Write the errors back to the calling function.

    *pTime  = dwTime;
    *pError = dwError;
}

/******************************Public*Routine******************************\
* vTestTextOutSpeed
*
* This will test the speed at which TextOut works with the default font
* and another fixed pitch font to give a general measure of our text
* performance.
*
* History:
*  19-Sep-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestTextOutSpeed(HDC hdc)
{
    DWORD dwTemp;
    HFONT hfont,hfontOld;
    LOGFONT lfIn;

// Test Fixed Pitch Fonts, use bitmap.

    lfIn.lfHeight =  16;
    lfIn.lfWidth =  8;
    lfIn.lfEscapement =  0;
    lfIn.lfOrientation =  0;
    lfIn.lfWeight =  400;
    lfIn.lfItalic =  0;
    lfIn.lfUnderline =  0;
    lfIn.lfStrikeOut =  0;
    lfIn.lfCharSet =  ANSI_CHARSET;
    lfIn.lfOutPrecision =  OUT_RASTER_PRECIS;
    lfIn.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    lfIn.lfQuality =  DEFAULT_QUALITY;
    lfIn.lfPitchAndFamily =  (FIXED_PITCH | FF_DONTCARE);
    strcpy(lfIn.lfFaceName, "Courier");

    hfont = CreateFontIndirect(&lfIn);
    hfontOld = SelectObject(hdc, hfont);

    for (dwTemp = 0; dwTemp < 8000; dwTemp++)
    {
        TextOut(hdc, 5, 30, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
        TextOut(hdc, 5, 60, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);
    }

    SelectObject(hdc, hfontOld);
    DeleteObject(hfont);

// Test the variable pitch fonts, use true type.

    lfIn.lfHeight =  16;
    lfIn.lfWidth =  0;
    lfIn.lfEscapement =  0;
    lfIn.lfOrientation =  0;
    lfIn.lfWeight =  400;
    lfIn.lfItalic =  0;
    lfIn.lfUnderline =  0;
    lfIn.lfStrikeOut =  0;
    lfIn.lfCharSet =  ANSI_CHARSET;
    lfIn.lfOutPrecision =  OUT_TT_PRECIS;
    lfIn.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    lfIn.lfQuality =  DEFAULT_QUALITY;
    lfIn.lfPitchAndFamily =  (VARIABLE_PITCH | FF_ROMAN);
    strcpy(lfIn.lfFaceName, "Times New Roman");

    hfont = CreateFontIndirect(&lfIn);
    hfontOld = SelectObject(hdc, hfont);

    for (dwTemp = 0; dwTemp < 8000; dwTemp++)
    {
        TextOut(hdc, 5, 30, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
        TextOut(hdc, 5, 60, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);
    }

    SelectObject(hdc, hfontOld);
    DeleteObject(hfont);
}

/******************************Public*Routine******************************\
* vTestTTRaterizationSpeed
*
* This test forces many TT font realizations to be generated, the time
* should be dominated by the TT interpreter as only 1 character is output
* from a font.  This will keep a watch on the drop we get from the Stat
* group.
*
* History:
*  19-Sep-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vDrawText(HDC hdc, LOGFONT *plfnt)
{
    DWORD dwNumber,dwOuter,dwInner;
    HFONT hlfnt, hlfntOld;

// Force a new realization every time by incrementing by 4 in case
// Win3.1 and NT quantize differently and wouldn't generate the same
// # of different realizations when incrementing by 1.

    for (dwNumber = 0; dwNumber < 8; dwNumber++)
    {
    for (dwOuter = 12; dwOuter < 16; dwOuter++)
    {
    for (dwInner = dwOuter; dwInner <= 248; dwInner += 4)
    {
        plfnt->lfHeight = (int) dwInner;
        hlfnt = CreateFontIndirect(plfnt);
        hlfntOld = SelectObject(hdc,hlfnt);
        TextOut(hdc, 0, 0, "A", 1);
        SelectObject(hdc,hlfntOld);
        DeleteObject(hlfnt);
    }
    }
    }
}

VOID vTestTTRealizationSpeed(HDC hdc)
{
    LOGFONT lfTT;

    lfTT.lfHeight = 12;
    lfTT.lfWidth =  0;
    lfTT.lfEscapement =  0;
    lfTT.lfOrientation =  0;
    lfTT.lfWeight =  0;
    lfTT.lfItalic =  0;
    lfTT.lfUnderline =  0;
    lfTT.lfStrikeOut =  0;
    lfTT.lfCharSet =  ANSI_CHARSET;
    lfTT.lfOutPrecision =  OUT_TT_PRECIS;
    lfTT.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    lfTT.lfQuality =  DEFAULT_QUALITY;
    lfTT.lfPitchAndFamily =  DEFAULT_PITCH | FF_DONTCARE;

    strcpy(lfTT.lfFaceName, "Arial");
    vDrawText(hdc, &lfTT);

    strcpy(lfTT.lfFaceName, "Times New Roman");
    vDrawText(hdc, &lfTT);

    strcpy(lfTT.lfFaceName, "Courier New");
    vDrawText(hdc, &lfTT);
}

/******************************Public*Routine******************************\
* vMatchNewLogFontToOldRealization
*
* This measures how fast we can find an old realization with a new log font.
* We continually create and destroy 6 different LogFonts repeatedly and
* just output a single character to force a realization.
*
* History:
*  19-Sep-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vFindCachedRealization(HDC hdc, LOGFONT *plfnt)
{
    DWORD dwLoop;
    HFONT hlfnt, hlfntOld;

    for (dwLoop = 0; dwLoop < 60000; dwLoop++)
    {
        hlfnt = CreateFontIndirect(&(plfnt[dwLoop % 6]));
        hlfntOld = SelectObject(hdc,hlfnt);
        TextOut(hdc, 0, 0, "A", 1);
        SelectObject(hdc,hlfntOld);
        DeleteObject(hlfnt);
    }
}

VOID vMatchNewLogFontToOldRealization(HDC hdc)
{
    DWORD dwTemp;
    LOGFONT alf[6];

    for (dwTemp = 0; dwTemp < 6; dwTemp++)
    {
        alf[dwTemp].lfHeight =  0;
        alf[dwTemp].lfWidth =  0;
        alf[dwTemp].lfEscapement =  0;
        alf[dwTemp].lfOrientation =  0;
        alf[dwTemp].lfWeight =  0;
        alf[dwTemp].lfItalic =  0;
        alf[dwTemp].lfUnderline =  0;
        alf[dwTemp].lfStrikeOut =  0;
        alf[dwTemp].lfCharSet =  ANSI_CHARSET;
        alf[dwTemp].lfOutPrecision =  OUT_DEFAULT_PRECIS;
        alf[dwTemp].lfClipPrecision =  CLIP_DEFAULT_PRECIS;
        alf[dwTemp].lfQuality =  DEFAULT_QUALITY;
        alf[dwTemp].lfPitchAndFamily =  DEFAULT_PITCH | FF_DONTCARE;
    }

    alf[0].lfHeight =  20;
    strcpy(alf[0].lfFaceName, "Courier New");

    alf[1].lfHeight =  8;
    strcpy(alf[1].lfFaceName, "MS Serif");

    alf[2].lfHeight =  20;
    strcpy(alf[2].lfFaceName, "Times New Roman");

    alf[3].lfHeight =  10;
    strcpy(alf[3].lfFaceName, "Courier");

    alf[4].lfHeight =  20;
    strcpy(alf[4].lfFaceName, "Arial");

    alf[5].lfHeight =  12;
    strcpy(alf[5].lfFaceName, "MS Sans Serif");

    vFindCachedRealization(hdc, alf);
}

/******************************Public*Routine******************************\
* vMatchOldLogFontToOldRealization
*
* We keep switching between the same 6 LogFonts to see how fast we can
* rehook up our old still valid realization.
*
* History:
*  19-Sep-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vReFindCachedRealization(HDC hdc, HFONT *phlfnt)
{
    DWORD dwLoop;
    HFONT hlfntOld;

    for (dwLoop = 0; dwLoop < 200000; dwLoop++)
    {
        hlfntOld = SelectObject(hdc,phlfnt[dwLoop % 6]);
        TextOut(hdc, 0, 0, "A", 1);
        SelectObject(hdc,hlfntOld);
    }
}

VOID vMatchOldLogFontToOldRealization(HDC hdc)
{
    DWORD dwTemp;
    LOGFONT LogFont;
    HFONT aHfont[6];

    LogFont.lfHeight =  0;
    LogFont.lfWidth =  0;
    LogFont.lfEscapement =  0;
    LogFont.lfOrientation =  0;
    LogFont.lfWeight =  0;
    LogFont.lfItalic =  0;
    LogFont.lfUnderline =  0;
    LogFont.lfStrikeOut =  0;
    LogFont.lfCharSet =  ANSI_CHARSET;
    LogFont.lfOutPrecision =  OUT_DEFAULT_PRECIS;
    LogFont.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    LogFont.lfQuality =  DEFAULT_QUALITY;
    LogFont.lfPitchAndFamily =  DEFAULT_PITCH | FF_DONTCARE;

    LogFont.lfHeight =  20;
    strcpy(LogFont.lfFaceName, "Courier New");
    aHfont[0] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  8;
    strcpy(LogFont.lfFaceName, "MS Serif");
    aHfont[1] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  20;
    strcpy(LogFont.lfFaceName, "Times New Roman");
    aHfont[2] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  10;
    strcpy(LogFont.lfFaceName, "Courier");
    aHfont[3] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  20;
    strcpy(LogFont.lfFaceName, "Arial");
    aHfont[4] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  12;
    strcpy(LogFont.lfFaceName, "MS Sans Serif");
    aHfont[5] = CreateFontIndirect(&LogFont);

    vReFindCachedRealization(hdc, aHfont);

    for (dwTemp = 0; dwTemp < 6; dwTemp++)
        DeleteObject(aHfont[dwTemp]);
}

/******************************Public*Routine******************************\
* vTestFontSpeed
*
* Test font speed
*
* History:
*  28-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestFontSpeed(HWND hwnd)
{
    HDC hdcMemory, hdcScreen;
    HBITMAP hbmMemory, hbmDefault;
    DWORD adw[20];
    char ach[256];

    hdcScreen = GetDC(hwnd);
    hdcMemory = CreateCompatibleDC(hdcScreen);
    hbmMemory = CreateCompatibleBitmap(hdcScreen, 500, 500);
    hbmDefault = SelectObject(hdcMemory,hbmMemory);
    #if WIN32_TEST
    GdiSetBatchLimit(10);
    #endif

    PatBlt(hdcScreen, 0, 0, 10000, 10000, WHITENESS);
    PatBlt(hdcMemory, 0, 0, 10000, 10000, WHITENESS);
    SetBkColor(hdcScreen, RGB(0,255,0));
    SetBkColor(hdcMemory, RGB(0,255,0));
    SetBkMode(hdcScreen, OPAQUE);
    SetBkMode(hdcMemory, OPAQUE);

// Flush the RFONT buffer to known state.

    TextOut(hdcScreen, 0, 0, "A", 1);
    TextOut(hdcMemory, 0, 0, "A", 1);

// Generate some TextOut Numbers.

    vTimeTest(vTestTextOutSpeed, hdcScreen, &(adw[0]), &(adw[1]));
    vTimeTest(vTestTextOutSpeed, hdcMemory, &(adw[2]), &(adw[3]));

// Flush the RFONT buffer to known state.

    TextOut(hdcScreen, 0, 0, "A", 1);
    TextOut(hdcMemory, 0, 0, "A", 1);

// Generate some TT Rasterization Numbers

    vTimeTest(vTestTTRealizationSpeed, hdcScreen, &(adw[4]), &(adw[5]));
    vTimeTest(vTestTTRealizationSpeed, hdcMemory, &(adw[6]), &(adw[7]));

// Flush the RFONT buffer to known state.

    TextOut(hdcScreen, 0, 0, "A", 1);
    TextOut(hdcMemory, 0, 0, "A", 1);

// Generate some New LogFont to Old Realization Times

    vTimeTest(vMatchNewLogFontToOldRealization, hdcScreen, &(adw[8]), &(adw[9]));
    vTimeTest(vMatchNewLogFontToOldRealization, hdcMemory, &(adw[10]), &(adw[11]));

// Flush the RFONT buffer to known state.

    TextOut(hdcScreen, 0, 0, "A", 1);
    TextOut(hdcMemory, 0, 0, "A", 1);

// Generate some Old LogFont to Old Realization Times

    vTimeTest(vMatchOldLogFontToOldRealization, hdcScreen, &(adw[12]), &(adw[13]));
    vTimeTest(vMatchOldLogFontToOldRealization, hdcMemory, &(adw[14]), &(adw[15]));

// Flush the RFONT buffer to known state.

    TextOut(hdcScreen, 0, 0, "A", 1);
    TextOut(hdcMemory, 0, 0, "A", 1);

// Print out the results to the screen

    PatBlt(hdcScreen, 0, 0, 10000, 10000, WHITENESS);
    memset(ach,0,256);
    sprintf(ach, "TextOut %lu %lu %lu %lu",adw[0],adw[1],adw[2],adw[3]);
    TextOut(hdcScreen, 0, 0, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif

    memset(ach,0,256);
    sprintf(ach, "TrueType Realization %lu %lu %lu %lu",adw[4],adw[5],adw[6],adw[7]);
    TextOut(hdcScreen, 0, 30, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif

    memset(ach,0,256);
    sprintf(ach, "New LogFont to Old Realization %lu %lu %lu %lu",adw[8],adw[9],adw[10],adw[11]);
    TextOut(hdcScreen, 0, 60, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif

    memset(ach,0,256);
    sprintf(ach, "Old LogFont to Old Realization %lu %lu %lu %lu",adw[12],adw[13],adw[14],adw[15]);
    TextOut(hdcScreen, 0, 90, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif

// Delete Everything.

    SelectObject(hdcMemory, hbmDefault);
    DeleteObject(hdcMemory);
    DeleteObject(hbmMemory);
    ReleaseDC(hwnd, hdcScreen);
}

#if WIN32_TEST
/******************************Public*Routine******************************\
* The following tests get executed when running pressing ft char 'b'.
* These are solely here so I can get wt's doing operations that I'm
* trying to optimize.
*
* History:
*  01-Nov-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestTextOutSpeedwt(HDC hdc)
{
    DWORD dwTemp;
    HFONT hfont,hfontOld;
    LOGFONT lfIn;

// Test Fixed Pitch Fonts, use bitmap.

    lfIn.lfHeight =  16;
    lfIn.lfWidth =  8;
    lfIn.lfEscapement =  0;
    lfIn.lfOrientation =  0;
    lfIn.lfWeight =  400;
    lfIn.lfItalic =  0;
    lfIn.lfUnderline =  0;
    lfIn.lfStrikeOut =  0;
    lfIn.lfCharSet =  ANSI_CHARSET;
    lfIn.lfOutPrecision =  OUT_RASTER_PRECIS;
    lfIn.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    lfIn.lfQuality =  DEFAULT_QUALITY;
    lfIn.lfPitchAndFamily =  (FIXED_PITCH | FF_DONTCARE);
    strcpy(lfIn.lfFaceName, "Courier");

    hfont = CreateFontIndirect(&lfIn);
    hfontOld = SelectObject(hdc, hfont);

// Do some to set up the cache full of glyphs.

    TextOut(hdc, 5, 30, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc, 5, 60, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);
    TextOut(hdc, 5, 30, "abcdefghijklmnopqrstuvwxyz1234567890", 36);
    TextOut(hdc, 5, 60, "ABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()", 36);
    DbgPrint("Do the F12 now for TextOut\n");

    for (dwTemp = 0; dwTemp < 10000; dwTemp++)
    {
        TextOut(hdc, 5, 30, "a", 1);
    }

    DbgPrint("End of wt for TextOut\n");

    SelectObject(hdc, hfontOld);
    DeleteObject(hfont);
}

VOID vFindCachedRealizationwt(HDC hdc, LOGFONT *plfnt)
{
    DWORD dwLoop;
    HFONT hlfnt, hlfntOld;

    for (dwLoop = 0; dwLoop < 60000; dwLoop++)
    {
    // We need to start at a known place for wt to get reliable results.

        if (((dwLoop % 6) == 0) && (dwLoop > 1000))
            PatBlt(hdc, 0, 0, 1000, 1000, BLACKNESS);

        hlfnt = CreateFontIndirect(&(plfnt[dwLoop % 6]));
        hlfntOld = SelectObject(hdc,hlfnt);
        TextOut(hdc, 0, 0, "A", 1);
        SelectObject(hdc,hlfntOld);
        DeleteObject(hlfnt);
    }
}

VOID vMatchNewLogFontToOldRealizationwt(HDC hdc)
{
    DWORD dwTemp;
    LOGFONT alf[6];

    for (dwTemp = 0; dwTemp < 6; dwTemp++)
    {
        alf[dwTemp].lfHeight =  0;
        alf[dwTemp].lfWidth =  0;
        alf[dwTemp].lfEscapement =  0;
        alf[dwTemp].lfOrientation =  0;
        alf[dwTemp].lfWeight =  0;
        alf[dwTemp].lfItalic =  0;
        alf[dwTemp].lfUnderline =  0;
        alf[dwTemp].lfStrikeOut =  0;
        alf[dwTemp].lfCharSet =  ANSI_CHARSET;
        alf[dwTemp].lfOutPrecision =  OUT_DEFAULT_PRECIS;
        alf[dwTemp].lfClipPrecision =  CLIP_DEFAULT_PRECIS;
        alf[dwTemp].lfQuality =  DEFAULT_QUALITY;
        alf[dwTemp].lfPitchAndFamily =  DEFAULT_PITCH | FF_DONTCARE;
    }

    alf[0].lfHeight =  20;
    strcpy(alf[0].lfFaceName, "Courier New");

    alf[1].lfHeight =  8;
    strcpy(alf[1].lfFaceName, "MS Serif");

    alf[2].lfHeight =  20;
    strcpy(alf[2].lfFaceName, "Times New Roman");

    alf[3].lfHeight =  10;
    strcpy(alf[3].lfFaceName, "Courier");

    alf[4].lfHeight =  20;
    strcpy(alf[4].lfFaceName, "Arial");

    alf[5].lfHeight =  12;
    strcpy(alf[5].lfFaceName, "MS Sans Serif");

    vFindCachedRealizationwt(hdc, alf);
}

VOID vReFindCachedRealizationwt(HDC hdc, HFONT *phlfnt)
{
    DWORD dwLoop;
    HFONT hlfntOld;

    for (dwLoop = 0; dwLoop < 200000; dwLoop++)
    {
    // We need to start at a known place for wt to get reliable results.

        if (((dwLoop % 6) == 0) && (dwLoop > 1000))
            PatBlt(hdc, 0, 0, 1000, 1000, BLACKNESS);

        hlfntOld = SelectObject(hdc,phlfnt[dwLoop % 6]);
        TextOut(hdc, 0, 0, "A", 1);
        SelectObject(hdc,hlfntOld);
    }
}

VOID vMatchOldLogFontToOldRealizationwt(HDC hdc)
{
    DWORD dwTemp;
    LOGFONT LogFont;
    HFONT aHfont[6];

    LogFont.lfHeight =  0;
    LogFont.lfWidth =  0;
    LogFont.lfEscapement =  0;
    LogFont.lfOrientation =  0;
    LogFont.lfWeight =  0;
    LogFont.lfItalic =  0;
    LogFont.lfUnderline =  0;
    LogFont.lfStrikeOut =  0;
    LogFont.lfCharSet =  ANSI_CHARSET;
    LogFont.lfOutPrecision =  OUT_DEFAULT_PRECIS;
    LogFont.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
    LogFont.lfQuality =  DEFAULT_QUALITY;
    LogFont.lfPitchAndFamily =  DEFAULT_PITCH | FF_DONTCARE;

    LogFont.lfHeight =  20;
    strcpy(LogFont.lfFaceName, "Courier New");
    aHfont[0] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  8;
    strcpy(LogFont.lfFaceName, "MS Serif");
    aHfont[1] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  20;
    strcpy(LogFont.lfFaceName, "Times New Roman");
    aHfont[2] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  10;
    strcpy(LogFont.lfFaceName, "Courier");
    aHfont[3] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  20;
    strcpy(LogFont.lfFaceName, "Arial");
    aHfont[4] = CreateFontIndirect(&LogFont);

    LogFont.lfHeight =  12;
    strcpy(LogFont.lfFaceName, "MS Sans Serif");
    aHfont[5] = CreateFontIndirect(&LogFont);

    vReFindCachedRealizationwt(hdc, aHfont);

    for (dwTemp = 0; dwTemp < 6; dwTemp++)
        DeleteObject(aHfont[dwTemp]);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftflag.c ===
/******************************Module*Header*******************************\
* Module Name: ftodd.c
*
* Oddball pattern size tests
*
* Created: 28-Jan-1992 20:53:20
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct _XLOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} XLOGPALETTE;

XLOGPALETTE XlogPal =
{

    0x300,  // driver version
    16,	    // num entries
    {
	{ 0,   0,   0,	 0 },	    // 0
	{ 0x80,0,   0,	 0 },	    // 1
	{ 0,   0x80,0,	 0 },	    // 2
	{ 0x80,0x80,0,	 0 },	    // 3
	{ 0,   0,   0x80,0 },	    // 4
	{ 0x80,0,   0x80,0 },	    // 5
	{ 0,   0x80,0x80,0 },	    // 6
	{ 0x80,0x80,0x80,0 },	    // 7

	{ 0xC0,0xC0,0xC0,0 },	    // 8
	{ 0xFF,0,   0,	 0 },	    // 9
	{ 0,   0xFF,0,	 0 },	    // 10
	{ 0xFF,0xFF,0,	 0 },	    // 11
	{ 0,   0,   0xFF,0 },	    // 12
	{ 0xFF,0,   0xFF,0 },	    // 13
	{ 0,   0xFF,0xFF,0 },	    // 14
	{ 0xFF,0xFF,0xFF,0 }	    // 15
    }
};

/******************************Public*Routine******************************\
* vTestFlag
*
* Draw the Canadian flag
*
* History:
*  11-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vTestFlag(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    HPALETTE	 hpal, hpalDef;
    HBITMAP	 hbm, hbmDef, hbm7, hbm13, hbm17;
    HBRUSH	 hbr7, hbr13, hbr17, hbrDef;
    HBRUSH	 hbrOrange, hbrRed;
    HFONT	 hfnt, hfntDef;
    POINT	 ptl[50];
    int 	 aint[10];
    int 	 ii, jj;
    LOGFONT	 lfnt;
    PALETTEENTRY palent[10];

#if defined(AMD64) || defined(_IA64_)
    hwnd = hwnd;

    PatBlt(hdcScreen, 0, 0, prcl->right, prcl->bottom, WHITENESS);

    hpal = CreatePalette((LOGPALETTE *) &XlogPal);
    hpalDef = SelectPalette(hdcScreen, hpal, 0);
    RealizePalette(hdcScreen);

// Create the Canadian flag

    ptl[ 0].x = 1115 +	0;  ptl[ 0].y = 460 +  0;
    ptl[ 1].x = 1115 +	8;  ptl[ 1].y = 460 + 12;
    ptl[ 2].x = 1115 + 14;  ptl[ 2].y = 460 +  8;
    ptl[ 3].x = 1115 + 12;  ptl[ 3].y = 460 + 28;
    ptl[ 4].x = 1115 + 22;  ptl[ 4].y = 460 + 22;
    ptl[ 5].x = 1115 + 26;  ptl[ 5].y = 460 + 28;
    ptl[ 6].x = 1115 + 34;  ptl[ 6].y = 460 + 28;
    ptl[ 7].x = 1115 + 30;  ptl[ 7].y = 460 + 36;
    ptl[ 8].x = 1115 + 34;  ptl[ 8].y = 460 + 42;
    ptl[ 9].x = 1115 + 18;  ptl[ 9].y = 460 + 54;
    ptl[10].x = 1115 + 22;  ptl[10].y = 460 + 62;
    ptl[11].x = 1115 + 10;  ptl[11].y = 460 + 56;
    ptl[12].x = 1115 +	2;  ptl[12].y = 460 + 56;
    ptl[13].x = 1115 +	2;  ptl[13].y = 460 + 76;
    ptl[14].x = 1115 -	2;  ptl[14].y = 460 + 76;
    ptl[15].x = 1115 -	2;  ptl[15].y = 460 + 56;
    ptl[16].x = 1115 - 10;  ptl[16].y = 460 + 56;
    ptl[17].x = 1115 - 22;  ptl[17].y = 460 + 62;
    ptl[18].x = 1115 - 18;  ptl[18].y = 460 + 54;
    ptl[19].x = 1115 - 34;  ptl[19].y = 460 + 42;
    ptl[20].x = 1115 - 30;  ptl[20].y = 460 + 36;
    ptl[21].x = 1115 - 34;  ptl[21].y = 460 + 28;
    ptl[22].x = 1115 - 26;  ptl[22].y = 460 + 28;
    ptl[23].x = 1115 - 22;  ptl[23].y = 460 + 22;
    ptl[24].x = 1115 - 12;  ptl[24].y = 460 + 28;
    ptl[25].x = 1115 - 14;  ptl[25].y = 460 +  8;
    ptl[26].x = 1115 -	8;  ptl[26].y = 460 + 12;

    ptl[27].x = 1115 - 85;  ptl[27].y = 460 -  5;
    ptl[28].x = 1115 - 40;  ptl[28].y = 460 -  5;
    ptl[29].x = 1115 - 40;  ptl[29].y = 460 + 80;
    ptl[30].x = 1115 - 85;  ptl[30].y = 460 + 80;

    ptl[31].x = 1115 + 85;  ptl[31].y = 460 -  5;
    ptl[32].x = 1115 + 40;  ptl[32].y = 460 -  5;
    ptl[33].x = 1115 + 40;  ptl[33].y = 460 + 80;
    ptl[34].x = 1115 + 85;  ptl[34].y = 460 + 80;

    aint[0] = 27;
    aint[1] =  4;
    aint[2] =  4;

// Fill in the logical font fields.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Lucida");
    lfnt.lfEscapement = 0; // mapper respects this filed
    lfnt.lfItalic = 0;
    lfnt.lfUnderline = 0;
    lfnt.lfStrikeOut = 0;
    lfnt.lfHeight = 440;
    lfnt.lfWeight = 400;

// Assure the ROP,filling mode and outline pen are correct

    SetROP2(hdcScreen, R2_COPYPEN);
    SetPolyFillMode(hdcScreen, ALTERNATE);
    SelectObject(hdcScreen, GetStockObject(BLACK_PEN));

// If we can get Lucida, do the demo

    if ((hfnt = CreateFontIndirect(&lfnt)) != NULL)
    {
	hfntDef = SelectObject(hdcScreen, hfnt);
	DeleteObject(hfnt);

	SetTextColor(hdcScreen, 0x000000ff);
	TextOutA(hdcScreen, 0, 375, "Canada", 6);	// TextOut, eh?

	hbrRed = CreateSolidBrush(RGB(255,0,0));
	SelectObject(hdcScreen, hbrRed);
	DeleteObject(hbrRed);

	PolyPolygon(hdcScreen, (LPPOINT) &ptl, (LPINT) &aint, 3);

	SelectObject(hdcScreen, hfntDef);
    }

    hpalDef = SelectPalette(hdcScreen, hpalDef, 0);
    DeleteObject(hpal);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftfonts.c ===
/******************************Module*Header*******************************\
* Module Name: ftfonts.c
*
* font tests
*
* Created: 26-May-1991 13:07:35
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


// These point sizes are used by vPrintFaces to create different size fonts.
// NOTE: these are no longer point sizes, rather they are font heights (which
// is what Windows uses in the LOGFONT).

USHORT  gusPointSize[6] = {13, 16, 19, 23, 27, 35};


// These are pitch strings to use when printing out LOGFONTs.

LPSTR   gapszPitch[3] = {"Default pitch",
                        "Fixed pitch",
                        "Variable pitch"
                       };


// These are family name strings to use when printing out LOGFONTs.

LPSTR   gapszFamily[6] = {"Don't care",
                         "Roman",
                         "Swiss",
                         "Modern",
                         "Script",
                         "Decorative"
                        };


// Function prototypes

VOID FontTest(HDC);
VOID vPrintMapModes (HDC, HFONT);
VOID vPrintFaces (HDC, PSZ, ULONG, USHORT *);
VOID vPrintStockFonts (HDC);
VOID vPrintGetObject (HDC, HFONT, PSZ);
VOID vPrintEnumFontTest (HDC);
int  iPrintFontInfo (PLOGFONT, PTEXTMETRIC, ULONG, HDC *);
int  iPrintFaceSamples (PLOGFONT, PTEXTMETRIC, ULONG, HDC *);
VOID vPrintCharSet (HDC, HFONT, ULONG);
VOID vTestSymbolFont (HDC);
VOID vPrintGetFontResourceInfoTest (HDC);
VOID vPrintLogFont (HDC, PLOGFONT);
LPSTR pszPitchIs (BYTE);
LPSTR pszFamilyIs (BYTE);


CHAR szOutText[255];

// Private GDI entry point

BOOL GetFontResourceInfoW(
    IN LPWSTR        lpPathname,
    IN OUT LPDWORD  lpBytes,
    IN OUT LPVOID   lpBuffer,
    IN DWORD        iType);

#define GFRI_NUMFONTS       0L
#define GFRI_DESCRIPTION    1L
#define GFRI_LOGFONTS       2L


// External references

extern HANDLE ghInstance;

extern SIZE sizlWindow;
extern SIZE sizlViewport;


/******************************Public*Routine******************************\
* VOID vTestFonts(HWND hwnd, HDC hdc, RECT* prcl)
*
* Test fonts in a variety of ways.
*
* History:
*  31-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vTestFonts(HWND hwnd, HDC hdc, RECT* prcl)
{
    COLORREF crText = GetTextColor(hdc);
    COLORREF crBack = GetBkColor(hdc);

    FontTest (hdc);

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(prcl);

    SetTextColor(hdc,crText);
    SetBkColor(hdc,crBack);
    return;
}


/******************************Public*Routine******************************\
* VOID FontTest (HDC hdc)
*
* Stub that calls all the other tests (stolen from fonttest.c).
*
* History:
*  31-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FontTest (HDC hdc)
{

    int iBkOld;
    USHORT  usPS = 16;
    HFONT   hfont;
    LOGFONT lfnt;

    iBkOld = SetBkMode(hdc, TRANSPARENT);

// GetFontResourceInfo.

//    SetTextColor(hdc, 0x0000ff00);
//    vPrintGetFontResourceInfoTest(hdc);
//    DbgBreakPoint();

// Test mapping mode.

    SetTextColor(hdc, 0x007fffff);

    vPrintMapModes(hdc, GetStockObject(DEVICE_DEFAULT_FONT));

    memset(&lfnt, 0, sizeof(lfnt));
    lfnt.lfHeight = 270;
    lstrcpy(lfnt.lfFaceName, "Tms Rmn");
    lfnt.lfItalic = FALSE;
    lfnt.lfUnderline = FALSE;
    lfnt.lfWeight = 400;
    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return;
    }

    vPrintMapModes(hdc, hfont);

    DeleteObject(hfont);

// Test symbol font.

    vTestSymbolFont(hdc);

// Test font enumeration.

//    SetMapMode (hdc, MM_ANISOTROPIC) ;
//
//    SetWindowExtEx (hdc, 1440, 1440, NULL);
//    SetViewportExtEx (hdc, GetDeviceCaps(hdc, LOGPIXELSX), GetDeviceCaps(hdc, LOGPIXELSY), NULL) ;

    SetTextColor(hdc, 0x000f00ff);

    vPrintEnumFontTest(hdc);

// Test fonts.

    SetTextColor(hdc, 0x00ffff00);
    // DbgPrint("Printing some System fonts.\n");
    vPrintFaces(hdc, "System", 1, &usPS);
    // DbgBreakPoint();

    SetTextColor(hdc, 0x00ffff00);
    // DbgPrint("Printing some Courier fonts.\n");
    vPrintFaces(hdc, "Courier", 3, gusPointSize);
    // DbgBreakPoint();

    SetTextColor(hdc, 0x0000ff00);
    // DbgPrint("Printing some Times Roman fonts.\n");
    vPrintFaces(hdc, "Tms Rmn", 6, gusPointSize);
    // DbgBreakPoint();

    SetTextColor(hdc, 0x000000ff);
    // DbgPrint("Printing some Helvetica fonts.\n");
    vPrintFaces(hdc, "Helv", 6, gusPointSize);
    // DbgBreakPoint();

// Test stock fonts.

    SetTextColor(hdc, 0x00000fff);
    // DbgPrint("Testing the stock fonts.\n");
    vPrintStockFonts(hdc);
    // DbgBreakPoint();

    SetTextColor(hdc, 0x00ff00ff);

// Test GetObject for stock fonts and some created fonts.

    // DbgPrint("Test GetObject().\n");

    // Stock fonts.

        vPrintGetObject(hdc, (HFONT) GetStockObject(SYSTEM_FONT), "System font");
	// DbgBreakPoint();

        vPrintGetObject(hdc, (HFONT) GetStockObject(SYSTEM_FIXED_FONT), "System fixed font");
	// DbgBreakPoint();

        vPrintGetObject(hdc, (HFONT) GetStockObject(OEM_FIXED_FONT), "Terminal font");
	// DbgBreakPoint();

        vPrintGetObject(hdc, (HFONT) GetStockObject(DEVICE_DEFAULT_FONT), "Device default font");
	// DbgBreakPoint();

        vPrintGetObject(hdc, (HFONT) GetStockObject(ANSI_VAR_FONT), "ANSI variable font");
	// DbgBreakPoint();

        vPrintGetObject(hdc, (HFONT) GetStockObject(ANSI_FIXED_FONT), "ANSI fixed font");
	// DbgBreakPoint();

    // Created fonts.

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = FALSE;
        lfnt.lfUnderline = FALSE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 400;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: normal");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = TRUE;
        lfnt.lfUnderline = FALSE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 400;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: italic");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = FALSE;
        lfnt.lfUnderline = FALSE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 700;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: bold");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = FALSE;
        lfnt.lfUnderline = FALSE;
        lfnt.lfStrikeOut = TRUE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 400;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: strikeout");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = FALSE;
        lfnt.lfUnderline = TRUE;
        lfnt.lfStrikeOut = FALSE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 400;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: underline");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = TRUE;
        lfnt.lfUnderline = FALSE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 700;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: bold, italic");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

        memset(&lfnt, 0, sizeof(lfnt));
        lstrcpy(lfnt.lfFaceName, "Tms Rmn");
        lfnt.lfItalic = TRUE;
        lfnt.lfUnderline = TRUE;
        lfnt.lfHeight = 21;
        lfnt.lfWeight = 700;
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        vPrintGetObject(hdc, hfont, "Created font: bold, italic, underlined");
	// DbgBreakPoint();
        if (!DeleteObject(hfont))
            DbgPrint("FontTest (GetObject rest for created fonts): error deleting HFONT = 0x%lx\n", hfont);

    iBkOld = SetBkMode(hdc, iBkOld);
}


/******************************Public*Routine******************************\
* VOID vPrintMapModes (
*     HDC     hdc
*     )
*
*
* History:
*  11-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintMapModes (
    HDC     hdc,
    HFONT   hfont
    )
{
    ULONG   iMapMode;
    ULONG   row = 0;
    HFONT   hfontOld;
    TEXTMETRIC  metrics;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

    iMapMode = SetMapMode(hdc, MM_TWIPS);

    hfontOld = SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

        if (!GetTextFace(hdc, 255, szOutText))
        {
            DbgPrint("vPrintFaces: GetTextFace failed.\n");
        }


    // Print those mothers!

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
//        DbgPrint("%s\n", szOutText);

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        sprintf(szOutText, "Height: %ld", metrics.tmHeight);
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
//        DbgPrint("%s\n", szOutText);

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        sprintf(szOutText, "AveWidth: %ld", metrics.tmAveCharWidth);
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
//        DbgPrint("%s\n", szOutText);

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        sprintf(szOutText, "Internal Leading: %ld", metrics.tmInternalLeading);
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
//        DbgPrint("%s\n", szOutText);

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        sprintf(szOutText, "External Leading: %ld", metrics.tmExternalLeading);
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
//        DbgPrint("%s\n", szOutText);

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        sprintf(szOutText, "Ascent Leading: %ld", metrics.tmAscent);
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
//        DbgPrint("%s\n", szOutText);

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));

        row -= metrics.tmHeight+metrics.tmExternalLeading;
        lstrcpy (szOutText, "1234567890-=`~!@#$%^&*()_+[]{}|\/.,<>?");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));

    if ((SelectObject(hdc, hfont)) == (HFONT) NULL)
    {
        DbgPrint("FT!vPrintMapModes(): select object failed\n");
    }

    SelectObject(hdc, hfontOld);

    iMapMode = SetMapMode(hdc, iMapMode);

}


/******************************Public*Routine******************************\
* VOID vPrintFaces (
*     HDC     hdc,
*     PSZ     pszFaceName
*     ULONG   cPointSizesEffects:
*     )
*
* This function will print several different point sizes of a font face.
*
* History:
*  07-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintFaces (
    HDC     hdc,                        // print to this HDC
    PSZ     pszFaceName,                // use this facename
    ULONG   cPointSizes,                // number of point sizes
    USHORT  usPointSize[]               // array of point sizes
    )
{
    LOGFONT lfnt;                       // logical font
    ULONG   iSize;                      // index into point size array
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    TEXTMETRIC  metrics;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

// Fill in the logical font fields.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, pszFaceName);
    lfnt.lfEscapement = 0; // mapper respects this filed
    lfnt.lfItalic = 0;
    lfnt.lfUnderline = 0;
    lfnt.lfStrikeOut = 0;

// Print text using different point sizes from array of point sizes.

    for (iSize = 0; iSize < cPointSizes; iSize++)
    {

    // Create a font of the desired face and size.

        lfnt.lfHeight = usPointSize[iSize];
        if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        // sprintf(szOutText, "%s %d: Stiggy was here!", pszFaceName, usPointSize[iSize]);
        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "1234567890-=`~!@#$%^&*()_+[]{}|\/.,<>?");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

    // Select original font back into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfontOriginal);

    // Delete font

        if (!DeleteObject(hfont))
            DbgPrint("vPrintFaces: error deleting HFONT = 0x%lx\n", hfont);

    }

}


/******************************Public*Routine******************************\
* VOID vPrintStockFonts (
*     HDC     hdc
*     )
*
* This function will print several different point sizes of a font face.
*
* History:
*  09-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

CHAR szOutText[255];

VOID vPrintStockFonts (
    HDC     hdc                         // print to this HDC
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    TEXTMETRIC  metrics;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

// System font.

    // Get stock font.

        hfont = (HFONT) GetStockObject(SYSTEM_FONT);

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        lstrcpy (szOutText, "System Font");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

// System fixed font.

    // Get stock font.

        hfont = (HFONT) GetStockObject(SYSTEM_FIXED_FONT);

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        lstrcpy (szOutText, "System Fixed Font");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

// OEM fixed font.

    // Get stock font.

        hfont = (HFONT) GetStockObject(OEM_FIXED_FONT);

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        lstrcpy (szOutText, "OEM Fixed Font (Terminal Font)");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

// Device default font.

    // Get stock font.

        hfont = (HFONT) GetStockObject(DEVICE_DEFAULT_FONT);

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        lstrcpy (szOutText, "Device Default Font");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

// ANSI variable-pitch font.

    // Get stock font.

        hfont = (HFONT) GetStockObject(ANSI_VAR_FONT);

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        lstrcpy (szOutText, "ANSI variable-pitch font");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

// ANSI fixed-pitch font.

    // Get stock font.

        hfont = (HFONT) GetStockObject(ANSI_FIXED_FONT);

    // Select font into DC.

        hfontOriginal = (HFONT) SelectObject(hdc, hfont);

    // Get metrics.

        if (!GetTextMetrics (hdc, &metrics))
        {
            DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        }

    // Print those mothers!

        lstrcpy (szOutText, "ANSI fixed-pitch font");
        TextOut(hdc, 0, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

        lstrcpy (szOutText, "abcdefghijklmnopqrstuvwxyz");
        TextOut(hdc, 10, row, szOutText, strlen(szOutText));
        row += metrics.tmHeight+metrics.tmExternalLeading;

}


/******************************Public*Routine******************************\
* VOID vPrintGetObject (
*     HDC     hdc,
*     HFONT   hfnt,
*     PSZ     pszText
*     )
*
* Print the LOGFONT of the specified HFONT.
*
* History:
*  09-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintGetObject (
    HDC     hdc,                        // print to this HDC
    HFONT   hfnt,                       // print info on this font
    PSZ     pszText                     // descriptive text
    )
{
    LOGFONT lfntRet;                    // logical font
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfontOriginal;
    TEXTMETRIC  metrics;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

// Get LOGFONT.

    if (!GetObject((HANDLE) hfnt, sizeof(LOGFONT), &lfntRet))
    {
        DbgPrint("vPrintGetObject: error getting LOGFONT from GetObject().\n");
        return;
    }

// Select incoming font into the DC.

    hfontOriginal = (HFONT) SelectObject(hdc, hfnt);

// Get metrics.

    if (!GetTextMetrics (hdc, &metrics))
    {
        DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
    }

// Print those mothers!

    sprintf(szOutText, "%s", pszText);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "LOGICAL FONT: %s", lfntRet.lfFaceName);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Height: %d", lfntRet.lfHeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Width: %d", lfntRet.lfWidth);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Escapement: %d", lfntRet.lfEscapement);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Orientation: %d", lfntRet.lfOrientation);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Weight: %d", lfntRet.lfWeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Italicized: %s", (lfntRet.lfItalic) ? "TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Underlined: %s", (lfntRet.lfUnderline) ? "TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Strike Through: %s", (lfntRet.lfStrikeOut) ? "TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Out Precision: %d", lfntRet.lfOutPrecision);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Clip Precision: %d", lfntRet.lfClipPrecision);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

    sprintf(szOutText, "Pitch and Family: %d", lfntRet.lfPitchAndFamily);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += metrics.tmHeight+metrics.tmExternalLeading;

// Restore original font.

    hfontOriginal = (HFONT) SelectObject(hdc, hfontOriginal);
}


/******************************Public*Routine******************************\
* VOID vPrintEnumFontTest (
*     HDC hdc
*     )
*
* Test EnumFonts by printing every example of every font face in the system
* that are usable by the specified HDC.
*
* History:
*  29-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintEnumFontTest (
    HDC hdc
    )
{
    EnumFonts (
        hdc,
        (LPCSTR) NULL,
        (FONTENUMPROC) iPrintFaceSamples,
        (LPARAM) &hdc
        );
}


/******************************Public*Routine******************************\
* iPrintFaceSamples (
*     PLOGFONT    plf,
*     PTEXTMETRIC ptm,
*     ULONG       flType
*     HDC         *phdc
*     )
*
* An EnumFonts callback.  Enumerate all fonts with the face specified
* in the LOGFONT.
*
* History:
*  31-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

iPrintFaceSamples (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc
    )
{
    int iRet;

    UNREFERENCED_PARAMETER(ptm);
    UNREFERENCED_PARAMETER(flType);

    iRet = EnumFonts (
                *phdc,
                (LPCSTR) (plf->lfFaceName),
                (FONTENUMPROC) iPrintFontInfo,
                (LPARAM) phdc
                );

    return (iRet);
}


/******************************Public*Routine******************************\
* int  iPrintFontInfo (
*     PLOGFONT    plf,
*     PTEXTMETRIC ptm,
*     ULONG       flType
*     HDC         *phdc
*     )
*
* An EnumFonts callback.  Print the LOGFONT.
*
* History:
*  29-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int  iPrintFontInfo (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    PSZ     pszPitch, pszFamily;

    UNREFERENCED_PARAMETER(flType);

// Clear the screen to black.

    BitBlt(*phdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

    if ((hfont = CreateFontIndirect(plf)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return 0;
    }

// Select font into DC.

    hfontOriginal = (HFONT) SelectObject(*phdc, hfont);

// Print those mothers!

    sprintf(szOutText, "LOGICAL FONT: %s", plf->lfFaceName);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Height: %d", plf->lfHeight);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Width: %d", plf->lfWidth);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Internal Leading: %d", ptm->tmInternalLeading);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Escapement: %d", plf->lfEscapement);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Orientation: %d", plf->lfOrientation);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Weight: %d", plf->lfWeight);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Italicized: %s", (plf->lfItalic) ? "TRUE":"FALSE");
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Underlined: %s", (plf->lfUnderline) ? "TRUE":"FALSE");
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Strike Through: %s", (plf->lfStrikeOut) ? "TRUE":"FALSE");
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Out Precision: %d", plf->lfOutPrecision);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    sprintf(szOutText, "Clip Precision: %d", plf->lfClipPrecision);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

    pszPitch = pszPitchIs(plf->lfPitchAndFamily);
    pszFamily = pszFamilyIs(plf->lfPitchAndFamily);
    sprintf(szOutText, "Pitch and Family: %s, %s", pszPitch, pszFamily);
//    sprintf(szOutText, "Pitch and Family: %d", plf->lfPitchAndFamily);
    TextOut(*phdc, 0, row, szOutText, strlen(szOutText));
    row += ptm->tmHeight+ptm->tmExternalLeading;

// Select original font back into DC.

    hfontOriginal = (HFONT) SelectObject(*phdc, hfontOriginal);

// Delete font

    if (!DeleteObject(hfont))
        DbgPrint("vPrintFaces: error deleting HFONT = 0x%lx\n", hfont);

    return 1;
}



/******************************Public*Routine******************************\
* VOID vPrintCharSet (
*     HDC     hdc,
*     HFONT   hfont,
*     ULONG   color
*     )
*
*
* History:
*  22-Aug-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintCharSet (
    HDC     hdc,
    HFONT   hfont,
    ULONG   color
    )
{
    ULONG   row = 0;
    ULONG   col = 0;
    HFONT   hfontOriginal;
    ULONG   ulLineSpacing;
    ULONG   ulCharSpacing;
    TEXTMETRIC tm;
    POINT   ptTextGrid[16][16];
    BYTE    jChar;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

// Set text color.

    SetTextColor(hdc, color);

// Select font into DC.

    hfontOriginal = (HFONT) SelectObject(hdc, hfont);

// Get text metrics.

    if (!GetTextMetrics (hdc, &tm))
    {
        DbgPrint("vPrintCharSet(): GetTextMetrics failed.\n");
    }

// Text grid parameters.

    ulLineSpacing = tm.tmHeight + tm.tmExternalLeading;
    ulCharSpacing = tm.tmMaxCharWidth;

// Compute text grid.

    for (row=0; row<16; row++)
        for (col=0; col<16; col++)
        {
            ptTextGrid[row][col].y = row*ulLineSpacing;
            ptTextGrid[row][col].x = col*ulCharSpacing;
        }

// Print characters in the grid.

    for (row=0, jChar=0; row<16; row++)
        for (col=0; col<16; col++, jChar++)
            TextOut(hdc, ptTextGrid[row][col].x, ptTextGrid[row][col].y, &jChar, 1);

// Select original font back into DC.

    hfontOriginal = (HFONT) SelectObject(hdc, hfontOriginal);

}


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  22-Aug-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vTestSymbolFont (HDC hdc)
{
    LOGFONT lfnt;
    HFONT   hfont;

// Fill in the logical font fields.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Symbol");
    lfnt.lfHeight = 16;

// Create a font of the desired face and size.

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("vTestSymbolFont(): Logical font creation failed.\n");
        return;
    }

// Print out all the characters.

    vPrintCharSet(hdc, hfont, 0x00ff00ff);

// Delete the font.

    if (!DeleteObject(hfont))
    {
        DbgPrint("vTestSymbolFont(): Logical font deletion failed.\n");
        return;
    }

    // DbgBreakPoint();

}


/******************************Public*Routine******************************\
* VOID vPrintGetFontResourceInfoTest(HDC hdc)
*
*
* History:
*  15-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LOGFONT galf[32];
CHAR    gach[255];

VOID vPrintGetFontResourceInfoTest(HDC hdc)
{
    ULONG   cjBuf;
    ULONG   nFonts;
    ULONG   ul;

// Test description string.

    AddFontResource((LPSTR) "c:\\nt\\windows\\fonts\\tmsre.fon");

    cjBuf = 0;
    if (!GetFontResourceInfoW((LPWSTR) L"c:\\nt\\windows\\fonts\\tmsre.fon", (LPDWORD) &cjBuf, (LPVOID) NULL, GFRI_DESCRIPTION))
        DbgPrint("vPrintGetFontResourceInfoTest(); GetFontResourceInfo failed\n");

    DbgPrint("Text string length is: %ld\n", cjBuf-1);

    if (!GetFontResourceInfoW((LPWSTR) L"c:\\nt\\windows\\fonts\\tmsre.fon", (LPDWORD) &cjBuf, (LPVOID) gach, GFRI_DESCRIPTION))
        DbgPrint("vPrintGetFontResourceInfoTest(); GetFontResourceInfo failed\n");

    TextOut(hdc, 0, 0, gach, cjBuf-1);
    DbgPrint("Text string is: %s\n", gach);
    DbgBreakPoint();

// Log font test.

    cjBuf = sizeof(nFonts);
    if (!GetFontResourceInfoW((LPWSTR) L"c:\\nt\\windows\\fonts\\tmsre.fon", (LPDWORD) &cjBuf, (LPVOID) &nFonts, GFRI_NUMFONTS))
        DbgPrint("vPrintGetFontResourceInfoTest(); GetFontResourceInfo failed\n");

    DbgPrint("There are %ld fonts in the file\n", nFonts);

    cjBuf = 0;
    if (!GetFontResourceInfoW((LPWSTR) L"c:\\nt\\windows\\fonts\\tmsre.fon", (LPDWORD) &cjBuf, (LPVOID) NULL, GFRI_LOGFONTS))
        DbgPrint("vPrintGetFontResourceInfoTest(); GetFontResourceInfo failed\n");

    DbgPrint("Size of buffer needed for LOGFONTS: %ld\n", cjBuf);
    DbgPrint("nFonts * sizeof(LOGFONT) = %ld\n", nFonts * sizeof(LOGFONT));

    if (!GetFontResourceInfoW((LPWSTR) L"c:\\nt\\windows\\fonts\\tmsre.fon", (LPDWORD) &cjBuf, (LPVOID) galf, GFRI_LOGFONTS))
        DbgPrint("vPrintGetFontResourceInfoTest(); GetFontResourceInfo failed\n");

    DbgPrint("Buffer: galf = 0x%lx\n", galf);

    for (ul = 0; ul < nFonts; ul++)
    {
        vPrintLogFont(hdc, &(galf[ul]));
        DbgBreakPoint();
    }

    RemoveFontResource((LPSTR) "c:\\nt\\windows\\fonts\\tmsre.fon");

}


/******************************Public*Routine******************************\
* VOID vPrintLogFont(HDC hdc, PLOGFONT plf)
*
* Print a sample of the LOGFONT.
*
* History:
*  15-Jul-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintLogFont(HDC hdc, PLOGFONT plf)
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    TEXTMETRIC  tm;
    PSZ     pszPitch, pszFamily;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, sizlWindow.cx, sizlWindow.cy, (HDC) 0, 0, 0, WHITENESS);

    if ((hfont = CreateFontIndirect(plf)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return;
    }

// Select font into DC.

    hfontOriginal = (HFONT) SelectObject(hdc, hfont);

// Get text metrics

    if (!GetTextMetrics (hdc, &tm))
    {
        DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
        return;
    }

// Print those mothers!

    sprintf(szOutText, "LOGICAL FONT: %s", plf->lfFaceName);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Height: %d", plf->lfHeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Width: %d", plf->lfWidth);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Escapement: %d", plf->lfEscapement);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Orientation: %d", plf->lfOrientation);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Weight: %d", plf->lfWeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Italicized: %s", (plf->lfItalic) ? "TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Underlined: %s", (plf->lfUnderline) ? "TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Strike Through: %s", (plf->lfStrikeOut) ? "TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Out Precision: %d", plf->lfOutPrecision);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Clip Precision: %d", plf->lfClipPrecision);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    pszPitch = pszPitchIs(plf->lfPitchAndFamily);
    pszFamily = pszFamilyIs(plf->lfPitchAndFamily);
    sprintf(szOutText, "Pitch and Family: %s, %s", pszPitch, pszFamily);
//    sprintf(szOutText, "Pitch and Family: %d", plf->lfPitchAndFamily);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

// Select original font back into DC.

    hfontOriginal = (HFONT) SelectObject(hdc, hfontOriginal);

// Delete font

    if (!DeleteObject(hfont))
        DbgPrint("vPrintFaces: error deleting HFONT = 0x%lx\n", hfont);
}


LPSTR pszPitchIs (BYTE j)
{
    return (gapszPitch[((ULONG) j) & 0x0F]);
}


LPSTR pszFamilyIs (BYTE j)
{
    return (gapszFamily[((ULONG) j) >> 4]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftgentxt.c ===
/******************************Module*Header*******************************\
* Module Name: ftgentxt.c
*
* This program prints text using a font from a specified file.  The text
* is printed normally, inverse, and clipped.  Finally, some text is printed
* through a circular region.
*
* Created: 29-Sep-1991 11:16:42
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define   MAX_CX  640 // vga
#define   MAX_CY  480 // vga


// This is to create a bitmapinfo structure

#define DEFAULT_FACENAME "Tms Rmn"

#define CHAR_BUFFER_SIZE 80

PSZ apszFaceName[] =
{
  "Tms Rmn"
, "Helv"
, "Courier"
, "System"
// , "Terminal"
};

VOID TextTest(HDC hdc);
VOID vListCharWidths(HDC hdc);

HRGN hrgnCircle(LONG,LONG,LONG);

ULONG  cxSize(HDC hdc, LPSTR psz);
ULONG cBreak(char * psz);
VOID  vJustify(HDC hdc, int x, int y, char * ach, ULONG cxLen);
VOID  vJustify2(HDC hdc, int x, int y, char * psz1, char * psz2, ULONG cxLen);
VOID  vJustify3(HDC hdc, int x, int y, char * psz1, char * psz2, char * psz3, ULONG cxLen);
BOOL  bTextOut(HDC hdc, HFONT hfont, int x, int y, char * psz);



VOID DbgPOINT(LPPOINT ppt, char * psz)
{
    DbgPrint("%s , x: %ld, y: %ld \n", psz, (LONG)ppt->x, (LONG)ppt->y);
}

#define CX_LEN   ((ULONG)400)       // justify to this length



void  ErrorCodeTest(HDC hdc);



VOID vTestGenText(HWND hwnd, HDC hdc, RECT* prcl)
{
    hwnd; prcl;

    ErrorCodeTest(hdc);

    TextTest(hdc);
}

/******************************Public*Routine******************************\
*
*     ErrorCodeTest
*
* Effects:
*
* Warnings:
*
* History:
*  01-May-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




void  ErrorCodeTest(HDC hdcScreen)
{
    char * psz = "This is ExtTextOut error code test";
    DWORD  err;
    RECT   rc;

    rc.left = 0;     // arbitrary values
    rc.right = 100;
    rc.top   = 0;
    rc.bottom = 200;

// verify that retrieving error codes works properly:

   // SetBatchLimit(1);

    ExtTextOut (
                hdcScreen,
                10,20,
                ETO_CLIPPED,    // illegal to have null rect and nonzero flags
                (LPRECT)NULL,
                psz, strlen(psz),
                (LPINT)NULL);
    GdiFlush();
    err = GetLastError();
    DbgPrint ("ExtTextOut 1, Last error  = 0x%lx = %ld\n", err, err);


    ExtTextOut (
                hdcScreen,
                10,20,
                5,                        // invalid flag
                &rc,
                psz, strlen(psz),
                (LPINT)NULL);
    GdiFlush();
    err = GetLastError();
    DbgPrint ("ExtTextOut 2,  Last error  = 0x%lx = %ld\n", err, err);


    ExtTextOut (
                (HDC)0X33344455,               // INVALID HANDLE
                10,20,
                0,
                (LPRECT)NULL,
                psz, strlen(psz),
                (LPINT)NULL);
    GdiFlush();
    err = GetLastError();
    DbgPrint ("ExtTextOut 3, Last error = 0x%lx = %ld\n", err, err);


    SetTextAlign (hdcScreen,0x77777777);
    GdiFlush();
    err = GetLastError();
    DbgPrint ("SetTextAlign, Last error  = 0x%lx = %ld\n", err, err);



    AngleArc(hdcScreen,
             100,          // x
             200,          // y
             0XFFFFFFFF,   // overflows when converted to long        // radius
             (FLOAT)0,
             (FLOAT)30
             );
    GdiFlush();
    err = GetLastError();
    DbgPrint ("AngleArc, Last error = 0x%lx = %ld\n", err, err);

    vDoPause(0);
}




VOID TextTest(HDC hdc)
{

    LOGFONT lfnt;                  // dummy logical font description
    HFONT   hfont;                 // handle to dummy font
    HFONT   hfontUnderline,hfontStrikeOut;              // handle of font originally in DC
    HRGN    hrgnTmp;
    int     y;

#ifdef  DOS_PLATFORM
#define MAX_LENGTH  80
    char    aBuffer[MAX_LENGTH];
#endif  //DOS_PLATFORM

// Create a logical font

#ifndef DOS_PLATFORM
    memset(&lfnt, 0, sizeof(lfnt));
#else
    memzero(&lfnt, sizeof(lfnt));
#endif  //DOS_PLATFORM

    lfnt.lfHeight     = 24;
    lfnt.lfEscapement = 0; // mapper respects this filed
    lfnt.lfUnderline  = 0; // no underline
    lfnt.lfStrikeOut  = 0; // no strike out
    lfnt.lfItalic     = 0;
    lfnt.lfWeight     = 400; // normal

    strcpy(lfnt.lfFaceName, DEFAULT_FACENAME);

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return;
    }

    lfnt.lfUnderline  = 1; // underline

    if ((hfontUnderline = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return;
    }

    lfnt.lfUnderline  = 0; // underline
    lfnt.lfStrikeOut  = 1; // no underline

    if ((hfontStrikeOut = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return;
    }

// Select font into DC

    SelectObject(hdc, hfont);

// Set text alignment

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

//

// List the character widths

    vListCharWidths(hdc);
    vDoPause(0);

// Clear screen

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, BLACKNESS);

    SetTextColor(hdc, RGB(127,127,0));
    SetBkColor(hdc, RGB(0,255,0));

// nonclipped underlined text

// Select font into DC

    SelectObject(hdc, hfontUnderline);

    TextOut(hdc, 0, 0, "This is normal text.", 20);

    SelectObject(hdc, hfont);

// Inverse text

    BitBlt(hdc, 0, 30, MAX_CX, 30, (HDC) 0, 0, 0, WHITENESS);

    SetROP2(hdc, R2_BLACK);

    TextOut(hdc, 0, 30, "This is inverse text.", 21);

    SetROP2(hdc, R2_WHITE);

// Clipped text (simple retangular region)

    hrgnTmp = CreateRectRgn(10, 70, MAX_CX, 90);
    SelectClipRgn(hdc, hrgnTmp);
    DeleteObject(hrgnTmp);

    TextOut(hdc, 0, 60, "This is clipped text.", 21);

// Clipped text (circular region)

    hrgnTmp = hrgnCircle(150, 240, 150);
    SelectClipRgn(hdc, hrgnTmp);
    DeleteObject(hrgnTmp);

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

    SetROP2(hdc, R2_BLACK);

    SelectObject(hdc, hfontStrikeOut);
    TextOut(hdc, 0, 120, "There was a young man from Wight,", 33);
    TextOut(hdc, 0, 150, "Who travelled much faster then light.", 37);
    SelectObject(hdc, hfontUnderline);
    TextOut(hdc, 0, 180, "He left home one day", 20);
    TextOut(hdc, 0, 210, "In a relative way,", 18);
    TextOut(hdc, 0, 240, "And arrived home the previous night.", 36);

    hrgnTmp = CreateRectRgn(0, 0, MAX_CX, MAX_CY);
    SelectClipRgn(hdc, hrgnTmp);
    DeleteObject(hrgnTmp);


    SelectObject(hdc, hfont);
    SetTextColor(hdc, RGB(127,127,0));

    {
    // check that update current position mode works properly
        SIZE  size;
        POINT pt;
        PSZ   pszExtent;
        LOGFONT lfntEsc;
        HFONT   hfntOld, hfntEsc;

        vDoPause(0);

        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        y = 30;

        TextOut(hdc, 0, y  , "Once upon a time there was a young man from Wight,", strlen("Once upon a time there was a young man from Wight,"));
        y += 30;

        GetCurrentPositionEx(hdc,&pt);
        DbgPOINT(&pt,"before MoveToEx");

        SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_UPDATECP);

        MoveToEx(hdc, 0, y, &pt);

        GetCurrentPositionEx(hdc,&pt);
        DbgPOINT(&pt,"before " );

        TextOut(hdc, 0, 0 , "Once upon a time ", strlen("Once upon a time "));

        GetCurrentPositionEx(hdc,&pt);
        DbgPOINT(&pt,"after " );

        // change bk color to observe another textOut call
        SetBkColor(hdc, RGB(0,0,255));

        TextOut(hdc, 0, 0 , "there was a young man from Wight,", strlen("there was a young man from Wight,"));

        SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);
        SetBkColor(hdc, RGB(0,255,0));

    // get text extent test,

        pszExtent = "iiiiiiiiii";

        TextOut(hdc,200,100, pszExtent, strlen(pszExtent));
        GetTextExtentPoint(hdc, pszExtent, strlen(pszExtent), &size);
        DbgPrint("%s, cx = %ld, cy = %ld\n", pszExtent, size.cx, size.cy);

        pszExtent = "iiiiWWiiii";

        TextOut(hdc,200,150, pszExtent, strlen(pszExtent));
        GetTextExtentPoint(hdc, pszExtent, strlen(pszExtent), &size);
        DbgPrint("%s, cx = %ld, cy = %ld\n", pszExtent, size.cx, size.cy);

    // see whether text extent works with font with escapement

    // Create a logical font

    #ifndef DOS_PLATFORM
        memset(&lfntEsc, 0, sizeof(lfnt));
    #else
        memzero(&lfntEsc, sizeof(lfnt));
    #endif  //DOS_PLATFORM

        lfntEsc.lfHeight     = 18;
        lfntEsc.lfEscapement = 450; // 45 degrees
        lfntEsc.lfUnderline  = 0;   // no underline
        lfntEsc.lfStrikeOut  = 0;   // no strike out
        lfntEsc.lfItalic     = 0;
        lfntEsc.lfWeight     = 400; // normal

        if ((hfntEsc = CreateFontIndirect(&lfntEsc)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        hfntOld = SelectObject(hdc, hfntEsc);

        pszExtent = "iiiiiiiiii";

        TextOut(hdc,100,200, pszExtent, strlen(pszExtent));
        GetTextExtentPoint(hdc, pszExtent, strlen(pszExtent), &size);
        DbgPrint("%s, cx = %ld, cy = %ld\n", pszExtent, size.cx, size.cy);
        Rectangle(hdc,100,300,100 + size.cx,300 + size.cy);

        pszExtent = "iiiiWWiiii";

        TextOut(hdc,400,200, pszExtent, strlen(pszExtent));
        GetTextExtentPoint(hdc, pszExtent, strlen(pszExtent), &size);
        DbgPrint("%s, cx = %ld, cy = %ld\n", pszExtent, size.cx, size.cy);
        Rectangle(hdc,400,300,400 + size.cx,300 + size.cy);

        SelectObject(hdc, hfntOld);

    }

    {
    // test for emboldening and italicizing

        char ach[] = {0,1,2,4,32,88};

        HFONT  hfontBold, hfontItalic, hfontBoldItalic, hfontOld;
        char * pszString = "string";

        vDoPause(0);
        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        lfnt.lfStrikeOut = 0;
        lfnt.lfWeight = 700;        // bold

        if ((hfontBold = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfWeight = 400;        // normal
        lfnt.lfItalic = 1;

        if ((hfontItalic = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfWeight = 700;        // bold

        if ((hfontBoldItalic = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfWeight = 400;        // normal
        lfnt.lfItalic = 0;

    // trying a string of chars with couple of chars out of range of the font


        TextOut
        (
        hdc,
        40,
        40,
        "trying a string of chars with couple of chars out of range of the font",
        strlen("trying a string of chars with couple of chars out of range of the font")
        );

        TextOut(hdc, 80, 80, (LPSTR)ach, sizeof(ach));

        vDoPause(0);

        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        y = 40;
        TextOut(hdc, 0, y, "string" , strlen("string"));

        y += 40;
        bTextOut(hdc,hfontBold, 0, y, pszString);


        y += 40;
        bTextOut(hdc,hfontItalic, 0, y, pszString);


        y += 40;
        bTextOut(hdc,hfontBoldItalic, 0, y, pszString);

// couple of more strings, just for the fun of it

        y += 80;
        bTextOut(hdc,hfontItalic, 0, y, "These are funny italic strings:" );
        y += 40;
        bTextOut(hdc,hfontItalic,   0, y, "UuuuU" );
        bTextOut(hdc,hfontItalic, 100, y, "WvvvW" );
        bTextOut(hdc,hfontItalic, 200, y, "VvvvV" );
        bTextOut(hdc,hfontItalic, 300, y, "YyyyY" );
        bTextOut(hdc,hfontItalic, 400, y, " 2 break chars " );

        y += 80;
        bTextOut(hdc,hfontBoldItalic, 0, y, "These are silly bold italic strings:" );
        y += 40;
        bTextOut(hdc,hfontBoldItalic,   0, y, "UuuuU" );
        bTextOut(hdc,hfontBoldItalic, 100, y, "WvvvW" );
        bTextOut(hdc,hfontBoldItalic, 200, y, "VvvvV" );
        bTextOut(hdc,hfontBoldItalic, 300, y, "YyyyY" );
        bTextOut(hdc,hfontBoldItalic, 400, y, " 2 break chars " );

        DeleteObject(hfontBold);
        DeleteObject(hfontItalic);
        DeleteObject(hfontBoldItalic);
    }

    {
    // test fonts that are both emboldened and/or
    // italicized  and striked out and/or outlined

        HFONT  hfontBoldStrikeUnder,
               hfontItalicUnder,
               hfontBoldItalicUnder,
               hfontItalicStrike,
               hfontBoldItalicStrikeUnder;  // wow, what a font !!!

        char * pszString = "string";

        vDoPause(0);
        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        lfnt.lfItalic = 0;
        lfnt.lfWeight = 700;        // bold
        lfnt.lfStrikeOut = 1;
        lfnt.lfUnderline = 1;

        if ((hfontBoldStrikeUnder = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfItalic = 1;
        lfnt.lfWeight = 400;
        lfnt.lfStrikeOut = 0;
        lfnt.lfUnderline = 1;

        if ((hfontItalicUnder = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfItalic = 1;
        lfnt.lfWeight = 700;
        lfnt.lfStrikeOut = 0;
        lfnt.lfUnderline = 1;

        if ((hfontBoldItalicUnder = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfItalic = 1;
        lfnt.lfWeight = 400;
        lfnt.lfStrikeOut = 1;
        lfnt.lfUnderline = 0;

        if ((hfontItalicStrike = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

        lfnt.lfItalic = 1;
        lfnt.lfWeight = 700;
        lfnt.lfStrikeOut = 1;
        lfnt.lfUnderline = 1;

        if ((hfontBoldItalicStrikeUnder = CreateFontIndirect(&lfnt)) == NULL)
        {
            DbgPrint("Logical font creation failed.\n");
            return;
        }

    // "clear" logfont

        lfnt.lfItalic = 0;
        lfnt.lfWeight = 400;
        lfnt.lfStrikeOut = 0;
        lfnt.lfUnderline = 0;


        y = 40;
        bTextOut(hdc,hfont, 20, y, "Normal font : YYYYYY");

        y += 40;
        bTextOut(hdc,hfontBoldStrikeUnder, 20, y, "Bold Striked Out and Underlined font : YYYY");


        y += 40;
        bTextOut(hdc,hfontItalicUnder, 20, y, "Italicized Underlined font: YYYY");


        y += 40;
        bTextOut(hdc,hfontBoldItalicUnder, 20, y, "Underlined Bold Italic font :askpW");

        y += 40;
        bTextOut(hdc,hfontItalicStrike, 20, y, "Striked Out Italic font :askpW");

        y += 40;
        bTextOut(hdc,hfontBoldItalicStrikeUnder, 20, y, "Underlined and Striked Out Bold Italic font :askpW");

        DeleteObject(hfontBoldStrikeUnder);
        DeleteObject(hfontItalicUnder);
        DeleteObject(hfontBoldItalicUnder);
        DeleteObject(hfontItalicStrike);
        DeleteObject(hfontBoldItalicStrikeUnder);
    }



    {
    // check whether mapper can select different sizes from an *.fon file
    // and choose bold, italic and bold_italic fonts

        HFONT  hfontHt;

        short     alfHeight[6] = {13, 16, 19, 23, 27, 35};
        int       iHt;
        int       iName;
        PSZ       pszComment = "Trying to map to the face name: ";

        for (iName = 0; iName < sizeof(apszFaceName)/4; iName++)
        {
            #ifndef DOS_PLATFORM
                memset(&lfnt, 0, sizeof(lfnt));
            #else
                memzero(&lfnt, sizeof(lfnt));
            #endif  //DOS_PLATFORM
            strcpy(lfnt.lfFaceName, apszFaceName[iName]);

            vDoPause(0);
            BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

            lfnt.lfItalic = 0;
            lfnt.lfWeight = 400;
            lfnt.lfStrikeOut = 0;
            lfnt.lfUnderline = 0;

            SetTextAlign(hdc, TA_UPDATECP);
            MoveToEx(hdc,60,40,NULL);
            TextOut(hdc,0,0,pszComment, strlen(pszComment));
            TextOut(hdc, 0, 0,  apszFaceName[iName], strlen(apszFaceName[iName]));
            SetTextAlign(hdc, TA_NOUPDATECP);

            y = 80;

            for (iHt = 0L; iHt < 6L; iHt++)
            {
                lfnt.lfHeight = alfHeight[iHt];

                if ((hfontHt = CreateFontIndirect(&lfnt)) == NULL)
                {
                    DbgPrint("Logical font creation failed.\n");
                    return;
                }

                bTextOut(hdc,hfontHt, 20, y, "Normal: Different font sizes from an *.fon file");
                y += 40;
                DeleteObject(hfontHt);
            }

            vDoPause(0);
            BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

            SetTextAlign(hdc, TA_UPDATECP);
            MoveToEx(hdc,60,40,NULL);
            TextOut(hdc,0,0,pszComment, strlen(pszComment));
            TextOut(hdc, 0, 0,  apszFaceName[iName], strlen(apszFaceName[iName]));
            SetTextAlign(hdc, TA_NOUPDATECP);

            lfnt.lfItalic = 1;
            lfnt.lfWeight = 700;
            lfnt.lfStrikeOut = 0;
            lfnt.lfUnderline = 0;

            y = 80;

            for (iHt = 0L; iHt < 6L; iHt++)
            {
                lfnt.lfHeight = alfHeight[iHt];

                if ((hfontHt = CreateFontIndirect(&lfnt)) == NULL)
                {
                    DbgPrint("Logical font creation failed.\n");
                    return;
                }

                bTextOut(hdc,hfontHt, 20, y, "Bold Italic: Different font sizes from an *.fon file");
                y += 40;
                DeleteObject(hfontHt);
            }
        }
    }


    {
        vDoPause(0);

    // this part of the test tests the SetTextJustification functionality

        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        y = 30;

    // first print strings without justification to see how long they are

        TextOut(hdc, 0, y       , "There was a young man from Wight,", 33);      // 120
        TextOut(hdc, 0, y + 30  , "Who travelled much faster then light.", 37);  // 150
        TextOut(hdc, 0, y + 60  , "He left home one day", 20);                   // 180
        TextOut(hdc, 0, y + 90  , "In a relative way,", 18);                     // 210
        TextOut(hdc, 0, y + 120 , "And arrived home the previous night.", 36);   // 240

        y += 190;

    // coerce strings to have total length CX_LEN by addjusting spaces that
    // correspond to break chars

    // add more space to break chars (positive dda) (CX_LEN > text extent)

        vJustify(hdc, 0, y ,       "There was a young man from Wight,",    CX_LEN);      // 120
        vJustify(hdc, 0, y + 30  , "Who travelled much faster then light.",CX_LEN);  // 150
        vJustify(hdc, 0, y + 60  , "He left home one day",                 CX_LEN);                   // 180
        vJustify(hdc, 0, y + 90  , "In a relative way,",                   CX_LEN);                     // 210
        vJustify(hdc, 0, y + 120 , "And arrived home the previous night.", CX_LEN);   // 240
    }

    {
        vDoPause(0);

    // add more space to break chars (positive dda) (CX_LEN > text extent)

        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        y = 30;

    // first print strings without justification to see how long they are

        TextOut(hdc, 0, y       , "Once upon a time there was a young man from Wight,", strlen("Once upon a time there was a young man from Wight,"));
        TextOut(hdc, 0, y + 30  , "Who travelled much much much faster then light."   , strlen("Who travelled much much much faster then light."   ));
        TextOut(hdc, 0, y + 60  , "Nobody knows why he left home one day"             , strlen("Nobody knows why he left home one day"             ));                   // 180
        TextOut(hdc, 0, y + 90  , "Nor why he did it in a very relative way,"         , strlen("Nor why he did it in a very relative way,"         ));                     // 210
        TextOut(hdc, 0, y + 120 , "And arrived back home the previous night."         , strlen("And arrived back home the previous night."         ));

        y += 190;

        vJustify(hdc, 0, y ,       "Once upon a time there was a young man from Wight," ,CX_LEN);
        vJustify(hdc, 0, y + 30  , "Who travelled much much much faster then light."    ,CX_LEN);
        vJustify(hdc, 0, y + 60  , "Nobody knows why he left home one day"              ,CX_LEN);
        vJustify(hdc, 0, y + 90  , "Nor why he did it in a very relative way,"          ,CX_LEN);                     // 210
        vJustify(hdc, 0, y + 120 , "And arrived back home the previous night."          ,CX_LEN);

    }

    {

        vDoPause(0);

    // justifying two or more strings with a single set text justification

        BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

        y = 30;

        TextOut(hdc, 0, y  , "Once upon a time there was a young man from Wight,", strlen("Once upon a time there was a young man from Wight,"));
        y += 30;
        vJustify(hdc, 0, y , "Once upon a time there was a young man from Wight," ,CX_LEN);
        y += 30;
        vJustify2(hdc, 0, y , "Once upon a time there", " was a young man from Wight," ,CX_LEN);
        y += 30;
        vJustify3(hdc, 0, y , "Once upon a ti","me there was a young"," man from Wight," ,CX_LEN);
        y += 30;
        vJustify3(hdc, 0, y , "Once ","upon a time there was a young"," man from Wight," ,CX_LEN);
        y += 90;

    // this string is shorter than CX_LEN

        TextOut(hdc, 0, y , "There was a young man from Wight,", 33);      // 120
        y += 30;
        vJustify(hdc, 0, y , "There was a young man from Wight,",    CX_LEN);      // 120
        y += 30;
        vJustify2(hdc, 0, y , "There was a y","oung man from Wight,",    CX_LEN);      // 120
        y += 30;
        vJustify3(hdc, 0, y , "The","re was a young"," man from Wight,",    CX_LEN);      // 120
        y += 30;
        vJustify3(hdc, 0, y , "There wa","s a young"," man from Wight,",    CX_LEN);      // 120
    }
}

/******************************Public*Routine******************************\
* VOID vListCharWidths(HDC hdc)                                                *
*                                                                          *
* Prints out the character widths                                          *
*                                                                          *
* History:                                                                 *
*  Thu 07-Mar-1991 07:57:00 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID vListCharWidths(HDC hdc)
{
    int     aiCharWidth[256];
    POINT   pt;
    char    achBuffer[5];
    int     i,iRowSpacing,iWidthCol;
    ULONG   ulOldTextColor,ulOldBkColor;
    SIZE    szScreen;
    TEXTMETRIC tm;
    HBRUSH  hBrush,hBrushOld;

    hBrush = CreateSolidBrush(RGB(0,0,255));
    hBrushOld = SelectObject(hdc,hBrush);
    ulOldTextColor = SetTextColor(hdc,RGB(255,255,255));
    ulOldBkColor = SetBkColor(hdc,RGB(0,0,255));

    GetTextMetrics(hdc,(LPTEXTMETRIC) &tm);
    iRowSpacing = tm.tmHeight + tm.tmExternalLeading;

    szScreen.cx = GetDeviceCaps(hdc,HORZRES);
    szScreen.cy = GetDeviceCaps(hdc,VERTRES);

#define FIRST_CHAR tm.tmFirstChar

    GetCharWidth(hdc,FIRST_CHAR,tm.tmLastChar,aiCharWidth);

    BitBlt(hdc,
           0,
           0,
           szScreen.cx,
           szScreen.cy,
           (HDC) 0,
           0,
           0,
           PATCOPY);


    TextOut(hdc, 0, 0, "GLYPH WIDTH", 11);

// Calculate the width of the of a column

    for (i = 0, iWidthCol = 0; i < 10; i++)
        iWidthCol = max(iWidthCol,aiCharWidth['0' + i - FIRST_CHAR]);
    iWidthCol *= 2;
    iWidthCol += tm.tmMaxCharWidth;
    iWidthCol += 2 * aiCharWidth[' ' - FIRST_CHAR];

    achBuffer[1] = ' ';
    achBuffer[2] = ' ';

    i = 0;
    while (i < tm.tmLastChar - FIRST_CHAR + 1)
    {
        pt.x = 0;
        pt.y = 2*iRowSpacing;
        BitBlt(hdc,
               0,
               2*iRowSpacing,
               szScreen.cx,
               szScreen.cy-2*iRowSpacing,
               (HDC) 0,
               0,
               0,
               PATCOPY);
        while (
            i < tm.tmLastChar - FIRST_CHAR + 1 &&
            pt.x < szScreen.cx - iWidthCol)
        {
            int jTemp, iTemp;

            achBuffer[0] = (char) (i + FIRST_CHAR);
            iTemp = aiCharWidth[i]/10;
            jTemp = aiCharWidth[i] % 10;
            achBuffer[3] = iTemp == 0 ? (char)' ' : (char)('0' + iTemp);
            achBuffer[4] = (char)('0' + jTemp);

            TextOut(hdc,pt.x,pt.y,&achBuffer[0],1);
            TextOut(hdc,pt.x + tm.tmMaxCharWidth,pt.y,&achBuffer[1],4);
            i++;

            pt.y += iRowSpacing;
            if (pt.y > szScreen.cy - iRowSpacing)
            {
                pt.x += iWidthCol + 3*tm.tmMaxCharWidth;
                pt.y = 2*iRowSpacing;
            }
        }
    }
    ulOldTextColor = SetTextColor(hdc,ulOldTextColor);
    ulOldBkColor = SetBkColor(hdc,ulOldBkColor);
}


ULONG  cxSize(HDC hdc, LPSTR psz)
{
    SIZE size;
    BOOL bOk = GetTextExtentPoint(hdc, psz, strlen(psz), &size);
    if (!bOk)
        vDoPause(0);
    return(size.cx);
}

/******************************Public*Routine******************************\
*
* ULONG cBreak(char * psz)
*
*
* Effects: counts break chars in the string
*
* History:
*  10-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG cBreak(char * psz)
{
    ULONG c = 0L;
    ULONG i;
    for (i = 0; i < strlen(psz); i++)
    {
        if (psz[i] == 32)       // if break char
            c++;
    }
    return(c);
}

/******************************Public*Routine******************************\
*
* VOID vJustify(HDC hdc, int x, int y, char * ach, ULONG cxLen)
*
* coerces the string to have the length cxLen by adding or subtracting
* space from break chars
*
* History:
*  10-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vJustify(HDC hdc, int x, int y, char * ach, ULONG cxLen)
{
    ULONG cBrk = cBreak(ach);
    ULONG cx   = cxSize(hdc,ach);
    BOOL  bOk;

    // DbgPrint("cBrk = %ld, cxSize = %ld\n", cBrk, cx);

    bOk = SetTextJustification(hdc, (int)(cxLen - cx), cBrk);
    if(!bOk)
        vDoPause(0);

    bOk = TextOut(hdc, x, y, ach, strlen(ach));
    if(!bOk)
        vDoPause(0);

    bOk = SetTextJustification(hdc,0,0);
    if(!bOk)
        vDoPause(0);
}


/******************************Public*Routine******************************\
*
* VOID vJustify2(HDC hdc, int x, int y, char * psz1, char * psz2, ULONG cxLen)
*
* coerces the string to have the length cxLen by adding or subtracting
* space from break chars
*
* History:
*  10-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vJustify2(HDC hdc, int x, int y, char * psz1, char * psz2, ULONG cxLen)
{
    ULONG cBrk = cBreak(psz1) + cBreak(psz2);

    ULONG cx   = cxSize(hdc,psz1) + cxSize(hdc,psz2);

    BOOL  bOk;

    POINT pt;
    MoveToEx(hdc,x,y,&pt);

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_UPDATECP);

    // DbgPrint("cBrk = %ld, cxSize = %ld\n", cBrk, cx);

    bOk = SetTextJustification(hdc, (int)(cxLen - cx), cBrk);
    if(!bOk)
        vDoPause(0);

    bOk = TextOut(hdc, 0, 0, psz1, strlen(psz1));
    if(!bOk)
        vDoPause(0);

    // change bk color to observe which part of the string is written
    // by the second call

    SetBkColor(hdc, RGB(0,0,255));

    bOk = TextOut(hdc, 0, 0, psz2, strlen(psz2));
    if(!bOk)
        vDoPause(0);

    bOk = SetTextJustification(hdc,0,0);
    if(!bOk)
        vDoPause(0);

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

    SetBkColor(hdc, RGB(0,255,0));      // restore old color

}


VOID vJustify3(HDC hdc, int x, int y, char * psz1, char * psz2, char * psz3, ULONG cxLen)
{
    ULONG cBrk = cBreak(psz1) + cBreak(psz2) + cBreak(psz3);

    ULONG cx = cxSize(hdc,psz1) + cxSize(hdc,psz2) + cxSize(hdc,psz3);

    BOOL  bOk;

    POINT pt;
    MoveToEx(hdc,x,y,&pt);

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_UPDATECP);

    // DbgPrint("cBrk = %ld, cxSize = %ld\n", cBrk, cx);

    bOk = SetTextJustification(hdc, (int)(cxLen - cx), cBrk);
    if(!bOk)
        vDoPause(0);

    bOk = TextOut(hdc, 0, 0, psz1, strlen(psz1));
    if(!bOk)
        vDoPause(0);

    SetBkColor(hdc, RGB(0,0,255));

    bOk = TextOut(hdc, 0, 0, psz2, strlen(psz2));
    if(!bOk)
        vDoPause(0);

    SetBkColor(hdc, RGB(255,0,0));

    bOk = TextOut(hdc, 0, 0, psz3, strlen(psz3));
    if(!bOk)
        vDoPause(0);

    bOk = SetTextJustification(hdc,0,0);
    if(!bOk)
        vDoPause(0);

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);
    SetBkColor(hdc, RGB(0,255,0));
}



/******************************Public*Routine******************************\
*
* VOID  vTextOut(HDC hdc, HFONT hfont, int x, int y, char * psz)
* select font into dc and do text output at a given location
*
* Effects:
*
* Warnings:
*
* History:
*  30-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL bTextOut(HDC hdc, HFONT hfont, int x, int y, char * psz)
{
    HFONT hfontOld;
    BOOL bOk;

    hfontOld = SelectObject(hdc, hfont);
    bOk = TextOut(hdc,x,y,psz,strlen(psz));
    SelectObject(hdc, hfontOld);
    return(bOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftjnl.c ===
/******************************Module*Header*******************************\
* Module Name: ftjnl.c
*
* (Brief description)
*
* Created: 20-Feb-1992 08:41:04
* Author:  - by - Eric Kutter [erick]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


VOID vStressDIBBrushes(HDC hdc, ULONG flDIB, ULONG ulY);

VOID vPage1(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage2(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage3(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage4(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage5(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage6(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage0F(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage1F(HWND hwnd, HDC hdc, RECT* prcl);
VOID vPage2F(HWND hwnd, HDC hdc, RECT* prcl);
VOID vScreenToPage(HWND hwnd, HDC hdc, RECT* prcl);

PFN_FT_TEST ajf[] =
{
   vPage1,
   vPage2,
   vPage3,
//   vScreenToPage

#if 0
   vTestBitmap,
   vTestBlting,
   vTestBrush,
   vTestColor,

   vTestBMText,
   vTestDIB,
   vTestFilling,
   vTestFonts,
   vTestLines,
   vTestPalettes,
   vTestPlgBlt,
   vTestMapping,
   vTestRegion,
   vTestStretch,
#endif

   vPage0F,
   vPage1F,
   vPage2F
};

#define CPAGES	(sizeof(ajf) / sizeof(PFN_FT_TEST))

#if 0
#define DBGMSG OutputDebugString
#else
#define DBGMSG DbgPrint
#endif

ULONG gy;
ULONG cFonts;

/******************************Public*Routine******************************\
*
*
*
* History:
*  20-Feb-1992 -by-  - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vTestJournaling(HWND hwnd, HDC hdcDisp, RECT *prcl)
{
    PRINTDLG pd;
    HDC hdc;
    CHAR achBuf[80];
    INT i;
    LPDEVMODE lpDevMode;
    LPDEVNAMES lpDevNames;
    DOCINFO    di;

    di.cbSize = sizeof(di);
    di.lpszDocName  = NULL;
    di.lpszOutput   = NULL;
    di.lpszDatatype = NULL;
    di.fwType       = 0;

    memset(&pd,0,sizeof(pd));

    pd.lStructSize = sizeof(pd);
    pd.hwndOwner   = hwnd;
    pd.hDevMode    = NULL;
    pd.hDevNames   = NULL;
    pd.hDC         = NULL;
    pd.Flags       = PD_RETURNDC | PD_PAGENUMS;
    pd.nCopies     = 1;
    pd.nFromPage   = 1;
    pd.nToPage     = CPAGES;
    pd.nMinPage    = 1;
    pd.nMaxPage    = CPAGES;

#if 1
    PrintDlg(&pd);
#endif

//!!! HACK-O-RAMA

    if (pd.hDC == NULL)
    {
        DBGMSG("doing it the hard way\n");

        if(!pd.hDevNames){ /* Retrieve default printer if none selected. */
            //pd.Flags = PD_RETURNDEFAULT|PD_PRINTSETUP;
            pd.Flags = PD_PRINTSETUP;
            if (!PrintDlg(&pd))
                return;
        }

        if(!pd.hDevNames){ /* Retrieve default printer if none selected. */
            pd.Flags = PD_RETURNDEFAULT|PD_PRINTSETUP;
            //pd.Flags = PRINTSETUP;
            if (!PrintDlg(&pd))
                return;
        }

        if (!pd.hDevNames)
        {
            DBGMSG("bad hDevNames\n");
            return;
        }

        lpDevNames  = (LPDEVNAMES)GlobalLock(pd.hDevNames);

        if (pd.hDevMode)
            lpDevMode = (LPDEVMODE)GlobalLock(pd.hDevMode);
        else
            lpDevMode = NULL;

        /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
         *  will be NULL after GlobalLock()
         */

        pd.hDC = CreateDC((LPSTR)lpDevNames+lpDevNames->wDriverOffset,
                               (LPSTR)lpDevNames+lpDevNames->wDeviceOffset,
                               (LPSTR)lpDevNames+lpDevNames->wOutputOffset,
                               lpDevMode);
        GlobalUnlock(pd.hDevNames);

        if (pd.hDevMode)
            GlobalUnlock(pd.hDevMode);
    }
    hdc = pd.hDC;

    DbgPrint("Ft-vTestJournaling has hdc %lx \n", hdc);

    if (hdc == NULL)
    {
        DBGMSG("couldn't create DC\n");
	return;
    }

{
    ULONG ulX,ulY;
    HDC hdcTemp;
    HBITMAP hbmTemp, hbmDefault;

    RECT rclPage;
    rclPage.left = 0;
    rclPage.top = 0;

    hdcTemp = CreateCompatibleDC(hdc);
    GdiSetBatchLimit(1);

    if (!StartDoc(hdc,&di))
        DBGMSG("StartDoc failed in print\n");

    for (i = pd.nFromPage; i <= pd.nToPage; ++i)
    {
    // print the document, We print to a compatible bitmap every page
    // before we print the page to see how it looks on the screen.

	DbgPrint("Ft-vTestJournaling In print loop %lu \n", i);

	if (!StartPage(hdc))
	    DBGMSG("StartPage failed\n");

	ulX = GetDeviceCaps(hdc, HORZRES);
	ulY = GetDeviceCaps(hdc, VERTRES);

	DbgPrint("Ft-vTestJournaling This is the size of the printer %lu %lu \n", ulX, ulY);

	hbmTemp = CreateCompatibleBitmap(hdc, ulX, ulY);

	if (hbmTemp == (HBITMAP) 0)
	{
	    DbgPrint("Ft-vTestJournaling failed hbmTemp creation\n");
	}

	hbmDefault = SelectObject(hdcTemp, hbmTemp);

	rclPage.right = GetDeviceCaps(hdcDisp, HORZRES);
	rclPage.bottom = GetDeviceCaps(hdcDisp, VERTRES);

    // This is total hack-or-rama.  We pass the ScreenDC into the function
    // so we can use it also.

	(*ajf[i-1])((HWND) hdcDisp, hdcDisp, &rclPage);

	if (!BitBlt(hdcDisp, 0, 0, ulX, ulY, hdcTemp, 0, 0, SRCCOPY))
	{
	    DbgPrint("Ft-vTestJournaling failed BitBlt of Bm to scrn\n");
	}

	SelectObject(hdcTemp, hbmDefault);
	DeleteObject(hbmTemp);

	rclPage.right = GetDeviceCaps(hdc, HORZRES);
	rclPage.bottom = GetDeviceCaps(hdc, VERTRES);

	(*ajf[i-1])((HWND) hdcDisp, hdc, &rclPage);

	if (!EndPage(hdc))
	    DBGMSG("EndPage failed\n");

    }

    EndDoc(hdc);

    DeleteDC(hdcTemp);
}
    DeleteDC(hdc);

    GlobalFree(pd.hDevNames);
    GlobalFree(pd.hDevMode);

    return;
}

/******************************Public*Routine******************************\
* vScreenToPage
*
* Test blting screen to page.
*
* History:
*  Sat 26-Sep-1992 -by- Patrick Haluptzok [patrickh]
* Wrote it.
\**************************************************************************/

VOID vScreenToPage(HWND hwnd, HDC hdc, RECT* prcl)
{
    HDC hdcScreen;
    RECT rclPage;

    hdcScreen = (HDC) hwnd;

    if (!BitBlt(hdc, 0, 0, 1000, 1000, hdcScreen, 0, 0, SRCCOPY))
    {
	DbgPrint("BitBlt Screen to Page failed\n");
    }

    rclPage = *prcl;
    hwnd;
}

/******************************Public*Routine******************************\
* vPage1
*
* Test Brushes.
*
* History:
*  01-Apr-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vPage1(HWND hwnd, HDC hdc, RECT* prcl)
{
    HBRUSH hbrR,hbrG,hbrB,hbrPat,hbrTemp,hbrDefault;
    HBITMAP hbm,hbmDefault,hbmN;
    HDC hdcM,hdcN;
    ULONG ulTemp;
    RECT rclPage;

    rclPage = *prcl;
    hwnd;

    DbgPrint("Printing Page 1 %lx\n", hdc);

    hbrR = CreateSolidBrush(RGB(0xFF,0,0));
    hbrG = CreateSolidBrush(RGB(0,0xFF,0));
    hbrB = CreateSolidBrush(RGB(0,0,0xFF));

// Simple solid color PatBlt test

    hbrDefault = SelectObject(hdc, hbrR);

    if (!PatBlt(hdc,10,10,20,20,PATCOPY))
	DBGMSG("Failed page 1 patblt\n");

// A hatch brush.

    for (ulTemp = 0; ulTemp < 19; ulTemp++)
    {
	hbrTemp = CreateHatchBrush(ulTemp, RGB(0xFF, 0, 0));

	if (hbrTemp == (HBRUSH) 0)
	{
	    DbgPrint("vPage1 solid dither brush creation failed\n");
	    return;
	}

	hbrDefault = SelectObject(hdc, hbrTemp);

	PatBlt(hdc, ulTemp * 50, 100, 50, 100, PATCOPY);

	SelectObject(hdc,hbrDefault);

	DeleteObject(hbrTemp);
    }

// A little dithering with solid brushes.

    for (ulTemp = 0; ulTemp < 8; ulTemp++)
    {
	hbrTemp = CreateSolidBrush(RGB((ulTemp * 32), 255, 255));

	if (hbrTemp == (HBRUSH) 0)
	{
	    DbgPrint("vPage1 solid dither brush creation failed\n");
	    return;
	}

	hbrDefault = SelectObject(hdc, hbrTemp);

	PatBlt(hdc, ulTemp * 50, 200, 50, 100, PATCOPY);

	SelectObject(hdc,hbrDefault);

	DeleteObject(hbrTemp);
    }

// A pattern brush.

    hbm = CreateCompatibleBitmap(hdc, 30, 30);
    hdcM = CreateCompatibleDC(hdc);

    SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 10, 30, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 10, 0, 10, 30, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 20, 0, 10, 30, PATCOPY);

    hbrPat = CreatePatternBrush(hbm);

    if (hbrPat == (HBRUSH) 0)
    {
	DbgPrint("vPage1 failed pattern brush creation\n");
	return;
    }

    SelectObject(hdc, hbrPat);
    PatBlt(hdc, 0, 300, 200, 100, PATCOPY);

    DeleteDC(hdcM);
    DeleteObject(hbm);

// A DIB brush

    vStressDIBBrushes(hdc, DIB_PAL_COLORS, 400);
    vStressDIBBrushes(hdc, DIB_PAL_INDICES, 500);

// Clean up time.

    SelectObject(hdc, hbrDefault);
    DeleteObject(hbrPat);
    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
}

/******************************Public*Routine******************************\
* vPage2
*
* Test Blting - all formats to printer.
*
* History:
*  01-Apr-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define FUNKY_ROP 0xAACC0000

VOID vPage2(HWND hwnd, HDC hdc, RECT* prcl)
{
    HBRUSH hbrR,hbrG,hbrB,hbrDefault;
    HBITMAP hbm,hbmDefault,hbmN,hbmMask;
    HDC hdcM,hdcN;
    POINT aPoint[4];
    RECT rclPage;
    COLORREF crTxt, crBack;
    POINT aPointStar[5] = {{50,0},{75,100},{0,35},{100,35},{25,100}};

    rclPage = *prcl;
    hwnd;

    DbgPrint("Printing Page 2 %lx\n", hdc);

    hbrR = CreateSolidBrush(RGB(0xFF,0,0));
    hbrG = CreateSolidBrush(RGB(0,0xFF,0));
    hbrB = CreateSolidBrush(RGB(0,0,0xFF));

// Simple solid color PatBlt test

    hbrDefault = SelectObject(hdc, hbrR);
    hdcM = CreateCompatibleDC(hdc);
    hdcN = CreateCompatibleDC(hdc);

// Set up STAR mask in hbm1

    hbmMask  = CreateBitmap(100,100,1,1,NULL);
    hbmDefault = SelectObject(hdcM, hbmMask);
    PatBlt(hdcM, 0, 0, 100, 100, BLACKNESS);
    SelectObject(hdcM, GetStockObject(WHITE_BRUSH));
    Polygon(hdcM, aPointStar,5);
    BitBlt(hdc,840,0,100,100,hdcM,0,0,SRCCOPY);
    SelectObject(hdcM, hbmDefault);

// Source blting test - identity.

    hbm  = CreateCompatibleBitmap(hdc, 100, 100);
    hbmDefault = SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    BitBlt(hdc, 40, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    MaskBlt(hdc, 40, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

// Source blting test - 1/pel Src

    hbm  = CreateBitmap(100, 100, 1, 1, NULL);
    SelectObject(hdcM, hbm);
    PatBlt(hdcM, 0, 0, 100, 100, BLACKNESS);
    PatBlt(hdcM, 20, 20, 60, 60, WHITENESS);
    crTxt  = SetTextColor(hdc,RGB(0xFF,0,0));
    crBack = SetBkColor(hdc,RGB(0,0,0xFF));
    BitBlt(hdc, 140, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    MaskBlt(hdc, 140, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

// Source blting test - 4/pel Src

    hbm  = CreateBitmap(100, 100, 1, 4, NULL);
    SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    BitBlt(hdc, 240, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    MaskBlt(hdc, 240, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

// Source blting test - 8/pel Src

    hbm  = CreateBitmap(100, 100, 1, 8, NULL);
    SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    BitBlt(hdc, 340, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    MaskBlt(hdc, 340, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

// Source blting test - 24/pel Src

    hbm  = CreateBitmap(100, 100, 1, 24, NULL);
    SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    BitBlt(hdc, 440, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    MaskBlt(hdc, 440, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

// Source blting test - 32/pel Src

    hbm  = CreateBitmap(100, 100, 1, 32, NULL);
    SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    BitBlt(hdc, 540, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    MaskBlt(hdc, 540, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);

// Source blting test - 32/pel Src

    hbmN  = CreateBitmap(100, 100, 1, 32, NULL);
    SelectObject(hdcN, hbmN);
    BitBlt(hdcN, 0, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    BitBlt(hdc, 640, 0, 100, 100, hdcN, 0, 0, SRCCOPY);
    MaskBlt(hdc, 640, 100, 100, 100, hdcN, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcN, hbmDefault);
    DeleteObject(hbmN);

    hbmN = CreateCompatibleBitmap(hdcM, 100, 100);
    SelectObject(hdcN, hbmN);
    BitBlt(hdcN, 0, 0, 100, 100, hdcM, 0, 0, SRCCOPY);
    BitBlt(hdc, 740, 0, 100, 100, hdcN, 0, 0, SRCCOPY);
    MaskBlt(hdc, 740, 100, 100, 100, hdcM, 0, 0, hbmMask, 0, 0, FUNKY_ROP);
    SelectObject(hdcN, hbmDefault);
    DeleteObject(hbmN);

// Printer to Printer BitBlt,StrchBlt,PlgBlt.

    BitBlt(hdc, 40, 200, 100, 100, hdc, 40, 0, SRCCOPY);

    StretchBlt(hdc, 140, 200, 200, 200, hdc, 40, 0, 100, 100, SRCCOPY);

    aPoint[0].x = 0;
    aPoint[0].y = 100;

    aPoint[1].x = 100;
    aPoint[1].y = 0;

    aPoint[2].x = 100;
    aPoint[2].y = 200;

    aPoint[3].x = 200;
    aPoint[3].y = 100;

    aPoint[0].y += 300;
    aPoint[1].y += 300;
    aPoint[2].y += 300;
    aPoint[3].y += 300;
    aPoint[0].x += 300;
    aPoint[1].x += 300;
    aPoint[2].x += 300;
    aPoint[3].x += 300;

    PlgBlt(hdc, aPoint, hdc, 40, 0, 100, 100, (HBITMAP) 0, 0, 0);

    SetTextColor(hdc,crTxt);
    SetBkColor(hdc,crBack);

    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);
    DeleteDC(hdcN);
    DeleteDC(hdcM);

// Clean up time.

    SelectObject(hdc, hbrDefault);
    DeleteObject(hbmMask);
    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
}

/******************************Public*Routine******************************\
* vPage3
*
* Test PlgBlt and StretchBlt.
*
* History:
*  01-Apr-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vPage3(HWND hwnd, HDC hdc, RECT* prcl)
{
    HBRUSH hbrR,hbrG,hbrB,hbrDefault;
    HBITMAP hbm,hbmDefault;
    HDC hdcM,hdcN;
    ULONG ulTemp;
    RECT rclPage;

    rclPage = *prcl;
    hwnd;

    DbgPrint("Printing Page 3 %lx\n", hdc);

    hbrR = CreateSolidBrush(RGB(0xFF,0,0));
    hbrG = CreateSolidBrush(RGB(0,0xFF,0));
    hbrB = CreateSolidBrush(RGB(0,0,0xFF));

// Simple solid color PatBlt test

    hbrDefault = SelectObject(hdc, hbrR);

    if (!PatBlt(hdc,10,10,20,20,PATCOPY))
	DBGMSG("Failed page 1 patblt\n");

    hdcM = CreateCompatibleDC(hdc);

    vTestPlg1(hdc);

// StretchBlt Test Code.

// Stretch blting test - 4/pel Src

    hbm  = CreateBitmap(100, 100, 1, 4, NULL);
    hbmDefault = SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    StretchBlt(hdc, 0, 400, 200, 200, hdcM, 0, 0, 100, 100, SRCCOPY);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

// Stretch blting test - 8/pel Src

    hbm  = CreateBitmap(100, 100, 1, 8, NULL);
    SelectObject(hdcM, hbm);
    SelectObject(hdcM, hbrR);
    PatBlt(hdcM, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcM, hbrB);
    PatBlt(hdcM, 20, 20, 60, 60, PATCOPY);
    SelectObject(hdcM, hbrG);
    PatBlt(hdcM, 40, 40, 20, 20, PATCOPY);
    StretchBlt(hdc, 0, 400, 50, 50, hdcM, 0, 0, 100, 100, SRCCOPY);
    SelectObject(hdcM, hbmDefault);
    DeleteObject(hbm);

    DeleteDC(hdcM);

    SelectObject(hdc, hbrDefault);

    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
}

/******************************Public*Routine******************************\
*
* Test for Eric's print stuff, go crazy write big and all over the page
* because he's got a laser jet that cranks out the pages.
*
* History:
*  20-Feb-1992 -by-  - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG iJnlPrintFont (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc)
{
    int iRet = TRUE;
    HFONT hfnt;

    ++cFonts;

    if (cFonts & 3)
        return(TRUE);

    if (cFonts > 25)
        return(0);

    if (gy > 3000)
        return(0);

    if ((hfnt = CreateFontIndirect(plf)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return(0);
    }

    hfnt = SelectObject(*phdc,hfnt);
    TextOut(*phdc,1200,gy,"ABCDEFGHIJKLMNOPQRSTUVWXYZ",26);
    gy += ptm->tmHeight+ptm->tmExternalLeading;
    hfnt = SelectObject(*phdc,hfnt);

    DeleteObject(hfnt);

    return(iRet);
    ptm;
    flType;
}


ULONG iJnlEnumFace (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc)
{
    int iRet;

    iRet = EnumFonts (
                *phdc,
                (LPSTR) (plf->lfFaceName),
                (FONTENUMPROCA) iJnlPrintFont,
		(LPARAM) phdc
                );

    return(iRet);
    ptm;
    flType;
}

VOID vJnlEnumFonts(HDC hdc)
{
    gy = 100;
    cFonts = 0;
    EnumFonts (
        hdc,
        (LPSTR) NULL,
        (FONTENUMPROCA) iJnlEnumFace,
	(LPARAM) &hdc
        );
}

ULONG gulHorzBand = 1;
ULONG gulVertBand = 1;

VOID vPage0F(HWND hwnd, HDC hdc, RECT* prcl)
{
    INT x,y;
    HFONT hfnt;
    HBRUSH hbrush;

    RECT rclPage;

    rclPage = *prcl;
    hwnd;
    DbgPrint("Printing Page 0F %lx\n", hdc);

    TextOut(hdc,100,50,"Page 0F",7);

// draw the clip area

    hbrush = SelectObject(hdc,GetStockObject(NULL_BRUSH));
    Rectangle(hdc,0,0,2301,3101);
    Rectangle(hdc,400,400,2000,2900);
    Rectangle(hdc,599,599,1801,2701);
    SelectObject(hdc,hbrush);

    for (x = 0; x < 2400; x += (2400 / gulHorzBand))
    {
        MoveToEx(hdc,x,0,NULL);
        LineTo(hdc,x,3150);
    }
    for (y = 0; y < 3150; y += (3150 / gulVertBand))
    {
        MoveToEx(hdc,0,y,NULL);
        LineTo(hdc,2400,y);
    }
}

/**************************************************************************\
 *
\**************************************************************************/

VOID vPage1F(HWND hwnd, HDC hdc, RECT* prcl)
{
    INT y;
    HFONT hfnt;
    HRGN hrgn1, hrgn2;
    HBRUSH hbrush;
    int xsz,ysz;

    prcl;
    hwnd;

    DbgPrint("Printing Page 1F %lx\n", hdc);

    xsz = GetDeviceCaps(hdc,HORZRES) - 1;
    ysz = GetDeviceCaps(hdc,VERTRES) - 1;

    TextOut(hdc,100,50,"Page 1F",7);

// draw the clip area

#if 1
    hbrush = SelectObject(hdc,GetStockObject(NULL_BRUSH));
    Rectangle(hdc,0,0,xsz,ysz);
    Rectangle(hdc,400,400,xsz-400,ysz-400);
    Rectangle(hdc,599,599,xsz-599,ysz-599);
    SelectObject(hdc,hbrush);
#endif

// setup the clip region

#if 1
    hrgn1 = CreateRectRgn(0,0,xsz,ysz);
    hrgn2 = CreateRectRgn(400,400,xsz-400,ysz-400);
    CombineRgn(hrgn1,hrgn1,hrgn2,RGN_DIFF);
    DeleteObject(hrgn2);
    hrgn2 = CreateRectRgn(600,600,xsz-600,ysz-600);
    CombineRgn(hrgn1,hrgn1,hrgn2,RGN_OR);
    DeleteObject(hrgn2);
    SelectClipRgn(hdc,hrgn1);
    DeleteObject(hrgn1);
#endif

// create the font

    hfnt = CreateFont(300,      // height
                      200,      // width
                      0,        // escapement
                      0,        // orientation
                      400,      // weight
                      FALSE,    // italic
                      FALSE,    // underline
                      FALSE,    // strikeout
                      OEM_CHARSET,
                      OUT_DEFAULT_PRECIS,
                      CLIP_DEFAULT_PRECIS,
                      DEFAULT_QUALITY,
                      VARIABLE_PITCH | FF_DONTCARE,
                      NULL);

    if (hfnt == NULL)
    {
        DbgPrint("hfnt == NULL\n");
        return;
    }

    hfnt = SelectObject(hdc,hfnt);

    hbrush = CreateHatchBrush(HS_CROSS,0);
    hbrush = SelectObject(hdc,hbrush);

    y = 100;
    for (y = 100; y < ysz; y += 300)
        TextOut(hdc,10,y,"TEXT",4);

    hbrush = SelectObject(hdc,hbrush);
    DeleteObject(hbrush);

    hfnt = SelectObject(hdc,hfnt);
    DeleteObject(hfnt);

    vJnlEnumFonts(hdc);

    SelectClipRgn(hdc,NULL);
}

/**************************************************************************\
 *
\**************************************************************************/

VOID vPage2F(HWND hwnd, HDC hdc, RECT* prcl)
{
    HBRUSH hbrush;
    HPEN   hpen;
    HRGN hrgn1, hrgn2;

    RECT rclPage;

    rclPage = *prcl;
    hwnd;

    DbgPrint("Printing Page 2F %lx\n", hdc);

    TextOut(hdc,100,50,"Page 2F",7);

// setup the clip region

    hrgn1 = CreateRectRgn(0,0,2300,3100);
    hrgn2 = CreateRectRgn(300,300,2000,2800);
    CombineRgn(hrgn1,hrgn1,hrgn2,RGN_DIFF);
    DeleteObject(hrgn2);
    hrgn2 = CreateRectRgn(500,500,1800,2600);
    CombineRgn(hrgn1,hrgn1,hrgn2,RGN_OR);
    DeleteObject(hrgn2);
    SelectClipRgn(hdc,hrgn1);
    DeleteObject(hrgn1);

// rectangle

//    hbrush = CreateHatchBrush(HS_HORIZONTAL,0);
//    hbrush = SelectObject(hdc,hbrush);
    hbrush = SelectObject(hdc,GetStockObject(NULL_BRUSH));
    Rectangle(hdc,0,0,2300,3100);
    hbrush = SelectObject(hdc,hbrush);
//    DeleteObject(hbrush);

// ellipse

    hbrush = CreateHatchBrush(HS_CROSS,0);
    hbrush = SelectObject(hdc,hbrush);
    Ellipse(hdc,0,0,2300,3100);
    hbrush = SelectObject(hdc,hbrush);
    DeleteObject(hbrush);

// ellipse

    hpen = CreatePen(PS_SOLID,100,0);
    hpen = SelectObject(hdc,hpen);

//    hbrush = CreateHatchBrush(HS_VERTICAL,0);
//    hbrush = SelectObject(hdc,hbrush);
    hbrush = SelectObject(hdc,GetStockObject(NULL_BRUSH));
    Ellipse(hdc,500,800,1800,2400);
    hbrush = SelectObject(hdc,hbrush);
//    DeleteObject(hbrush);

    hpen = SelectObject(hdc,hpen);
    DeleteObject(hpen);

    SelectClipRgn(hdc,NULL);
}

/******************************Public*Routine******************************\
* vStressDIBBrushes
*
* Test CreateDIBPatternBrush, see if it works for DIB_PAL_COLORS,
* DIB_
*
* History:
*  08-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFOPATI
{
    BITMAPINFOHEADER                 bmiHeader;
    SHORT			     bmiColors[16];
    DWORD			     dw[16];
} BITMAPINFOPATI;

BITMAPINFOPATI bmi566 =
{
    {
	sizeof(BITMAPINFOHEADER),
	8,
	8,
	1,
	4,
	BI_RGB,
	32, // 64,
	0,
	0,
	16,
	16
    },

    { 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 },
    {
	0x33333333,
	0x33333333,
	0x33333333,
	0x33333333,
	0x44444444,
	0x44444444,
	0x44444444,
	0x44444444
    }
};

VOID vStressDIBBrushes(HDC hdc, ULONG flDIB, ULONG ulY)
{
    HBRUSH hbrDefault, hbrDIB;
    HDC hdc4;
    HBITMAP hbm4;

    hbrDIB = CreateDIBPatternBrushPt(&bmi566, flDIB);

    if (hbrDIB == (HBRUSH) 0)
    {
	DbgPrint("vStressDIBBrushes failed to CreateDIBPatternBrush\n");
	return;
    }

    hdc4 = CreateCompatibleDC(hdc);
    hbm4 = CreateCompatibleBitmap(hdc, 200, 100);
    SelectObject(hdc4, hbm4);

    hbrDefault = SelectObject(hdc4, hbrDIB);
    SelectObject(hdc, hbrDIB);

    PatBlt(hdc, 0, ulY, 200, 100, PATCOPY);
    PatBlt(hdc4, 0, 0, 200, 100, PATCOPY);
    BitBlt(hdc, 200, ulY, 200, 100, hdc4, 0, 0, SRCCOPY);

    SelectObject(hdc, hbrDefault);
    SelectObject(hdc4, hbrDefault);

    DeleteDC(hdc4);
    DeleteObject(hbrDIB);
    DeleteObject(hbm4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftlines.c ===
/******************************Module*Header*******************************\
* Module Name: ftline.c
*
* Line tests
*
* Created: 26-May-1991 13:07:35
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <time.h>

#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define ABS(x)    ((x) >= 0 ? (x) : -(x))

RECT  grclLine;
HDC   ghdcLine;
INT   giSeed;

// DIB brush:

extern BITMAPINFO bmiPat;
extern BYTE       abBitCat[];

VOID vDoLines(HPEN hpen)
{
    POINT aptl[3];
    HPEN  hpenOld;

    if (!BitBlt(ghdcLine, grclLine.left, grclLine.top,
                          grclLine.right, grclLine.bottom,
                          (HDC) 0, 0, 0, BLACKNESS))
        DbgPrint("1 ERROR: BitBlt returned FALSE\n");

    hpenOld = SelectObject(ghdcLine, hpen);
    if (hpenOld == (HPEN) 0)
        DbgPrint("2 ERROR: SelectObject returned 0\n");

    if (!BeginPath(ghdcLine))
        DbgPrint("3 ERROR: BeginPath returned FALSE\n");

    if (!MoveToEx(ghdcLine, 50, 50, (LPPOINT) NULL))
        DbgPrint("4 ERROR: MoveTo returned FALSE\n");

    if (!LineTo(ghdcLine, 50, 300))
        DbgPrint("5 ERROR: LineTo returned FALSE\n");

    if (!LineTo(ghdcLine, 300, 300))
        DbgPrint("6 ERROR: LineTo returned FALSE\n");

    aptl[0].x = 300;
    aptl[0].y = 200;
    aptl[1].x = 200;
    aptl[1].y = 50;
    aptl[2].x = 100;
    aptl[2].y = 50;

    if (!PolyBezierTo(ghdcLine, aptl, 3))
        DbgPrint("7 ERROR: PolyBezierTo returned FALSE\n");

    if (!EndPath(ghdcLine))
        DbgPrint("8 ERROR: EndPath returned FALSE\n");

    if (!StrokePath(ghdcLine))
        DbgPrint("9 ERROR: StrokePath returned FALSE\n");

    SelectObject(ghdcLine, hpenOld);
}

typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD			     bmiColors[16];
    DWORD			     dw[8];
} BITMAPINFOPAT;

BITMAPINFOPAT bmi =
{
    {
	sizeof(BITMAPINFOHEADER),
	8,
	8,
	1,
	4,
	BI_RGB,
	32,
	0,
	0,
	16,
	16
    },

    {				    // B    G	 R
	{ 0,   0,   0,	 0 },	    // 0
	{ 0,   0,   0x80,0 },	    // 1
	{ 0,   0x80,0,	 0 },	    // 2
	{ 0,   0x80,0x80,0 },	    // 3
	{ 0x80,0,   0,	 0 },	    // 4
	{ 0x80,0,   0x80,0 },	    // 5
	{ 0x80,0x80,0,	 0 },	    // 6
	{ 0x80,0x80,0x80,0 },	    // 7
	{ 0xC0,0xC0,0xC0,0 },	    // 8
	{ 0,   0,   0xFF,0 },	    // 9
	{ 0,   0xFF,0,	 0 },	    // 10
	{ 0,   0xFF,0xFF,0 },	    // 11
	{ 0xFF,0,   0,	 0 },	    // 12
	{ 0xFF,0,   0xFF,0 },	    // 13
	{ 0xFF,0xFF,0,	 0 },	    // 14
	{ 0xFF,0xFF,0xFF,0 }	    // 15
    },

    {
	0xAAAAAAAA,
	0xAAAAAAAA,
	0xAACCCCCC,
	0xAACCCCCC,
	0xAACCCCCC,
	0xCCCCCCCC,
	0xCCCCCCCC,
	0xAAAAAAAA
    }
};

VOID vDoABunch(HDC hdc)
{
    HPEN     hpen;
    LOGBRUSH lb;
    LOGBRUSH lbSolid = { BS_SOLID, RGB(255, 0, 0), 0 };
    HBITMAP  hbmCat;
    DWORD    aul[20];
    BITMAPINFOPAT* pbmi;
    HANDLE   h;

// Hatched extended pen:

    lb.lbStyle = BS_HATCHED;
    lb.lbColor = RGB(0, 0, 255);
    lb.lbHatch = HS_CROSS;
    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lb, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("10 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("11 ERROR: DeleteObject returned FALSE\n");

// NULL brush:

    lb.lbStyle  = BS_HOLLOW;
    lb.lbColor  = RGB(0, 0, 255);
    lb.lbHatch  = HS_CROSS;
    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lb, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("12 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("13 ERROR: DeleteObject returned FALSE\n");

// Solid dithered brush:

    lb.lbStyle = BS_SOLID;
    lb.lbColor = RGB(80, 80, 80);
    lb.lbHatch = HS_CROSS;
    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lb, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("14 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("14.5 ERROR: DeleteObject returned FALSE\n");

// DIB patterned brush:

    h = GlobalAlloc(GMEM_MOVEABLE, sizeof(bmi));
    if (h == (HANDLE) 0)
        DbgPrint("14.6 ERROR: Couldn't GlobalAlloc\n");

    pbmi = (BITMAPINFOPAT*) GlobalLock(h);
    if (pbmi == (BITMAPINFOPAT*) NULL)
        DbgPrint("14.7 ERROR: Couldn't GlobalLock\n");

    *pbmi = bmi;

    GlobalUnlock(h);

    lb.lbStyle = BS_DIBPATTERN;
    lb.lbColor = DIB_RGB_COLORS;
    lb.lbHatch = (ULONG_PTR) h;
    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lb, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("16 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("17 ERROR: DeleteObject returned FALSE\n");

    if (GlobalFree(h) != (LPVOID) NULL)
        DbgPrint("17.5 ERROR: Couldn't GlobalFree\n");

// Pattern brush:

    hbmCat = CreateDIBitmap(0,
			  (BITMAPINFOHEADER *) &bmiPat,
			  CBM_INIT | CBM_CREATEDIB,
                          abBitCat,
			  (BITMAPINFO *) &bmiPat,
                          DIB_RGB_COLORS);
    if (hbmCat == (HBITMAP) 0)
        DbgPrint("15 ERROR: CreateDIBitmap returned 0\n");

    lb.lbStyle = BS_PATTERN;
    lb.lbColor = 62;
    lb.lbHatch = (ULONG_PTR) hbmCat;
    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lb, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("18 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("19 ERROR: DeleteObject returned FALSE\n");

    if (!DeleteObject(hbmCat))
        DbgPrint("20 ERROR: Couldn't delete hbmCat\n");

// Invalid brush:

    lb.lbStyle = 666;
    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lb, 0, (LPDWORD) NULL);
    if (hpen != (HPEN) 0)
        DbgPrint("21 ERROR: ExtCreatePen returned non-zero\n");

// Make a valid brush:

    lb.lbStyle = BS_SOLID;
    lb.lbColor = RGB(255, 0, 255);
    lb.lbHatch = 0;

// Try some invalid pens:

    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lbSolid, 0, aul);
    if (hpen != (HPEN) 0)
        DbgPrint("22 ERROR: ExtCreatePen returned non-zero\n");

    hpen = ExtCreatePen(PS_GEOMETRIC, 30, &lbSolid, 5, aul);
    if (hpen != (HPEN) 0)
        DbgPrint("23 ERROR: ExtCreatePen returned non-zero\n");

    hpen = ExtCreatePen(PS_COSMETIC, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen != (HPEN) 0)
        DbgPrint("24 ERROR: ExtCreatePen returned non-zero\n");

    lb.lbStyle = BS_DIBPATTERN;
    hpen = ExtCreatePen(PS_COSMETIC, 1, &lb, 0, (LPDWORD) NULL);
    if (hpen != (HPEN) 0)
        DbgPrint("25 ERROR: ExtCreatePen returned non-zero\n");

    lb.lbStyle = BS_HATCHED;
    hpen = ExtCreatePen(PS_COSMETIC, 1, &lb, 0, (LPDWORD) NULL);
    if (hpen != (HPEN) 0)
        DbgPrint("26 ERROR: ExtCreatePen returned non-zero\n");

    lb.lbStyle = BS_HOLLOW;
    hpen = ExtCreatePen(PS_COSMETIC, 1, &lb, 0, (LPDWORD) NULL);
    if (hpen != (HPEN) 0)
        DbgPrint("27 ERROR: ExtCreatePen returned non-zero\n");

    lb.lbStyle = 666;
    hpen = ExtCreatePen(PS_COSMETIC, 1, &lb, 0, (LPDWORD) NULL);
    if (hpen != (HPEN) 0)
        DbgPrint("28 ERROR: ExtCreatePen returned non-zero\n");

    hpen = ExtCreatePen(PS_COSMETIC, 30, &lbSolid, 8000000, aul);
    if (hpen != (HPEN) 0)
        DbgPrint("29 ERROR: ExtCreatePen returned non-zero\n");

// Try a cosmetic pen:

    hpen = ExtCreatePen(PS_COSMETIC, 1, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("30 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("31 ERROR: DeleteObject returned FALSE\n");

// Round cap:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_ENDCAP_ROUND, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("32 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("33 ERROR: DeleteObject returned FALSE\n");

// Flat cap:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_ENDCAP_FLAT, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("34 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("35 ERROR: DeleteObject returned FALSE\n");

// Square cap:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_ENDCAP_SQUARE, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("36 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("37 ERROR: DeleteObject returned FALSE\n");

// Miter join:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_JOIN_MITER, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("38 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("39 ERROR: DeleteObject returned FALSE\n");

// Bevel join:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_JOIN_BEVEL, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("40 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("41 ERROR: DeleteObject returned FALSE\n");

// Round join:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_JOIN_ROUND, 30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("42 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("43 ERROR: DeleteObject returned FALSE\n");

//
// Styling with square end-caps
//

// Dot style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DOT | PS_JOIN_MITER | PS_ENDCAP_SQUARE,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("44 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("45 ERROR: DeleteObject returned FALSE\n");

// Dash style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DASH | PS_JOIN_MITER | PS_ENDCAP_SQUARE,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("46 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("47 ERROR: DeleteObject returned FALSE\n");

// DashDot style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DASHDOT | PS_JOIN_MITER | PS_ENDCAP_SQUARE,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("48 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("49 ERROR: DeleteObject returned FALSE\n");

// DashDotDot style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DASHDOTDOT | PS_JOIN_MITER | PS_ENDCAP_SQUARE,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("50 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("51 ERROR: DeleteObject returned FALSE\n");

//
// Styling with flat end-caps
//

// Dot style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DOT | PS_JOIN_MITER | PS_ENDCAP_FLAT,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("52 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("53 ERROR: DeleteObject returned FALSE\n");

// Dash style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DASH | PS_JOIN_MITER | PS_ENDCAP_FLAT,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("54 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("55 ERROR: DeleteObject returned FALSE\n");

// DashDot style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DASHDOT | PS_JOIN_MITER | PS_ENDCAP_FLAT,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("56 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("57 ERROR: DeleteObject returned FALSE\n");

// DashDotDot style:

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_DASHDOTDOT | PS_JOIN_MITER | PS_ENDCAP_FLAT,
                        30, &lbSolid, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("58 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("59 ERROR: DeleteObject returned FALSE\n");

//
// User-supplied style:
//

    aul[0] = 50;
    aul[1] = 10;

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_USERSTYLE | PS_JOIN_MITER | PS_ENDCAP_FLAT,
                        30, &lbSolid, 2, aul);
    if (hpen == (HPEN) 0)
        DbgPrint("60 ERROR: ExtCreatePen returned 0\n");

    vDoLines(hpen);
    if (!DeleteObject(hpen))
        DbgPrint("61 ERROR: DeleteObject returned FALSE\n");

// Illegal style:

    aul[0] = 0;
    aul[1] = 0;
    aul[2] = 0;

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_USERSTYLE | PS_JOIN_MITER | PS_ENDCAP_FLAT,
                        30, &lbSolid, 3, aul);
    if (hpen != (HPEN) 0)
        DbgPrint("62 ERROR: ExtCreatePen returned non-zero\n");
}

VOID vTestGetObject(HDC hdc)
{
    HPEN       hpen;
    LOGPEN     lp  = { 1, {2, 3}, 4 };
    DWORD      aulBigBuf[80];
    LOGBRUSH   lb;
    DWORD      aul[] = { 8, 3, 0 };
    HBITMAP    hbmCat;
    PEXTLOGPEN pelp;
    EXTLOGPEN  elp;

// Old type pen:

    hpen = CreatePen(PS_DASH, 5, RGB(1, 2, 3));
    if (hpen == (HPEN) 0)
        DbgPrint("63 ERROR: CreatePen returned 0\n");

    if (GetObjectType(hpen) != OBJ_PEN)
        DbgPrint("64 ERROR: GetObjectType returned wrong type\n");

    if (GetObject(hpen, 0, (LPVOID) NULL) != sizeof(LOGPEN))
        DbgPrint("65 ERROR: GetObject returned wrong size\n");

    if (GetObject(hpen, sizeof(LOGPEN), &lp) != sizeof(LOGPEN))
        DbgPrint("66 ERROR: GetObject returned wrong size\n");

    if (lp.lopnStyle != PS_DASH ||
        lp.lopnWidth.x != 5 ||
        lp.lopnColor != RGB(1, 2, 3))
        DbgPrint("67 ERROR: GetObject retured wrong info\n");

    if (!DeleteObject(hpen))
        DbgPrint("68 ERROR: Didn't delete pen");

// Extended NULL pen:

    lb.lbStyle = BS_HOLLOW;
    lb.lbColor = RGB(3, 2, 1);
    lb.lbHatch = 3;

    hpen = ExtCreatePen(PS_GEOMETRIC, 5, &lb, 0, (LPDWORD) NULL);
    if (hpen == (HPEN) 0)
        DbgPrint("69 ERROR: ExtCreatePen returned 0\n");

    if (GetObjectType(hpen) != OBJ_PEN)
        DbgPrint("70 ERROR: GetObjectType returned wrong type\n");

    if (GetObject(hpen, 0, (LPVOID) NULL) != sizeof(LOGPEN))
        DbgPrint("71 ERROR: GetObject returned wrong size\n");

    if (GetObject(hpen, sizeof(EXTLOGPEN), &elp) != sizeof(EXTLOGPEN))
        DbgPrint("72 ERROR: GetObject returned wrong size\n");

    if (elp.elpPenStyle != PS_NULL ||
        elp.elpWidth    != 0       ||
        elp.elpBrushStyle != 0     ||
        elp.elpColor != 0          ||
        elp.elpHatch != 0          ||
        elp.elpNumEntries != 0)
        DbgPrint("73 ERROR: GetObject returned wrong info\n");

    if (!DeleteObject(hpen))
        DbgPrint("74 ERROR: Didn't delete pen");

// Extended pen:


    hbmCat = CreateDIBitmap(0,
			  (BITMAPINFOHEADER *) &bmiPat,
			  CBM_INIT,
                          abBitCat,
			  (BITMAPINFO *) &bmiPat,
                          DIB_RGB_COLORS);

    if (hbmCat == (HBITMAP) 0)
        DbgPrint("75 ERROR: CreateDIBitmap returned 0\n");

    lb.lbStyle = BS_PATTERN;
    lb.lbColor = DIB_RGB_COLORS;
    lb.lbHatch = (ULONG_PTR) hbmCat;

    hpen = ExtCreatePen(PS_GEOMETRIC | PS_USERSTYLE | PS_JOIN_BEVEL | PS_ENDCAP_SQUARE,
                        30, &lb, 3, aul);
    if (hpen == (HPEN) 0)
        DbgPrint("76 ERROR: ExtCreatePen returned 0\n");

    if (GetObjectType(hpen) != OBJ_EXTPEN)
        DbgPrint("77 ERROR: GetObjectType returned wrong type\n");

    pelp = (PEXTLOGPEN) aulBigBuf;

    if (GetObject(hpen, 0, (LPVOID) NULL) != sizeof(EXTLOGPEN) + 2 * sizeof(DWORD))
        DbgPrint("78 ERROR: GetObject returned wrong size\n");

    if (GetObject(hpen, sizeof(aulBigBuf), pelp) != sizeof(EXTLOGPEN) + 2 * sizeof(DWORD))
        DbgPrint("79 ERROR: GetObject returned wrong size\n");

    if (pelp->elpPenStyle != (PS_GEOMETRIC | PS_USERSTYLE | PS_JOIN_BEVEL | PS_ENDCAP_SQUARE) ||
        pelp->elpWidth    != 30 ||
        pelp->elpBrushStyle != BS_PATTERN ||
        //pelp->elpColor != DIB_RGB_COLORS ||
        pelp->elpHatch != (ULONG_PTR) hbmCat ||
        pelp->elpNumEntries != 3 ||
        pelp->elpStyleEntry[0] != aul[0] ||
        pelp->elpStyleEntry[1] != aul[1] ||
        pelp->elpStyleEntry[2] != aul[2])
        DbgPrint("80 ERROR: GetObject returned wrong info\n");

    if (!DeleteObject(hpen))
        DbgPrint("81 ERROR: Didn't delete pen\n");

    DeleteObject(hbmCat);
}

VOID vTestSaveDC(HDC hdc)
{
    HPEN hpenWide    = CreatePen(PS_SOLID, 30, RGB(100, 100, 100));
    HPEN hpenSpine   = CreatePen(PS_SOLID, 1, RGB(0, 255, 0));
    HPEN hpenOutline = CreatePen(PS_SOLID, 1, RGB(0, 0, 255));
    HPEN hpenOld     = SelectObject(hdc, hpenSpine);

    POINT apt1[] = { 100, 300, 100, 100, 300, 100, 300, 300 };
    POINT apt2[] = { 200, 400, 200, 200, 400, 200, 400, 400 };

    BeginPath(hdc);
    PolyBezier(hdc, apt1, 4);
    PolyBezier(hdc, apt2, 4);
    CloseFigure(hdc);
    EndPath(hdc);

// Test if temporary path stuff works:

    MoveToEx(hdc, grclLine.left, grclLine.top, NULL);
    LineTo(hdc, grclLine.right, grclLine.bottom);

    SaveDC(hdc);
    MoveToEx(hdc, grclLine.left, grclLine.bottom, NULL);
    LineTo(hdc, grclLine.right, grclLine.top);
    RestoreDC(hdc, -1);

// Check if SaveDC can save paths!

    SaveDC(hdc);

        SelectObject(hdc, hpenWide);
        SaveDC(hdc);

            StrokePath(hdc);

        RestoreDC(hdc, -1);
        WidenPath(hdc);
        SelectObject(hdc, hpenOutline);
        StrokePath(hdc);

    RestoreDC(hdc, -1);
    StrokePath(hdc);

// See if we can save our state in the middle:

    BeginPath(hdc);
    MoveToEx(hdc, 25, 75, NULL);
    LineTo(hdc, 25, 25);
    LineTo(hdc, 75, 25);

    SaveDC(hdc);
    {
        HPEN hpenNotSoWide = CreatePen(PS_SOLID, 5, RGB(255, 255, 0));
        HPEN hpenOld;

        hpenOld = SelectObject(hdc, hpenNotSoWide);

        LineTo(hdc, 75, 75);
        CloseFigure(hdc);
        EndPath(hdc);
        StrokePath(hdc);

        SelectObject(hdc, hpenOld);

        if (!DeleteObject(hpenNotSoWide))
            DbgPrint ("didn't deletepen hpennotsowide\n");
    }
    RestoreDC(hdc, -1);

    {
        POINT apt3[] = { 75, 50, 50, 75, 30, 75 };
        SelectObject(hdc, hpenSpine);

        PolyBezierTo(hdc, apt3, 3);
        CloseFigure(hdc);
        EndPath(hdc);
        StrokePath(hdc);
    }

// See if a current path will be thrown away on a restore:

    SaveDC(hdc);
    BeginPath(hdc);
    PolyBezier(hdc, apt2, 4);
    RestoreDC(hdc, -1);

#if THISISREALLYWHATIWANTTODO
    {
        POINT pt;

    // Check out if path properly inherits DC's current position (which
    // was set by the CloseFigure() up above to (25, 75)).

        BeginPath(hdc);
        GetCurrentPositionEx(hdc, &pt);
        if (pt.x != 25 || pt.y != 75)
            DbgPrint("82 ERROR: Didn't get expected current position\n");

        AbortPath(hdc);
    }
#endif

    SelectObject(hdc,hpenOld);

    if (!DeleteObject(hpenWide))
        DbgPrint ("fail to delete hpenwide\n");

    if (!DeleteObject(hpenSpine))
        DbgPrint ("fail to delete hpenspine\n");

    if (!DeleteObject(hpenOutline))
        DbgPrint ("fail to delete hpenoutline\n");
    //SelectObject(hdc, hpenOld);
}

VOID vTestCP(HDC hdc)
{
    POINT pt;
    POINT ptOld;

    BitBlt(ghdcLine, grclLine.left, grclLine.top,
                      grclLine.right, grclLine.bottom,
                      (HDC) 0, 0, 0, BLACKNESS);

    SelectObject(hdc, GetStockObject(WHITE_PEN));

    MoveToEx(hdc, 100, 200, NULL);
    LineTo(hdc, 100, 90);

    SetWindowOrgEx(hdc, 100, 0, &ptOld);
    GetCurrentPositionEx(hdc, &pt);

    if (pt.x != 100 || pt.y != 90)
        DbgPrint("200 ERROR: Expect CP = (100, 90), got (%li, %li)\n", pt.x, pt.y);

    LineTo(hdc, 100, 200);

    SetWindowOrgEx(hdc, ptOld.x, ptOld.y, NULL);
}

#define RADIALX     80
#define RADIALY     80

#define XSIZE     40
#define YSIZE     40

#define SEGMENTSIZE 3
#define CLIPSECTIONSIZE 2

VOID vSimpleRadialLines(HDC hdc, LONG x, LONG y)
{
    RECT rect;

    SetViewportOrgEx(hdc, x * RADIALX + XSIZE, y * RADIALY + YSIZE, NULL);

    SetRect(&rect, 0, -YSIZE, XSIZE, YSIZE);
    FillRect(hdc, &rect, GetStockObject(WHITE_BRUSH));

    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, 0);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, -YSIZE / 2);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, -YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE / 2, -YSIZE);

    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, 0, -YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE / 2, -YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, -YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, -YSIZE / 2);

    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, 0);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, YSIZE / 2);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE / 2, YSIZE);

    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, 0, YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE / 2, YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, YSIZE);
    MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, YSIZE / 2);
}

#define DENSE_LINES 8

VOID vDenseRadialLines(HDC hdc, LONG x, LONG y)
{
    LONG ll;
    LONG xSign;
    LONG ySign;

    SetViewportOrgEx(hdc, x * RADIALX + XSIZE, y * RADIALY + YSIZE, NULL);

    for (xSign = -1; xSign <= 1; xSign += 2)
        for (ySign = -1; ySign <= 1; ySign += 2)
            for (ll = 0; ll <= DENSE_LINES; ll++)
            {
                MoveToEx(hdc, 0, 0, NULL);
                LineTo(hdc, xSign * XSIZE, ySign * YSIZE * ll / DENSE_LINES);
                MoveToEx(hdc, 0, 0, NULL);
                LineTo(hdc, xSign * XSIZE * ll / DENSE_LINES, ySign * YSIZE);
            }
}

VOID vSegmentedLineTo(HDC hdc, LONG x, LONG y)
{
    LONG ll;
    LONG xNonZero = (x == 0) ? 0 : ((x < 0) ? -1 : 1);
    LONG yNonZero = (y == 0) ? 0 : ((y < 0) ? -1 : 1);

    for (ll = SEGMENTSIZE; ll < MAX(ABS(x), ABS(y)); ll += SEGMENTSIZE)
    {
        LineTo(hdc, ll * xNonZero, ll * yNonZero);
    }

    LineTo(hdc, x, y);
}

VOID vComplexRadialLines(HDC hdc, LONG x, LONG y)
{
    LONG ll;
    RECT rect;

    SetViewportOrgEx(hdc, x * RADIALX + XSIZE, y * RADIALY + YSIZE, NULL);

    SetRect(&rect, 0, -YSIZE, XSIZE, YSIZE);
    FillRect(hdc, &rect, GetStockObject(WHITE_BRUSH));

    for (ll = 0; ll < MAX(XSIZE, YSIZE); ll += CLIPSECTIONSIZE)
    {
        HRGN hrgn;
        HRGN hrgnTmp;

        hrgn = CreateRectRgn(-ll - CLIPSECTIONSIZE, -ll - CLIPSECTIONSIZE,
                              ll + CLIPSECTIONSIZE, ll + CLIPSECTIONSIZE);
        hrgnTmp = CreateRectRgn(-ll, -ll, ll, ll);

        CombineRgn(hrgn, hrgn, hrgnTmp, RGN_DIFF);
        DeleteObject(hrgnTmp);

        OffsetRgn(hrgn, x * RADIALX + XSIZE, y * RADIALY + YSIZE);

        SelectClipRgn(hdc, hrgn);
        DeleteObject(hrgn);

        MoveToEx(hdc, 0, 0, NULL); vSegmentedLineTo(hdc, XSIZE, 0);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, -YSIZE / 2);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, -YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE / 2, -YSIZE);

        MoveToEx(hdc, 0, 0, NULL); vSegmentedLineTo(hdc, 0, -YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE / 2, -YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, -YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, -YSIZE / 2);

        MoveToEx(hdc, 0, 0, NULL); vSegmentedLineTo(hdc, -XSIZE, 0);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, YSIZE / 2);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE, YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, -XSIZE / 2, YSIZE);

        MoveToEx(hdc, 0, 0, NULL); vSegmentedLineTo(hdc, 0, YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE / 2, YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, YSIZE);
        MoveToEx(hdc, 0, 0, NULL); LineTo(hdc, XSIZE, YSIZE / 2);
    }

    SelectClipRgn(hdc, NULL);
}

VOID vMakePens(HPEN ahpen[], COLORREF cr)
{
    LOGBRUSH lb;
    DWORD    adw[3];

    lb.lbColor = cr;
    lb.lbStyle = BS_SOLID;
    lb.lbHatch = 0;

    adw[0] = 1;
    adw[1] = 2;
    adw[2] = 1;

    ahpen[0] = ExtCreatePen(PS_COSMETIC | PS_SOLID,
                            1, &lb, 0, (LPDWORD) NULL);
    ahpen[1] = ExtCreatePen(PS_COSMETIC | PS_DASHDOT,
                            1, &lb, 0, (LPDWORD) NULL);
    ahpen[2] = ExtCreatePen(PS_COSMETIC | PS_ALTERNATE,
                            1, &lb, 0, (LPDWORD) NULL);
    ahpen[3] = ExtCreatePen(PS_COSMETIC | PS_USERSTYLE,
                            1, &lb, 3, adw);
}

VOID vDeletePens(HPEN ahpen[])
{
    int i;

    for (i = 0; i < 4; ++i)
    {
        if (!DeleteObject(ahpen[i]))
            DbgPrint("fail to delete ahpen[%x]\n", i);
    }
}
// This function will produce a bunch of lines for all the different
// ROPs.  The ROPs will be displayed in the following pattern:
//
//    White Pen              Black Pen
//   1   2   3   4          1   2   3   4
//   5   6   7   8          5   6   7   8
//   9  10  11  12          9  10  11  12
//  13  14  15  16         13  14  15  16

VOID vTestStylesAndROPs(HDC hdc)
{
    LONG ll;
    HPEN ahpen[4];
    HPEN hpenOld;

    BitBlt(ghdcLine, grclLine.left, grclLine.top,
                     grclLine.right, grclLine.bottom,
                     (HDC) 0, 0, 0, BLACKNESS);

// Do white pen case:

    vMakePens(ahpen, RGB(255, 255, 255));

    ll = 0;

    SetROP2(hdc, ll + 1);
    hpenOld = SelectObject(hdc, ahpen[ll & 3]);
    vSimpleRadialLines(hdc, ll & 3, ll >> 2);

    for (ll = 1; ll < 16; ll++)
    {
        SetROP2(hdc, ll + 1);
        SelectObject(hdc, ahpen[ll & 3]);
        vSimpleRadialLines(hdc, ll & 3, ll >> 2);
    }

    SelectObject (hdc, hpenOld);

    vDeletePens(ahpen);

// Do black pen case:

    vMakePens(ahpen, RGB(0, 0, 0));

    ll = 0;

    SetROP2(hdc, ll + 1);
    hpenOld = SelectObject(hdc, ahpen[ll & 3]);
    vComplexRadialLines(hdc, (ll & 3) + 4, ll >> 2);

    for (ll = 1; ll < 16; ll++)
    {
        SetROP2(hdc, ll + 1);
        SelectObject(hdc, ahpen[ll & 3]);
        vComplexRadialLines(hdc, (ll & 3) + 4, ll >> 2);
    }

    SelectObject (hdc, hpenOld);

    vDeletePens(ahpen);

// Do other case:

    SetROP2(hdc, R2_COPYPEN);
    vMakePens(ahpen, RGB(255, 255, 0));

    ll = 0;
    hpenOld = SelectObject(hdc, ahpen[ll]);
    vDenseRadialLines(hdc, ll, 4);

    for (ll = 1; ll < 4; ll++)
    {
        SelectObject(hdc, ahpen[ll]);
        vDenseRadialLines(hdc, ll, 4);
    }

    SelectObject (hdc, hpenOld);

    vDeletePens(ahpen);

// Clean up:

    //SelectObject(hdc, GetStockObject(WHITE_PEN));
    SetViewportOrgEx(hdc, 0, 0, NULL);
}

VOID vTestFlattenPath(HDC hdc)
{
    LONG    i;
    POINT   apt[4];
    HPEN    hpen;
    HPEN    hpenOld;

    hpen = CreatePen(PS_SOLID, 0, 0);

    hpenOld = SelectObject(hdc, hpen);

    giSeed = time(NULL);

    // Test the Beizer flattener to see if it dies:

    for (i = 0; i < 1000; i++)
    {
        srand(giSeed);

        if (i == 0)
        {
        // Colinear points are a special challenge to the Bezier Flattener:

            apt[0].x = 102;
            apt[0].y = 532;
            apt[1].x = 221;
            apt[1].y = 180;
            apt[2].x = 340;
            apt[2].y = -172;
            apt[3].x = 459;
            apt[3].y = -524;
        }
        else if (i & 1)
        {
        // Try random points over a big space:

            apt[0].x = (rand() & 8191) - 4096;
            apt[0].y = (rand() & 8191) - 4096;
            apt[1].x = (rand() & 8191) - 4096;
            apt[1].y = (rand() & 8191) - 4096;
            apt[2].x = (rand() & 8191) - 4096;
            apt[2].y = (rand() & 8191) - 4096;
            apt[3].x = (rand() & 8191) - 4096;
            apt[3].y = (rand() & 8191) - 4096;
        }
        else
        {
        // Try random points in a small space, since that is special-cased
        // by the flattener code:

            apt[0].x = (rand() & 1023);
            apt[0].y = (rand() & 1023);
            apt[1].x = (rand() & 1023);
            apt[1].y = (rand() & 1023);
            apt[2].x = (rand() & 1023);
            apt[2].y = (rand() & 1023);
            apt[3].x = (rand() & 1023);
            apt[3].y = (rand() & 1023);
        }

        PolyBezier(hdc, apt, 4);

        giSeed = giSeed + rand();
    }

    SelectObject(hdc, hpenOld);
}

VOID vTestLines(HWND hwnd, HDC hdc, RECT* prcl)
{
    ghdcLine = hdc;
    grclLine = *prcl;

//    if (!GdiSetBatchLimit(1))
//        DbgPrint("82 ERROR: Couldn't set batch  limit");

    vTestFlattenPath(hdc);
    vDoABunch(hdc);
    vTestGetObject(hdc);
    vTestSaveDC(hdc);
    vTestCP(hdc);
    vTestStylesAndROPs(hdc);

    hwnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftlfont.c ===
/******************************Module*Header*******************************\
* Module Name: ftlfont.c
*
* Created: 13-Oct-1991 15:22:43
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


/******************************Public*Routine******************************\
* VOID vTestLFONTCleanup(HWND hwnd, HDC hdc, RECT* prcl)
*
* History:
*  08-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vTestLFONTCleanup(HWND hwnd, HDC hdc, RECT* prcl)
{
    LOGFONT lfnt;
    HFONT   hfont;
    ULONG   ul;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(prcl);

    DbgPrint("Creating HLFONTs: ");
    for (ul = 0; ul<1000; ul++)
    {
        hfont = CreateFontIndirect(&lfnt);

        DbgPrint(", 0x%lx", hfont);
    }
    DbgPrint("\n");
    DbgBreakPoint();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftkern.c ===
/******************************Module*Header*******************************\
* Module Name: ftkern.c
*
* For testing GetKerningPairs
*
* Created: 14-Nov-1991 08:56:42
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct _FTPARAM {
    HWND hwnd;
    HDC  hdc;
    RECT *prect;
} FTPARAM;

/******************************Public*Routine******************************\
* FontFunc
*
* History:
*  Tue 17-Mar-1992 10:38:02 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

FONTENUMPROC
FontFunc(
    LOGFONT    *plf,
    TEXTMETRIC *ptm,
    int         iType,
    FTPARAM    *pftp
    )
{
    HFONT hf,
          hfOld;
    int cPair,                // number of kerning pairs
        cPairCopied,          // number of pairs coppied to buffer
        iSpace,               // space between successive lines
        y;                    // current y-coordinate
    char ach[100];            // scratch space
    HBRUSH hbOld;
    TEXTMETRIC tm;

    y = 20;
    iSpace = (int) (ptm->tmHeight + ptm->tmExternalLeading);

    hf = CreateFontIndirect(plf);
    if (hf == 0)
    {
        DbgPrint("FontFunc -- CreateFontIndirect failed\n");
    }
    hfOld = SelectObject(pftp->hdc,hf);
    if (hfOld == 0)
    {
        DbgPrint("FontFunc -- Select Object failed\n");
    }
    cPair = GetKerningPairs(pftp->hdc, 0, (KERNINGPAIR*) NULL);

    if (cPair != 0)
    {
        HANDLE hMem;
        PVOID  pvMem;

        hMem = LocalAlloc(LMEM_FIXED,cPair * sizeof(KERNINGPAIR));
        if (hMem == 0)
        {
            DbgPrint("FontFunc -- LocalAlloc failed\n");
            return(0);
        }
        if (hMem)
        {
            pvMem = LocalLock(hMem);
            if (pvMem == NULL)
            {
                DbgPrint("FontFunc -- LocalLock failed\n");
                return(0);
            }
            if (pvMem != NULL)
            {
                KERNINGPAIR *pkpTooBig;
                KERNINGPAIR *pkp = (KERNINGPAIR*) pvMem;

                cPairCopied = GetKerningPairs(pftp->hdc, cPair, pkp);
                pkpTooBig = pkp + cPairCopied;

                hbOld = SelectObject(pftp->hdc,GetStockObject(WHITE_BRUSH));
                PatBlt(
                    pftp->hdc,
                    pftp->prect->left,
                    pftp->prect->top + y,
                    pftp->prect->right - pftp->prect->left,
                    pftp->prect->bottom - pftp->prect->top,
                    PATCOPY
                    );
                SelectObject(pftp->hdc,hbOld);

                wsprintf(ach,"%s has %d kerning pairs",plf->lfFaceName,cPair);
                TextOut(pftp->hdc,0,y,ach,strlen(ach));
                y += iSpace;

                wsprintf(ach,"    wFirst wSecond iKernAmount");
                TextOut(pftp->hdc,0,y,ach,strlen(ach));
                y += iSpace;

                while (pkp < pkpTooBig && (y + ptm->tmHeight < (int) pftp->prect->bottom))
                {
                    wsprintf(
                        ach,
                        "    %-#6lx %-#6lx   %d",
                        pkp->wFirst,
                        pkp->wSecond,
                        pkp->iKernAmount
                        );
                    TextOut(pftp->hdc,0,y,ach,strlen(ach));
                    y += iSpace;
                    pkp += 1;
                }
                vSleep(1);
            }
            LocalUnlock(hMem);
        }
    }

    SelectObject(pftp->hdc,hfOld);
    DeleteObject(hf);

    UNREFERENCED_PARAMETER(iType);
    return(1);
}

/******************************Public*Routine******************************\
* vTestKerning
*
* History:
*  Wed 13-Nov-1991 13:14:04 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

void
vTestKerning(
    HWND hwnd,
    HDC  hdc,
    RECT *prect
    )
{
    FTPARAM ftp;
    HBRUSH hbOld;
    char ach[100];
    char *psz1 = "*** GetKerningPairs Test ***";
    char *psz2 = "*** GetKerningPairs Test is Finished ***";
    HBRUSH hbrushKern;

    hbrushKern = CreateHatchBrush(HS_CROSS,RGB(0xC0,0xC0,0xC0));

    hbOld = SelectObject(hdc,hbrushKern);
    PatBlt(
        hdc,
        prect->left,
        prect->top,
        prect->right - prect->left,
        prect->bottom - prect->top,
        PATCOPY
        );
    SelectObject(hdc,hbOld);
    DeleteObject(hbrushKern);

    ftp.hwnd  = hwnd;
    ftp.hdc   = hdc;
    ftp.prect = prect;

    TextOut(hdc,0,0,psz1,strlen(psz1));
    EnumFonts(hdc,(LPCSTR)NULL, (FONTENUMPROC)FontFunc,(LPARAM) &ftp);
    TextOut(hdc,0,0,psz2,strlen(psz2));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftmap.c ===
/******************************Module*Header*******************************\
* Module Name: ftmap.c
*
* map tests
*
* Created: 26-May-1991 13:07:35
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

extern BYTE abColorLines[];
extern BYTE abBitCat[];

/******************************Public*Routine******************************\
* vBug787
*
* History:
*  19-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFOPAT2
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD			     bmiColors[2];
} BITMAPINFOPAT2;

BITMAPINFOPAT2 bmiPat12 =
{
    {
        sizeof(BITMAPINFOHEADER),
	8,
	8,
        1,
        1,
        BI_RGB,
	32,
        0,
        0,
        2,
        2
    },

    {                               // B    G    R
	{ 0,   0,   0,	 0 },	    // 1
	{ 0xFF,0xFF,0xFF,0 },	    // 2
    }
};

VOID vBug787(HDC hdcScreen)
{
    DWORD White[] =  { 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa };
    HBITMAP hbmMono, hbmbrush, hbm4;
    HBRUSH hbrMono;
    HDC hdcMono, hdc4;

    hdc4    = CreateCompatibleDC(hdcScreen);
    hdcMono = CreateCompatibleDC(hdcScreen);

    hbmbrush = CreateBitmap(8, 8, 1, 1, (LPBYTE) White);
    hbmMono  = CreateBitmap(100, 100, 1, 1, (LPBYTE) NULL);
    hbm4     = CreateBitmap(100, 100, 1, 4, NULL);
    hbrMono  = CreatePatternBrush(hbmbrush);
    DeleteObject(hbmbrush);

    SelectObject(hdcMono, hbmMono);
    SelectObject(hdcMono, hbrMono);
    SelectObject(hdc4, hbm4);

    SetTextColor(hdcMono, 0x00000000L);
    SetBkMode(hdcMono, OPAQUE);
    SetBkColor(hdcMono, 0x00FFFFFFL);

    PatBlt(hdcMono, 0, 0, 100, 100, WHITENESS);
    TextOut(hdcMono, 0, 0,  "ABCDEFGHIJKLMNOPQRSTUVXYZ", 26);
    TextOut(hdcMono, 0, 50, "ABCDEFGHIJKLMNOPQRSTUVXYZ", 26);
    PatBlt(hdcMono, 0, 0, 100, 100, 0x00fa0089);

    SetTextColor(hdc4, 0x00000000L);
    SetBkColor(hdc4, 0x00FFFFFFL);

// Doing it to a bitmap.

    SelectObject(hdc4, GetStockObject(BLACK_BRUSH));
    PatBlt(hdc4, 0, 0, 100, 100, WHITENESS);
    BitBlt(hdc4, 0, 0, 100, 100, hdcMono, 0, 0, 0xE20746);
    BitBlt(hdcScreen, 0, 0, 100, 100, hdc4, 0, 0, SRCCOPY);
    PatBlt(hdc4, 0, 0, 100, 100, WHITENESS);
    BitBlt(hdc4, 0, 0, 100, 100, hdcMono, 0, 0, 0xB8074A);
    BitBlt(hdcScreen, 100, 0, 100, 100, hdc4, 0, 0, SRCCOPY);

    SelectObject(hdc4, GetStockObject(WHITE_BRUSH));
    PatBlt(hdc4, 0, 0, 100, 100, BLACKNESS);
    BitBlt(hdc4, 0, 0, 100, 100, hdcMono, 0, 0, 0xE20746);
    BitBlt(hdcScreen, 0, 100, 100, 100, hdc4, 0, 0, SRCCOPY);
    PatBlt(hdc4, 0, 0, 100, 100, BLACKNESS);
    BitBlt(hdc4, 0, 0, 100, 100, hdcMono, 0, 0, 0xB8074A);
    BitBlt(hdcScreen, 100, 100, 100, 100, hdc4, 0, 0, SRCCOPY);

// Doing it to the VGA. !!! VGA bug demo

    SelectObject(hdcScreen, GetStockObject(BLACK_BRUSH));
    PatBlt(hdcScreen, 200, 0, 100, 100, WHITENESS);
    BitBlt(hdcScreen, 200, 0, 100, 100, hdcMono, 0, 0, 0xE20746);
    PatBlt(hdcScreen, 300, 0, 100, 100, WHITENESS);
    BitBlt(hdcScreen, 300, 0, 100, 100, hdcMono, 0, 0, 0xB8074A);

    SelectObject(hdcScreen, GetStockObject(WHITE_BRUSH));
    PatBlt(hdcScreen, 200, 100, 100, 100, BLACKNESS);
    BitBlt(hdcScreen, 200, 100, 100, 100, hdcMono, 0, 0, 0xE20746);
    PatBlt(hdcScreen, 300, 100, 100, 100, BLACKNESS);
    BitBlt(hdcScreen, 300, 100, 100, 100, hdcMono, 0, 0, 0xB8074A);

    DeleteDC(hdc4);
    DeleteDC(hdcMono);
    DeleteObject(hbm4);
    DeleteObject(hbmMono);
    DeleteObject(hbrMono);
}

/******************************Public*Routine******************************\
* vBuginSetPixel
*
* SetPixel supposably fails, we will see.
*
* History:
*  16-Aug-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vBuginSetPixel(void)
{
    HDC hDC;
    DWORD dwTemp;

    hDC = CreateDC("DISPLAY", NULL, NULL, NULL);

    if (hDC == (HDC) 0)
    {
	DbgPrint("CreateDC failed in vBuginSetPixel\n");
	return;
    }

    dwTemp = SetPixel(hDC, 1, 1, RGB(0, 0, 255));

    if (dwTemp == 0xFFFFFFFF)
    {
	DbgPrint("1SetPixel failed in vBuginSetPixel %lx %lu\n", dwTemp, dwTemp);
    }

    dwTemp = SetPixel(hDC, 0, 0, RGB(0, 0, 255));

    if (dwTemp == 0xFFFFFFFF)
    {
	DbgPrint("2SetPixel failed in vBuginSetPixel %lx %lu\n", dwTemp, dwTemp);
    }

    dwTemp = SetPixel(hDC, 639, 0, RGB(0, 0, 255));

    if (dwTemp == 0xFFFFFFFF)
    {
	DbgPrint("3SetPixel failed in vBuginSetPixel %lx %lu\n", dwTemp, dwTemp);
    }

    DeleteDC(hDC);
}

/******************************Public*Routine******************************\
* vTestMapping
*
* Test graying of stuff.
*
* History:
*  26-Jul-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestMapping(HWND hwnd, HDC hdc, RECT* prcl)
{
    vBuginSetPixel();
    vBug787(hdc);
    hwnd;
    prcl;
}

#if 0
/*-----------------------------------------
   MYDRAW2.C -- Create and Display a Bitmap
  -----------------------------------------*/

#define NCOLOURS            16
#define PATTERNWIDTH        256
#define PATTERNHEIGHT       16
#define BITSPERPIXEL        4
#define PIXELSPERBYTE	    2
#define PIXELSPERCOLOURBAND 16
#define BYTESPERLINE	    128

static HPALETTE PASCAL NewPalette(void);
static PBITMAPINFO PASCAL NewBitmapInfo(HWND hwnd, int wUsage);
static void PASCAL FreeBitmapInfo(PBITMAPINFO);

long TestPalette (HWND hwnd, WORD message, LONG wParam, LONG lParam)
{
    PBITMAPINFO  pDibInfo;
    HPALETTE	 hPal;
    BYTE	 Pattern[PATTERNHEIGHT * PATTERNWIDTH / PIXELSPERBYTE];
    BYTE	 pix_val,
		 pattern_val;
    HDC 	 hdc;
    PAINTSTRUCT  ps;
    int 	 pindex,
		 line,
		 pos,
		 pixel,
		 pix_pos,
		 bitmap_type = DIB_PAL_COLORS;

    pindex = 0;
    for (line = 0; line < PATTERNHEIGHT; line++)
    {
	pix_pos = 0;
	for (pos = 0; pos < 128; pos++)
	{
	    pattern_val = 0;
	    for (pixel = 0; pixel < 2; pixel++)
	    {
		pix_val = (BYTE) (pix_pos++ / 16);
		pattern_val = (BYTE)(pattern_val<<4) + pix_val;
	    }
	    Pattern[pindex++] = pattern_val;
	}
    }

    hPal = NewPalette();
    pDibInfo = NewBitmapInfo(hwnd, bitmap_type);
    return 0;

    case WM_PAINT:
        hdc = BeginPaint(hwnd, &ps);
        SetDIBitsToDevice(hdc, 0, 0, PATTERNWIDTH, PATTERNHEIGHT, 0, 0,
                          0, PATTERNHEIGHT, (LPSTR) Pattern, pDibInfo,
                          bitmap_type);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_QUERYNEWPALETTE:
        hdc = GetDC(hwnd);
        SelectPalette(hdc, hPal, 0);
        RealizePalette(hdc);
        ReleaseDC(hwnd, hdc);
        return TRUE;
        break;

    case WM_DESTROY:
        FreeBitmapInfo(pDibInfo);
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProc(hwnd, message, wParam, lParam);
}

static HPALETTE PASCAL NewPalette(void)
{
    WORD         i;
    LOGPALETTE  *pPal;
    HPALETTE     hPal = 0;

    pPal = (LOGPALETTE *) LocalAlloc(LPTR, sizeof(LOGPALETTE) +
                                           NCOLOURS * sizeof(PALETTEENTRY));
    if (pPal == (LOGPALETTE *) NULL)
        return (HPALETTE) 0;

    pPal->palNumEntries = NCOLOURS;
    pPal->palVersion = 0x300;

    for (i = 0; i < NCOLOURS; i++)
    {
        pPal->palPalEntry[i].peRed = (BYTE)i;
        pPal->palPalEntry[i].peGreen = 0;
        pPal->palPalEntry[i].peBlue = 0;
        pPal->palPalEntry[i].peFlags = PC_EXPLICIT;

        if(i == 8)
        {
            pPal->palPalEntry[i].peRed = 255;
            pPal->palPalEntry[i].peGreen = 255;
            pPal->palPalEntry[i].peBlue = 255;
            pPal->palPalEntry[i].peFlags = 0;
        }

    }
    hPal = CreatePalette(pPal);
    LocalFree((HANDLE)pPal);
    return hPal;
}

static PBITMAPINFO PASCAL NewBitmapInfo(HWND hwnd, int wUsage)
{
    PBITMAPINFO     pDibInfo;
    int             infoSize,
                    colSize;
    WORD            i;

    switch (wUsage)
    {
    case DIB_RGB_COLORS:
        colSize = NCOLOURS * sizeof(RGBQUAD);
        break;
    case DIB_PAL_COLORS:
        colSize = NCOLOURS * sizeof(WORD);
        break;
    case DIB_PAL_INDICES:
        colSize = 0;
        break;
    default:
        break;
    }
    infoSize = sizeof(BITMAPINFOHEADER) + colSize;
    pDibInfo = (PBITMAPINFO) malloc(infoSize);
    if (pDibInfo == (PBITMAPINFO) NULL)
    {
	return(0);
    }
    pDibInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pDibInfo->bmiHeader.biWidth = PATTERNWIDTH;
    pDibInfo->bmiHeader.biHeight = PATTERNHEIGHT;
    pDibInfo->bmiHeader.biPlanes = 1;
    pDibInfo->bmiHeader.biBitCount = BITSPERPIXEL;
    pDibInfo->bmiHeader.biCompression = 0;
    pDibInfo->bmiHeader.biSizeImage = 0;
    pDibInfo->bmiHeader.biXPelsPerMeter = 0;
    pDibInfo->bmiHeader.biYPelsPerMeter = 0;
    pDibInfo->bmiHeader.biClrUsed = 0;
    pDibInfo->bmiHeader.biClrImportant = 0;

    switch (wUsage)
    {
    case DIB_RGB_COLORS:
        pDibInfo->bmiColors[0].rgbRed = 0xff;
        pDibInfo->bmiColors[0].rgbGreen = 0;
        pDibInfo->bmiColors[0].rgbBlue = 0;
        pDibInfo->bmiColors[1].rgbRed = 0;
        pDibInfo->bmiColors[1].rgbGreen = 0xff;
        pDibInfo->bmiColors[1].rgbBlue = 0;
        break;
    case DIB_PAL_COLORS:
        for (i = 0; i < NCOLOURS; i++)
            ((WORD *) pDibInfo->bmiColors)[i] = i;
        break;
    default:
        break;
    }
    return pDibInfo;
}

static void PASCAL FreeBitmapInfo(PBITMAPINFO pDibInfo)
{
    LocalFree((HANDLE) pDibInfo);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftpal.c ===
/******************************Module*Header*******************************\
* Module Name: ftpal.c
*
* Palette tests for NT.
*
* Created: 31-Aug-1991 15:35:03
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

typedef struct _VGALOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} VGALOGPALETTE;

typedef struct _LOGPALETTE256
{
    USHORT palVersion;
    USHORT palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

VGALOGPALETTE logpalVGA =
{
0x300,  // driver version
16,     // num entries
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7

    { 0x80,0x80,0x80,0 },       // 8
    { 0xFF,0,   0,   0 },       // 9
    { 0,   0xFF,0,   0 },       // 10
    { 0xFF,0xFF,0,   0 },       // 11
    { 0,   0,   0xFF,0 },       // 12
    { 0xFF,0,   0xFF,0 },       // 13
    { 0,   0xFF,0xFF,0 },       // 14
    { 0xFF,0xFF,0xFF,0 }        // 15
}
};

/******************************Public*Routine******************************\
* vTestPal1
*
* Test GetNearestPaletteIndex
*
* History:
*  31-Aug-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestPal1(void)
{
    HPALETTE hpal1;
    UINT uiTemp;

    hpal1 = CreatePalette((LPLOGPALETTE) &logpalVGA);

    if (hpal1 == (HPALETTE) 0)
    {
	DbgPrint("vTestPal1 failed to create palette\n");
	return;
    }

    AnimatePalette(hpal1, 0, 100, NULL);
    SetPaletteEntries(hpal1, 0, 100, NULL);

    uiTemp = GetNearestPaletteIndex(hpal1, 0);

    if (uiTemp != 0)
	DbgPrint("GetNearestPaletteIndex failed 0 %lx\n", uiTemp);

    uiTemp = GetNearestPaletteIndex(hpal1, 0x00000080);

    if (uiTemp != 1)
	DbgPrint("GetNearestPaletteIndex failed 1 %lx\n", uiTemp);

    uiTemp = GetNearestPaletteIndex(hpal1, 0x00C0C0C0);

    if (uiTemp != 7)
	DbgPrint("GetNearestPaletteIndex failed 7 %lx\n", uiTemp);

    uiTemp = GetNearestPaletteIndex(hpal1, 0x0000FF00);

    if (uiTemp != 10)
	DbgPrint("GetNearestPaletteIndex failed 10 %lx\n", uiTemp);

    uiTemp = GetNearestPaletteIndex(hpal1, 0x00FFFFFF);

    if (uiTemp != 15)
	DbgPrint("GetNearestPaletteIndex failed 15 %lx\n", uiTemp);

    uiTemp = GetNearestPaletteIndex(hpal1, PALETTEINDEX(5));

    if (uiTemp != 5)
	DbgPrint("GetNearestPaletteIndex failed 15 %lx\n", uiTemp);

    uiTemp = GetNearestPaletteIndex(hpal1, PALETTEINDEX(10));

    if (uiTemp != 10)
	DbgPrint("GetNearestPaletteIndex failed 15 %lx\n", uiTemp);

    if (!DeleteObject(hpal1))
	DbgPrint("vTestPal1 failed to delete palette\n");
}

/******************************Public*Routine******************************\
* vTestPal2
*
* Test palette stuff.
*
* History:
*  01-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestPal2(HDC hdc)
{
    HPALETTE hpalDefault;
    HBRUSH hbrDefault, hbr;
    DWORD ulIndex, ulPal;
    PALETTEENTRY palentry;

    hpalDefault = GetStockObject(DEFAULT_PALETTE);

    SelectPalette(hdc, hpalDefault, 0);
    SelectPalette(hdc, hpalDefault, 0);
    SelectPalette(hdc, hpalDefault, 0);
    SelectPalette(hdc, hpalDefault, 0);

    for (ulIndex = 0; ulIndex < 20; ulIndex++)
    {
	ulPal = PALETTEINDEX(ulIndex);

	if (!(ulPal & 0x01000000))
	    DbgPrint("PALETTEINDEX failed to do it\n");

	hbr = CreateSolidBrush(PALETTEINDEX(ulIndex));
	hbrDefault = SelectObject(hdc, hbr);
	PatBlt(hdc, ulIndex * 20, 0, 20, 20, PATCOPY);
	SelectObject(hdc, hbrDefault);
	DeleteObject(hbr);

	GetPaletteEntries(hpalDefault, ulIndex, 1, (LPPALETTEENTRY) &ulPal);

	hbr = CreateSolidBrush(ulPal);
	hbrDefault = SelectObject(hdc, hbr);
	PatBlt(hdc, ulIndex * 20, 20, 20, 20, PATCOPY);
	SelectObject(hdc, hbrDefault);
	DeleteObject(hbr);

	GetPaletteEntries(hpalDefault, ulIndex, 1, (LPPALETTEENTRY) &palentry);

	hbr = CreateSolidBrush(PALETTERGB(palentry.peRed, palentry.peGreen, palentry.peBlue));
	hbrDefault = SelectObject(hdc, hbr);
	PatBlt(hdc, ulIndex * 20, 40, 20, 20, PATCOPY);
	SelectObject(hdc, hbrDefault);
	DeleteObject(hbr);
    }
}

/******************************Public*Routine******************************\
* vTestPal3 and vTestPal4
*
* Test some SetDIBitsToDevice stuff.
*
* History:
*  06-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

typedef struct _BITMAPINFO256
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD			     bmiColors[256];
} BITMAPINFO256;

BYTE ajBuffer[64*64];
BITMAPINFO256 bmi256;

VOID vTestPal3(HDC hdc)
{
    HBRUSH   hbrR, hbrG, hbrB;
    HDC hdc8;
    HBITMAP hbm8;

    if (GetDeviceCaps(hdc,BITSPIXEL) > 8)
        return;

    hbm8 = CreateCompatibleBitmap(hdc, 64, 64);
    hdc8 = CreateCompatibleDC(hdc);
    SelectObject(hdc8, hbm8);

    hbrR = CreateSolidBrush(RGB(255,0,0));
    hbrG = CreateSolidBrush(RGB(0,255,0));
    hbrB = CreateSolidBrush(RGB(0,0,255));

    SelectObject(hdc8, hbrR);
    PatBlt(hdc8, 0, 0, 64, 64, PATCOPY);
    SelectObject(hdc8, hbrG);
    PatBlt(hdc8, 16, 16, 32, 32, PATCOPY);
    SelectObject(hdc8, hbrB);
    PatBlt(hdc8, 24, 24, 16, 16, PATCOPY);

// See what the bitmap looks like.

    BitBlt(hdc, 0, 100, 64, 64, hdc8, 0, 0, SRCCOPY);

// Get the header

    bmi256.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi256.bmiHeader.biBitCount = 0;

    GetDIBits(hdc8, hbm8, 0, 64, (PBYTE) NULL, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

// Get the color table

    GetDIBits(hdc8, hbm8, 0, 64, (PBYTE) NULL, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

// Get the bits

    if (64 != GetDIBits(hdc8, hbm8, 0, 64, (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS))
	DbgPrint("The GetDIBits failed vTestPal3\n");

// Look at the bits.

    SetDIBitsToDevice(hdc, 64, 100, 64, 64, 0, 0, 0, 64,
		      (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

// Do them left half right half

    SetDIBitsToDevice(hdc, 128, 100, 32, 64, 0, 0, 0, 64,
		      (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdc, 160, 100, 32, 64, 32, 0, 0, 64,
		      (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

    DeleteDC(hdc8);
    DeleteObject(hbm8);
    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
}

VOID vTestPal4(HDC hdc)
{
    HBRUSH   hbrR, hbrG, hbrB;
    HDC hdc8;
    HBITMAP hbm4;
    int i;

    hbm4 = CreateBitmap(62, 62, 1, 4, NULL);
    hdc8 = CreateCompatibleDC(hdc);
    SelectObject(hdc8, hbm4);

    hbrR = CreateSolidBrush(RGB(255,0,0));
    hbrG = CreateSolidBrush(RGB(0,255,0));
    hbrB = CreateSolidBrush(RGB(0,0,255));

    SelectObject(hdc8, hbrR);
    PatBlt(hdc8, 0, 0, 64, 64, PATCOPY);
    SelectObject(hdc8, hbrG);
    PatBlt(hdc8, 16, 16, 32, 32, PATCOPY);
    SelectObject(hdc8, hbrB);
    PatBlt(hdc8, 24, 24, 16, 16, PATCOPY);

// See what the bitmap looks like.

    BitBlt(hdc, 0, 200, 64, 64, hdc8, 0, 0, SRCCOPY);

// Get the header

    bmi256.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi256.bmiHeader.biBitCount = 0;

    GetDIBits(hdc8, hbm4, 0, 64, (PBYTE) NULL, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);
    bmi256.bmiHeader.biBitCount = 8;

// Get the color table

    GetDIBits(hdc8, hbm4, 0, 64, (PBYTE) NULL, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

    if (bmi256.bmiHeader.biBitCount != 8)
	DbgPrint("Error bitcount wrong in vTestPal4\n");

// Get the bits

#if 0

    if (62 != (i = GetDIBits(hdc8, hbm4, 0, 62, (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS)))
	DbgPrint("The GetDIBits failed vTestPal4 %d\n",i);

    if (bmi256.bmiHeader.biBitCount != 8)
	DbgPrint("Error bitcount wrong in vTestPal4\n");
#endif

// Look at the bits.

    SetDIBitsToDevice(hdc, 64, 200, 64, 64, 0, 0, 0, 62,
		      (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

// Do them left half right half

    SetDIBitsToDevice(hdc, 128, 200, 32, 64, 0, 0, 0, 62,
		      (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

    SetDIBitsToDevice(hdc, 160, 200, 32, 64, 32, 0, 0, 62,
		      (PBYTE) ajBuffer, (LPBITMAPINFO) &bmi256, DIB_RGB_COLORS);

    DeleteDC(hdc8);
    DeleteObject(hbm4);
    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
}

/******************************Public*Routine******************************\
* vTestAnimatePalette
*
* This tests animating the palette.
*
* History:
*  26-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestAnimatePalette(HDC hdc, HPALETTE hpal)
{
    PALETTEENTRY peTemp;
    PALETTEENTRY palPalEntry[256];
    DWORD ulIndex, ulTemp;
    HPALETTE hpalTemp;

    hpalTemp = SelectPalette(hdc,hpal,0);
    RealizePalette(hdc);

    if (0 == GetPaletteEntries(hpal, 0, 256, palPalEntry))
	DbgPrint("GetPaletteEntries failed, return 0\n");

    if (palPalEntry[1].peFlags != PC_RESERVED)
	DbgPrint("GetPaletteEntries failed 1 flags\n");

    if (palPalEntry[1].peRed != 1)
	DbgPrint("GetPaletteEntries failed 1\n");

    if (palPalEntry[2].peFlags != PC_RESERVED)
	DbgPrint("GetPaletteEntries failed 2 flags\n");

    if (palPalEntry[2].peRed != 2)
	DbgPrint("GetPaletteEntries failed 2\n");

    for (ulIndex = 0; ulIndex < 256; ulIndex++)
    {
	peTemp = palPalEntry[0];

	for (ulTemp = 0; ulTemp < 255; ulTemp++)
	{
	    palPalEntry[ulTemp] =
	    palPalEntry[ulTemp + 1];
	}

	palPalEntry[255] = peTemp;

	AnimatePalette(hpal, 0, 256, palPalEntry);
    }

    SelectPalette(hdc,hpalTemp,0);
}

/******************************Public*Routine******************************\
* vPaintStripes
*
* Paints stripes of every index onto surface.
*
* History:
*  26-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vPaintStripes(HDC hdc, RECT *prcl)
{
    LOGPALETTE256 logPal256;
    DWORD ulTemp;
    HBRUSH hBrush, hOldBrush;
    HPALETTE hpalExplicit,hpalTemp;

    logPal256.palVersion    = 0x300;
    logPal256.palNumEntries = 256;

// Set up explicit palette.

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
	logPal256.palPalEntry[ulTemp].peRed	 = (BYTE)ulTemp;
	logPal256.palPalEntry[ulTemp].peGreen	 = 0;
	logPal256.palPalEntry[ulTemp].peBlue	 = 0;
	logPal256.palPalEntry[ulTemp].peFlags	 = PC_EXPLICIT;
    }

    hpalExplicit = CreatePalette((LOGPALETTE *) &logPal256);
    hpalTemp = SelectPalette(hdc,hpalExplicit,0);
    RealizePalette(hdc);

// Paint Surface with all colors.

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
	hBrush = CreateSolidBrush(PALETTEINDEX(ulTemp));
	hOldBrush = SelectObject(hdc,hBrush);

	PatBlt(hdc,
	       (((prcl->right - prcl->left) * ulTemp) / 256),
	       0,
	       (((prcl->right - prcl->left) / 256) + 3) ,
	       (prcl->bottom - prcl->top),
	       PATCOPY);

	SelectObject(hdc, hOldBrush);
	DeleteObject(hBrush);
    }

    SelectPalette(hdc,hpalTemp,0);
    DeleteObject(hpalExplicit);
}

VOID vTestPal5(HDC hdc, RECT *prcl)
{
    LOGPALETTE256 logPal256;
    HPALETTE hpalR;
    DWORD ulTemp;

    vPaintStripes(hdc, prcl);

    logPal256.palVersion = 0x300;
    logPal256.palNumEntries = 256;

// Set up Red palette.

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
	logPal256.palPalEntry[ulTemp].peRed	 = (BYTE)ulTemp;
	logPal256.palPalEntry[ulTemp].peGreen	 = 0;
	logPal256.palPalEntry[ulTemp].peBlue	 = 0;
	logPal256.palPalEntry[ulTemp].peFlags	 = PC_RESERVED;
    }

    hpalR = CreatePalette((LOGPALETTE *) &logPal256);
    vTestAnimatePalette(hdc, hpalR);
    DeleteObject(hpalR);
}

/******************************Public*Routine******************************\
* vTestXlates
*
* Test creation deletion and use of palette xlates.
*
* History:
*  26-Jun-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestXlates(HDC hdc, RECT *prcl)
{
    HPALETTE ahpal[4];
    HPALETTE hPalOld;
    DWORD ulTemp;

    LOGPALETTE256 alog256[4];

    alog256[0].palVersion = 0x300;
    alog256[0].palNumEntries = 256;
    alog256[1].palVersion = 0x300;
    alog256[1].palNumEntries = 256;
    alog256[2].palVersion = 0x300;
    alog256[2].palNumEntries = 256;
    alog256[3].palVersion = 0x300;
    alog256[3].palNumEntries = 256;

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
	alog256[0].palPalEntry[ulTemp].peRed	  = (BYTE)ulTemp;
	alog256[0].palPalEntry[ulTemp].peBlue	  = 0;
	alog256[0].palPalEntry[ulTemp].peGreen	  = 0;
	alog256[0].palPalEntry[ulTemp].peFlags	  = 0;

	alog256[1].palPalEntry[ulTemp].peRed	  = 0;
	alog256[1].palPalEntry[ulTemp].peBlue	  = (BYTE)ulTemp;
	alog256[1].palPalEntry[ulTemp].peGreen	  = 0;
	alog256[1].palPalEntry[ulTemp].peFlags	  = 0;

	alog256[2].palPalEntry[ulTemp].peRed	  = 0;
	alog256[2].palPalEntry[ulTemp].peBlue	  = 0;
	alog256[2].palPalEntry[ulTemp].peGreen	  = (BYTE)ulTemp;
	alog256[2].palPalEntry[ulTemp].peFlags	  = PC_RESERVED;

	alog256[3].palPalEntry[ulTemp].peRed	  = (BYTE)ulTemp;
	alog256[3].palPalEntry[ulTemp].peBlue	  = (BYTE)ulTemp;
	alog256[3].palPalEntry[ulTemp].peGreen	  = (BYTE)ulTemp;
	alog256[3].palPalEntry[ulTemp].peFlags	  = PC_RESERVED;
    }

    ahpal[0] = CreatePalette((LOGPALETTE *) &alog256[0]);
    ahpal[1] = CreatePalette((LOGPALETTE *) &alog256[1]);
    ahpal[2] = CreatePalette((LOGPALETTE *) &alog256[2]);
    ahpal[3] = CreatePalette((LOGPALETTE *) &alog256[3]);

    hPalOld = SelectPalette(hdc,ahpal[0],0);

    for (ulTemp = 0; ulTemp < 20; ulTemp++)
    {
    	SelectPalette(hdc, ahpal[ulTemp % 4], 0);
    	RealizePalette(hdc);
    	UpdateColors(hdc);
    	SetPaletteEntries(ahpal[ulTemp % 4], 0, 256, alog256[ulTemp % 4].palPalEntry);
    	RealizePalette(hdc);
    	UpdateColors(hdc);
    }

    SelectPalette(hdc,hPalOld,0);

    DeleteObject(ahpal[0]);
    DeleteObject(ahpal[1]);
    DeleteObject(ahpal[2]);
    DeleteObject(ahpal[3]);
}

/******************************Public*Routine******************************\
* vDrawStuff6
*
* Draw picture on a surface.
*
* History:
*  02-Jan-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void vDrawStuff6(HDC hdc, RECT *prclBound)
{
    DWORD dwTemp;
    HBRUSH hBrush, hOldBrush;

// Paint the PALETTEINDEX stripes.

    vPaintStripes(hdc, prclBound);

// Paint PALETTEINDEX stripes.

    for (dwTemp = 0; dwTemp < 256; dwTemp++)
    {
        hBrush = CreateSolidBrush(PALETTEINDEX(dwTemp));
	hOldBrush = SelectObject(hdc,hBrush);

	PatBlt(hdc,
	       (((prclBound->right - prclBound->left) * dwTemp) / 256),
               75,
	       (((prclBound->right - prclBound->left) / 256) + 3),
               75,
	       PATCOPY);

	SelectObject(hdc, hOldBrush);
	DeleteObject(hBrush);
    }

// Paint the RGB stripes.

    for (dwTemp = 0; dwTemp < 256; dwTemp++)
    {
	hBrush = CreateSolidBrush(RGB(dwTemp,0,0));
	hOldBrush = SelectObject(hdc,hBrush);

	PatBlt(hdc,
	       (((prclBound->right - prclBound->left) * dwTemp) / 256),
               150,
	       (((prclBound->right - prclBound->left) / 256) + 3),
               75,
	       PATCOPY);

	SelectObject(hdc, hOldBrush);
	DeleteObject(hBrush);
    }

// Paint the PALETTERGB stripes.

    for (dwTemp = 0; dwTemp < 256; dwTemp++)
    {
	hBrush = CreateSolidBrush(PALETTERGB(dwTemp,0,0));
	hOldBrush = SelectObject(hdc,hBrush);

	PatBlt(hdc,
	       (((prclBound->right - prclBound->left) * dwTemp) / 256),
               225,
	       (((prclBound->right - prclBound->left) / 256) + 3),
               75,
	       PATCOPY);

	SelectObject(hdc, hOldBrush);
	DeleteObject(hBrush);
    }
}

/******************************Public*Routine******************************\
* vTestPal6
*
* This is a test that also runs under Win3.1
*
* History:
*  02-Jan-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void vTestPal6(HWND hwnd, HDC hdc)
{
    RECT rclBound;
    LOGPALETTE256 logPal256;
    HPALETTE hpalR, hpalTemp, hpalTemp1;
    HDC hdcMem;
    HBITMAP hbmMem,hbmTemp;
    DWORD dwTemp;

// Get the bounding rectangle.

    GetClientRect(hwnd, &rclBound);

// Create Bitmap half size of client area.

    hdcMem = CreateCompatibleDC(hdc);
    hbmMem = CreateCompatibleBitmap(hdc, rclBound.right - rclBound.left, 300);
    hbmTemp = SelectObject(hdcMem, hbmMem);

// Set up Red palette.

    logPal256.palVersion = 0x300;
    logPal256.palNumEntries = 256;

    for (dwTemp = 0; dwTemp < 256; dwTemp++)
    {
	logPal256.palPalEntry[dwTemp].peRed	 = (BYTE) dwTemp;
	logPal256.palPalEntry[dwTemp].peGreen	 = 0;
	logPal256.palPalEntry[dwTemp].peBlue	 = 0;
	logPal256.palPalEntry[dwTemp].peFlags	 = PC_RESERVED;
    }

    hpalR = CreatePalette((LOGPALETTE *) &logPal256);

    hpalTemp = SelectPalette(hdc, hpalR, 0);
    RealizePalette(hdc);
    vDrawStuff6(hdc, &rclBound);

    hpalTemp1 = SelectPalette(hdcMem, hpalR, 0);
    RealizePalette(hdcMem);
    vDrawStuff6(hdcMem, &rclBound);

    BitBlt(hdc, 0, 300, rclBound.right - rclBound.left, 300, hdcMem, 0, 0, SRCCOPY);

// Animate the palette.

    vTestAnimatePalette(hdc, hpalR);

// Clean up.

    SelectObject(hdcMem, hbmTemp);
    SelectPalette(hdc, hpalTemp,0);
    SelectPalette(hdc, hpalTemp1,0);

    DeleteDC(hdcMem);
    DeleteObject(hpalR);
    DeleteObject(hbmMem);
}

/******************************Public*Routine******************************\
* vTestPalettes
*
* Does various tests of palette code.
*
* History:
*  31-Aug-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestPalettes(HWND hwnd, HDC hdc, RECT* prcl)
{
    DWORD ul1,ul2;

    hwnd;

    PatBlt(hdc, 0, 0, 10000, 10000, WHITENESS);

    vTestPal5(hdc, prcl);
    vTestPal1();
    vTestPal2(hdc);
    vTestPal3(hdc);
    vTestPal4(hdc);
    vTestXlates(hdc,prcl);
    vTestPal6(hwnd, hdc);

    ul1 = GetSystemPaletteEntries(hdc, 0,0, NULL);
    ul2 = GetDeviceCaps(hdc, SIZEPALETTE);

    if (ul1 != ul2)
	DbgPrint("vTestPalettes failed on system size %lu %lu\n", ul1, ul2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftmaze.c ===
/******************************Module*Header*******************************\
* Module Name: ftmaze.c
*
* Example test.
*
* Created: 26-May-1991 12:38:18
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define ROOM_SIZE   10
#define WALL_SIZE   1

#define DOT_START   ((ROOM_SIZE + 1) / 2)
#define DOT_SIZE    3

LONG glSeed = 0;
LONG glJump;

LOGFONT lfnt;	       // logical font description
HFONT	hfont;	       // handle to font

#define MAX_MAZE_SIZE (1024/10) * (768/10)

int  giMaze[MAX_MAZE_SIZE];
int  giPath[MAX_MAZE_SIZE];

BOOL bBuild(HDC, RECT*);
void vTravel(HDC, RECT*);
void vDrawBox(HDC, HBRUSH, int, int, int, int, int);

// Global handles to color brushes

HBRUSH  ghbrushRed;
HBRUSH  ghbrushGreen;
HBRUSH  ghbrushBlue;
HBRUSH  ghbrushWhite;
HBRUSH  ghbrushBlack;

ULONG	argb[4] = {0x00ff0000, 0x0000ff00, 0x000000ff, 0x00ff00ff};

BOOL bBuild(HDC hdc, RECT *prc);
void vTravel(HDC hdc, RECT *prc);

/******************************Public*Routine******************************\
* vInitMaze
*
* Creates a handle to hfont.
*
* History:
*  27-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vInitMaze(VOID)
{
// Create a logical font

    memset(&lfnt, 0, sizeof(lfnt)); // zero out the structure!!
    lfnt.lfEscapement = 0;
    lfnt.lfUnderline  = 0;
    lfnt.lfStrikeOut  = 0;

// Create a logical font

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
	DbgPrint("Logical font creation failed.\n");
    }
}

/******************************Public*Routine******************************\
* vMazeTest
*
* Example Test procedure.
*
* History:
*  26-May-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

//!!! Should create and delete font in this module.  Get rid of global
//!!! variables, every test should clean up after itself.

VOID vTestMaze(HWND hwnd, HDC hdc, PRECT prclClient)
{
    HFONT   hfontOriginal;		// handle of font originally in DC
    LARGE_INTEGER    time;
    HBRUSH  hbrushOrg;

// wait for WM_PAINT to be hit


    NtQuerySystemTime(&time);
    glSeed = time.LowPart;

// create the brushes

    ghbrushRed	 = CreateSolidBrush(RGB(0xff,0x00,0x00));
    ghbrushGreen = CreateSolidBrush(RGB(0x00,0xff,0x00));
    ghbrushBlue  = CreateSolidBrush(RGB(0x00,0x00,0xff));
    ghbrushWhite = CreateSolidBrush(RGB(0xff,0xff,0xff));
    ghbrushBlack = CreateSolidBrush(RGB(0x00,0x00,0x00));

// Select font into DC

    hfontOriginal = (HFONT) SelectObject(hdc, hfont);
    hbrushOrg = SelectObject(hdc, ghbrushRed);

// Set text alignment

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

    if (bBuild(hdc, prclClient))
	vTravel(hdc, prclClient);

    SelectObject(hdc, hfontOriginal);
    SelectObject(hdc, hbrushOrg);

    DeleteObject(ghbrushRed);
    DeleteObject(ghbrushGreen);
    DeleteObject(ghbrushBlue);
    DeleteObject(ghbrushWhite);
    DeleteObject(ghbrushBlack);
}

////////////////////////////
// All the maze functions //
////////////////////////////

LONG lRandom()
{
    glSeed *= 69069;
    glSeed++;
    return(glSeed);
}

HRGN hrgnCircle(LONG xC, LONG yC, LONG lRadius)
{
    HRGN    hrgn, hrgnTmp;
    LONG    x = 0;
    LONG    y = lRadius;
    LONG    d = 3 - 2 * lRadius;

    hrgn = CreateRectRgn(0, 0, 0, 0);
    if (hrgn == (HRGN) 0)
        return(hrgn);

    hrgnTmp = CreateRectRgn(0, 0, 0, 0);
    if (hrgnTmp == (HRGN) 0)
    {
        DeleteObject(hrgn);
        return((HRGN) 0);
    }

    while (x < y)
    {
        if (d < 0)
            d = d + 4 * x + 6;
        else
        {
            SetRectRgn(hrgnTmp, xC - x, yC - y, xC + x + 1, yC + y + 1);
            if (CombineRgn(hrgn, hrgn, hrgnTmp, RGN_OR) == ERROR)
            {
                DeleteObject(hrgn);
                DeleteObject(hrgnTmp);
                return((HRGN) 0);
            }

            SetRectRgn(hrgnTmp, xC - y, yC - x, xC + y + 1, yC + x + 1);
            if (CombineRgn(hrgn, hrgn, hrgnTmp, RGN_OR) == ERROR)
            {
                DeleteObject(hrgn);
                DeleteObject(hrgnTmp);
                return((HRGN) 0);
            }

            d = d + 4 * (x - y) + 10;
            y--;
        }

        x++;
    }

    if (x == y)
    {
        SetRectRgn(hrgnTmp, xC - x, yC - y, xC + x + 1, yC + y + 1);
        if (CombineRgn(hrgn, hrgn, hrgnTmp, RGN_OR) == ERROR)
        {
            DeleteObject(hrgn);
            DeleteObject(hrgnTmp);
            return((HRGN) 0);
        }
    }

    DeleteObject(hrgnTmp);
    return(hrgn);
}

void vNumber(HDC hdc, LONG l, LONG x, LONG y)
{
    LONG    lPOT;
    LONG    lDigit;
    CHAR    ach[12];            // Build string here
    LONG    cch = 0;            // Length of the string

    if (!l)
    {
        ach[cch++] = '0';
        goto out;
    }

    if (l < 0)
    {
        ach[cch++] = '-';
        l = -l;
    }

    lPOT = 1;
    while (lPOT <= l)
        lPOT *= 10;

    while (lPOT > 1)
    {
        lPOT /= 10;
        lDigit = l / lPOT;
        l -= (lDigit * lPOT);
        ach[cch++] = (CHAR)('0' + lDigit);
    }

out:
        TextOut(hdc, x, y, ach, cch);

}

void vClear(HDC hdc, int iPos, int iDir, int cColume)
{
    LONG    x, y;

    y = (iPos / cColume) * ROOM_SIZE;
    x = (iPos % cColume) * ROOM_SIZE;

    switch(iDir)
    {
    case 0:
        BitBlt(hdc,
               x + WALL_SIZE,
               y - WALL_SIZE,
               ROOM_SIZE - (2 * WALL_SIZE),
               2 * WALL_SIZE,
               (HDC) 0, 0, 0, BLACKNESS);
        break;
    case 1:
        BitBlt(hdc,
               x + ROOM_SIZE - WALL_SIZE,
               y + WALL_SIZE,
               2 * WALL_SIZE,
               ROOM_SIZE - (2 * WALL_SIZE),
               (HDC) 0, 0, 0, BLACKNESS);
        break;
    case 2:
        BitBlt(hdc,
               x + WALL_SIZE,
               y + ROOM_SIZE - WALL_SIZE,
               ROOM_SIZE - (2 * WALL_SIZE),
               2 * WALL_SIZE,
               (HDC) 0, 0, 0, BLACKNESS);
        break;
    case 3:
        BitBlt(hdc,
               x - WALL_SIZE,
               y + WALL_SIZE,
               2 * WALL_SIZE,
               ROOM_SIZE - (2 * WALL_SIZE),
               (HDC) 0, 0, 0, BLACKNESS);
        break;
    }
}

#define NORTH       0x01
#define EAST        0x02
#define SOUTH       0x04
#define WEST        0x08
#define VIRGIN      0x10

BOOL bBuild(HDC hdc, RECT *prc)
{
    HRGN    hrgn;
    int     i;
    int     iPos;
    int     iScan;
    int     cLeft;
    int     iTry;
    int     cTry;
    int     cStuck;
    BOOL    bStuck;
    HBRUSH  hbrushOld;

    int     cColume = prc->right / ROOM_SIZE;
    int     cRow = prc->bottom / ROOM_SIZE;
    int     cMazeSize = cColume * cRow;


    if ((prc->bottom < ROOM_SIZE) || (prc->right < ROOM_SIZE))
    {
        DbgPrint("Client area too small to run maze\n");
        return(FALSE);
    }

    if ((hrgn = CreateRectRgn(0, 0, prc->right, prc->bottom)) == (HRGN) NULL)
    {
	DbgPrint("ERROR bBuild CreateRectRgn failed\n");
	return(FALSE);
    }

    if (SelectClipRgn(hdc, hrgn) == ERROR)
    {
	DbgPrint("ERROR bBuild SelectClipRgn failed\n");
        DeleteObject(hrgn);
        return(FALSE);
    }

    DeleteObject(hrgn);

    BitBlt(hdc, 0, 0, prc->right, prc->bottom, (HDC) 0, 0, 0, BLACKNESS);

    if ((hrgn = CreateRectRgn(0, 0, prc->right, ROOM_SIZE)) == (HRGN) NULL)
        return(FALSE);

    if (SelectClipRgn(hdc, hrgn) == ERROR)
    {
	DbgPrint("ERROR bBuild SelectClipRgn failed\n");
        DeleteObject(hrgn);
        return(FALSE);
    }

    DeleteObject(hrgn);

    for (i = 0; i < cColume; i++)
        if (ExcludeClipRect(hdc,
                            ROOM_SIZE * i + WALL_SIZE,
                            WALL_SIZE,
                            ROOM_SIZE * i + ROOM_SIZE - WALL_SIZE,
			    ROOM_SIZE - WALL_SIZE) == ERROR)
	{
	    DbgPrint("ERROR bBuild excludeClipRgn failed\n");
	    return(FALSE);
	}

    hbrushOld = SelectObject(hdc,ghbrushGreen);
    for (i = 0; i < cRow; i++)
    {
        BitBlt(hdc, 0, 0, prc->right, prc->bottom, (HDC) 0, 0, 0, PATCOPY);

        if (OffsetClipRgn(hdc, 0, ROOM_SIZE) == ERROR)
            return(FALSE);
    }
    SelectObject(hdc,hbrushOld);

    if (SelectClipRgn(hdc, (HRGN) 0) == ERROR)
    {
	DbgPrint("ERROR bBuild SelectClipRgn failed\n");
	return(FALSE);
    }

    glJump = 0;

    for (i = 0; i < cMazeSize; i++)
        giMaze[i] = NORTH | EAST | SOUTH | WEST | VIRGIN;

    cStuck = 512;
    iPos = (lRandom() & 0x7fffffff) % cMazeSize;
    cLeft = cMazeSize - 1;
    giMaze[iPos] ^= VIRGIN;

    while (cLeft)
    {
        do
        {
            cTry = (cStuck >> 9) + ((lRandom() >> 30) & 3);
            iTry = (lRandom() >> 30) & 3;
            bStuck = TRUE;

            while(bStuck && cTry)
            {
                switch(iTry)
                {
                case 0:
                    if ((iPos >= cColume) &&
                        (giMaze[iPos - cColume] & VIRGIN))
                    {
                        vClear(hdc, iPos, iTry, cColume);
                        giMaze[iPos] ^= NORTH;
                        iPos -= cColume;
                        giMaze[iPos] ^= SOUTH;
                        bStuck = FALSE;
                    }
                    break;
                case 1:
                    if (((iPos % cColume) != (cColume - 1)) &&
                        (giMaze[iPos + 1] & VIRGIN))
                    {
                        vClear(hdc, iPos, iTry, cColume);
                        giMaze[iPos] ^= EAST;
                        iPos++;
                        giMaze[iPos] ^= WEST;
                        bStuck = FALSE;
                    }
                    break;
                case 2:
                    if ((iPos < (cMazeSize - cColume)) &&
                        (giMaze[iPos + cColume] & VIRGIN))
                    {
                        vClear(hdc, iPos, iTry, cColume);
                        giMaze[iPos] ^= SOUTH;
                        iPos += cColume;
                        giMaze[iPos] ^= NORTH;
                        bStuck = FALSE;
                    }
                    break;
                case 3:
                    if ((iPos % cColume) &&
                        (giMaze[iPos - 1] & VIRGIN))
                    {
                        vClear(hdc, iPos, iTry, cColume);
                        giMaze[iPos] ^= WEST;
                        iPos--;
                        giMaze[iPos] ^= EAST;
                        bStuck = FALSE;
                    }
                    break;
                }

                iTry = (iTry + 1) & 3;
                cTry--;
            }

            if (!bStuck)
            {
                giMaze[iPos] ^= VIRGIN;
                cLeft--;
            }
        } while (!bStuck);

        if (!cLeft)
            return(TRUE);

    // We're stuck, find someplace we've been before and continue
    // building the path from there.

        glJump++;

    // Make it less likely we'll get stuck again.

        cStuck++;

        iScan = (lRandom() & 0x7fffffff) % cMazeSize;

        do
        {
            do
            {
                iScan = (iScan + 1) % cMazeSize;
            } while (giMaze[iScan] & VIRGIN);

        // OK, we've found a likely prospect make sure its next to
        // someplace we've never been

            if ((iScan >= cColume) &&
                (giMaze[iScan - cColume] & VIRGIN))
                bStuck = FALSE;

            if (((iScan % cColume) != (cColume - 1)) &&
                (giMaze[iScan + 1] & VIRGIN))
                bStuck = FALSE;

            if ((iScan < (cMazeSize - cColume)) &&
                (giMaze[iScan + cColume] & VIRGIN))
                bStuck = FALSE;

            if ((iScan % cColume) &&
                (giMaze[iScan - 1] & VIRGIN))
                bStuck = FALSE;

        } while (bStuck);

        // Put ourselves in the new position.

        iPos = iScan;
    }

    return(TRUE);
}

void vTravel(HDC hdc, RECT *prc)
{
    HRGN    hrgn;
    int     i;
    int     iPos;
    int     iPath;
    int     iFinal;
    LONG    lVisit = 0;
    LONG    lStart;
    LONG    lFinal;
    BOOL    bRetAll = TRUE;

    HBRUSH  hbrushOld;
    int     iBkModeOld;
    int     cColume = prc->right / ROOM_SIZE;
    int     cRow = prc->bottom / ROOM_SIZE;
    int     cMazeSize = cColume * cRow;
    int     hStart, vStart;


    hrgn = hrgnCircle(DOT_START, DOT_START, DOT_SIZE);
    if (hrgn == (HRGN) NULL)
        return;

    if (SelectClipRgn(hdc, hrgn) == ERROR)
        return;

    DeleteObject(hrgn);

    lStart = (lRandom() >> 30) & 3;
    switch (lStart)
    {
    case 0:
        iPos = 0;
        break;
    case 1:
        iPos = cColume - 1;
        OffsetClipRgn(hdc, ROOM_SIZE * (cColume - 1), 0);
        break;
    case 2:
        iPos = cMazeSize - 1;
        OffsetClipRgn(hdc, ROOM_SIZE * (cColume - 1), ROOM_SIZE * (cRow - 1));
        break;
    case 3:
        iPos = cMazeSize - cColume;
        OffsetClipRgn(hdc, 0, ROOM_SIZE * (cRow - 1));
        break;
    }

    do
    {
        lFinal = (lRandom() >> 30) & 3;
    }
    while (lFinal == lStart);

    switch (lFinal)
    {
    case 0:
        iFinal = 0;
        break;
    case 1:
        iFinal = cColume - 1;
        break;
    case 2:
        iFinal = cMazeSize - 1;
        break;
    case 3:
        iFinal = cMazeSize - cColume;
        break;
    }

    iPath = 0;
    giPath[iPath] = 0;

start:
    hbrushOld = SelectObject(hdc,ghbrushWhite);
    BitBlt(hdc, 0, 0, prc->right, prc->bottom, (HDC) 0, 0, 0, PATCOPY);
    SelectObject(hdc,hbrushOld);

    giMaze[iPos] |= VIRGIN;
    lVisit++;

    while (iPos != iFinal)
    {
        i = giPath[iPath];
        switch(i)
        {
        case 0:
            if (!(giMaze[iPos] & NORTH) &&
                !(giMaze[iPos - cColume] & VIRGIN))
            {
                OffsetClipRgn(hdc, 0, -ROOM_SIZE);
                iPos -= cColume;
                giPath[++iPath] = 0;
                goto start;
            }
            giPath[iPath] = 1;

        case 1:
            if (!(giMaze[iPos] & EAST) &&
                !(giMaze[iPos + 1] & VIRGIN))
            {
                OffsetClipRgn(hdc, ROOM_SIZE, 0);
                iPos++;
                giPath[++iPath] = 0;
                goto start;
            }
            giPath[iPath] = 2;

        case 2:
            if (!(giMaze[iPos] & SOUTH) &&
                !(giMaze[iPos + cColume] & VIRGIN))
            {
                OffsetClipRgn(hdc, 0, ROOM_SIZE);
                iPos += cColume;
                giPath[++iPath] = 0;
                goto start;
            }
            giPath[iPath] = 3;

        case 3:
            if (!(giMaze[iPos] & WEST) &&
                !(giMaze[iPos - 1] & VIRGIN))
            {
                OffsetClipRgn(hdc, -ROOM_SIZE, 0);
                iPos--;
                giPath[++iPath] = 0;
                goto start;
            }
            giPath[iPath] = 4;
        }


    // mark where we've been

        hbrushOld = SelectObject(hdc,ghbrushBlack);
        BitBlt(hdc, 0, 0, prc->right, prc->bottom, (HDC) 0, 0, 0, PATCOPY);
        SelectObject(hdc,ghbrushBlue);
        BitBlt(hdc, 
              (LONG)((iPos % cColume) * ROOM_SIZE + DOT_START - 1),
              (LONG)((iPos / cColume) * ROOM_SIZE + DOT_START - 1),
                2, 2, (HDC) 0, 0, 0, PATCOPY);
        SelectObject(hdc,hbrushOld);

        giMaze[iPos] ^= VIRGIN;

        switch(giPath[--iPath])
        {
        case 0:
            iPos += cColume;
            OffsetClipRgn(hdc, 0, ROOM_SIZE);
            break;
        case 1:
            iPos--;
            OffsetClipRgn(hdc, -ROOM_SIZE, 0);
            break;
        case 2:
            iPos -= cColume;
            OffsetClipRgn(hdc, 0, -ROOM_SIZE);
            break;
        case 3:
            iPos++;
            OffsetClipRgn(hdc, ROOM_SIZE, 0);
            break;
        }

        giPath[iPath]++;
    }


    if (TRUE)
    {
        iPath++;
        SelectClipRgn(hdc, (HRGN) 0);

    // flash the screen to show we finished

        for (i = 0; i < 20; i++)
            BitBlt(hdc, 0, 0, prc->right, prc->bottom, (HDC) 0, 0, 0, DSTINVERT);

        hbrushOld = SelectObject(hdc,ghbrushBlack);

        hStart = (prc->right - 280) / 2;
        vStart = (prc->bottom -160) / 2;

        if (hStart < 0)
            hStart = 0;

        if (vStart < 0)
            vStart = 0;

        BitBlt(hdc, hStart - 2, vStart - 2, 284, 164, (HDC) 0, 0, 0, PATCOPY);
        vDrawBox(hdc, ghbrushRed, hStart, vStart, 280, 160, 2);
        vDrawBox(hdc, ghbrushWhite, hStart+4, vStart+4, 272, 150, 2);
        vDrawBox(hdc, ghbrushBlue, hStart+8, vStart+8, 264, 142, 2);

        SelectObject(hdc,hbrushOld);

        SetTextColor(hdc, argb[glJump & 3]);
        SetROP2(hdc,R2_COPYPEN);
        iBkModeOld = SetBkMode(hdc,TRANSPARENT);

        bRetAll &= TextOut(hdc, hStart+16, vStart+20, "       Maze statistics  ", 24);
        bRetAll &=TextOut(hdc, hStart+16, vStart+60, "Jumps needed to create: ", 24);
        vNumber(hdc, glJump, hStart+216, vStart+60);
        bRetAll &=TextOut(hdc, hStart+16, vStart+90, "Rooms visited to solve: ", 24);
        vNumber(hdc, lVisit, hStart+216, vStart+90);
        bRetAll &=TextOut(hdc, hStart+16, vStart+120, "Path length of solution:", 24);
        vNumber(hdc, (LONG) iPath, hStart+216, vStart+120);
        SetBkMode(hdc,iBkModeOld);

        if (!bRetAll)
            DbgPrint("vTravel: One or more TextOut calls failed\n");

	GdiFlush();
        vSleep(1);
    }
}

void vDrawBox(HDC hdc, HBRUSH hbr, int x, int y, int w, int h, int size)

{
    HBRUSH  hbrOld;

    hbrOld = SelectObject(hdc,hbr);

    BitBlt(hdc, x, y, w, size, (HDC) 0, 0, 0, PATCOPY);
    BitBlt(hdc, x + w, y, size, h + size, (HDC) 0, 0, 0, PATCOPY);
    BitBlt(hdc, x, y + h, w, size, (HDC) 0, 0, 0, PATCOPY);
    BitBlt(hdc, x, y, size, h, (HDC) 0, 0, 0, PATCOPY);

    SelectObject(hdc,hbrOld);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftplg.c ===
/******************************Module*Header*******************************\
* Module Name: ftplg.c
*
* Test the PlgBlt functionality
*
* Created: 16-Jan-1992 10:28:57
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
* RotatePoints
*
* Rotates the points around.
*
* History:
*  28-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID RotatePoints(PPOINT aPoint, ULONG ul)
{
    POINT ptl;

    aPoint[0].x += ul;
    aPoint[1].x += ul;
    aPoint[2].x += ul;
    aPoint[3].x += ul;

    ptl = aPoint[0];
    aPoint[0] = aPoint[1];  // A = B
    aPoint[1] = aPoint[3];  // B = D
    aPoint[3] = aPoint[2];  // D = C
    aPoint[2] = ptl;        // C = A
}

/******************************Public*Routine******************************\
* vTestPlg1
*
* Test stretching and blting of 32/pel bitmaps.
*
* History:
*  03-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestPlg1(HDC hdc)
{
    HDC     hdcPat;
    HBITMAP hbmPat;
    HBRUSH  hbrR, hbrG, hbrB;
    ULONG   ul1;
    POINT   aPoint[4];

    PatBlt(hdc, -30, -30, 20000, 20000, WHITENESS);

    hdcPat = CreateCompatibleDC(hdc);
    hbmPat = CreateBitmap(100, 100, 1, 4, NULL);
    SelectObject(hdcPat, hbmPat);
    hbrR = CreateSolidBrush(RGB(255,0,0));
    hbrG = CreateSolidBrush(RGB(0,255,0));
    hbrB = CreateSolidBrush(RGB(0,0,255));

    SelectObject(hdcPat, hbrR);
    PatBlt(hdcPat, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdcPat, hbrG);
    PatBlt(hdcPat, 30, 60, 40, 40, PATCOPY);
    SelectObject(hdcPat, hbrB);
    PatBlt(hdcPat, 20, 0, 60, 10, PATCOPY);

    BitBlt(hdc, 0, 0, 100, 100, hdcPat, 0, 0, SRCCOPY);

    SetStretchBltMode(hdc, COLORONCOLOR);

    aPoint[0].x = 100;
    aPoint[0].y = 0;

    aPoint[1].x = 200;
    aPoint[1].y = 0;

    aPoint[2].x = 100;
    aPoint[2].y = 100;

    aPoint[3].x = 200;
    aPoint[3].y = 100;

    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,101);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,101);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,101);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);

    aPoint[0].x = 0;
    aPoint[0].y = 50;

    aPoint[1].x = 50;
    aPoint[1].y = 0;

    aPoint[2].x = 50;
    aPoint[2].y = 100;

    aPoint[3].x = 100;
    aPoint[3].y = 50;

    aPoint[0].y += 100;
    aPoint[1].y += 100;
    aPoint[2].y += 100;
    aPoint[3].y += 100;

    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,101);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,101);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,101);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);

    aPoint[0].x = 0;
    aPoint[0].y = 100;

    aPoint[1].x = 100;
    aPoint[1].y = 0;

    aPoint[2].x = 100;
    aPoint[2].y = 200;

    aPoint[3].x = 200;
    aPoint[3].y = 100;

    aPoint[0].y += 200;
    aPoint[1].y += 200;
    aPoint[2].y += 200;
    aPoint[3].y += 200;

    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,201);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,201);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);
    RotatePoints(aPoint,201);
    PlgBlt(hdc, aPoint, hdcPat, 0, 0, 100, 100, (HBITMAP) 0, 0, 0);

    DeleteDC(hdcPat);
    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbrB);
    DeleteObject(hbmPat);
}

/******************************Public*Routine******************************\
* vTestBW
*
* Test the black/white blting functionality.
*
* History:
*  27-Jan-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestBW(HDC hdc)
{
    HDC hdc1,hdc2,hdc3;
    HBITMAP hbm1,hbm2,hbm3;
    HBRUSH hbrBlack,hbrWhite;
    ULONG ulTemp;

    hdc1 = CreateCompatibleDC(hdc);
    hdc2 = CreateCompatibleDC(hdc);

    if ((hdc1 == (HDC) 0) ||
	(hdc2 == (HDC) 0))
    {
	DbgPrint("vTestBW failed CreateDC\n");
	return;
    }

    hbm1 = CreateBitmap(100,100,1,1,NULL);
    hbm2 = CreateBitmap(100,100,1,1,NULL);

    if ((hbm1 == (HBITMAP) 0) ||
	(hbm2 == (HBITMAP) 0))
    {
	DbgPrint("vTestBW failed CreateBitmap\n");
	return;
    }

    if (SelectObject(hdc1, hbm1) != SelectObject(hdc2, hbm2))
    {
	DbgPrint("vTestBW SelectObject on hdc's failed\n");
	return;
    }

// Check if we invert correctly.

    PatBlt(hdc1,0,0,100,100,WHITENESS);
    PatBlt(hdc2,0,0,100,100,BLACKNESS);
    PatBlt(hdc1,0,0,100,100,DSTINVERT);
    PatBlt(hdc2,0,0,100,100,DSTINVERT);

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0)
	    DbgPrint("1GetPixel failed vTestBW\n");

	if (GetPixel(hdc2,10,ulTemp) != 0xFFFFFF)
	    DbgPrint("2GetPixel failed vTestBW\n");
    }

// Check if we do white and source copy correctly

    PatBlt(hdc1,0,0,100,100,WHITENESS);
    BitBlt(hdc2,0,0,100,100,hdc1,0,0,SRCCOPY);

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0xFFFFFF)
	    DbgPrint("3GetPixel failed vTestBW\n");

	if (GetPixel(hdc2,10,ulTemp) != 0xFFFFFF)
	    DbgPrint("4GetPixel failed vTestBW\n");
    }

// Check if we do black and source copy correctly

    PatBlt(hdc1,0,0,100,100,BLACKNESS);
    BitBlt(hdc2,0,0,100,100,hdc1,0,0,SRCCOPY);

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0)
	    DbgPrint("5GetPixel failed vTestBW\n");

	if (GetPixel(hdc2,10,ulTemp) != 0)
	    DbgPrint("6GetPixel failed vTestBW\n");
    }

// Check if we do a funny rop with S and D correctly.

    PatBlt(hdc1,0,0,100,100,WHITENESS);
    PatBlt(hdc2,0,0,100,100,WHITENESS);
    BitBlt(hdc2,0,0,100,100,hdc1,0,0,NOTSRCCOPY);

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0x00FFFFFF)
	    DbgPrint("7GetPixel failed vTestBW\n");

	if (GetPixel(hdc2,10,ulTemp) != 0)
	    DbgPrint("8GetPixel failed vTestBW\n");
    }

// Check if we do Pattern and Dst correctly.

    hbm3 = CreateBitmap(8,8,1,1,NULL);
    hdc3 = CreateCompatibleDC(hdc);

    if ((hdc3 == (HDC) 0) ||
	(hbm3 == (HBITMAP) 0))
    {
	DbgPrint("Error vTestBW has hdc3 hbm3 failure\n");
	return;
    }

    if (0 == SelectObject(hdc3,hbm3))
    {
	DbgPrint("Error vTestBW has Select3 problem\n");
	return;
    }

    PatBlt(hdc3, 0, 0, 100, 100, BLACKNESS);

    hbrBlack = CreatePatternBrush(hbm3);

    PatBlt(hdc3, 0, 0, 100, 100, WHITENESS);

    hbrWhite = CreatePatternBrush(hbm3);

    SelectObject(hdc1, hbrWhite);
    PatBlt(hdc1,0,0,100,100,BLACKNESS);
    PatBlt(hdc1,0,0,100,100,PATCOPY);

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0x00FFFFFF)
	    DbgPrint("9GetPixel failed vTestBW\n");
    }

    SelectObject(hdc1, hbrBlack);
    PatBlt(hdc1,0,0,100,100, WHITENESS);
    PatBlt(hdc1,0,0,100,100,PATCOPY);

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0)
	    DbgPrint("10GetPixel failed vTestBW\n");
    }

// Check if we do pattern and dst correctly with funky rop.

    SelectObject(hdc1, hbrBlack);
    PatBlt(hdc1,0,0,100,100, BLACKNESS);
    PatBlt(hdc1,0,0,100,100,0x000F0001);  // This is NOTPATCOPY

    ulTemp = 100;

    while (ulTemp--)
    {
	if (GetPixel(hdc1,10,ulTemp) != 0x00FFFFFF)
	    DbgPrint("11GetPixel failed vTestBW\n");
    }

    DeleteDC(hdc1);
    DeleteDC(hdc2);
    DeleteDC(hdc3);
    DeleteObject(hbm1);
    DeleteObject(hbm2);
    DeleteObject(hbm3);
    DeleteObject(hbrBlack);
    DeleteObject(hbrWhite);
}

/******************************Public*Routine******************************\
* vTestPlgBlt
*
* Test some plgblt functionality.
*
* History:
*  16-Jan-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestPlgBlt(HWND hwnd, HDC hdc, RECT* prcl)
{
    vTestPlg1(hdc);
    vTestBW(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftptext.c ===
/******************************Module*Header*******************************\
* Module Name: ftptext.c
*
* (Brief description)
*
* Created: 02-Apr-1993 10:41:10
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


int dx[] = {10,20,30,40,10,20,30,40,10,20,30,40};


POLYTEXT polytext1[] =
{
    {  0,  0,  6, "Line 1",         0, {0}, NULL},
    {  0, 20,  7, "Line 2x",        0, {0}, NULL},
    {  0, 40,  8, "Foo bar ",       0, {0}, dx},
    {  0, 60,  8, "spaced 1",       0, {0}, NULL},
    {  0, 80,  8, "spaced 2",       0, {0}, dx} ,
    {  0,100, 12, "PolyTextOutA",   0, {0}, NULL}
};

POLYTEXTW polytextw[] =
{
    {  100,  0,  6, L"Line 1"  ,     0, {0}, NULL},
    {  100, 20,  7, L"Line 2x" ,     0, {0}, NULL},
    {  100, 40,  8, L"Foo bar ",     0, {0}, dx},
    {  100, 60,  8, L"spaced 1",     0, {0}, NULL},
    {  100, 80,  8, L"spaced 2",     0, {0}, dx}  ,
    {  100,100, 12, L"PolyTextOutW", 0, {0}, NULL}
};



VOID vTestPolyTextOut(
    HWND hwnd,
    HDC  hdc,
    RECT *prcl)
{
    COLORREF cr;

    PatBlt(hdc,0,0,2000,2000,WHITENESS);

    cr = SetTextColor(hdc,0x00808080);

    PolyTextOut(hdc,polytext1,sizeof(polytext1) / sizeof(POLYTEXT));

    SetTextColor(hdc, RGB(255,0,0));
    PolyTextOutW(hdc,polytextw,sizeof(polytextw) / sizeof(POLYTEXTW));

    SetTextColor(hdc,cr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftodd.c ===
/******************************Module*Header*******************************\
* Module Name: ftodd.c
*
* Oddball pattern size tests
*
* Created: 28-Jan-1992 20:53:20
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct _XLOGPALETTE
{
    USHORT ident;
    USHORT NumEntries;
    PALETTEENTRY palPalEntry[16];
} XLOGPALETTE;

XLOGPALETTE xlogPal =
{

    0x300,  // driver version
    16,	    // num entries
    {
	{ 0,   0,   0,	 0 },	    // 0
	{ 0x80,0,   0,	 0 },	    // 1
	{ 0,   0x80,0,	 0 },	    // 2
	{ 0x80,0x80,0,	 0 },	    // 3
	{ 0,   0,   0x80,0 },	    // 4
	{ 0x80,0,   0x80,0 },	    // 5
	{ 0,   0x80,0x80,0 },	    // 6
	{ 0x80,0x80,0x80,0 },	    // 7

	{ 0xC0,0xC0,0xC0,0 },	    // 8
	{ 0xFF,0,   0,	 0 },	    // 9
	{ 0,   0xFF,0,	 0 },	    // 10
	{ 0xFF,0xFF,0,	 0 },	    // 11
	{ 0,   0,   0xFF,0 },	    // 12
	{ 0xFF,0,   0xFF,0 },	    // 13
	{ 0,   0xFF,0xFF,0 },	    // 14
	{ 0xFF,0xFF,0xFF,0 }	    // 15
    }
};

static BYTE ajPat7x7[56] =
{
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x00,
    0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x01, 0x00,
    0x03, 0x04, 0x05, 0x06, 0x00, 0x01, 0x02, 0x00,
    0x04, 0x05, 0x06, 0x00, 0x01, 0x02, 0x03, 0x00,
    0x05, 0x06, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00,
    0x06, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x00
};

static BYTE ajPat13x13[208] =
{
    0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00,
    0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00,
    0x0f, 0x0f, 0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x0f, 0x00, 0x00, 0x00,
    0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
    0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00,
    0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x0b, 0x0b, 0x0b, 0x00, 0x00, 0x00, 0x00,
    0x0f, 0x00, 0x0b, 0x0b, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x0b, 0x0b, 0x00, 0x0f, 0x00, 0x00, 0x00,
    0x0f, 0x0f, 0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x0f, 0x0f, 0x00, 0x00, 0x00,
    0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x00, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00,
    0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x0b, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00
};

static BYTE ajPat17x17[340] =
{
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x00, 0x00, 0x00,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x00, 0x00, 0x00,
    0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x09, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00,
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x09, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00
};

typedef struct _XBITMAPINFO
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} XBITMAPINFO;

XBITMAPINFO xbmi =
{
    {
        sizeof(BITMAPINFOHEADER),
        32,
        32,
        1,
	8,
        BI_RGB,
        (32 * 32),
        0,
        0,
	16,
	16
    },

    {                               // B    G    R
        { 0,   0,   0,   0 },       // 0
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
	{ 0x80,0x80,0x80,0 },	    // 7
	{ 0xC0,0xC0,0xC0,0 },	    // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

/******************************Public*Routine******************************\
* vTestOddBlt
*
* Test various blitting functionality
*
* History:
*  02-Feb-1992 -by- Donald Sidoroff [donalds]
* Let MIPS write directly to screen
*
*  28-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vTestOddBlt(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    HPALETTE	 hpal, hpalDef;
    HBITMAP	 hbm, hbmDef, hbm7, hbm13, hbm17;
    HBRUSH	 hbr7, hbr13, hbr17, hbrDef;
    HBRUSH	 hbrOrange;
    HFONT	 hfnt, hfntDef;
    HDC 	 hdc;
    POINT	 ptl[50];
    int 	 aint[10];
    int 	 ii, jj;
    LOGFONT	 lfnt;
    PALETTEENTRY palent[10];

    hwnd = hwnd;

    PatBlt(hdcScreen, 0, 0, prcl->right, prcl->bottom, WHITENESS);

    hpal = CreatePalette((LOGPALETTE *) &xlogPal);
    hpalDef = SelectPalette(hdcScreen, hpal, 0);
    RealizePalette(hdcScreen);

#if defined(MIPS) || defined(_PPC_)
    hdc = hdcScreen;
#else
// Create a MEMORY_DC

    hdc = CreateCompatibleDC(hdcScreen);

// Create an 8BPP bitmap for drawing

    xbmi.bmiHeader.biWidth = 256;
    xbmi.bmiHeader.biHeight = 256;

    hbm = CreateDIBitmap(hdc,
			(BITMAPINFOHEADER *) &xbmi,
			0 | CBM_CREATEDIB,
			NULL,
			(BITMAPINFO *) &xbmi,
			DIB_RGB_COLORS);

// Select it into MEMORY_DC

    hbmDef = SelectObject(hdc, hbm);
#endif

// Create some goofy size bitmaps

    xbmi.bmiHeader.biWidth = 7;
    xbmi.bmiHeader.biHeight = 7;

    hbm7  = CreateDIBitmap(hdc,
			  (BITMAPINFOHEADER *) &xbmi,
			  CBM_INIT | CBM_CREATEDIB,
			  ajPat7x7,
			  (BITMAPINFO *) &xbmi,
                          DIB_RGB_COLORS);

    xbmi.bmiHeader.biWidth = 13;
    xbmi.bmiHeader.biHeight = 13;

    hbm13 = CreateDIBitmap(hdc,
			  (BITMAPINFOHEADER *) &xbmi,
			  CBM_INIT | CBM_CREATEDIB,
			  ajPat13x13,
			  (BITMAPINFO *) &xbmi,
                          DIB_RGB_COLORS);

    xbmi.bmiHeader.biWidth = 17;
    xbmi.bmiHeader.biHeight = 17;

    hbm17 = CreateDIBitmap(hdc,
			  (BITMAPINFOHEADER *) &xbmi,
			  CBM_INIT | CBM_CREATEDIB,
			  ajPat17x17,
			  (BITMAPINFO *) &xbmi,
                          DIB_RGB_COLORS);

// Make them brushes

    hbr7      = CreatePatternBrush(hbm7);
    hbr13     = CreatePatternBrush(hbm13);
    hbr17     = CreatePatternBrush(hbm17);
    hbrOrange = CreateSolidBrush(RGB(255,144,0));

// Select in a brush and draw with it

    hbrDef = SelectObject(hdc, hbr7);

    PatBlt(hdc,   0,  0,  3, 20, PATCOPY);
    PatBlt(hdc,  10,  0,  3, 20, PATCOPY);
    PatBlt(hdc,  20,  0, 30, 20, PATCOPY);

    PatBlt(hdc,   0, 30,  3, 20, 0x000F0000);
    PatBlt(hdc,  10, 30,  3, 20, 0x000F0000);
    PatBlt(hdc,  20, 30, 30, 20, 0x000F0000);

    PatBlt(hdc,   0, 60,  3, 20, PATINVERT);
    PatBlt(hdc,  10, 60,  3, 20, PATINVERT);
    PatBlt(hdc,  20, 60, 30, 20, PATINVERT);

// Select in another brush and draw with it

    SelectObject(hdc, hbr13);

    PatBlt(hdc, 100,  0,  3, 20, PATCOPY);
    PatBlt(hdc, 110,  0,  3, 20, PATCOPY);
    PatBlt(hdc, 120,  0, 30, 20, PATCOPY);

    PatBlt(hdc, 100, 30,  3, 20, 0x000F0000);
    PatBlt(hdc, 110, 30,  3, 20, 0x000F0000);
    PatBlt(hdc, 120, 30, 30, 20, 0x000F0000);

    PatBlt(hdc, 100, 60,  3, 20, PATINVERT);
    PatBlt(hdc, 110, 60,  3, 20, PATINVERT);
    PatBlt(hdc, 120, 60, 30, 20, PATINVERT);

// Select in yet another brush and draw with it

    SelectObject(hdc, hbr17);

    PatBlt(hdc, 200,  0,  3, 20, PATCOPY);
    PatBlt(hdc, 210,  0,  3, 20, PATCOPY);
    PatBlt(hdc, 220,  0, 30, 20, PATCOPY);

    PatBlt(hdc, 200, 30,  3, 20, 0x000F0000);
    PatBlt(hdc, 210, 30,  3, 20, 0x000F0000);
    PatBlt(hdc, 220, 30, 30, 20, 0x000F0000);

    PatBlt(hdc, 200, 60,  3, 20, PATINVERT);
    PatBlt(hdc, 210, 60,  3, 20, PATINVERT);
    PatBlt(hdc, 220, 60, 30, 20, PATINVERT);

// Select in a boring dithered brush and draw with it

    SelectObject(hdc, hbrOrange);

    PatBlt(hdc, 300,  0,  3, 20, PATCOPY);
    PatBlt(hdc, 310,  0,  3, 20, PATCOPY);
    PatBlt(hdc, 320,  0, 30, 20, PATCOPY);

    PatBlt(hdc, 300, 30,  3, 20, 0x000F0000);
    PatBlt(hdc, 310, 30,  3, 20, 0x000F0000);
    PatBlt(hdc, 320, 30, 30, 20, 0x000F0000);

    PatBlt(hdc, 300, 60,  3, 20, PATINVERT);
    PatBlt(hdc, 310, 60,  3, 20, PATINVERT);
    PatBlt(hdc, 320, 60, 30, 20, PATINVERT);

// Assure the ROP,filling mode and outline pen are correct

    SetROP2(hdc, R2_COPYPEN);
    SetPolyFillMode(hdc, ALTERNATE);
    SelectObject(hdc, GetStockObject(BLACK_PEN));

// Make a wierd shape to fill

    aint[0] = 5;
    aint[1] = 5;

    ptl[0].x = 0;
    ptl[0].y = 200;
    ptl[1].x = 70;
    ptl[1].y = 200;
    ptl[2].x = 0;
    ptl[2].y = 270;
    ptl[3].x = 80;
    ptl[3].y = 280;
    ptl[4].x = 0;
    ptl[4].y = 200;

    ptl[5].x = 30;
    ptl[5].y = 210;
    ptl[6].x = 50;
    ptl[6].y = 210;
    ptl[7].x = 20;
    ptl[7].y = 260;
    ptl[8].x = 40;
    ptl[8].y = 260;
    ptl[9].x = 30;
    ptl[9].y = 210;

    SelectObject(hdc, hbr7);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 0, 300, 90, 350);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbr13);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 100, 300, 190, 350);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbr17);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 200, 300, 290, 350);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbrOrange);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 300, 300, 390, 350);

    ptl[0].x = 0;
    ptl[0].y = 200 + 200;
    ptl[1].x = 70;
    ptl[1].y = 200 + 200;
    ptl[2].x = 0;
    ptl[2].y = 270 + 200;
    ptl[3].x = 80;
    ptl[3].y = 280 + 200;
    ptl[4].x = 0;
    ptl[4].y = 200 + 200;

    ptl[5].x = 30;
    ptl[5].y = 210 + 200;
    ptl[6].x = 50;
    ptl[6].y = 210 + 200;
    ptl[7].x = 20;
    ptl[7].y = 260 + 200;
    ptl[8].x = 40;
    ptl[8].y = 260 + 200;
    ptl[9].x = 30;
    ptl[9].y = 210 + 200;

    SetROP2(hdc, R2_NOTCOPYPEN);
    SelectObject(hdc, hbr7);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 0, 500, 90, 550);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbr13);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 100, 500, 190, 550);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbr17);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 200, 500, 290, 550);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbrOrange);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 300, 500, 390, 550);

    ptl[0].x = 0;
    ptl[0].y = 200 + 400;
    ptl[1].x = 70;
    ptl[1].y = 200 + 400;
    ptl[2].x = 0;
    ptl[2].y = 270 + 400;
    ptl[3].x = 80;
    ptl[3].y = 280 + 400;
    ptl[4].x = 0;
    ptl[4].y = 200 + 400;

    ptl[5].x = 30;
    ptl[5].y = 210 + 400;
    ptl[6].x = 50;
    ptl[6].y = 210 + 400;
    ptl[7].x = 20;
    ptl[7].y = 260 + 400;
    ptl[8].x = 40;
    ptl[8].y = 260 + 400;
    ptl[9].x = 30;
    ptl[9].y = 210 + 400;

    SetROP2(hdc, R2_XORPEN);
    SelectObject(hdc, hbr7);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 0, 700, 90, 750);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbr13);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 100, 700, 190, 750);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbr17);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 200, 700, 290, 750);

    for (ii = 0; ii < 10; ii++)
	ptl[ii].x += 100;

    SelectObject(hdc, hbrOrange);
    PolyPolygon(hdc, (LPPOINT) &ptl, (LPINT) &aint, 2);
    Ellipse(hdc, 300, 700, 390, 750);

#if !defined(MIPS) && !defined(_PPC_)
// Blt MEMORY_DC to screen so we can see it

    BitBlt(hdcScreen, 0, 0, 256, 256, hdc, 0, 0, SRCCOPY);

// Restore original objects

    SelectObject(hdc, hbmDef);
#endif
    SelectObject(hdc, hbrDef);

// Delete everything

// why is this? commented out #ifdef [lingyunw]
//#if defined(MIPS) || defined(_PPC_)
    DeleteObject(hbrOrange);
//#endif

    DeleteObject(hbr17);
    DeleteObject(hbm17);
    DeleteObject(hbr13);
    DeleteObject(hbm13);
    DeleteObject(hbr7);
    DeleteObject(hbm7);

#if !defined(MIPS) && !defined(_PPC_)
    DeleteObject(hbm);
    DeleteObject(hdc);
#endif

    SelectPalette(hdcScreen,hpalDef,0);
    DeleteObject(hpal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftqtest.c ===
/******************************Module*Header*******************************\
* Module Name: ftqtest.c
*
* (Brief description)
*
* Created: 29-Dec-1993 08:23:24
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993 Microsoft Corporation
*
*
\**************************************************************************/


#include "precomp.h"
#pragma hdrstop

VOID vTestQuick(
    HWND hwnd,
    HDC  hdc,
    RECT *prcl)
{
    COLORREF cr;
    HBRUSH hbr;

    hbr = CreateSolidBrush(0xff0000);
    hbr = SelectObject(hdc,hbr);
    PatBlt(hdc,0,0,100,100,PATCOPY);
    hbr = SelectObject(hdc,hbr);
    DeleteObject(hbr);

    hbr = CreateSolidBrush(0x00ff00);
    hbr = SelectObject(hdc,hbr);
    PatBlt(hdc,100,0,100,100,PATCOPY);
    hbr = SelectObject(hdc,hbr);
    DeleteObject(hbr);

    hbr = CreateSolidBrush(0x0000ff);
    hbr = SelectObject(hdc,hbr);
    PatBlt(hdc,200,0,100,100,PATCOPY);
    hbr = SelectObject(hdc,hbr);
    DeleteObject(hbr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftprint.c ===
/******************************Module*Header*******************************\
* Module Name: ftprint.c
*
* Created: 08-Oct-1991 12:29:46
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID vPrinterEnumFontTest (HDC);
int iPrinterFontCallback (PLOGFONT, PTEXTMETRIC, ULONG, HDC *);
int iPrinterFaceCallback (PLOGFONT, PTEXTMETRIC, ULONG, HDC *);
VOID vReallyPrintEnumFontTest (HDC);
int iReallyPrintFontCallback (PLOGFONT, PTEXTMETRIC, ULONG, HDC *);
int iReallyPrintFaceCallback (PLOGFONT, PTEXTMETRIC, ULONG, HDC *);
extern LPSTR pszPitchIs (BYTE);
extern LPSTR pszFamilyIs (BYTE);

// #define MYTEXTOUT(a, b, c, d, e)    DbgPrint("%s\n", (d))
#define MYTEXTOUT(a, b, c, d, e)    TextOut((a), (b), (c), (d), (e))

static HDC hdcScreen;
static ULONG   CX, CY;
static CHAR    szOutText[256];
static BYTE giColor = 0;
static ULONG    grgbColor[16] = {
                                 0x00FF7f7f,
                                 0x0000FF00,
                                 0x007F7FFF,
                                 0x00FFFF00,
                                 0x0000FFFF,
                                 0x00FF00FF,
                                 0x00FF7F7F,
                                 0x00FFFFFF
                                };
static LONG yPage;
static LONG yPageMax;

void vDavidguTest(HDC hdc)
{
    HFONT           hFont,
                    hOldFont;
    TEXTMETRIC      tmTM;
    LOGFONT         lfLogFont;
    int             lpiArray[50];
    int             lpiArray2[50];
    TCHAR           lpstrBuf[100];
    int 	    count;

    lfLogFont.lfHeight        = -40;
    lfLogFont.lfWidth         = 0;
    lfLogFont.lfEscapement    = 0;
    lfLogFont.lfOrientation   = 0;
    lfLogFont.lfWeight        = 0;
    lfLogFont.lfItalic        = 0;
    lfLogFont.lfUnderline     = 0;
    lfLogFont.lfStrikeOut     = 0;
    lfLogFont.lfCharSet       = 0;
    lfLogFont.lfOutPrecision  = 0;
    lfLogFont.lfClipPrecision = 0;
    lfLogFont.lfQuality       = 0;
    // strcpy(lfLogFont.lfFaceName, "Univers");
    strcpy(lfLogFont.lfFaceName, "AvanteGarde");
    lfLogFont.lfPitchAndFamily = 0;

    hFont    = CreateFontIndirect(&lfLogFont);
    hOldFont = SelectObject( hdc, hFont );
    GetTextMetrics(hdc, &tmTM);
    GetTextFace(hdc, 100, &lpstrBuf[0]);
    TextOut(hdc,0,0, "ABC", 3);
    TextOut(hdc,0,200, &lpstrBuf[0], (int)lstrlen(&lpstrBuf[0]));
    GetCharWidth(hdc, 'A', 'C', lpiArray2);

    DeleteObject( SelectObject( hdc, GetStockObject(SYSTEM_FONT) ));

    lfLogFont.lfWidth = tmTM.tmAveCharWidth / 2;
    hFont    = CreateFontIndirect(&lfLogFont);
    hOldFont = SelectObject( hdc, hFont );

    GetTextMetrics(hdc, &tmTM);
    GetTextFace(hdc, 100, &lpstrBuf[0]);
    TextOut(hdc,0,400, TEXT("ABC"), 26);
    TextOut(hdc,0,600, &lpstrBuf[0], (int)lstrlen(&lpstrBuf[0]));
    GetCharWidth(hdc, 'A', 'C', lpiArray);

    for (count = 0; count < 3; count++)
    {
        wsprintf(&lpstrBuf[0], TEXT("char %c 1st %d 2nd %d"), (char)count + 'A',lpiArray2[count], lpiArray[count]);
        TextOut(hdc, 0, 750+(count*50), &lpstrBuf[0], (int)lstrlen(&lpstrBuf[0]));
    }

    DeleteObject( SelectObject( hdc, GetStockObject(SYSTEM_FONT) ));
}



/******************************Public*Routine******************************\
* VOID vTestPrinters(HWND hwnd, HDC hdc, RECT* prcl)
*
* History:
*  08-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vTestPrinters(HWND hwnd, HDC hdc, RECT* prcl)
{
    HDC hdcPrinter;
    PRINTDLG pd;
    DOCINFO    di;

    di.cbSize = sizeof(di);
    di.lpszDocName = "Unicode Printer Test";
    di.lpszOutput   = NULL;
    di.lpszDatatype = NULL;
    di.fwType       = 0;

    memset(&pd,0,sizeof(pd));

    pd.lStructSize = sizeof(pd);
    pd.hwndOwner   = hwnd;
    pd.hDevMode    = NULL;
    pd.hDevNames   = NULL;
    pd.hDC         = NULL;
    pd.Flags       = PD_RETURNDC | PD_PAGENUMS;
    pd.nCopies     = 1;
    pd.nFromPage   = 1;
    pd.nToPage     = 1;
    pd.nMinPage    = 1;
    pd.nMaxPage    = 1;

    PrintDlg(&pd);

    hdcPrinter = pd.hDC;

    if (hdcPrinter == NULL)
    {
        DbgPrint("Printing to the screen\n");
        hdcPrinter = hdc;
    }

    UNREFERENCED_PARAMETER(hwnd);

    StartDoc(hdcPrinter,&di);
    StartPage(hdcPrinter);

// Lets be lazy and cheat -- store the display hdc globally!

    hdcScreen = hdc;

// Let's also save the display dimensions while we're at it!

    CX = prcl->right - prcl->left;
    CY = prcl->bottom - prcl->top;

// Do printer font tests.

    vDavidguTest(hdcPrinter);

    // iMapModeOld = SetMapMode(MM_TWIPS);
    // vPrinterEnumFontTest(hdcPrinter);
    // SetMapMode(iMapModeOld);
    // vPrinterEnumFontTest(hdcPrinter);
    // vReallyPrintEnumFontTest(hdcPrinter);

// We're out of here!

    EndPage(hdcPrinter);
    EndDoc(hdcPrinter);

    if (hdcScreen != hdcPrinter)
    {
        DeleteDC(hdcPrinter);
    }
}

#if 0
/******************************Public*Routine******************************\
* VOID vPrinterEnumFontTest (
*     HDC hdc
*     )
*
* Enumerates faces and calls iPrinterFontCallback for each face.
*
* History:
*  29-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrinterEnumFontTest (
    HDC hdc
    )
{
    EnumFonts (
        hdc,
        (LPSTR) NULL,
        (PROC) iPrinterFontCallback,
        (LPVOID) &hdc
        );

}


/******************************Public*Routine******************************\
* iPrinterFontCallback (
*      PLOGFONT    plf,
*      PTEXTMETRIC ptm,
*      ULONG       flType,
*      HDC         *phdc
*      )
*
* Enumerates all fonts of a particular face and calls iPrinterFaceCallback
* for each font.
*
* History:
*  31-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iPrinterFontCallback (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc
    )
{
    int iRet;

    UNREFERENCED_PARAMETER(ptm);
    UNREFERENCED_PARAMETER(flType);

    giColor = giColor & (BYTE) 0x07;
    SetTextColor(hdcScreen, grgbColor[giColor++]);

    iRet = EnumFonts (
                *phdc,
                (LPSTR) (plf->lfFaceName),
                (PROC) iPrinterFaceCallback,
                (LPVOID) phdc
                );

    return (iRet);
}


/******************************Public*Routine******************************\
* int  iPrinterFaceCallback (
*     PLOGFONT    plf,
*     PTEXTMETRIC ptm,
*     ULONG       flType
*     HDC         *phdc
*     )
*
* An EnumFonts callback.  Print the LOGFONT.
*
* History:
*  29-May-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int  iPrinterFaceCallback (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    TEXTMETRIC  tm;
    PSZ     pszPitch, pszFamily;

    UNREFERENCED_PARAMETER(flType);
    UNREFERENCED_PARAMETER(phdc);

// Clear the screen to black.

    BitBlt(hdcScreen, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Helv");
    lfnt.lfHeight = 21;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("Logical font creation failed.\n");
        return 0;
    }

    hfontOriginal = SelectObject(hdcScreen, hfont);

// Get text metrics

    if (!GetTextMetrics (hdcScreen, &tm))
    {
        DbgPrint("vPrintFaces: GetTextMetrics failed.\n");
    }

// Print those mothers!

    sprintf(szOutText, "LOGICAL FONT: %s", plf->lfFaceName);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Height: %ld", plf->lfHeight);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Width: %ld", plf->lfWidth);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Internal Leading: %ld", ptm->tmInternalLeading);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Escapement: %ld", plf->lfEscapement);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Orientation: %ld", plf->lfOrientation);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Weight: %ld", plf->lfWeight);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Italicized: %s", (plf->lfItalic) ? "TRUE":"FALSE");
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Underlined: %s", (plf->lfUnderline) ? "TRUE":"FALSE");
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Strike Through: %s", (plf->lfStrikeOut) ? "TRUE":"FALSE");
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Out Precision: %ld", plf->lfOutPrecision);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "Clip Precision: %ld", plf->lfClipPrecision);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    pszPitch = pszPitchIs(plf->lfPitchAndFamily);
    pszFamily = pszFamilyIs(plf->lfPitchAndFamily);
    sprintf(szOutText, "Pitch and Family: %s, %s", pszPitch, pszFamily);
//    sprintf(szOutText, "Pitch and Family: %d", plf->lfPitchAndFamily);
    MYTEXTOUT(hdcScreen, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    GdiFlush();
//    vSleep(1);

    SelectObject(hdcScreen, hfontOriginal);
    DeleteObject(hfont);

    return 1;
}


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  09-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vReallyPrintEnumFontTest (
    HDC hdc
    )
{
    Escape(hdc, STARTDOC, 7, (LPSTR) "FtTest", 0L);

    EnumFonts (
        hdc,
        (LPSTR) NULL,
        (PROC) iReallyPrintFontCallback,
        (LPVOID) &hdc
        );

    Escape(hdc, NEWFRAME, 0L, 0L, 0L);
    Escape(hdc, ENDDOC, 0L, 0L, 0L);

}


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  09-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iReallyPrintFontCallback (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc
    )
{
    UNREFERENCED_PARAMETER(ptm);
    UNREFERENCED_PARAMETER(flType);

    return (EnumFonts (
                *phdc,
                (LPSTR) (plf->lfFaceName),
                (PROC) iReallyPrintFaceCallback,
                (LPVOID) phdc
                )
           );
}


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  09-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iReallyPrintFaceCallback (
    PLOGFONT    plf,
    PTEXTMETRIC ptm,
    ULONG       flType,
    HDC         *phdc
    )
{
    HFONT   hfont;
    HFONT   hfontOriginal;

    UNREFERENCED_PARAMETER(flType);

    plf->lfUnderline = TRUE;
    plf->lfStrikeOut = TRUE;

// Get a font.

    if ((hfont = CreateFontIndirect(plf)) == (HFONT) NULL)
    {
        DbgPrint("FT!iReallyPrintFaceCallback(): logical font %s creation failed\n", plf->lfFaceName);
        return 0;
    }

    if ((hfontOriginal = SelectObject(*phdc, hfont)) == (HFONT) NULL)
    {
        DbgPrint("FT!iReallyPrintFaceCallback(): selection of font %s failed\n", plf->lfFaceName);
        return 0;
    }

// Print those mothers!

    sprintf(szOutText, "%s %ld pel (I = %s, H = %ld, W = %ld)", plf->lfFaceName, ptm->tmHeight - ptm->tmInternalLeading, ptm->tmItalic ? "TRUE":"FALSE", ptm->tmHeight, ptm->tmWeight);
    TextOut(*phdc, 100, yPage, szOutText, strlen(szOutText));

// Update page position.

    yPage += ptm->tmHeight+ptm->tmExternalLeading;

// If we have exceeded the maximum page position, start a new page.

    if (yPage > yPageMax)
    {
        DbgPrint("FT!iReallyPrintFaceCallback(): NEW PAGE\n");

        yPage = 0;
        Escape(*phdc, NEWFRAME, 0L, 0L, 0L);
    }

// Eliminate the font.

    SelectObject(*phdc, hfontOriginal);

    if (!DeleteObject(hfont))
    {
        DbgPrint("FT!iReallyPrintFaceCallback(): deletion of font %s failed\n", plf->lfFaceName);
    }

    return 1;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftreg.c ===
/******************************Module*Header*******************************\
* Module Name: ftreg.c
*
* Region tests
*
* Created: 26-May-1991 13:07:35
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID vTestRegion(HWND hwnd, HDC hdc, RECT* prcl)
{
    HRGN hrgnRectangle;
    HRGN hrgnRoundRect;
    HRGN hrgnEllipse;
    HRGN hrgnComplex;
    HRGN hrgnComplex1;
    HRGN hrgnComplex2;
    HRGN hrgnComplex3;
    HRGN hrgnX;
    HRGN hrgnPath;
    DWORD dwBatch;
    HBRUSH hbrush;
    HBRUSH hbrushWhite;
    int iMapMode;
    RECT rc;

    BitBlt(hdc, prcl->left, prcl->top, prcl->right, prcl->bottom,
           0, 0, 0, BLACKNESS);

    hbrush = GetStockObject(GRAY_BRUSH);
    hbrushWhite = GetStockObject(WHITE_BRUSH);

    {
        HRGN hrgnTmp = CreateRectRgn(0, 0, 100, 100);

        hrgnX = CreateRectRgn(100, 100, 250, 250);

        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);
        OffsetRgn(hrgnTmp, 250, 0);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);
        OffsetRgn(hrgnTmp, 0, 250);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);
        OffsetRgn(hrgnTmp, -250, 0);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);

        OffsetRgn(hrgnTmp, 50, -200);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);
        OffsetRgn(hrgnTmp, 150, 0);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);
        OffsetRgn(hrgnTmp, 0, 150);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);
        OffsetRgn(hrgnTmp, -150, 0);
        CombineRgn(hrgnX, hrgnX, hrgnTmp, RGN_OR);

        DeleteObject(hrgnTmp);

        OffsetRgn(hrgnX, 500, 500);

        hrgnTmp = CreateRectRgn(450, 450, 900, 900);
        CombineRgn(hrgnX, hrgnTmp, hrgnX, RGN_XOR);
        DeleteObject(hrgnTmp);
    }

    BeginPath(hdc);
    MoveToEx(hdc, 0, 0, NULL);
    LineTo(hdc, 50, 0);
    LineTo(hdc, 50, 100);
    LineTo(hdc, 100, 100);
    LineTo(hdc, 100, 0);
    LineTo(hdc, 150, 0);
    LineTo(hdc, 150, 50);
    LineTo(hdc, 0, 50);
    CloseFigure(hdc);

    MoveToEx(hdc, 200, 25, NULL);
    LineTo(hdc, 250, 25);
    LineTo(hdc, 250, 75);
    LineTo(hdc, 200, 75);
    CloseFigure(hdc);
    EndPath(hdc);

    hrgnPath = PathToRegion(hdc);
    OffsetRgn(hrgnPath, 100, 500);

    hrgnComplex = CreateRectRgn(100, 50, 350, 300);
    hrgnComplex1 = CreateRectRgn(300, 250, 450, 400);
    hrgnComplex2 = CreateEllipticRgn(150, 100, 300, 250);
    hrgnComplex3 = CreateEllipticRgn(200, 150, 250, 200);

    CombineRgn(hrgnComplex, hrgnComplex, hrgnComplex1, RGN_OR);
    CombineRgn(hrgnComplex, hrgnComplex, hrgnComplex2, RGN_DIFF);
    CombineRgn(hrgnComplex, hrgnComplex, hrgnComplex3, RGN_OR);

    hrgnRectangle = CreateRectRgn(100, 350, 200, 450);
    hrgnRoundRect = CreateRoundRectRgn(400, 50, 550, 200, 50, 50);
    hrgnEllipse   = CreateEllipticRgn(500, 300, 600, 400);

//    GetRgnBox(hrgnRectangle, &rc);
//DbgPrint("Rect: (%li, %li, %li, %li)\n", rc.left, rc.top, rc.right, rc.bottom);
//    if (rc.left != 100 || rc.top != 350 || rc.right != 199 || rc.bottom != 449)
//        DbgPrint("1 ERROR: GetRgnBox wrong for CreateRectRgn\n");

    GetRgnBox(hrgnRoundRect, &rc);
//DbgPrint("RoundRect: (%li, %li, %li, %li)\n", rc.left, rc.top, rc.right, rc.bottom);
    if (rc.left != 400 || rc.top != 50 || rc.right != 549 || rc.bottom != 199)
        DbgPrint("2 ERROR: GetRgnBox wrong for CreateRoundRectRgn\n");

    GetRgnBox(hrgnEllipse, &rc);
//DbgPrint("Ellipse: (%li, %li, %li, %li)\n", rc.left, rc.top, rc.right, rc.bottom);
    if (rc.left != 500 || rc.top != 300 || rc.right != 599 || rc.bottom != 399)
        DbgPrint("3 ERROR: GetRgnBox wrong for CreateEllipticRgn\n");

    dwBatch = GdiSetBatchLimit(1);

    if (!FrameRgn(hdc, hrgnComplex, hbrush, 10, 10))
        DbgPrint("4 ERROR: FrameRgn returned FALSE\n");

    if (!FrameRgn(hdc, hrgnRectangle, hbrush, 20, 40))
        DbgPrint("5 ERROR: FrameRgn returned FALSE\n");

    if (!FrameRgn(hdc, hrgnRoundRect, hbrush, 40, 20))
        DbgPrint("6 ERROR: FrameRgn returned FALSE\n");

    if (!FrameRgn(hdc, hrgnEllipse, hbrush, 1, 20))
        DbgPrint("7 ERROR: FrameRgn returned FALSE\n");


    FillRgn(hdc, hrgnX, hbrush);

    if (!FrameRgn(hdc, hrgnX, hbrushWhite, 5, 5))
        DbgPrint("8 ERROR: FrameRgn returned FALSE\n");

    if (!FrameRgn(hdc, hrgnPath, hbrushWhite, 10, 10))
        DbgPrint("9 ERROR: FrameRgn returned FALSE\n");


#if 0
    iMapMode = SetMapMode(hdc, MM_TWIPS);
    if (!FrameRgn(hdc, hrgnRectangle, hbrush, 500, 500))
        DbgPrint("10 ERROR: FrameRgn returned FALSE\n");
    SetMapMode(hdc, iMapMode);
#endif

    DeleteObject(hrgnRectangle);
    DeleteObject(hrgnRoundRect);
    DeleteObject(hrgnEllipse);
    DeleteObject(hrgnComplex);
    DeleteObject(hrgnComplex1);
    DeleteObject(hrgnComplex2);
    DeleteObject(hrgnComplex3);
    DeleteObject(hrgnX);
    DeleteObject(hrgnPath);

    GdiSetBatchLimit(dwBatch);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftsect.c ===
/******************************Module*Header*******************************\
* Module Name: ftsect.c
*
* Does some DIBSECTION testing for fun.
*
* Created: 08-Feb-1994 14:54:06
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define WIN32_TEST 1

typedef struct _BITMAPINFO1
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[2];
} BITMAPINFO1;

typedef struct _BITMAPINFO4
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFO4;

typedef struct _BITMAPINFO8
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[256];
} BITMAPINFO8;

typedef struct _BITMAPINFO16
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO16;

typedef struct _BITMAPINFO32
{
    BITMAPINFOHEADER                 bmiHeader;
    ULONG                            bmiColors[3];
} BITMAPINFO32;

#define BM_WIDTH  256
#define BM_HEIGHT 256
#define NUM_LOOP  256

/******************************Public*Routine******************************\
* vCleanSystemPalette
*
* Wipes out the system palette so the next palette realize starts at 10.
*
* History:
*  31-Jan-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

void vCleanSystemPalette(HDC hdc)
{
    HPALETTE hpal,hpalOld;
    DWORD aTemp[257];
    LPLOGPALETTE lpLogPal;
    UINT iTemp;

    lpLogPal = (LPLOGPALETTE) aTemp;
    lpLogPal->palVersion = 0x300;
    lpLogPal->palNumEntries = 256;

    for (iTemp = 0; iTemp < 256; iTemp++)
    {
        lpLogPal->palPalEntry[iTemp].peRed   = 0;
        lpLogPal->palPalEntry[iTemp].peGreen = 0;
        lpLogPal->palPalEntry[iTemp].peBlue  = (BYTE)iTemp;
        lpLogPal->palPalEntry[iTemp].peFlags = PC_RESERVED;
    }

    hpal = CreatePalette(lpLogPal);
    hpalOld = SelectPalette(hdc, hpal, 0);
    RealizePalette(hdc);
    SelectPalette(hdc, hpalOld, 0);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
* vTestDIBSECTION
*
* Do some simple tests with DIBSECTION, print out times for operations
*
* History:
*  09-Feb-1994 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestDIBSECTION1(HWND hwnd, HDC hdcScreen, RECT* prcl, LONG width)
{
    HDC hdcMem;
    HBITMAP hdib;
    PUSHORT pusLog;
    ULONG ulTemp,ulX,ulY;
    BITMAPINFO8 bmi8;
    HPALETTE hpalFore,hpalBack,hpalOld;
    DWORD aTemp[257];
    LPLOGPALETTE lpLogPal;
    char ach[256];
    ULONG ulStartFore, ulEndFore;
    ULONG ulStartBack, ulEndBack;
    PBYTE pjBits;

// Clear the screen.

    PatBlt(hdcScreen, 0, 0, 10000, 10000, WHITENESS);

// Initialize the 8BPP DIB info.

    bmi8.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
    bmi8.bmiHeader.biWidth         = BM_WIDTH;
    bmi8.bmiHeader.biHeight        = width * BM_HEIGHT;
    bmi8.bmiHeader.biPlanes        = 1;
    bmi8.bmiHeader.biBitCount      = 8;
    bmi8.bmiHeader.biCompression   = BI_RGB;
    bmi8.bmiHeader.biSizeImage     = 0;
    bmi8.bmiHeader.biXPelsPerMeter = 0;
    bmi8.bmiHeader.biYPelsPerMeter = 0;
    bmi8.bmiHeader.biClrUsed       = 0;
    bmi8.bmiHeader.biClrImportant  = 0;

    pusLog = (PUSHORT)bmi8.bmiColors;

    for (ulTemp = 0; ulTemp < 256; ulTemp++)
    {
        pusLog[ulTemp] = (USHORT)ulTemp;
    }

// Create the foreground logical palette.

    lpLogPal = (LPLOGPALETTE) aTemp;
    lpLogPal->palVersion = 0x300;
    lpLogPal->palNumEntries = 256;

    if ((GetDeviceCaps(hdcScreen, RASTERCAPS) & RC_PALETTE) &&
        (GetDeviceCaps(hdcScreen, SIZEPALETTE) == 256))
    {
        GetSystemPaletteEntries(hdcScreen,
                                0, 256, lpLogPal->palPalEntry);
    }
    else
    {
        GetPaletteEntries(GetStockObject(DEFAULT_PALETTE),
                          0, 10, lpLogPal->palPalEntry);
        GetPaletteEntries(GetStockObject(DEFAULT_PALETTE),
                          246, 10, &lpLogPal->palPalEntry[246]);
    }

    for (ulTemp = 10; ulTemp < 246; ulTemp++)
    {
        lpLogPal->palPalEntry[ulTemp].peRed   = (BYTE)ulTemp;
        lpLogPal->palPalEntry[ulTemp].peGreen = 0;
        lpLogPal->palPalEntry[ulTemp].peBlue  = 0;
        lpLogPal->palPalEntry[ulTemp].peFlags = PC_NOCOLLAPSE;
    }

    hpalFore = CreatePalette(lpLogPal);

// Create the background logical palette.

    for (ulTemp = 10; ulTemp < 246; ulTemp++)
    {
        lpLogPal->palPalEntry[ulTemp].peRed   = 0;
        lpLogPal->palPalEntry[ulTemp].peGreen = 0;
        lpLogPal->palPalEntry[ulTemp].peBlue  = (BYTE)ulTemp;
        lpLogPal->palPalEntry[ulTemp].peFlags = PC_NOCOLLAPSE;
    }

    hpalBack = CreatePalette(lpLogPal);

// Select and Realize the palette for identity palette support

    vCleanSystemPalette(hdcScreen);
    hpalOld = SelectPalette(hdcScreen, hpalFore, 0);
    RealizePalette(hdcScreen);

// Create the objects.

    hdcMem = CreateCompatibleDC(hdcScreen);
    hdib = CreateDIBSection(hdcScreen,(BITMAPINFO *) &bmi8,DIB_PAL_COLORS,&pjBits,0,0);
    SelectObject(hdcMem, hdib);

// Initialize the bits to something neat.

    for (ulY = 0; ulY < BM_HEIGHT; ulY++)
    {
        for (ulX = 0; ulX < BM_WIDTH; ulX++)
        {
            pjBits[ulY * BM_WIDTH + ulX] = (BYTE) ulX;
        }
    }

// Do 1 blt to get the xlate created and cached.

    BitBlt(hdcScreen, 0, 0, BM_WIDTH, BM_HEIGHT, hdcMem, 0, 0, SRCCOPY);

// Start timing the blts for foreground.

    ulStartFore = GetTickCount();

    for (ulX = 0; ulX < NUM_LOOP; ulX++)
    {
        BitBlt(hdcScreen, 0, 0, BM_WIDTH, BM_HEIGHT, hdcMem, 0, 0, SRCCOPY);
        GdiFlush();
        pjBits[ulX + ((BM_WIDTH * BM_HEIGHT) / 2)] = 8;
    }

    ulEndFore = GetTickCount();

// Select in the background palette and realize it.

    hpalOld = SelectPalette(hdcScreen, hpalBack, 1);
    RealizePalette(hdcScreen);

// Do 1 blt to get the xlate created and cached.

    BitBlt(hdcScreen, 0, 0, BM_WIDTH, BM_HEIGHT, hdcMem, 0, 0, SRCCOPY);

// Start timing the blts for foreground.

    ulStartBack = GetTickCount();

    for (ulX = 0; ulX < NUM_LOOP; ulX++)
    {
        BitBlt(hdcScreen, 0, 0, BM_WIDTH, BM_HEIGHT, hdcMem, 0, 0, SRCCOPY);
        GdiFlush();
        pjBits[ulX + (BM_WIDTH * 40)] = 9;
    }

    ulEndBack = GetTickCount();

    DeleteDC(hdcMem);
    DeleteObject(hdib);
    SelectPalette(hdcScreen, hpalOld, 0);
    DeleteObject(hpalFore);
    DeleteObject(hpalBack);

    PatBlt(hdcScreen, 0, 0, 10000, 10000, WHITENESS);
    memset(ach,0,256);
    sprintf(ach, "SRC DIBSECT 8bpp width %lu height %lu repeated %lu", BM_WIDTH, BM_HEIGHT, NUM_LOOP);
    TextOut(hdcScreen, 0, 0, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif

    memset(ach,0,256);
    sprintf(ach, "DIBSECT->Screen ident xlate millisecs %lu pixels per milli-second %lu", ulEndFore - ulStartFore, (BM_WIDTH * BM_HEIGHT * NUM_LOOP) / (ulEndFore - ulStartFore));
    TextOut(hdcScreen, 0, 20, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif

    memset(ach,0,256);
    sprintf(ach, "DIBSECT->Screen not-ident xlate millisecs %lu pixels per milli-second %lu", ulEndBack - ulStartBack, (BM_WIDTH * BM_HEIGHT * NUM_LOOP) / (ulEndBack - ulStartBack));
    TextOut(hdcScreen, 0, 40, ach, strlen(ach));
    #if WIN32_TEST
    DbgPrint(ach);
    DbgPrint("\n");
    #endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\fttest.c ===
/******************************Module*Header*******************************\
* Module Name: fttest.c
*
* Test the speed of some things.
*
* Created: 05-Jul-1993 09:23:28
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// Local Function to test calling direct.

NTSTATUS
FtPlgBlt(
IN HANDLE hdcD,
IN PLONG pul,
IN HANDLE hdcS,
IN LONG x,
IN LONG y,
IN LONG cx,
IN LONG cy,
IN HANDLE hbm,
IN LONG xhbm,
IN LONG yhbm)
{
    return(x + y + cx + cy);
}

/******************************Public*Routine******************************\
* QLPC Time Functions
*
* History:
*  24-Apr-1993 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

#define NUMBER_OF_RUNS 3
#define NUMBER_OF_LOOP 100000
#define NORMALIZE_LOOP 10000

typedef struct _QLPCRUN
{
    ULONG ulTime1;
    ULONG ulTime10;
    ULONG ulTime100;
    ULONG ulTimeKernel;
    ULONG ulTimeDirect;
} QLPCRUN;

/******************************Public*Routine******************************\
* vTestDirectSpeed
*
* Generic speed test for kernel calls versus QLPC.
*
* History:
*  13-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestDirectSpeed(HDC hdc, ULONG *pul)
{
// First let's stress it a little bit.

    ULONG ulTime;
    LARGE_INTEGER  time,timeEnd;
    ULONG ulCount;

    POINT aPoint[3] = {{0,1}, {4,5}, {7,8}};

    GdiFlush();

// Do the PatBlt test.

    NtQuerySystemTime(&time);
    ulCount = NUMBER_OF_LOOP;

    while (ulCount--)
    {
        PatBlt(hdc, 0, 0, 1, 1, BLACKNESS);
    }

    GdiFlush();
    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;

    *pul = ulTime;
}

/******************************Public*Routine******************************\
* vTestKernelSpeed
*
* Generic speed test for kernel calls versus QLPC.
*
* History:
*  13-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestKernelSpeed(HDC hdc, ULONG *pul)
{
// First let's stress it a little bit.

    ULONG ulTime;
    LARGE_INTEGER  time,timeEnd;
    ULONG ulCount;

    POINT aPoint[3] = {{0,1}, {4,5}, {7,8}};

    GdiFlush();

// Do the PatBlt test.

    NtQuerySystemTime(&time);
    ulCount = NUMBER_OF_LOOP;

    while (ulCount--)
    {
        PatBlt(hdc, 0, 0, 1, 1, BLACKNESS);
    }

    GdiFlush();
    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;

    *pul = ulTime;
}

/******************************Public*Routine******************************\
* vTestBatchSpeed
*
* Generic speed test for kernel calls versus QLPC.
*
* History:
*  13-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestBatchSpeed(HDC hdc, ULONG *pul)
{
// First let's stress it a little bit.

    ULONG ulTime;
    LARGE_INTEGER  time,timeEnd;
    ULONG ulCount;

    POINT aPoint[3] = {{0,1}, {4,5}, {7,8}};

    GdiFlush();

// Do the PatBlt test.

    NtQuerySystemTime(&time);
    ulCount = NUMBER_OF_LOOP;

#if 0
    while (ulCount--)
    {
        PatBlt(hdc, 0, 0, 1, 1, BLACKNESS);
    }
#endif

    GdiFlush();
    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;

    *pul = ulTime;

    // ulTime = ulTime / 10000;
    // DbgPrint("Time for Kernel was %lu\n", ulTime);
}

/******************************Public*Routine******************************\
* vTestKernel
*
* Test Kernel speed.
*
* History:
*  13-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestKernel(HWND hwnd, HDC hdc, RECT* prcl)
{
    HDC hdcTemp;
    HBITMAP hbmTemp, hbmMask;
    ULONG ulTemp;

// Data for NUMBER_OF_RUNS, each run has 3 times, each time has 2 ULONGS.

    QLPCRUN aQLPCTimeRuns[NUMBER_OF_RUNS + 1];

    hwnd;

    hbmMask = CreateBitmap(5, 5, 1, 1, NULL);

    PatBlt(hdc, 0, 0, prcl->right, prcl->bottom, WHITENESS);

    hdcTemp = CreateCompatibleDC(hdc);
    hbmTemp = CreateCompatibleBitmap(hdc, 100, 100);
    SelectObject(hdcTemp, hbmTemp);
    PatBlt(hdcTemp, 0, 0, 1000, 1000, WHITENESS);
    // DbgPrint("Starting QLPC time overhead test\n");
    GdiFlush();

    for (ulTemp = 0; ulTemp < NUMBER_OF_RUNS + 1; ulTemp++)
    {
        GdiSetBatchLimit(1);
        vTestBatchSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTime1));

        GdiSetBatchLimit(10);
        vTestBatchSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTime10));

        GdiSetBatchLimit(100);
        vTestBatchSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTime100));
        GdiSetBatchLimit(10);

        vTestKernelSpeed(hdc, &(aQLPCTimeRuns[ulTemp].ulTimeKernel));

        vTestDirectSpeed(hdcTemp, &(aQLPCTimeRuns[ulTemp].ulTimeDirect));
    }

    DeleteDC(hdcTemp);
    DeleteObject(hbmTemp);
    DeleteObject(hbmMask);

// Average the data.  Don't use first run, mouse still moving, other apps still
// processing messages being generated.

    aQLPCTimeRuns[0].ulTime1   =
    aQLPCTimeRuns[0].ulTime10  =
    aQLPCTimeRuns[0].ulTime100 =
    aQLPCTimeRuns[0].ulTimeDirect =
    aQLPCTimeRuns[0].ulTimeKernel = 0;

    for (ulTemp = 1; ulTemp < NUMBER_OF_RUNS + 1; ulTemp++)
    {
        aQLPCTimeRuns[0].ulTime1   += aQLPCTimeRuns[ulTemp].ulTime1;
        aQLPCTimeRuns[0].ulTime10  += aQLPCTimeRuns[ulTemp].ulTime10;
        aQLPCTimeRuns[0].ulTime100 += aQLPCTimeRuns[ulTemp].ulTime100;
        aQLPCTimeRuns[0].ulTimeDirect += aQLPCTimeRuns[ulTemp].ulTimeDirect;
        aQLPCTimeRuns[0].ulTimeKernel += aQLPCTimeRuns[ulTemp].ulTimeKernel;
    }

    aQLPCTimeRuns[0].ulTime1   /= NUMBER_OF_RUNS;
    aQLPCTimeRuns[0].ulTime10  /= NUMBER_OF_RUNS;
    aQLPCTimeRuns[0].ulTime100 /= NUMBER_OF_RUNS;
    aQLPCTimeRuns[0].ulTimeDirect /= NUMBER_OF_RUNS;
    aQLPCTimeRuns[0].ulTimeKernel /= NUMBER_OF_RUNS;

    DbgPrint("Time was 1 %lu 10 %lu 100 %lu Kernel %lu Direct %lu\n",
                                   (aQLPCTimeRuns[0].ulTime1   / NORMALIZE_LOOP),
                                   (aQLPCTimeRuns[0].ulTime10  / NORMALIZE_LOOP),
                                   (aQLPCTimeRuns[0].ulTime100 / NORMALIZE_LOOP),
                                   (aQLPCTimeRuns[0].ulTimeKernel / NORMALIZE_LOOP),
                                   (aQLPCTimeRuns[0].ulTimeDirect / NORMALIZE_LOOP));

{
    ULONG ulTime;
    LARGE_INTEGER  time,timeEnd;

    NtQuerySystemTime(&time);
    vSleep(2);
    NtQuerySystemTime(&timeEnd);

    ulTime = timeEnd.LowPart - time.LowPart;

    DbgPrint("2 second Microsecond Time is %lu\n", ulTime / NORMALIZE_LOOP);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftuni.c ===
/******************************Module*Header*******************************\
* Module Name: ftuni.c
*
* the tests for simple unicode extended functions
*
* Created: 06-Aug-1991 16:05:32
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// This is to create a bitmapinfo structure

BOOL bEqualABC(LPABC pabc1,LPABC pabc2)
{
    return (
            (pabc1->abcA == pabc2->abcA) &&
            (pabc1->abcB == pabc2->abcB) &&
            (pabc1->abcC == pabc2->abcC)
           );
}

BOOL bEqualABCFLOAT(LPABCFLOAT pabcf1,LPABCFLOAT pabcf2)
{
    return (
            (pabcf1->abcfA == pabcf2->abcfA) &&
            (pabcf1->abcfB == pabcf2->abcfB) &&
            (pabcf1->abcfC == pabcf2->abcfC)
           );
}


VOID vToUNICODE(LPWSTR pwszDst, PSZ pszSrc)
{
    while((*pwszDst++ = (WCHAR)(*pszSrc++)) != (WCHAR)'\0')
        ;
}

#define CGLYPHS 300

VOID DbgPrintLOGFONT(PVOID pv);

VOID  vTestEnumFonts(HDC hdc);
VOID  vTestStuff(HDC hdcScreen);
VOID  vTestAddFR(HDC);





void    vTestGetOTM(HDC hdc);


VOID vTestUnicode(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    prcl; hwnd;

    vTestGetOTM   (hdcScreen);
    vTestAddFR    (hdcScreen);
    vTestStuff    (hdcScreen);
    vTestEnumFonts(hdcScreen);
}


void    vTestGetOTM(HDC hdc)
{
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    OUTLINETEXTMETRICA  otma, *potma;
    UINT    cjotma;

    OUTLINETEXTMETRICW  otmw, *potmw;
    UINT                cjotmw;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, 3000, 4000, (HDC) 0, 0, 0, 0);

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Arial");
    lfnt.lfHeight = -14;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("ft!bTestGOTM(): Logical font creation failed.\n");
    }

    hfontOriginal = SelectObject(hdc, hfont);

// Determine size needed for OTM.

    cjotma = GetOutlineTextMetricsA(hdc, sizeof(OUTLINETEXTMETRICA), &otma);

    if (cjotma != sizeof(OUTLINETEXTMETRICA))
    {
        DbgPrint("ft!bTestGOTM(): cjotma != sizeof(OUTLINETEXTMETRICA)\n");
    }

    cjotma = GetOutlineTextMetricsA(hdc, offsetof(OUTLINETEXTMETRICA,otmpFamilyName), &otma);

    if (cjotma != offsetof(OUTLINETEXTMETRICA,otmpFamilyName))
    {
        DbgPrint("ft!bTestGOTM(): cjotma != offsetof(OUTLINETEXTMETRICA,otmpFamilyName)\n");
    }


    cjotma = GetOutlineTextMetricsA(hdc, 0, NULL);

    potma = (OUTLINETEXTMETRICA*)LocalAlloc(LMEM_FIXED, cjotma);

    if (potma)
    {
        UINT cjotma1 = GetOutlineTextMetricsA(hdc, cjotma, potma);
        if (cjotma1 != cjotma)
        {
            DbgPrint("ft!bTestGOTM(): cjotma != cjotma1, cjotma = %ld, cjotma1 = %ld \n",
                cjotma, cjotma1);
        }
        else
        {
            DbgPrint("\n\nAnsi version: \n\n");

            DbgPrint("Family: %s\n", (BYTE*)potma + (ULONG_PTR)potma->otmpFamilyName);
            DbgPrint("Face:   %s\n", (BYTE*)potma + (ULONG_PTR)potma->otmpFaceName);
            DbgPrint("Style:  %s\n", (BYTE*)potma + (ULONG_PTR)potma->otmpStyleName);
            DbgPrint("Full:   %s\n", (BYTE*)potma + (ULONG_PTR)potma->otmpFullName);
        }

    // this should fail, no room for all the strings:

        cjotma1 = GetOutlineTextMetricsA(hdc, cjotma - 3 , potma);
        if (cjotma1 != 0)
        {
            DbgPrint("ft!bTestGOTM(): cjotma1 = %ld, != 0 \n",cjotma1);
        }

        LocalFree(potma);
    }

// repeat all of this for a unicode version

// Determine size needed for OTM.


    cjotmw = GetOutlineTextMetricsW(hdc, sizeof(OUTLINETEXTMETRICW), &otmw);

    if (cjotmw != sizeof(OUTLINETEXTMETRICW))
    {
        DbgPrint("ft!bTestGOTM(): cjotmw != sizeof(OUTLINETEXTMETRICW)\n");
    }

    cjotmw = GetOutlineTextMetricsW(hdc, offsetof(OUTLINETEXTMETRICW,otmpFamilyName), &otmw);

    if (cjotmw != offsetof(OUTLINETEXTMETRICW,otmpFamilyName))
    {
        DbgPrint("ft!bTestGOTM(): cjotmw != offsetof(OUTLINETEXTMETRICW,otmpFamilyName)\n");
    }


    cjotmw = GetOutlineTextMetricsW(hdc, 0, NULL);

    potmw = (OUTLINETEXTMETRICW*)LocalAlloc(LMEM_FIXED, cjotmw);

    if (potmw)
    {
        UINT cjotmw1 = GetOutlineTextMetricsW(hdc, cjotmw, potmw);
        if (cjotmw1 != cjotmw)
        {
            DbgPrint("ft!bTestGOTM(): cjotmw != cjotmw1, cjotmw = %ld, cjotmw1 = %ld \n",
                cjotmw, cjotmw1);
        }
        else
        {
            DbgPrint("\n\nUnicode version: \n\n");

            DbgPrint("Family: %ws\n", (BYTE*)potmw + (ULONG_PTR)potmw->otmpFamilyName);
            DbgPrint("Face:   %ws\n", (BYTE*)potmw + (ULONG_PTR)potmw->otmpFaceName);
            DbgPrint("Style:  %ws\n", (BYTE*)potmw + (ULONG_PTR)potmw->otmpStyleName);
            DbgPrint("Full:   %ws\n", (BYTE*)potmw + (ULONG_PTR)potmw->otmpFullName);
        }

    // this should fail, no room for all the strings:

        cjotmw1 = GetOutlineTextMetricsW(hdc, cjotmw - 3 , potmw);
        if (cjotmw1 != 0)
        {
            DbgPrint("ft!bTestGOTM(): cjotmw1 = %ld, != 0 \n",cjotmw1);
        }

        LocalFree(potmw);
    }


    SelectObject(hdc, hfontOriginal);
    DeleteObject(hfont);

}




VOID vTestStuff(HDC hdcScreen)
{
// produce several UNICODE strings to be used with Unicode text calls.

    BYTE ajStack[CGLYPHS * 2];   // can accomodate up to CGLYPHS WCHARS

    char * pszETOU = "This is ExtTextOutW output ";
    char * pszNoPdx = "This is ExtTextOutW with no pdx ";
    char * pszPdx = "This is ExtTextOutW with pdx ";
    char * pszTOU = "This is TextOutW output ";
    char * pszTO = "This is ordinary TextOut output ";


    ULONG adx[CGLYPHS];

    ULONG idx;


    for (idx = 0; idx < CGLYPHS; idx++)
        adx[idx] = 20;

// just do one string

    vToUNICODE((LPWSTR)ajStack, pszETOU);

    ExtTextOutW(
                hdcScreen,
                10,20,
                0, (LPRECT)NULL,
                (LPWSTR)ajStack, strlen(pszETOU),
                (LPINT)NULL
               );

// no pdx

    vToUNICODE((LPWSTR)ajStack, pszNoPdx);

    ExtTextOutW(
                hdcScreen,
                10,40,
                0, (LPRECT)NULL,
                (LPWSTR)ajStack, strlen(pszNoPdx),
                (LPINT)NULL
               );


// with pdx

    vToUNICODE((LPWSTR)ajStack, pszPdx);

    ExtTextOutW(
                hdcScreen,
                10,60,
                0, (LPRECT)NULL,
                (LPWSTR)ajStack, strlen(pszPdx),
                (LPINT)adx
               );


    ExtTextOut(                 // compare it with ordinary ExtTextOut
                hdcScreen,
                10,80,
                0, (LPRECT)NULL,
                pszPdx, strlen(pszPdx),
                (LPINT)adx
               );

// change adx and try again

    for (idx = 0; idx < CGLYPHS; idx++)
        adx[idx] = 15 + 2 * (idx & 7);


    ExtTextOutW(
                hdcScreen,
                10,100,
                0, (LPRECT)NULL,
                (LPWSTR)ajStack, strlen(pszPdx),
                (LPINT)adx
               );


    ExtTextOut(                 // compare it with ordinary ExtTextOut
                hdcScreen,
                10,120,
                0, (LPRECT)NULL,
                pszPdx, strlen(pszPdx),
                (LPINT)adx
               );

// ordinary text out

    TextOut(hdcScreen,
            10,160,
            pszTO, strlen(pszTO));

// text out,  unicode version

    vToUNICODE((LPWSTR)ajStack, pszTOU);

    ExtTextOutW(
                hdcScreen,
                10,180,
                0, (LPRECT)NULL,
                (LPWSTR)ajStack, strlen(pszTOU),
                (LPINT)NULL
               );

// try doing a very long string, bigger than 256 chars

    {
        PCHAR pchar = (PCHAR)ajStack;
        for (idx = 0; idx < 250; idx++)
        {
            adx[idx] = 0;                // put them on the top of each other
            *pchar++ = 'a';
        }
        adx[249] = 10;                // put them on the top of each other
        for (idx = 250; idx < 260; idx++)
        {
            adx[idx] = 10;
            *pchar++ = 'b';
        }

        ExtTextOut(
                    hdcScreen,
                    10,220,
                    0, (LPRECT)NULL,
                    (LPSTR)ajStack, 260,
                    (LPINT)adx
                   );
    }

// test GetTextFace(W)

    {
        int cRet, cRetW;

        cRet = GetTextFace(hdcScreen, CGLYPHS * 2, (LPSTR)ajStack);
        TextOut(hdcScreen, 10, 300, (LPSTR)ajStack, (DWORD)cRet);

        cRetW = GetTextFaceW(hdcScreen, CGLYPHS * 2, (LPWSTR)ajStack);
        TextOutW(hdcScreen, 10, 320, (LPWSTR)ajStack, cRetW);

    // output of the two text out calls should look exactly the same

        if ((cRet * 2) != cRetW)
            DbgPrint("GetTextFace(W) error\n\n");
    }

    {
    // here must add the test for GetTextMetrics(W)
    }

// test for GetObject(W)

    {
        LOGFONT lfIn, lfOut;
        LOGFONTW lfwOut;
        HFONT   hfnt;
        int x = 300,y = 300;

        lfIn.lfHeight =  16;
        lfIn.lfWidth =  8;
        lfIn.lfEscapement =  0;
        lfIn.lfOrientation =  0;
        lfIn.lfWeight =  700;
        lfIn.lfItalic =  0;
        lfIn.lfUnderline =  0;
        lfIn.lfStrikeOut =  0;
        lfIn.lfCharSet =  ANSI_CHARSET;
        lfIn.lfOutPrecision =  OUT_DEFAULT_PRECIS;
        lfIn.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
        lfIn.lfQuality =  DEFAULT_QUALITY;
        lfIn.lfPitchAndFamily =  (FIXED_PITCH | FF_DONTCARE);

        strcpy(lfIn.lfFaceName, "System");

        hfnt = CreateFontIndirect(&lfIn);

        if (hfnt == (HFONT)0)
        {
            DbgPrint("CreateFontIndirect failed\n");
        }
        else
        {
            int cjRet = GetObject(hfnt, sizeof(LOGFONT), (LPVOID)&lfOut);

            if (cjRet)
            {
                if (cjRet != (int)sizeof(LOGFONT))
                    DbgPrint("GetObject  returned bizzare value \n");

                TextOut(hdcScreen, x, y, lfOut.lfFaceName, strlen(lfIn.lfFaceName));

                DbgPrintLOGFONT((PVOID)&lfOut);

            }
            else
            {
                DbgPrint("GetObject  failed \n");
            }

        // GetObjectW test

            cjRet = GetObjectW(hfnt, sizeof(LOGFONTW), (LPVOID)&lfwOut);

            if (cjRet)
            {
                if (cjRet != (int)sizeof(LOGFONTW))
                    DbgPrint("GetObjectW  returned bizzare value \n");

                y += 40;
		TextOutW(hdcScreen, x, y, lfwOut.lfFaceName, strlen(lfIn.lfFaceName));

                DbgPrintLOGFONT((PVOID)&lfwOut);

            }
            else
            {
                DbgPrint("GetObjectW  failed \n");
            }

            if (!DeleteObject(hfnt))
                DbgPrint("DeleteObject(hfnt) failed\n");


        }

    // try to fill the face name with junk, do not put terminating zero in any
    // of the slots

        {
            int i;
            for (i = 0; i < LF_FACESIZE; i++)
                lfIn.lfFaceName[i] = 'A';
        }

        hfnt = CreateFontIndirect(&lfIn);

        if (hfnt == (HFONT)0)
        {
            DbgPrint("CreateFontIndirect failed\n");
        }
        else
        {
            ULONG cjRet = GetObject(hfnt, sizeof(LOGFONT), (LPVOID)&lfOut);

            if (cjRet)
            {
                if (cjRet != sizeof(LOGFONT))
                    DbgPrint("GetObject  returned bizzare value \n");

                y += 40;
                TextOut(hdcScreen, x, y, lfOut.lfFaceName, LF_FACESIZE);
                DbgPrintLOGFONT((PVOID)&lfOut);
            }
            else
            {
                DbgPrint("GetObject  failed \n");
            }

        // GetObjectW is implemented

            cjRet = GetObjectW(hfnt, sizeof(LOGFONTW), (LPVOID)&lfwOut);

            if (cjRet)
            {
                if (cjRet != sizeof(LOGFONTW))
                    DbgPrint("GetObjectW  returned bizzare value \n");

		TextOutW(hdcScreen, x, y + 32, lfwOut.lfFaceName, LF_FACESIZE);
                DbgPrintLOGFONT((PVOID)&lfwOut);
            }
            else
            {
                DbgPrint("GetObjectW  failed \n");
            }

            if (!DeleteObject(hfnt))
                DbgPrint("DeleteObject(hfnt) failed\n");

        }

    }

#define C_CHAR   150


// check GetCharWidth


    {

        UINT iFirst = 30;
        UINT iLast = iFirst + C_CHAR - 1;

        INT  aiWidth[C_CHAR];
        INT  aiWidthW[C_CHAR];

        FLOAT  aeWidth[C_CHAR];
        FLOAT  aeWidthW[C_CHAR];

        BOOL b, bW, bFloat, bFloatW;

        b  = GetCharWidth (hdcScreen, iFirst, iLast, aiWidth);
        bW = GetCharWidthW(hdcScreen, iFirst, iLast, aiWidthW);

        bFloat  = GetCharWidthFloat (hdcScreen, iFirst, iLast, aeWidth);
        bFloatW = GetCharWidthFloatW(hdcScreen, iFirst, iLast, aeWidthW);

        if (!b || !bW || !bFloat || !bFloatW)
        {
            DbgPrint("GetCharWidth (Float)(W) failed\n");
        }
        else
        {
            INT iWidth;

            DbgPrint("\n Width Table : \n");

            for (iWidth = 0; iWidth < C_CHAR; iWidth++)
            {
                if (
                    (aiWidth[iWidth] != aiWidthW[iWidth])
                    ||
                    (aeWidth[iWidth] != aeWidthW[iWidth])
                   )
                {
                    DbgPrint("aiWidth[%ld] != aiWidthW[%ld], aiWidth = %ld, aiWidthW = %ld\n", iWidth, aiWidth[iWidth], aiWidthW[iWidth]);
                }
                else
                {
                #ifdef NEVER
                    DbgPrint("aiWidth[%ld] = %ld \n",
                             iFirst + iWidth,       // offset the index to disply the true ascii value
                             aiWidth[iWidth]);
                #endif  // NEVER
                }

                if (aeWidth[iWidth] != (FLOAT)aiWidth[iWidth])
                {
                //!!! the following test will only be ok on the integer fonts

                    DbgPrint("ft: width problem if not an integer font\n");
                }
            }
            DbgPrint("\n completed Width Table test : \n");
        }

    }

// this should be moved to some other file, ftbmtext.c e.g.

    {

        UINT iFirst = 30;
        UINT iLast = iFirst + C_CHAR - 1;

        ABC  aABC[C_CHAR];
        ABC  aABCW[C_CHAR];

        ABCFLOAT  aABCF[C_CHAR];
        ABCFLOAT  aABCFW[C_CHAR];

        BOOL b, bW, bFloat, bFloatW;

        b  = GetCharABCWidths (hdcScreen, iFirst, iLast, aABC );
        bW = GetCharABCWidthsW(hdcScreen, iFirst, iLast, aABCW);

        bFloat  = GetCharABCWidthsFloat (hdcScreen, iFirst, iLast, aABCF );
        bFloatW = GetCharABCWidthsFloatW(hdcScreen, iFirst, iLast, aABCFW);

        if (!b || !bW || !bFloat || !bFloatW)
        {
            DbgPrint("GetCharABCWidths (Float)(W) failed\n");
        }
        else
        {
            INT iWidth;

            DbgPrint("\n abc Width test : \n");

            for (iWidth = 0; iWidth < C_CHAR; iWidth++)
            {
            #ifdef PRINT_STUFF
                if (
                    !(b = bEqualABC(&aABC[iWidth], &aABCW[iWidth]))
                    ||
                    !(bFloat = bEqualABCFLOAT(&aABCF[iWidth], &aABCFW[iWidth]))
                   )
            #endif // PRINT_STUFF
                {
                    DbgPrint("\n abc screwed up on iWidth = %ld, bABC = %ld, bABCF = %ld \n",
                              iWidth, b, bFloat);

                    DbgPrint ("ANSI Integer: a = %ld, b = %ld, c = %ld,\n",
                              aABC[iWidth].abcA,
                              aABC[iWidth].abcB,
                              aABC[iWidth].abcC);

                    DbgPrint ("UNICODE Integer: a = %ld, b = %ld, c = %ld,\n",
                              aABCW[iWidth].abcA,
                              aABCW[iWidth].abcB,
                              aABCW[iWidth].abcC);

                    DbgPrint ("ANSI float: a = %ld, b = %ld, c = %ld,\n",
                              (LONG)aABCF[iWidth].abcfA,
                              (LONG)aABCF[iWidth].abcfB,
                              (LONG)aABCF[iWidth].abcfC);

                    DbgPrint ("UNICODE float: a = %ld, b = %ld, c = %ld,\n",
                              (LONG)aABCFW[iWidth].abcfA,
                              (LONG)aABCFW[iWidth].abcfB,
                              (LONG)aABCFW[iWidth].abcfC);
                }

            //!!! the following test will only be ok on the integer fonts

                if (
                    ((FLOAT)aABC[iWidth].abcA != aABCF[iWidth].abcfA) ||
                    ((FLOAT)aABC[iWidth].abcB != aABCF[iWidth].abcfB) ||
                    ((FLOAT)aABC[iWidth].abcC != aABCF[iWidth].abcfC)
                   )
                {
                    DbgPrint("ft: this is an ABC problem if not an integer font\n\n");
                }
            }
            DbgPrint("\n completed abc Width test : \n");

        }

    }

// this is a test to verify the use of the sections, where the amount of data
// that needs to be transfered over the client server boundary
// is  bigger than 64K (size of mem window)

#define C_GLYPHS_HUGE   (0X00004000)

    {
        UINT       iFirst = 30;
        UINT       iLast = iFirst + C_GLYPHS_HUGE - 1;
        PVOID      pvMem;
        BOOL       b;
        LPINT      pintWidth;
        PFLOAT     peWidth;
        LPABC      pabc;
        LPABCFLOAT pabcf;

        pvMem = malloc(C_GLYPHS_HUGE * sizeof(ABC));

        if (pvMem != (PVOID)NULL)
        {
            pintWidth = (LPINT)pvMem;
            peWidth   = (PFLOAT)pvMem;
            pabc      = (LPABC)pvMem ;
            pabcf     = (LPABCFLOAT)pvMem ;

            b = GetCharABCWidthsW (hdcScreen, iFirst, iLast, pabc);

            if (!b)
            {
                DbgPrint(" section test GetCharABCWidthsW  failed\n");
            }
            else
            {
                INT iWidth;

            #ifdef NEVER_DO_IT

                DbgPrint("\n abc Width section test : \n");

                for (iWidth = 0; iWidth < C_GLYPHS_HUGE; iWidth++)
                {
                    DbgPrint ("UNICODE Integer: a = %ld, b = %ld, c = %ld,\n",
                               pabc[iWidth].abcA,
                               pabc[iWidth].abcB,
                               pabc[iWidth].abcC);
                }
                DbgPrint("\n completed abc Width section test : \n");

            #endif // NEVER_DO_IT
            }

        // GetCharWidthsW section test

            b = GetCharWidthW (hdcScreen, iFirst, iLast, pintWidth);

            if (!b)
            {
                DbgPrint(" section test GetCharWidthW  failed\n");
            }
            else
            {
                INT iWidth;

                DbgPrint("\n  Width section test : \n");

            #ifdef NEVER_DO_IT
                for (iWidth = 0; iWidth < C_GLYPHS_HUGE; iWidth++)
                {
                    DbgPrint("\n width[%ld] = %ld \n", iWidth, pintWidth[iWidth]);
                }
            #endif // NEVER_DO_IT
                DbgPrint("\n completed Width section test : \n");
            }

            b = GetCharWidthFloatW (hdcScreen, iFirst, iLast, peWidth);

            if (!b)
            {
                DbgPrint(" section test GetCharWidthFloatW  failed\n");
            }
            else
            {
                INT iWidth;

                DbgPrint("\n  Width section test : \n");

            #ifdef NEVER_DO_IT
                for (iWidth = 0; iWidth < C_GLYPHS_HUGE; iWidth++)
                {
                    DbgPrint("\n float width[%ld] = %ld \n", iWidth, (LONG)peWidth[iWidth]);
                }
            #endif // NEVER_DO_IT
                DbgPrint("\n completed Width section test : \n");
            }

            free(pvMem);
        }

    }



/*
    {
        HBITMAP hbm, hbmOld;
        BITMAP  bm;
        HDC     hdcMem;
        char * pszMem = "Memory Bitmap";
        LOGFONT lfItalic;
        HFONT    hfItalic, hfOld;
        int cPelCorrection;

        lfItalic.lfHeight =  16;
        lfItalic.lfWidth =  8;
        lfItalic.lfEscapement =  0;
        lfItalic.lfOrientation =  0;
        lfItalic.lfWeight =  700;
        lfItalic.lfItalic =  1;
        lfItalic.lfUnderline =  0;
        lfItalic.lfStrikeOut =  0;
        lfItalic.lfCharSet =  ANSI_CHARSET;
        lfItalic.lfOutPrecision =  OUT_DEFAULT_PRECIS;
        lfItalic.lfClipPrecision =  CLIP_DEFAULT_PRECIS;
        lfItalic.lfQuality =  DEFAULT_QUALITY;
        lfItalic.lfPitchAndFamily =  (FIXED_PITCH | FF_DONTCARE);

        strcpy(lfItalic.lfFaceName, "System");

        hfItalic = CreateFontIndirect(&lfItalic);

        if (hfItalic == (HFONT)0)
        {
            DbgPrint("CreateFontIndirect failed\n");
        }

    // create bitmap

        bm.bmType   = 0;  // what does this mean
        bm.bmWidth  = 256;
        bm.bmHeight = 64;
        bm.bmBitsPixel  = 1;   // 8;
        bm.bmPlanes  = 1;

    // cj = (((Width in pels) + pels/dword - 1) & ~(pels/dword - 1)) * 4

        cPelCorrection = (32 / bm.bmBitsPixel) - 1;

        bm.bmWidthBytes =   ((bm.bmWidth + cPelCorrection) & ~cPelCorrection) * 4;      // chriswil  used GetObject on this
        bm.bmBits       = (LPSTR)NULL;


        hbm = CreateBitmapIndirect(&bm);
        if (hbm == (HBITMAP)0)
            DbgPrint("CreateBitmapIndirect failed  on 1 bpp\n");
        else
            DbgPrint("CreateBitmapIndirect succeeded 1 bpp\n");

        hdcMem = CreateCompatibleDC(hdcScreen);
        if (hdcMem == (HDC)0)
            DbgPrint("CreateCompatibleDC failed \n");

        hbmOld = SelectObject(hdcMem, hbm);
        hfOld  = SelectObject(hdcMem, hfItalic);
        SetBkMode(hdcMem, TRANSPARENT);
        PatBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, WHITENESS);
        TextOut(hdcMem, 5, 10, pszMem, strlen(pszMem));


    // display on the screen

        BitBlt(hdcScreen,               // Dst
               0, 200,                  // Dst
               bm.bmWidth, bm.bmHeight, // cx, cy
               hdcMem,                  // Src
               0,0,                     // Src
               SRCCOPY
               );

        SelectObject(hdcMem, hbmOld);
        SelectObject(hdcMem, hfOld);

        if (!DeleteObject(hbm))
        	DbgPrint("ERROR failed to delete 1bpp  hbm\n");

        if (!DeleteObject(hfItalic))
        	DbgPrint("ERROR failed to delete hfItalic  \n");

        if (!DeleteDC(hdcMem))
        	DbgPrint("ERROR failed to delete hdcMem\n");


    }



    {
        HBITMAP hbm;
        BITMAP  bm;
        int cPelCorrection;

        bm.bmType   = 1;  0;  //!!! what does this mean
        bm.bmWidth  = 30;
        bm.bmHeight = 70;
        bm.bmBitsPixel  = 4;   // 8;
        bm.bmPlanes  = 1;

     // cj = (((Width in pels) + pels/dword - 1) & ~(pels/dword - 1)) * 4

        cPelCorrection = (32 / bm.bmBitsPixel) - 1;

        bm.bmWidthBytes =   ((bm.bmWidth + cPelCorrection) & ~cPelCorrection) * 4;      // chriswil  used GetObject on this
        bm.bmBits       = (LPSTR)NULL;


        hbm = CreateBitmapIndirect(&bm);
        if (hbm == (HBITMAP)0)
            DbgPrint("CreateBitmapIndirect failed  on 4 bpp\n");
        else
            DbgPrint("CreateBitmapIndirect succeeded 4 bpp\n");

        if (!DeleteObject(hbm))
        	DbgPrint("ERROR failed to delete 4bpp  hbm\n");

        bm.bmType   = 0;
        bm.bmWidth  = 30;
        bm.bmHeight = 70;
        bm.bmBitsPixel  = 8;   // 8;
        bm.bmPlanes  = 1;
        cPelCorrection = (32 / bm.bmBitsPixel) - 1;

        bm.bmWidthBytes =   ((bm.bmWidth + cPelCorrection) & ~cPelCorrection) * 4;      // chriswil  used GetObject on this
        bm.bmBits       = (LPSTR)NULL;

        hbm = CreateBitmapIndirect(&bm);
        if (hbm == (HBITMAP)0)
            DbgPrint("CreateBitmapIndirect failed 8bpp \n");
        else
            DbgPrint("CreateBitmapIndirect succeeded 8 bpp \n");

        if (!DeleteObject(hbm))
        	DbgPrint("ERROR failed to delete  8bpp hbm\n");


    }

*/

// test GetTextExtentPoint

    {
        SIZE size, sizeU;
        RECT rc;

// couple of strings to demonstrate that there is no overlap of chars that
// have low stems with the top of the next row

        char *psz1 = "ab__cdjjyygg";
        char *psz2 = "abTTHHTT__djjyygg";
        char *psz3 = "abTTHHTTcdjjyygg";
        int x,y;

        PatBlt(hdcScreen, 0,0, 2000, 2000, WHITENESS);


        if (
            !GetTextExtentPoint(hdcScreen, pszTOU, strlen(pszTOU),&size)
                  ||
            !GetTextExtentPointW(hdcScreen, (LPWSTR)ajStack, strlen(pszTOU),&sizeU)
           )
        {
            DbgPrint("GetTextExtentPoint or GetTextExtentPointW failed\n\n");
        }

        DbgPrint("size.cx = %ld, size.cy = %ld \n", size.cx, size.cy);
        DbgPrint("sizeU.cx = %ld, sizeU.cy = %ld \n", sizeU.cx, sizeU.cy);

        SetBkColor(hdcScreen, RGB(255,0,0));

        x = 200;
        y = 20;
        TextOut(hdcScreen, x, y, psz1, strlen(psz1));
        y += size.cy;
        TextOut(hdcScreen, x, y, psz2, strlen(psz2));
        y += size.cy;
        TextOut(hdcScreen, x, y, psz3, strlen(psz3));


// demonstrate that clipping and opaqueing works

        SetBkColor(hdcScreen, RGB(0,255,0));

        GetTextExtentPoint(hdcScreen, psz1, strlen(psz1), &size);

        x = 10;
        y = 200;

        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);

        ExtTextOut(hdcScreen, x, y, 0 ,NULL , psz1, strlen(psz1), NULL);

        y += (2 * size.cy);
        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);
        ExtTextOut(hdcScreen, x, y, ETO_CLIPPED ,&rc, psz1, strlen(psz1), NULL);

        y += (2 * size.cy);
        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);
        ExtTextOut(hdcScreen, x, y, ETO_OPAQUE ,&rc, psz1, strlen(psz1), NULL);

        y += (2 * size.cy);
        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);
        ExtTextOut(hdcScreen, x, y, ETO_CLIPPED | ETO_OPAQUE,&rc, psz1, strlen(psz1), NULL);

        SetBkMode(hdcScreen, TRANSPARENT);

        x = 300;
        y = 200;

        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);

        ExtTextOut(hdcScreen, x, y, 0 ,NULL , psz1, strlen(psz1), NULL);

        y += (2 * size.cy);
        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);
        ExtTextOut(hdcScreen, x, y, ETO_CLIPPED ,&rc, psz1, strlen(psz1), NULL);

        y += (2 * size.cy);
        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);
        ExtTextOut(hdcScreen, x, y, ETO_OPAQUE ,&rc, psz1, strlen(psz1), NULL);

        y += (2 * size.cy);
        rc.left = x;
        rc.top  = y;
        rc.right = x + (3 * size.cx / 4);
        rc.bottom = y + (size.cy / 2);
        ExtTextOut(hdcScreen, x, y, ETO_CLIPPED | ETO_OPAQUE,&rc, psz1, strlen(psz1), NULL);


        SetBkMode(hdcScreen, OPAQUE);

        SetBkColor(hdcScreen, RGB(255,255,255));
    }





}




typedef struct _FONTFACE
{
    ULONG cFont;                   // COUNT OF FONTS WITH THIS FACE NAME
    UCHAR achFaceName[LF_FACESIZE];
} FONTFACE, *PFONTFACE;

typedef struct _FONTFACEW
{
    ULONG cFont;                   // COUNT OF FONTS WITH THIS FACE NAME
    WCHAR awcFaceName[LF_FACESIZE];
} FONTFACEW, *PFONTFACEW;


typedef struct _TEXTOUTDATA
{
    int cFaces;
    HDC hdc;
    int x;
    int y;
} TEXTOUTDATA, *PTEXTOUTDATA;


#define FF_CUTOFF 10

FONTFACE  gaff[FF_CUTOFF];
FONTFACEW gaffw[FF_CUTOFF];



/******************************Public*Routine******************************\
*
*  callback function, to be used with lpFaceName == NULL, to get the total
*  number of all face names
*
\**************************************************************************/

int iCountFaces
(
PLOGFONT     plf,
PTEXTMETRIC  ptm,
int          flFontType,
PVOID        pv
)
{

    PTEXTOUTDATA ptod = (PTEXTOUTDATA)pv;
    HFONT hf, hfOld;

    strcpy(gaff[ptod->cFaces].achFaceName, plf->lfFaceName);

    hf = CreateFontIndirect(plf);

    if (hf == (HFONT)0)
    {
        DbgPrint("CreateFontIndirect failed \n");
        return 0;
    }


    hfOld = SelectObject(ptod->hdc, hf);
    if (flFontType & RASTER_FONTTYPE)
        TextOut(ptod->hdc, ptod->x, ptod->y, plf->lfFaceName, strlen(plf->lfFaceName));
    ptod->y += (ptm->tmHeight + ptm->tmExternalLeading);

    SelectObject(ptod->hdc, hfOld);
    if (!DeleteObject(hf))
    {
        DbgPrint("DeleteObject(hf) failed \n");
        return 0;
    }

    ptod->cFaces++;

    if (ptod->cFaces >= FF_CUTOFF)
        return 0;     // break out of the loop that calls this function
    return(1);
}



int iCountFacesW
(
PLOGFONTW     plfw,
PTEXTMETRICW  ptmw,
int           flFontType,
PVOID         pv
)
{

    PTEXTOUTDATA ptod = (PTEXTOUTDATA)pv;
    HFONT hf, hfOld;

    wcscpy(gaffw[ptod->cFaces].awcFaceName, plfw->lfFaceName);

    hf = CreateFontIndirectW(plfw);
    if (hf == (HFONT)0)
    {
        DbgPrint("CreateFontIndirectW failed \n");
        return 0;
    }

    hfOld = SelectObject(ptod->hdc, hf);
    if (flFontType & RASTER_FONTTYPE)
	TextOutW(ptod->hdc, ptod->x, ptod->y, plfw->lfFaceName, wcslen(plfw->lfFaceName));
    ptod->y += (ptmw->tmHeight + ptmw->tmExternalLeading);

    SelectObject(ptod->hdc, hfOld);
    if (!DeleteObject(hf))
    {
        DbgPrint("DeleteObject(hf) failed \n");
        return 0;
    }

    ptod->cFaces++;
    if (ptod->cFaces >= FF_CUTOFF)
        return 0;     // break out of the loop that calls this function

    return(1);
}

#define COLORS 7

COLORREF gcr[COLORS] =
{
RGB(0,255,255),
RGB(255,0,255),
RGB(255,255,0),
RGB(0,0,255),
RGB(0,255,0),
RGB(255,0,0),
RGB(127,127,127)
};


int  iPrintSample
(
PLOGFONT     plf,
PTEXTMETRIC  ptm,
int          flFontType,
PVOID        pv
)
{

    PTEXTOUTDATA ptod = (PTEXTOUTDATA)pv;
    HFONT hf, hfOld;


    hf = CreateFontIndirect(plf);

    if (hf == (HFONT)0)
    {
        DbgPrint("CreateFontIndirect failed \n");
        return 0;
    }

    hfOld = SelectObject(ptod->hdc, hf);

    SetTextColor(ptod->hdc, gcr[plf->lfHeight % COLORS]);
    if (flFontType & RASTER_FONTTYPE)
        TextOut(ptod->hdc, ptod->x, ptod->y, plf->lfFaceName, strlen(plf->lfFaceName));
    ptod->y += (ptm->tmHeight + ptm->tmExternalLeading);

    SelectObject(ptod->hdc, hfOld);
    if (!DeleteObject(hf))
    {
        DbgPrint("DeleteObject(hf) failed \n");
        return 0;
    }

    return(1);
}

int  iPrintSampleW
(
PLOGFONTW     plfw,
PTEXTMETRICW  ptmw,
int           flFontType,
PVOID         pv
)
{

    PTEXTOUTDATA ptod = (PTEXTOUTDATA)pv;
    HFONT hf, hfOld;

    hf = CreateFontIndirectW(plfw);
    if (hf == (HFONT)0)
    {
        DbgPrint("CreateFontIndirectW failed \n");
        return 0;
    }

    hfOld = SelectObject(ptod->hdc, hf);

    SetTextColor(ptod->hdc, gcr[plfw->lfHeight % COLORS]);
    if (flFontType & RASTER_FONTTYPE)
	TextOutW(ptod->hdc, ptod->x, ptod->y, plfw->lfFaceName, wcslen(plfw->lfFaceName));
    ptod->y += (ptmw->tmHeight + ptmw->tmExternalLeading);

    SelectObject(ptod->hdc, hfOld);
    if (!DeleteObject(hf))
    {
        DbgPrint("DeleteObject(hf) failed \n");
        return 0;
    }

    return(1);
}





VOID  vTestEnumFonts(HDC hdc)
{
    TEXTOUTDATA tod, todW;
    int iFace;

// initialize

    BitBlt(
           hdc,               // Dst
           0, 0,              // Dst
           2000, 1000,        // cx, cy
           (HDC)0,            // Src
           0,0,               // Src
           WHITENESS
          );


    tod.cFaces = 0;
    tod.hdc = hdc;
    tod.x   = 10;
    tod.y   = 10;

    EnumFonts(hdc, (LPCSTR)NULL, (FONTENUMPROC)iCountFaces, (LPARAM)&tod);

    DbgPrint("\n Total number of faces = %ld\n", tod.cFaces);

    todW.cFaces = 0;
    todW.hdc = hdc;
    todW.x   = 300;
    todW.y   = 10;

    EnumFontsW(hdc, (LPWSTR)NULL, (FONTENUMPROCW)iCountFacesW, (LPARAM)&todW);

    DbgPrint("\n Total number of faces = %ld\n", todW.cFaces);

    if (tod.cFaces != todW.cFaces)
    {
        DbgPrint("\n tod.cFaces != todW.cFaces \n");
        return;
    }

    for (iFace = 0; iFace < tod.cFaces; iFace++)
    {
        BitBlt(
               hdc,               // Dst
               0, 0,              // Dst
               2000, 1000,        // cx, cy
               (HDC)0,            // Src
               0,0,               // Src
               WHITENESS
              );

        tod.hdc = hdc;
        tod.x   = 10;
        tod.y   = 10;

        todW.hdc = hdc;
        todW.x   = 300;
        todW.y   = 10;



        EnumFonts (hdc, gaff[iFace].achFaceName, (FONTENUMPROC)iPrintSample , (LPARAM)&tod);
        EnumFontsW(hdc, gaffw[iFace].awcFaceName,(FONTENUMPROCW)iPrintSampleW, (LPARAM)&todW);
    }

    SetTextColor(hdc, RGB(0,0,0));

}


VOID DbgPrintLOGFONT(PVOID pv)
{
    PLOGFONT  plf = (PLOGFONT)pv;

        DbgPrint("\n");
        DbgPrint("lfHeight          = %ld\n", (LONG)plf->lfHeight          );
        DbgPrint("lfWidth           = %ld\n", (LONG)plf->lfWidth           );
        DbgPrint("lfEscapement      = %ld\n", (LONG)plf->lfEscapement      );
        DbgPrint("lfOrientation     = %ld\n", (LONG)plf->lfOrientation     );
        DbgPrint("lfWeight          = %ld\n", (LONG)plf->lfWeight          );
        DbgPrint("lfItalic          = %ld\n", (LONG)plf->lfItalic          );
        DbgPrint("lfUnderline       = %ld\n", (LONG)plf->lfUnderline       );
        DbgPrint("lfStrikeOut       = %ld\n", (LONG)plf->lfStrikeOut       );
        DbgPrint("lfCharSet         = %ld\n", (LONG)plf->lfCharSet         );
        DbgPrint("lfOutPrecision    = %ld\n", (LONG)plf->lfOutPrecision    );
        DbgPrint("lfClipPrecision   = %ld\n", (LONG)plf->lfClipPrecision   );
        DbgPrint("lfQuality         = %ld\n", (LONG)plf->lfQuality         );
        DbgPrint("lfPitchAndFamily  = %ld\n", (LONG)plf->lfPitchAndFamily  );

        DbgPrint("face name = %s\n", plf->lfFaceName);
        DbgPrint("\n");

}


/******************************Public*Routine******************************\
*
* vTestAddFR(HDC hdc);
*
* Effects:
*
* Warnings:
*
* History:
*  12-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID  vTestAddFR(HDC hdcScreen)
{
// test add/remove font resource
    LPSTR pszFileName = "serife.fon";
    LPSTR pszPath = "c:\\nt\\system\\serife.fon";
    int cFonts, cFontsSave;
    BYTE ajStack[CGLYPHS * 2];   // can accomodate up to CGLYPHS WCHARS

    cFontsSave = cFonts = AddFontResource(pszFileName);
    if (cFontsSave == 0)
        DbgPrint("AddFontResource(%s) failed\n\n", pszFileName);
    else
    {
        DbgPrint("AddFontResource(%s) loaded %ld fonts\n\n", pszFileName, cFonts);
        if (!RemoveFontResource(pszFileName))
            DbgPrint("RemoveFontResource(%s) failed\n\n", pszFileName);

        cFonts = cFontsSave = AddFontResource(pszPath);
        if ((cFonts == 0) || (cFonts != cFontsSave))
            DbgPrint("AddFontResource(%s) failed, cFonts = %ld\n\n", pszPath, cFonts);
        else
        {
            DbgPrint("AddFontResource(%s) succeeded, cFonts = %ld\n\n", pszPath, cFonts);
            if (!RemoveFontResource(pszPath))
                DbgPrint("RemoveFontResourceW(%s) failed\n\n", pszPath);
        }

    // convert the strings to unicode

        vToUNICODE((LPWSTR)ajStack, pszFileName);

        cFonts = cFontsSave = AddFontResourceW((LPWSTR)ajStack);
        if ((cFonts == 0) || (cFonts != cFontsSave))
            DbgPrint("AddFontResourceW(%s) failed, cFonts = %ld\n\n", pszFileName, cFonts);
        else
        {
            DbgPrint("AddFontResourceW(%s) succeeded, cFonts = %ld\n\n", pszFileName, cFonts);
            if (!RemoveFontResourceW((LPWSTR)ajStack))
                DbgPrint("RemoveFontResourceW(%s) failed\n\n", pszPath);
        }

        vToUNICODE((LPWSTR)ajStack, pszPath);

        cFonts = cFontsSave = AddFontResourceW((LPWSTR)ajStack);
        if ((cFonts == 0) || (cFonts != cFontsSave))
            DbgPrint("AddFontResourceW(%s) failed, cFonts = %ld\n\n", pszPath, cFonts);
        else
        {
            DbgPrint("AddFontResourceW(%s) succeeded, cFonts = %ld\n\n", pszPath, cFonts);

            if (!RemoveFontResourceW((LPWSTR)ajStack))
                DbgPrint("RemoveFontResourceW(%s) failed\n\n", pszPath);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftreset.c ===
/******************************Module*Header*******************************\
* Module Name: ftjnl.c
*
* (Brief description)
*
* Created: 20-Feb-1992 08:41:04
* Author:  - by - Eric Kutter [erick]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/******************************Public*Routine******************************\
*
*
*
* History:
*  20-Feb-1992 -by-  - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/
VOID vPage1F(HWND hwnd, HDC hdc, RECT* prcl);

VOID vPageOut(HDC hdc,int page,int doc, PSZ pszMode)
{
    int x,y;
    CHAR ach[120];

    StartPage(hdc);
    x = GetDeviceCaps(hdc,HORZRES) - 1;
    y = GetDeviceCaps(hdc,VERTRES) - 1;

    sprintf(ach,"Page %ld, Doc %ld, (%ld x %ld), in %s",page,doc,x,y,pszMode);

    TextOut(hdc,500,50,ach,strlen(ach));

    MoveToEx(hdc,0,0,NULL);
    LineTo(hdc,x,0);
    LineTo(hdc,x,y);
    LineTo(hdc,0,y);
    LineTo(hdc,0,0);

    vPage1F(NULL,hdc,NULL);

    EndPage(hdc);
}


/******************************Public*Routine******************************\
*
* History:
*  15-Jan-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vTestResetDC(HWND hwnd, HDC hdcDisp, RECT *prcl)
{
    PRINTDLG pd;
    HDC hdc;
    CHAR achBuf[80];
    INT i;
    LPDEVMODE lpDevMode;
    LPDEVMODE pdmPortrait = NULL;
    LPDEVMODE pdmLandscape = NULL;
    LPDEVNAMES lpDevNames;
    DOCINFO    di;

    di.cbSize = sizeof(di);
    di.lpszDocName = NULL;
    di.lpszOutput   = NULL;
    di.lpszDatatype = NULL;
    di.fwType       = 0;

    memset(&pd,0,sizeof(pd));

    pd.lStructSize = sizeof(pd);
    pd.hwndOwner   = hwnd;
    pd.hDevMode    = NULL;
    pd.hDevNames   = NULL;
    pd.hDC         = NULL;
    pd.Flags       = PD_RETURNDC | PD_PAGENUMS;
    pd.nCopies     = 1;
    pd.nFromPage   = 1;
    pd.nToPage     = 1;
    pd.nMinPage    = 1;
    pd.nMaxPage    = 1;

    if(!pd.hDevNames) /* Retrieve default printer if none selected. */
    {
        pd.Flags = PD_RETURNDEFAULT|PD_PRINTSETUP;
        if (!PrintDlg(&pd))
            return;
    }

    if (!pd.hDevNames)
    {
        DbgPrint("bad hDevNames\n");
        return;
    }

    lpDevNames  = (LPDEVNAMES)GlobalLock(pd.hDevNames);

    if (pd.hDevMode)
    {
        lpDevMode = (LPDEVMODE)GlobalLock(pd.hDevMode);

        pdmPortrait = (LPDEVMODE)LocalAlloc(LMEM_FIXED,lpDevMode->dmSize + lpDevMode->dmDriverExtra);
        memcpy(pdmPortrait,lpDevMode,lpDevMode->dmSize + lpDevMode->dmDriverExtra);
        pdmPortrait->dmOrientation = DMORIENT_PORTRAIT;

        pdmLandscape = (LPDEVMODE)LocalAlloc(LMEM_FIXED,lpDevMode->dmSize + lpDevMode->dmDriverExtra);
        memcpy(pdmLandscape,lpDevMode,lpDevMode->dmSize + lpDevMode->dmDriverExtra);
        pdmLandscape->dmOrientation = DMORIENT_LANDSCAPE;

        GlobalUnlock(lpDevMode);
        GlobalFree(pd.hDevMode);
    }
    else
    {
        DbgPrint("null pdev, reset DC won't work\n");
    }

    /*  For pre 3.0 Drivers,hDevMode will be null  from Commdlg so lpDevMode
     *  will be NULL after GlobalLock()
     */

    hdc = CreateDC((LPSTR)lpDevNames+lpDevNames->wDriverOffset,
                           (LPSTR)lpDevNames+lpDevNames->wDeviceOffset,
                           (LPSTR)lpDevNames+lpDevNames->wOutputOffset,
                           pdmPortrait);

    GlobalUnlock(pd.hDevNames);
    GlobalFree(pd.hDevNames);

    DbgPrint("ResetDC test, hdc = %lx \n", hdc);

    if (hdc == NULL)
    {
        DbgPrint("couldn't create DC\n");
	return;
    }

// DOC 1

    di.lpszDocName = "Document1";
    StartDoc(hdc,&di);

    ResetDC(hdc,pdmLandscape);
    vPageOut(hdc,1,1,"landscape");

    ResetDC(hdc,pdmPortrait);
    vPageOut(hdc,2,1,"portrait");

    ResetDC(hdc,pdmLandscape);
    vPageOut(hdc,3,1,"landscape");

    ResetDC(hdc,pdmPortrait);
    vPageOut(hdc,4,1,"portrait");

    EndDoc(hdc);

#if 1
// DOC 2

    ResetDC(hdc,pdmLandscape);
    di.lpszDocName = "Document2";
    StartDoc(hdc,&di);

    vPageOut(hdc,1,2,"landscape");

    ResetDC(hdc,pdmPortrait);  // prepare for Doc 3

    EndDoc(hdc);

// DOC 3

    di.lpszDocName = "Document3";
    StartDoc(hdc,&di);

    vPageOut(hdc,1,3,"portrait");

    ResetDC(hdc,pdmLandscape);
    ResetDC(hdc,pdmPortrait);
    ResetDC(hdc,pdmLandscape);

    vPageOut(hdc,2,3,"landscape");

    EndDoc(hdc);
#endif

    DeleteDC(hdc);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftwin95.c ===
/******************************Module*Header*******************************\
* Module Name: ftwin95.c
*
* (Brief description)
*
* Created: 22-Mar-1995 14:51:47
* Author: Bodin Dresevic [BodinD]
*
* test some multilingual win95 apis
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

VOID  vDisplayFontSignature(FONTSIGNATURE *pfs)
{
    DbgPrint("pfs->fsUsb[0] = 0x%lx\n", pfs->fsUsb[0]);
    DbgPrint("pfs->fsUsb[1] = 0x%lx\n", pfs->fsUsb[1]);
    DbgPrint("pfs->fsUsb[2] = 0x%lx\n", pfs->fsUsb[2]);
    DbgPrint("pfs->fsUsb[3] = 0x%lx\n", pfs->fsUsb[3]);
    DbgPrint("pfs->fsCsb[0] = 0x%lx\n", pfs->fsCsb[0]);
    DbgPrint("pfs->fsCsb[1] = 0x%lx\n", pfs->fsCsb[1]);
}



void vDisplayCharsetInfo(CHARSETINFO *pcsi)
{
    DbgPrint("\nCharsetInfo:\n");
    DbgPrint("ciCharset = 0x%lx = %ld\n", pcsi->ciCharset, pcsi->ciCharset);
    DbgPrint("ciACP     = 0x%lx = %ld\n", pcsi->ciACP, pcsi->ciACP);
    vDisplayFontSignature(&pcsi->fs);
}

#define NCHARSETS      14
#define CHARSET_ARRAYS
UINT nCharsets = NCHARSETS;
UINT charsets[] = {
      ANSI_CHARSET,   SHIFTJIS_CHARSET, HANGEUL_CHARSET, JOHAB_CHARSET,
      GB2312_CHARSET, CHINESEBIG5_CHARSET, HEBREW_CHARSET,
      ARABIC_CHARSET, GREEK_CHARSET,       TURKISH_CHARSET,
      BALTIC_CHARSET, EASTEUROPE_CHARSET,  RUSSIAN_CHARSET, THAI_CHARSET };
UINT codepages[] ={ 1252, 932, 949, 1361,
                    936,  950, 1255, 1256,
                    1253, 1254, 1257, 1250,
                    1251, 874 };
DWORD fs[] = { FS_LATIN1,      FS_JISJAPAN,    FS_WANSUNG, FS_JOHAB,
               FS_CHINESESIMP, FS_CHINESETRAD, FS_HEBREW,  FS_ARABIC,
               FS_GREEK,       FS_TURKISH,     FS_BALTIC,  FS_LATIN2,
               FS_CYRILLIC,    FS_THAI };





VOID vTestWin95Apis(HWND hwnd, HDC hdc, RECT* prcl)
{
    CHOOSEFONT cf;      /* common dialog box structure */
    LOGFONT lf;         /* logical-font structure */
    HFONT hfont;        /* new logical-font handle */
    HFONT hfontOld;     /* original logical-font handle */
    HFONT hfntTmp, hfntOldTmp;
    COLORREF crOld;     /* original text color */

    TEXTMETRICW tmw;
    LONG        lHt, y;
    UCHAR       achText[10] = {65, 66, 122, 123, 187, 188, 200, 201, 254, 255};
    int i;

// font language info

    DWORD dwFontLangInfo;

// args for GetTextCharsetInfo

    int           iTextCharsetInfo;
    FONTSIGNATURE fsig;

// translate charset info:

    BOOL          bRet;
    CHARSETINFO   csi;
    DWORD        *lpSrc;
    DWORD         afs[2];
    SIZE sz;


PSZ apszCharsets[] =
                  {
                    "ANSI_CHARSET       ",
                    "SHIFTJIS_CHARSET   ",
                    "HANGEUL_CHARSET    ",
                    "JOHAB_CHARSET      ",
                    "GB2312_CHARSET     ",
                    "CHINESEBIG5_CHARSET",
                    "HEBREW_CHARSET     ",
                    "ARABIC_CHARSET     ",
                    "GREEK_CHARSET      ",
                    "TURKISH_CHARSET    ",
                    "BALTIC_CHARSET     ",
                    "EASTEUROPE_CHARSET ",
                    "RUSSIAN_CHARSET    ",
                    "THAI_CHARSET       "
                   };


    cf.lStructSize = sizeof (CHOOSEFONT);
    cf.hwndOwner = hwnd;
    cf.lpLogFont = &lf;

    cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_FORCEFONTEXIST;
    cf.rgbColors = RGB(255, 0, 0);
    cf.nFontType = SCREEN_FONTTYPE;

    /*
     * Display the dialog box, allow the user to
     * choose a font, and render the text in the
     * window with that selection.
     */

    if (!ChooseFont(&cf))
    {
        DbgPrint("Font selection failed\n");
        return;
    }

    crOld = SetTextColor(hdc, cf.rgbColors);

// Hack, the way to specify the size

    hfont = CreateFontIndirect(&lf);
    hfontOld = SelectObject(hdc, hfont);

    GetTextMetricsW(hdc,&tmw);
    lHt  = tmw.tmHeight + 10; // add little bit to be safe;
    GetTextExtentPointA(hdc, apszCharsets[4],
                             strlen(apszCharsets[4]),
                             &sz);


// start testing

    dwFontLangInfo = GetFontLanguageInfo(hdc);
    DbgPrint("dwFontLangInfo = 0x%lx\n", dwFontLangInfo);

    iTextCharsetInfo = GetTextCharsetInfo(hdc, &fsig, 0);
    DbgPrint("\n\n GetTextCharsetInfo = 0x%lx\n", iTextCharsetInfo);
    vDisplayFontSignature(&fsig);

    DbgPrint("\n\n vDisplayCharsetInfo: TCI_SRCFONTSIG\n\n");
    DbgPrint("Listing supported windows code pages:\n");

    afs[1] = 0;              // null out oem code pages;
    for (i = 0; i < 32; i++)
    {
        afs[0] = fsig.fsCsb[0] & (DWORD)(1 << i); // single out one bit:
        bRet = TranslateCharsetInfo(afs, &csi, TCI_SRCFONTSIG);

        if (bRet)
            vDisplayCharsetInfo(&csi);
    }

    DbgPrint("\n\n vDisplayCharsetInfo: TCI_SRCCHARSET\n\n");

    for (i = 0,y = 10; i < sizeof(charsets)/sizeof(charsets[0]); i++, y+=lHt)
    {
        lpSrc = (DWORD *)charsets[i];
        bRet = TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCHARSET);
        ASSERTGDI(csi.fs.fsCsb[0] == fs[i], "fsCsb wrong!!!?\n");
        DbgPrint("TranslateCharsetInfo(0x%lx, TCI_SRCCHARSET)\n",charsets[i]);
        vDisplayCharsetInfo(&csi);

    // display our sample string in this charset:

        lf.lfCharSet = charsets[i];

        hfntTmp    = CreateFontIndirect(&lf);
        hfntOldTmp = SelectObject(hdc, hfntTmp);

        TextOutA(hdc, 10, y, apszCharsets[i], strlen(apszCharsets[i]));
        TextOutA(hdc, 10 + sz.cx + 10, y, achText, sizeof(achText));

        SelectObject(hdc, hfntOldTmp);
        DeleteObject(hfntTmp);
    }

    DbgPrint("\n\n vDisplayCharsetInfo: TCI_SRCCODEPAGE\n\n");

    for (i = 0; i < sizeof(codepages)/sizeof(codepages[0]); i++)
    {
        lpSrc = (DWORD *)codepages[i];
        bRet = TranslateCharsetInfo(lpSrc, &csi, TCI_SRCCODEPAGE);
        ASSERTGDI(csi.fs.fsCsb[0] == fs[i], "fsCsb wrong!!!?\n");
        DbgPrint("TranslateCharsetInfo(0x%lx, TCI_SRCCODEPAGE)\n",codepages[i]);
        vDisplayCharsetInfo(&csi);
    }

    SelectObject(hdc, hfontOld);
    DeleteObject(hfont);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftstr.c ===
/******************************Module*Header*******************************\
* Module Name: ftstr.c
*
* Tests for StretchBlts
*
* Created: 09-Sep-1991 12:27:04
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#define OEMRESOURCE 1

extern BYTE abColorLines[];

VOID vTestStretch1(HDC hdc);
VOID vTestStretch2(HDC hdc);
VOID vTestStretch3(HDC hdc);
VOID vTestStretch4(HDC hdc);

/******************************Public*Routine******************************\
* vTestStretch
*
* Test StretchBlt functions.
*
* History:
*  09-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestStretch(HWND hwnd, HDC hdc, RECT* prcl)
{
    hwnd;
    prcl;
    PatBlt(hdc, 0, 0, 2000, 2000, WHITENESS);
    vTestStretch1(hdc);
    vTestStretch2(hdc);
    vTestStretch3(hdc);
    vTestStretch4(hdc);
}

/******************************Public*Routine******************************\
* vTestStretch1
*
* Test some simple stretching.
*
* History:
*  09-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestStretch1(HDC hdc)
{
    HDC hdc4;
    HBITMAP hbm4;
    HBITMAP hbmbrush;
    HBRUSH hbr, hbrDefault;
    BOOL bReturn;
    DWORD White[] =  { 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa };

    hbmbrush = CreateBitmap(8, 8, 1, 1, (LPBYTE) White);

    if (hbmbrush == (HBITMAP) 0)
    {
	DbgPrint("vTestStretch1 bm brush bitmap create failed\n");
	return;
    }

    hbr  = CreatePatternBrush(hbmbrush);

    if (hbr == (HBRUSH) 0)
    {
	DbgPrint("vTestStretch1 bm brush brush create failed\n");
	return;
    }

    hbrDefault = SelectObject(hdc, hbr);

    if (hbrDefault == (HBRUSH) 0)
    {
	DbgPrint("vTEstiedi failed select[aodgq[woe");
	return;
    }

    hdc4 = CreateCompatibleDC(hdc);
    hbm4 = CreateBitmap(64, 64, 1, 4, abColorLines);
    SelectObject(hdc4, hbm4);

    StretchBlt(hdc, 0,	 0,  64,  64,  hdc4, 0,  0,  64,  64, SRCCOPY);
    StretchBlt(hdc, 128, 0, -64,  64,  hdc4, 0,  0,  64,  64, SRCCOPY);
    StretchBlt(hdc, 128, 0,  64,  64,  hdc4, 64, 0, -64,  64, SRCCOPY);
    StretchBlt(hdc, 192, 64, 64, -64,  hdc4, 0,  0,  64,  64, SRCCOPY);
    StretchBlt(hdc, 256, 0,  64,  64,  hdc4, 0,  64, 64, -64, SRCCOPY);

    StretchBlt(hdc, 0,	 128,  64,  64,  hdc4, 0,  0,  64,  64, NOTSRCCOPY);
    StretchBlt(hdc, 128, 128, -64,  64,  hdc4, 0,  0,  64,  64, NOTSRCCOPY);
    StretchBlt(hdc, 128, 128,  64,  64,  hdc4, 64, 0, -64,  64, NOTSRCCOPY);
    StretchBlt(hdc, 192, 192,  64, -64,  hdc4, 0,  0,  64,  64, NOTSRCCOPY);
    StretchBlt(hdc, 256, 128,  64,  64,  hdc4, 0,  64, 64, -64, NOTSRCCOPY);

    bReturn = StretchBlt(hdc, 0,   65,	64,  64,  hdc4, 0,  0,	64,  64, 0x00CA0000);
    if (!bReturn)
	DbgPrint("Failed1 ftstr\n");

    bReturn = StretchBlt(hdc, 128, 65, -64,  64,  hdc4, 0,  0,	64,  64, 0x00CA0000);
    if (!bReturn)
	DbgPrint("Failed2 ftstr\n");

    bReturn = StretchBlt(hdc, 128, 65,	64,  64,  hdc4, 64, 0, -64,  64, 0x00CA0000);
    if (!bReturn)
	DbgPrint("Failed3 ftstr\n");

    bReturn = StretchBlt(hdc, 192, 129,  64, -64,  hdc4, 0,  0,  64,  64, 0x00CA0000);
    if (!bReturn)
	DbgPrint("Failed4 ftstr\n");

    bReturn = StretchBlt(hdc, 256, 65,	64,  64,  hdc4, 0,  64, 64, -64, 0x00CA0000);
    if (!bReturn)
	DbgPrint("Failed5 ftstr\n");

    SelectObject(hdc, hbrDefault);

    DeleteDC(hdc4);
    DeleteObject(hbm4);
    DeleteObject(hbmbrush);
    DeleteObject(hbr);
}

/******************************Public*Routine******************************\
* vTestStretch2
*
* Test that we don't gp-fault doing text to the default bitmap memory dc.
*
* History:
*  09-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestStretch2(HDC hdc)
{
    HDC hdc4;
    HBITMAP hbm4;
    hdc4 = CreateCompatibleDC(hdc);
    hbm4 = CreateCompatibleBitmap(hdc, 100, 100);

    StretchBlt(hdc4, 0,   0,  1,  1,	hdc,  0,  0,  64,  64, SRCCOPY);
    StretchBlt(hdc4, 0, 0, -64,  64,  hdc,  0,	0,  64,  64, SRCCOPY);
    StretchBlt(hdc4, 0, 0,  64,  64,  hdc,  64, 0, -64,  64, SRCCOPY);
    StretchBlt(hdc4, 0, 64, 64, -64,  hdc,  0,	0,  64,  64, SRCCOPY);
    StretchBlt(hdc4, 256, 0,  64,  64,	hdc,  0,  64, 64, -64, SRCCOPY);
    StretchBlt(hdc4, 0, 0, 100, 100, hdc, 0, 0, 100, 100, SRCCOPY);

    SelectObject(hdc4, hbm4);

    StretchBlt(hdc4, 0,   0,  1,  1,	hdc,  0,  0,  64,  64, SRCCOPY);
    StretchBlt(hdc4, 0, 0, -64,  64,  hdc,  0,	0,  64,  64, SRCCOPY);
    StretchBlt(hdc4, 0, 0,  64,  64,  hdc,  64, 0, -64,  64, SRCCOPY);
    StretchBlt(hdc4, 0, 64, 64, -64,  hdc,  0,	0,  64,  64, SRCCOPY);
    StretchBlt(hdc4, 256, 0,  64,  64,	hdc,  0,  64, 64, -64, SRCCOPY);
    StretchBlt(hdc4, 0, 0, 100, 100, hdc, 0, 0, 100, 100, SRCCOPY);

    DeleteDC(hdc4);
    DeleteObject(hbm4);
}

/******************************Public*Routine******************************\
* vTestStretch3
*
* Solve the button problem
*
* History:
*  09-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestStretch3(HDC hdc)
{
    HBITMAP hbm1, hbm2, hbm4, hbmDib;
    HDC hdc1, hdc2, hdc4, hdcDib;
    HBRUSH hbrR, hbrB, hbrDefault;
    UINT x1,y1,x2,y2;
    BITMAP bm;
    BITMAPINFOHEADER bmiTemp;

    bmiTemp.biSize	      = sizeof(BITMAPINFOHEADER);
    bmiTemp.biWidth	      = 368;
    bmiTemp.biHeight	      = 18;
    bmiTemp.biPlanes	      = 1;
    bmiTemp.biBitCount	      = 4;
    bmiTemp.biCompression     = BI_RGB;
    bmiTemp.biSizeImage       = 0;
    bmiTemp.biXPelsPerMeter   = 0;
    bmiTemp.biYPelsPerMeter   = 0;
    bmiTemp.biClrUsed	      = 16;
    bmiTemp.biClrImportant    = 16;

    hbrR = CreateSolidBrush(RGB(0xFF, 0, 0));
    hbrB = CreateSolidBrush(RGB(0, 0, 0xFF));

    hbmDib = CreateDIBitmap(hdc, &bmiTemp, 0, (LPBYTE) NULL, (LPBITMAPINFO) NULL, DIB_RGB_COLORS);
    if (hbmDib == (HBITMAP) 0)
    {
	DbgPrint("hbmDib failed");
	return;
    }

    hdcDib = CreateCompatibleDC(hdc);
    SelectObject(hdcDib, hbmDib);
    SelectObject(hdcDib, hbrR);
    PatBlt(hdcDib, 0, 0, 368, 18, PATCOPY);

    hbm4 = CreateBitmap(368,18,1,4,NULL);
    hdc4 = CreateCompatibleDC(hdc);
    SelectObject(hdc4,hbm4);
    SelectObject(hdc4, hbrR);
    PatBlt(hdc4, 0, 0, 170, 18, PATCOPY);

    hbm1 = LoadBitmap((HINSTANCE) NULL, (LPSTR) OBM_DNARROWD);
    hbm2 = LoadBitmap((HINSTANCE) NULL, (LPSTR) OBM_DNARROW);
    hdc1 = CreateCompatibleDC(hdc);
    hdc2 = CreateCompatibleDC(hdc);
    SelectObject(hdc1, hbm1);
    SelectObject(hdc2, hbm2);

    GetObject(hbm1, sizeof(BITMAP), &bm);
    x1 = bm.bmWidth;
    y1 = bm.bmHeight;

    GetObject(hbm2, sizeof(BITMAP), &bm);
    x2 = bm.bmWidth;
    y2 = bm.bmHeight;

// Test to bimap then to screen.

    BitBlt(hdc4, 36, 0, 17, 17, hdc2, 0, 0, SRCCOPY);
    BitBlt(hdcDib, 36, 0, 17, 17, hdc2, 0, 0, SRCCOPY);
    BitBlt(hdc, 350, 0, 100, 18, hdc4, 0, 0, SRCCOPY);
    BitBlt(hdc, 450, 0, 100, 18, hdcDib, 0, 0, SRCCOPY);

    StretchBlt(hdc, 350, 30, 17, 17, hdc4, 36, 0, 17, 17, SRCCOPY);
    StretchBlt(hdc, 380, 30, 17, 17, hdcDib, 36, 0, 17, 17, SRCCOPY);

// Test to screen

    BitBlt(hdc, 0, 300, 20, 20, hdc1, 0, 0, SRCCOPY);

    hbrDefault = SelectObject(hdc, hbrB);
    PatBlt(hdc, 38, 299, 21, 21, PATCOPY);

    SelectObject(hdc, hbrR);
    PatBlt(hdc, 39, 300, 19, 19, PATCOPY);

    BitBlt(hdc, 40, 301, 20, 20, hdc1, 0, 0, SRCCOPY);
    BitBlt(hdc, 80, 300, 20, 20, hdc2, 0, 0, SRCCOPY);
    BitBlt(hdc, 120, 301, 20, 20, hdc2, 0, 0, SRCCOPY);

    StretchBlt(hdc, 0, 320, x1, y1, hdc1, 0, 0, x1, y1, SRCCOPY);

    SelectObject(hdc, hbrB);
    PatBlt(hdc, 28, 319, 21, 21, PATCOPY);

    SelectObject(hdc, hbrR);
    PatBlt(hdc, 29, 320, 19, 19, PATCOPY);

    StretchBlt(hdc, 30, 321, x1, y1, hdc1, 0, 0, x1, y1, SRCCOPY);

    StretchBlt(hdc, 60, 322, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 90, 323, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 120, 324, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 150, 325, x2 - 1, y2 - 1, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 180, 326, x2 - 1, y2 - 1, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 210, 327, x2 - 2, y2 - 2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 240, 328, x2 - 2, y2 - 2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 270, 329, x2 - 3, y2 - 3, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 300, 330, x2 - 3, y2 - 3, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 330, 331, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 360, 332, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 390, 333, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 420, 334, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);
    StretchBlt(hdc, 450, 335, x2, y2, hdc2, 0, 0, x2, y2, SRCCOPY);

    SelectObject(hdc,hbrDefault);

    if (!DeleteDC(hdcDib))
        DbgPrint("vStretch3 This is bogus1\n");
    if (!DeleteDC(hdc1))
        DbgPrint("vStretch3 This is bogus1\n");
    if (!DeleteDC(hdc2))
        DbgPrint("vStretch3 This is bogus2\n");
    if (!DeleteDC(hdc4))
        DbgPrint("vStretch3 This is bogus2\n");
    if (!DeleteObject(hbm1))
        DbgPrint("vStretch3 This is bogus3\n");
    if (!DeleteObject(hbm2))
        DbgPrint("vStretch3 This is bogus4\n");
    if (!DeleteObject(hbm4))
        DbgPrint("vStretch3 This is bogus4\n");

    if (!DeleteObject(hbmDib))
    {
        DbgPrint("vTestStretch->vTestStretch3: delete of hmbDIBfails\n");
    }

    DeleteObject(hbrR);
    DeleteObject(hbrB);
}

/******************************Public*Routine******************************\
* vTestStretch4
*
* Test stretching and blting of 32/pel bitmaps.
*
* History:
*  03-Dec-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vTestStretch4(HDC hdc)
{
#ifdef THISISFIXED

// this is completely broken.  You need to use a DIB not a bitmap.  The
// selectobject of hdc32, hbm32 is failing.

    HDC     hdc32;
    HBITMAP hbm32;
    HBRUSH  hbrR, hbrG;
    ULONG   ul1;

    hdc32 = CreateCompatibleDC(hdc);
    hbm32 = CreateBitmap(100, 100, 1, 32, NULL);
    SelectObject(hdc32, hbm32);
    hbrR = CreateSolidBrush(RGB(255,0,0));
    hbrG = CreateSolidBrush(RGB(0,255,0));

    SelectObject(hdc32, hbrR);
    PatBlt(hdc32, 0, 0, 100, 100, PATCOPY);
    SelectObject(hdc32, hbrG);
    PatBlt(hdc32, 30, 30, 40, 40, PATCOPY);

    ul1 = SetPixel(hdc32, 0, 0, RGB(255,0,0));

    if (RGB(255,0,0) != ul1)
	DbgPrint("Failed SetPixel Stretch4 %lu\n", ul1);

    ul1 = GetPixel(hdc32, 0, 0);

    if (RGB(255,0,0) != ul1)
	DbgPrint("Failed GetPixel Stretch4 %lu\n", ul1);

    BitBlt(hdc, 0, 192, 100, 100, hdc32, 0, 0, SRCCOPY);
    StretchBlt(hdc, 100, 192, 100, 100, hdc32, 0, 0, 100, 100, SRCCOPY);
    StretchBlt(hdc, 200, 192, 50, 50, hdc32, 0, 0, 100, 100, SRCCOPY);
    StretchBlt(hdc, 250, 192, 200, 200, hdc32, 0, 0, 100, 100, SRCCOPY);

    DeleteDC(hdc32);
    DeleteObject(hbrR);
    DeleteObject(hbrG);
    DeleteObject(hbm32);

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ftxftxt.cxx ===
/******************************Module*Header*******************************\
* Module Name: ftxftxt.c
*
* xforms on text
*
*
* Created: 10-Apr-1992 16:41:02
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
*
\**************************************************************************/


extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "ft.h"
#include <stdio.h>
#include <string.h>

#include "stddef.h"
#include "wingdip.h"
BOOL bTextOut(HDC hdc, HFONT hfont, int x, int y, char * psz);

}

#define   MAX_CX  40000
#define   MAX_CY  40000

VOID vEscText   (HDC hdc);
VOID vXformText (HDC hdc);
VOID vTextInPath(HDC hdc);





VOID vClearScreen(HDC hdc)
{
    int iMode  = GetGraphicsMode(hdc);

    if (iMode == GM_ADVANCED)
    {
        DbgPrint("ft:shouldn't have tried to clear screen in adv mode\n");
        if (!ModifyWorldTransform(hdc,(PXFORM)NULL, MWT_IDENTITY))
            DbgPrint("ft:modify wt failed 1\n");

        SetGraphicsMode(hdc, GM_COMPATIBLE);
    }

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, WHITENESS);

}

/*********************************Class************************************\
* class CLASSNAME:public BASENAME
*
*   (brief description)
*
* Public Interface:
*
* History:
*  04-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

PVOID __nw(unsigned int ui)
{
    ui=ui;
    return(NULL);
}

VOID __dl(PVOID pv)
{
    pv = pv;
}



class ADVOBJ    /* hungarian prefix */
{
private:

    HDC  hdc;
    int  iModeOld;

public:

    ADVOBJ(HDC hdc_)
    {
        hdc = hdc_;
        iModeOld = SetGraphicsMode(hdc,GM_ADVANCED);
        if (iModeOld != GM_COMPATIBLE)
            DbgPrint("ft: we should have been in compatible mode \n");

    }

   ~ADVOBJ()
    {
        if (iModeOld != 0)
        {
        // restore the state of the dc so that other tests can proceed as before

            BOOL b = ModifyWorldTransform(hdc,(PXFORM)NULL, MWT_IDENTITY);
            if (!b)
                DbgPrint("ft:could not reset the xform to 1\n");

            iModeOld = SetGraphicsMode(hdc,GM_COMPATIBLE);

            if (iModeOld != GM_ADVANCED)
                DbgPrint("ft:could not reset the compatible mode  1\n");

        }
        else
        {
            DbgPrint("ft: hdc was not set to the advanced mode\n");
        }
    }

    BOOL bValid() {return (iModeOld != 0);}

};





VOID vTestXformText(HWND hwnd, HDC hdc, RECT* prcl)
{
    hwnd = hwnd; prcl = prcl;

    SaveDC(hdc);

    SetPolyFillMode(hdc,ALTERNATE);
    vEscText(hdc);
    vXformText(hdc);
    vTextInPath(hdc);

// We've probably got a wacko transform in effect; restore DC
// for rest of tests:

    RestoreDC(hdc, -1);
}



VOID  vXformTextOut
(
HDC      hdc,
int      i,
HFONT    hfont,
POINTL  *pptl,
PSZ      psz,
XFORM   *pxform
);





#define ONEOVERSQRT2 0.7071067


/******************************Public*Routine******************************\
*
* vXformTextFlipY
*
* Effects:
*
* Warnings:
*
* History:
*  10-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vXformTextFlipY(HDC hdc, HFONT hfont)
{
    int     x,y;
    PSZ psz = "This is a flip Y test";
    XFORM   xform;


    xform.eDx  = (FLOAT)0;
    xform.eDy  = (FLOAT)0;

// clear the screen

    vClearScreen(hdc);

// Set text alignment

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

    x = 10;
    y = 100;

    bTextOut(hdc, hfont, x, y, psz);

// now modify wtod transform and then try to display the text

    xform.eM11 = (FLOAT)1;
    xform.eM12 = (FLOAT)0;
    xform.eM21 = (FLOAT)0;
    xform.eM22 = (FLOAT)-1;

    y -= 450;

    ADVOBJ adv(hdc);

    if (!ModifyWorldTransform(hdc,&xform, MWT_RIGHTMULTIPLY))
        DbgPrint("ft:modify wt failed 2\n");

    bTextOut(hdc, hfont, x, y, psz);

// reset the transform back to what it was before:

    // ModifyWorldTransform(hdc,&xform, MWT_RIGHTMULTIPLY);

}


/******************************Public*Routine******************************\
*
* vXformTestItalicize
*
* Effects:
*
* Warnings:
*
* History:
*  15-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#define SIN32 ((FLOAT)0.5299192642332)
#define COS32 ((FLOAT)0.8480480961564)

VOID vXformTestItalicize(HDC hdc, HFONT hfont)
{
    int     x,y;
    PSZ psz = "Test string";
    XFORM   xform;
    POINTL  ptl;

    xform.eDx  = (FLOAT)0;
    xform.eDy  = (FLOAT)0;

// clear the screen

    vClearScreen(hdc);

// Set text alignment

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

    x = 300;
    y = 100;

    bTextOut(hdc, hfont, x, y, psz);
    y += 100;

// now modify wtod transform and then try to display the text

    xform.eM11 = (FLOAT)1;
    xform.eM12 = (FLOAT)0;
    xform.eM21 = (FLOAT)-0.5;
    xform.eM22 = (FLOAT)1;

    ADVOBJ adv(hdc);

    if (!ModifyWorldTransform(hdc,&xform, MWT_RIGHTMULTIPLY))
        DbgPrint("ft:modify wt failed 3\n");

    bTextOut(hdc, hfont, x + y/2, y, psz);

// now rotate the italicized text by 32 degrees

    xform.eM11 = COS32;
    xform.eM12 = SIN32;
    xform.eM21 = -SIN32;
    xform.eM22 = COS32;

    y += 100;
    ptl.x = x; ptl.y = y;

    vXformTextOut
    (
    hdc,
    1,
    hfont,
    &ptl,
    psz,
    &xform
    );

// reset the transform back to IDENTITY

    // ModifyWorldTransform(hdc,&xform, MWT_IDENTITY);
}




/******************************Public*Routine******************************\
*
* vXformTextOut
*
* Effects:
*
* Warnings:
*
* History:
*  10-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID  vXformTextOut
(
HDC      hdc,
int      i,
HFONT    hfont,
POINTL  *pptl,
PSZ      psz,
XFORM   *pxform
)
{
// here we want to ensure that screen coords of the
// string are always the same

    int    j;
    POINTL ptl, ptlTmp;

    ptl = *pptl;

    for (j=0; j<i;j++)
    {
        ptlTmp.x = (LONG)(pxform->eM11 * ptl.x + pxform->eM12 * ptl.y);
        ptlTmp.y = (LONG)(pxform->eM21 * ptl.x + pxform->eM22 * ptl.y);

        ptl = ptlTmp;
    }

    if (GetGraphicsMode(hdc) != GM_ADVANCED)
    {
        DbgPrint("ft:vXformTextOut, hdc not in the advanced graphics mode \n");
        return;
    }

    if (!ModifyWorldTransform(hdc,pxform, MWT_RIGHTMULTIPLY))
        DbgPrint("ft:modify wt failed 4\n");

    bTextOut(hdc, hfont, (int) ptlTmp.x, (int) ptlTmp.y, psz);
    vDoPause(1);
}


/******************************Public*Routine******************************\
*
* vXformTextOut90
*
* Effects:
*
* Warnings:
*
* History:
*  10-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID vXformText90(HDC hdc, HFONT hfont)
{
    PSZ psz = "Test string";
    XFORM   xform;
    POINTL  ptl;
    int     i;

    xform.eDx  = (FLOAT)0;
    xform.eDy  = (FLOAT)0;

// clear the screen

    vClearScreen(hdc);

// Set text alignment

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

// init on the center of the screen

    ptl.x = 320;
    ptl.y = 240;

// rotate 4 times by 90 degrees:

    xform.eM11 = (FLOAT)0;
    xform.eM12 = (FLOAT)1;
    xform.eM21 = (FLOAT)-1;
    xform.eM22 = (FLOAT)0;

    ADVOBJ adv(hdc);

    for (i = 1; i <= 4; i++)
        vXformTextOut(hdc, i, hfont, &ptl, psz, &xform);
}



/******************************Public*Routine******************************\
*
* vXformText45
*
* Effects:
*
* Warnings:
*
* History:
*  10-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID vXformText45(HDC hdc, HFONT hfont)
{
    PSZ psz = "Test string";
    XFORM   xform;
    POINTL  ptl;
    int     i;

    xform.eDx  = (FLOAT)0;
    xform.eDy  = (FLOAT)0;

// clear the screen

    vClearScreen(hdc);

// Set text alignment

    SetTextAlign(hdc, TA_LEFT | TA_TOP | TA_NOUPDATECP);

// init on the center of the screen

    ptl.x = 320;
    ptl.y = 240;

// do some 45 degree rotations:

    xform.eM11 = (FLOAT)ONEOVERSQRT2;
    xform.eM12 = (FLOAT)ONEOVERSQRT2;
    xform.eM21 = (FLOAT)-ONEOVERSQRT2;
    xform.eM22 = (FLOAT)ONEOVERSQRT2;

    ADVOBJ adv(hdc);

    for (i = 1; i <= 8; i++)
        vXformTextOut(hdc, i, hfont, &ptl, psz, &xform);

   // ModifyWorldTransform(hdc,&xform,MWT_IDENTITY);
}





VOID vDoAllTests
(
HDC hdc,
HFONT hfont,
HFONT hfontUnderline,
HFONT hfontStrikeOut
)
{
// flip y

    vXformTextFlipY(hdc, hfont);
    vDoPause(0);
    vXformTextFlipY(hdc, hfontUnderline);
    vDoPause(0);
    vXformTextFlipY(hdc, hfontStrikeOut);

// multiples of 90 degrees

    vDoPause(0);
    vXformText90(hdc, hfont);
    vDoPause(0);
    vXformText90(hdc, hfontUnderline);
    vDoPause(0);
    vXformText90(hdc, hfontStrikeOut);

// multiples of 45 degrees

    vDoPause(0);
    vXformText45(hdc, hfont);
    vDoPause(0);
    vXformText45(hdc, hfontUnderline);
    vDoPause(0);
    vXformText45(hdc, hfontStrikeOut);
    vDoPause(0);

// some more random xforms:

    vXformTestItalicize(hdc, hfont);
    vDoPause(0);
    vXformTestItalicize(hdc, hfontUnderline);
    vDoPause(0);
    vXformTestItalicize(hdc, hfontStrikeOut);
    vDoPause(0);

}


/******************************Public*Routine******************************\
*
* vXformTextLogfont
*
* Effects:
*
* Warnings:
*
* History:
*  15-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vXformTextLogfont(HDC hdc, LOGFONT *plfnt)
{
    HFONT   hfont, hfontUnderline,hfontStrikeOut;              // handle of font originally in DC

    if ((hfont = CreateFontIndirect(plfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

    plfnt->lfUnderline  = 1; // underline

    if ((hfontUnderline = CreateFontIndirect(plfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

    plfnt->lfUnderline  = 0; // underline
    plfnt->lfStrikeOut  = 1; // no underline

    if ((hfontStrikeOut = CreateFontIndirect(plfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

// make sure that the bkground rectangle is drawn properly

    SetBkColor(hdc, RGB(255,0,0));
    SetBkMode (hdc, TRANSPARENT);

    vDoAllTests (hdc, hfont, hfontUnderline, hfontStrikeOut);

    SetBkMode (hdc, OPAQUE);

    vDoAllTests (hdc, hfont, hfontUnderline, hfontStrikeOut);


    DeleteObject(hfont);
    DeleteObject(hfontUnderline);
    DeleteObject(hfontStrikeOut);
}






/******************************Public*Routine******************************\
*
* vXformText, main routine here
*
* Effects:
*
* Warnings:
*
* History:
*  10-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vXformText(HDC hdc)
{
    LOGFONT lfnt;

// Create a logical font

#ifndef DOS_PLATFORM
    memset(&lfnt, 0, sizeof(lfnt));
#else
    memzero(&lfnt, sizeof(lfnt));
#endif  //DOS_PLATFORM

    lfnt.lfHeight     = 24;
    lfnt.lfEscapement = 0;
    lfnt.lfUnderline  = 0; // no underline
    lfnt.lfStrikeOut  = 0; // no strike out
    lfnt.lfItalic     = 0;
    lfnt.lfWeight     = 400; // normal

    strcpy((char *)lfnt.lfFaceName, "Lucida Blackletter");

    vXformTextLogfont(hdc, &lfnt);

    lfnt.lfHeight     = 64;
    lfnt.lfEscapement = 0;
    lfnt.lfUnderline  = 0; // no underline
    lfnt.lfStrikeOut  = 0; // no strike out
    lfnt.lfItalic     = 0;
    lfnt.lfWeight     = 400; // normal

    strcpy((char *)lfnt.lfFaceName, "Lucida Fax");

    vXformTextLogfont(hdc, &lfnt);

}




/******************************Public*Routine******************************\
*
* vSimpleTextInPath
*
* Effects:
*
* Warnings:
*
* History:
*  11-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID vSimpleTextInPath(HDC hdc, HFONT hfont)
{
    PSZ psz = "Text in the path";

    vClearScreen(hdc);

    BeginPath(hdc);

    bTextOut(hdc, hfont, 10, 5, psz);
    bTextOut(hdc, hfont, 10, 105, "Another string");

    EndPath(hdc);

    StrokePath(hdc);


    psz = "Blt thru a clip path";

    BeginPath(hdc);

    bTextOut(hdc, hfont, 10, 205, psz);

    EndPath(hdc);

    SelectClipPath(hdc, RGN_COPY);

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, BLACKNESS);

    SelectClipRgn(hdc,0);

// same thing in transparent mode

    SetBkMode (hdc,TRANSPARENT);

    BeginPath(hdc);

    bTextOut(hdc, hfont, 10, 350, psz);

    EndPath(hdc);

    SelectClipPath(hdc, RGN_COPY);

    BitBlt(hdc, 0, 0, MAX_CX, MAX_CY, (HDC) 0, 0, 0, BLACKNESS);

    SelectClipRgn(hdc,0);

    SetBkMode (hdc,OPAQUE);

    vDoPause(0);

}


/******************************Public*Routine******************************\
*
* vTextInPath
*
* Effects:
*
* Warnings:
*
* History:
*  11-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




VOID vTextInPath(HDC hdc)
{
    LOGFONT lfnt;
    HFONT   hfont, hfontBitmap, hfontVector;
    HFONT   hfontUnderline,hfontStrikeOut;              // handle of font originally in DC
    HPEN    hpen, hpen1, hpenOld;
    LOGBRUSH lbr;

    if (GetGraphicsMode(hdc) != GM_COMPATIBLE)
    {
        DbgPrint("ft:hdc not in the compatible mode \n");
        return;
    }

    lbr.lbStyle = BS_SOLID;
    lbr.lbColor = RGB(255,0,0);
    lbr.lbHatch = 0; // ignored


    hpen1 = ExtCreatePen(
               PS_COSMETIC | PS_SOLID,
               1,              // width
               &lbr,
               0,
               (LPDWORD)NULL
               );

// create thick pen to ensure  that endpoints are not seen
// when curve is properly closed

    hpen = ExtCreatePen(
               PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_FLAT,
               3,              // width
               &lbr,
               0,
               (LPDWORD)NULL
               );

// Create a logical font

#ifndef DOS_PLATFORM
    memset(&lfnt, 0, sizeof(lfnt));
#else
    memzero(&lfnt, sizeof(lfnt));
#endif  //DOS_PLATFORM

    lfnt.lfHeight     = -80;
    lfnt.lfEscapement = 0;
    lfnt.lfUnderline  = 0; // no underline
    lfnt.lfStrikeOut  = 0; // no strike out
    lfnt.lfItalic     = 0;
    lfnt.lfWeight     = 400; // normal

    strcpy((char *)lfnt.lfFaceName, "Lucida Blackletter");

    if ((hfont = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

    lfnt.lfUnderline  = 1; // underline

    if ((hfontUnderline = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

    lfnt.lfUnderline  = 0;
    lfnt.lfStrikeOut  = 1;

    if ((hfontStrikeOut = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

// make sure that the text path code does not blow up if we attempt
// to put a bitmap font text in the path

    lfnt.lfHeight     = -40;
    lfnt.lfEscapement = 0;
    lfnt.lfUnderline  = 0; // no underline
    lfnt.lfStrikeOut  = 0; // no strike out
    lfnt.lfItalic     = 0;
    lfnt.lfWeight     = 400; // normal

    strcpy((char *)lfnt.lfFaceName, "Ms Sans Serif");

    if ((hfontBitmap = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }

    lfnt.lfHeight     = -70;
    strcpy((char *)lfnt.lfFaceName, "Script");

    if ((hfontVector = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
    {
        DbgPrint("ft:Logical font creation failed.\n");
        return;
    }


    hpenOld = (HPEN)SelectObject(hdc, hpen1);

// make sure we do not blow up on bitmap and vector fonts:

    vSimpleTextInPath(hdc, hfontBitmap);
    vSimpleTextInPath(hdc, hfontVector);

    vSimpleTextInPath(hdc, hfont);
    vSimpleTextInPath(hdc, hfontUnderline);
    vSimpleTextInPath(hdc, hfontStrikeOut);

    SelectObject(hdc, hpen);

    vSimpleTextInPath(hdc, hfont);
    vSimpleTextInPath(hdc, hfontUnderline);
    vSimpleTextInPath(hdc, hfontStrikeOut);

    SelectObject(hdc, hpenOld);

    DeleteObject(hpen);
    DeleteObject(hpen1);

    DeleteObject(hfontBitmap);
    DeleteObject(hfontVector);

    DeleteObject(hfont);
    DeleteObject(hfontUnderline);
    DeleteObject(hfontStrikeOut);
}



/******************************Public*Routine******************************\
*
* vEscText   (HDC hdc)
*
*
* Effects:
*
* Warnings:
*
* History:
*  17-Apr-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vEscText   (HDC hdc)
{
    LOGFONT lfnt;
    HFONT   hfont;
    LONG    lEsc;

    memset(&lfnt, 0, sizeof(lfnt));
    lfnt.lfHeight     = 48;
    lfnt.lfUnderline  = 1; // underline
    lfnt.lfStrikeOut  = 1; // strike out
    lfnt.lfItalic     = 0;
    lfnt.lfWeight     = 400; // normal
    strcpy((char *)lfnt.lfFaceName, "Times New Roman");

    vClearScreen(hdc);
    SetBkMode(hdc,TRANSPARENT);

    if (GetGraphicsMode(hdc) != GM_COMPATIBLE)
    {
    // make sure we are in compatible mode at the beginning of this
    // test. this is ensured by hitting the destructor here

        ADVOBJ advTmp(hdc);
    }

    for (lEsc = 0; lEsc < 3600; lEsc += 300)
    {
        lfnt.lfOrientation = lfnt.lfEscapement = lEsc;

        if ((hfont = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
        {
            DbgPrint("ft:Logical font creation failed.\n");
            return;
        }

        bTextOut(hdc, hfont, 320, 240, "Esc equal to Orient");
        vDoPause(1);
        DeleteObject(hfont);
    }

    vDoPause(0);

    vClearScreen(hdc);

// test the most general case, esc != orientation

    lfnt.lfHeight     = 24;
    lfnt.lfWeight     = 700; // bold
    lfnt.lfStrikeOut  = 0;
    lfnt.lfUnderline  = 0;
    strcpy((char *)lfnt.lfFaceName, "Courier New");

    lfnt.lfOrientation = 470; // randomly chosen angle

    {
        ADVOBJ advTmp1(hdc);
        for (lEsc = 0; lEsc < 3600; lEsc += 300)
        {
            lfnt.lfEscapement = lEsc;

            if ((hfont = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
            {
                DbgPrint("ft:Logical font creation failed.\n");
                return;
            }

            bTextOut(hdc, hfont, 320, 240, "Esc diff. from Orientation");
            vDoPause(1);
            DeleteObject(hfont);
        }
    }
    vDoPause(0);

    {
        POINTL  ptl;

        SetBkMode(hdc,OPAQUE);
        SetBkColor(hdc, RGB(255,0,0));

        vClearScreen(hdc);

    // test the most general case, esc != orientation + modify world xform

        lfnt.lfHeight     = 30;
        lfnt.lfWeight     = 700; // bold
        lfnt.lfStrikeOut  = 0;
        strcpy((char *)lfnt.lfFaceName, "Courier New");

        lfnt.lfOrientation = 650; // randomly chosen angle
        lfnt.lfEscapement = 1200; // randomly chosen angle

        if ((hfont = CreateFontIndirect(&lfnt)) == (HFONT)NULL)
        {
            DbgPrint("ft:Logical font creation failed.\n");
            return;
        }

        bTextOut(hdc, hfont, 220, 240, "Esc diff. from Orientation");

        XFORM   xform;

        xform.eDx  = (FLOAT)0;
        xform.eDy  = (FLOAT)0;

    // now modify wtod transform and then try to display the text

        xform.eM11 = (FLOAT)1;
        xform.eM12 = (FLOAT)0;
        xform.eM21 = (FLOAT)-0.5;
        xform.eM22 = (FLOAT)1;

        ADVOBJ adv(hdc);

        if (!ModifyWorldTransform(hdc,&xform, MWT_RIGHTMULTIPLY))
            DbgPrint("ft:modify wt failed 5\n");

    // now rotate the italicized text by 32 degrees

        xform.eM11 = COS32;
        xform.eM12 = -SIN32;
        xform.eM21 = SIN32;
        xform.eM22 = COS32;

        ptl.x = 320; ptl.y = 400;

        vXformTextOut
        (
        hdc,
        1,
        hfont,
        &ptl,
        "Esc diff. from Orientation",
        &xform
        );

    // reset the transform back to IDENTITY

        // ModifyWorldTransform(hdc,&xform, MWT_IDENTITY);
        DeleteObject(hfont);
    }


    vDoPause(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ft_tt.c ===
/******************************Module*Header*******************************\
* Module Name: ft_tt.c
*
* TrueType specific API tests.
*
* Created: 26-Feb-1992 18:50:06
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop


static ULONG   CX, CY;
static CHAR    szOutText[256];

static BYTE giColor = 0;
static ULONG    grgbColor[16] = {
                                 0x00FF7f7f,
                                 0x0000FF00,
                                 0x007F7FFF,
                                 0x00FFFF00,
                                 0x0000FFFF,
                                 0x00FF00FF,
                                 0x00FF7F7F,
                                 0x00FFFFFF
                                };

extern LPSTR pszPitchIs (BYTE);
extern LPSTR pszFamilyIs (BYTE);
extern LPSTR pszCharSet (BYTE);


BOOL bTestGRC(HDC);
BOOL bTestCSFR(HDC);
BOOL bTestLoadFOT(HDC);
BOOL bTestGOTM(HDC);
BOOL bTestGFD(HDC);
VOID vTestGGO(HDC);
BOOL bTestGGO(HDC, LPMAT2);
VOID vPrintTM(HDC, PTEXTMETRIC);
VOID vPrintOTM(HDC, POUTLINETEXTMETRIC);


/******************************Public*Routine******************************\
* vTestTrueType
*
* History:
*  08-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vTestTrueType(HWND hwnd, HDC hdc, RECT* prcl)
{
    ULONG iBkOld;

    UNREFERENCED_PARAMETER(hwnd);

// Let's also save the display dimensions while we're at it!
// The BitBlt's used to clear the screen will access these.

    CX = prcl->right - prcl->left;
    CY = prcl->bottom - prcl->top;

// Set background modes.

    iBkOld = SetBkMode(hdc, TRANSPARENT);

// Perform tests.

    DbgPrint("----- Test GetRasterizerCaps ---------\n");
    SetTextColor(hdc, grgbColor[1]);
    bTestGRC(hdc);
    DbgPrint("----- End test GetRasterizerCaps -----\n");
    DbgBreakPoint();

    DbgPrint("----- Test CreateScalableFontResource ---------\n");
    SetTextColor(hdc, grgbColor[2]);
    bTestCSFR(hdc);
    DbgPrint("----- End test CreateScalableFontResource -----\n");
    DbgBreakPoint();

    DbgPrint("----- Test created FOT file -----\n");
    SetTextColor(hdc, grgbColor[3]);
    bTestLoadFOT(hdc);
    DbgPrint("----- End test FOT file ---------\n");
    DbgBreakPoint();

    DbgPrint("----- Test GetOutlineTextMetrics ---------\n");
    SetTextColor(hdc, grgbColor[4]);
    bTestGOTM(hdc);
    DbgPrint("----- End test GetOutlineTextMetrics -----\n");
    DbgBreakPoint();

    DbgPrint("----- Test GetFontData ---------\n");
    SetTextColor(hdc, grgbColor[5]);
    bTestGFD(hdc);
    DbgPrint("----- End test GetFontData -----\n");
    DbgBreakPoint();

    DbgPrint("----- Test GetGlyphOutline ---------\n");
    SetTextColor(hdc, grgbColor[6]);
    vTestGGO(hdc);
    DbgPrint("----- End test GetGlyphOutline -----\n");
    DbgBreakPoint();

// Restore background modes.

    iBkOld = SetBkMode(hdc, iBkOld);

}


/******************************Public*Routine******************************\
* bTestGRC
*
* Test the rasterizer (TrueType driver) status.
*
* History:
*  27-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bTestGRC (
    HDC         hdc
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    TEXTMETRIC  tm;
    PSZ     pszPitch, pszFamily;
    RASTERIZER_STATUS   rstat;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Courier New");
    lfnt.lfHeight = 21;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("bTestGRC: Logical font creation failed.\n");
        return FALSE;
    }

    hfontOriginal = SelectObject(hdc, hfont);

// Get text metrics

    if (!GetTextMetrics (hdc, &tm))
    {
        DbgPrint("bTestGRC: GetTextMetrics failed.\n");
    }

// Call GetRasterizerCaps.

    if ( !GetRasterizerCaps(&rstat, sizeof(RASTERIZER_STATUS)) )
    {
        DbgPrint("bTestGRC: GetRasterizerCaps failed.\n");
        return FALSE;
    }

// Print those mothers!

    sprintf(szOutText, "RASTERIZER STATUS");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "nSize = %ld (0x%lx)", rstat.nSize, rstat.nSize);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "wFlags = %s%s", (rstat.wFlags & TT_ENABLED)? "enabled ":"", (rstat.wFlags & TT_AVAILABLE)? "available":"");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

    sprintf(szOutText, "nLanguageID = %ld (0x%lx)", rstat.nLanguageID, rstat.nLanguageID);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += tm.tmHeight+tm.tmExternalLeading;

// Avoid any weirdness (incomplete text output) in case a break point
// is inserted after this call.

    GdiFlush();

// Restore the font.

    SelectObject(hdc, hfontOriginal);
    DeleteObject(hfont);

    return TRUE;
}


/******************************Public*Routine******************************\
* bTestCSFR
*
* Test the CreateScalableFontResource call.
*
* History:
*  27-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bTestCSFR (
    HDC         hdc
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    TEXTMETRIC  tm;
    PSZ     pszPitch, pszFamily;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Call the evil function.

    if ( !CreateScalableFontResource(0, "c:\\nt\\windows\\fonts\\lcallig.fot", "lcallig.ttf", "c:\\nt\\windows\\fonts") )
    {
        DbgPrint("ft!bTestCSFR(): CreateScalableFontResource call failed\n");
        DbgPrint("                (which is OK if it already exists...)\n");
        return FALSE;
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* bTestLoadFOT
*
* Two things are tested:
*
*   1.  The ability of the TrueType driver to laod a .FOT file created by
*       CreateScalableFontResource.
*
*   2.  Check to see if the gdisrv!gcTrueTypeFonts counter is updated
*       properly.
*
* History:
*  02-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bTestLoadFOT (
    HDC     hdc
    )
{
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    TEXTMETRIC  tm;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

    DbgPrint("ft!bTestLoadFOT(): check gcTrueTypeFonts\n");
    DbgBreakPoint();

// Add a TrueType .FOT font file.

    if ( !AddFontResource("lcallig.fot") )
    {
        DbgPrint("ft!bTestLoadFOT(): failed to load .FOT file\n");
        return FALSE;
    }
    GdiFlush();
    DbgPrint("ft!bTestLoadFOT(): check gcTrueTypeFonts (it should be 1 bigger)\n");
    DbgBreakPoint();

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Lucida Calligraphy");
    lfnt.lfHeight = -14;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("ft!bTestLoadFOT(): Logical font creation failed.\n");
        return FALSE;
    }

    hfontOriginal = SelectObject(hdc, hfont);

// Get metrics.

    if ( GetTextMetrics(hdc, &tm) )
        vPrintTM(hdc, &tm);
    else
        DbgPrint("ft!bTestLoadFOT(): GetTextMetrics call failed\n");

// Restore the font.

    SelectObject(hdc, hfontOriginal);
    DeleteObject(hfont);

// Remove the TrueType .FOT font file.

    if ( !RemoveFontResource("lcallig.fot") )
    {
        DbgPrint("ft!bTestLoadFOT(): error removing .FOT file\n");
        return FALSE;
    }
    GdiFlush();
    DbgPrint("ft!bTestLoadFOT(): check gcTrueTypeFonts (it should be 1 smaller)\n");
    DbgBreakPoint();

    return TRUE;
}


/******************************Public*Routine******************************\
* bTestGOTM
*
* Test the GetOutlineTextMetric call.  Force a load/unload of a .FOT file
* while we're at it.
*
* History:
*  28-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bTestGOTM (
    HDC     hdc
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    POUTLINETEXTMETRIC  potm;
    ULONG   cjotm;
    PSZ     pszPitch, pszFamily;


// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Arial");
    lfnt.lfHeight = -14;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("ft!bTestGOTM(): Logical font creation failed.\n");
        return FALSE;
    }

    hfontOriginal = SelectObject(hdc, hfont);

// Determine size needed for OTM.

    if ( (cjotm = (ULONG) GetOutlineTextMetrics(hdc, 0, (POUTLINETEXTMETRIC) NULL)) == (ULONG) 0 )
    {
        DbgPrint("ft!bTestGOTM(): could not get size info from GetOutlineTextMetrics\n");
        return FALSE;
    }

// Allocate memory.

    if ( (potm = (POUTLINETEXTMETRIC) LocalAlloc(LPTR, cjotm)) == (POUTLINETEXTMETRIC) NULL )
    {
        DbgPrint("ft!bTestGOTM(): LocalAlloc(LPTR, 0x%lx) failed\n", cjotm);
        return FALSE;
    }

// Get the OTM.

    if ( GetOutlineTextMetrics(hdc, cjotm, potm) == (DWORD) 0 )
    {
        LocalFree(potm);

        DbgPrint("ft!bTestGOTM(): GetOutlineTextMetrics call failed\n");
        return FALSE;
    }

// Print TEXTMETRIC.

    vPrintTM(hdc, &potm->otmTextMetrics);
    DbgBreakPoint();

// Print TEXTMETRIC.

    vPrintOTM(hdc, potm);
    DbgBreakPoint();

// Restore the font.

    SelectObject(hdc, hfontOriginal);
    DeleteObject(hfont);

    LocalFree(potm);

    return TRUE;
}


/******************************Public*Routine******************************\
* vPrintTM
*
* Print to the given DC, the contents of a TEXTMETRIC structure.
*
*
*
*
* History:
*  28-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintTM (
    HDC         hdc,
    PTEXTMETRIC ptm
    )
{
    ULONG   row = 0;
    ULONG   rowIncr = ptm->tmHeight + ptm->tmExternalLeading;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Print TEXTMETRIC fields.

    sprintf(szOutText, "OUTLINETEXTMETRIC, otmTextMetrics substructure:");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmHeight: %ld", ptm->tmHeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmAscent: %ld", ptm->tmAscent);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmDescent: %ld", ptm->tmDescent);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmInternalLeading: %ld", ptm->tmInternalLeading);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmExternalLeading: %ld", ptm->tmExternalLeading);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmAveCharWidth: %ld", ptm->tmAveCharWidth);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmMaxCharWidth: %ld", ptm->tmMaxCharWidth);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmWeight: %ld", ptm->tmWeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmOverhang: %ld", ptm->tmOverhang);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmDigitizedAspectX: %ld", ptm->tmDigitizedAspectX);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmDigitizedAspectY: %ld", ptm->tmDigitizedAspectY);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmFirstChar: %d (%c)", ptm->tmFirstChar, ptm->tmFirstChar);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmLastChar: %d (%c)", ptm->tmLastChar, ptm->tmLastChar);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmDefaultChar: %d (%c)", ptm->tmDefaultChar, ptm->tmDefaultChar);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmBreakChar: %d (%c)", ptm->tmBreakChar, ptm->tmBreakChar);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmItalic: %s", (ptm->tmItalic)?"TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmUnderlined: %s", (ptm->tmUnderlined)?"TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmStruckOut: %s", (ptm->tmStruckOut)?"TRUE":"FALSE");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmPitchAndFamily: %s%s", pszFamilyIs(ptm->tmPitchAndFamily), (ptm->tmPitchAndFamily & 0x01)?", Variable Pitch":", Fixed Pitch");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "tmCharSet: %s", pszCharSet(ptm->tmCharSet));
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

// Flush out batched calls.

    GdiFlush();

}


/******************************Public*Routine******************************\
* vPrintOTM
*
* Print to the given DC, the contents of an OUTLINETEXTMETRIC structure,
* excluding the otmTextMetrics field.
*
* History:
*  28-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vPrintOTM (
    HDC                 hdc,
    POUTLINETEXTMETRIC  potm
    )
{
    ULONG   row = 0;
    ULONG   rowIncr = potm->otmTextMetrics.tmHeight + potm->otmTextMetrics.tmExternalLeading;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Print OUTLINETEXTMETRIC fields.

    sprintf(szOutText, "OUTLINETEXTMETRIC:");
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmSize: %ld", potm->otmSize);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmpFamilyName: %s", potm->otmpFamilyName);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmpFaceName: %s", potm->otmpFaceName);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmpStyleName: %s", potm->otmpStyleName);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmpFullName: %ld", potm->otmpFullName);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmFiller: %ld", potm->otmFiller);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmPanoseNumber: %ld", potm->otmPanoseNumber);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmfsSelection: %ld", potm->otmfsSelection);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmfsType: %ld", potm->otmfsType);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmsCharSlopeRise: %ld", potm->otmsCharSlopeRise);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmsCharSlopeRun: %ld", potm->otmsCharSlopeRun);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmItalicAngle: %ld", potm->otmItalicAngle);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmEMSquare: %ld", potm->otmEMSquare);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmAscent: %ld", potm->otmAscent);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmDescent: %ld", potm->otmDescent);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmLineGap: %ld", potm->otmLineGap);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmXHeight: %ld", potm->otmXHeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmCapEmHeight: %ld", potm->otmCapEmHeight);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmrcFontBox: ( (%ld, %ld), (%ld, %ld) )", potm->otmrcFontBox.left, potm->otmrcFontBox.top, potm->otmrcFontBox.right, potm->otmrcFontBox.bottom);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmMacAscent: %ld", potm->otmMacAscent);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmMacDescent: %ld", potm->otmMacDescent);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmMacLineGap: %ld", potm->otmMacLineGap);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmusMinimumPPEM: %ld", potm->otmusMinimumPPEM);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmptSubscriptSize: (%ld, %ld)", potm->otmptSubscriptSize.x, potm->otmptSubscriptSize.y);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmptSubscriptOffset: (%ld, %ld)", potm->otmptSubscriptOffset.x, potm->otmptSubscriptOffset.y);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmptSuperscriptSize: (%ld, %ld)", potm->otmptSuperscriptSize.x, potm->otmptSuperscriptSize.y);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmptSuperscriptOffset: (%ld, %ld)", potm->otmptSuperscriptOffset.x, potm->otmptSuperscriptOffset.y);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmsStrikeoutSize: %ld", potm->otmsStrikeoutSize);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmsStrikeoutPosition: %ld", potm->otmsStrikeoutPosition);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmsUnderscorePosition: %ld", potm->otmsUnderscorePosition);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "otmsUnderscoreSize: %ld", potm->otmsUnderscoreSize);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

// Flush out batched calls.

    GdiFlush();

}


/******************************Public*Routine******************************\
* bTestGFD
*
* Test the GetFontData call.
*
* History:
*  28-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bTestGFD (
    HDC     hdc
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;

    ULONG   cjBuffer;
    PBYTE   pjBuffer;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Lucida Blackletter");
    lfnt.lfHeight = 40;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("ft!bTestGFD(): Logical font creation failed.\n");
        return FALSE;
    }

    hfontOriginal = SelectObject(hdc, hfont);

// Determine buffer size needed by GetFontData.

                                               // 'OS/2'
    if ( (cjBuffer = (ULONG) GetFontData(hdc, 0x4f532f32, 0, (PVOID) NULL, 0)) == (ULONG) -1 )
    {
        DbgPrint("ft!bTestGFD(): could not get buffer size from API\n");
        return FALSE;
    }

// Allocate memory.

    if ( (pjBuffer = (PBYTE) LocalAlloc(LPTR, cjBuffer)) == (PBYTE) NULL )
    {
        DbgPrint("ft!bTestGFD(): LocalAlloc(LPTR, 0x%lx) failed\n", cjBuffer);
        return FALSE;
    }

// Get the OS/2 table from TrueType.

    if ( GetFontData(hdc, 0x4f532f32, 0, (PVOID) pjBuffer, cjBuffer) == (DWORD) -1 )
    {
        LocalFree(pjBuffer);

        DbgPrint("ft!bTestGFD(): call to GetFontData failed\n");
        return FALSE;
    }

// Flush out batched calls.

    GdiFlush();

// Allow an opportunity to examine the contents.

    DbgPrint("ft!bTestGFD(): call to GetFontData succeeded\n");
    DbgPrint("\tOS/2 TrueType table is at 0x%lx, size is 0x%lx (%ld)\n", pjBuffer, cjBuffer, cjBuffer);
    DbgBreakPoint();

// Restore the font.

    SelectObject(hdc, hfontOriginal);
    DeleteObject(hfont);

// Free allocated memory.

    LocalFree(pjBuffer);

    return TRUE;
}


/******************************Public*Routine******************************\
* vTestGGO
*
* Test the GetGlyphOutline call, hitting it with different transforms.  This
* is really a wrapper for bTestGGO.
*
* History:
*  28-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vTestGGO (
    HDC     hdc
    )
{
    MAT2    mat2;

// Fill in MAT2 structure.  Identity matrix.

    mat2.eM11.value = 1;
    mat2.eM11.fract = 0;

    mat2.eM12.value = 0;
    mat2.eM12.fract = 0;

    mat2.eM21.value = 0;
    mat2.eM21.fract = 0;

    mat2.eM22.value = 1;
    mat2.eM22.fract = 0;

    DbgPrint("ft!vTestGGO(): use identity matrix\n");
    if ( !bTestGGO(hdc, &mat2) )
        DbgPrint("ft!vTestGGO(): call to bTestGGO failed\n");
    DbgBreakPoint();

// Fill in MAT2 structure.  Scale by 5.

    mat2.eM11.value = 5;
    mat2.eM11.fract = 0;

    mat2.eM12.value = 0;
    mat2.eM12.fract = 0;

    mat2.eM21.value = 0;
    mat2.eM21.fract = 0;

    mat2.eM22.value = 5;
    mat2.eM22.fract = 0;

    DbgPrint("ft!vTestGGO(): Scale by 5\n");
    if ( !bTestGGO(hdc, &mat2) )
        DbgPrint("ft!vTestGGO(): call to bTestGGO failed\n");
    DbgBreakPoint();

// Fill in MAT2 structure.  Rotate 45 deg CCW, scale by sqrt(2).

    mat2.eM11.value = 1;
    mat2.eM11.fract = 0;

    mat2.eM12.value = 1;
    mat2.eM12.fract = 0;

    mat2.eM21.value = -1;
    mat2.eM21.fract = 0;

    mat2.eM22.value = 1;
    mat2.eM22.fract = 0;

    DbgPrint("ft!vTestGGO(): rotate 45 deg CCW and scale by sqrt(2)\n");
    if ( !bTestGGO(hdc, &mat2) )
        DbgPrint("ft!vTestGGO(): call to bTestGGO failed\n");
    DbgBreakPoint();

}


/******************************Public*Routine******************************\
* bTestGGO
*
* Test the GetGlyphOutline call.
*
* History:
*  28-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bTestGGO (
    HDC     hdc,
    LPMAT2  lpmat2
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    ULONG   rowIncr;
    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;
    TEXTMETRIC  tm;

    ULONG   cjBuffer;
    PBYTE   pjBuffer;

    GLYPHMETRICS    gm;

// Clear the screen to black.

    BitBlt(hdc, 0, 0, CX, CY, (HDC) 0, 0, 0, 0);

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Lucida Fax");
    lfnt.lfHeight = 24;
    lfnt.lfWeight = 400;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        DbgPrint("ft!bTestGGO(): Logical font creation failed.\n");
        return FALSE;
    }

    hfontOriginal = SelectObject(hdc, hfont);

// Get textmetrics.

    if ( !GetTextMetrics(hdc, &tm) )
    {
        DbgPrint("ft!bTestGGO(): GetTextMetrics failed\n");
        return FALSE;
    }

    rowIncr = tm.tmHeight + tm.tmExternalLeading;

// Determine buffer size needed by GetGlyphOutline.

    if ( (cjBuffer = (ULONG) GetGlyphOutline(hdc, 0x0054, GGO_BITMAP, &gm, 0, (PVOID) NULL, lpmat2)) == (ULONG) -1 )
    {
        DbgPrint("ft!bTestGGO(): could not get buffer size from API\n");
        return FALSE;
    }

// Allocate memory.

    DbgPrint("ft!bTestGGO(): allocating 0x%lx bytes for buffer\n", cjBuffer);
    if ( (pjBuffer = (PBYTE) LocalAlloc(LPTR, cjBuffer)) == (PBYTE) NULL )
    {
        DbgPrint("ft!bTestGGO(): LocalAlloc(LPTR, 0x%lx) failed\n", cjBuffer);
        return FALSE;
    }

// Get the bitmap.

    if ( GetGlyphOutline(hdc, 0x0054, GGO_BITMAP, &gm, cjBuffer, (PVOID) pjBuffer, lpmat2) == (DWORD) -1 )
    {
        LocalFree(pjBuffer);

        DbgPrint("ft!bTestGGO(): call to GetFontData failed\n");
        return FALSE;
    }

// Print out GLYPHMETRIC data.

    sprintf(szOutText, "gmBlackBoxX: %ld", gm.gmBlackBoxX);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmBlackBoxY: %ld", gm.gmBlackBoxY);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmptGlyphOrigin: (%ld, %ld)", gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmCellIncX: %ld", gm.gmCellIncX);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmCellIncY: %ld", gm.gmCellIncY);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

// Flush out batched calls.

    GdiFlush();

// Allow an opportunity to examine the contents.

    DbgPrint("ft!bTestGGO(): call to GetGlyphOutline succeeded\n");
    DbgPrint("\tbitmap is at 0x%lx, size is 0x%lx (%ld)\n", pjBuffer, cjBuffer, cjBuffer);
    DbgBreakPoint();

// Restore the font.

    SelectObject(hdc, hfontOriginal);
    DeleteObject(hfont);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\ft_ttout.c ===
/******************************Module*Header*******************************\
* Module Name: ftuni.c
*
* the tests for simple unicode extended functions
*
* Created: 06-Aug-1991 16:05:32
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.h"
#pragma hdrstop


#define C_CHAR   150
static  CHAR    szOutText[256];
#define RET_FALSE(x)  {DbgPrint((x)); return(FALSE);}
#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) if(!(x)) RIP(y)


// This is to create a bitmapinfo structure

VOID vTestGetGlyphOutline(HDC hdc);


VOID vTestGlyphOutline(HWND hwnd, HDC hdcScreen, RECT* prcl)
{
    SIZE ptl;

    HFONT   hfont;
    HFONT   hfontOriginal;
    LOGFONT lfnt;

// Get a font.

    memset(&lfnt, 0, sizeof(lfnt));
    lstrcpy(lfnt.lfFaceName, "Lucida Blackletter");
    lfnt.lfHeight = 24;
    lfnt.lfWeight = 400;
    lfnt.lfOutPrecision = OUT_TT_ONLY_PRECIS;

    if ((hfont = CreateFontIndirect(&lfnt)) == NULL)
    {
        // DbgPrint("ft!bTestGetGlyphOutline(): Logical font creation failed.\n");
        return;
    }

    hfontOriginal = SelectObject(hdcScreen, hfont);


    ModifyWorldTransform   (hdcScreen, NULL, MWT_IDENTITY);
    SetMapMode         (hdcScreen, MM_ANISOTROPIC);
    SetViewportExtEx        (hdcScreen, 2, 1, &ptl);

// do the experiment once in the compatible mode

    SetGraphicsMode(hdcScreen,GM_COMPATIBLE);
    vTestGetGlyphOutline(hdcScreen);

// do the experiment once in the advmode mode

    SetGraphicsMode(hdcScreen,GM_ADVANCED);
    vTestGetGlyphOutline(hdcScreen);

// restore the state

    SetViewportExtEx (hdcScreen, ptl.cx, ptl.cy,  NULL);
    SetMapMode  (hdcScreen, MM_TEXT);
    SetGraphicsMode (hdcScreen,GM_COMPATIBLE);

    SelectObject(hdcScreen, hfontOriginal);
    DeleteObject(hfont);

    prcl; hwnd;

}



/******************************Public*Routine******************************\
*
*    vQsplineToPolyBezier, stolen from ttfd
*
* Effects:
*
* Warnings:
*
* History:
*  20-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define   ONE_HALF_28_4       0x0000000
#define   THREE_HALVES_28_4   (ONE_HALF_28_4 * 3)

#define DIV_BY_2(x) (((x) + 1) / 2)
#define DIV_BY_3(x) (((x) + 1) / 3)


#ifdef LATER

VOID vQsplineToPolyBezier
(
ULONG      cBez,          //IN  count of curves to convert to beziers format
POINTFIX * pptfixStart,   //IN  starting point on the first curve
POINTFIX * pptfixSpline,  //IN  array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
POINTFIX * pptfixBez      //OUT buffer to be filled with 3 * cBez poly bezier control points
)
{
    ULONG    iBez,cMidBez;
    POINTFIX ptfixA;

// cMidBez == # of beziers for whom the last point on the bezier is computed
// as a mid point of the two consecutive points in the input array. Only the
// last bezier is not a mid bezier, the last point for that bezier is equal
// to the last point in the input array

    ASSERTGDI(cBez > 0, "TTFD!_cBez == 0\n");

    cMidBez = cBez - 1;
    ptfixA = *pptfixStart;

    for (iBez = 0; iBez < cMidBez; iBez++, pptfixSpline++)
    {
    // let us call the three spline points
    // A,B,C;
    // B = *pptfix;
    // C = (pptfix[0] + pptfix[1]) / 2; // mid point, unless at the end
    //
    // if we decide to call the two intermediate control points for the
    // bezier M,N (i.e. full set of control points for the bezier is
    // A,M,N,C), the points M,N are determined by following formulas:
    //
    // M = (2*B + A) / 3  ; two thirds along the segment AB
    // N = (2*B + C) / 3  ; two thirds along the segment CB
    //
    // this is the computation we are doing in this loop:

    // M point for this bezier

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // compute C point for this bezier, which is also the A point for the next
    // bezier

        if (iBez == (cBez - 1))
        {
        // this is the last bezier, its end point is the last point
        // in the input array

            ptfixA = pptfixSpline[1];
        }
        else // take midpoint
        {
            ptfixA.x = DIV_BY_2(pptfixSpline[0].x + pptfixSpline[1].x);
            ptfixA.y = DIV_BY_2(pptfixSpline[0].y + pptfixSpline[1].y);
        }

    // now compute N point for this bezier:

        pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
        pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
        pptfixBez++;

    // finally record the C point for this curve

        *pptfixBez++ = ptfixA;
    }

// finally do the last bezier. If the last bezier is the only one, the loop
// above has been skipped

// M point for this bezier

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// compute C point for this bezier, its end point is the last point
// in the input array

    ptfixA = pptfixSpline[1];

// now compute N point for this bezier:

    pptfixBez->x = DIV_BY_3((pptfixSpline->x * 2) + ptfixA.x);
    pptfixBez->y = DIV_BY_3((pptfixSpline->y * 2) + ptfixA.y);
    pptfixBez++;

// finally record the C point for this curve, no need to increment pptfixBez

    *pptfixBez = ptfixA;
}




#endif



// reasonable guess that in most cases a contour will not consist of more
// that this many beziers

#define C_BEZIER 6


/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  09-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define X_OFF  (340/2)
#define Y_OFF  240
#define SHIFT  16


VOID vShiftPoint(POINTL * pptl, PSZ psz)
{
    POINTL ptlTmp = *pptl;

    pptl->x >>= SHIFT;
    pptl->x +=  X_OFF;

    pptl->y = - pptl->y;
    pptl->y >>= SHIFT;
    pptl->y +=  Y_OFF;

/*
    DbgPrint(" %s : bef. (0x%lx, 0x%lx) aft. (0x%lx, 0x%lx) \n",
              psz,
              ptlTmp.x,
              ptlTmp.y,
              pptl->x,
              pptl->y
              );

*/

}

VOID vShiftCrv(TTPOLYCURVE *pcrv, ULONG * pcjCrv)
{
     INT i;

     *pcjCrv = offsetof(TTPOLYCURVE,apfx) + pcrv->cpfx * sizeof(POINTFX);

/*
     DbgPrint("New curve, type = 0x%x, cpt = %d, cjCrv = %ld\n",
               pcrv->wType, pcrv->cpfx, *pcjCrv);
*/

     for (i = 0; i < (INT)pcrv->cpfx; i++)
         vShiftPoint((POINTL *)&pcrv->apfx[i]," ");
}



VOID vShiftPoly(TTPOLYGONHEADER *ppoly, ULONG cjTotal)
{
    ULONG             cjCrv;
    TTPOLYCURVE     * pcrv;
    ULONG             cjPoly;

    // DbgPrint("New Polygon: dwType = %d, ppoly->cb = %d, cjTotal = %ld \n",
    //           ppoly->dwType, ppoly->cb, cjTotal);

    vShiftPoint((POINTL *)&ppoly->pfxStart, "pfxStart");

    for (
         cjPoly = sizeof(TTPOLYGONHEADER),pcrv = (TTPOLYCURVE *)(ppoly + 1);
         cjPoly < ppoly->cb;
         cjPoly += cjCrv
        )
    {
        vShiftCrv(pcrv, &cjCrv);

    // get to the next curve in this polygon

        pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + cjCrv);
    }

    // DbgPrint("cjPoly final = %ld, ppoly->cb = %d \n", cjPoly, ppoly->cb);
}



VOID vShiftOutline
(
TTPOLYGONHEADER * ppolyStart, // IN OUT pointer to the buffer with outline data
ULONG             cjTotal     // IN     size of the buffer
)
{
    ULONG             cjSoFar = 0;
    TTPOLYGONHEADER * ppoly;

    for (
         cjSoFar = 0, ppoly = ppolyStart;
         cjSoFar < cjTotal;
         cjSoFar += ppoly->cb, ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb)
        )
    {
        vShiftPoly(ppoly, cjTotal);
    }
}



#ifdef LATER


BOOL bDrawOutline
(
HDC               hdc,        // IN OUT pointer to the path object to be generated
TTPOLYGONHEADER * ppolyStart, // IN OUT pointer to the buffer with outline data
ULONG             cjTotal     // IN     size of the buffer
)
{
    ULONG             cjPoly, cjSoFar = 0;
    TTPOLYGONHEADER * ppoly;
    TTPOLYCURVE     * pcrv;
    POINTFIX          aptfixBez[3 * C_BEZIER];  // 3 points per bezier
    POINTFIX        * pptfixBez;
    ULONG             cBez;
    ULONG             cjCrv;
    POINTFIX        * pptfixStart;

    for (ppoly = ppolyStart; cjSoFar < cjTotal; )
    {
        // DbgPrint("Starting new polygon\n");

        ASSERTGDI(ppoly->dwType == TT_POLYGON_TYPE, "TTFD!_ TT_POLYGON_TYPE\n");

        MoveToEx(hdc, ((LPPOINT)&ppoly->pfxStart)->x, ((LPPOINT)&ppoly->pfxStart)->y, NULL);  // begin new closed contour

        pptfixStart = (POINTFIX *)&ppoly->pfxStart;

        for (cjPoly = sizeof(TTPOLYGONHEADER), pcrv = (TTPOLYCURVE *)(ppoly + 1);cjPoly < ppoly->cb;)
        {
            if (pcrv->wType == TT_PRIM_LINE)
            {
                if (!PolylineTo(hdc,(LPPOINT)pcrv->apfx, pcrv->cpfx))
                    RET_FALSE("TTFD!_bPolyLineTo()\n");
            }
            else // qspline
            {
                ASSERTGDI(pcrv->wType == TT_PRIM_QSPLINE, "TTFD!_TT_PRIM_QSPLINE\n");
                ASSERTGDI(pcrv->cpfx > 1, "TTFD!_TT_PRIM_QSPLINE, cpfx <= 1\n");
                cBez = pcrv->cpfx - 1;

                pptfixBez = aptfixBez;

                if (cBez <= C_BEZIER)
                {
                    vQsplineToPolyBezier (
                        cBez,                     // count of curves to convert to beziers format
                        pptfixStart,              // starting point on the first curve
                        (POINTFIX *)pcrv->apfx,   // array of (cBez+1) points that, together with the starting point *pptfixStart define the spline
                        pptfixBez);               // buffer to be filled with 3 * cBez poly bezier control points

                    if (!PolyBezierTo(hdc, (LPPOINT)pptfixBez, 3 * cBez))
                        RET_FALSE("TTFD!_bPolyBezierTo() failed\n");
                }
                else
                {
                    // DbgPrint("ft, to many beziers, cBez = %ld\n", cBez);
                }
            }

        // get to the next curve in this polygon

            pptfixStart = (POINTFIX *) &pcrv->apfx[pcrv->cpfx - 1];
            cjCrv = offsetof(TTPOLYCURVE,apfx) + pcrv->cpfx * sizeof(POINTFX);
            cjPoly += cjCrv;
            pcrv = (TTPOLYCURVE *)((PBYTE)pcrv + cjCrv);
        }

    // close contour

        LineTo(hdc, ((LPPOINT)&ppoly->pfxStart)->x, ((LPPOINT)&ppoly->pfxStart)->y);

    // get to the next polygon header

        cjSoFar += ppoly->cb;
        ppoly = (TTPOLYGONHEADER *)((PBYTE)ppoly + ppoly->cb);
    }

    return (TRUE);
}


#endif



/******************************Public*Routine******************************\
*
* Stolen from gilman and modified
*
* Effects:
*
* Warnings:
*
* History:
*  09-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bTestGetGlyphOutline (
    HDC     hdc,
    ULONG   uch,
    LPMAT2  lpmat2
    )
{
    ULONG   row = 0;                    // screen row coordinate to print at
    ULONG   rowIncr;
    TEXTMETRIC  tm;

    ULONG   cjBuffer;
    PBYTE   pjBuffer;

    GLYPHMETRICS    gm;

    uch = (ULONG)(BYTE)uch;

// Get textmetrics.

    if ( !GetTextMetrics(hdc, &tm) )
    {
        DbgPrint("ft!bTestGetGlyphOutline(): GetTextMetrics failed\n");
        return FALSE;
    }

    rowIncr = tm.tmHeight + tm.tmExternalLeading;

    sprintf(szOutText, "tmMaxCharWidth : %ld", tm.tmMaxCharWidth);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += (2 * rowIncr);

// Determine buffer size needed by GetGlyphOutline.

    if ( (cjBuffer = (ULONG) GetGlyphOutline(hdc, uch, GGO_NATIVE, &gm, 0, (PVOID) NULL, lpmat2)) == (ULONG) -1 )
    {
        DbgPrint("ft!bTestGetGlyphOutline(): could not get buffer size from API\n");
        return FALSE;
    }

// Allocate memory.

    if ( (pjBuffer = (PBYTE) LocalAlloc(LPTR, cjBuffer)) == (PBYTE) NULL )
    {
        DbgPrint("ft!bTestGetGlyphOutline(): LocalAlloc(LPTR, 0x%lx) failed\n", cjBuffer);
        return FALSE;
    }

// Get the bitmap.

    if ( GetGlyphOutline(hdc, uch, GGO_NATIVE, &gm, cjBuffer, (PVOID) pjBuffer, lpmat2) == (DWORD) -1 )
    {
        LocalFree(pjBuffer);

        return FALSE;
    }

// Print out GLYPHMETRIC data.

    sprintf(szOutText, "gmBlackBoxX: %ld", gm.gmBlackBoxX);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmBlackBoxY: %ld", gm.gmBlackBoxY);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmptGlyphOrigin: (%ld, %ld)", gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmCellIncX: %ld", gm.gmCellIncX);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

    sprintf(szOutText, "gmCellIncY: %ld", gm.gmCellIncY);
    TextOut(hdc, 0, row, szOutText, strlen(szOutText));
    row += rowIncr;

// draw outline

    // DbgPrint("ft! bDrawOutline begin \n");

// converting 16.16 to POINTL's

    vShiftOutline((TTPOLYGONHEADER *)pjBuffer, cjBuffer);

#ifdef LATER

    if (!bDrawOutline(hdc, (TTPOLYGONHEADER *)pjBuffer, cjBuffer))
        DbgPrint("bDrawOutline screwed up\n");

    // DbgPrint("ft! bDrawOutline end \n");

#endif

// Allow an opportunity to examine the contents.

    // DbgPrint("ft!bTestGetGlyphOutline(): call to GetGlyphOutline succeeded\n");
    // DbgPrint("\tbitmap is at 0x%lx, size is 0x%lx (%ld)\n", pjBuffer, cjBuffer, cjBuffer);
    // DbgBreakPoint();

    return TRUE;
}






/******************************Public*Routine******************************\
*
*
*
* Effects:
*
* Warnings:
*
* History:
*  09-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID vTestGetGlyphOutline(HDC hdc)
{
    MAT2    mat2;
    ULONG   ul = 'T';

// Fill in MAT2 structure.  Identity matrix.

    mat2.eM11.value = 3;
    mat2.eM11.fract = 0;

    mat2.eM12.value = 0;
    mat2.eM12.fract = 0;

    mat2.eM21.value = 0;
    mat2.eM21.fract = 0;

    mat2.eM22.value = 3;
    mat2.eM22.fract = 0;
// Clear the screen to white

    PatBlt(hdc, 0, 0, 2000, 2000, WHITENESS);


    DbgPrint("ft!vTestGGO(): use identity matrix\n");

    for (ul = (ULONG)'a'; ul < (ULONG)'z'; ul++)
    {
     if ( !bTestGetGlyphOutline(hdc, ul, &mat2))
         DbgPrint("ft!vTestGGO(): call to bTestGetGlyphOutline failed\n");
        vDoPause(1);
        // Clear the screen to white

        PatBlt(hdc, 0, 0, 2000, 2000, WHITENESS);


    }
    vDoPause(0);

// Fill in MAT2 structure.  Rotate 45 deg CCW, scale

    mat2.eM11.value = 3;
    mat2.eM11.fract = 0;

    mat2.eM12.value = 3;
    mat2.eM12.fract = 0;

    mat2.eM21.value = -3;
    mat2.eM21.fract = 0;

    mat2.eM22.value = 3;
    mat2.eM22.fract = 0;

    DbgPrint("ft!vTestGGO(): rotate 45 deg CCW and scale by sqrt(2)\n");
    if ( !bTestGetGlyphOutline(hdc, ul,&mat2) )
        DbgPrint("ft!vTestGGO(): call to bTestGetGlyphOutline failed\n");
    vDoPause(0);

// Clear the screen to white

    PatBlt(hdc, 0, 0, 2000, 2000, WHITENESS);


// Fill in MAT2 structure.  general values

    mat2.eM11.value = 5;
    mat2.eM11.fract = 0;

    mat2.eM12.value = 6;
    mat2.eM12.fract = 0;

    mat2.eM21.value = -3;
    mat2.eM21.fract = 0;

    mat2.eM22.value = 3;
    mat2.eM22.fract = 0;

    DbgPrint("ft!vTestGGO(): rotate 45 deg CCW and scale by sqrt(2)\n");
    if ( !bTestGetGlyphOutline(hdc, ul,&mat2) )
        DbgPrint("ft!vTestGGO(): call to bTestGetGlyphOutline failed\n");
    vDoPause(0);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\attr.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   attr.c

Abstract:

   Measure time for a small number of each API call

Author:

   Mark Enstrom   (marke)  13-Apr-1995

Enviornment:

   User Mode

Revision History:

    Dan Almosnino (danalm) 20-Sept-195

1. Timer call modified to run on both NT and WIN95. Results now reported in 100 nano-seconds.
2. Took out a call to strlen in the ETO_ARGS etc. #definitions (attr.c), so that the time
   measurement won't include this call.

    Dan Almosnino (danalm) 20-Nov-1995

1.  Modified Timer call to measure Pentium cycle counts when applicable
2.  Modified default numbers for test iterations to accomodate the statistical module add-on.
    (Typically 1000 test samples are taken, doing 10 iterations each).

--*/

#include "precomp.h"
#include "gdibench.h"
#include "resource.h"

/*++

Routine Description:

    Measure start count

Arguments



Return Value - Performance Count


--*/
_int64
BeginTimeMeasurement()
{
    _int64 PerformanceCount;
    extern BOOL gfPentium;
    extern BOOL gfUseCycleCount;

#ifdef _X86_
                if(gfPentium)
                    PerformanceCount = GetCycleCount();
                else
#endif
                QueryPerformanceCounter((LARGE_INTEGER *)&PerformanceCount);

    return(PerformanceCount);
}

/*++

Routine Description:

    Measure stop count and return the calculated time difference

Arguments

    StartTime   = Start Time Count
    Iter        = No. of Test Iterations

Return Value - Test Time per Iteration, in 100 nano-second units


--*/

ULONGLONG
EndTimeMeasurement(
    _int64  StartTime,
    ULONG      Iter)
{

   _int64 PerformanceCount;
   extern  _int64 PerformanceFreq;
   extern  BOOL gfPentium;

#ifdef _X86_
                if(gfPentium)
                {
                    PerformanceCount = GetCycleCount();
                    PerformanceCount -= CCNT_OVERHEAD;
                }
                else
#endif

   QueryPerformanceCounter((LARGE_INTEGER *)&PerformanceCount);

   PerformanceCount -= StartTime ;

#ifdef _X86_
                if(gfPentium)
                    PerformanceCount /= Iter;
                else
#endif

   PerformanceCount = (PerformanceCount * 10) / (PerformanceFreq * Iter);

   return((ULONGLONG)PerformanceCount);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*++

Routine Description:

   Measure APIs

Arguments

   hdc   - dc
   iter  - number of times to call

Return Value

   time for calls

--*/


ULONGLONG
msAddFontResourceA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //AddFontResourceA();
    }
    END_TIMER;
}

ULONGLONG
msAddFontResourceW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //AddFontResourceW();
    }
    END_TIMER;
}

ULONGLONG
msAngleArc(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        AngleArc(hdc,20,20,ix,(FLOAT)0.0,(FLOAT)0.05);
    }
    END_TIMER;
}

ULONGLONG
msArc(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        Arc(hdc,10,10,50,50,40,40,10,10);
    }
    END_TIMER;
}

ULONGLONG
msBitBlt(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        BitBlt(hdc,0,0,2,2,hdc,100,100,SRCINVERT);
    }
    END_TIMER;
}

ULONGLONG
msCancelDC(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        CancelDC(hdc);
    }
    END_TIMER;
}

ULONGLONG
msChoosePixelFormat(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ChoosePixelFormat();
    }
    END_TIMER;
}

ULONGLONG
msChord(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        Chord(hdc,10,10,40,40,15,15,35,35);
    }
    END_TIMER;
}

ULONGLONG
msCloseMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CloseMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msCloseEnhMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CloseEnhMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msCombineRgn(
    HDC hdc,
    ULONG Iter)
{
    HRGN hr1 = CreateRectRgn(0,0,1000,1000);
    HRGN hr2 = CreateRectRgn(10,10,100,1032);
    HRGN hr3 = CreateRectRgn(0,0,0,0);

    START_TIMER;
    while (ix--)
    {
        CombineRgn(hr3,hr1,hr2,RGN_OR);
    }
	END_TIMER_NO_RETURN;

    DeleteObject(hr1);
    DeleteObject(hr2);
    DeleteObject(hr3);

    RETURN_STOP_TIME;
}

ULONGLONG
msCombineTransform(
    HDC hdc,
    ULONG Iter)
{
    XFORM xf1 = {(FLOAT)1.0,(FLOAT)2.0,(FLOAT)3.0,(FLOAT)4.0,(FLOAT)5.0,(FLOAT)6.0};
    XFORM xf2 = {(FLOAT)-1.0,(FLOAT)-2.0,(FLOAT)-3.0,(FLOAT)-4.0,(FLOAT)-5.0,(FLOAT)-6.0};
    XFORM xf3 = {(FLOAT)0.0,(FLOAT)0.0,(FLOAT)0.0,(FLOAT)0.0,(FLOAT)0.0,(FLOAT)0.0};

    START_TIMER;
    while (ix--)
    {
        CombineTransform(&xf3,&xf1,&xf2);
    }
    END_TIMER;
}

ULONGLONG
msCopyMetaFileA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CopyMetaFileA();
    }
    END_TIMER;
}

ULONGLONG
msCopyMetaFileW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CopyMetaFileW();
    }
    END_TIMER;
}

ULONGLONG
msCopyEnhMetaFileA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CopyEnhMetaFileA();
    }
    END_TIMER;
}

ULONGLONG
msCopyEnhMetaFileW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CopyEnhMetaFileW();
    }
    END_TIMER;
}

ULONGLONG
msCreateCompatibleBitmap(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HBITMAP hbm = CreateCompatibleBitmap(hdc,100,100);
        DeleteObject(hbm);
    }
    END_TIMER;
}

ULONGLONG
msCreateCompatibleDC(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HDC  h1 = CreateCompatibleDC(hdc);
        DeleteDC(h1);
    }
    END_TIMER;
}

ULONGLONG
msCreateDCA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HDC h1 = CreateDCA("DISPLAY",NULL,NULL,NULL);
        DeleteDC(h1);
    }
    END_TIMER;
}

ULONGLONG
msCreateDCW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HDC h1 = CreateDCW(L"DISPLAY",NULL,NULL,NULL);
        DeleteDC(h1);
    }
    END_TIMER;
}

ULONGLONG
msCreateDiscardableBitmap(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HBITMAP hbm = CreateDiscardableBitmap(hdc,100,100);
        DeleteObject(hbm);
    }
    END_TIMER;
}

ULONGLONG
msCreateEllipticRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HRGN hr = CreateEllipticRgn(10,10,40,40);
        DeleteObject(hr);
    }
    END_TIMER;
}

ULONGLONG
msCreateEllipticRgnIndirect(
    HDC hdc,
    ULONG Iter)
{
    RECT rcl = {10,10,40,40};
    START_TIMER;
    while (ix--)
    {
        HRGN hr = CreateEllipticRgnIndirect(&rcl);
        DeleteObject(hr);
    }
    END_TIMER;
}

ULONGLONG
msCreateFontA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HFONT hf = CreateFontA(

                                12,
                                8,
                                0,
                                0,
                                0,
                                FALSE,
                                FALSE,
                                FALSE,
                                ANSI_CHARSET,
                                OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS,
                                DEFAULT_QUALITY,
                                FIXED_PITCH,
                                "Courier"
                                );

        DeleteObject(hf);
    }
    END_TIMER;
}

ULONGLONG
msCreateFontW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HFONT hf = CreateFontW(
                                12,
                                8,
                                0,
                                0,
                                0,
                                FALSE,
                                FALSE,
                                FALSE,
                                ANSI_CHARSET,
                                OUT_DEFAULT_PRECIS,
                                CLIP_DEFAULT_PRECIS,
                                DEFAULT_QUALITY,
                                FIXED_PITCH,
                                L"Courier"
                                );

        DeleteObject(hf);
    }
    END_TIMER;
}

ULONGLONG
msCreateFontIndirectA(
    HDC hdc,
    ULONG Iter)
{
    LOGFONTA lf = {
                  12,
                  8,
                  0,
                  0,
                  0,
                  FALSE,
                  FALSE,
                  FALSE,
                  ANSI_CHARSET,
                  OUT_DEFAULT_PRECIS,
                  CLIP_DEFAULT_PRECIS,
                  DEFAULT_QUALITY,
                  FIXED_PITCH,
                  "Courier"
                 };

    START_TIMER;
    while (ix--)
    {
        HFONT hf = CreateFontIndirectA(&lf);
        DeleteObject(hf);
    }
    END_TIMER;
}

ULONGLONG
msCreateFontIndirectW(
    HDC hdc,
    ULONG Iter)
{
    LOGFONTW lf = {
                  12,
                  8,
                  0,
                  0,
                  0,
                  FALSE,
                  FALSE,
                  FALSE,
                  ANSI_CHARSET,
                  OUT_DEFAULT_PRECIS,
                  CLIP_DEFAULT_PRECIS,
                  DEFAULT_QUALITY,
                  FIXED_PITCH,
                  L"Courier"
                 };

    START_TIMER;
    while (ix--)
    {
        HFONT hf = CreateFontIndirectW(&lf);
        DeleteObject(hf);
    }
    END_TIMER;
}

ULONGLONG
msCreateHatchBrush(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HBRUSH hbr = CreateHatchBrush(HS_CROSS,RGB(0x00,0x80,0x80));
        DeleteObject(hbr);
    }
    END_TIMER;
}

ULONGLONG
msCreateICA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HDC h = CreateICA("DISPLAY",NULL,NULL,NULL);
        DeleteDC(h);
    }
    END_TIMER;
}

ULONGLONG
msCreateICW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HDC h = CreateICW(L"DISPLAY",NULL,NULL,NULL);
        DeleteDC(h);
    }
    END_TIMER;
}

ULONGLONG
msCreateMetaFileA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateMetaFileA();
    }
    END_TIMER;
}

ULONGLONG
msCreateMetaFileW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateMetaFileW();
    }
    END_TIMER;
}

ULONGLONG
msCreateEnhMetaFileA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateEnhMetaFileA();
    }
    END_TIMER;
}

ULONGLONG
msCreateEnhMetaFileW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateEnhMetaFileW();
    }
    END_TIMER;
}

ULONGLONG
msCreatePatternBrush(
    HDC hdc,
    ULONG Iter)
{
    UCHAR data[64];
    HBITMAP hbm = CreateBitmap(8,8,1,8,&data);
    START_TIMER;
    while (ix--)
    {
        HBRUSH h = CreatePatternBrush(hbm);
        DeleteObject(h);
    }
    END_TIMER_NO_RETURN;
    DeleteObject(hbm);
    RETURN_STOP_TIME;
}

ULONGLONG
msCreatePen(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HPEN h = CreatePen(PS_SOLID,0,RGB(0,255,500));
        DeleteObject(h);
    }
    END_TIMER;
}

ULONGLONG
msExtCreatePen(
    HDC hdc,
    ULONG Iter)
{
    LOGBRUSH lb = {BS_SOLID,RGB(0,255,255),0};
    START_TIMER;
    while (ix--)
    {
        HPEN h = ExtCreatePen(PS_GEOMETRIC|PS_SOLID,10,&lb,0,NULL);
        DeleteObject(h);
    }
    END_TIMER;
}

ULONGLONG
msCreatePenIndirect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreatePenIndirect();
    }
    END_TIMER;
}

ULONGLONG
msCreateRectRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateRectRgn();
    }
    END_TIMER;
}

ULONGLONG
msCreateRectRgnIndirect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateRectRgnIndirect();
    }
    END_TIMER;
}

ULONGLONG
msCreateRoundRectRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateRoundRectRgn();
    }
    END_TIMER;
}

ULONGLONG
msCreateScalableFontResourceA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateScalableFontResourceA();
    }
    END_TIMER;
}

ULONGLONG
msCreateScalableFontResourceW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateScalableFontResourceW();
    }
    END_TIMER;
}

ULONGLONG
msCreateSolidBrush(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateSolidBrush();
    }
    END_TIMER;
}

ULONGLONG
msDeleteDC(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HDC h = CreateDC("DISPLAY",NULL,NULL,NULL);
        DeleteDC(h);
    }
    END_TIMER;
}

ULONGLONG
msDeleteMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DeleteMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msDeleteEnhMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DeleteEnhMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msDeleteObject(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HPEN h = CreatePen(PS_SOLID,0,0);
        DeleteObject(h);
    }
    END_TIMER;
}

ULONGLONG
msDescribePixelFormat(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DescribePixelFormat();
    }
    END_TIMER;
}

ULONGLONG
msDeviceCapabilitiesExA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DeviceCapabilitiesExA();
    }
    END_TIMER;
}

ULONGLONG
msDeviceCapabilitiesExW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DeviceCapabilitiesExW();
    }
    END_TIMER;
}

//= DeviceCapabilitiesExA
ULONGLONG
msDrawEscape(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DrawEscape();
    }
    END_TIMER;
}

ULONGLONG
msEndDoc(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EndDoc();
    }
    END_TIMER;
}

ULONGLONG
msEndPage(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EndPage();
    }
    END_TIMER;
}

ULONGLONG
msEnumFontFamiliesA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumFontFamiliesA();
    }
    END_TIMER;
}

ULONGLONG
msEnumFontFamiliesW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumFontFamiliesW();
    }
    END_TIMER;
}

ULONGLONG
msEnumFontsA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumFontsA();
    }
    END_TIMER;
}

ULONGLONG
msEnumFontsW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumFontsW();
    }
    END_TIMER;
}

ULONGLONG
msEnumObjects(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumObjects();
    }
    END_TIMER;
}

ULONGLONG
msEllipse(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //Ellipse();
    }
    END_TIMER;
}

ULONGLONG
msEqualRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EqualRgn();
    }
    END_TIMER;
}

ULONGLONG
msEscape(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //Escape();
    }
    END_TIMER;
}

ULONGLONG
msExtEscape(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ExtEscape();
    }
    END_TIMER;
}

ULONGLONG
msExcludeClipRect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ExcludeClipRect();
    }
    END_TIMER;
}

ULONGLONG
msExtFloodFill(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ExtFloodFill();
    }
    END_TIMER;
}

ULONGLONG
msExtCreateRegion(
    HDC hdc,
    ULONG Iter)
{
    PRGNDATA prData;
    RECT rc1 = {1,1,32,4};
    RECT rc2 = {1,5,32,8};
    RECT rc3 = {1,9,32,12};
    RECT rc4 = {1,13,32,16};
    RECT rcb = {0,0,100,100};
    XFORM x = {(FLOAT)1.0,(FLOAT)0.0, (FLOAT)0.0, (FLOAT)1.0,(FLOAT)0.0,(FLOAT)0.0};

    prData = LocalAlloc(0,sizeof(RGNDATA) + sizeof(RECT) * 4);

    prData->rdh.dwSize = sizeof(RGNDATAHEADER);
    prData->rdh.iType  = RDH_RECTANGLES;
    prData->rdh.nCount = 4;
    prData->rdh.nRgnSize = 0;
    prData->rdh.rcBound = rcb;

    *(PRECT)(&prData->Buffer[0]) =  rc1;
    *(PRECT)(&prData->Buffer[16]) =  rc1;
    *(PRECT)(&prData->Buffer[32]) =  rc1;
    *(PRECT)(&prData->Buffer[48]) =  rc1;

    {
        START_TIMER;
        while (ix--)
        {
            HRGN h = ExtCreateRegion(&x,sizeof(RGNDATA) + sizeof(RECT) * 4,prData);
            DeleteObject(h);
        }
        END_TIMER;
    }

}

ULONGLONG
msExtSelectClipRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ExtSelectClipRgn();
    }
    END_TIMER;
}

ULONGLONG
msFillRgn(
    HDC hdc,
    ULONG Iter)
{
    HRGN h = CreateRectRgn(10,10,20,20);
    HBRUSH hbr = GetStockObject(BLACK_BRUSH);
    START_TIMER;
    while (ix--)
    {
        FillRgn(hdc,h,hbr);
    }
    END_TIMER_NO_RETURN;
    DeleteObject(h);
    RETURN_STOP_TIME;
}

ULONGLONG
msFloodFill(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //FloodFill();
    }
    END_TIMER;
}

ULONGLONG
msFrameRgn(
    HDC hdc,
    ULONG Iter)
{
    HRGN h = CreateRectRgn(10,10,20,20);
    HBRUSH hbr = GetStockObject(BLACK_BRUSH);
    START_TIMER;
    while (ix--)
    {
        FrameRgn(hdc,h,hbr,1,1);
    }
	END_TIMER_NO_RETURN;
    DeleteObject(h);
    RETURN_STOP_TIME;
}

ULONGLONG
msGdiComment(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GdiComment();
    }
    END_TIMER;
}

ULONGLONG
msGdiPlayScript(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GdiPlayScript();
    }
    END_TIMER;
}

ULONGLONG
msGdiPlayDCScript(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GdiPlayDCScript();
    }
    END_TIMER;
}

ULONGLONG
msGdiPlayJournal(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GdiPlayJournal();
    }
    END_TIMER;
}

ULONGLONG
msGetAspectRatioFilterEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetAspectRatioFilterEx();
    }
    END_TIMER;
}

ULONGLONG
msGetBitmapDimensionEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetBitmapDimensionEx();
    }
    END_TIMER;
}

ULONGLONG
msGetBkColor(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ULONG Color = GetBkColor(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetBkMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ULONG mode = GetBkMode(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetBrushOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        POINT pt;
        GetBrushOrgEx(hdc,&pt);
    }
    END_TIMER;
}

ULONGLONG
msGetCharABCWidthsA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ABC abc[2];
        GetCharABCWidthsA(hdc,3,4,abc);
    }
    END_TIMER;
}

ULONGLONG
msGetCharABCWidthsW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ABC abc[2];
        GetCharABCWidthsW(hdc,3,4,abc);
    }
    END_TIMER;
}

ULONGLONG
msGetCharABCWidthsFloatA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ABCFLOAT abc[2];
        GetCharABCWidthsFloatA(hdc,2,3,abc);
    }
    END_TIMER;
}

ULONGLONG
msGetCharABCWidthsFloatW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ABCFLOAT abc[2];
        GetCharABCWidthsFloatA(hdc,2,3,abc);
    }
    END_TIMER;
}

ULONGLONG
msGetClipBox(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        RECT rc;
        GetClipBox(hdc,&rc);
    }
    END_TIMER;
}

ULONGLONG
msGetClipRgn(
    HDC hdc,
    ULONG Iter)
{

    HRGN hRgn;
    HRGN hOld;

    START_TIMER;

    hRgn = CreateRectRgn(1,1,5,5);

    hOld = (HRGN)SelectObject(hdc,hRgn);

    while (ix--)
    {
        int il;
        il = GetClipRgn(hdc,hRgn);
    }

    SelectObject(hdc,hOld);

    DeleteObject(hRgn);

    END_TIMER;
}

ULONGLONG
msGetColorAdjustment(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        COLORADJUSTMENT lpca;
        GetColorAdjustment(hdc,&lpca);
    }
    END_TIMER;
}

ULONGLONG
msGetCurrentObject(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HPEN hpen;
        HBRUSH hbr;
        HPALETTE hpal;
        HFONT hfo;
        HBITMAP hbm;

        hpen = GetCurrentObject(hdc,OBJ_PEN);
        hbr  = GetCurrentObject(hdc,OBJ_BRUSH);
        hpal = GetCurrentObject(hdc,OBJ_PAL);
        hfo  = GetCurrentObject(hdc,OBJ_FONT);
        hbm  = GetCurrentObject(hdc,OBJ_BITMAP);
    }
    END_TIMER;
}

ULONGLONG
msGetCurrentPositionEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        POINT pt;
        GetCurrentPositionEx(hdc,&pt);
    }
    END_TIMER;
}

ULONGLONG
msGetDeviceCaps(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ULONG ul = GetDeviceCaps(hdc,DRIVERVERSION);
    }
    END_TIMER;
}

ULONGLONG
msGetFontResourceInfo(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetFontResourceInfo();
    }
    END_TIMER;
}

ULONGLONG
msGetFontResourceInfoW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetFontResourceInfoW();
    }
    END_TIMER;
}

ULONGLONG
msGetGraphicsMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        int i = GetGraphicsMode(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetMapMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        int i = GetMapMode(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetMetaFileA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetMetaFileA();
    }
    END_TIMER;
}

ULONGLONG
msGetMetaFileW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetMetaFileW();
    }
    END_TIMER;
}

ULONGLONG
msGetMetaRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetMetaRgn();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFileA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFileA();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFileW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFileW();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFileDescriptionA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFileDescriptionA();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFileDescriptionW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFileDescriptionW();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFileHeader(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFileHeader();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFilePaletteEntries(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFilePaletteEntries();
    }
    END_TIMER;
}

ULONGLONG
msGetFontData(
    HDC hdc,
    ULONG Iter)
{

    //
    // must select true-type font
    //
    HFONT hfo = CreateFont(
                            12,
                            8,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            ANSI_CHARSET,
                            OUT_DEFAULT_PRECIS,
                            CLIP_DEFAULT_PRECIS,
                            DEFAULT_QUALITY,
                            FIXED_PITCH,
                            "Arial");

    HFONT hOld = SelectObject(hdc,hfo);

	    START_TIMER;
        while (ix--)
        {
            UCHAR BufData[1024];
            int i = GetFontData(hdc,0,0,BufData,1024);
        }
    	END_TIMER_NO_RETURN;

    //
    // delete font
    //

    SelectObject(hdc,hOld);
    DeleteObject(hfo);

	RETURN_STOP_TIME;

}

ULONGLONG
msGetGlyphOutlineA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        MAT2 mat = {{1,0},{1,0}, {1,0}, {1,0}};
        UCHAR Buffer[1024];
        GLYPHMETRICS pGlyph;
        DWORD dw = GetGlyphOutlineA(hdc,
                                   32,
                                   GGO_METRICS,
                                   &pGlyph,
                                   1024,
                                   Buffer,
                                   &mat
                                   );
    }
    END_TIMER;
}

ULONGLONG
msGetGlyphOutlineW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        MAT2 mat = {{1,0},{1,0}, {1,0}, {1,0}};
        UCHAR Buffer[1024];
        GLYPHMETRICS pGlyph;
        DWORD dw = GetGlyphOutlineW(hdc,
                                   32,
                                   GGO_METRICS,
                                   &pGlyph,
                                   1024,
                                   Buffer,
                                   &mat
                                   );
    }
    END_TIMER;
}

ULONGLONG
msGetKerningPairsA(
    HDC hdc,
    ULONG Iter)
{
    HFONT hfo = CreateFont(
                            12,
                            8,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            ANSI_CHARSET,
                            OUT_DEFAULT_PRECIS,
                            CLIP_DEFAULT_PRECIS,
                            DEFAULT_QUALITY,
                            FIXED_PITCH,
                            "Arial");
    HFONT hOld = SelectObject(hdc,hfo);

    START_TIMER;
    while (ix--)
    {
        KERNINGPAIR lpk[2];
        GetKerningPairsA(hdc,2,lpk);
    }
    END_TIMER_NO_RETURN;

    SelectObject(hdc,hOld);
    DeleteObject(hfo);

	RETURN_STOP_TIME;

}

ULONGLONG
msGetKerningPairsW(
    HDC hdc,
    ULONG Iter)
{
    HFONT hfo = CreateFont(
                            12,
                            8,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            ANSI_CHARSET,
                            OUT_DEFAULT_PRECIS,
                            CLIP_DEFAULT_PRECIS,
                            DEFAULT_QUALITY,
                            FIXED_PITCH,
                            "Arial");
    HFONT hOld = SelectObject(hdc,hfo);

    START_TIMER;
    while (ix--)
    {
        KERNINGPAIR lpk[2];
        GetKerningPairsW(hdc,2,lpk);
    }
    END_TIMER_NO_RETURN;

    SelectObject(hdc,hOld);
    DeleteObject(hfo);

	RETURN_STOP_TIME;

}

ULONGLONG
msGetNearestColor(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ULONG ul = GetNearestColor(hdc,PALETTERGB(0xff,0x05,0x43));
    }
    END_TIMER;
}

ULONGLONG
msGetNearestPaletteIndex(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        UINT i = GetNearestPaletteIndex(GetStockObject(DEFAULT_PALETTE),PALETTERGB(0xff,0x05,0x43));
    }
    END_TIMER;
}

ULONGLONG
msGetOutlineTextMetricsA(
    HDC hdc,
    ULONG Iter)
{
    //
    // must have a true-type font
    //

    HFONT hfo = CreateFont(
                            12,
                            8,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            ANSI_CHARSET,
                            OUT_DEFAULT_PRECIS,
                            CLIP_DEFAULT_PRECIS,
                            DEFAULT_QUALITY,
                            FIXED_PITCH,
                            "Arial");

    HFONT hOld = SelectObject(hdc,hfo);

    ULONG Size = GetOutlineTextMetricsA(hdc,0,NULL);

    POUTLINETEXTMETRICA pOtm = NULL;

    if (Size == 0)
    {
        MessageBox(NULL,"ERROR","GetOutlineTextMetric size = 0",MB_OK);
        SelectObject(hdc,hOld);
        DeleteObject(hfo);
        return(0);
    }

    pOtm = LocalAlloc(0,Size);

    {
        START_TIMER;
        while (ix--)
        {
            OUTLINETEXTMETRICA Otm;
            UINT i = GetOutlineTextMetricsA(hdc,Size,pOtm);
        }
		END_TIMER_NO_RETURN;

        SelectObject(hdc,hOld);
        LocalFree(pOtm);
        DeleteObject(hfo);

        RETURN_STOP_TIME;
    }
}

ULONGLONG
msGetOutlineTextMetricsW(
    HDC hdc,
    ULONG Iter)
{
    //
    // must have a true-type font
    //

    HFONT hfo = CreateFont(
                            12,
                            8,
                            0,
                            0,
                            0,
                            0,
                            0,
                            0,
                            ANSI_CHARSET,
                            OUT_DEFAULT_PRECIS,
                            CLIP_DEFAULT_PRECIS,
                            DEFAULT_QUALITY,
                            FIXED_PITCH,
                            "Arial");

    HFONT hOld = SelectObject(hdc,hfo);

    ULONG Size = GetOutlineTextMetricsW(hdc,0,NULL);

    POUTLINETEXTMETRICW pOtm = NULL;

    if (Size == 0)
    {
//        MessageBox(NULL,"ERROR","GetOutlineTextMetric size = 0",MB_OK);
//  Killed message, does not work well in statistics loop where you'll have to press "OK" 1000 times...

        SelectObject(hdc,hOld);
        DeleteObject(hfo);
        return(0);
    }

    pOtm = LocalAlloc(0,Size);

    {
        START_TIMER;
        while (ix--)
        {
            OUTLINETEXTMETRICW Otm;
            UINT i = GetOutlineTextMetricsW(hdc,Size,pOtm);
        }
		END_TIMER_NO_RETURN;

        SelectObject(hdc,hOld);
        LocalFree(pOtm);
        DeleteObject(hfo);

        RETURN_STOP_TIME;
    }
}

ULONGLONG
msGetPixel(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        COLORREF c = GetPixel(hdc,1,1);
    }
    END_TIMER;
}

ULONGLONG
msGetPixelFormat(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
//        int i = GetPixelFormat(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetPolyFillMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        int i = GetPolyFillMode(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetRasterizerCaps(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        RASTERIZER_STATUS lps;
        GetRasterizerCaps(&lps,sizeof(RASTERIZER_STATUS));
    }
    END_TIMER;
}

ULONGLONG
msGetRandomRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetRandomRgn();
    }
    END_TIMER;
}

ULONGLONG
msGetRegionData(
    HDC hdc,
    ULONG Iter)
{
    HRGN hr = CreateRectRgn(0,5,13,43);
    PRGNDATA pRgn = (PRGNDATA)LocalAlloc(0,sizeof(RGNDATA) + 255);
    START_TIMER;
    while (ix--)
    {
        GetRegionData(hr,sizeof(RGNDATA) + 255,pRgn);
    }
	END_TIMER_NO_RETURN;

    DeleteObject(hr);

    RETURN_STOP_TIME;
}


ULONGLONG
msGetRelAbs(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetRelAbs();
    }
    END_TIMER;
}

ULONGLONG
msGetRgnBox(
    HDC hdc,
    ULONG Iter)
{
    HRGN hr = CreateRectRgn(0,5,13,43);
    START_TIMER;
    while (ix--)
    {
        RECT r;
        GetRgnBox(hr,&r);
    }
    END_TIMER_NO_RETURN;

    DeleteObject(hr);

    RETURN_STOP_TIME;
}

ULONGLONG
msGetROP2(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        UINT i = GetROP2(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetStockObject(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        HGDIOBJ h = GetStockObject(GRAY_BRUSH);
    }
    END_TIMER;
}

ULONGLONG
msGetStretchBltMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        int i = GetStretchBltMode(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetSystemPaletteUse(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        UINT i = GetSystemPaletteUse(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetTextAlign(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        UINT i = GetTextAlign(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetTextCharacterExtra(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        int i = GetTextCharacterExtra(hdc);
    }
    END_TIMER;
}

ULONGLONG
msGetTextColor(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        COLORREF c = GetTextColor(hdc);
    }
    END_TIMER;
}

SIZE    gsz;
extern pszTest, pwszTest;

#define TestLen StrLen
#define wTestLen StrLen

#define ETO_ARGS_A  hdc, 0, 50, 0, NULL, (LPCTSTR)pszTest,  TestLen, NULL
#define TO_ARGS_A   hdc, 0, 50, (LPCTSTR)pszTest,  TestLen
#define GTE_ARGS_A  hdc, (LPCTSTR)pszTest,  TestLen, &gsz
#define PDX_ARGS_A  hdc, 0, 50, 0, NULL, (LPCTSTR)pszTest, StrLen, dx

#define ETO_ARGS_W  hdc, 0, 50, 0, NULL, (LPCWSTR)pwszTest, wTestLen, NULL
#define TO_ARGS_W   hdc, 0, 50, (LPCWSTR)pwszTest, wTestLen
#define GTE_ARGS_W  hdc, (LPCWSTR)pwszTest, wTestLen, &gsz
#define PDX_ARGS_W  hdc, 0, 50, 0, NULL, (LPCWSTR)pwszTest, wTestLen, dx

ULONGLONG
msGetTextExtentPointA(
    HDC hdc,
    ULONG Iter)
{

    GetTextExtentPointA(GTE_ARGS_A);

    {
    START_TIMER;
    while (ix--)
    {
        GetTextExtentPointA(GTE_ARGS_A);
    }
    END_TIMER;
    }

}

ULONGLONG
msGetTextExtentPointW(
    HDC hdc,
    ULONG Iter)
{

    GetTextExtentPointW(GTE_ARGS_W);
    {
    START_TIMER;
    while (ix--)
    {
        GetTextExtentPointW(GTE_ARGS_W);
    }
    END_TIMER;
    }

}

ULONGLONG
msGetTextExtentPoint32A(
    HDC hdc,
    ULONG Iter)
{

    GetTextExtentPoint32A(GTE_ARGS_A);

    {
    START_TIMER;
    while (ix--)
    {
        GetTextExtentPoint32A(GTE_ARGS_A);
    }
    END_TIMER;
    }

}

ULONGLONG
msGetTextExtentPoint32W(
    HDC hdc,
    ULONG Iter)
{

    GetTextExtentPoint32W(GTE_ARGS_W);
    {
    START_TIMER;
    while (ix--)
    {
        GetTextExtentPoint32W(GTE_ARGS_W);
    }
    END_TIMER;
    }

}

ULONGLONG
msGetTextExtentExPointA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        UCHAR Str[] = "String";
        UINT Fit;
        UINT Dx[32];
        SIZE sz;

        GetTextExtentExPointA(hdc,Str,6,100,&Fit,Dx,&sz);
    }
    END_TIMER;
}

ULONGLONG
msGetTextExtentExPointW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        WCHAR Str[] = L"String";
        UINT Fit;
        UINT Dx[32];
        SIZE sz;

        GetTextExtentExPointW(hdc,Str,6,100,&Fit,Dx,&sz);
    }
    END_TIMER;
}

ULONGLONG
msGetTextFaceA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        UCHAR Name[100];
        GetTextFaceA(hdc,100,Name);
    }
    END_TIMER;
}

ULONGLONG
msGetTextFaceW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        WCHAR Name[100];
        GetTextFaceW(hdc,100,Name);
    }
    END_TIMER;
}

ULONGLONG
msGetTextMetricsA(
    HDC hdc,
    ULONG Iter)
{
    INIT_TIMER;

//    if(WINNT_PLATFORM){
       INIT_IO_COUNT;
//	}

    if(WINNT_PLATFORM){
       START_IO_COUNT;
	}
    START_TIMER_NO_INIT;

    while (ix--)
    {
        TEXTMETRICA lptm;
        GetTextMetricsA(hdc,&lptm);
    }
    END_TIMER_NO_RETURN;
	
	if(WINNT_PLATFORM){
	   STOP_IO_COUNT;
	}
	RETURN_STOP_TIME;

}

ULONGLONG
msGetTextMetricsW(
    HDC hdc,
    ULONG Iter)
{
    INIT_TIMER;
//    if(WINNT_PLATFORM){
       INIT_IO_COUNT;
//	}

    if(WINNT_PLATFORM){
       START_IO_COUNT;
	}
    START_TIMER_NO_INIT;
	
    while (ix--)
    {
        TEXTMETRICW lptm;
        GetTextMetricsW(hdc,&lptm);
    }
    END_TIMER_NO_RETURN;
	
	if(WINNT_PLATFORM){
	   STOP_IO_COUNT;
	}
	RETURN_STOP_TIME;
}

ULONGLONG
msGetViewportExtEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetViewportExtEx();
    }
    END_TIMER;
}

ULONGLONG
msGetViewportOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        POINT pt;
        GetViewportOrgEx(hdc,&pt);
    }
    END_TIMER;
}

ULONGLONG
msGetWindowExtEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SIZE sz;
        GetWindowExtEx(hdc,&sz);
    }
    END_TIMER;
}

ULONGLONG
msGetWindowOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        POINT pt;
        GetWindowOrgEx(hdc,&pt);
    }
    END_TIMER;
}

ULONGLONG
msGetWorldTransform(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        XFORM xf;
        GetWorldTransform(hdc,&xf);
    }
    END_TIMER;
}

ULONGLONG
msIntersectClipRect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SelectClipRgn(hdc,NULL);
        IntersectClipRect(hdc,0,1,20,30);
    }
    END_TIMER;
}

ULONGLONG
msInvertRgn(
    HDC hdc,
    ULONG Iter)
{
    HRGN hr = CreateRectRgn(5,5,10,10);
    START_TIMER;
    while (ix--)
    {
        InvertRgn(hdc,hr);
    }
    END_TIMER_NO_RETURN;

    DeleteObject(hr);

    RETURN_STOP_TIME;
}

ULONGLONG
msLineDDA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //LineDDA();
    }
    END_TIMER;
}

ULONGLONG
msLineTo(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        MoveToEx(hdc,0,0,NULL);
        LineTo(hdc,ix&0xff,ix&0xff);
    }
    END_TIMER;
}

ULONGLONG
msMaskBlt(
    HDC hdc,
    ULONG Iter)
{
    HDC hdcSrc = CreateCompatibleDC(hdc);
    ULONG hData[10] = {1,2,3,4,5,6,7,8,9,10};
    HBITMAP hbmSrc = CreateCompatibleBitmap(hdc,10,10);
    HBITMAP hbmMask = CreateBitmap(10,10,1,1,(PVOID)hData);

    START_TIMER;

    SelectObject(hdcSrc,hbmSrc);

    while (ix--)
    {
        MaskBlt(hdc,0,0,2,2,hdcSrc,1,0,hbmMask,2,0,0xcdef00);
    }

    DeleteDC(hdcSrc);
    DeleteObject(hbmSrc);
    DeleteObject(hbmMask);
    END_TIMER;
}

ULONGLONG
msModifyWorldTransform(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ModifyWorldTransform();
    }
    END_TIMER;
}

ULONGLONG
msMoveToEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        MoveToEx(hdc,ix&0xff,ix&0xff,NULL);
    }
    END_TIMER;
}

ULONGLONG
msOffsetClipRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //OffsetClipRgn();
    }
    END_TIMER;
}

ULONGLONG
msOffsetRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //OffsetRgn();
    }
    END_TIMER;
}

ULONGLONG
msOffsetViewportOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //OffsetViewportOrgEx();
    }
    END_TIMER;
}

ULONGLONG
msOffsetWindowOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //OffsetWindowOrgEx();
    }
    END_TIMER;
}

ULONGLONG
msPaintRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PaintRgn();
    }
    END_TIMER;
}

ULONGLONG
msPatBlt(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        PatBlt(hdc,10,10,2,2,PATCOPY);
    }
    END_TIMER;
}

ULONGLONG
msPie(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //Pie();
    }
    END_TIMER;
}

ULONGLONG
msPlayMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PlayMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msPlayEnhMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PlayEnhMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msPlgBlt(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PlgBlt();
    }
    END_TIMER;
}

ULONGLONG
msPtInRegion(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PtInRegion();
    }
    END_TIMER;
}

ULONGLONG
msPtVisible(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PtVisible();
    }
    END_TIMER;
}

ULONGLONG
msRealizePalette(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RealizePalette();
    }
    END_TIMER;
}

ULONGLONG
msRectangle(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //Rectangle();
    }
    END_TIMER;
}

ULONGLONG
msRectInRegion(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RectInRegion();
    }
    END_TIMER;
}

ULONGLONG
msRectVisible(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RectVisible();
    }
    END_TIMER;
}

ULONGLONG
msRemoveFontResourceA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RemoveFontResourceA();
    }
    END_TIMER;
}

ULONGLONG
msRemoveFontResourceW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RemoveFontResourceW();
    }
    END_TIMER;
}

ULONGLONG
msResizePalette(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ResizePalette();
    }
    END_TIMER;
}

ULONGLONG
msRestoreDC(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RestoreDC();
    }
    END_TIMER;
}

ULONGLONG
msRoundRect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //RoundRect();
    }
    END_TIMER;
}

ULONGLONG
msSaveDC(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SaveDC();
    }
    END_TIMER;
}

ULONGLONG
msScaleViewportExtEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ScaleViewportExtEx();
    }
    END_TIMER;
}

ULONGLONG
msScaleWindowExtEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ScaleWindowExtEx();
    }
    END_TIMER;
}

ULONGLONG
msSelectClipRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SelectClipRgn();
    }
    END_TIMER;
}

ULONGLONG
msSelectObject(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
       //SelectObject();
    }
    END_TIMER;
}

ULONGLONG
msSelectBrushLocal(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SelectBrushLocal();
    }
    END_TIMER;
}

ULONGLONG
msSelectFontLocal(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SelectFontLocal();
    }
    END_TIMER;
}

ULONGLONG
msSelectPalette(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SelectPalette();
    }
    END_TIMER;
}

ULONGLONG
msSetBitmapDimensionEx(
    HDC hdc,
    ULONG Iter)
{
    HBITMAP hbm = CreateCompatibleBitmap(hdc,20,20);
    START_TIMER;
    while (ix--)
    {
        SetBitmapDimensionEx(hbm,ix & 0xff,20,NULL);
    }
    END_TIMER;
}

ULONGLONG
msSetBkColor(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetBkColor(hdc,ix);
    }
    END_TIMER;
}

ULONGLONG
msSetBkMode(
    HDC hdc,
    ULONG Iter)
{
    INIT_TIMER;

    SetBkMode(hdc, OPAQUE);

    START_TIMER_NO_INIT;
    while (ix--)
    {
        SetBkMode(hdc,OPAQUE);
    }
    END_TIMER;
}

ULONGLONG
msSetBrushOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetBrushOrgEx(hdc,ix & 0x0f,ix & 0x0f,NULL);
    }
    END_TIMER;
}

ULONGLONG
msSetColorAdjustment(
    HDC hdc,
    ULONG Iter)
{
    COLORADJUSTMENT ca = {sizeof(COLORADJUSTMENT),
                          CA_NEGATIVE,
                          ILLUMINANT_A,
                          12000,
                          13000,
                          14000,
                          1000,
                          7000,
                          50,
                          50,
                          50,
                          -10
                          };
    START_TIMER;
    while (ix--)
    {
        SetColorAdjustment(hdc,&ca);
    }
    END_TIMER;
}

ULONGLONG
msSetFontEnumeration(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetFontEnumeration();
    }
    END_TIMER;
}

ULONGLONG
msSetGraphicsMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetGraphicsMode(hdc,ix&1?GM_ADVANCED:GM_COMPATIBLE);
    }
    END_TIMER;
}

ULONGLONG
msSetMapMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetMapMode(hdc,ix&1?MM_TEXT:MM_LOENGLISH);
    }
    END_TIMER;
}

ULONGLONG
msSetMapperFlags(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetMapperFlags(hdc,ix&1);
    }
    END_TIMER;
}

ULONGLONG
msSetPixel(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        COLORREF cr = SetPixel(hdc,ix&0xff,20,PALETTERGB(0xff,0x00,0x00));
    }
    END_TIMER;
}

ULONGLONG
msSetPixelFormat(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetPixelFormat();
    }
    END_TIMER;
}

ULONGLONG
msSetPixelV(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetPixelV(hdc,ix&0xff,30,PALETTERGB(0x00,0xff,0x00));
    }
    END_TIMER;
}

ULONGLONG
msSetPolyFillMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetPolyFillMode(hdc,ix&1?ALTERNATE:WINDING);
    }
    END_TIMER;
}

ULONGLONG
msSetRectRgn(
    HDC hdc,
    ULONG Iter)
{
    HRGN hr = CreateRectRgn(0,0,1000,1000);
    START_TIMER;
    while (ix--)
    {
        SetRectRgn(hr,0,0,ix,ix);
    }
    END_TIMER_NO_RETURN;

    DeleteObject(hr);

    RETURN_STOP_TIME;
}

ULONGLONG
msSetRelAbs(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetRelAbs();
    }
    END_TIMER;
}

ULONGLONG
msSetROP2(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetROP2(hdc,ix&0xff);
    }
    END_TIMER;
}

ULONGLONG
msSetStretchBltMode(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetStretchBltMode(hdc,ix&1?BLACKONWHITE:COLORONCOLOR);
    }
    END_TIMER;
}

ULONGLONG
msSetSystemPaletteUse(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetSystemPaletteUse(hdc,ix&1?SYSPAL_STATIC:SYSPAL_NOSTATIC);
    }
    END_TIMER;
}

ULONGLONG
msSetTextAlign(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetTextAlign(hdc,ix&0x01?TA_BOTTOM:TA_TOP);
    }
    END_TIMER;
}

ULONGLONG
msSetTextCharacterExtra(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetTextCharacterExtra(hdc,ix&0x0f);
    }
    END_TIMER;
}

ULONGLONG
msSetTextColor(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetTextColor(hdc,ix&0xff);
    }
    END_TIMER;
}

ULONGLONG
msSetTextJustification(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetTextJustification(hdc,ix&0xf,ix&0xf);
    }
    END_TIMER;
}

ULONGLONG
msSetViewportExtEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetViewportExtEx(hdc,ix,ix,NULL);
    }
    END_TIMER;
}

ULONGLONG
msSetViewportOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetViewportOrgEx(hdc,ix&0xf,ix&0xf,NULL);
    }
    END_TIMER;
}

ULONGLONG
msSetWindowExtEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetWindowExtEx(hdc,ix,ix,NULL);
    }
    END_TIMER;
}

ULONGLONG
msSetWindowOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        SetWindowOrgEx(hdc,ix&0x0f,ix&0x0f,NULL);
    }
    END_TIMER;
}

ULONGLONG
msSetWorldTransform(
    HDC hdc,
    ULONG Iter)
{
    XFORM xf = {(FLOAT)1.0,(FLOAT)1.0,(FLOAT)2.0,(FLOAT)2.0,(FLOAT)3.0,(FLOAT)3.0};
    START_TIMER;
    while (ix--)
    {
        SetWorldTransform(hdc,&xf);
        xf.eM11 = (FLOAT)ix;
    }
    END_TIMER;
}

ULONGLONG
msStartDocA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //StartDocA();
        //AbortDoc();
    }
    END_TIMER;
}

ULONGLONG
msStartDocW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //StartDocW();
        //AbortDoc();
    }
    END_TIMER;
}

ULONGLONG
msStartPage(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //StartPage();
    }
    END_TIMER;
}

ULONGLONG
msStretchBlt(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        StretchBlt(hdc,0,0,2,2,hdc,10,10,4,4,SRCCOPY);
    }
    END_TIMER;
}

ULONGLONG
msSwapBuffers(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SwapBuffers();
    }
    END_TIMER;
}

ULONGLONG
msTextOutA(
    HDC hdc,
    ULONG Iter)
{

    TextOutA(TO_ARGS_A);

    {
    START_TIMER;
    while (ix--)
    {
        TextOutA(TO_ARGS_A);
    }
    END_TIMER;
    }

}

ULONGLONG
msTextOutW(
    HDC hdc,
    ULONG Iter)
{

    TextOutW(TO_ARGS_W);
    {
    START_TIMER;
    while (ix--)
    {
        TextOutW(TO_ARGS_W);
    }
    END_TIMER;
    }

}

ULONGLONG
msUpdateColors(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //UpdateColors();
    }
    END_TIMER;
}

ULONGLONG
msUnrealizeObject(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //UnrealizeObject();
    }
    END_TIMER;
}

ULONGLONG
msFixBrushOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //FixBrushOrgEx();
    }
    END_TIMER;
}

ULONGLONG
msGetDCOrgEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetDCOrgEx();
    }
    END_TIMER;
}

ULONGLONG
msAnimatePalette(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //AnimatePalette();
    }
    END_TIMER;
}

ULONGLONG
msArcTo(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ArcTo();
    }
    END_TIMER;
}

ULONGLONG
msBeginPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //BeginPath();
    }
    END_TIMER;
}

ULONGLONG
msCloseFigure(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CloseFigure();
    }
    END_TIMER;
}

ULONGLONG
msCreateBitmap(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateBitmap();
    }
    END_TIMER;
}

ULONGLONG
msCreateBitmapIndirect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateBitmapIndirect();
    }
    END_TIMER;
}

ULONGLONG
msCreateBrushIndirect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateBrushIndirect();
    }
    END_TIMER;
}

ULONGLONG
msCreateDIBitmap(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateDIBitmap();
    }
    END_TIMER;
}

ULONGLONG
msCreateDIBPatternBrush(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateDIBPatternBrush();
    }
    END_TIMER;
}

ULONGLONG
msCreateDIBPatternBrushPt(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateDIBPatternBrushPt();
    }
    END_TIMER;
}

ULONGLONG
msCreateDIBSection(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateDIBSection();
    }
    END_TIMER;
}

ULONGLONG
msCreateHalftonePalette(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreateHalftonePalette();
    }
    END_TIMER;
}

ULONGLONG
msCreatePalette(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreatePalette();
    }
    END_TIMER;
}

ULONGLONG
msCreatePolygonRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreatePolygonRgn();
    }
    END_TIMER;
}

ULONGLONG
msCreatePolyPolygonRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //CreatePolyPolygonRgn();
    }
    END_TIMER;
}

ULONGLONG
msDPtoLP(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //DPtoLP();
    }
    END_TIMER;
}

ULONGLONG
msEndPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EndPath();
    }
    END_TIMER;
}

ULONGLONG
msEnumMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumMetaFile();
    }
    END_TIMER;
}

ULONGLONG
msEnumEnhMetaFile(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //EnumEnhMetaFile();
    }
    END_TIMER;
}



ULONGLONG
msExtTextOutA(
    HDC hdc,
    ULONG Iter)
{

// put all the glyphs in the cache

//        ExtTextOutA(ETO_ARGS_A);

        {
            START_TIMER;
        while (ix--)
        {
            ExtTextOutA(ETO_ARGS_A);
        }
        END_TIMER;
        }

}

ULONGLONG
msExtTextOutW(
    HDC hdc,
    ULONG Iter)
{

// put all the glyphs in the cache

//    ExtTextOutW(ETO_ARGS_W);

    {
    START_TIMER;
    while (ix--)
    {
        ExtTextOutW(ETO_ARGS_W);
    }
    END_TIMER;
    }

}

ULONGLONG
msExtTextOutApdx(
    HDC hdc,
    ULONG Iter)
{
    INT  dx[256];
    INT  i;
    SIZE size;
    INT  iOldExtent;

    iOldExtent = 0;
    for (i = 0; i < (int)StrLen - 1; i++)
    {
        GetTextExtentPoint32A(hdc, (LPCTSTR)pszTest, i + 1, &size);
        dx[i] = size.cx - iOldExtent;
        iOldExtent = size.cx;
    }
    dx[StrLen - 1] = 0;

    ExtTextOutA(PDX_ARGS_A);

    {
    START_TIMER;
    while (ix--)
    {
        ExtTextOutA(PDX_ARGS_A);
    }
    END_TIMER;
    }
}

ULONGLONG
msExtTextOutWpdx(
    HDC hdc,
    ULONG Iter)
{
    INT  dx[256];
    INT  i;
    SIZE size;
    INT  iOldExtent;

    iOldExtent = 0;
    for (i = 0; i < (int)StrLen - 1; i++)
    {
        GetTextExtentPoint32W(hdc, (LPCWSTR)pwszTest, i + 1, &size);
        dx[i] = size.cx - iOldExtent;
        iOldExtent = size.cx;
    }
    dx[StrLen - 1] = 0;

    ExtTextOutW(PDX_ARGS_W);

    {
    START_TIMER;
    while (ix--)
    {
        ExtTextOutW(PDX_ARGS_W);
    }
    END_TIMER;
    }
}

ULONGLONG
msPolyTextOutA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PolyTextOutA();
    }
    END_TIMER;
}

ULONGLONG
msPolyTextOutW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PolyTextOutW();
    }
    END_TIMER;
}

ULONGLONG
msFillPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //FillPath();
    }
    END_TIMER;
}

ULONGLONG
msFlattenPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //FlattenPath();
    }
    END_TIMER;
}

ULONGLONG
msGetArcDirection(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetArcDirection();
    }
    END_TIMER;
}

ULONGLONG
msGetBitmapBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetBitmapBits();
    }
    END_TIMER;
}

ULONGLONG
msGetCharWidthA(
    HDC hdc,
    ULONG Iter)
{
	UINT iFirstChar = FirstFontChar;
	UINT cwc = StrLen;
	UINT iLastChar  = iFirstChar + cwc - 1;

    INIT_TIMER;

//    if(WINNT_PLATFORM){
       INIT_IO_COUNT;
//    }

    if(WINNT_PLATFORM){
       START_IO_COUNT;
    }

    START_TIMER_NO_INIT;
    while (ix--)
    {
        GetCharWidthA(hdc, iFirstChar, iLastChar, Widths);//lpBuffer);
    }
    END_TIMER_NO_RETURN;

    if(WINNT_PLATFORM){
       STOP_IO_COUNT;
	}

    RETURN_STOP_TIME;

}

ULONGLONG
msGetCharWidthW(
    HDC hdc,
    ULONG Iter)
{
	UINT iFirstChar = FirstFontChar;
	UINT cwc = StrLen;
	UINT iLastChar  = iFirstChar + cwc - 1;
//	LINK_INFO *lip;
//	char szT[80];

    INIT_TIMER;

//    if(WINNT_PLATFORM){
       INIT_IO_COUNT;
//    }

    if(WINNT_PLATFORM){
       START_IO_COUNT;
    }

    START_TIMER_NO_INIT;
    while (ix--)
    {
        GetCharWidthW(hdc, iFirstChar, iLastChar, Widths);
    }
    END_TIMER_NO_RETURN;

    if(WINNT_PLATFORM){
       STOP_IO_COUNT;
	}

//    lip = Find_Caller(_ReturnAddress());
//	wsprintf(szT,"%16x,%16x,%6d",lip->callee_address,lip->caller_address,lip->caller_count);
//	MessageBox(NULL,szT,"LinkInfo",MB_OK);
    RETURN_STOP_TIME;

}


ULONGLONG
msGetCharWidth32A(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetCharWidth32A();
    }
    END_TIMER;
}

ULONGLONG
msGetCharWidth32W(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetCharWidth32W();
    }
    END_TIMER;
}

ULONGLONG
msGetCharWidthFloatA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetCharWidthFloatA();
    }
    END_TIMER;
}

ULONGLONG
msGetCharWidthFloatW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetCharWidthFloatW();
    }
    END_TIMER;
}

ULONGLONG
msGetDIBColorTable(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetDIBColorTable();
    }
    END_TIMER;
}

ULONGLONG
msGetDIBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetDIBits();
    }
    END_TIMER;
}

ULONGLONG
msGetMetaFileBitsEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetMetaFileBitsEx();
    }
    END_TIMER;
}

ULONGLONG
msGetMiterLimit(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetMiterLimit();
    }
    END_TIMER;
}

ULONGLONG
msGetEnhMetaFileBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetEnhMetaFileBits();
    }
    END_TIMER;
}

ULONGLONG
msGetObjectA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetObjectA();
    }
    END_TIMER;
}

ULONGLONG
msGetObjectW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetObjectW();
    }
    END_TIMER;
}

ULONGLONG
msGetObjectType(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetObjectType();
    }
    END_TIMER;
}

ULONGLONG
msGetPaletteEntries(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetPaletteEntries();
    }
    END_TIMER;
}

ULONGLONG
msGetPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetPath();
    }
    END_TIMER;
}

ULONGLONG
msGetSystemPaletteEntries(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetSystemPaletteEntries();
    }
    END_TIMER;
}

ULONGLONG
msGetWinMetaFileBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetWinMetaFileBits();
    }
    END_TIMER;
}

ULONGLONG
msLPtoDP(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //LPtoDP();
    }
    END_TIMER;
}

ULONGLONG
msPathToRegion(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PathToRegion();
    }
    END_TIMER;
}

ULONGLONG
msPlayMetaFileRecord(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PlayMetaFileRecord();
    }
    END_TIMER;
}

ULONGLONG
msPlayEnhMetaFileRecord(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PlayEnhMetaFileRecord();
    }
    END_TIMER;
}

ULONGLONG
msPolyBezier(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PolyBezier();
    }
    END_TIMER;
}

ULONGLONG
msPolyBezierTo(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PolyBezierTo();
    }
    END_TIMER;
}

ULONGLONG
msPolyDraw(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PolyDraw();
    }
    END_TIMER;
}

ULONGLONG
msPolygon(
    HDC hdc,
    ULONG Iter)
{
	long x0 = 10;
	long y0 = 300;
    int nPoints = 6;

    POINT pt[200];

    INIT_TIMER;

// Create a Hexagon

    pt[0].x = x0;
	pt[0].y = y0;
	pt[1].x = x0 + 10;
	pt[1].y = y0 - 15;
	pt[2].x = x0 + 20;
	pt[2].y = pt[1].y;
	pt[3].x = x0 + 30;
	pt[3].y = y0;
	pt[4].x = x0 + 20;
	pt[4].y = y0 + 15;
	pt[5].x = x0 + 10;
	pt[5].y = pt[4].y;

    START_TIMER_NO_INIT;
    while (ix--)
    {
        Polygon(hdc,pt,nPoints);
    }
    END_TIMER;
}

ULONGLONG
msPolyline(
    HDC hdc,
    ULONG Iter)
{
    long i;
	long x0 = 10;
	long y0 = 300;
	long dx = 3;
	long dy = 5;
    int  nPoints = 100;
    long sign = 1;

    POINT pt[100];

    INIT_TIMER;

// Create a crazy segmented line

    for(i=0; i<nPoints; i++)
	{
         if((i+1)%20 == 0)sign = -sign;
	     pt[i].x = x0 + i*dx;
		 pt[i].y = y0 + (i%20)*dy*sign;
	}


    START_TIMER_NO_INIT;
     while (ix--)
    {
        Polyline(hdc,pt,nPoints);
    }
    END_TIMER;
}

ULONGLONG
msPolylineTo(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //PolylineTo();
    }
    END_TIMER;
}

ULONGLONG
msPolyPolygon(
    HDC hdc,
    ULONG Iter)
{

    long i,j;
	long x0 = 0;
	long y0 = 200;
	long dx = 30;
	long dy = 30;
    int nPoints[50];
    int nPolygons = 50;

    POINT pt[300];

    INIT_TIMER;

// Create a basic Hexagon (same as in Polygon)

    pt[0].x = x0;
	pt[0].y = y0;
	pt[1].x = x0 + 10;
	pt[1].y = y0 - 15;
	pt[2].x = x0 + 20;
	pt[2].y = pt[1].y;
	pt[3].x = x0 + 30;
	pt[3].y = y0;
	pt[4].x = x0 + 20;
	pt[4].y = y0 + 15;
	pt[5].x = x0 + 10;
	pt[5].y = pt[4].y;

// Create multiple hexagon shape based on the previous shape
// Changing dx and dy allow for overlapping if necessary

    for(i=0; i<nPolygons; i++)
	{

         nPoints[i] = 6;

         for(j=0; j<nPoints[i]; j++)
		 {

	         pt[6*i + j].x = pt[j].x + (i%10)*dx;
		     pt[6*i + j].y = pt[j].y + (i/10)*dy;

         }
	}


    START_TIMER_NO_INIT;

    while (ix--)
    {
        PolyPolygon(hdc,pt,nPoints,nPolygons);
    }
    END_TIMER;
}

ULONGLONG
msPolyPolyline(
    HDC hdc,
    ULONG Iter)
{

    long i,j;
	long x0 = 10;
	long y0 = 300;
	long dx = 3;
	long dy = 5;
    int  nPoints[50];
    int nLines = 50;
    long sign = 1;

    POINT pt[5000];               // 100 points * 50 polylines

    INIT_TIMER;

// Create same crazy line as in PolyLine

    for(j=0; j<100; j++)
	{
         if((j+1)%20 == 0)sign = -sign;
	     pt[j].x = x0 + j*dx;
		 pt[j].y = y0 + (j%20)*dy*sign;
	}

// Create PloyPolyLine = multiple PolyLines

    for(i=0; i<nLines; i++)
	{
         nPoints[i] = 100;

         for(j=0; j<100; j++)
		 {
             pt[100*i + j].x = pt[j].x;
		     pt[100*i + j].y = pt[j].y + i*dy;
         }
	}


    START_TIMER_NO_INIT;

    while (ix--)
    {
        PolyPolyline(hdc,pt,nPoints,nLines);
    }
    END_TIMER;
}

ULONGLONG
msResetDCA(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ResetDCA();
    }
    END_TIMER;
}

ULONGLONG
msResetDCW(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //ResetDCW();
    }
    END_TIMER;
}

ULONGLONG
msSelectClipPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SelectClipPath();
    }
    END_TIMER;
}

ULONGLONG
msSetAbortProc(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetAbortProc();
    }
    END_TIMER;
}

ULONGLONG
msSetBitmapBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetBitmapBits();
    }
    END_TIMER;
}

ULONGLONG
msSetDIBColorTable(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetDIBColorTable();
    }
    END_TIMER;
}

ULONGLONG
msSetDIBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetDIBits();
    }
    END_TIMER;
}

ULONGLONG
msSetDIBitsToDevice(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetDIBitsToDevice();
    }
    END_TIMER;
}

ULONGLONG
msSetMetaFileBitsEx(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetMetaFileBitsEx();
    }
    END_TIMER;
}

ULONGLONG
msSetEnhMetaFileBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetEnhMetaFileBits();
    }
    END_TIMER;
}

ULONGLONG
msSetMiterLimit(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetMiterLimit();
    }
    END_TIMER;
}

ULONGLONG
msSetPaletteEntries(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetPaletteEntries();
    }
    END_TIMER;
}

ULONGLONG
msSetWinMetaFileBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetWinMetaFileBits();
    }
    END_TIMER;
}

ULONGLONG
msStretchDIBits(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //StretchDIBits();
    }
    END_TIMER;
}

ULONGLONG
msStrokeAndFillPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //StrokeAndFillPath();
    }
    END_TIMER;
}

ULONGLONG
msStrokePath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //StrokePath();
    }
    END_TIMER;
}

ULONGLONG
msWidenPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //WidenPath();
    }
    END_TIMER;
}

ULONGLONG
msAbortPath(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //AbortPath();
    }
    END_TIMER;
}

ULONGLONG
msSetArcDirection(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetArcDirection();
    }
    END_TIMER;
}

ULONGLONG
msSetMetaRgn(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetMetaRgn();
    }
    END_TIMER;
}

ULONGLONG
msGetBoundsRect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //GetBoundsRect();
    }
    END_TIMER;
}

ULONGLONG
msSetBoundsRect(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        //SetBoundsRect();
    }
    END_TIMER;
}

ULONGLONG
msPatBlt88FxBr(
    HDC hdc,
    ULONG Iter)
{

    HBRUSH hbr = GetStockObject(BLACK_BRUSH);

    START_TIMER;

    SelectObject(hdc,hbr);

    while (ix--)
    {

        PatBlt(hdc,10,10,8,8,PATCOPY);

    }
    END_TIMER;
}

ULONGLONG
msPatBlt88SelBr(
    HDC hdc,
    ULONG Iter)
{

    HBRUSH hbr = GetStockObject(BLACK_BRUSH);

    START_TIMER;

    SelectObject(hdc,GetStockObject(WHITE_BRUSH));

    while (ix--)
    {
        SelectObject(hdc,hbr);

        PatBlt(hdc,10,10,8,8,PATCOPY);
    }
    END_TIMER;
}

ULONGLONG
msPatBlt88SelBr2(
    HDC hdc,
    ULONG Iter)
{

    HBRUSH hbr = GetStockObject(BLACK_BRUSH);

    START_TIMER;

    SelectObject(hdc,GetStockObject(WHITE_BRUSH));

    while (ix--)
    {
        hbr = SelectObject(hdc,hbr);

        PatBlt(hdc,10,10,8,8,PATCOPY);
    }
    END_TIMER;
}

ULONGLONG
msPatBlt88SelBr3(
    HDC hdc,
    ULONG Iter)
{

    ULONG ulRGB = 304030;
    HBRUSH hbr = GetStockObject(BLACK_BRUSH);

    START_TIMER;

    SelectObject(hdc,GetStockObject(WHITE_BRUSH));

    while (ix--)
    {
        hbr = CreateSolidBrush(ulRGB);

        hbr = SelectObject(hdc,hbr);

        PatBlt(hdc,10,10,8,8,PATCOPY);

        hbr = SelectObject(hdc,hbr);

        DeleteObject(hbr);
        ulRGB ^= 0xffffff;
    }
    END_TIMER;
}

ULONGLONG
msPatBlt88FxBrSelClipCopy(
    HDC hdc,
    ULONG Iter)
{

    HBRUSH hbr = GetStockObject(BLACK_BRUSH);
    HRGN   hrgn1 = CreateRectRgn(11,11,32,32);

    START_TIMER;

    SelectObject(hdc,hbr);

    while (ix--)
    {
        ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);

        PatBlt(hdc,10,10,8,8,PATCOPY);
    }
	END_TIMER_NO_RETURN;

    ExtSelectClipRgn(hdc,NULL,RGN_COPY);
    DeleteObject(hrgn1);

    RETURN_STOP_TIME;
}

ULONGLONG
msPatBlt88FxBrSelClipAnd(
    HDC hdc,
    ULONG Iter)
{

    HBRUSH hbr = GetStockObject(BLACK_BRUSH);
    HRGN   hrgn1 = CreateRectRgn(11,11,32,32);
    HRGN   hrgn2 = CreateRectRgn(12,12,17,17);

    START_TIMER;

    SelectObject(hdc,hbr);

    while (ix--)
    {
        ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);
        ExtSelectClipRgn(hdc,hrgn2,RGN_AND);

        PatBlt(hdc,10,10,8,8,PATCOPY);

    }
	END_TIMER_NO_RETURN;

    ExtSelectClipRgn(hdc,NULL,RGN_COPY);
    DeleteObject(hrgn1);

    RETURN_STOP_TIME;
}

#if 0
ULONGLONG
msKMTransition(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ExtEscape(hdc,ESCNOOP,0,NULL,0,NULL);
    }
    END_TIMER;
}

ULONGLONG
msKMTransitionLock(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ExtEscape(hdc,ESCLOCK,0,NULL,0,NULL);
    }
    END_TIMER;
}

ULONGLONG
msResourceLock(
    HDC hdc,
    ULONG Iter)
{
    START_TIMER;
    while (ix--)
    {
        ExtEscape(hdc,ESCHMGRLOCK,0,NULL,0,NULL);
    }
    END_TIMER;
}
#endif

ULONGLONG
msGetPrinterDeviceIC(
    HDC hdc,
    ULONG Iter)
{
    char szT[80];
    int    i,flag,resH,resV;
    DWORD  error;
    HDC    prDC,ScrDC;
    char   szPrinter [64] ;
    char   *szDevice, *szDriver, *szOutput ;
    LONG   devmodesize,flagL;
    HANDLE phPrinter;
    void*  devmodebuff;
    LPDEVMODE prdevmode;
	HWND hWnd;

    INIT_TIMER;
//    if(WINNT_PLATFORM){
       INIT_IO_COUNT;
//	}
//    _int64 StartO,EndO,StartC,EndC,StartH,EndH,
//            StartV,EndV,StartD1,EndD1,StartD2,EndD2,StartD3,EndD3;

	hWnd = GetActiveWindow();
    GetProfileString ("windows", "device", "", szPrinter, 64) ;
    if ((szDevice = strtok (szPrinter, "," )) &&
        (szDriver = strtok (NULL,      ", ")) &&
        (szOutput = strtok (NULL,      ", ")))
    {

       START_CPU_DUMP;
       if(WINNT_PLATFORM){
          START_IO_COUNT;
	   }
       START_TIMER_NO_INIT;
       while (ix--)
       {
           OpenPrinter(szDevice,(LPHANDLE) &phPrinter,NULL);
           devmodesize = DocumentProperties(hWnd,phPrinter,szDevice,
                                     (PDEVMODE) NULL ,NULL,0);
           if (devmodesize < 0) {
               wsprintf(szT,"DocumentProperties returns %ld for DEVMODE size\n",devmodesize);
			   MessageBox(NULL,szT,"DeviceIC Test - DEVMODE ERROR",MB_APPLMODAL|MB_OK|MB_ICONSTOP);
               return 0L;
           }

           devmodebuff = (void *) malloc((size_t) devmodesize);

           flagL = DocumentProperties(hWnd,phPrinter,szDevice,
                               (PDEVMODE) devmodebuff,NULL,DM_OUT_BUFFER);

           prdevmode = (LPDEVMODE) devmodebuff;

           if (flagL < 0L) {
               wsprintf(szT,"DocumentProperties returns %s when asked to fill\n","NOK");
			   MessageBox(NULL,szT,"DeviceIC Test - Printer Return Value ERROR1",MB_APPLMODAL|MB_OK|MB_ICONSTOP);
			   return 0L;
//             fprintf(log,"Printer configured for %d Copies\n",prdevmode->dmCopies);
           }

           prdevmode->dmCopies = 9;
           prdevmode->dmFields = DM_COPIES;

           flagL = DocumentProperties(hWnd,phPrinter,
                          szDevice,(PDEVMODE) devmodebuff,
                                   (PDEVMODE) devmodebuff,
                                   DM_IN_BUFFER | DM_OUT_BUFFER);

           if (flagL < 0L) {
               wsprintf(szT,"DocumentProperties returns %s when asked to modify\n", "NOK");
			   MessageBox(NULL,szT,"DeviceIC Test - Printer Return Value ERROR2",MB_APPLMODAL|MB_OK|MB_ICONSTOP);
			   return 0L;
//             fprintf(log,"Printer reconfigured for %d copies\n", prdevmode->dmCopies);
           }

           prDC = CreateIC((LPCTSTR)   "winspool",
                        (LPCTSTR)   szDevice,
                        (LPCTSTR)   NULL,
                        (LPDEVMODE) prdevmode);

           resH = 0;
           resV = 0;
           if (prDC!=NULL) {
              resH = GetDeviceCaps(prDC,HORZRES);
              resV = GetDeviceCaps(prDC,VERTRES);
	       }

       }                             // end while

       END_TIMER_NO_RETURN;
       if(WINNT_PLATFORM){
	      STOP_IO_COUNT;
	   }
       STOP_CPU_DUMP;
	   RETURN_STOP_TIME;

   }                                // end if
   else
   {
       wsprintf(szT,"Apparently No Printer Configured");
	   MessageBox(NULL,szT,"DeviceIC Test - NO PRINTER CONFIGURED ERROR",MB_APPLMODAL|MB_OK|MB_ICONSTOP);
       return 0L;
   }

}

#define TEST_DEFAULT 300

TEST_ENTRY  gTestEntry[] = {
    (PUCHAR)"PatBlt88FxBr             ",(PFN_MS)msPatBlt88FxBr              ,TEST_DEFAULT,0,
    (PUCHAR)"PatBlt88SelBr            ",(PFN_MS)msPatBlt88SelBr             ,TEST_DEFAULT,0,
    (PUCHAR)"PatBlt88SelBr2           ",(PFN_MS)msPatBlt88SelBr2            ,TEST_DEFAULT,0,
    (PUCHAR)"PatBlt88CreSelDelBr      ",(PFN_MS)msPatBlt88SelBr3            ,TEST_DEFAULT,0,
    (PUCHAR)"PatBlt88FxBrSelClipCopy  ",(PFN_MS)msPatBlt88FxBrSelClipCopy   ,TEST_DEFAULT,0,
    (PUCHAR)"PatBlt88FxBrSelClipAnd   ",(PFN_MS)msPatBlt88FxBrSelClipAnd    ,TEST_DEFAULT,0,
#if 0
    (PUCHAR)"km transition            ",(PFN_MS)msKMTransition              ,TEST_DEFAULT,0,
    (PUCHAR)"km transition + HmgLock  ",(PFN_MS)msKMTransitionLock          ,TEST_DEFAULT,0,
    (PUCHAR)"ResourceLock             ",(PFN_MS)msResourceLock              ,TEST_DEFAULT,0,
#endif
    (PUCHAR)"TextOutA                 ",(PFN_MS)msTextOutA                  ,TEST_DEFAULT,0,
    (PUCHAR)"TextOutW                 ",(PFN_MS)msTextOutW                  ,TEST_DEFAULT,0,
    (PUCHAR)"ExtTextOutA pdx          ",(PFN_MS)msExtTextOutApdx            ,TEST_DEFAULT,0,
    (PUCHAR)"ExtTextOutW pdx          ",(PFN_MS)msExtTextOutWpdx            ,TEST_DEFAULT,0,
    (PUCHAR)"ExtTextOutA              ",(PFN_MS)msExtTextOutA               ,TEST_DEFAULT,0,
    (PUCHAR)"ExtTextOutW              ",(PFN_MS)msExtTextOutW               ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextExtentPointA      ",(PFN_MS)msGetTextExtentPointA       ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextExtentPointW      ",(PFN_MS)msGetTextExtentPointW       ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextExtentPoint32A    ",(PFN_MS)msGetTextExtentPoint32A     ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextExtentPoint32W    ",(PFN_MS)msGetTextExtentPoint32W     ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextExtentExPointA    ",(PFN_MS)msGetTextExtentExPointA     ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextExtentExPointW    ",(PFN_MS)msGetTextExtentExPointW     ,TEST_DEFAULT,0,
    (PUCHAR)"SetTextColor             ",(PFN_MS)msSetTextColor              ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextAlign             ",(PFN_MS)msGetTextAlign              ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextCharacterExtra    ",(PFN_MS)msGetTextCharacterExtra     ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextColor             ",(PFN_MS)msGetTextColor              ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextFaceA             ",(PFN_MS)msGetTextFaceA              ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextFaceW             ",(PFN_MS)msGetTextFaceW              ,TEST_DEFAULT,0,
    (PUCHAR)"GetTextMetricsA          ",(PFN_MS)msGetTextMetricsA           ,1,0,
    (PUCHAR)"GetTextMetricsW          ",(PFN_MS)msGetTextMetricsW           ,1,0,
//    (PUCHAR)"SelectObject             ",(PFN_MS)msSelectObject              ,TEST_DEFAULT,0,
    (PUCHAR)"SetBkColor               ",(PFN_MS)msSetBkColor                ,TEST_DEFAULT,0,
    (PUCHAR)"BitBlt                   ",(PFN_MS)msBitBlt                    ,TEST_DEFAULT,0,
    (PUCHAR)"StretchBlt               ",(PFN_MS)msStretchBlt                ,TEST_DEFAULT,0,
    (PUCHAR)"PatBlt                   ",(PFN_MS)msPatBlt                    ,TEST_DEFAULT,0,
    (PUCHAR)"MaskBlt                  ",(PFN_MS)msMaskBlt                   ,TEST_DEFAULT,0,
    (PUCHAR)"GetBkColor               ",(PFN_MS)msGetBkColor                ,TEST_DEFAULT,0,
    (PUCHAR)"GetBkMode                ",(PFN_MS)msGetBkMode                 ,TEST_DEFAULT,0,
    (PUCHAR)"GetBrushOrgEx            ",(PFN_MS)msGetBrushOrgEx             ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharABCWidthsA        ",(PFN_MS)msGetCharABCWidthsA         ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharABCWidthsW        ",(PFN_MS)msGetCharABCWidthsW         ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharABCWidthsFloatA   ",(PFN_MS)msGetCharABCWidthsFloatA    ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharABCWidthsFloatW   ",(PFN_MS)msGetCharABCWidthsFloatW    ,TEST_DEFAULT,0,
    (PUCHAR)"GetClipBox               ",(PFN_MS)msGetClipBox                ,TEST_DEFAULT,0,
    (PUCHAR)"GetClipRgn               ",(PFN_MS)msGetClipRgn                ,TEST_DEFAULT,0,
    (PUCHAR)"GetColorAdjustment       ",(PFN_MS)msGetColorAdjustment        ,TEST_DEFAULT,0,
    (PUCHAR)"GetCurrentObject         ",(PFN_MS)msGetCurrentObject          ,TEST_DEFAULT,0,
    (PUCHAR)"GetCurrentPositionEx     ",(PFN_MS)msGetCurrentPositionEx      ,TEST_DEFAULT,0,
    (PUCHAR)"GetDeviceCaps            ",(PFN_MS)msGetDeviceCaps             ,TEST_DEFAULT,0,
//    (PUCHAR)"GetFontResourceInfo      ",(PFN_MS)msGetFontResourceInfo       ,TEST_DEFAULT,0,
//    (PUCHAR)"GetFontResourceInfoW     ",(PFN_MS)msGetFontResourceInfoW      ,TEST_DEFAULT,0,
    (PUCHAR)"GetGraphicsMode          ",(PFN_MS)msGetGraphicsMode           ,TEST_DEFAULT,0,
    (PUCHAR)"GetMapMode               ",(PFN_MS)msGetMapMode                ,TEST_DEFAULT,0,
    (PUCHAR)"GetFontData              ",(PFN_MS)msGetFontData               ,TEST_DEFAULT,0,
    (PUCHAR)"GetGlyphOutlineA         ",(PFN_MS)msGetGlyphOutlineA          ,TEST_DEFAULT,0,
    (PUCHAR)"GetGlyphOutlineW         ",(PFN_MS)msGetGlyphOutlineW          ,TEST_DEFAULT,0,
    (PUCHAR)"GetKerningPairsA         ",(PFN_MS)msGetKerningPairsA          ,TEST_DEFAULT,0,
    (PUCHAR)"GetKerningPairsW         ",(PFN_MS)msGetKerningPairsW          ,TEST_DEFAULT,0,
    (PUCHAR)"GetNearestColor          ",(PFN_MS)msGetNearestColor           ,TEST_DEFAULT,0,
    (PUCHAR)"GetNearestPaletteIndex   ",(PFN_MS)msGetNearestPaletteIndex    ,TEST_DEFAULT,0,
    (PUCHAR)"GetOutlineTextMetricsA   ",(PFN_MS)msGetOutlineTextMetricsA    ,TEST_DEFAULT,0,
    (PUCHAR)"GetOutlineTextMetricsW   ",(PFN_MS)msGetOutlineTextMetricsW    ,TEST_DEFAULT,0,
    (PUCHAR)"GetPixel                 ",(PFN_MS)msGetPixel                  ,TEST_DEFAULT,0,
//    (PUCHAR)"GetPixelFormat           ",(PFN_MS)msGetPixelFormat            ,TEST_DEFAULT,0,
    (PUCHAR)"GetPolyFillMode          ",(PFN_MS)msGetPolyFillMode           ,TEST_DEFAULT,0,
    (PUCHAR)"GetRasterizerCaps        ",(PFN_MS)msGetRasterizerCaps         ,TEST_DEFAULT,0,
    (PUCHAR)"GetRegionData            ",(PFN_MS)msGetRegionData             ,TEST_DEFAULT,0,
    (PUCHAR)"GetRgnBox                ",(PFN_MS)msGetRgnBox                 ,TEST_DEFAULT,0,
    (PUCHAR)"GetROP2                  ",(PFN_MS)msGetROP2                   ,TEST_DEFAULT,0,
    (PUCHAR)"GetStockObject           ",(PFN_MS)msGetStockObject            ,TEST_DEFAULT,0,
    (PUCHAR)"GetStretchBltMode        ",(PFN_MS)msGetStretchBltMode         ,TEST_DEFAULT,0,
    (PUCHAR)"GetSystemPaletteUse      ",(PFN_MS)msGetSystemPaletteUse       ,TEST_DEFAULT,0,
//    (PUCHAR)"GetViewportExtEx         ",(PFN_MS)msGetViewportExtEx          ,TEST_DEFAULT,0,
    (PUCHAR)"GetViewportOrgEx         ",(PFN_MS)msGetViewportOrgEx          ,TEST_DEFAULT,0,
    (PUCHAR)"GetWindowExtEx           ",(PFN_MS)msGetWindowExtEx            ,TEST_DEFAULT,0,
    (PUCHAR)"GetWindowOrgEx           ",(PFN_MS)msGetWindowOrgEx            ,TEST_DEFAULT,0,
    (PUCHAR)"GetWorldTransform        ",(PFN_MS)msGetWorldTransform         ,TEST_DEFAULT,0,
    (PUCHAR)"SetBitmapDimensionEx     ",(PFN_MS)msSetBitmapDimensionEx      ,TEST_DEFAULT,0,
    (PUCHAR)"SetBkMode                ",(PFN_MS)msSetBkMode                 ,TEST_DEFAULT,0,
    (PUCHAR)"SetBrushOrgEx            ",(PFN_MS)msSetBrushOrgEx             ,TEST_DEFAULT,0,
    (PUCHAR)"SetColorAdjustment       ",(PFN_MS)msSetColorAdjustment        ,TEST_DEFAULT,0,
    (PUCHAR)"SetGraphicsMode          ",(PFN_MS)msSetGraphicsMode           ,TEST_DEFAULT,0,
    (PUCHAR)"SetMapMode               ",(PFN_MS)msSetMapMode                ,TEST_DEFAULT,0,
    (PUCHAR)"SetMapperFlags           ",(PFN_MS)msSetMapperFlags            ,TEST_DEFAULT,0,
    (PUCHAR)"SetPixel                 ",(PFN_MS)msSetPixel                  ,TEST_DEFAULT,0,
    (PUCHAR)"SetPixelV                ",(PFN_MS)msSetPixelV                 ,TEST_DEFAULT,0,
    (PUCHAR)"SetPolyFillMode          ",(PFN_MS)msSetPolyFillMode           ,TEST_DEFAULT,0,
    (PUCHAR)"SetRectRgn               ",(PFN_MS)msSetRectRgn                ,TEST_DEFAULT,0,
    (PUCHAR)"SetROP2                  ",(PFN_MS)msSetROP2                   ,TEST_DEFAULT,0,
    (PUCHAR)"SetStretchBltMode        ",(PFN_MS)msSetStretchBltMode         ,TEST_DEFAULT,0,
//    (PUCHAR)"SetSystemPaletteUse      ",(PFN_MS)msSetSystemPaletteUse       ,TEST_DEFAULT,0,
    (PUCHAR)"SetTextAlign             ",(PFN_MS)msSetTextAlign              ,TEST_DEFAULT,0,
    (PUCHAR)"SetTextCharacterExtra    ",(PFN_MS)msSetTextCharacterExtra     ,TEST_DEFAULT,0,
    (PUCHAR)"SetTextJustification     ",(PFN_MS)msSetTextJustification      ,TEST_DEFAULT,0,
    (PUCHAR)"SetViewportExtEx         ",(PFN_MS)msSetViewportExtEx          ,TEST_DEFAULT,0,
    (PUCHAR)"SetViewportOrgEx         ",(PFN_MS)msSetViewportOrgEx          ,TEST_DEFAULT,0,
    (PUCHAR)"SetWindowExtEx           ",(PFN_MS)msSetWindowExtEx            ,TEST_DEFAULT,0,
    (PUCHAR)"SetWindowOrgEx           ",(PFN_MS)msSetWindowOrgEx            ,TEST_DEFAULT,0,
    (PUCHAR)"SetWorldTransform        ",(PFN_MS)msSetWorldTransform         ,TEST_DEFAULT,0,
    (PUCHAR)"AngleArc                 ",(PFN_MS)msAngleArc                  ,TEST_DEFAULT,0,
    (PUCHAR)"Arc                      ",(PFN_MS)msArc                       ,TEST_DEFAULT,0,
    (PUCHAR)"CancelDC                 ",(PFN_MS)msCancelDC                  ,TEST_DEFAULT,0,
    (PUCHAR)"Chord                    ",(PFN_MS)msChord                     ,TEST_DEFAULT,0,
    (PUCHAR)"CombineRgn               ",(PFN_MS)msCombineRgn                ,TEST_DEFAULT,0,
    (PUCHAR)"CombineTransform         ",(PFN_MS)msCombineTransform          ,TEST_DEFAULT,0,
    (PUCHAR)"CreateCompatibleBitmap   ",(PFN_MS)msCreateCompatibleBitmap    ,TEST_DEFAULT,0,
    (PUCHAR)"CreateCompatibleDC       ",(PFN_MS)msCreateCompatibleDC        ,TEST_DEFAULT,0,
    (PUCHAR)"CreateDiscardableBitmap  ",(PFN_MS)msCreateDiscardableBitmap   ,TEST_DEFAULT,0,
    (PUCHAR)"CreateEllipticRgn        ",(PFN_MS)msCreateEllipticRgn         ,TEST_DEFAULT,0,
    (PUCHAR)"CreateEllipticRgnIndirect",(PFN_MS)msCreateEllipticRgnIndirect ,TEST_DEFAULT,0,
    (PUCHAR)"CreateFontA              ",(PFN_MS)msCreateFontA               ,TEST_DEFAULT,0,
    (PUCHAR)"CreateFontW              ",(PFN_MS)msCreateFontW               ,TEST_DEFAULT,0,
    (PUCHAR)"CreateFontIndirectA      ",(PFN_MS)msCreateFontIndirectA       ,TEST_DEFAULT,0,
    (PUCHAR)"CreateFontIndirectW      ",(PFN_MS)msCreateFontIndirectW       ,TEST_DEFAULT,0,
    (PUCHAR)"CreateHatchBrush         ",(PFN_MS)msCreateHatchBrush          ,TEST_DEFAULT,0,
    (PUCHAR)"CreateDCA                ",(PFN_MS)msCreateDCA                 ,TEST_DEFAULT,0,
    (PUCHAR)"Polyline 100 Pts.        ",(PFN_MS)msPolyline                  ,TEST_DEFAULT/3,0,
    (PUCHAR)"Polygon 6 Pts.           ",(PFN_MS)msPolygon                   ,TEST_DEFAULT,0,
    (PUCHAR)"PolyPolygon 50Poly*6Pts. ",(PFN_MS)msPolyPolygon               ,TEST_DEFAULT/3,0,
    (PUCHAR)"PolyPolyline 50*100Pts.  ",(PFN_MS)msPolyPolyline              ,TEST_DEFAULT/6,0,
    (PUCHAR)"GetCharWidthA            ",(PFN_MS)msGetCharWidthA             ,1,0,
    (PUCHAR)"GetCharWidthW            ",(PFN_MS)msGetCharWidthW             ,1,0,
    (PUCHAR)"Get Printer DeviceIC Test",(PFN_MS)msGetPrinterDeviceIC        ,1,0,
};
/*

    (PUCHAR)"CreateDCW                ",(PFN_MS)msCreateDCW                 ,TEST_DEFAULT,0,
    (PUCHAR)"CreateICA                ",(PFN_MS)msCreateICA                 ,TEST_DEFAULT,0,
    (PUCHAR)"CreateICW                ",(PFN_MS)msCreateICW                 ,TEST_DEFAULT,0,
    (PUCHAR)"DeleteDC                 ",(PFN_MS)msDeleteDC                  ,TEST_DEFAULT,0,

    (PUCHAR)"DeleteObject             ",(PFN_MS)msDeleteObject              ,TEST_DEFAULT,0,
    (PUCHAR)"CreatePatternBrush       ",(PFN_MS)msCreatePatternBrush        ,TEST_DEFAULT,0,
    (PUCHAR)"CreatePen                ",(PFN_MS)msCreatePen                 ,TEST_DEFAULT,0,
    (PUCHAR)"FrameRgn                 ",(PFN_MS)msFrameRgn                  ,TEST_DEFAULT,0,
    (PUCHAR)"FillRgn                  ",(PFN_MS)msFillRgn                   ,TEST_DEFAULT,0,
    (PUCHAR)"MoveToEx                 ",(PFN_MS)msMoveToEx                  ,TEST_DEFAULT,0,
    (PUCHAR)"LineTo                   ",(PFN_MS)msLineTo                    ,TEST_DEFAULT,0,
    (PUCHAR)"ExtCreatePen             ",(PFN_MS)msExtCreatePen              ,TEST_DEFAULT,0,
    (PUCHAR)"ExtCreateRegion          ",(PFN_MS)msExtCreateRegion           ,TEST_DEFAULT,0,

    (PUCHAR)"ExtSelectClipRgn",(PFN_MS)msExtSelectClipRgn               ,TEST_DEFAULT,0,
    (PUCHAR)"CreatePenIndirect",(PFN_MS)msCreatePenIndirect             ,TEST_DEFAULT,0,
    (PUCHAR)"CreateRectRgn",(PFN_MS)msCreateRectRgn                     ,TEST_DEFAULT,0,
    (PUCHAR)"CreateRectRgnIndirect",(PFN_MS)msCreateRectRgnIndirect     ,TEST_DEFAULT,0,
    (PUCHAR)"CreateRoundRectRgn",(PFN_MS)msCreateRoundRectRgn           ,TEST_DEFAULT,0,
    (PUCHAR)"CreateScalableFontResourceA",(PFN_MS)msCreateScalableFontResourceA ,TEST_DEFAULT,0,
    (PUCHAR)"CreateScalableFontResourceW",(PFN_MS)msCreateScalableFontResourceW ,TEST_DEFAULT,0,
    (PUCHAR)"CreateSolidBrush",(PFN_MS)msCreateSolidBrush               ,TEST_DEFAULT,0,
    (PUCHAR)"DeleteMetaFile",(PFN_MS)msDeleteMetaFile                   ,TEST_DEFAULT,0,
    (PUCHAR)"GetBitmapDimensionEx",(PFN_MS)msGetBitmapDimensionEx       ,TEST_DEFAULT,0,
    (PUCHAR)"IntersectClipRect",(PFN_MS)msIntersectClipRect             ,TEST_DEFAULT,0,
    (PUCHAR)"InvertRgn",(PFN_MS)msInvertRgn                             ,TEST_DEFAULT,0,
    (PUCHAR)"LineDDA",(PFN_MS)msLineDDA                                 ,TEST_DEFAULT,0,
    (PUCHAR)"ModifyWorldTransform",(PFN_MS)msModifyWorldTransform       ,TEST_DEFAULT,0,
    (PUCHAR)"OffsetClipRgn",(PFN_MS)msOffsetClipRgn                     ,TEST_DEFAULT,0,
    (PUCHAR)"OffsetRgn",(PFN_MS)msOffsetRgn                             ,TEST_DEFAULT,0,
    (PUCHAR)"OffsetViewportOrgEx",(PFN_MS)msOffsetViewportOrgEx         ,TEST_DEFAULT,0,
    (PUCHAR)"OffsetWindowOrgEx",(PFN_MS)msOffsetWindowOrgEx             ,TEST_DEFAULT,0,
    (PUCHAR)"DeleteEnhMetaFile",(PFN_MS)msDeleteEnhMetaFile             ,TEST_DEFAULT,0,
    (PUCHAR)"DescribePixelFormat",(PFN_MS)msDescribePixelFormat         ,TEST_DEFAULT,0,
    (PUCHAR)"DeviceCapabilitiesExA",(PFN_MS)msDeviceCapabilitiesExA     ,TEST_DEFAULT,0,
    (PUCHAR)"DeviceCapabilitiesExW",(PFN_MS)msDeviceCapabilitiesExW     ,TEST_DEFAULT,0,
    (PUCHAR)"DrawEscape",(PFN_MS)msDrawEscape                           ,TEST_DEFAULT,0,
    (PUCHAR)"EndDoc",(PFN_MS)msEndDoc                                   ,TEST_DEFAULT,0,
    (PUCHAR)"EndPage",(PFN_MS)msEndPage                                 ,TEST_DEFAULT,0,
    (PUCHAR)"EnumFontFamiliesA",(PFN_MS)msEnumFontFamiliesA             ,TEST_DEFAULT,0,
    (PUCHAR)"EnumFontFamiliesW",(PFN_MS)msEnumFontFamiliesW             ,TEST_DEFAULT,0,
    (PUCHAR)"EnumFontsA",(PFN_MS)msEnumFontsA                           ,TEST_DEFAULT,0,
    (PUCHAR)"EnumFontsW",(PFN_MS)msEnumFontsW                           ,TEST_DEFAULT,0,
    (PUCHAR)"EnumObjects",(PFN_MS)msEnumObjects                         ,TEST_DEFAULT,0,
    (PUCHAR)"Ellipse",(PFN_MS)msEllipse                                 ,TEST_DEFAULT,0,
    (PUCHAR)"EqualRgn",(PFN_MS)msEqualRgn                               ,TEST_DEFAULT,0,
    (PUCHAR)"Escape",(PFN_MS)msEscape                                   ,TEST_DEFAULT,0,
    (PUCHAR)"ExtEscape",(PFN_MS)msExtEscape                             ,TEST_DEFAULT,0,
    (PUCHAR)"ExcludeClipRect",(PFN_MS)msExcludeClipRect                 ,TEST_DEFAULT,0,
    (PUCHAR)"ExtFloodFill",(PFN_MS)msExtFloodFill                       ,TEST_DEFAULT,0,
    (PUCHAR)"FloodFill",(PFN_MS)msFloodFill                             ,TEST_DEFAULT,0,
    (PUCHAR)"GdiComment",(PFN_MS)msGdiComment                           ,TEST_DEFAULT,0,
    (PUCHAR)"GdiPlayScript",(PFN_MS)msGdiPlayScript                     ,TEST_DEFAULT,0,
    (PUCHAR)"GdiPlayDCScript",(PFN_MS)msGdiPlayDCScript                 ,TEST_DEFAULT,0,
    (PUCHAR)"GdiPlayJournal",(PFN_MS)msGdiPlayJournal                   ,TEST_DEFAULT,0,
    (PUCHAR)"GetAspectRatioFilterEx",(PFN_MS)msGetAspectRatioFilterEx   ,TEST_DEFAULT,0,
    (PUCHAR)"PaintRgn",(PFN_MS)msPaintRgn                               ,TEST_DEFAULT,0,
    (PUCHAR)"Pie",(PFN_MS)msPie                                         ,TEST_DEFAULT,0,
    (PUCHAR)"PlayMetaFile",(PFN_MS)msPlayMetaFile                       ,TEST_DEFAULT,0,
    (PUCHAR)"PlayEnhMetaFile",(PFN_MS)msPlayEnhMetaFile                 ,TEST_DEFAULT,0,
    (PUCHAR)"PlgBlt",(PFN_MS)msPlgBlt                                   ,TEST_DEFAULT,0,
    (PUCHAR)"PtInRegion",(PFN_MS)msPtInRegion                           ,TEST_DEFAULT,0,
    (PUCHAR)"PtVisible",(PFN_MS)msPtVisible                             ,TEST_DEFAULT,0,
    (PUCHAR)"RealizePalette",(PFN_MS)msRealizePalette                   ,TEST_DEFAULT,0,
    (PUCHAR)"Rectangle",(PFN_MS)msRectangle                             ,TEST_DEFAULT,0,
    (PUCHAR)"RectInRegion",(PFN_MS)msRectInRegion                       ,TEST_DEFAULT,0,
    (PUCHAR)"RectVisible",(PFN_MS)msRectVisible                         ,TEST_DEFAULT,0,
    (PUCHAR)"RemoveFontResourceA",(PFN_MS)msRemoveFontResourceA         ,TEST_DEFAULT,0,
    (PUCHAR)"RemoveFontResourceW",(PFN_MS)msRemoveFontResourceW         ,TEST_DEFAULT,0,
    (PUCHAR)"ResizePalette",(PFN_MS)msResizePalette                     ,TEST_DEFAULT,0,
    (PUCHAR)"RestoreDC",(PFN_MS)msRestoreDC                             ,TEST_DEFAULT,0,
    (PUCHAR)"RoundRect",(PFN_MS)msRoundRect                             ,TEST_DEFAULT,0,
    (PUCHAR)"SaveDC",(PFN_MS)msSaveDC                                   ,TEST_DEFAULT,0,
    (PUCHAR)"ScaleViewportExtEx",(PFN_MS)msScaleViewportExtEx           ,TEST_DEFAULT,0,
    (PUCHAR)"ScaleWindowExtEx",(PFN_MS)msScaleWindowExtEx               ,TEST_DEFAULT,0,
    (PUCHAR)"SelectClipRgn",(PFN_MS)msSelectClipRgn                     ,TEST_DEFAULT,0,
    (PUCHAR)"SelectBrushLocal",(PFN_MS)msSelectBrushLocal               ,TEST_DEFAULT,0,
    (PUCHAR)"SelectFontLocal",(PFN_MS)msSelectFontLocal                 ,TEST_DEFAULT,0,
    (PUCHAR)"SelectPalette",(PFN_MS)msSelectPalette                     ,TEST_DEFAULT,0,
    (PUCHAR)"StartDocA",(PFN_MS)msStartDocA                             ,TEST_DEFAULT,0,
    (PUCHAR)"StartDocW",(PFN_MS)msStartDocW                             ,TEST_DEFAULT,0,
    (PUCHAR)"StartPage",(PFN_MS)msStartPage                             ,TEST_DEFAULT,0,
    (PUCHAR)"SwapBuffers",(PFN_MS)msSwapBuffers                         ,TEST_DEFAULT,0,
    (PUCHAR)"UpdateColors",(PFN_MS)msUpdateColors                       ,TEST_DEFAULT,0,
    (PUCHAR)"UnrealizeObject",(PFN_MS)msUnrealizeObject                 ,TEST_DEFAULT,0,
    (PUCHAR)"FixBrushOrgEx",(PFN_MS)msFixBrushOrgEx                     ,TEST_DEFAULT,0,
    (PUCHAR)"GetDCOrgEx",(PFN_MS)msGetDCOrgEx                           ,TEST_DEFAULT,0,
    (PUCHAR)"AnimatePalette",(PFN_MS)msAnimatePalette                   ,TEST_DEFAULT,0,
    (PUCHAR)"ArcTo",(PFN_MS)msArcTo                                     ,TEST_DEFAULT,0,
    (PUCHAR)"BeginPath",(PFN_MS)msBeginPath                             ,TEST_DEFAULT,0,
    (PUCHAR)"CloseFigure",(PFN_MS)msCloseFigure                         ,TEST_DEFAULT,0,
    (PUCHAR)"CreateBitmap",(PFN_MS)msCreateBitmap                       ,TEST_DEFAULT,0,
    (PUCHAR)"CreateBitmapIndirect",(PFN_MS)msCreateBitmapIndirect       ,TEST_DEFAULT,0,
    (PUCHAR)"CreateBrushIndirect",(PFN_MS)msCreateBrushIndirect         ,TEST_DEFAULT,0,
    (PUCHAR)"CreateDIBitmap",(PFN_MS)msCreateDIBitmap                   ,TEST_DEFAULT,0,
    (PUCHAR)"CreateDIBPatternBrush",(PFN_MS)msCreateDIBPatternBrush     ,TEST_DEFAULT,0,
    (PUCHAR)"CreateDIBPatternBrushPt",(PFN_MS)msCreateDIBPatternBrushPt ,TEST_DEFAULT,0,
    (PUCHAR)"CreateDIBSection",(PFN_MS)msCreateDIBSection               ,TEST_DEFAULT,0,
    (PUCHAR)"CreateHalftonePalette",(PFN_MS)msCreateHalftonePalette     ,TEST_DEFAULT,0,
    (PUCHAR)"CreatePalette",(PFN_MS)msCreatePalette                     ,TEST_DEFAULT,0,
    (PUCHAR)"CreatePolygonRgn",(PFN_MS)msCreatePolygonRgn               ,TEST_DEFAULT,0,
    (PUCHAR)"CreatePolyPolygonRgn",(PFN_MS)msCreatePolyPolygonRgn       ,TEST_DEFAULT,0,
    (PUCHAR)"DPtoLP",(PFN_MS)msDPtoLP                                   ,TEST_DEFAULT,0,
    (PUCHAR)"EndPath",(PFN_MS)msEndPath                                 ,TEST_DEFAULT,0,
    (PUCHAR)"EnumMetaFile",(PFN_MS)msEnumMetaFile                       ,TEST_DEFAULT,0,
    (PUCHAR)"EnumEnhMetaFile",(PFN_MS)msEnumEnhMetaFile                 ,TEST_DEFAULT,0,
//    (PUCHAR)"ExtTextOutA      ",(PFN_MS)msExtTextOutA                         ,TEST_DEFAULT,0,
//    (PUCHAR)"ExtTextOutW",(PFN_MS)msExtTextOutW                         ,TEST_DEFAULT,0,
    (PUCHAR)"PolyTextOutA",(PFN_MS)msPolyTextOutA                       ,TEST_DEFAULT,0,
    (PUCHAR)"PolyTextOutW",(PFN_MS)msPolyTextOutW                       ,TEST_DEFAULT,0,
    (PUCHAR)"FillPath",(PFN_MS)msFillPath                               ,TEST_DEFAULT,0,
    (PUCHAR)"FlattenPath",(PFN_MS)msFlattenPath                         ,TEST_DEFAULT,0,
    (PUCHAR)"GetArcDirection",(PFN_MS)msGetArcDirection                 ,TEST_DEFAULT,0,
    (PUCHAR)"GetBitmapBits",(PFN_MS)msGetBitmapBits ,TEST_DEFAULT,0,
//    (PUCHAR)"GetCharWidthA",(PFN_MS)msGetCharWidthA ,TEST_DEFAULT,0,
//    (PUCHAR)"GetCharWidthW",(PFN_MS)msGetCharWidthW ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharWidth32A",(PFN_MS)msGetCharWidth32A ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharWidth32W",(PFN_MS)msGetCharWidth32W ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharWidthFloatA",(PFN_MS)msGetCharWidthFloatA ,TEST_DEFAULT,0,
    (PUCHAR)"GetCharWidthFloatW",(PFN_MS)msGetCharWidthFloatW ,TEST_DEFAULT,0,
    (PUCHAR)"GetDIBColorTable",(PFN_MS)msGetDIBColorTable ,TEST_DEFAULT,0,
    (PUCHAR)"GetDIBits",(PFN_MS)msGetDIBits ,TEST_DEFAULT,0,
    (PUCHAR)"GetMetaFileBitsEx",(PFN_MS)msGetMetaFileBitsEx ,TEST_DEFAULT,0,
    (PUCHAR)"GetMiterLimit",(PFN_MS)msGetMiterLimit ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFileBits",(PFN_MS)msGetEnhMetaFileBits ,TEST_DEFAULT,0,
    (PUCHAR)"GetObjectA",(PFN_MS)msGetObjectA ,TEST_DEFAULT,0,
    (PUCHAR)"GetObjectW",(PFN_MS)msGetObjectW ,TEST_DEFAULT,0,
    (PUCHAR)"GetObjectType",(PFN_MS)msGetObjectType ,TEST_DEFAULT,0,
    (PUCHAR)"GetPaletteEntries",(PFN_MS)msGetPaletteEntries ,TEST_DEFAULT,0,
    (PUCHAR)"GetPath",(PFN_MS)msGetPath ,TEST_DEFAULT,0,
    (PUCHAR)"GetSystemPaletteEntries",(PFN_MS)msGetSystemPaletteEntries ,TEST_DEFAULT,0,
    (PUCHAR)"GetWinMetaFileBits",(PFN_MS)msGetWinMetaFileBits ,TEST_DEFAULT,0,
    (PUCHAR)"LPtoDP",(PFN_MS)msLPtoDP ,TEST_DEFAULT,0,
    (PUCHAR)"PathToRegion",(PFN_MS)msPathToRegion ,TEST_DEFAULT,0,
    (PUCHAR)"PlayMetaFileRecord",(PFN_MS)msPlayMetaFileRecord ,TEST_DEFAULT,0,
    (PUCHAR)"PlayEnhMetaFileRecord",(PFN_MS)msPlayEnhMetaFileRecord ,TEST_DEFAULT,0,
    (PUCHAR)"PolyBezier",(PFN_MS)msPolyBezier ,TEST_DEFAULT,0,
    (PUCHAR)"PolyBezierTo",(PFN_MS)msPolyBezierTo ,TEST_DEFAULT,0,
    (PUCHAR)"PolyDraw",(PFN_MS)msPolyDraw ,TEST_DEFAULT,0,
    (PUCHAR)"PolylineTo",(PFN_MS)msPolylineTo ,TEST_DEFAULT,0,
    (PUCHAR)"ResetDCA",(PFN_MS)msResetDCA ,TEST_DEFAULT,0,
    (PUCHAR)"ResetDCW",(PFN_MS)msResetDCW ,TEST_DEFAULT,0,
    (PUCHAR)"SelectClipPath",(PFN_MS)msSelectClipPath ,TEST_DEFAULT,0,
    (PUCHAR)"SetAbortProc",(PFN_MS)msSetAbortProc ,TEST_DEFAULT,0,
    (PUCHAR)"SetBitmapBits",(PFN_MS)msSetBitmapBits ,TEST_DEFAULT,0,
    (PUCHAR)"SetDIBColorTable",(PFN_MS)msSetDIBColorTable ,TEST_DEFAULT,0,
    (PUCHAR)"SetDIBits",(PFN_MS)msSetDIBits ,TEST_DEFAULT,0,
    (PUCHAR)"SetDIBitsToDevice",(PFN_MS)msSetDIBitsToDevice ,TEST_DEFAULT,0,
    (PUCHAR)"SetMetaFileBitsEx",(PFN_MS)msSetMetaFileBitsEx ,TEST_DEFAULT,0,
    (PUCHAR)"SetEnhMetaFileBits",(PFN_MS)msSetEnhMetaFileBits ,TEST_DEFAULT,0,
    (PUCHAR)"SetMiterLimit",(PFN_MS)msSetMiterLimit ,TEST_DEFAULT,0,
    (PUCHAR)"SetPaletteEntries",(PFN_MS)msSetPaletteEntries ,TEST_DEFAULT,0,
    (PUCHAR)"SetWinMetaFileBits",(PFN_MS)msSetWinMetaFileBits ,TEST_DEFAULT,0,
    (PUCHAR)"StretchDIBits",(PFN_MS)msStretchDIBits ,TEST_DEFAULT,0,
    (PUCHAR)"StrokeAndFillPath",(PFN_MS)msStrokeAndFillPath ,TEST_DEFAULT,0,
    (PUCHAR)"StrokePath",(PFN_MS)msStrokePath ,TEST_DEFAULT,0,
    (PUCHAR)"WidenPath",(PFN_MS)msWidenPath ,TEST_DEFAULT,0,
    (PUCHAR)"AbortPath",(PFN_MS)msAbortPath ,TEST_DEFAULT,0,
    (PUCHAR)"SetArcDirection",(PFN_MS)msSetArcDirection ,TEST_DEFAULT,0,
    (PUCHAR)"SetMetaRgn",(PFN_MS)msSetMetaRgn ,TEST_DEFAULT,0,
    (PUCHAR)"GetBoundsRect",(PFN_MS)msGetBoundsRect ,TEST_DEFAULT,0,
    (PUCHAR)"SetRelAbs",(PFN_MS)msSetRelAbs                             ,TEST_DEFAULT,0,
    (PUCHAR)"GetRandomRgn",(PFN_MS)msGetRandomRgn                     ,TEST_DEFAULT,0,
    (PUCHAR)"GetRelAbs",(PFN_MS)msGetRelAbs                           ,TEST_DEFAULT,0,
    (PUCHAR)"SetBoundsRect",(PFN_MS)msSetBoundsRect ,TEST_DEFAULT,0,
    (PUCHAR)"SetFontEnumeration",(PFN_MS)msSetFontEnumeration           ,TEST_DEFAULT,0,
    (PUCHAR)"SetPixelFormat",(PFN_MS)msSetPixelFormat                   ,TEST_DEFAULT,0,
    (PUCHAR)"GetMetaFileA",(PFN_MS)msGetMetaFileA ,TEST_DEFAULT,0,
    (PUCHAR)"GetMetaFileW",(PFN_MS)msGetMetaFileW ,TEST_DEFAULT,0,
    (PUCHAR)"GetMetaRgn",(PFN_MS)msGetMetaRgn ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFileA",(PFN_MS)msGetEnhMetaFileA ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFileW",(PFN_MS)msGetEnhMetaFileW ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFileDescriptionA",(PFN_MS)msGetEnhMetaFileDescriptionA ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFileDescriptionW",(PFN_MS)msGetEnhMetaFileDescriptionW ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFileHeader",(PFN_MS)msGetEnhMetaFileHeader ,TEST_DEFAULT,0,
    (PUCHAR)"AddFontResourceA",(PFN_MS)msAddFontResourceA               ,TEST_DEFAULT,0,
    (PUCHAR)"AddFontResourceW",(PFN_MS)msAddFontResourceW               ,TEST_DEFAULT,0,
    (PUCHAR)"ChoosePixelFormat",(PFN_MS)msChoosePixelFormat ,TEST_DEFAULT,0,
    (PUCHAR)"CloseMetaFile",(PFN_MS)msCloseMetaFile ,TEST_DEFAULT,0,
    (PUCHAR)"CopyMetaFileA",(PFN_MS)msCopyMetaFileA ,TEST_DEFAULT,0,
    (PUCHAR)"CopyMetaFileW",(PFN_MS)msCopyMetaFileW ,TEST_DEFAULT,0,
    (PUCHAR)"CopyEnhMetaFileA",(PFN_MS)msCopyEnhMetaFileA ,TEST_DEFAULT,0,
    (PUCHAR)"CopyEnhMetaFileW",(PFN_MS)msCopyEnhMetaFileW ,TEST_DEFAULT,0,
    (PUCHAR)"CloseEnhMetaFile",(PFN_MS)msCloseEnhMetaFile ,TEST_DEFAULT,0,
    (PUCHAR)"CreateMetaFileA",(PFN_MS)msCreateMetaFileA                 ,TEST_DEFAULT,0,
    (PUCHAR)"CreateMetaFileW",(PFN_MS)msCreateMetaFileW                 ,TEST_DEFAULT,0,
    (PUCHAR)"CreateEnhMetaFileA",(PFN_MS)msCreateEnhMetaFileA           ,TEST_DEFAULT,0,
    (PUCHAR)"CreateEnhMetaFileW",(PFN_MS)msCreateEnhMetaFileW           ,TEST_DEFAULT,0,
    (PUCHAR)"GetEnhMetaFilePaletteEntries",(PFN_MS)msGetEnhMetaFilePaletteEntries ,TEST_DEFAULT,0,

};
*/

//gNumTests = sizeof(gTestEntry) / sizeof(TEST_ENTRY);
ULONG gNumTests = 113;
ULONG gNumQTests = 9;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\cycle.h ===
/*
**  Cycle count overhead. This is a number of cycles required to actually
**  calculate the cycle count. To get the actual number of net cycles between
**  two calls to GetCycleCount, subtract CCNT_OVERHEAD.
**
**  For example:
**
**  __int64 start, finish, actual_cycle_count;
**
**  start = GetCycleCount ();
**
**      ... do some stuff ...
**
**  finish = GetCycleCount ();
**
**  actual_cycle_count = finish - start - CCNT_OVERHEAD;
**
**
*/

#define CCNT_OVERHEAD 8


#pragma warning( disable: 4035 )    /* Don't complain about lack of return value */

__inline __int64 GetCycleCount ()
{
__asm   _emit   0x0F
__asm   _emit   0x31    /* rdtsc */
    // return EDX:EAX       causes annoying warning
};

__inline unsigned GetCycleCount32 ()  // enough for about 40 seconds
{
__asm   push    EDX
__asm   _emit   0x0F
__asm   _emit   0x31    /* rdtsc */
__asm   pop     EDX
    // return EAX       causes annoying warning
};

#pragma warning( default: 4035 )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\mapevent.c ===
#include <windows.h>
#include "precomp.h"
#pragma hdrstop


//
//  NOTE: these escape codes are for a hacked version of the ATI display
//  driver. They can easily be implemented in any display driver by
//  setting up up the appropriate escape code to call EngMapEvent or
//  EngSetEvent.
//

#define ATI_ESC_MAP_EVENT           4005
#define ATI_ESC_SET_MAPPED_EVENT    4007

typedef struct __EVENTTHREAD {
    HANDLE  childEvent;
    HANDLE  parentEvent;
    } EVENTTHREAD, *PEVENTTHREAD;


DWORD
WINAPI
pMapEventThread(
    PEVENTTHREAD    pContext
    )
{
    //
    //  Wait on event that dd will set.
    //

    DbgPrint("pMapEventThread will now wait on the event\n");

    WaitForSingleObject(pContext->childEvent, INFINITE);

    DbgPrint("Hey! pMapEventThread woke up from waiting\n");

    //
    //  Be nice and tidy it up, then set the parents event so
    //  it can exit (pContext is on parents stack).
    //

    CloseHandle(pContext->childEvent);

    SetEvent(pContext->parentEvent);
    DbgPrint("Child: set parent event\n");

    ExitThread(0);

    return(1);
}

VOID
vMapEvent(
    HWND hwnd, HDC hdc, RECT* prcl
    )
{
    HANDLE      userThread;
    EVENTTHREAD ThreadContext;
    DWORD       threadId;

    //
    // Create the event to be passed into the driver.
    //

    ThreadContext.childEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);
    ThreadContext.parentEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    //
    //  Pass the event HANDLE in to the DD to be mapped.
    //

    DbgPrint("Ask DD to map event\n");

    ExtEscape(hdc,
              ATI_ESC_MAP_EVENT,
              sizeof(HANDLE),
              (LPCSTR)&(ThreadContext.childEvent),
              0,
              (LPSTR)NULL);

    //
    //  Create the thread that will wait on this event and sleep a bit.
    //

    userThread = CreateThread(NULL,
                              0,
                              pMapEventThread,
                              &ThreadContext,
                              0,
                              &threadId);
    Sleep(1000);

    //
    //  Perform the driver function that sets the associated PEVENT.
    //

    DbgPrint("Ask DD to set mapped event.\n");
    ExtEscape(hdc,
              ATI_ESC_SET_MAPPED_EVENT,
              sizeof(HANDLE),
              (LPCSTR)&(ThreadContext.childEvent),
              0,
              (LPSTR)NULL);

    //
    //  Wait for thread to signal it woke up, then tidy.
    //

    WaitForSingleObject(ThreadContext.parentEvent, INFINITE);

    DbgPrint("Parent: child set parent event\n");
    CloseHandle(ThreadContext.parentEvent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\ft\precomp.h ===
#define OEMRESOURCE 1

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stddef.h>
#include <commdlg.h>
#include <memory.h>
#include <stdlib.h>
#include <math.h>
#include "wingdip.h"
#include "ft.h"


//#include "winuser.h"
//#include "winddi.h"
//#include "..\..\gre\jenumfnt.h"
//#include "afxwin.h"
//#include "stack.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\cpudump.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   CPUdump.c

Abstract:

   Modified from PDump.c, a Win32 application to display performance statictics.

Author:

   Ken Reneris

Environment:

   User Mode

  Revision History:


--*/
#include "precomp.h"
#include "resource.h"
//#include <errno.h>
//#include <malloc.h>
#include "CPUdump.h"
#include "gdibench.h"

#define	INFSIZE             1024

extern	HWND	    hWndMain;
extern  UCHAR	    Buffer[];
extern  PUCHAR      ShortPerfName[MAX_EVENTS];
extern  BOOL        gfCPUEventMonitor;

extern  HANDLE      hLibrary;   // the handle to the NTDLL.DLL loaded in the init GDIBench
extern  PFNNTAPI    pfnNtQuerySystemInformation;    // loaded in the init of GDIBench

typedef NTSTATUS (NTAPI *PFNNTDEVICEIOCONTROLFILE)(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);
PFNNTDEVICEIOCONTROLFILE pfnNtDeviceIoControlFile;

typedef VOID (NTAPI *PFNRTLINITUNICODESTRING)(PUNICODE_STRING, PCWSTR);
PFNRTLINITUNICODESTRING pfnRtlInitUnicodeString;

typedef NTSTATUS (NTAPI *PFNNTOPENFILE)(PHANDLE, ACCESS_MASK,POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);
PFNNTOPENFILE pfnNtOpenFile;


// Global variables
ULONGLONG   NumberIter;
UCHAR       NumberOfProcessors;
HANDLE      DriverHandle;
ULONG       BufferStart [INFSIZE/4];
ULONG       BufferEnd   [INFSIZE/4];


//
// Selected Display Mode (read from wp2.ini), default set here.
//

struct {
    ULONG   EventId;
    PUCHAR  ShortName;
    PUCHAR  PerfName;
} *Counters;

SETEVENT  CounterEvent[MAX_EVENTS];


int CPUDumpInit()
{
    if (WINNT_PLATFORM) {
        pfnNtDeviceIoControlFile = (PFNNTDEVICEIOCONTROLFILE) GetProcAddress(hLibrary,"NtDeviceIoControlFile");
        if(pfnNtDeviceIoControlFile==NULL)MessageBox(NULL,"ptr1 NULL","DeviceIOControlFile",MB_OK);
        pfnRtlInitUnicodeString = (PFNRTLINITUNICODESTRING) GetProcAddress(hLibrary,"RtlInitUnicodeString");
        if(pfnRtlInitUnicodeString==NULL)MessageBox(NULL,"ptr2 NULL","InitUnicodeString",MB_OK);
        pfnNtOpenFile = (PFNNTOPENFILE) GetProcAddress(hLibrary,"NtOpenFile");
        if(pfnNtOpenFile==NULL)MessageBox(NULL,"ptr3 NULL","NtOpenFile",MB_OK);
    }
	//
	// Locate pentium perf driver
	//
	if (!InitDriver ()) {
        MessageBox(hWndMain,
			"pstat.sys is not installed!",
			"Cannot load PSTAT.SYS",
			MB_ICONSTOP | MB_OK);
		return FALSE;		// exit the application
    }
    //
    // Initialize supported event list
    //

    InitPossibleEventList();
    if (!Counters) {
		MessageBox(hWndMain,
			"No events to monitor!",
			"No events to monitor!",
			MB_ICONSTOP | MB_OK);
		return FALSE;		// exit the application
    }

	if (NumberOfProcessors > 1) {
		MessageBox(hWndMain,
			"The count will not be correct for more than one CPU",
			"Warning: More than one CPU detected",
			MB_ICONWARNING | MB_OK);
	}
/*
    if (WINNT_PLATFORM) {
        pfnNtDeviceIoControlFile = (PFNNTDEVICEIOCONTROLFILE) GetProcAddress(hLibrary,"NtDeviceIoControlFile");
        if(pfnNtDeviceIoControlFile==NULL)MessageBox(NULL,"ptr1 NULL","DeviceIOControlFile",MB_OK);
        pfnRtlInitUnicodeString = (PFNRTLINITUNICODESTRING) GetProcAddress(hLibrary,"RtlInitUnicodeString");
        if(pfnRtlInitUnicodeString==NULL)MessageBox(NULL,"ptr2 NULL","InitUnicodeString",MB_OK);
        pfnNtOpenFile = (PFNNTOPENFILE) GetProcAddress(hLibrary,"NtOpenFile");
        if(pfnNtOpenFile==NULL)MessageBox(NULL,"ptr3 NULL","NtOpenFile",MB_OK);
    }
*/
	return TRUE;
} // End of CPUDumpInit

BOOLEAN
InitCPUDump()
{
    BOOLEAN     CounterSet;
    LONG        CounterType;
    ULONG       i;

	CounterSet = 0;

    for (i=0; i<MAX_EVENTS; i++) {
        //
        // if the short perfname is not set, set to 
        // "instruction executed" instead
        //
        if (ShortPerfName[i] != NULL)
            CounterType = FindShortName(ShortPerfName[i]);
        else {
            //
            // if there is no short name at all, hardcode
            // "instruction executed".
            //
            ShortPerfName[i] = _strdup("iexec");
            CounterType = FindShortName("iexec");
        }
        if (CounterType == -1) {
            MessageBox(hWndMain,
                "Counter dtlbmiss not found",
			    "Failed to find CPU counters",
			     MB_ICONEXCLAMATION | MB_OK);
            return FALSE;
        }
       	CounterSet |= SetCounter (CounterType, i); 
    }

	if (!CounterSet) {
		MessageBox(hWndMain,
			"Failed to set CPU counters!",
			"Failed to set CPU counters",
			MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
	}

    return TRUE;
}

    //
    // The template for monitoring an API
	// Snap begining & ending counts
    //
VOID
BeginCPUDump()
{
    //
    // Call driver and perform the setting
    //
    if (gfCPUEventMonitor) {
        SetCounterEncodings ();
        GetInternalStats (BufferStart);     // snap current values
    }
}

// snap ending values
VOID
EndCPUDump(ULONG Iter)
{
    if (gfCPUEventMonitor) {
        GetInternalStats (BufferEnd);
        NumberIter = Iter;
    }
}

// return the counter name
PUCHAR
Get_CPUDumpName(ULONG EventNo)
{
    return Counters[CounterEvent[EventNo].AppReserved].PerfName;
}

VOID
Get_CPUDump(ULONG eventno, ULONGLONG *NewETime, ULONGLONG *NewECount)
{
	ULONG			j,len;
    pPSTATS         ProcStart, ProcEnd;
    ULONGLONG       ETime, ECount;
    BOOLEAN         ProcessorBreakout, ProcessorTotal;

	// Hardcoded for single CPU
	ProcessorBreakout=FALSE;
	ProcessorTotal=TRUE;

    //
    // Calculate each counter and print it
    //

	if (!CounterEvent[eventno].Active) {
        (*NewETime) = 0;
		(*NewECount) = 0;
        return;
    }

	len = *((PULONG) BufferStart);
    /*
    if (ProcessorBreakout) {
		//
        // Print stat for each processor
        // This part is hardcoded out 11/20/96 a-ifkao
        // Modify later
        //
		
		ProcStart = (pPSTATS) ((PUCHAR) BufferStart + sizeof(ULONG));
        ProcEnd   = (pPSTATS) ((PUCHAR) BufferEnd   + sizeof(ULONG));
	
        for (j=0; j < NumberOfProcessors; j++) {
			ETime = ProcEnd->TSC - ProcStart->TSC;
            ECount = ProcEnd->Counters[eventno] - ProcStart->Counters[eventno];
			ProcStart = (pPSTATS) (((PUCHAR) ProcStart) + len);
            ProcEnd   = (pPSTATS) (((PUCHAR) ProcEnd)   + len);
			// for each processor, stsatistics must be printed once
			// need to solve this later.
			//(Dump->PerfName)[eventno] = Counters[CounterEvent[eventno].AppReserved].PerfName;
			//(Dump->ETime)[eventno] = ETime;
			//(Dump->ECount)[eventno] = ECount;
		} // for
	} // if
    */
	if (!ProcessorBreakout || ProcessorTotal) {
		//
        // Sum processor's and print it
        //

        ProcStart = (pPSTATS) ((PUCHAR) BufferStart + sizeof(ULONG));
        ProcEnd   = (pPSTATS) ((PUCHAR) BufferEnd   + sizeof(ULONG));
        ETime  = 0;
        ECount = 0;

        for (j=0; j < NumberOfProcessors; j++) {
			ETime = ETime + ProcEnd->TSC;
            ETime = ETime - ProcStart->TSC;

            ECount = ECount + ProcEnd->Counters[eventno];
            ECount = ECount - ProcStart->Counters[eventno];

            ProcStart = (pPSTATS) (((PUCHAR) ProcStart) + len);
            ProcEnd   = (pPSTATS) (((PUCHAR) ProcEnd)   + len);
		} // for

		(*NewETime) = ETime / NumberIter;
		(*NewECount) = ECount / NumberIter;

	} // if
} // End

BOOLEAN
InitDriver ()
{
    UNICODE_STRING              DriverName;
    NTSTATUS                    status;
    OBJECT_ATTRIBUTES           ObjA;
    IO_STATUS_BLOCK             IOSB;
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    // PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;


    //
    //  Init Nt performance interface
    //

    pfnNtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSORS) {
        return FALSE;
    }

	// Also if NumberofProcessors>1 prompt a dialog box, but not stop
	// the program, since the count will not be accurate.

    //
    // Open PStat driver
    //

    pfnRtlInitUnicodeString(&DriverName, L"\\Device\\PStat");
	
    InitializeObjectAttributes(
            &ObjA,
            &DriverName,
            OBJ_CASE_INSENSITIVE,
            0,
            0 );

    status = pfnNtOpenFile (
            &DriverHandle,                      // return handle
            SYNCHRONIZE | FILE_READ_DATA,       // desired access
            &ObjA,                              // Object
            &IOSB,                              // io status block
            FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
            FILE_SYNCHRONOUS_IO_ALERT           // open options
            );

    return NT_SUCCESS(status) ? TRUE : FALSE;
    return TRUE;
}

VOID
InitPossibleEventList()
{
    UCHAR               buffer[400];
    ULONG               i, Count;
    NTSTATUS            status;
    PEVENTID            Event;
    IO_STATUS_BLOCK     IOSB;


    //
    // Initialize possible counters
    //

    // determine how many events there are

    Event = (PEVENTID) buffer;
    Count = 0;
    do {
        *((PULONG) buffer) = Count;
        Count += 1;

        status = pfnNtDeviceIoControlFile(
                    DriverHandle,
                    (HANDLE) NULL,          // event
                    (PIO_APC_ROUTINE) NULL,
                    (PVOID) NULL,
                    &IOSB,
                    PSTAT_QUERY_EVENTS,
                    buffer,                 // input buffer
                    sizeof (buffer),
                    NULL,                   // output buffer
                    0
                    );
    } while (NT_SUCCESS(status));

    Counters = malloc(sizeof(*Counters) * Count);
    Count -= 1;
    for (i=0; i < Count; i++) {
        *((PULONG) buffer) = i;
        pfnNtDeviceIoControlFile(
           DriverHandle,
           (HANDLE) NULL,          // event
           (PIO_APC_ROUTINE) NULL,
           (PVOID) NULL,
           &IOSB,
           PSTAT_QUERY_EVENTS,
           buffer,                 // input buffer
           sizeof (buffer),
           NULL,                   // output buffer
           0
           );

        Counters[i].EventId   = Event->EventId;
        Counters[i].ShortName = _strdup (Event->Buffer);
        Counters[i].PerfName  = _strdup (Event->Buffer + Event->DescriptionOffset);
    }

    Counters[i].EventId   = 0;
    Counters[i].ShortName = NULL;
    Counters[i].PerfName  = NULL;
}

VOID GetInternalStats (PVOID Buffer)
{
    IO_STATUS_BLOCK             IOSB;

    pfnNtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_READ_STATS,
        Buffer,                 // input buffer
        INFSIZE,
        NULL,                   // output buffer
        0
    );
}


VOID SetCounterEncodings (VOID)
{
    IO_STATUS_BLOCK             IOSB;

    pfnNtDeviceIoControlFile(
        DriverHandle,
        (HANDLE) NULL,          // event
        (PIO_APC_ROUTINE) NULL,
        (PVOID) NULL,
        &IOSB,
        PSTAT_SET_CESR,
        CounterEvent,           // input buffer
        sizeof (CounterEvent),
        NULL,                   // output buffer
        0
    );
}


BOOLEAN SetCounter (LONG CounterId, ULONG counter)
{
    if (CounterId == -1) {
        CounterEvent[counter].Active = FALSE;
        return FALSE;
    }

    CounterEvent[counter].EventId = Counters[CounterId].EventId;
    CounterEvent[counter].AppReserved = (ULONG) CounterId;
    CounterEvent[counter].Active = TRUE;
    CounterEvent[counter].UserMode = TRUE;
    CounterEvent[counter].KernelMode = TRUE;

    return TRUE;
}

LONG FindShortName (PSZ name)
{
    LONG   i;

    for (i=0; Counters[i].ShortName; i++) {
        if (strcmp (Counters[i].ShortName, name) == 0) {
            return i;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\cpudump.h ===
//
// global handles
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   CPUdump.h

Abstract:

   Modified from PDump.c, a Win32 application to display performance statictics.

Author:

   Ken Reneris

Environment:

   User Mode

  Revision History:


--*/

#ifndef _CPUDUMP_INCLUDED_
#define _CPUDUMP_INCLUDED_

#include "\nt\private\sdktools\pperf\pstat.h"

// Note that the following works only in Windows NT,
// so add if( WINNT_PLATFORM ){} tests in attr.c where you want CPU measured!
// WINNT_PLATFORM is defined in gdibench.h

typedef struct _CPU_DUMP
{
	ULONGLONG   ETime,
				ECount;
} CPU_DUMP, *PCPU_DUMP;


//
// Protos..
//

int     CPUDumpInit();
BOOLEAN InitCPUDump();
VOID    BeginCPUDump();
VOID    EndCPUDump(ULONG Iter);
PUCHAR  Get_CPUDumpName(ULONG EventNo);
VOID    Get_CPUDump(ULONG eventno, ULONGLONG *ETime, ULONGLONG *ECount);

VOID    GetInternalStats (PVOID Buffer);
VOID    SetCounterEncodings (VOID);
BOOLEAN SetCounter (LONG CounterID, ULONG counter);
BOOLEAN InitDriver ();
VOID    InitPossibleEventList();
LONG    FindShortName (PSZ name);

#endif	// CPUDump.h included
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\gdibench.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   gdibench.c

Abstract:

    GDI performance numbers

Author:

   Mark Enstrom   (marke)  13-Apr-1995

Enviornment:

   User Mode

Revision History:

   Dan Almosnino (danalm) 20-Sept-1995

1. Timer call modified to run on both NT and WIN95. Results now reported in 100 nano-seconds.
2. Test-Menu flag option added to prevent long one-colomn menu that flows out of the window in new
   shell (both WIN95 and NT).
3. Added Option menu item to choose fonts and string size for text-string related function calls.
4. Added Run Text Suite option for the above.
5. Modified the output save file to report the information for the above.

    Dan Almosnino (danalm) 17-Oct-1995

1.  Added Batch Mode and help for running batch mode
2.  Added "Transparent" background text option to menu

    Dan Almosnino (danalm) 20-Nov-1995

1.  Added Option for using the Pentium Cycle Counter instead of "QueryPerformanceCounter" when applicable.
2.  Added a simple statistics module and filter for processing the raw test data.

--*/


#include "precomp.h"
#include "resource.h"
#include "wchar.h"
#include "gdibench.h"

//
// some globals
//
#ifdef _X86_
   SYSTEM_INFO SystemInfo;
#endif

PSZ     pszTest                 = DEFAULT_A_STRING;
PWSTR   pwszTest                = DEFAULT_W_STRING;

BOOL    gfPentium               = FALSE;
BOOL    gfUseCycleCount         = TRUE;

HINSTANCE   hInstMain;
HWND        hWndMain;
HANDLE      hLibrary;

extern _int64     BeginTimeMeasurement();
extern ULONGLONG  EndTimeMeasurement(_int64,ULONG);

// CPU Dump related globals
// The number 200 is the same as the declaration in the header
// for the number of tests.
//
// Since PerfName is the same for all tests. Only one instance
// per each event is kept.
PUCHAR      PerfName[MAX_EVENTS];
ULONGLONG   ETime[200][MAX_EVENTS],
            ECount[200][MAX_EVENTS],
            NewETime,
            NewECount;
ULONG       eventloop;
PUCHAR      ShortPerfName[MAX_EVENTS];
BOOLEAN     CPUDumpFlag;

int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR szCmdLine,
    int cmdShow
)

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   msg     - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/


{
    MSG         msg;
    WNDCLASS    wc;
    HWND        hWndDesk;
    HINSTANCE   hInstMain;
    RECT        hwRect;
    HDC hdc2;

    char txtbuf[80];
    char txtbuf2[80];
    char *ptr;

    Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);
    if (GetVersionEx(&Win32VersionInformation))
       if(WINNT_PLATFORM)
  	            {
				   hLibrary = LoadLibrary("ntdll.dll");
				   pfnNtQuerySystemInformation = (PFNNTAPI) GetProcAddress(hLibrary,"NtQuerySystemInformation");
				}


    hInstMain =  hInst;

    hWndDesk = GetDesktopWindow();
    GetWindowRect(hWndDesk,&hwRect);

    //
    // Create (if no prev instance) and Register the class
    //

    if (!hPrev)
    {
        wc.hCursor        = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
        wc.hIcon          = (HICON)NULL;
        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_GDIBENCH_MENU);
        wc.lpszClassName  = "gdibenchClass";
        wc.hbrBackground  = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
        wc.hInstance      = hInst;
        wc.style          = (UINT)0;
        wc.lpfnWndProc    = WndProc;
        wc.cbWndExtra     = 0;
        wc.cbClsExtra     = 0;


        if (!RegisterClass(&wc)) {
            return FALSE;
        }
    }

    //
    // Create and show the main window
    //

    hWndMain = CreateWindow ("gdibenchClass",
                            "GDI Call Performace",
                            WS_OVERLAPPEDWINDOW,
                            0,
                            0,
                            hwRect.right,
                            hwRect.bottom,
                            (HWND)NULL,
                            (HMENU)NULL,
                            (HINSTANCE)hInst,
                            (LPSTR)NULL
                           );

    if (hWndMain == NULL) {
        return(FALSE);
    }
    //
    //  Show the window
    //

    ShowWindow(hWndMain,cmdShow);
    UpdateWindow(hWndMain);
    SetFocus(hWndMain);

    // Initialize Source Strings

    strcpy(SourceString, "This is just a silly test string. Would you rather have a different one? Well, you can define one if you run GDI bench in batch!");
    wcscpy(SourceStringW, L"This is just a silly test string. Would you rather have a different one? Well, you can define one if you run GDI bench in batch!");
    StrLen                  = DEFAULT_STRING_LENGTH;

    //
    // for x86 family CPU, detect the CPU to see if the CPU if Pentium or above.
    //
#ifdef _X86_
    GetSystemInfo(&SystemInfo);
    if (gfUseCycleCount&&(PROCESSOR_INTEL_PENTIUM==SystemInfo.dwProcessorType))
        gfPentium = TRUE;
    else
#endif
        gfPentium = FALSE;

    gfCPUEventMonitor       = FALSE;    // CPU Event Monitoring Turned OFF by default
    if ( CMD_IS("-p") || CMD_IS("-P") || CMD_IS("/p") || CMD_IS("/P"))
		if (WINNT_PLATFORM && gfPentium) gfCPUEventMonitor = TRUE; // Turn on CPU Monitoring

    // If Pentium or better CPU is detected, check for the events to monitor
    // Get the choice on the CPU events to monitor
    if (gfCPUEventMonitor) {
        if (CMD_IS("-c")) {
            ptr = strstr(szCmdLine, "-c");
            sscanf(ptr+2, "%s %s", txtbuf, txtbuf2);
            ShortPerfName[0] = _strdup(txtbuf);
            ShortPerfName[1] = _strdup(txtbuf2);
        }
        if (CMD_IS("/c")) {
            ptr = strstr(szCmdLine, "/c");
            sscanf(ptr+2, "%s %s", txtbuf, txtbuf2);
            ShortPerfName[0] = _strdup(txtbuf);
            ShortPerfName[1] = _strdup(txtbuf2);
        }

	// Load and initialize PSTAT.SYS driver
    // Currently, If no Pentium CPU or better is found
    // simply return. However, this should changed into a flag
    // for the codes thereafter to check instead of hard coding.
    // a-ifkao
        CPUDumpFlag = (BOOLEAN)CPUDumpInit();
	    if (!CPUDumpFlag) return FALSE;
        InitCPUDump();
        // Get full performance event name
        for (eventloop=0; eventloop<MAX_EVENTS; eventloop++) {
            PerfName[eventloop] = Get_CPUDumpName(eventloop);
        }
    }
	//
    // Command Line Option to Disable GDI batching limit.
    // In particular, use this option for CPU Event monitoring,
    // so API's will be forced to call kernel API each time,
    // instead of batching to get more exact timing.
    //

    if ( CMD_IS("-z") || CMD_IS("-Z") || CMD_IS("/z") || CMD_IS("/Z"))
        GdiSetBatchLimit(1);

    //  Batch Mode Related

    TextSuiteFlag           = FALSE;
    BatchFlag               = FALSE;
    Finish_Message          = FALSE;
    Dont_Close_App          = FALSE;
    SelectedFontTransparent = FALSE;
    String_Length_Warn      = FALSE;
    Print_Detailed          = FALSE;

//  GdiSetBatchLimit(1);                // Kills all GDI Batching


    // Check for help or batch-mode command-line parameters


    if(CMD_IS("-?") || CMD_IS("/?") || CMD_IS("-h") || CMD_IS("-H") ||CMD_IS("/h") || CMD_IS("/H"))
    {
          DialogBox(hInstMain, (LPSTR)IDD_HELP, hWndMain, (DLGPROC)HelpDlgProc);
    }

    if (CMD_IS("-b") || CMD_IS("-B") || CMD_IS("/b") || CMD_IS("/B"))
    {
        BatchFlag = TRUE;
        GetCurrentDirectory(sizeof(IniFileName),IniFileName);  // Prepare INI file path, append name later
        strcat(IniFileName,"\\");
    }

    if (CMD_IS("-m") || CMD_IS("-M") || CMD_IS("/m") || CMD_IS("/M"))
        Finish_Message = TRUE;

    if ( CMD_IS("-s") || CMD_IS("-S") || CMD_IS("/s") || CMD_IS("/S"))
        Dont_Close_App = TRUE;

    if ( CMD_IS("-t") || CMD_IS("-T") || CMD_IS("/t") || CMD_IS("/T"))
        gfUseCycleCount = FALSE;

    if ( CMD_IS("-d") || CMD_IS("-D") || CMD_IS("/d") || CMD_IS("/D"))
        Print_Detailed = TRUE;


    if ( CMD_IS("-i"))
    {
        ptr = strstr(szCmdLine, "-i");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else if (CMD_IS("-I"))
    {
        ptr = strstr(szCmdLine, "-I");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else if (CMD_IS("/i"))
    {
        ptr = strstr(szCmdLine, "/i");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else if (CMD_IS("/I"))
    {
        ptr = strstr(szCmdLine, "/I");
        sscanf(ptr+2,"%s",txtbuf);
        strcat(IniFileName,txtbuf);
    }
    else
    {
        strcat(IniFileName,"GDIBATCH.INI");
    }

    if(BatchFlag == TRUE)
        SendMessage(hWndMain,WM_COMMAND,RUN_BATCH,0L);      // Start Batch

    //
    // Main message loop
    //

    while (GetMessage(&msg,(HWND)NULL,0,0))
    {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
    }

  return (int)msg.wParam;
}



LRESULT FAR
PASCAL WndProc(
    HWND        hWnd,
    unsigned    msg,
    WPARAM      wParam,
    LPARAM      lParam)

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   msg     - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{

    BOOL Status;
    UCHAR tmsg[256];
    int MBresult;
    char txtbuf[80];
    char strbuf[256];
    char tmpbuf[5][20];
    int i,j,k,l,m,n;
    char *kptr;
    char TestTypeEntry[16];
    int TestType;
    int Num_Selected_Tests;
    int Test_Item[25];
    char SelectedFont[32];
    char FaceNameBuf[320];                                 //Ten Face Names
    char FaceName[10][32];
	int NumFonts;
    int  SelectedFontSize       = 12;
    BYTE SelectedFontBold       = FALSE;
    BYTE SelectedFontItalic     = FALSE;
    BYTE SelectedFontUnderline  = FALSE;
    BYTE SelectedFontStrike     = FALSE;
    COLORREF SelectedFontColor  = RGB(0,0,0);
    char tst[2];
    BYTE FontRed, FontGreen, FontBlue;
    char TextString[256];
    int No_String_Lengths, No_Font_Sizes;
    int StringLength[16], FontSize[16];
    static int Source_String_Length;
    int Text_Test_Order[16];
    int VPixelsPerLogInch;
    static int Last_Checked = 5;

    double Sum;
    double Sample[NUM_SAMPLES];

    static HDC hdc2;          /* display DC handle            */
    static HFONT hfont;       /* new logical font handle      */
    static HFONT hfontOld;    /* original logical font handle */
    static COLORREF crOld;    /* original text color          */



    switch (msg) {

    case WM_CREATE:
    {
        ULONG ix;

        HMENU hAdd = GetSubMenu(GetMenu(hWnd),1);
        HMENU hmenu = GetSubMenu(GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0),0);

        for (ix=0;ix<NUM_TESTS;ix++)
        {

            if ((ix > 0) && ((ix % 40) == 0))
            {
                AppendMenu(hAdd, MF_MENUBARBREAK | MF_SEPARATOR,0,0);
            }

            wsprintf(tmsg,"T%i: %s",ix,gTestEntry[ix].Api);
            AppendMenu(hAdd, MF_STRING | MF_ENABLED, ID_TEST_START + ix, tmsg);
        }

        CheckMenuItem(hmenu,5,MF_BYPOSITION|MF_CHECKED);


    }
    break;

    case WM_COMMAND:
    {

            switch (LOWORD(wParam)){
            case IDM_EXIT:
            {
                SendMessage(hWnd,WM_CLOSE,0,0L);
            }
             break;


            case IDM_SHOW:
                DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, (DLGPROC)ResultsDlgProc);
                break;

            case IDM_HELP:
                DialogBox(hInstMain, (LPSTR)IDD_HELP, hWnd, (DLGPROC)HelpDlgProc);
                break;


//
// Choose and Set Text String Length
//

            case IDM_S001:
                {
                    StrLen = 1;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 0);
                }
                break;

            case IDM_S002:
                {
                    StrLen = 2;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 1);

                }
                break;

            case IDM_S004:
                {
                    StrLen = 4;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 2);

                }
                break;

            case IDM_S008:
                {
                    StrLen = 8;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 3);

                }
                break;

            case IDM_S016:
                {
                    StrLen = 16;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 4);

                }
                break;

            case IDM_S032:
                {
                    StrLen = 32;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 5);

                }
                break;

            case IDM_S064:
                {
                    StrLen = 64;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 6);

                }
                break;

            case IDM_S128:
                {
                    StrLen = 128;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 7);

                }
                break;

            case IDM_S256:
                {
                    StrLen = 256;
                    Last_Checked = SyncMenuChecks(hWnd, Last_Checked, 8);

                }
                break;

//            case IDM_SXXX:
//
//            break;

            case IDM_TRANSPARENT:
                {
                    HMENU hmenu = GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0);
                    if(SelectedFontTransparent == TRUE)
                    {
                        SelectedFontTransparent = FALSE;
                        CheckMenuItem(hmenu,2,MF_BYPOSITION|MF_UNCHECKED);
                    }
                    else if(SelectedFontTransparent == FALSE)
                    {
                        SelectedFontTransparent = TRUE;
                        CheckMenuItem(hmenu,2,MF_BYPOSITION|MF_CHECKED);
                    }
                }
                break;


            case IDM_FONT:         // Invoke the ChooseFont Dialog (interactive mode)
                {
        /* Initialize the necessary members */

                    cf.lStructSize = sizeof (CHOOSEFONT);
                    cf.hwndOwner = hWnd;
                    cf.lpLogFont = &lf;
                    cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
                    cf.nFontType = SCREEN_FONTTYPE;
/*
 * Display the dialog box, allow the user to
 * choose a font, and render the text in the
 * window with that selection.
 */
                    if (ChooseFont(&cf)){
                        hdc2 = GetDC(hWnd);
                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);
                    }

                }
                break;

            //
            // Run all tests
            //

            case IDM_RUN:               // Run all tests
            {
                ULONG Index;
                PFN_MS pfn;
                HDC hdc = GetDC(hWnd);
                RECT CliRect = {20,20,500,40};


                for (Index=0;Index<NUM_TESTS;Index++)
                {
                    HDC hdc2 = GetDC(hWnd);

                    FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));
                    wsprintf(tmsg,"Testing %s",gTestEntry[Index].Api);
                    TextOut(hdc2,20,20,tmsg,strlen(tmsg));
                    pfn = gTestEntry[Index].pfn;
                    ShowCursor(FALSE);

                    hfont = CreateFontIndirect(cf.lpLogFont);
                    hfontOld = SelectObject(hdc2, hfont);
                    crOld = SetTextColor(hdc2, cf.rgbColors);
                    if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);

////// Statistics
                    for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                        ETime[Index][eventloop] = 0;
                        ECount[Index][eventloop] = 0;
                    }

                    for(j=0; j<NUM_SAMPLES; j++)
                    {

                        GdiFlush();

                        Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                        Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                        PageFaultData[Index][j] = PageFaults;
						PagesReadData[Index][j] = PagesRead;
                        if(Per_Test_CPU_Event_Flag == TRUE)
                            for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                                Get_CPUDump(eventloop, &NewETime, &NewECount);
                                ETime[Index][eventloop] += NewETime;
                                ECount[Index][eventloop] += NewECount;
                            }

                    }

                    Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
					for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                        ETime[Index][eventloop] /= NUM_SAMPLES;
                        ECount[Index][eventloop] /= NUM_SAMPLES;
                    }

///////
					Per_Test_CPU_Event_Flag = FALSE; // reset for next test
                    ShowCursor(TRUE);

                    SetTextColor(hdc, crOld);
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                    SetBkMode(hdc2,OPAQUE);

                    ReleaseDC(hWnd,hdc2);
                }

                ReleaseDC(hWnd,hdc);
                if(BatchFlag != TRUE)
                    DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, (DLGPROC)ResultsDlgProc);
            }
            break;

            case IDM_QRUN:              // Run the quick test suite
            {
                ULONG Index;
                PFN_MS pfn;
                HDC hdc = GetDC(hWnd);
                RECT CliRect = {20,20,500,40};


                for (Index=0;Index<NUM_QTESTS;Index++)
                {
                    HDC hdc2 = GetDC(hWnd);

                    FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));
                    wsprintf(tmsg,"Testing %s",gTestEntry[Index].Api);
                    TextOut(hdc2,20,20,tmsg,strlen(tmsg));
                    pfn = gTestEntry[Index].pfn;
                    ShowCursor(FALSE);

                    hfont = CreateFontIndirect(cf.lpLogFont);
                    hfontOld = SelectObject(hdc2, hfont);
                    crOld = SetTextColor(hdc2, cf.rgbColors);
                    if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);

////// Statistics
                    for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                        ETime[Index][eventloop] = 0;
                        ECount[Index][eventloop] = 0;
                    }

                    for(j=0; j<NUM_SAMPLES; j++)
                    {

                        GdiFlush();

                        Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                        Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                        PageFaultData[Index][j] = PageFaults;
						PagesReadData[Index][j] = PagesRead;
                        if(Per_Test_CPU_Event_Flag == TRUE)
                            for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                                Get_CPUDump(eventloop, &NewETime, &NewECount);
                                ETime[Index][eventloop] += NewETime;
                                ECount[Index][eventloop] += NewECount;
                            }

                    }

                    Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
					for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                        ETime[Index][eventloop] /= NUM_SAMPLES;
                        ECount[Index][eventloop] /= NUM_SAMPLES;
                    }

///////

					Per_Test_CPU_Event_Flag = FALSE; // reset for next test
                    ShowCursor(TRUE);

                    SetTextColor(hdc, crOld);
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                    SetBkMode(hdc2,OPAQUE);
                    ReleaseDC(hWnd,hdc2);
                }

                ReleaseDC(hWnd,hdc);

                if(BatchFlag != TRUE)
                    DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, (DLGPROC)ResultsDlgProc);
            }
            break;

            case IDM_TEXT_QRUN:         // Run Text Suite
            {
                ULONG Index;
                PFN_MS pfn;
                HDC hdc = GetDC(hWnd);
                RECT CliRect = {20,20,500,40};

                TextSuiteFlag = TRUE;

                for (Index = FIRST_TEXT_FUNCTION; Index <= LAST_TEXT_FUNCTION; Index++)
                {
                    HDC hdc2 = GetDC(hWnd);

                    FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));
                    wsprintf(tmsg,"Testing %s",gTestEntry[Index].Api);
                    TextOut(hdc2,20,20,tmsg,strlen(tmsg));
                    pfn = gTestEntry[Index].pfn;
                    ShowCursor(FALSE);

                    hfont = CreateFontIndirect(cf.lpLogFont);
                    hfontOld = SelectObject(hdc2, hfont);
                    crOld = SetTextColor(hdc2, cf.rgbColors);
                    if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);
////// Statistics
                    for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                        ETime[Index][eventloop] = 0;
                        ECount[Index][eventloop] = 0;
                    }

                    for(j=0; j<NUM_SAMPLES; j++)
                    {

                        GdiFlush();

                        Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                        Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                        PageFaultData[Index][j] = PageFaults;
						PagesReadData[Index][j] = PagesRead;
                        if(Per_Test_CPU_Event_Flag == TRUE)
                            for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                                Get_CPUDump(eventloop, &NewETime, &NewECount);
                                ETime[Index][eventloop] += NewETime;
                                ECount[Index][eventloop] += NewECount;
                            }

                    }

                    Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
					for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                        ETime[Index][eventloop] /= NUM_SAMPLES;
                        ECount[Index][eventloop] /= NUM_SAMPLES;
                    }

///////
					Per_Test_CPU_Event_Flag = FALSE; // reset for next test
                    ShowCursor(TRUE);
                    SetTextColor(hdc, crOld);
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                    SetBkMode(hdc2,OPAQUE);

                    ReleaseDC(hWnd,hdc2);

                }

                ReleaseDC(hWnd,hdc);

                if(BatchFlag != TRUE)
                    DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hWnd, (DLGPROC)ResultsDlgProc);

            }
            break;

//
// Run in Batch Mode
//
            case RUN_BATCH:
            {
                fpIniFile = fopen(IniFileName,"r");
                if(NULL == fpIniFile)
                {
                    MessageBox(hWnd,"GDIBATCH.INI File Not Found, Cannot Continue in Batch Mode","INI File Not Found",MB_ICONSTOP|MB_OK);
                    BatchFlag = FALSE;
                    break;
                }
                else                    //Start reading INI file Keys

                {
                    if(!GetPrivateProfileString("BATCH","RUN","TEXT",TestTypeEntry,sizeof(TestTypeEntry),IniFileName))
                    {
                        MessageBox(hWnd,"Invalid Caption 1 in GDIBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                        BatchFlag = FALSE;
                        break;
                    }

                    BatchCycle = GetPrivateProfileInt("BATCH","CYCLE",1,IniFileName);

                    if(NULL != strstr(TestTypeEntry, "ALL"))
                    {
                        TestType = ALL;
                    }
                    else if(NULL != strstr(TestTypeEntry, "QUICK"))
                    {
                        TestType = QUICK;
                    }
                    else if(NULL != strstr(TestTypeEntry, "TEXT"))
                    {
                        TestType = TEXT_SUITE;
                    }
                    else if(NULL != strstr(TestTypeEntry, "SELECT"))
                    {
                        TestType = SELECT;
                    }
                    else
                    {
                        MessageBox(hWnd,"Invalid or No Test-Type Entry in GDIBATCH.INI File", "INI File Error",MB_ICONSTOP|MB_OK);
                        BatchFlag = FALSE;
                        break;
                    }

//                    switch (TestType)
//                    {
//                        case ALL:                   // Run all tests
                        if(TestType == ALL)
                        {
                            fclose(fpIniFile);
                            OutFileName = SelectOutFileName(hWnd);
                            if(NULL == OutFileName)
                            {
                                BatchFlag = FALSE;
                                break;
                            }
                            fpOutFile = fopen(OutFileName, "w+");

                            for(i=0; i < BatchCycle; i++)
                            {
                                SendMessage(hWnd,WM_COMMAND,IDM_RUN,0L);
                                WriteBatchResults(fpOutFile, TestType, i+1);
                            }

                            fclose(fpOutFile);

                            if(Finish_Message == TRUE)
                            {
                                strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                strcat(txtbuf,OutFileName);
                                MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                            }

                            if(Dont_Close_App == TRUE)
                            {
                                BatchFlag = FALSE;
                                for(i=0; i<(int)NUM_TESTS; i++)
                                {
                                    gTestEntry[i].Result = 0;
                                }
                            }
                            else
                            {
                                SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                            }

                        }

//                        break;

//                        case QUICK:                 // Run the quick suite
                        else if (TestType == QUICK)
                        {

                            fclose(fpIniFile);

                            OutFileName = SelectOutFileName(hWnd);

                            fpOutFile = fopen(OutFileName, "w+");
                            if(NULL == fpOutFile)
                            {
                                BatchFlag = FALSE;
                                break;
                            }

                            for(i=0; i < BatchCycle; i++)
                            {
                                SendMessage(hWnd,WM_COMMAND,IDM_QRUN,0L);
                                WriteBatchResults(fpOutFile, TestType, i+1);
                            }

                            fclose(fpOutFile);

                            if(Finish_Message == TRUE)
                            {
                                strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                strcat(txtbuf,OutFileName);
                                MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                            }

                            if(Dont_Close_App == TRUE)
                            {
                                BatchFlag = FALSE;
                                for(i=0; i<(int)NUM_TESTS; i++)
                                {
                                    gTestEntry[i].Result = 0;
                                }
                            }
                            else
                            {
                                SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                            }

                        }
//                        break;

//                        case TEXT_SUITE:                    // Get some more keys then run the text suite
                        else if ((TestType == TEXT_SUITE) || (TestType == SELECT))
                        {

                            n = GetPrivateProfileString("TEXT","FONT","Arial",txtbuf,sizeof(txtbuf),IniFileName);

                            i = 0;

                            do
                            {
                                sscanf(&txtbuf[i],"%1c",tst);
                                ++i;
                            }
                            while((i <= n ) && (tst[0] != ',') && (tst[0] != ';'));

                            strncpy(&SelectedFont[0],&txtbuf[0],i-1);
                            strcpy(&SelectedFont[i-1],"\0");

                            if(NULL != strstr(&txtbuf[i], "BOLD"))
                            {
                                SelectedFontBold = TRUE;
                            }

                            if(NULL != strstr(&txtbuf[i], "ITALIC"))
                            {
                                SelectedFontItalic = TRUE;
                            }

                            if(NULL != strstr(&txtbuf[i], "UNDERLINE"))
                            {
                                SelectedFontUnderline = TRUE;
                            }

                            if(NULL != strstr(&txtbuf[i], "STRIKE"))
                            {
                                SelectedFontStrike = TRUE;
                            }

                            if(NULL != strstr(&txtbuf[i], "TRANSPARENT"))
                            {
                                SelectedFontTransparent = TRUE;
                            }

                            kptr = strstr(&txtbuf[0], "RGB(");   // Parse and interpret the RGB values if exist
                            if(NULL != kptr)
                            {
                                sscanf(kptr+4,"%s",tmpbuf[0]);

                                FontRed     = 0;
                                FontGreen   = 0;
                                FontBlue    = 0;

                                j = 0;

                                sscanf(&tmpbuf[0][j],"%1c",tst);

                                while(tst[0] == ' ')
                                {
                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                }
                                while(tst[0] != ',')
                                {
                                    FontRed = 10*FontRed + atoi(tst);
                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                }

                                ++j;
                                sscanf(&tmpbuf[0][j],"%1c",tst);
                                while(tst[0] == ' ')
                                {
                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                }
                                while(tst[0] != ',')
                                {
                                    FontGreen = 10*FontGreen + atoi(tst);
                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                }

                                ++j;
                                sscanf(&tmpbuf[0][j],"%1c",tst);
                                while(tst[0] == ' ')
                                {
                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                }
                                while(tst[0] != ')')
                                {
                                    FontBlue = 10*FontBlue + atoi(tst);
                                    ++j;
                                    sscanf(&tmpbuf[0][j],"%1c",tst);
                                    if(tst[0] == ' ')break;
                                }

                                SelectedFontColor = RGB(FontRed, FontGreen, FontBlue);
                            }

                            k = GetPrivateProfileString("TEXT","STRING_CONTENT",DEFAULT_A_STRING,strbuf,sizeof(strbuf),IniFileName);

                            strncpy(SourceString,strbuf,(size_t)k);
                            Source_String_Length = k;

                            MultiByteToWideChar(CP_ACP|CP_OEMCP,0,SourceString,-1,SourceStringW,sizeof(SourceStringW));

                            for(j=0; j<2; j++)
                                Text_Test_Order[j] = 0;

                            GetPrivateProfileString("RUN","ORDER","FONT_SIZE, STRING_LENGTH",txtbuf,sizeof(txtbuf),IniFileName);
                            if(strstr(txtbuf,"STRING_LENGTH") > strstr(txtbuf,"FONT_SIZE"))
                            {
                                Text_Test_Order[0] = 1;
                                Text_Test_Order[1] = 2;
                            }
                            else
                            {
                                Text_Test_Order[0] = 2;
                                Text_Test_Order[1] = 1;
                            }

                            k = GetPrivateProfileString("RUN","STRING_LENGTH","32",txtbuf,sizeof(txtbuf),IniFileName);
                            No_String_Lengths = Std_Parse(txtbuf, k, StringLength);

                            if(No_String_Lengths==0)
                            {
                                MessageBox(hWnd,"Invalid or No String Length Entry in GDIBATCH.INI File", "INI File Error",MB_ICONSTOP|MB_OK);
                                BatchFlag = FALSE;
                                break;
                            }

                            k = GetPrivateProfileString("RUN","FONT_SIZE","10",txtbuf,sizeof(txtbuf),IniFileName);
                            No_Font_Sizes = Std_Parse(txtbuf, k, FontSize);

                            if(No_Font_Sizes==0)
                            {
                                MessageBox(hWnd,"Invalid or No Font Size Entry in GDIBATCH.INI File", "INI File Error",MB_ICONSTOP|MB_OK);
                                BatchFlag = FALSE;
                                break;
                            }

////
                            if( TestType == SELECT)
                            {
                               k = GetPrivateProfileString("BATCH","TEST","0",txtbuf,sizeof(txtbuf),IniFileName);
                               fclose(fpIniFile);

                               Num_Selected_Tests = Std_Parse(txtbuf, k, Test_Item);

                               if(Num_Selected_Tests == 0)
                               {
                                   MessageBox(hWnd,"Invalid Test-Number Entry in GDIBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                                   BatchFlag = FALSE;
                                   break;
                               }

                               for(i=0; i<Num_Selected_Tests; i++)
                               {
                                   if(Test_Item[i] > (int)NUM_TESTS)
                                   {
                                       MessageBox(hWnd,"Invalid Test-Number Entry in GDIBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                                       BatchFlag = FALSE;
                                       break;
                                   }
                               }
							}


							NumFonts = GetPrivateProfileInt("RUN","NUM_FONTS",1,IniFileName);
							if(NumFonts == 0)NumFonts = 1; // Guaranty at least one (default) font

							if(NumFonts > 1)  // If NumFonts is 1 user need not supply [FACE_NAMES] data, the info in FONT= will do
							{
							   GetPrivateProfileString("FACE_NAMES","FONT_NAMES","Arial",FaceNameBuf,sizeof(FaceNameBuf),IniFileName);
                               l = String_Parse(FaceNameBuf,lstrlen(FaceNameBuf),(char *)FaceName);
                               if(l != NumFonts)MessageBox(hWnd,"Number of Fonts Found Doesn't Match Declaration", "INI File Error",MB_ICONSTOP|MB_OK);
							}
                            else
							{
							   lstrcpy(FaceName[0],SelectedFont);
							}
// FirstFontChar set to 0 by default in the following:
                            FirstFontChar = GetPrivateProfileInt("FACE_NAMES","FIRST_FONT_CHARACTER",0,IniFileName);

                            fclose(fpIniFile);

// Auto Select an output file name

                               OutFileName = SelectOutFileName(hWnd);
                               fpOutFile = fopen(OutFileName, "w+");
                               if(NULL == OutFileName)
                               {
                                   MessageBox(hWnd,"Could not Open an Output File, Batch Mode Halted", "Output Open File Error",MB_ICONSTOP|MB_OK);
                                   BatchFlag = FALSE;
                                   break;
                               }

// Start Font Face Names Loop

                            for (l=0; l<NumFonts; l++)
							{

							   lstrcpy(SelectedFont,FaceName[l]);

// Initialize the LOGFONT struct

                               lf.lfWidth          = 0;
                               lf.lfEscapement     = 0;
                               lf.lfOrientation    = 0;
                               lf.lfWeight         = (SelectedFontBold == FALSE)? 400 : 700;
                               lf.lfItalic         = SelectedFontItalic;
                               lf.lfUnderline      = SelectedFontUnderline;
                               lf.lfStrikeOut      = SelectedFontStrike;
                               lf.lfCharSet        = ANSI_CHARSET;
                               lf.lfOutPrecision   = OUT_DEFAULT_PRECIS;
                               lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS;
                               lf.lfQuality        = DEFAULT_QUALITY;
                               lf.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
                               lstrcpy(&lf.lfFaceName[0],&SelectedFont[0]);

// Get some necessary font information for the present screen to be able to determine its height

                               hdc2 = GetDC(hWnd);
                               GetTextFace(hdc2, sizeof(SelectedFont), &SelectedFont[0]);
                               VPixelsPerLogInch = GetDeviceCaps(hdc2, LOGPIXELSY);
                               ReleaseDC(hWnd,hdc2);

// Some more font initialization

                               cf.lStructSize      = sizeof (CHOOSEFONT);
                               cf.hwndOwner        = hWnd;
                               cf.lpLogFont        = &lf;
                               cf.Flags            = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT;
                               cf.nFontType        = SCREEN_FONTTYPE;
                               cf.rgbColors        = SelectedFontColor;


// Execute Text Suite, Depending on the Predefined Order of Loops

                               if(Text_Test_Order[1] == 1)
                               {

                                   for(i = 0; i < No_String_Lengths; i++)
                                   {
                                       StrLen = StringLength[i];
                                       String_Length_Warn = (StrLen <= (size_t)Source_String_Length)? FALSE : TRUE;
                                       strcpy(&DestString[StrLen],"\0");
                                       pszTest =(PSZ) strncpy(&DestString[0], SourceString, StrLen);
                                       pwszTest = (PWSTR) wcsncpy(&DestStringW[0], SourceStringW, StrLen);

                                       for(j = 0; j < No_Font_Sizes; j++)
                                       {
                                           lf.lfHeight = -MulDiv(FontSize[j], VPixelsPerLogInch, POINTS_PER_INCH);
                                           cf.iPointSize = 10*FontSize[j];  // Point Size is in 1/10 of a point

                                           if(TestType == TEXT_SUITE)
                                           {
                                              for(k=0; k < BatchCycle; k++)
                                              {
                                                  SendMessage(hWnd,WM_COMMAND,IDM_TEXT_QRUN,0L);
                                                  WriteBatchResults(fpOutFile, TestType, k+1);
                                              }
                                           }

                                           if(TestType == SELECT)
	    								   {
                                              for(k=0; k < Num_Selected_Tests; k++)
                                              {
                                                  SendMessage(hWnd,WM_COMMAND,ID_TEST_START+Test_Item[k],0L);
                                              }

                                              WriteBatchResults(fpOutFile, TestType, k);
										
									       }

                                      }

                                  }               //for

                               }               //endif

                               else
                               {

                                   for(i = 0; i < No_Font_Sizes; i++)
                                   {

                                       lf.lfHeight = -MulDiv(FontSize[i], VPixelsPerLogInch, POINTS_PER_INCH);
                                       cf.iPointSize = 10*FontSize[i];  // Point Size is in 1/10 of a point

                                       for(j = 0; j < No_String_Lengths; j++)
                                       {
                                           StrLen = StringLength[j];
                                           String_Length_Warn = (StrLen <= (size_t)Source_String_Length)? FALSE : TRUE;
                                           strcpy(&DestString[StrLen],"\0");
                                           pszTest =(PSZ) strncpy(&DestString[0], SourceString, StrLen);
                                           pwszTest = (PWSTR) wcsncpy(&DestStringW[0], SourceStringW, StrLen);


                                           if(TestType == TEXT_SUITE)
                                           {
                                              for(k=0; k < BatchCycle; k++)
                                              {
                                                  SendMessage(hWnd,WM_COMMAND,IDM_TEXT_QRUN,0L);
                                                  WriteBatchResults(fpOutFile, TestType, k+1);
                                              }
                                           }
										   if(TestType == SELECT)
										   {
                                              for(k=0; k < Num_Selected_Tests; k++)
                                              {
                                                 SendMessage(hWnd,WM_COMMAND,ID_TEST_START+Test_Item[k],0L);
                                              }

                                              WriteBatchResults(fpOutFile, TestType, k);
                                           }
                                       }

                                   }               //for

                               }                //else

                            }                // FaceName Loop
// Cleanup
                            fclose(fpOutFile);

                            if(Finish_Message == TRUE)
                            {
                                strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                strcat(txtbuf,OutFileName);
                                MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                            }

                            if(Dont_Close_App == TRUE)// App Stays Open, Check Appropriate Menu Items for Last Selection
                            {
                                HMENU hmenu = GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0);
                                if(SelectedFontTransparent == TRUE)
                                {
                                    CheckMenuItem(hmenu,2,MF_BYPOSITION|MF_CHECKED);
                                }

                                if(StrLen == 1)i=0;
                                else if(StrLen ==     2)i=1;
                                else if(StrLen ==     4)i=2;
                                else if(StrLen ==     8)i=3;
                                else if(StrLen ==    16)i=4;
                                else if(StrLen ==    32)i=5;
                                else if(StrLen ==    64)i=6;
                                else if(StrLen ==   128)i=7;
                                else
                                {
                                    i = 8;                         // "Other" non-standard menu selection
                                }
                                Last_Checked = SyncMenuChecks(hWnd, Last_Checked, i);

                                BatchFlag = FALSE;
                                for(i=0; i<(int)NUM_TESTS; i++)
                                {
                                    gTestEntry[i].Result = 0;
                                }

                            }
                            else
                            {
                                SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                            }

                        }             //case TEXT_SUITE

//                        break;
/*
                        case SELECT:        // Read some more keys then run the selected test suite
                        {

                            k = GetPrivateProfileString("BATCH","TEST","0",txtbuf,sizeof(txtbuf),IniFileName);
                            fclose(fpIniFile);

                            Num_Selected_Tests = Std_Parse(txtbuf, k, Test_Item);

                            if(Num_Selected_Tests == 0)
                            {
                                MessageBox(hWnd,"Invalid Test-Number Entry in GDIBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                                BatchFlag = FALSE;
                                break;
                            }

                            for(i=0; i<Num_Selected_Tests; i++)
                            {
                                if(Test_Item[i] > (int)NUM_TESTS)
                                {
                                    MessageBox(hWnd,"Invalid Test-Number Entry in GDIBATCH.INI File ", "INI File Error",MB_ICONSTOP|MB_OK);
                                    BatchFlag = FALSE;
                                    break;
                                }
                            }

                            OutFileName = SelectOutFileName(hWnd);
                            if(NULL == OutFileName)
                            {
                                BatchFlag = FALSE;
                                break;
                            }
                            fpOutFile = fopen(OutFileName, "w+");

                            for(j=0; j < BatchCycle; j++)
                            {
                                for(i=0; i < Num_Selected_Tests; i++)
                                {
                                    SendMessage(hWnd,WM_COMMAND,ID_TEST_START+Test_Item[i],0L);
                                }

                                WriteBatchResults(fpOutFile, TestType, i+1);
                            }

                            fclose(fpOutFile);

                            if(Finish_Message == TRUE)
                            {
                                strcpy(txtbuf,"Batch Job Finished Successfully, Results Written to ");
                                strcat(txtbuf,OutFileName);
                                MessageBox(hWnd,txtbuf, "Batch Job Finished",MB_ICONINFORMATION|MB_OK);
                            }

                            if(Dont_Close_App == TRUE)
                            {
                                BatchFlag = FALSE;
                                for(i=0; i<(int)NUM_TESTS; i++)
                                {
                                    gTestEntry[i].Result = 0;
                                }
                            }
                            else
                            {
                                SendMessage(hWnd,WM_COMMAND,IDM_EXIT,0L);
                            }

                        }
                        break;

                    }       // switch TestType
*/
                }           //else (RUN_BATCH - OK to Proceed)

            }               // case RUN_BATCH
            break;

            //
            // run a single selected test (interactive mode)
            //

            default:

                {
                    ULONG Test = LOWORD(wParam) - ID_TEST_START;
                    ULONG Index;
                    PFN_MS pfn;
                    RECT CliRect = {0,0,10000,10000};
                    HDC hdc = GetDC(hWnd);
                    FillRect(hdc,&CliRect,GetStockObject(GRAY_BRUSH));

                    if (Test < NUM_TESTS)
                    {
						ULONG Iter = 1;
                        HDC hdc2 = GetDC(hWnd);

                        wsprintf(tmsg,"Testing %s",gTestEntry[Test].Api);
                        TextOut(hdc,20,20,tmsg,strlen(tmsg));

                        pfn = gTestEntry[Test].pfn;
                        ShowCursor(FALSE);

                        hfont = CreateFontIndirect(cf.lpLogFont);
                        hfontOld = SelectObject(hdc2, hfont);
                        crOld = SetTextColor(hdc2, cf.rgbColors);
                        if(SelectedFontTransparent)SetBkMode(hdc2,TRANSPARENT);
////// Statistics
                        Index = Test;

                        for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                            ETime[Index][eventloop] = 0;
                            ECount[Index][eventloop] = 0;
                        }

                        for(j=0; j<NUM_SAMPLES; j++)
                        {
                            GdiFlush();

                            Sample[j] = (double)(*pfn)(hdc2,gTestEntry[Index].Iter);
                            Detailed_Data[Index][j] = (long)(0.5 + Sample[j]);
                            PageFaultData[Index][j] = PageFaults;
	     					PagesReadData[Index][j] = PagesRead;
                            if(Per_Test_CPU_Event_Flag == TRUE)
                                for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                                    Get_CPUDump(eventloop, &NewETime, &NewECount);
                                    ETime[Index][eventloop] += NewETime;
                                    ECount[Index][eventloop] += NewECount;
                                }

                        }

                        Get_Stats(Sample,NUM_SAMPLES,HI_FILTER,VAR_LIMIT,&TestStats[Index]);
                        for (eventloop=0; (gfCPUEventMonitor) && (eventloop<MAX_EVENTS); eventloop++) {
                            ETime[Index][eventloop] /= NUM_SAMPLES;
                            ECount[Index][eventloop] /= NUM_SAMPLES;
                        }
///////
						Per_Test_CPU_Event_Flag = FALSE; // reset for next test
                        ShowCursor(TRUE);

                        SetTextColor(hdc2, crOld);
                        SelectObject(hdc2, hfontOld);
                        DeleteObject(hfont);
                        SetBkMode(hdc2, OPAQUE);

                        ReleaseDC(hWnd,hdc2);

                    }

                    ReleaseDC(hWnd,hdc);
                }

            }       // SWITCH CASE


            if(BatchFlag == FALSE)               // Initialize Test Strings (interactive mode)
            {
                strcpy(&DestString[StrLen],"\0");
                pszTest =(PSZ) strncpy(&DestString[0], SourceString, StrLen);
                pwszTest = (PWSTR) wcsncpy(&DestStringW[0], SourceStringW, StrLen);
            }

        }       // WM_COMMAND
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd,&ps);
            EndPaint(hWnd,&ps);
        }
        break;

    case WM_DESTROY:

            if (GetVersionEx(&Win32VersionInformation))
               if(WINNT_PLATFORM)
  	                {
				       FreeLibrary(hLibrary);
				    }

            PostQuitMessage(0);
            break;

    default:

        //
        // Passes message on if unproccessed
        //

        return (DefWindowProc(hWnd, msg, wParam, lParam));
    }

/* Calculate Timer Frequency For Current Machine and Convert to MicroSeconds (Actual time will be presented in units of 100ns) */

    Status = QueryPerformanceFrequency((LARGE_INTEGER *)&PerformanceFreq);
    if(Status){
           PerformanceFreq /= 1000000;
    }
    else
    {
            MessageBox(NULL, "High Resolution Performance Counter"
                "Doesn't Seem to be Supported on This Machine",
                "Warning", MB_OK | MB_ICONEXCLAMATION);
            PerformanceFreq = 1;                /* To Prevent Possible Div by zero later */
    }


    return 0;
}


/*++

Routine Description:

    Save results to file

Arguments

    none

Return Value

    none

--*/

VOID
SaveResults()
{
    static OPENFILENAME ofn;
    static char szFilename[80];
    char szT[80];
    int i, hfile;
    FILE *fpOut;

    BatchFlag = FALSE;

    for (i = 0; i < sizeof(ofn); i++)
    {
        //
        // clear out the OPENFILENAME struct
        //

        ((char *)&ofn)[i] = 0;
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWndMain;
    ofn.hInstance = hInstMain;

    ofn.lpstrFilter = "GdiBench (*.cs;*.km)\0*.cs;*.km\0All Files\0*.*\0\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = "C:\\";
    ofn.Flags = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    lstrcpy(szFilename, "GDIB001.km");

    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = sizeof(szFilename);
    ofn.lpstrTitle = "Save As";

    if (!GetSaveFileName(&ofn))
    {
        return;
    }

    fpOut = fopen(szFilename, "w+");
    if(NULL != fpOut)
    {
        WriteBatchResults(fpOut,0,0);
        fclose(fpOut);
    }
    else
    {
        MessageBox(hWndMain,"Cannot Open File to Save Results", "Output File Creation Error",MB_ICONSTOP|MB_OK);
    }

}


/*++

Routine Description:

    Show results  (Interactive Mode Dialog)

Arguments

    Std dlg

Return Value

    Status

--*/

BOOL
APIENTRY
ResultsDlgProc(
    HWND hwnd,
    UINT msg,
    UINT wParam,
    LONG lParam)
{
    ULONG ix;
    char szT[180];
    BOOL fResults;
    int aiT[2];

    switch (msg) {
    case WM_INITDIALOG:
        aiT[0] = 100;
        aiT[1] = 190;
        fResults = FALSE;

        {
            LV_COLUMN lvc;
            LV_ITEM lvl;
            UINT width;
            RECT rc;
            HWND hwndList = GetDlgItem(hwnd, IDC_RESULTSLIST);
            int i;
            static LPCSTR title[] = {
                "Function", "Time(100ns)", "StdDev%", "Best", "Worst",
                "Valid Samples", "Out of", "Iterations",
            };
#ifdef _X86_
            if (gfPentium)
                title[1] = "Cycle Counts";
#endif
            if (hwndList == NULL)
                break;
            GetClientRect(hwndList, &rc);
            // only first column has doubled width
            lvc.cx = (width = (rc.right - rc.left) / (sizeof title / sizeof *title + 1)) * 2;
            lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt = LVCFMT_LEFT;
            for (i = 0; i < sizeof title / sizeof *title; ++i) {
                lvc.pszText = (LPSTR)title[i];
                ListView_InsertColumn(hwndList, i, &lvc);
                lvc.cx = width;     // normal width
            }

            lvl.iItem = 0;
            lvl.mask = LVIF_TEXT;
            for (ix = 0; ix < NUM_TESTS; ix++) {
                if ((long)(0.5 + TestStats[ix].Average) == 0) {
                    // no measuement, skip
                    continue;
                }
                lvl.iSubItem = 0;
                lvl.pszText = gTestEntry[ix].Api;
                ListView_InsertItem(hwndList, &lvl);
#define SUBITEM(fmt, v) \
                sprintf(szT, fmt, v); \
                ListView_SetItemText(hwndList, lvl.iItem, ++lvl.iSubItem, szT);

                SUBITEM("%ld", (long)(0.5 + TestStats[ix].Average));
                SUBITEM("%.2f", (float)TestStats[ix].StdDev);
                SUBITEM("%ld", (long)(0.5 + TestStats[ix].Minimum_Result));
                SUBITEM("%ld", (long)(0.5 + TestStats[ix].Maximum_Result));
                SUBITEM("%ld", TestStats[ix].NumSamplesValid);
                SUBITEM("%ld", (long)NUM_SAMPLES);
                SUBITEM("%ld", gTestEntry[ix].Iter);
#undef SUBITEM
                ++lvl.iItem;
                fResults = TRUE;
            }

            if (!fResults)
                MessageBox(hwnd, "No results have been generated yet or Test may have failed!",
                    "UsrBench", MB_OK | MB_ICONEXCLAMATION);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        case IDM_SAVERESULTS:
            SaveResults();
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

    SelectOutFileName  - Select the next output file name (batch mode)

Arguments

    HWND hWnd

Return Value

    char *OutFileName

--*/

char *
SelectOutFileName(HWND hWnd)

{

    static char buf[11];
    char buf2[4];
    FILE *fpFile;
    int i;

    lstrcpy(buf,"gdb");

    for (i=1; i<201; i++)   // Allow for up to 200 output files to exist in current directory
    {
      sprintf(&buf[3],"%03s.gdi",_itoa(i,buf2,10));

      fpFile = fopen(&buf[0],"r");  // Try to open for read, if succeeds the file already exists
                                    //                       if fails, thats the next file selected
      if(NULL != fpFile)
      {
        fclose(fpFile);
        continue;
      }
      return buf;
    }

    MessageBox(hWnd,"Cannot Continue, Limit of 200 gdbxxx.gdi Output Files Exceeded, Please Clean Up! ", "Output File Creation Error",MB_ICONSTOP|MB_OK);
    return NULL;
}


/*++

Routine Description:

    WriteBatchResults - Save Batch results to file

Arguments

    FILE *fpOutFile
    int  TestType

Return Value

    none

--*/


void WriteBatchResults(FILE *fpOut, int TestType, int cycle)
{
    char szT[180];
    MEMORYSTATUS MemoryStatus;
    char ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    int SizBuf = MAX_COMPUTERNAME_LENGTH + 1;
    int i,j;
    ULONG ix;
    char *pszOSName;
    ULONG ixStart = 0;
    ULONG ixEnd  = NUM_TESTS;

    if(TEXT_SUITE == TestType){
    ixStart = FIRST_TEXT_FUNCTION;
    ixEnd  = LAST_TEXT_FUNCTION + 1;
    }


    /*
     * Write out the build information and current date.
     */
    Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);
    if (GetVersionEx(&Win32VersionInformation))
    {
        switch (Win32VersionInformation.dwPlatformId)
        {
            case VER_PLATFORM_WIN32s:
                pszOSName = "WIN32S";
                break;
            case VER_PLATFORM_WIN32_WINDOWS:
                pszOSName = "Windows 95";
                break;
            case VER_PLATFORM_WIN32_NT:
                pszOSName = "Windows NT";
                break;
            default:
                pszOSName = "Windows ???";
                break;
        }

        GetComputerName(ComputerName, &SizBuf);
        wsprintf(szT, "\n\n///////////////   ");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "%s Version %d.%d Build %d ", pszOSName,
        Win32VersionInformation.dwMajorVersion,
        Win32VersionInformation.dwMinorVersion,
        Win32VersionInformation.dwBuildNumber);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        MemoryStatus.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus(&MemoryStatus);

        wsprintf(szT, "Physical Memory = %dKB   ////////////////\n", MemoryStatus.dwTotalPhys/1024);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT,"\nComputer Name = %s", ComputerName);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

    }

    wsprintf(szT, "\n\nMaximum Variation Coefficient (Standard Deviation/Average) Imposed on Test Data = %d %%", VAR_LIMIT);
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    wsprintf(szT, "\n\nBest and Worst Cycle or Time Counts per Call are Unprocessed Values", VAR_LIMIT);
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);


    if(BatchFlag == TRUE)
    {
        wsprintf(szT, "\n\nBatch Cycle No. %d Out of %d Cycles", cycle, BatchCycle );
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    }
    else
    {
        wsprintf(szT, "\n\nResults of interactive mode session;");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    }

    if(TEXT_SUITE == TestType || TRUE == TextSuiteFlag || SELECT == TestType){
        wsprintf(szT, "\n\nFor Text Function Suite:\n\nTest String Length (or Number of Font Characters) = %d Characters", StrLen);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nString Used=   %s", DestString);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        if(String_Length_Warn == TRUE)
        {
            wsprintf(szT, "\n!!!WARNING: One or More String Lengths Specified in INI File \n           is Longer than Supplied or Default Source String");
            fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
        }

        wsprintf(szT, "\nFont name = %s, Font Size = %d", &lf.lfFaceName[0], cf.iPointSize/10);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nFont Weight = %ld (400 = Normal, 700 = Bold)",lf.lfWeight);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (lf.lfItalic != FALSE)?wsprintf(szT,"\nItalic = TRUE"):wsprintf(szT,"\nItalic = FALSE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (lf.lfUnderline==TRUE)?wsprintf(szT,"\nUnderline = TRUE"):wsprintf(szT,"\nUnderline = FALSE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (lf.lfStrikeOut==TRUE)?wsprintf(szT,"\nStrikeOut = TRUE"):wsprintf(szT,"\nStrikeOut = FALSE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        (SelectedFontTransparent==TRUE)?wsprintf(szT,"\nTransparent Background = TRUE"):wsprintf(szT,"\nOpaque Background = TRUE");
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nColor Used: RED = %d, GREEN = %d, BLUE = %d", (unsigned char)cf.rgbColors, (unsigned char)(cf.rgbColors>>8), (unsigned char)(cf.rgbColors>>16) );
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "\nFirst Font Character Used = %d (For FONT Related Calls)", FirstFontChar );
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);


   }

#ifdef _X86_
    //
    // Print the Names of the event monitored
    // Needs to detect CPU for Pentium or up later
    // a-ifkao
    //
    if(gfCPUEventMonitor) {
        wsprintf(szT, "\nThe CPU Events monitored are <%s> and <%s>",PerfName[0], PerfName[1]);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    }
#endif

    if(TEXT_SUITE == TestType || TRUE == TextSuiteFlag || SELECT == TestType)
      {
#ifdef _X86_
                if(gfPentium){
                    if (gfCPUEventMonitor)
                        lstrcpy(szT, "\n\n  Function\t\t Cycle Counts \tStdDev%\tBest \t Worst \t Valid Samples \t Out of\tIterations  StrLen \t Font Size   Font Name\tETime 1\tECount 1\tETime 2\tECount 2\n\n");
                    else
                       	lstrcpy(szT, "\n\n  Function\t\t Cycle Counts \tStdDev%\tBest \t Worst \t Valid Samples \t Out of\tIterations  StrLen \t Font Size   Font Name\n\n");
                }
                else
#endif
                    lstrcpy(szT, "\n\n  Function\t\tTime (100 ns) \tStdDev%\tBest \t Worst \t Valid Samples \t Out of\tIterations  StrLen \t Font Size   Font Name\n\n");
      }
    else
      {
#ifdef _X86_
                if(gfPentium){
                    if (gfCPUEventMonitor)
                        lstrcpy(szT, "\n\n  Function\t\t Cycle Counts \tStdDev% \t Best \t Worst \t Valid Samples \t Out of \t Iterations\tETime 1\tECount 1\tETime 2\tECount 2\n\n");
                    else
				        lstrcpy(szT, "\n\n  Function\t\t Cycle Counts \tStdDev% \t Best \t Worst \t Valid Samples \t Out of \t Iterations\n\n");
                }
                else
#endif
                    lstrcpy(szT, "\n\n  Function\t\tTime (100 ns) \tStdDev% \t Best \t Worst \t Valid Samples \t Out of \t Iterations\n\n");

      }

    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

    for (ix = ixStart; ix < ixEnd; ix++) {

        if(TEXT_SUITE == TestType || TRUE == TextSuiteFlag || SELECT == TestType)
        {
#ifdef _X86_
            if(gfPentium) {
              if (gfCPUEventMonitor)
                sprintf(szT,
                   "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%s,%I64d\t,%I64d\t,%I64d\t,%I64d\n",
                   (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter,
                                StrLen,
                                cf.iPointSize / 10,
                                &lf.lfFaceName[0],
                                ETime[ix][0],
					            ECount[ix][0],
                                ETime[ix][1],
					            ECount[ix][1]);
                else
                    sprintf(szT,
                      "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%s\n",
                                (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter,
                                StrLen,
                                cf.iPointSize / 10,
                                &lf.lfFaceName[0]);

            } // Pentium CPU
            else
#endif			

            sprintf(szT,
                   "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%s\n",
                   (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter,
                                StrLen,
                                cf.iPointSize / 10,
                                &lf.lfFaceName[0]);


        }	 //if( TEXT || SELECT)
        else
        {
#ifdef _X86_
            if(gfPentium) {
              if (gfCPUEventMonitor)
                  sprintf(szT,
                   "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%I64d\t,%I64d\t,%I64d\t,%I64d\n",
                   (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter,
                                ETime[ix][0],
					            ECount[ix][0],
                                ETime[ix][1],
					            ECount[ix][1]);
                else
                    sprintf(szT,
                       "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t,%6ld\t,%6ld\n",
                                (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter);

            } // if Pentium

            else
#endif

            sprintf(szT,
                   "%-30s\t,%6ld\t,%6.2f\t,%6ld\t,%6ld\t,%6ld\t\t,%6ld\t,%6ld\n",
                   (LPSTR)gTestEntry[ix].Api,
                                (long)(0.5 + TestStats[ix].Average),
                                (float)TestStats[ix].StdDev,
                                (long)(0.5 + TestStats[ix].Minimum_Result),
                                (long)(0.5 + TestStats[ix].Maximum_Result),
                                TestStats[ix].NumSamplesValid,
                                (long)NUM_SAMPLES,
                                gTestEntry[ix].Iter);
        } //else

        if((long)(0.5 + TestStats[ix].Average) != 0)
        {
            BOOL Suspicious = ((float)(NUM_SAMPLES - TestStats[ix].NumSamplesValid)/(float)NUM_SAMPLES > 0.05F)? TRUE:FALSE;
            fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
            if((Print_Detailed == TRUE) || Suspicious){
                if(Suspicious){
                   sprintf(szT,"\nThe Last Test Had More Than 5 Percent of Its Samples Filtered Out;\n\n");
                   fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
                }

                sprintf(szT,"Here Is a Detailed Distribution of the Samples:\n\n");
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                for(j = 0; j < NUM_SAMPLES; j++)
                {
                    if((j+1)%10)
                        sprintf(szT,"%d\t",Detailed_Data[ix][j]);
                    else
                        sprintf(szT,"%d\n",Detailed_Data[ix][j]);

                    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
                }
                sprintf(szT,"\n");
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                if(WINNT_PLATFORM)
                {
                   sprintf(szT,"Page Faults / Pages Read Information For Each Sample:\n\n");
                   fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                   for(j = 0; j < NUM_SAMPLES; j++)
                   {
                       if((j+1)%10)
                           sprintf(szT,"%d / %d\t",PageFaultData[ix][j],PagesReadData[ix][j]);
                       else
                           sprintf(szT,"%d / %d\n",PageFaultData[ix][j],PagesReadData[ix][j]);

                       fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
                   }
                   sprintf(szT,"\n");
                   fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
                }
/*
////// Debug Output:

                wsprintf(szT, "\n\nSpecial_Data1 = %d Cycles\nSpecial_Data2 = %d Cycles\n\n", Special_Data1, Special_Data2);
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
                wsprintf(szT, "\n\nSpecial_Data3 = %d Cycles\nSpecial_Data4 = %d Cycles\n\n", Special_Data3, Special_Data4);
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                wsprintf(szT, "\n\nCharacter Widths:\n");
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                for(j = 0; j < 256; j++)
				{
                   if((j+1)%16)
                      sprintf(szT, "%d\t",Widths[j]);
  				   else
                      sprintf(szT, "%d\n",Widths[j]);
				
                   fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

                }
*/

            }
        }
        else {				                     // Warn if no results are produced
                if(TestType == ALL || TestType == QUICK || TestType == TEXT_SUITE)
			    {
                    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
//                    fputs("!!! !!! !!! Pay attention to the last API !!! !!! !!!\n", fpOut);
                }
        }

    }

    if(TRUE == TextSuiteFlag)TextSuiteFlag = FALSE;
}

/*++

Routine Description:

    ShowHelp - Write Help Contents to Client Area

Arguments

    HWND hwnd

Return Value

    none

--*/

BOOL
APIENTRY
HelpDlgProc(
    HWND hwnd,
    UINT msg,
    UINT wParam,
    LONG lParam)
{
    ULONG ix, last_ix;
    static const char* szT[] = {
        "Usage:",
        "",
        "gdibench (interactive mode), or ",
        "gdibench /b (batch mode)",
        "         /d (Batch and Interactive Mode (When Saved); Print detailed distribution of all samples)",
        "             Note: In Interactive Mode, one needs to run with /d to save I/O information for each sample where available",
        "",
        "         /m (Message when batch finished)",
        "         /s (Stay, don't close application when batch finished)",
        "         /t (Batch and Interactive Modes; Measure test time - not Cycle Counts, on Pentium Machines)",
        "         /i [INI filename] (optional, def.= GDIBATCH.INI )",
        "         /z (Batch and Interactive Modes; Disable GDI Batching)",
		"         /p (Batch and Interactive Modes; Enable CPU Event Monitoring on P5-P6 processors running WINNT for the following events",
		"         /c [Event Name1][Event Name2] (Batch and Interactive Modes; Monitor the CPU Events Specified;",
		"                                        Notes: 1. Code TLB Misses are monitored by default if there is no /c option;",
		"                                               2. Two names are mandatory if /c is used.",
		"                                               3. List of Event Names for P5 and P6 Processors can be found in the corresponding",
		"                                                  files P5.c and P6.c located in \\sdktools\\pperf\\driver\\i386 ",
        "                                               4. Registry file P5perf.reg (from sdktools\\pperf)needs to be imported",
        "                                                  and pstat.sys needs to be installed in \\system32\\drivers for the CPU event",
        "                                                  monitoring to take place.",
		"",
        "Batch Mode requires preparing an INI file (default: GDIBATCH.INI) in the same directory where the application is being run.",
        "You may also specify an INI filename using /i [INI filename] in the command line (must reside in the directory mentioned above).",
        "",
        "_______________",
		"",
        "INI file Sections and Keys: (Use  ' , '  or  ' ; '  as separators where necessary)",
        "",
        "[BATCH]",
        "RUN= ALL / QUICK / TEXT / SELECT (Test type, select one, def.= TEXT)",
        "CYCLE= (No. of batch cycles, def.= 1)",
        "TEST= test numbers (Selected tests to run, needed only for test type= SELECT)",
        "",
        "[TEXT]",
        "FONT = name, +optional parameters   (Font name + any combination of:",
        " BOLD, ITALIC, UNDERLINE, STRIKE, TRANSPARENT, RGB(r,g,b), def.= Arial)",
        "STRING_CONTENT= string (Text string to be used, up to 128 characters)",
        "",
        "[RUN]",
        "FONT_SIZE= font sizes (Font sizes to be tested, def. 12)",
        "STRING_LENGTH= string lengths (String Length to be tested, taken as sub-strings of the one specified, def. 32)",
        "ORDER= test loop order (Order of test loops (first is outer); example: FONT_SIZE, STRING_LENGTH )",
        "NUM_FONTS= number of different fonts to be tested (for test types TEXT and SELECT)",
        "",
        "[FACE_NAMES]",
        "FONT_NAMES= names of the fonts to be tested; example: Times New Roman, Century Schoolbook",
        "            A key entry here will override any FONT key entry under the [TEXT] section",
        "            unless NUM_FONTS is 0 or 1 (any FONT_NAMES key entry would then be ignored)",
        "            Note that when NUM_FONT > 1 the Outer Execution Loop will always run on the Font Names",
        "FIRST_FONT_CHARACTER= integer decimal value of the index of the first font character to be used in some tests",
        "                      Use STRING_LENGTH to specify the number of glyphs required",
        "_______________",
        "",
        "Batch Output:",
        "",
        "* Output files will be generated automatically in the run directory, with the name [GDBxxx.log], where xxx is a number.",
        "* Note that the program will refuse to run if more than 200 output files are accumulated...",
        "* Batch and Interactive Mode (when saved) - A detailed distribution of the samples will be automatically generated",
        "  if the variation for a certain test exceeds the predefined limit in more than 5% of the samples",
    };

    int aiT[2];

    switch (msg) {
    case WM_INITDIALOG:
        aiT[0] = 100;
        aiT[1] = 190;
        SendDlgItemMessage(hwnd, IDC_HELPLIST, LB_SETTABSTOPS, 2,
                (LPARAM)(LPSTR)aiT);
        SendDlgItemMessage(hwnd, IDC_HELPLIST, LB_SETHORIZONTALEXTENT, (WPARAM)1600, 0);

        for (ix = 0; ix < sizeof szT / sizeof szT[0]; ix++) {
            SendDlgItemMessage(hwnd, IDC_HELPLIST, LB_ADDSTRING, 0,
                        (LPARAM)(LPSTR)szT[ix]);
        }


        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hwnd, 0);
            break;
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

    SyncMenuChecks - toggle checkmarks between String-Length menu items

Arguments

    HWND hwnd
    int Last_Checked - index of last menu item checked
    int New_Checked  - index of new menu item to check

Return Value

    int Last_Checked - new index of menu item just checked

--*/

int SyncMenuChecks(HWND hWnd, int Last_Checked, int New_Checked)
{
    HMENU hmenu = GetSubMenu(GetSubMenu(GetSubMenu(GetMenu(hWnd),2),0),0);
    CheckMenuItem(hmenu,Last_Checked,MF_BYPOSITION|MF_UNCHECKED);
    CheckMenuItem(hmenu,New_Checked,MF_BYPOSITION|MF_CHECKED);
    Last_Checked = New_Checked;
    return Last_Checked;
}

/*++

Routine Description:

    StdParse - Standard parser for comma, semi-colon or space delimited integer containing strings

Arguments

    char txtbuf - buffer containing the string to parse
    int limit -   max no. of characters to search in txtbuf
    int * array - returned array containing the integers found

Return Value

    int i - number of integers found in txtbuf

--*/

int Std_Parse(char txtbuf[80], int limit, int *array)
{
    int i = 0;
    int n = 0;
    char tst[2];

    array[0] = 0;

    do
    {
        sscanf(&txtbuf[n],"%1c",tst);

        if((array[i] != 0)&&((tst[0] == ' ')||(tst[0] == ',')||(tst[0] == ';')))
        {
            ++i;
            array[i] = 0;
        }

        if(tst[0] == '\n')
        {
            ++i;
            break;
        }
        while((n<limit)&&((tst[0] == ' ')||(tst[0] == ',')||(tst[0] == ';')))
        {
            ++n;
            sscanf(&txtbuf[n],"%1c",tst);
        }
        if(n>=limit)
            break;

        array[i] = 10*array[i] + atoi(tst);
        ++n;

    }while(n<limit );

    if(array[i] != 0) ++i;
    return i;
}


/*++

Routine Description:

    String_Parse - Standard parser for a comma or semi-colon separated string that
    contains several font face names

Arguments

    char * txtbuf - buffer containing the string to parse
    int limit -   max no. of characters to search in txtbuf
    char * array - returned array containing the strings found (null terminated)

	Each individual string may not exceed FACE_NAME_SIZE characters (current limit on font names).

Return Value

    int i - number of strings found in txtbuf

--*/

int String_Parse(char *txtbuf, int limit, char *array)
{
    #define FACE_NAME_SIZE 32
    int i = 0;									 // Current Face_Name count
    int n = 0;									 // Current Input buffer position
    int k = 0;									 // Current Face_Name buffer position
    char tst[2];
	char terminator[] = {'\0'};

    do
    {
        sscanf(&txtbuf[n],"%1c",tst);

        if((tst[0] == ',')||(tst[0] == ';'))	 // check for separators
        {
            lstrcpy(&array[i],terminator);	     // terminate last string
            ++i;								 // if found increment face name count
			array += (FACE_NAME_SIZE - k - 1);	 // increment output array pointer to new face name start point
			k = 0;								 // zero target face_name buffer index

            do
			{
               ++n;
               if(n>=limit-1)break;
               sscanf(&txtbuf[n],"%1c",tst);

	        }while(tst[0] == ' ');				  //skip blanks after separators

        }

        if((tst[0] == '\n')||(tst[0] == '\r'))
        {
			lstrcpy(&array[i],terminator);
            ++i;								 // and increment face_name count for the last one
            break;
        }

        strncpy(&array[i],&tst[0],1);			 // otherwise copy next character

        if((n>=limit-1)||(n==limit-1 && tst[0] == ' '))  // Stop if at last character or if last character is blank
        {
           ++array;								 // increment array pointer for terminating null
    	   lstrcpy(&array[i],terminator);
		   ++i;
           break;
		}

        ++n;									 // and increment current input buffer position
        ++k;									 // increment current face_name buffer position
		++array;								 // increment output array pointer

    }while(n<limit);

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\gdibench.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   gdibench.h

Abstract:

    GDI performance numbers

Author:

   Mark Enstrom   (marke)  13-Apr-1995

Enviornment:

   User Mode

Revision History:

    Dan Almosnino (danalm) 20-Sept-1995

    Added some default values for text string-related tests
							
    Dan Almosnino (danalm) 17-Oct-1995

    Added some default values, globals and new functions for batch mode execution

    Dan Almosnino (danalm) 20-Nov-1995

    Included header files for Pentium Cycle Counter and Statistics module.
    Added some variables for statistic processing.

--*/

#ifdef _WIN32_WINNT
#include <ntexapi.h>
#endif

int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR szCmdLine,
    int cmdShow
);

LRESULT FAR
PASCAL WndProc(
    HWND        hWnd,
    unsigned    msg,
    WPARAM      wParam,
    LPARAM      lParam);


ULONGLONG
msSetBkColor(
   HDC   hdc,
   ULONG iter
   );

ULONGLONG
msGetBkColor(
   HDC   hdc,
   ULONG iter
   );

ULONGLONG
msCreateDCW(
   HDC   hdc,
   ULONG iter
   );

ULONGLONG
msCreateDCA(
   HDC   hdc,
   ULONG iter
   );

BOOL
APIENTRY
ResultsDlgProc(
    HWND,
    UINT,
    UINT,
    LONG);

BOOL
APIENTRY
HelpDlgProc(
    HWND,
    UINT,
    UINT,
    LONG);

VOID
SaveResults();

char *
SelectOutFileName(
    HWND hWnd
    );

VOID
WriteBatchResults(
    FILE *fpOut,
    int  TestType,
    int  cycle
    );

int
SyncMenuChecks(
    HWND hWnd,
    int Last_Checked,
    int New_Checked
    );

int
Std_Parse(
    char *txtbuf,
    int limit,
    int *array);

int
String_Parse(
char *txtbuf,
int limit,
char *array);

#ifdef _X86_
#include "cycle.h"
#endif

#include "stats.h"
#include "CPUDump.h"

typedef ULONG (*PFN_MS)(HDC,ULONG);

typedef BOOL (NTAPI *PFNNTAPI)(SYSTEM_INFORMATION_CLASS,PVOID,ULONG,PULONG);
PFNNTAPI pfnNtQuerySystemInformation;

typedef struct _TEST_ENTRY
{
    PUCHAR Api;
    PFN_MS pfn;
    ULONG  Iter;
    ULONG  Result;

}TEST_ENTRY,*PTEST_ENTRY;

#define CMD_IS(x) (NULL != strstr(szCmdLine,x))

#define INIT_TIMER   ULONGLONG StartTime,StopTime; \
                     ULONG ix = Iter

#define START_TIMER_NO_INIT  StartTime = BeginTimeMeasurement()

#define START_TIMER   ULONGLONG StartTime,StopTime; \
                      ULONG ix = Iter; \
					  StartTime = BeginTimeMeasurement()

#define END_TIMER     StopTime = EndTimeMeasurement(StartTime,Iter); \
                      return (StopTime)

#define END_TIMER_NO_RETURN	  StopTime = EndTimeMeasurement(StartTime,Iter)
#define RETURN_STOP_TIME	  return (StopTime)

// Note that the following works only in Windows NT,
// so add if( WINNT_PLATFORM ){} tests in attr.c where you want IO measured!

#define WINNT_PLATFORM Win32VersionInformation.dwPlatformId	== VER_PLATFORM_WIN32_NT

#define INIT_IO_COUNT  SYSTEM_PERFORMANCE_INFORMATION SysInfo; \
	                   ULONG InitialPageFaultCount;	\
	                   ULONG InitialPagesReadCount


#define START_IO_COUNT pfnNtQuerySystemInformation(SystemPerformanceInformation, &SysInfo, sizeof(SYSTEM_PERFORMANCE_INFORMATION), NULL);	 \
                       InitialPageFaultCount = SysInfo.PageReadIoCount; \
	                   InitialPagesReadCount = SysInfo.PageReadCount

#define STOP_IO_COUNT  pfnNtQuerySystemInformation(SystemPerformanceInformation, &SysInfo, sizeof(SYSTEM_PERFORMANCE_INFORMATION), NULL);	 \
                       PageFaults = SysInfo.PageReadIoCount - InitialPageFaultCount; \
                       PagesRead  = SysInfo.PageReadCount   - InitialPagesReadCount

#define START_CPU_DUMP if(gfCPUEventMonitor == TRUE)BeginCPUDump()
#define STOP_CPU_DUMP  if((Per_Test_CPU_Event_Flag = gfCPUEventMonitor)==TRUE)EndCPUDump(Iter)

//

#define FIRST_TEXT_FUNCTION 9
#define LAST_TEXT_FUNCTION 18

#define DEFAULT_STRING_LENGTH 32
#define DEFAULT_A_STRING    "This is just a silly test string"
#define DEFAULT_W_STRING    L"This is just a silly test string"

#define ALL             11
#define QUICK           12
#define TEXT_SUITE      13
#define SELECT          14
#define POINTS_PER_INCH 72

extern ULONG gNumTests;
extern ULONG gNumQTests;
extern TEST_ENTRY  gTestEntry[];


#define NUM_TESTS  gNumTests
#define NUM_QTESTS gNumQTests
#define NUM_SAMPLES     100         // Number of test samples to be taken, each performing the test
                                    // TEST_DEFAULT times
#define VAR_LIMIT       3           // Desired Variation Coefficient (StdDev/Average) in percents

TEST_STATS TestStats[200];          // Sample Array [of size at least as number of test entries]
static	CPU_DUMP	CPUDump[200];			// CPU Dump Array [of size at least as number of test entries]	
long    Detailed_Data[200][NUM_SAMPLES];        // Storage for detailed sample data
long    PageFaultData[200][NUM_SAMPLES];
long    PagesReadData[200][NUM_SAMPLES];

_int64  PerformanceFreq;        /* Timer Frequency  */

OSVERSIONINFO Win32VersionInformation;	/* OS Version Info */


// Text String Tests Related

size_t  StrLen;

char    SourceString[129];
wchar_t SourceStringW[129];
char    DestString[256];
wchar_t DestStringW[256];
wchar_t WCstrbuf[256];

UINT FirstFontChar;

static  CHOOSEFONT   cf;
static  LOGFONT      lf;        /* logical font structure       */

//  Batch Mode Related

BYTE    TextSuiteFlag;
BYTE    BatchFlag;
int     BatchCycle;
BYTE    Finish_Message;
BYTE    Dont_Close_App;
BYTE    SelectedFontTransparent;
BYTE    String_Length_Warn;
BYTE    Print_Detailed;

FILE *fpIniFile;
FILE *fpOutFile;
char IniFileName[80];
char *OutFileName;

ULONG PageFaults;
ULONG PagesRead;

BOOL        gfCPUEventMonitor;
BOOL        Per_Test_CPU_Event_Flag;

/*
static ULONG Special_Data1 = 0;
static ULONG Special_Data2 = 0;
static ULONG Special_Data3 = 0;
static ULONG Special_Data4 = 0;
*/
ULONG Widths[256];

//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <commctrl.h>
#include <winspool.h>
#include <wingdi.h>
#include <malloc.h>
#include <limits.h>

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\stats.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   stats.h

Abstract:

    Header file for Statistics module stats.c

Author:

   Dan Almosnino   (danalm)  20-Nov-1995
   Wrote it.

Enviornment:

   User Mode

Revision History:

++*/


#define HI_FILTER       3
#define LO_FILTER       1
#define HI_LO_FILTER    2
#define NO_FILTER       0
#define HIGH_FILTER     HI_FILTER
#define LOW_FILTER      LO_FILTER
#define HILO_FILTER     HI_LO_FILTER
#define HIGH_LOW_FILTER HI_LO_FILTER


typedef struct _TEST_STATS
{
    double  Average;
    double  StdDev;
    double  Minimum_Result;
    double  Maximum_Result;
    long    NumSamplesValid;

}TEST_STATS, *PTEST_STATS;  


BOOL 
Get_Stats(
    double      *array, 
    long        num_samples, 
    const       filter_option, 
    long        var_limit, 
    PTEST_STATS stats);

BOOL
GetAverage(
    double Sample_Array[],
    long No_Samples, 
    double *Average);

BOOL
GetStdDev(
    double Sample_Array[], 
    double Average, 
    long No_Samples,
    double *varcoef);

void 
SortUp(
    double *array, 
    long array_size);

BOOL 
FilterResults(
    double Sorted_Array[], 
    double *tmpAverage, 
    double *tmpSD, 
    long *tmpNumSamples, 
    long limit,
    const filter_option);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdiplus\prntest\prntest.c ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#include "gdiplus.h"

#define ExitIf(cond) \
        { \
            if (cond) \
            { \
                fprintf(stderr, "Error on line %d - ec = %d\n", __LINE__, GetLastError()); \
                exit(-1); \
            } \
        }


INT _cdecl
main(
    INT argc,
    CHAR **argv
    )

{
    HDC     hdc;
    DOCINFO docinfo = { sizeof(DOCINFO), "prntest", };

    ExitIf(argc <= 1);

    hdc = GpCreateDCA(NULL, argv[1], NULL, NULL);
    ExitIf(hdc == NULL);

    ExitIf(GpStartDocA(hdc, &docinfo) <= 0);
    GpStartPage(hdc);

    GpSelectObject(hdc, GpGetStockObject(GRAY_BRUSH));
    GpRectangle(hdc, 0, 0, 300, 300);

    GpEndPage(hdc);
    GpEndDoc(hdc);
    GpDeleteDC(hdc);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\resource.h ===
/*--

Copyright (c) 1990  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    defines for resource file

Author:

    Mark Enstrom (marke) 30-Dec-1992

Revision History:

    Dan Almosnino (danalm) 20-Sep-1995

    Added TEXT_QRUN, Text String-Length choice items (IDM_S...), Font choice option

    Dan Almosnino (danalm) 17-Oct-1995

    Added RUN_BATCH         for batch mode execution
    Added IDM_TRANSPARENT   for transparent background text option
--*/

#define ID_DC                   110
#define IDD_RESULTS             111
#define IDD_HELP				913
#define IDC_RESULTSLIST         112
#define IDM_SAVERESULTS         113
#define IDM_SHOW                114
#define IDR_GDIBENCH_MENU       101
#define IDM_EXIT                202
#define IDM_RUN                 205
#define IDM_QRUN                206
#define IDM_TEXT_QRUN           207
#define RUN_BATCH               208
#define SHOW_HELP				911
#define IDM_HELP				911
#define IDC_HELPLIST			912
#define IDM_S001                 221
#define IDM_S002                 222
#define IDM_S004                 223
#define IDM_S008                 224
#define IDM_S016                 225
#define IDM_S032                 226
#define IDM_S064                 227
#define IDM_S128                 228
#define IDM_S256                 229
#define IDM_SXXX                 240
#define IDM_FONT                250
#define IDM_TRANSPARENT         260
#define ID_TEST_START           400


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdibench\stats.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name

   stats.c

Abstract:

   Perform basic statistics on a sample array of data: Average, Standard Deviation Coefficient.
   Perform simple filtering of Data to meet a specified Standard Deviation Coeficient (Optional). 

Author:

   Dan Almosnino   (danalm)  20-Nov-1995 -  Wrote it
  
Enviornment:

   User Mode

Revision History:

++*/

#include "precomp.h"
#include "stats.h"

/*++

Routine Description:

    Shell for statistic processing of data

Arguments

    double      *array,                Raw data array
    long        num_samples,           Number of samples taken
    const       filter_option,         available options: HI_FILTER, LO_FILTER, HI_LO_FILTER, NO_FILTER
    long        var_limit,             Filter data so that its variation coefficient (StdDev/Average) 
                                       Won't exceed var_limit (in whole percent units)
    PTEST_STATS stats)                 Pointer to struct that contains the calculated statistical data 
                                       Members: double  Average, StdDev(%) (variation coefficient),
                                                        Minimum_Result, Maximum_Result
                                                long    NumSamplesValid (after filtering)
                                       Notes: Minimum_Result and Max_Result are always before filtering.
                                            A negative value of StdDev means that the average was zero, and
                                            the number returned is the negative value of the standard deviation
                                            itself and not a relative number (coeficient of variation)  
Return Value

    TRUE for Success
    FALSE for Failure   (Indicates a failure of one of the called functions due to either:
                         Too small No. of original Samples or Valid Samples left after filtering, or
                         Zero Arithmetic Average of data (filtering cannot continue), or
                         Invalid filter option.
                           
--*/

BOOL 
Get_Stats(
    double      *array,               
    long        num_samples,          
    const       filter_option,        
    long        var_limit,             
    PTEST_STATS stats)                 

    {  

        double  Averagetmp;
        double  StdDevtmp;
        long    NumSamplestmp;

        if(!GetAverage(array, num_samples, &Averagetmp))
            return FALSE; 

        SortUp(array, num_samples);

        if(!GetStdDev(array, Averagetmp, num_samples, &StdDevtmp))
            return FALSE;

        stats->Minimum_Result   = array[0];
        stats->Maximum_Result   = array[num_samples - 1];

        if(filter_option == NO_FILTER)
        {
            stats->Average = Averagetmp;
            stats->StdDev  = StdDevtmp;
            stats->NumSamplesValid  = num_samples;
            return TRUE;
        }


        NumSamplestmp   = num_samples;
        if(!FilterResults(array,&Averagetmp,&StdDevtmp,&NumSamplestmp,var_limit,filter_option))
            return FALSE;

        stats->Average              = Averagetmp;
        stats->StdDev               = StdDevtmp;
        stats->NumSamplesValid      = NumSamplestmp;
        return TRUE;

    }

/*++

Routine Description:

    Calculate the arithmetic average of an array of numbers

Arguments

    double  Sample_Array    - data array
    long    No_Samples      - number of samples to calculate the average of
    double *Average         - pointer to the result

Return Value

    TRUE    for Success
    FALSE   for Failure (No_Samples is zero)

--*/


BOOL 
GetAverage(
    double  Sample_Array[], 
    long    No_Samples, 
    double  *Average)
    {
        long i;
        (*Average) = 0.0;
        
        if(No_Samples == 0)return FALSE;

        for(i = 0; i < No_Samples; i++)
        {
            (*Average) += Sample_Array[i];
        }

        (*Average) /= No_Samples;

        return TRUE;

    }

/*++

Routine Description:

    Calculate the standard deviation of a set of data

Arguments

    double  Sample_Array    - The data array
    double  Average         - The arithmetic Average of the Sample_Array
    long    No_Samples      - Number of Samples to Calculate
    double *varcoef         - The resulting coeficient of variation (StdDev / Average) in percent
                              (If the average is zero then the standard deviation itself is returned in 
                              negative value) 

Return Value

    TRUE for    Success
    FALSE for   Failure (No. of Samples is less than two)

--*/
                     


BOOL
GetStdDev(
    double  Sample_Array[], 
    double  Average, 
    long    No_Samples, 
    double  *varcoef)
    {
        long    i;
        double  tmp;
        double  Sum = 0.0;

        if(No_Samples <= 1L)
        {
            return FALSE;
        }

        for(i=0; i<No_Samples; i++)
        {
            tmp = (Sample_Array[i] - Average);
            Sum += (tmp*tmp);
        }

        Sum /= (No_Samples - 1);

        if(fabs( (float)Average) < 1.E-6)
        {
            *varcoef = (-sqrt(Sum));    // return the Standard Deviation itself in negative sign for distinction
        }           
        else
        {
            *varcoef = (100*sqrt(Sum)/Average); // return the variation coeficient in percents
        }

        return TRUE;
    }

/*++

Routine Description:

    Simplest Quick Sort routine (sorts-up an array of doubles)

Arguments

    double *Array       - Pointer to the array to be sorted (result is returned in the same address)
    long    array_size  - Size of array to be sorted

Return Value

    none

--*/


void
SortUp(
    double  *array, 
    long    array_size)
    {
        long gap, i, j;
        double temp;
            
        for(gap = array_size/2; gap > 0; gap /= 2)
            for(i = gap; i < array_size; i++)
                for(j = i - gap; j >= 0 && array[j] > array[j + gap]; j -= gap)
                {
                    temp = array[j];
                    array[j] = array[j + gap];
                    array[j + gap] = temp;
                }

    }           

/*++

Routine Description:

    Filter a set of data to meet a pre-defined coeficient of variation

Arguments

    double Sorted_Array     - A pointer to a pre-sorted up array of data to be filtered
    double *tmpAverage      - A pointer to the arithmetic average of the array of data.
                              Upon exit will contain the resulting average of the filtered data.
    double *tmpSD           - A pointer to the variation coefficient (in percent) of the input array of data.
                              Upon exit will contain the resulting variation coefficient of the filtered data
                              after the constraint was met.
    long    *tmpNumSamples  - A pointer to the number of samples to be filtered.
                              Upon return will contain the number of valid samples left after the filtering.
    long    limit           - The pre defined coefficient of variation (StdDev / Average)to be met 
                              (in whole percents).
    const   filter_option   - One of the following: 
                                HI_FILTER   - filter eliminates the high values from top down until limit is met
                                LO_FILTER   - filter eliminates the low values from bottom up until limit is met
                                HI_LO_FILTER- filter eliminates both high and low values in this order until limit is met
                                other   - routine will return a FALSE 

Return Value

    TRUE    for Success
    FALSE   for failure (Either number of samples left after sequential filtering passes is less than three,
                         or for some reason the filtered average became zero,
                         or the filter option is an invalid value)

--*/



BOOL 
FilterResults(
    double  Sorted_Array[], 
    double  *tmpAverage, 
    double  *tmpSD, 
    long    *tmpNumSamples, 
    long    limit,
    const   filter_option)
    {


        switch (filter_option)
        {
            case HI_FILTER:
            {
                while(*tmpSD > (double)limit)
                {

                    if(*tmpNumSamples <= 2)return FALSE;

                    (*tmpAverage)   *= (*tmpNumSamples);
                    (*tmpAverage)   -= Sorted_Array[(*tmpNumSamples) - 1];
                    (*tmpNumSamples)--;
                    (*tmpAverage)   /= (*tmpNumSamples);

                    GetStdDev(Sorted_Array, *tmpAverage, *tmpNumSamples, &(*tmpSD));
                
                }
            
                if(*tmpSD < 0)return FALSE;
            }
            break;

            case LO_FILTER:
            {

                while(*tmpSD > (double)limit)
                {

                    if(*tmpNumSamples <= 2)return FALSE;

                    (*tmpAverage)   *= (*tmpNumSamples);
                    (*tmpAverage)   -= (*Sorted_Array);
                    Sorted_Array++;
                    (*tmpNumSamples)--;
                    (*tmpAverage)   /= (*tmpNumSamples);

                    GetStdDev(Sorted_Array, *tmpAverage, *tmpNumSamples, &(*tmpSD));
                
                }
            
                if(*tmpSD < 0)return FALSE;

            }
            break;

            case HI_LO_FILTER:
            {
                
                while(*tmpSD > (double)limit)
                {

                    if(*tmpNumSamples <= 2)return FALSE;

                    if(fabs((*Sorted_Array) - (*tmpAverage)) > fabs(Sorted_Array[*tmpNumSamples - 1] - *tmpAverage))
                    {
                        (*tmpAverage)   *= (*tmpNumSamples);
                        (*tmpAverage)   -= (*Sorted_Array);
                        Sorted_Array++;
                    }
                    else
                    {
                        (*tmpAverage)   *= (*tmpNumSamples);
                        (*tmpAverage)   -= Sorted_Array[(*tmpNumSamples) - 1];
                    }                       

                    (*tmpNumSamples)--;
                    (*tmpAverage)   /= (*tmpNumSamples);

                    GetStdDev(Sorted_Array, *tmpAverage, *tmpNumSamples, &(*tmpSD));
                
                }
            
                if(*tmpSD < 0)return FALSE;

            }
            break;

            default:
            return FALSE;

        }               //switch filter_option

        return TRUE;
                        
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdiplus\inc\gdiplus.h ===
/**************************************************************************
*                                                                         
* gdiplus.h -- GDI+ public procedure declarations, constant definitions and 
*              macros 
*                                                                    
* Copyright (c) 1998, Microsoft Corp. All rights reserved.           
*                                                                    
**************************************************************************/

// GDI+ specific functions:

WINGDIAPI BOOL GpInitialize(IN HWND);

// Standard GDI functions:
                                                                             
WINGDIAPI HDC WINAPI GpCreateDCA(IN LPCSTR, IN LPCSTR, IN LPCSTR, IN CONST DEVMODEA *);
WINGDIAPI BOOL WINAPI GpDeleteDC(IN HDC);
WINGDIAPI BOOL WINAPI GpPatBlt(IN HDC, IN int, IN int, IN int, IN int, IN DWORD);
WINGDIAPI BOOL WINAPI GpEllipse(IN HDC, IN int, IN int, IN int, IN int);
WINGDIAPI HPEN WINAPI GpCreatePen(IN int, IN int, IN COLORREF);
WINGDIAPI HBRUSH WINAPI GpCreateSolidBrush(IN COLORREF);
WINGDIAPI BOOL WINAPI GpDeleteObject(IN HGDIOBJ);
WINGDIAPI HGDIOBJ WINAPI GpSelectObject(IN HDC, IN HGDIOBJ);
WINGDIAPI BOOL WINAPI GpPolyBezier(IN HDC, IN CONST POINT *, IN DWORD);
WINGDIAPI BOOL WINAPI GpPolyline(IN HDC, IN CONST POINT *, IN int);
WINGDIAPI BOOL WINAPI GpRectangle(IN HDC, IN int, IN int, IN int, IN int);

WINGDIAPI BOOL WINAPI GpTextOutA( IN HDC, IN int, IN int, IN LPCSTR, IN int);
WINGDIAPI INT WINAPI GpSetBkMode(IN HDC, IN int);
WINGDIAPI COLORREF WINAPI GpSetTextColor(IN HDC, IN COLORREF);
WINGDIAPI HFONT WINAPI GpCreateFontIndirectA( IN CONST LOGFONTA *);
WINGDIAPI INT WINAPI GpEnumFontFamiliesA(IN HDC, IN LPCSTR, IN FONTENUMPROCA, IN LPARAM);
WINGDIAPI HGDIOBJ WINAPI GpGetStockObject(IN INT);

WINGDIAPI INT WINAPI GpStartDocA(IN HDC, IN CONST DOCINFOA *);
WINGDIAPI INT WINAPI GpEndDoc(IN HDC);
WINGDIAPI INT WINAPI GpStartPage(IN HDC);
WINGDIAPI INT WINAPI GpEndPage(IN HDC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdiplus\test\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: hello.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW          0x8001
#define MM_EXIT         0x8002
#define MM_TEST         0x8003

BOOL bInitApp(VOID);
VOID vTest(HWND);
LONG lMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

#define MY_WINDOWSTYLE_FLAGS       \
            (                      \
                WS_OVERLAPPED   |  \
                WS_CAPTION      |  \
                WS_BORDER       |  \
                WS_THICKFRAME   |  \
                WS_MAXIMIZEBOX  |  \
                WS_MINIMIZEBOX  |  \
                WS_CLIPCHILDREN |  \
                WS_VISIBLE      |  \
                WS_SYSMENU         \
            )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdiplus\test\wndstuff.c ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.c
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wndstuff.h"

HANDLE  ghInstance;
HWND    ghwndMain;
HBRUSH  ghbrWhite;

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HANDLE haccel;

    DONTUSE(argc);
    DONTUSE(argv);

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = "MainMenu";
    wc.lpszClassName    = "TestClass";
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        "TestClass",
        "Win32 Test",
        MY_WINDOWSTYLE_FLAGS,
        80,
        70,
        400,
        300,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return(TRUE);
}

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    switch (message)
    {
    case WM_COMMAND:

        switch(LOWORD(wParam))
        {
        case MM_TEST:

            vTest(hwnd);
            break;

        default:

            break;
        }
        break;

    case WM_DESTROY:

        DeleteObject(ghbrWhite);
        PostQuitMessage(0);
        return(DefWindowProc(hwnd, message, wParam, lParam));

    default:

        return(DefWindowProc(hwnd, message, wParam, lParam));
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\appinit.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    INIT.H
//
//  PURPOSE:
//    Header file for INIT.C.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// String literals and defines for Registry and most Recent files.
#define APP_REG     __TEXT("Software\\Microsoft\\ICMView")
#define APP_COORD   __TEXT("WinCoord")
#define APP_FLAGS   __TEXT("Flags")
#define APP_RECENT  __TEXT("RecentFile")

#define MAX_RECENT  4

//
// Function prototypes
//
BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
BOOL SetSettings(LPRECT, DWORD, HANDLE);
BOOL AddRecentFile(HWND, LPTSTR);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\gdiplus\test\test.c ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
* Dependencies:
*
\**************************************************************************/

#include <windows.h>

#include <stdio.h>
#include <commdlg.h>

#include "gdiplus.h"


/******************************Public*Routine******************************\
* vTest
*
* This is the workhorse routine that does the test. The test is
* started by chosing it from the window menu.
*
* History:
*  Tue 08-Dec-1992 17:31:22 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

void
vTest(
    HWND hwnd
    )
{
    HDC     hdcScreen;
    HBRUSH  hbrush;
    HBRUSH  hbrushOld;
    HPEN    hpen;
    HPEN    hpenOld;
    POINT   apt[4];

    GpInitialize(hwnd);

    hdcScreen = GpCreateDCA("DISPLAY", NULL, NULL, NULL);

    hbrush = GpCreateSolidBrush(RGB(0, 0, 0xff));
    hbrushOld = GpSelectObject(hdcScreen, hbrush);
    GpPatBlt(hdcScreen, 0, 0, 10000, 10000, PATCOPY);
    GpSelectObject(hdcScreen, hbrushOld);
    GpDeleteObject(hbrush);

    GpPatBlt(hdcScreen, 100, 100, 400, 200, BLACKNESS);
    GpPatBlt(hdcScreen, 100, 300, 200, 200, BLACKNESS);

    hbrush = GpCreateSolidBrush(RGB(0, 0xff, 0));
    hpen = GpCreatePen(PS_SOLID, 100, RGB(0xff, 0, 0));

    hbrushOld = GpSelectObject(hdcScreen, hbrush);
    hpenOld = GpSelectObject(hdcScreen, hpen);

    apt[0].x = 0;
    apt[0].y = 0;
    apt[1].x = 500;
    apt[1].y = 0;
    apt[2].x = 0;
    apt[2].y = 500;
    apt[3].x = 500;
    apt[3].y = 500;

    GpPolyBezier(hdcScreen, apt, 4);

    GpSelectObject(hdcScreen, hbrushOld);
    GpSelectObject(hdcScreen, hpenOld);

    GpDeleteObject(hbrush);
    GpDeleteObject(hpenOld);

    {

    LOGFONT logfont;
    HFONT   hfont, hfontold;

    ZeroMemory(&logfont, sizeof(logfont));

    logfont.lfHeight = -32;
    strcpy(logfont.lfFaceName, "Arial");
    hfont = GpCreateFontIndirectA(&logfont);

    hfontold = GpSelectObject(hdcScreen, hfont);

    GpSetBkMode(hdcScreen, TRANSPARENT);
    GpSetTextColor(hdcScreen, RGB(0, 0xff, 0));
    GpTextOutA(hdcScreen, 40, 50, "Hello World", 11);

    GpSelectObject(hdcScreen, hfontold);
    GpDeleteObject(hfont);

    }

    DeleteObject(hdcScreen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\child.c ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    CHILD.C
//
//  PURPOSE:
//    Routines for child windows.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// These pragmas allow for the maximum warning level to be set
// without getting bombarded by warnings from the Windows SDK
// include files.
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include <CommCtrl.h>
#include <STDLIB.H>
#include "icm.h"

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings

// C RunTime Header Files

// Local Header Files
#include "icmview.h"
#include "resource.h"
#include "child.h"
#include "DibInfo.H"
#include "dialogs.h"
#include "Dibs.h"
#include "print.h"
#include "debug.h"

// Pre-processor definitions and macros

// Typedefs and structs

typedef struct TAG_PROGRESSPARAM
{
    BOOL    bCancel;
    HWND    hWnd;
    HWND    hDialog;
    DWORD   dwStartTick;
} PROGRESSPARAM, *PPROGRESSPARAM;


// External global data

// Private Global DataPrivate data

// Function prototypes
void ChildWndPaint (HWND hWnd);
BOOL ChildWndQueryNewPalette (HWND hWnd, HWND hWndFrame);
BOOL ChildWndPaletteChanged (HWND hWnd, HWND hWndActive, HWND hWndFrame);
BOOL WINAPI TransformProgress(ULONG ulMax, ULONG ulCurrent, ULONG ulCallbackData);
BOOL CALLBACK TransformProgressProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void SizeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo, UINT uiWindowHeight, UINT uiWindowWidth);
void InitializeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo);
BOOL ScrollChildWindow(HWND hWnd, int nScrollBar, WORD wScrollCode);



//////////////////////////////////////////////////////////////////////////
//  Function:  ChildWndProc
//
//  Description:
//    Child window procedure.
//
//  Parameters:
//    HWND    handle of window
//    UINT    message identifier
//    WPARAM  first message parameter
//    LPARAM  second message parameter
//
//  Returns:
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK ChildWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    LPDIBINFO   lpDIBInfo;
    int wmId, wmEvent;

    // Initialize variables
    lpDIBInfo = GetDIBInfoPtr(hWnd);
    switch (uiMsg)
    {
        case WM_COMMAND:
            wmId    = LOWORD(wParam);
            wmEvent = HIWORD(wParam);

            switch (wmId)
            {
                case ID_FILE_SAVEAS:
                    SaveDIBToFileDialog(hWnd, lpDIBInfo);
                    break;

                case IDM_FILE_PRINT_SETUP:
                    CreateDIBPropSheet(hWnd, ghInst, DIB_PROPSHEET_PRINT, lpDIBInfo->lpszImageFileName);
                    SetFocus(ghAppWnd);
                    break;

                case IDM_FILE_PRINT:
                    PrintDialog(hWnd, ghInst, lpDIBInfo);
                    break;

                case IDM_FILE_DISPLAY:
                    CreateDIBPropSheet(hWnd, ghInst, DIB_PROPSHEET_DISPLAY, lpDIBInfo->lpszImageFileName);
                    InvalidateRect(hWnd, NULL, FALSE);
                    break;

                case IDM_FILE_CLOSE:
                    SendMessage(hWnd, WM_CLOSE, 0, 0);
                    break;

                case IDM_FILE_ICM20:
                case IDM_FILE_ICM10:
                case IDM_FILE_CONFIGURE_ICM:
                    {
                        HGLOBAL     hDIBInfo;
                        BOOL        bFreed;

                        switch (wmId)
                        {
                            case IDM_FILE_ICM20:
                                if (!CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20))  // Don't redundantly transform DIB
                                {
                                    SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE);
                                    SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), (ICMVFLAGS_ICM20), TRUE);
                                }
                                break;

                            case IDM_FILE_ICM10:
                                SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), ICMVFLAGS_ICM20, FALSE);
                                break;

                            case IDM_FILE_CONFIGURE_ICM:
                                ColorMatchUI(hWnd, lpDIBInfo);
                                break;

                            default:
                                break;
                        }
                        hDIBInfo = GlobalHandle(lpDIBInfo);
                        bFreed = GlobalUnlock(hDIBInfo);
                        InvalidateRect(hWnd, NULL, FALSE);
                    }
                    break;

                case IDM_FILE_COPY_CLIPBOARD_DDB:
                case IDM_FILE_COPY_CLIPBOARD_DIB:
                case IDM_FILE_COPY_CLIPBOARD_DIBSECT:
                    {
                        if (OpenClipboard(hWnd))
                        {
                            HBITMAP        hbmDib;
                            LPBITMAPINFO   lpBmpInfo;
                            LPVOID         lpDibSection = NULL;
                            HDC            hDC;

                            lpBmpInfo = (LPBITMAPINFO) GlobalLock(lpDIBInfo->hDIB);

                            if (wmId == IDM_FILE_COPY_CLIPBOARD_DIB)
                            {
                                UINT   uFormat = CF_DIB;
                                HANDLE hBitmap;

                                //
                                // If this is BITMAPV4/V5, paste it as CF_DIBV5, otheriwse CF_DIB.
                                //
                                if ((sizeof(BITMAPV4HEADER) == lpBmpInfo->bmiHeader.biSize) ||
                                    (sizeof(BITMAPV5HEADER) == lpBmpInfo->bmiHeader.biSize))
                                {
                                    uFormat = CF_DIBV5;
                                }

                                //
                                // Make a copy of bitmap.
                                //
                                hBitmap = GlobalAlloc(GHND,GlobalSize(lpDIBInfo->hDIB));

                                if (hBitmap)
                                { 
                                    PVOID pvBitmap = GlobalLock(hBitmap);

                                    if (pvBitmap)
                                    {
                                        CopyMemory(pvBitmap,lpBmpInfo,GlobalSize(lpDIBInfo->hDIB));

                                        GlobalUnlock(hBitmap);
                                    }

                                    EmptyClipboard();
                                    SetClipboardData(uFormat,hBitmap);
                                    CloseClipboard();
                                }
                            }
                            else if (wmId == IDM_FILE_COPY_CLIPBOARD_DIBSECT)
                            {
                                // !!! Warning !!!
                                //
                                // Bitmap handle of DIBSECTION can *NOT* pass to clipboard. 
                                // SetClipboardData(CF_BITMAP,hBmDibSection) will success,
                                // but, other process can not get it by GetClipboardData(
                                // AnyFormat), since DIBSection data is very specific to
                                // the owner process. Thus, we can call GetClipboardData()
                                // from same process as owner.
                                //
                                hbmDib = CreateDIBSection((HDC)0,
                                                          lpBmpInfo, 
                                                          DIB_RGB_COLORS,
                                                          &lpDibSection,
                                                          NULL, 0);

                                if (hbmDib && lpDibSection)
                                {
                                    CopyMemory(lpDibSection,
                                           FindDIBBits((LPBITMAPINFOHEADER)lpBmpInfo),
                                           lpDIBInfo->dwSizeOfImage);

                                    EmptyClipboard();
                                    SetClipboardData(CF_BITMAP,hbmDib);
                                    CloseClipboard();
                                }
                            }
                            else if (wmId == IDM_FILE_COPY_CLIPBOARD_DDB)
                            {
                                TCHAR szsRGBColorProfile[MAX_PATH];
                                ULONG ulSizeOfBuff = sizeof(szsRGBColorProfile) / sizeof(TCHAR);

                                hDC = GetDC(hWnd);

                                // !!! Warning !!!
                                //
                                // If you want to pass the bitmap handle through the clipboard
                                // please be aware to create bitmap with sRGB color space.
                                //
                                // So, here we set destination color space as sRGB.
                                //
                                if (!GetStandardColorSpaceProfile(NULL,LCS_sRGB,szsRGBColorProfile,&ulSizeOfBuff))
                                {
                                    // If error, use hardcode-ed filename
                                    lstrcpy(szsRGBColorProfile,TEXT("sRGB Color Space Profile.icm"));
                                }

                                SetICMProfile(hDC,szsRGBColorProfile);

                                // Enable ICM.

                                SetICMMode(hDC,ICM_ON);

                                hbmDib = CreateDIBitmap(hDC,
                                                        (CONST LPBITMAPINFOHEADER)lpBmpInfo,
                                                        CBM_INIT,
                                                        FindDIBBits((LPBITMAPINFOHEADER)lpBmpInfo),
                                                        lpBmpInfo,
                                                        DIB_RGB_COLORS);

                                // Disable ICM

                                SetICMMode(hDC,ICM_OFF);
                                ReleaseDC(hWnd,hDC);

                                if (hbmDib)
                                {
                                    EmptyClipboard();
                                    SetClipboardData(CF_BITMAP,hbmDib);
                                    CloseClipboard();
                                }
                            }

                            GlobalUnlock(lpDIBInfo->hDIB);
                        }
                    }
                    break;

                default:
                    return(DefMDIChildProc(hWnd, uiMsg, wParam, lParam));
                    break;
            }
            break;

        case WM_CONTEXTMENU:
            {
                HMENU hMenu;
                hMenu = InitImageMenu(hWnd);
                if (hMenu)
                {
                    TrackPopupMenu (hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, LOWORD(lParam), HIWORD(lParam), 0, hWnd, NULL);
                    DestroyMenu(hMenu);
                }
                return(0);
            }
            break;

        case WM_PAINT:
            ChildWndPaint(hWnd);
            return(0); // We have processed the message
            break;

        case WM_CLOSE:
            SendMessage(ghWndMDIClient, WM_MDIDESTROY, (WPARAM)(HWND)hWnd, 0);
            DestroyWindow(hWnd);
            SetFocus(ghAppWnd);
            return(1L);

        case WM_DESTROY:
            fFreeDIBInfo(GetDIBInfoHandle(hWnd), TRUE);
            SetWindowLong(hWnd, GWL_DIBINFO, (LONG)NULL);
            break;

        case WM_MDIACTIVATE:
            if (0 != wParam)
            {
                SendMessage (hWnd, MYWM_QUERYNEWPALETTE, (WPARAM) GetParent(ghWndMDIClient), 0L);
            }
            break;

        case WM_SIZE:
            // May need to show or hide scroll bars.
            SizeScrollBars(hWnd, lpDIBInfo, HIWORD(lParam), LOWORD(lParam));

            // This makes sure that we redraw
            // all the window if we are stretching to window
            // and the size changes.
            InvalidateRect(hWnd, NULL, FALSE);
            break;

        case WM_VSCROLL:
            ScrollChildWindow(hWnd, SB_VERT, LOWORD(wParam));
            return FALSE;

        case WM_HSCROLL:
            ScrollChildWindow(hWnd, SB_HORZ, LOWORD(wParam));
            return FALSE;

        case MYWM_QUERYNEWPALETTE:
            return ChildWndQueryNewPalette (hWnd, (HWND) wParam);

        case MYWM_PALETTECHANGED:
            return ChildWndPaletteChanged (hWnd, (HWND) wParam, (HWND) lParam);
    }
    return DefMDIChildProc(hWnd, uiMsg, wParam, lParam);
}

//////////////////////////////////////////////////////////////////////////
//  Function:  CreateNewImageWindow
//
//  Description:
//    Creates a new window for a new image.  As this function is the
//    startup function for a new thread, some administrative duties
//    are required.  The following actions are taken when the new
//    thread is created:
//      -A new window is created.
//                      -A DIBINFO structure is created and associated with the
//       window via a SetWindowLong call.
//                      -The contents of the DIBINFO structure associated with the
//       main application window are copied into the new window's
//       DIBINFO structure.
//
//  Parameters:
//    DWORD   Actually an LPTSTR to the file name of the image.
//
//  Returns:
//    DWORD to be returned by implicit CloseThread call
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

DWORD CreateNewImageWindow(HANDLE hDIBInfo)
{
    // Local variables
    int             nWidth;
    int             nHeight;
    HWND            hwndImage;
    HANDLE          hAccel;
    RECT            rcWindow;
    RECT            rcClient;
    LPDIBINFO       lpDIBInfo;


    //  Initialize variables
    ASSERT(ghWndMDIClient != NULL);  // If it's NULL, won't get a window for thread
    ASSERT(NULL != hDIBInfo);
    if (NULL == hDIBInfo)
    {
        return(FALSE);
    }
    lpDIBInfo = GlobalLock(hDIBInfo);

    // Determine the necessary window size to hold the DIB.
    rcWindow.left   = 0;
    rcWindow.top    = 0;
    rcWindow.right  = (int) lpDIBInfo->uiDIBWidth;
    rcWindow.bottom = (int) lpDIBInfo->uiDIBHeight;

    if (!AdjustWindowRectEx (&rcWindow,
                             MDIS_ALLCHILDSTYLES|WS_CHILD|WS_SYSMENU|WS_CAPTION|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX,
                             FALSE, WS_EX_MDICHILD))
    {
        DebugMsg(__TEXT("CreateNewImageWindow:  AdjustWindowRectEx failed, LastError = %lu\r\n"), GetLastError());
        return(ERROR_INVALID_PARAMETER);
    }

    // Make sure child window is not larger than parent's client area.
    GetClientRect(ghWndMDIClient, &rcClient);
    nWidth  = __min(rcClient.right, rcWindow.right - rcWindow.left);
    nHeight = __min(rcClient.bottom, rcWindow.bottom - rcWindow.top);

    // Create child window; class declaration leaves room for pointer to DIBINFO.
    hwndImage = CreateWindowEx(WS_EX_MDICHILD, CHILD_CLASSNAME,
                               lpDIBInfo->lpszImageFileName,
                               MDIS_ALLCHILDSTYLES | WS_CHILD|WS_SYSMENU|WS_CAPTION|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX,
                               0, 0, nWidth, nHeight, ghWndMDIClient, NULL, ghInst, 0);

    if (hwndImage != NULL)
    {
        // Obtain handle to main window's ICMINFO
        lpDIBInfo->hWndOwner = hwndImage;  // Establish ownership of DIBINFO structure
        SetWindowLong(hwndImage, GWL_DIBINFO, (LONG)hDIBInfo);

        // Initial scroll information.
        InitializeScrollBars(hwndImage, lpDIBInfo);

        ShowWindow(hwndImage, SW_NORMAL);
        UpdateWindow(hwndImage);

        SendMessage(hwndImage, MYWM_QUERYNEWPALETTE, (WPARAM) ghAppWnd, 0L);
    }
    else
    {
        DebugMsg(__TEXT("CreateNewImageWindow:  hwndImage = NULL, LastError = %lu\r\n"), GetLastError);
        return(ERROR_INVALID_PARAMETER);
    }

    // Unlock handle
    GlobalUnlock(hDIBInfo);
    lpDIBInfo = NULL;

    hAccel = LoadAccelerators(ghInst, __TEXT("ICMVIEW"));
    ASSERT(hAccel);
    return(ERROR_SUCCESS);
}   // End of CreateNewImageWindow


///////////////////////////////////////////////////////////////////////
//
// Function:   ChildWndPaint
//
// Purpose:    Called by ChildWndProc() on WM_PAINT.  Does all paints
//             for this MDI child window.
//
//             Reads position of scroll bars to find out what part
//             of the DIB to display.
//
//             Checks the stretching flag in the DIBINFO structure for
//             this window to see if we are stretching to the window
//             (if we're iconic, we always stretch to a tiny bitmap).
//
//             Selects/Realizes the palette as a background palette.
//             The palette was realized as the foreground palette in
//             ChildWndQueryNewPalette() if this is the active window.
//
//
// Parms:      hWnd == Handle to window being painted.
//
///////////////////////////////////////////////////////////////////////

void ChildWndPaint(HWND hWnd)
{
    HDC                 hDC;
    RECT                rectClient;
    RECT                rectDDB;
    BOOL                bStretch;
    HGLOBAL             hDIBInfo;
    LPDIBINFO           lpDIBInfo;
    HANDLE              hDIB;
    LPTSTR              lpszTargetProfile;
    DWORD               dwLCSIntent;
    HCURSOR             hCur;
    PAINTSTRUCT         ps;
    PROGRESSPARAM       ProgressParam;
    LPBITMAPINFOHEADER  lpBi;

    // Initialize variables
    lpDIBInfo = NULL;
    lpBi = NULL;
    hDIBInfo = NULL;
    hDIB = NULL;
    lpszTargetProfile = NULL;

    START_WAIT_CURSOR(hCur);
    hDC = BeginPaint (hWnd, &ps);
    hDIBInfo = GetDIBInfoHandle(hWnd);

    if ( (NULL != hDC)
         &&
         (NULL != hDIBInfo)
         &&
         (RECTWIDTH(&ps.rcPaint) != 0)
         &&
         (RECTHEIGHT(&ps.rcPaint) !=0)
       )
    {
        lpDIBInfo = (LPDIBINFO)GlobalLock(hDIBInfo);

        //Check if we're using ICM outside of the DC. If so, it might be necessary to
        // create a color transform.
        if ( CHECK_DWFLAG(lpDIBInfo->dwICMFlags,ICMVFLAGS_ICM20) && CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ENABLE_ICM))
        {
            // Outside DC selected
            hDIB = lpDIBInfo->hDIBTransformed;
            if (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_CREATE_TRANSFORM) || (hDIB == NULL))
            {
                if (NULL != lpDIBInfo->hDIBTransformed)  // Free old transformed bits
                {
                    GlobalFree(lpDIBInfo->hDIBTransformed);
                }
                // Set up for transform
                if (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_PROOFING))
                {
                    lpszTargetProfile = lpDIBInfo->lpszTargetProfile;
                }
                // Initialize Progress Param structure.
                ProgressParam.bCancel = FALSE;
                ProgressParam.hWnd = hWnd;
                ProgressParam.hDialog = NULL;
                ProgressParam.dwStartTick = GetTickCount();

                ConvertIntent(lpDIBInfo->dwRenderIntent, ICC_TO_LCS, &dwLCSIntent);
                lpDIBInfo->hDIBTransformed = TransformDIBOutsideDC(lpDIBInfo->hDIB,
                                                                   lpDIBInfo->bmFormat,
                                                                   lpDIBInfo->lpszMonitorProfile,
                                                                   lpszTargetProfile,
                                                                   USE_BITMAP_INTENT, NULL, //TransformProgress,
                                                                   (ULONG) &ProgressParam);
                // May need to destroy progress dialog.
                if (IsWindow(ProgressParam.hDialog))
                    DestroyWindow(ProgressParam.hDialog);

                if (NULL == lpDIBInfo->hDIBTransformed)
                {
                    ErrMsg(hWnd, __TEXT("DIB Transform failed.  Disabling ICM"));
                    hDIB = lpDIBInfo->hDIB;
                    SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), ICMVFLAGS_ENABLE_ICM, FALSE);
                }
                else
                {
                    SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, FALSE);
                    hDIB = lpDIBInfo->hDIBTransformed;
                }
            }
        }
        else  // Inside DC selected
        {
            hDIB = lpDIBInfo->hDIB;
        }

        if (NULL != hDIB)
        {
            lpBi = GlobalLock(hDIB);
        }
        if (NULL == lpBi)
        {
            DebugMsg(__TEXT("CHILD.C : ChildWndPaint : NULL lpBi\r\n"));
            goto ABORTPAINT;
        }
        bStretch = lpDIBInfo->bStretch;

        // Set up the necessary rectangles -- i.e. the rectangle
        //  we're rendering into, and the rectangle in the DIB.
        if (bStretch)
        {
            GetClientRect(hWnd, &rectClient);
            rectDDB.left   = 0;
            rectDDB.top    = 0;
            rectDDB.right  = BITMAPWIDTH(lpBi);
            rectDDB.bottom = abs(BITMAPHEIGHT(lpBi));
        }
        else
        {
            int xScroll;
            int yScroll;


            xScroll  = GetScrollPos(hWnd, SB_HORZ);
            yScroll  = GetScrollPos(hWnd, SB_VERT);
            CopyRect(&rectClient, &ps.rcPaint);

            rectDDB.left   = xScroll + rectClient.left;
            rectDDB.top    = yScroll + rectClient.top;
            rectDDB.right  = rectDDB.left + RECTWIDTH(&rectClient);
            rectDDB.bottom = rectDDB.top + RECTHEIGHT(&rectClient);

            if (rectDDB.right > BITMAPWIDTH(lpBi))
            {
                int dx;

                dx = BITMAPWIDTH(lpBi) - rectDDB.right;
                rectDDB.right     += dx;
                rectClient.right  += dx;
            }

            if (rectDDB.bottom > abs(BITMAPHEIGHT(lpBi)))
            {
                int dy;

                dy = abs(BITMAPHEIGHT(lpBi)) - rectDDB.bottom;
                rectDDB.bottom    += dy;
                rectClient.bottom += dy;
            }
        }
        DIBPaint (hDC, &rectClient, hDIB, &rectDDB, lpDIBInfo);

        // Draw the clipboard selection rubber-band.
        SetWindowOrgEx (hDC, GetScrollPos(hWnd, SB_HORZ), GetScrollPos (hWnd, SB_VERT), NULL);
    }
    else
    {
        if (NULL == hDC)
        {
            END_WAIT_CURSOR(hCur);
            DebugMsg(__TEXT("ChildWndPaint : NULL hDC\r\n"));
            return;
        }
    }

    ABORTPAINT:
    EndPaint (hWnd, &ps);
    END_WAIT_CURSOR(hCur);

    if (hDIB && lpBi)
    {
        GlobalUnlock(hDIB);
    }
    if (lpDIBInfo)
    {
        GlobalUnlock(hDIBInfo);
    }
}

///////////////////////////////////////////////////////////////////////
//
// Function:   ChildWndQueryNewPalette
//
// Purpose:    Called by ChildWndProc() on WM_QUERYNEWPALETTE.
//
//             We get this message when an MDI child is getting
//             focus (by hocus pocus in FRAME.C, and by passing
//             this message when we get WM_MDIACTIVATE).  Normally
//             this message is passed only to the top level window(s)
//             of an application.
//
//             We want this window to have the foreground palette when this
//             happens, so we select and realize the palette as
//             a foreground palette (of the frame Window).  Then make
//             sure the window repaints, if necessary.
//
// Parms:      hWnd      == Handle to window getting WM_QUERYNEWPALETTE.
//             hWndFrame == Handle to the frame window (i.e. the top-level
//                            window of this app.
//
///////////////////////////////////////////////////////////////////////

BOOL ChildWndQueryNewPalette (HWND hWnd, HWND hWndFrame)
{
    HPALETTE  hOldPal;
    HDC       hDC;
    HGLOBAL   hDIBInfo;
    LPDIBINFO lpDIBInfo;
    int       nColorsChanged;

    hDIBInfo = GetDIBInfoHandle (hWnd);

    if (!hDIBInfo)
        return FALSE;

    lpDIBInfo = (LPDIBINFO) GlobalLock (hDIBInfo);

    if (!lpDIBInfo->hPal)
    {
        GlobalUnlock (hDIBInfo);
        return FALSE;
    }


    // We're going to make our palette the foreground palette for
    //  this application.  Window's palette manager expects the
    //  top-level window of the application to have the palette,
    //  so, we get a DC for the frame here!

    hDC     = GetDC (hWndFrame);
    hOldPal = SelectPalette (hDC, lpDIBInfo->hPal, FALSE);

    nColorsChanged = RealizePalette (hDC);
    InvalidateRect (hWnd, NULL, FALSE);

    if (hOldPal)
        SelectPalette (hDC, hOldPal, FALSE);

    ReleaseDC (hWndFrame, hDC);

    GlobalUnlock (hDIBInfo);

    return (nColorsChanged != 0);
}

BOOL ChildWndPaletteChanged (HWND hWnd, HWND hWndActive, HWND hWndFrame)
{
    HPALETTE  hOldPal;
    HDC       hDC;
    HGLOBAL   hDIBInfo;
    LPDIBINFO lpDIBInfo;

    if (hWnd != hWndActive)
    {
        hDIBInfo = GetDIBInfoHandle (hWnd);

        if (!hDIBInfo)
            return FALSE;

        lpDIBInfo = (LPDIBINFO) GlobalLock (hDIBInfo);

        if (!lpDIBInfo->hPal)
        {
            GlobalUnlock (hDIBInfo);
            return FALSE;
        }
 
        // We're going to make our palette the foreground palette for
        //  this application.  Window's palette manager expects the
        //  top-level window of the application to have the palette,
        //  so, we get a DC for the frame here!

        hDC     = GetDC (hWnd);
        hOldPal = SelectPalette (hDC, lpDIBInfo->hPal, FALSE);

        if (RealizePalette (hDC))
        {
            UpdateColors(hDC);
        }

        if (hOldPal)
            SelectPalette (hDC, hOldPal, FALSE);

        ReleaseDC (hWnd, hDC);

        GlobalUnlock (hDIBInfo);
    }

    return (TRUE);
}

//////////////////////////////////////////////////////////////////////////
//  Function:  TransformProgress
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL WINAPI TransformProgress(ULONG ulMax, ULONG ulCurrent, ULONG ulCallbackData)
{
    PPROGRESSPARAM  pProgressParam = (PPROGRESSPARAM) ulCallbackData;


    DebugMsg(__TEXT("TransformProgress:  ulCurrent = %d, ulMax = %d\r\n"), ulCurrent, ulMax);

    if (!IsWindow(pProgressParam->hDialog))
    {
        DWORD   dwTick = GetTickCount();

        // May need to create progress dialog for translate bitmap bits.
        // Create dialog only if translation takes awhile to do.
        if ( (dwTick - pProgressParam->dwStartTick > 1000L) && ((double)ulCurrent/ulMax < 0.33))
        {
            // Created dialog must be destroyed by TranslateBitmapBits caller.
            pProgressParam->hDialog = CreateDialogParam(NULL, MAKEINTRESOURCE(IDD_TRANSLATE),
                                                        pProgressParam->hWnd, TransformProgressProc,
                                                        (LPARAM) ulCallbackData);
            ShowWindow(pProgressParam->hDialog, SW_SHOWNORMAL);
            UpdateWindow(pProgressParam->hDialog);
            SendDlgItemMessage(pProgressParam->hDialog, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELONG(0, ulMax));
            SendDlgItemMessage(pProgressParam->hDialog, IDC_PROGRESS, PBM_SETPOS, ulCurrent, 0);
        }
    }
    else
    {
        // Update dialog's progress bar.
        SendDlgItemMessage(pProgressParam->hDialog, IDC_PROGRESS, PBM_SETPOS, ulCurrent, 0);
    }

    return !pProgressParam->bCancel;
}



//////////////////////////////////////////////////////////////////////////
//  Function:  TransformProgressProc
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CALLBACK TransformProgressProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{

    switch (uMsg)
    {
        case WM_INITDIALOG:
            ASSERT(lParam != 0);
            SetWindowLong(hDlg, GWL_USERDATA, lParam);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL:
                    {
                        PPROGRESSPARAM  pProgressParam = (PPROGRESSPARAM) GetWindowLong(hDlg, GWL_USERDATA);

                        pProgressParam->bCancel = TRUE;
                    }
                    break;
            }
            break;
    }

    return FALSE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:  SizeScrollBars
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void SizeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo, UINT uiWindowHeight, UINT uiWindowWidth)
{
    static BOOL    bAdjusting = FALSE;


    // Only size for validte windows and dib info.
    // Don't SizeScrollBars if in process of adjusting them.
    if ( IsWindow(hWnd)
         &&
         (NULL != lpDIBInfo)
         &&
         !bAdjusting
       )
    {
        int         nScrollHeight = GetSystemMetrics (SM_CXVSCROLL);
        int         nScrollWidth = GetSystemMetrics (SM_CYHSCROLL);
        SCROLLINFO  VertScrollInfo;
        SCROLLINFO  HorzScrollInfo;

        // Make sure that we don't get into an infinite loop when updating scroll bars.
        bAdjusting = TRUE;

        // Get current vertical scroll info.
        VertScrollInfo.cbSize = sizeof(SCROLLINFO);
        VertScrollInfo.fMask = SIF_ALL;
        GetScrollInfo(hWnd, SB_VERT, &VertScrollInfo);

        // Get current horizontal scroll info.
        HorzScrollInfo.cbSize = sizeof(SCROLLINFO);
        HorzScrollInfo.fMask = SIF_ALL;
        GetScrollInfo(hWnd, SB_HORZ, &HorzScrollInfo);

        // Only adjust if not stretching to fit.
        // Turn off scroll bars if stretching to fit.
        if (!lpDIBInfo->bStretch)
        {
            // Adjust window width and height to account for current scroll bars.
            if ((int) VertScrollInfo.nPage <= VertScrollInfo.nMax)
            {
                // INVARIANT:  Vertical scroll bar exists.

                // modify width to account for scroll bars width.
                uiWindowWidth += nScrollWidth;
            }
            if ((int) HorzScrollInfo.nPage <= HorzScrollInfo.nMax)
            {
                // INVARIANT:   Horizantal scroll bar exists.

                // Modify height to account for scroll bars height.
                uiWindowHeight += nScrollHeight;
            }

            // Adjust width and height based on what will happen.
            if ((int) uiWindowHeight < VertScrollInfo.nMax)
            {
                uiWindowWidth -= nScrollWidth;
                if ((int) uiWindowWidth < HorzScrollInfo.nMax)
                {
                    uiWindowHeight -= nScrollHeight;
                }
            }
            else if ((int) uiWindowWidth < HorzScrollInfo.nMax)
            {
                uiWindowHeight -= nScrollHeight;
                if ((int) uiWindowHeight < VertScrollInfo.nMax)
                {
                    uiWindowWidth -= nScrollWidth;
                }
            }

            // If width or height equals bitmap, need to make it larger
            // so that scroll bars will not appear.
            if ((int) uiWindowWidth == HorzScrollInfo.nMax)
            {
                ++uiWindowWidth;
            }
            if ((int) uiWindowHeight == VertScrollInfo.nMax)
            {
                ++uiWindowHeight;
            }
        }
        else
        {
            uiWindowHeight = VertScrollInfo.nMax + 1;
            uiWindowWidth = HorzScrollInfo.nMax + 1;
        }

        // Update vertical scroll info.
        VertScrollInfo.fMask = SIF_PAGE;
        VertScrollInfo.nPage = uiWindowHeight;
        SetScrollInfo(hWnd, SB_VERT, &VertScrollInfo, FALSE);

        // Update horizontal scroll info.
        HorzScrollInfo.fMask = SIF_PAGE;
        HorzScrollInfo.nPage = uiWindowWidth;
        SetScrollInfo(hWnd, SB_HORZ, &HorzScrollInfo, FALSE);

        bAdjusting = FALSE;
    }
}


//////////////////////////////////////////////////////////////////////////
//  Function:  InitializeScrollBars
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void InitializeScrollBars(HWND hWnd, LPDIBINFO lpDIBInfo)
{
    RECT        rClient;
    SCROLLINFO  ScrollInfo;


    // Get windows client size.
    GetClientRect(hWnd, &rClient);

    // If client size is equel to dib size, then add one to client size
    // so that we don't show scroll bars.
    // However, if client size is less than dib size, subtract scroll bar
    // size form client size so that page size will be correct when
    // scroll bars are shown.
    if ((UINT) rClient.bottom == lpDIBInfo->uiDIBHeight)
        ++rClient.bottom;
    else if ((UINT) rClient.bottom < lpDIBInfo->uiDIBHeight)
        rClient.bottom -= GetSystemMetrics (SM_CYHSCROLL);
    if ((UINT) rClient.right == lpDIBInfo->uiDIBWidth)
        ++rClient.right;
    else if ((UINT) rClient.right < lpDIBInfo->uiDIBWidth)
        rClient.right -= GetSystemMetrics (SM_CXVSCROLL);

    // Initialize vertical scroll bar.
    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = SIF_ALL;
    ScrollInfo.nMin = 0;
    ScrollInfo.nMax = lpDIBInfo->uiDIBHeight;
    ScrollInfo.nPage = rClient.bottom;
    ScrollInfo.nPos = 0;
    SetScrollInfo(hWnd, SB_VERT, &ScrollInfo, TRUE);

    // Initialize vertical scroll bar.
    ScrollInfo.nMax = lpDIBInfo->uiDIBWidth;
    ScrollInfo.nPage = rClient.right;
    SetScrollInfo(hWnd, SB_HORZ, &ScrollInfo, TRUE);
}


//////////////////////////////////////////////////////////////////////////
//  Function:  ScrollChildWindow
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL ScrollChildWindow(HWND hWnd, int nScrollBar, WORD wScrollCode)
{
    int         nPosition;
    int         nHorzScroll = 0;
    int         nVertScroll = 0;
    SCROLLINFO  ScrollInfo;


    // Get current scroll information.
    ScrollInfo.cbSize = sizeof(SCROLLINFO);
    ScrollInfo.fMask = SIF_ALL;
    GetScrollInfo(hWnd, nScrollBar, &ScrollInfo);
    nPosition = ScrollInfo.nPos;

    // Modify scroll information based on requested
    // scroll action.
    switch (wScrollCode)
    {
        case SB_LINEDOWN:
            ScrollInfo.nPos++;
            break;

        case SB_LINEUP:
            ScrollInfo.nPos--;
            break;

        case SB_PAGEDOWN:
            ScrollInfo.nPos += ScrollInfo.nPage;
            break;

        case SB_PAGEUP:
            ScrollInfo.nPos -= ScrollInfo.nPage;
            break;

        case SB_TOP:
            ScrollInfo.nPos = ScrollInfo.nMin;
            break;

        case SB_BOTTOM:
            ScrollInfo.nPos = ScrollInfo.nMax;
            break;

            // Don't do anything.
        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            ScrollInfo.nPos = ScrollInfo.nTrackPos;
            break;

        case SB_ENDSCROLL:
            default:
            return FALSE;
    }

    // Make sure that scroll position is in range.
    if (0 > ScrollInfo.nPos)
        ScrollInfo.nPos = 0;
    else if (ScrollInfo.nMax - (int) ScrollInfo.nPage + 1 < ScrollInfo.nPos)
        ScrollInfo.nPos = ScrollInfo.nMax  - ScrollInfo.nPage + 1;

    // Set new scroll position.
    ScrollInfo.fMask = SIF_POS;
    SetScrollInfo(hWnd, nScrollBar, &ScrollInfo, TRUE);

    // Scroll window.
    if (SB_VERT == nScrollBar)
        nVertScroll = nPosition - ScrollInfo.nPos;
    else
        nHorzScroll = nPosition - ScrollInfo.nPos;

    ScrollWindowEx(hWnd, nHorzScroll, nVertScroll, NULL, NULL,
                   NULL, NULL, SW_INVALIDATE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\appinit.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1996  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    INIT.C
//
//  PURPOSE:
//    Initializes ICMVIEW.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include <commctrl.h>
#include "icm.h"

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings

// C RunTime Header Files
#include <stdlib.h>
#include <tchar.h>

// Local Header Files
#include "AppInit.h"
#include "icmview.h"
#include "child.h"
#include "DibInfo.H"
#include "debug.h"
#include "resource.h"


#define RECENT_MENU         0
#define RECENT_POSITION     11


// local definitions
BOOL RegisterICMViewClasses(HINSTANCE);
BOOL CreateGlobalDIBInfo(void);
BOOL GetSettings(LPRECT, LPDWORD, HANDLE);
BOOL UpdateRecentFiles(HWND, HANDLE);
int RegisterCMMProc(LPCTSTR lpszFileName);

// default settings

// external functions

// external data

// public data

// private data

//
// Public functions
//

//////////////////////////////////////////////////////////////////////////
//  Function:  InitApplication
//
//  Description:
//    Initializes window data and registers window class.
//
//  Parameters:
//    HINSTANCE   Instance handle.
//
//  Returns:
//    BOOL    Success indicator
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL  InitApplication(HINSTANCE hInstance)
{
    //  Initialize variables
    SetLastError(0);

    return RegisterICMViewClasses(hInstance);
}   // End of function InitApplication


//////////////////////////////////////////////////////////////////////////
//  Function:  InitInstance
//
//  Description:
//    Initializes this instance and saves an instance handle.
//
//  Parameters:
//    HINSTANCE Instance handle
//    int       Integer identifying initial display mode@@@
//
//  Returns:
//    BOOL    Success indicator.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
    // Local variables
    HDC       hDisplay = GetDC(NULL);
    int       nScreenWidth = GetDeviceCaps(hDisplay, HORZRES);
    int       nScreenHeight = GetDeviceCaps(hDisplay, VERTRES);
    HWND      hWnd;
    RECT      rCoord;
    DWORD     dwFlags = 0L;
    HANDLE    hRecent = NULL;
    DWORD     dwPathSize;

    // No longer need display DC.
    if (hDisplay)
        ReleaseDC(NULL, hDisplay);

    //  Initialize variables
    ghInst = hInstance; // Store instance handle in our global variable

    // Get stored coordinates from last run.
    GetSettings(&rCoord, &dwFlags, &hRecent);
    if ( ((rCoord.left + rCoord.right)/2 < 0)
         ||
         ((rCoord.left + rCoord.right)/2 > nScreenWidth)
         ||
         ((rCoord.top + rCoord.bottom)/2 < 0)
         ||
         ((rCoord.top + rCoord.bottom)/2 > nScreenHeight)
         ||
         ( (double)(rCoord.right - rCoord.left)/(double)(nScreenHeight) * 1.1
           >= (double)(nScreenWidth)/(double)(rCoord.bottom - rCoord.top) )
       )
    {
        SetRect(&rCoord, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT);
    }
    else
    {
        // Set right and bottom to width and height.
        rCoord.right -= rCoord.left;
        rCoord.bottom -= rCoord.top;
    }

    // Create the window using stored coordinates.
    _tcscpy(gstTitle, APPNAME);
    hWnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, APPNAME, gstTitle, WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                          rCoord.left, rCoord.top, rCoord.right, rCoord.bottom, NULL, NULL, hInstance, NULL);

    if (!hWnd)  // Couldn't create main window, exit w/FAILURE code
    {
        DebugMsg(__TEXT("InitInstance:  CreateWindow failed.\r\n"));
        return (FALSE);
    }
    ghAppWnd = hWnd;  // Save main application window handle

    // Attach recent files to main window and display them.
    SetProp(hWnd, APP_RECENT, hRecent);
    UpdateRecentFiles(hWnd, hRecent);

    // Store profiles directory
    dwPathSize = MAX_PATH;
    GetColorDirectory(NULL, gstProfilesDir, &dwPathSize);

    if (!CreateGlobalDIBInfo())
    {
        DebugMsg(__TEXT("InitInstance:  CreateGlobalDIBInfo failed\r\n"));
        return(FALSE);
    }
    InitCommonControls();

    // Figure out how the window should be shown.
    if ((SW_NORMAL == nCmdShow) && (IVF_MAXIMIZED & dwFlags))
    {
        nCmdShow = SW_MAXIMIZE;
    }

    // Show window.
    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    return (TRUE);
}   // End of function InitInstance

//
// Private functions
//

//////////////////////////////////////////////////////////////////////////
//  Function:  RegisterICMViewClasses
//
//  Description:
//    Registers the window class
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//    This function and its usage is only necessary if you want this code
//    to be compatible with Win32 systems prior to the 'RegisterClassEx'
//    function that was added to Windows 95. It is important to call this
//    function so that the application will get 'well formed' small icons
//    associated with it.
//
//////////////////////////////////////////////////////////////////////////
BOOL RegisterICMViewClasses(HINSTANCE hInstance)
{
    // Local variables
    BOOL          bAppClass, bChildClass;   // Booleans indicate if classes registered successfully
    WNDCLASSEX    wcex;

    //  Initialize variables
    bAppClass = bChildClass = FALSE;
    wcex.style         = 0;
    wcex.lpfnWndProc   = (WNDPROC)WndProc;
    wcex.cbClsExtra    = 0;
    wcex.cbWndExtra    = ICMVIEW_CBWNDEXTRA;
    wcex.hInstance     = hInstance;
    wcex.hIcon         = LoadIcon (hInstance, APPNAME);
    wcex.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);

    // Set menu depending upon Operating System
    wcex.lpszMenuName = APPNAME;
    wcex.lpszClassName = APPNAME;

    // Added elements for Windows 95:
    wcex.cbSize = sizeof(WNDCLASSEX);
    wcex.hIconSm = LoadIcon(wcex.hInstance, __TEXT("SMALL"));

    // Register App Class
    bAppClass = RegisterClassEx(&wcex);

    if (bAppClass)
    {
        // Register the child class
        wcex.style         = CS_SAVEBITS;
        wcex.lpfnWndProc   = ChildWndProc;
        wcex.lpszMenuName  = (LPCTSTR)NULL;
        wcex.cbWndExtra    = CHILD_CBWNDEXTRA;
        wcex.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
        wcex.lpszClassName = CHILD_CLASSNAME;
        wcex.hIcon         = NULL;
        bChildClass = RegisterClassEx(&wcex);
    }
    return    (   bAppClass    &&    bChildClass);
}   // End of function RegisterICMViewClasses

//////////////////////////////////////////////////////////////////////////
//  Function:  CreateGlobalDIBInfo
//
//  Description:
//    Creates and initializes the DIBINFO structure for the global ICMVIEW application window.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL CreateGlobalDIBInfo(void)
{
    // Local variables
    HGLOBAL     hDIBInfo;
    LPDIBINFO   lpDIBInfo;

    //  Initialize variables
    hDIBInfo = CreateDIBInfo();
    if (NULL == hDIBInfo)
    {
        DebugMsg(__TEXT("CreateGlobalDIBInfo:  CreateDIBInfo failed.\r\n"));
        return(FALSE);
    }
    lpDIBInfo = GlobalLock(hDIBInfo);
    lpDIBInfo->hWndOwner = ghAppWnd;
    GlobalUnlock(hDIBInfo);
    SetWindowLong(ghAppWnd, GWL_DIBINFO, (LONG)hDIBInfo);
    GetDefaultICMInfo();
    return(TRUE);
}   // End of function CreateGlobalDIBInfo


//////////////////////////////////////////////////////////////////////////
//  Function:  GetSettings
//
//  Description:
//    Grabs stored settings from registry.
//
//  Parameters:
//    lpRect    Pointer to rect of window position and size.
//    phRecent  Pointer to handle of an array of most recent files.
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL GetSettings(LPRECT lpRect, LPDWORD pdwFlags, LPHANDLE phRecent)
{
    HKEY    hKey;
    LONG    lResult;
    DWORD   dwSize;
    DWORD   dwType;

    // Initialize coordinates and recent file list in case we fail.
    if (NULL != phRecent)
    {
        // Free and re-allocate.
        if (NULL != *phRecent)
        {
            GlobalFree(*phRecent);
        }

        // Allocate string table.
        *phRecent = GlobalAlloc(GHND, (sizeof(LPTSTR) + MAX_PATH * sizeof(TCHAR)) * MAX_RECENT);
    }
    if (NULL != lpRect)
    {
        SetRect(lpRect, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT);
    }

    // Open top level registry to application settings.
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER, APP_REG, 0L, KEY_ALL_ACCESS, &hKey);
    if (ERROR_SUCCESS == lResult)
    {
        // INVARIANT:  Application registry key exists.
        // If lpRect is non-null, attempt to get the stored window coord.
        if (NULL != lpRect)
        {
            dwSize = sizeof(RECT);
            RegQueryValueEx(hKey, APP_COORD, NULL, &dwType, (LPBYTE)lpRect, &dwSize);
        }

        // Get stored state flags.
        dwSize = sizeof(DWORD);
        RegQueryValueEx(hKey, APP_FLAGS, NULL, &dwType, (LPBYTE)pdwFlags, &dwSize);

        // If ppszRecent is non-null, attempt to get the stored recent file list.
        if (NULL != phRecent)
        {
            TCHAR    szReg[32];
            DWORD   dwCount;
            LPTSTR  *ppszRecent;

            // Make sure alloc succeded from above.
            if (NULL == *phRecent)
            {
                RegCloseKey(hKey);
                return FALSE;
            }
            ppszRecent = (LPTSTR*)GlobalLock(*phRecent);

            // Get each of the recent files.
            for (dwCount = 0; dwCount < MAX_RECENT; dwCount++)
            {
                // Build the key name to the nth recent file.
                wsprintf(szReg, __TEXT("%s%d"), APP_RECENT, dwCount);

                // Get the size of the recent file string.
                dwSize = 0;
                lResult = RegQueryValueEx(hKey, szReg, NULL, &dwType, NULL, &dwSize);

                // Alloc the string and attempt to get the recent file.
                if ((ERROR_SUCCESS == lResult) && (0 != dwSize))
                {
                    ASSERT(dwSize <= MAX_PATH);
                    ppszRecent[dwCount] = (LPTSTR) ((LPBYTE)(ppszRecent + MAX_RECENT) + MAX_PATH
                                                    * sizeof(TCHAR) * dwCount);
                    if (NULL != ppszRecent[dwCount])
                    {
                        RegQueryValueEx(hKey, szReg, NULL, &dwType, (LPBYTE)ppszRecent[dwCount], &dwSize);
                    }
                }
            }
        }
        RegCloseKey(hKey);
        GlobalUnlock(*phRecent);
    }
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:  SetSettings
//
//  Description:
//    Store settings into registry.
//
//  Parameters:
//    lpRect          Pointer to rect of window position and size.
//    ppszRecent      Pointer to an array of most recent files.
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL SetSettings(LPRECT lpRect, DWORD dwFlags, HANDLE hRecent)
{
    HKEY    hKey;
    LONG    lResult;
    DWORD   dwType;
    LPTSTR  *ppszRecent = NULL;

    // Open top level registry to application settings.
    lResult = RegCreateKeyEx(HKEY_CURRENT_USER, APP_REG, 0L, NULL,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                             &hKey, &dwType);
    if (ERROR_SUCCESS == lResult)
    {
        // INVARIANT:  Application registry key exists or has been created.
        // If lpRect is non-null, attempt to store the window coord.
        if (NULL != lpRect)
        {
            RegSetValueEx(hKey, APP_COORD, 0, REG_BINARY, (LPBYTE)lpRect, sizeof(RECT));
        }

        // Store ICMView state flags.
        RegSetValueEx(hKey, APP_FLAGS, 0, REG_DWORD, (LPBYTE)&dwFlags, sizeof(dwFlags));

        // If ppszRecent is non-null, attempt to store recent file list.
        if (NULL != hRecent)
        {
            ppszRecent = (LPTSTR*) GlobalLock(hRecent);
        }
        if (NULL != ppszRecent)
        {
            TCHAR    szReg[32];
            DWORD   dwCount;


            // Set each of the recent files.
            for (dwCount = 0; dwCount < MAX_RECENT; dwCount++)
            {
                // Build the key name to the nth recent file.
                wsprintf(szReg, __TEXT("%s%d"), APP_RECENT, dwCount);

                // Set the the recent file string.
                if (NULL != ppszRecent[dwCount])
                {
                    RegSetValueEx(hKey, szReg, 0, REG_SZ, (LPBYTE)ppszRecent[dwCount],
                                  lstrlen(ppszRecent[dwCount]) * sizeof(TCHAR) );
                }
            }
            GlobalUnlock(hRecent);
        }
        RegCloseKey(hKey);
    }
    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:  AddRecentFile
//
//  Description:
//    Adds and displays recent file strins.
//
//  Parameters:
//    hWnd                    Window that was menu and prop for recent file list.
//    lpszFileName    File name string to add to recent files list.
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL AddRecentFile(HWND hWnd, LPTSTR lpszFileName)
{
    int             nFind;
    int             nCount;
    HANDLE  hRecent;
    LPTSTR  *ppszRecent;

    // Make sure valid paramters.
    if (!IsWindow(hWnd) || (NULL == lpszFileName) ||(lstrlen(lpszFileName) == 0))
    {
        return FALSE;
    }

    // Get Recent file list.
    hRecent = GetProp(hWnd, APP_RECENT);
    if (NULL == hRecent)
    {
        return FALSE;
    }

    // Get pointer to string array.
    ppszRecent = (LPTSTR*) GlobalLock(hRecent);
    ASSERT(ppszRecent != NULL);

    // Search array for an occurence of the string
    // we are adding.
    for (nFind = 0; (nFind < MAX_RECENT) && (NULL != ppszRecent[nFind])
        && lstrcmpi(ppszRecent[nFind], lpszFileName); nFind++);

    // Make sure that nFind element is valid string.
    // nFind - 1 should be non null or not indexed.
    if ( (nFind < MAX_RECENT) && (NULL == ppszRecent[nFind]))
    {
        ppszRecent[nFind] = (LPTSTR)((LPBYTE)(ppszRecent + MAX_RECENT) + MAX_PATH * sizeof(TCHAR) * nFind);
    }

    // Move strings from nFind to zero down one to make room
    // to add string to top of list.
    for (nCount = __min(nFind, MAX_RECENT -1); nCount > 0; nCount--)
        _tcscpy(ppszRecent[nCount], ppszRecent[nCount -1]);

    // Add file to first position.
    _tcscpy(ppszRecent[0], lpszFileName);

    // Unlock array.
    GlobalUnlock(hRecent);

    // Display strings.
    UpdateRecentFiles(hWnd, hRecent);

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//  Function:  UpdateRecentFiles
//
//  Description:
//    Displays recent files.
//
//  Parameters:
//
//    hWnd            Window that was menu and prop for recent file list.
//    hRecent         Handle to an array of most recent files.
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////

BOOL UpdateRecentFiles(HWND hWnd, HANDLE hRecent)
{
    int                    nMenuAdjust;
    int                    nCount;
    TCHAR                  szTemp[MAX_PATH + 4];
    HWND                   hwndActiveChild;
    HMENU                  hMenu;
    LPTSTR                 *ppszRecent;
    MENUITEMINFO          ItemInfo;

    // Validate paramters.
    if ( !IsWindow(hWnd) || (NULL == hRecent) )
    {
        return FALSE;
    }

    // Get current active MDI window and check to see
    // if it is maximized.  Need to add 1 to menu if it
    // is maximized.
    hwndActiveChild = GetCurrentMDIWnd();
    nMenuAdjust = 0;
    if (IsZoomed(hwndActiveChild))
    {
        nMenuAdjust = 1;
    }

    // Get file menu.
    hMenu = GetMenu(hWnd);
    ASSERT(hMenu != NULL);
    hMenu = GetSubMenu(hMenu, RECENT_MENU + nMenuAdjust);
    ASSERT(hMenu != NULL);
    ASSERT(GetMenuItemCount(hMenu) > RECENT_POSITION);

    // Get pointer to recent file array.
    ppszRecent = (LPTSTR*) GlobalLock(hRecent);
    ASSERT(ppszRecent != NULL);

    // Add each string in recent file list to menu.
    // Replace menu items until separator, then insert them.
    for (nCount = 0; nCount < MAX_RECENT; nCount++)
    {
        // Only add strings that are not null or zero length.
        if ( (NULL != ppszRecent[nCount]) && (lstrlen(ppszRecent[nCount]) != 0) )
        {
            // Build recent file menu string.
            wsprintf(szTemp, __TEXT("&%d %s"), nCount +1, ppszRecent[nCount]);

            // Determine if replacing item or inserting.
            memset(&ItemInfo, 0, sizeof(MENUITEMINFO));
            ItemInfo.cbSize = sizeof(MENUITEMINFO);
            ItemInfo.fMask = MIIM_TYPE;
            GetMenuItemInfo(hMenu, RECENT_POSITION + nCount, TRUE, &ItemInfo);
            if (MFT_SEPARATOR == ItemInfo.fType)
            {
                // Insert item. MIIM_ID
                ItemInfo.fMask = MIIM_TYPE | MIIM_ID;
                ItemInfo.wID = IDM_FILE_RECENT + nCount;
                ItemInfo.fType = MFT_STRING;
                ItemInfo.dwTypeData = szTemp;
                ItemInfo.cch = lstrlen(ItemInfo.dwTypeData);
                InsertMenuItem(hMenu, RECENT_POSITION + nCount, TRUE, &ItemInfo);
            }
            else
            {
                // Replace menu item.
                ItemInfo.fMask = MIIM_TYPE | MIIM_STATE;
                ItemInfo.fState = MFS_ENABLED;
                ItemInfo.fType = MFT_STRING;
                ItemInfo.dwTypeData = szTemp;
                ItemInfo.cch = lstrlen(ItemInfo.dwTypeData);
                SetMenuItemInfo(hMenu, RECENT_POSITION + nCount, TRUE, &ItemInfo);
            }
        }
    }

    // Unlock recent array.
    GlobalUnlock(hRecent);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\child.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    Child.H
//
//  PURPOSE:
//    Include file for CHILD.C.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//
// local definitions
#define GetCurrentMDIWnd() (HWND)(SendMessage(ghWndMDIClient, WM_MDIGETACTIVE, 0, 0L))


// For use in creating children windows
#define CHILD_CLASSNAME __TEXT("ICMVIEWCHILD")
#define CHILD_CBWNDEXTRA  (sizeof(LPDIBINFO))
#define ICMVIEW_CBWNDEXTRA (sizeof(LPDIBINFO))
#define FIRSTCHILD  1
#define WINDOWMENU_POS  2
#define MYWM_QUERYNEWPALETTE  WM_USER+1
#define MYWM_PALETTECHANGED   WM_USER+2

//
// Public functions
//
LRESULT CALLBACK ChildWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD CreateNewImageWindow(HANDLE hDIBInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\debug.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DEBUG.C
//
//  PURPOSE:
//    Debugging routines.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include <icm.h>


// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings
#pragma warning(default:4514)   // Unreferenced inline function has been removed

// C RunTime Header Files
#include <stdio.h>
#include <TCHAR.H>
#include <stdlib.h>

// Local Header Files
#include "icmview.h"
#include "dibinfo.h"
#define I_AM_DEBUG
#include "Debug.h"
#undef I_AM_DEBUG

// local definitions

// default settings

// external functions

// external data

// public data

// private data

// public functions

// private functions




//////////////////////////////////////////////////////////////////////////
//  Function:  _Assert
//
//  Description:
//    Replacement assertion function
//
//  Parameters:
//    LPSTR    Name of file
//    UINT      Line number@@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void _Assert(LPSTR strFile, UINT uiLine)
{
    // Local variables
    char  stAssert[255];

    //  Initialize variables
    wsprintfA(stAssert, "Assertion failed %s, line %u\r\n", strFile, uiLine);
    OutputDebugStringA(stAssert);
} // End of function _Assert

///////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: DebugMsg
//
//  PURPOSE:
//    To provide a printf type DebugMsg function.
//
//  PARAMETERS:
//    LPTSTR  Format string
//    <variable arguments>  printf-style arguments
//
//  RETURN VALUE:
//    void
//
//  COMMENTS:
//
///////////////////////////////////////////////////////////////////////////

void DebugMsg (LPTSTR lpszMessage,...)
{
#ifdef _DEBUG
    va_list VAList;
    TCHAR   szMsgBuf[256];

    // Pass the variable parameters to wvsprintf to be formated.
    va_start(VAList, lpszMessage);
    wvsprintf(szMsgBuf, lpszMessage, VAList);
    va_end(VAList);

    ASSERT(lstrlen((LPTSTR)szMsgBuf) < MAX_DEBUG_STRING);
    OutputDebugString(szMsgBuf);
#endif
    lpszMessage = lpszMessage;  // Eliminates 'unused formal parameter' warning
}

void DebugMsgA (LPSTR lpszMessage,...)
{
#ifdef _DEBUG
    va_list VAList;
    char    szMsgBuf[256];

    // Pass the variable parameters to wvsprintf to be formated.
    va_start(VAList, lpszMessage);
    wvsprintfA(szMsgBuf, lpszMessage, VAList);
    va_end(VAList);

    ASSERT(strlen((LPSTR)szMsgBuf) < MAX_DEBUG_STRING);
    OutputDebugStringA(szMsgBuf);
#endif
    lpszMessage = lpszMessage;  // Eliminates 'unused formal parameter' warning
}


///////////////////////////////////////////////////////////////////////////
//
//  FUNCTION: ErrMsg
//
//  PURPOSE:
//    To provide a printf type error message box.
//
//  PARAMETERS:
//    LPTSTR  wsprintf-style format string
//    ...     formatting information
//
//  RETURN VALUE:
//    Value from MessageBox function; 0 if failure, non-zero
//    otherwise.  For specific values, see MessageBox.
//
//  COMMENTS:
//
///////////////////////////////////////////////////////////////////////////
int ErrMsg (HWND hwndOwner, LPTSTR lpszMessage,...)
{
    va_list VAList;
    TCHAR   szMsgBuf[256];

    // Pass the variable parameters to wvsprintf to be formated.
    va_start(VAList, lpszMessage);
    wvsprintf(szMsgBuf, lpszMessage, VAList);
    va_end(VAList);

    ASSERT(lstrlen((LPTSTR)szMsgBuf) < MAX_DEBUG_STRING);
    return(MessageBox(hwndOwner, (LPCTSTR)szMsgBuf, (LPCTSTR)__TEXT("Error"), MB_ICONSTOP|MB_APPLMODAL));
}

//////////////////////////////////////////////////////////////////////////
//  Function:  DumpMemory
//
//  Description:
//    Dumps values at specified memory.
//
//  Parameters:
//    LPVOID    Pointer to memory
//    UINT      Size of each element, i.e. 8 or 16
//    UINT      Number of elements to dump.
//
//  Returns:
//    void
//
//  Comments:
//    -Need to add validation of uiElementSize.
//    -uiElementSize * uiNumElements should not exceed the size
//     of the buffer; otherwise, wacky and wonderful events will
//     take place.
//
//////////////////////////////////////////////////////////////////////////
void DumpMemory(LPBYTE lpbMem, UINT uiElementSize, UINT uiNumElements)
{
    // Local variables
    UINT  uiIdx;

    uiElementSize = uiElementSize; // Eliminates 'unused formal parameters'

    // Initialize variables
    for (uiIdx = 0; uiIdx < uiNumElements; uiIdx++)
    {
        if (uiIdx == 0 || ((uiIdx % 16) == 0))
        {
            DebugMsg(__TEXT("\r\n0x%08X\t"), (DWORD)(lpbMem + (uiIdx)));
        }
        DebugMsg(__TEXT("%02x "), (WORD)*(lpbMem + uiIdx));
    }
} // End of function DumpMemory

//////////////////////////////////////////////////////////////////////////
//  Function:  DumpProfile
//
//  Description:
//    Dumps the PROFILE structure provided.
//
//  Parameters:
//    PPROFILE  Pointer to the profile.
//
//  Returns:
//    void
//
//  Comments:
//////////////////////////////////////////////////////////////////////////
void DumpProfile(PPROFILE pProfile)
{
    // Local variables
    TCHAR   stProfileType[MAX_PATH];

    // Initialize variables
    if (pProfile == NULL)
    {
        DebugMsg(__TEXT("DEBUG.C : DumpProfile : NULL pProfile\r\n"));
        return;
    }

    // Set type string
    _tcscpy(stProfileType, __TEXT("UNKNOWN"));
    if (PROFILE_FILENAME == pProfile->dwType)
    {
        _tcscpy(stProfileType, __TEXT("FILE"));
    }
    if (PROFILE_MEMBUFFER == pProfile->dwType)
    {
        _tcscpy(stProfileType, __TEXT("MEMBUFFER"));
    }

    DebugMsg(__TEXT("***** PROFILE *****\r\n"));
    DebugMsg(__TEXT("pProfile        0x%08lX\r\n"), pProfile);
    DebugMsg(__TEXT("dwType          %s\r\n"), stProfileType);
    DebugMsg(__TEXT("pProfileData    0x%08lX\r\n"), pProfile->pProfileData);
    if (PROFILE_FILENAME == pProfile->dwType)
    {
        DebugMsg(__TEXT("Filename        %s\r\n"), pProfile->pProfileData);
    }
    DebugMsg(__TEXT("cbDataSize      %ld\r\n\r\n"), pProfile->cbDataSize);
} // End of function DumpMemory


//////////////////////////////////////////////////////////////////////////
//  Function:  DumpRectangle
//
//  Description:
//    Dumps the coordinates of a rectangle structure
//
//  Parameters:
//    LPTSTR    Comment
//    LPRECT    Rectangle to dump
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void DumpRectangle(LPTSTR lpszDesc, LPRECT lpRect)
{
    DebugMsg(__TEXT("%s:  %ld, %ld, %ld, %ld\r\n"), lpszDesc, lpRect->left, lpRect->top, lpRect->right,
             lpRect->bottom);
}   // End of function DumpRectangle


//////////////////////////////////////////////////////////////////////////
//  Function:  SafeFree
//
//  Description:
//    Debug Free routine which checks lock counts and return codes.
//
//  Parameters:
//    @@@
//
//  Returns:
//    HGLOBAL
//
//  Comments:
//    This function assumes that the HGLOBAL object has been unlocked;
//    if not, the item will still be freed, but a warning message will
//    be displayed.  This is useful for tracking down items which have
//    been locked without being unlocked.
//
//    The last error value will be preserved if no error occurs in this
//    function.  If an error does occur, it will be passed to the calling
//    function.
//
//////////////////////////////////////////////////////////////////////////
HGLOBAL SafeFree(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory)
{
    // Local variables
    UINT      uiLockCount, uiFlags;
    DWORD     dwLastError;
    HGLOBAL   hFreed;                         // Return from GlobalFree
    TCHAR   szName[MAX_PATH], szExt[MAX_PATH];

    //  Initialize variables
    _tsplitpath(lpszFile, NULL, NULL, szName, szExt);
    wsprintf(lpszFile,__TEXT("%s%s"), szName, szExt);
    if (NULL == hMemory)
    {
        DebugMsg(__TEXT("%s(%lu) : SafeFree:  NULL hMem!!!  This will cause an exception!!!!   Fix it!!!\r\n"), lpszFile, uiLine);
        DebugBreak();
        return(NULL);
    }
    SetLastError(0);

    hFreed = GlobalFree(hMemory);
    if (NULL != hFreed) // unsuccessful free
    {
        dwLastError = GetLastError();
        uiFlags = GlobalFlags(hMemory);
        uiLockCount = uiFlags & GMEM_LOCKCOUNT;
        uiFlags = HIBYTE(LOWORD(uiFlags));
        DebugMsg(__TEXT("SafeFree : <%s(%lu)> failed\tLastError = %ld, Flags = %lu, Lock Count = %lu\r\n"),
                 lpszFile, uiLine, dwLastError, uiFlags, uiLockCount);
    }
    return(hFreed);
}   // End of function SafeFree

//////////////////////////////////////////////////////////////////////////
//  Function:  SafeUnlock
//
//  Description:
//    Unlocks handle and displays the lock count and flags information.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL SafeUnlock(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory)
{
    // Local variables
    BOOL    bUnlocked;
    UINT    uiLockCount,   uiFlags;
    DWORD   dwLastError;
    TCHAR   szName[MAX_PATH], szExt[MAX_PATH];

    //  Initialize variables
    _tsplitpath(lpszFile, NULL, NULL, szName, szExt);
    wsprintf(lpszFile, __TEXT("%s%s"), szName, szExt);

    if (NULL == hMemory)
    {
        DebugMsg(__TEXT("%s(%lu) : SafeUnlock:  NULL hMem\r\n"), lpszFile, uiLine);
        return(0);
    }
    SetLastError(0);

    bUnlocked = GlobalUnlock(hMemory);
    dwLastError = GetLastError();
    uiFlags = GlobalFlags(hMemory);
    uiLockCount = uiFlags & GMEM_LOCKCOUNT;
    if (0 != dwLastError)
    {
        uiFlags = HIBYTE(LOWORD(uiFlags));
    }
    DebugMsg(__TEXT("SafeUnlock : <%s(%lu)>\tGlobalUnlock(0x%08lX) returned %4d w/LastError = %4ld, Lock Count = %4lu, Flags = %4lu\r\n"),
             lpszFile, uiLine, hMemory, bUnlocked, dwLastError, uiLockCount, uiFlags);
    return(bUnlocked);
}   // End of function SafeUnlock



//////////////////////////////////////////////////////////////////////////
//  Function:  SafeLock
//
//  Description:
//    Locks memory and reports lock count.
//
//  Parameters:
//    @@@
//
//  Returns:
//    LPVOID
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPVOID SafeLock(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory)
{
    // Local variables
    LPVOID  lpMem;
    UINT    uiLockCount, uiFlags;
    DWORD   dwLastError;
    TCHAR   szName[MAX_PATH], szExt[MAX_PATH];

    //  Initialize variables
    _tsplitpath(lpszFile, NULL, NULL, szName, szExt);
    wsprintf(lpszFile, __TEXT("%s%s"), szName, szExt);
    if (NULL == hMemory)
    {
        DebugMsg(__TEXT("%s(%lu) : SafeLock:  NULL hMem\r\n"), lpszFile, uiLine);
        return((LPVOID)NULL);
    }
    SetLastError(0);

    lpMem = GlobalLock(hMemory);
    dwLastError = GetLastError();
    uiFlags = GlobalFlags(hMemory);
    uiLockCount = uiFlags & GMEM_LOCKCOUNT;
    uiFlags = HIBYTE(LOWORD(uiFlags));

    DebugMsg(__TEXT("SafeLock : <%s(%lu)>\tGlobalLock(0x%08lX) returned 0x%08lX w/LastError = %ld, Lock Count = %lu, Flags = %lu\r\n"),
             lpszFile, uiLine, hMemory, lpMem, dwLastError, uiLockCount, uiFlags);
    return(lpMem);
}   // End of function SafeLock

//////////////////////////////////////////////////////////////////////////
//  Function:  FormatLastError
//
//  Description:
//    Allocates and formats a string of LastError's text-equivalent message.
//    If the caller requests, the message will be displayed and the memory
//    will be deallocated.
//
//  Parameters:
//    LPTSTR  Name of file where error occured
//    UINT    Line of file at which point error occured
//    DWORD Numeric value of LastError
//    UINT  Display and free indicator
//            LASTERROR_NOALLOC  Display via DebugMsg and deallocate
//            LASTERROR_ALLOC    Return pointer to allocated string
//
//  Returns:
//    BOOL
//
//  Comments:
//    Caller must free memory returned by this function.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR FormatLastError(LPTSTR lpszFile, UINT uiLine, UINT uiOutput, DWORD dwLastError)
{
    // Local variables
    LPTSTR  lpszLastErrorMsg;
    LPTSTR  lpszDebugMsg;
    DWORD   cbBytes;

    //  Initialize variables
    lpszLastErrorMsg = NULL;
    cbBytes = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                            | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            dwLastError,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language
                            (LPTSTR) &lpszLastErrorMsg,
                            0,
                            NULL );

    if (0 == cbBytes) // Error occured in FormatMessage
    {
        SetLastError(dwLastError); // restore the last error to time of call
    }

    // Create the error message
    lpszDebugMsg = GlobalAlloc(GPTR, ((cbBytes + 512) * sizeof(TCHAR)));
    ASSERT(NULL != lpszDebugMsg);
    wsprintf(lpszDebugMsg, __TEXT("<%s(%lu)>:\r\n\tLastError(ld, lu) = (%ld, %lu)\r\n\t\t%s\r\n"),
             lpszFile,
             uiLine,
             dwLastError,
             dwLastError,
             NULL != lpszLastErrorMsg ? lpszLastErrorMsg : __TEXT("UNKNOWN LASTERROR"));

    // Free the buffer memory if requested
    if (LASTERROR_NOALLOC == uiOutput)
    {
        DebugMsg(lpszDebugMsg);
        GlobalFree(lpszDebugMsg);
    }

    // Always free the string created by FormatMessage
    if (NULL != lpszLastErrorMsg)
    {
        GlobalFree(lpszLastErrorMsg);
    }
    return(lpszDebugMsg);
}   // End of function FormatLastError


//////////////////////////////////////////////////////////////////////////
//  Function:  DumpBITMAPFILEHEADER
//
//  Description:
//    Dumps the contents of a BITMAPFILEHEADER.
//
//  Parameters:
//    @@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void DumpBITMAPFILEHEADER(LPBITMAPFILEHEADER lpBmpFileHeader)
{
    // Local variables
    DebugMsg(__TEXT("////////////////// BITMAPFILEHEADER ///////////////////\r\n"));
    DebugMsg(__TEXT("sizeof(BITMAPFILEHEADER)    %ld\r\n"), sizeof(BITMAPFILEHEADER));
    DebugMsg(__TEXT("bfType                      0x%04x\r\n"), lpBmpFileHeader->bfType);
    DebugMsg(__TEXT("bfSize                      %ld\r\n"), lpBmpFileHeader->bfSize);
    DebugMsg(__TEXT("bfReserved1                 %d\r\n"), lpBmpFileHeader->bfReserved1);
    DebugMsg(__TEXT("bfReserved2                 %d\r\n"), lpBmpFileHeader->bfReserved1);
    DebugMsg(__TEXT("bfOffBits                   %ld\r\n"), lpBmpFileHeader->bfOffBits);
    DebugMsg(__TEXT("///////////////////////////////////////////////////////\r\n"));

    //  Initialize variables

}   // End of function DumpBITMAPFILEHEADER


//////////////////////////////////////////////////////////////////////////
//  Function:  DumpBITMAPINFOHEADER
//
//  Description:
//    Dumps a BITMAPINFO header structure.
//
//  Parameters:
//    @@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void DumpBmpHeader(LPVOID lpvBmpHeader)
{
    // Local variables
    LPBITMAPV5HEADER  lpBmpV5Header;
    TCHAR             stNumText[MAX_PATH];

    //  Initialize variables
    lpBmpV5Header = (LPBITMAPV5HEADER)lpvBmpHeader;

    switch (lpBmpV5Header->bV5Size)
    {
        case sizeof(BITMAPCOREHEADER):
            _tcscpy(stNumText,__TEXT("BITMAPCOREHEADER"));
            break;

        case sizeof(BITMAPINFOHEADER):
            _tcscpy(stNumText, __TEXT("BITMAPINFOHEADER"));
            break;

        case sizeof(BITMAPV4HEADER):
            _tcscpy(stNumText, __TEXT("BITMAPV4HEADER"));
            break;

        case sizeof(BITMAPV5HEADER):
            _tcscpy(stNumText,__TEXT("BITMAPV5HEADER"));
            break;

        default:
            _tcscpy(stNumText, __TEXT("UNKNOWN HEADER SIZE"));
            break;
    }
    DebugMsg(__TEXT("/////////////////// %s /////////////////////\r\n"), stNumText);
    DebugMsg(__TEXT("HeaderSize        %ld\r\n"), lpBmpV5Header->bV5Size);
    DebugMsg(__TEXT("Width             %lu\r\n"), lpBmpV5Header->bV5Width);
    DebugMsg(__TEXT("Height            %lu\r\n"), lpBmpV5Header->bV5Height);
    DebugMsg(__TEXT("Planes            %d\r\n"), lpBmpV5Header->bV5Planes);
    DebugMsg(__TEXT("BitCount          %d\r\n"), lpBmpV5Header->bV5BitCount);
    if ( sizeof(BITMAPCOREHEADER)== lpBmpV5Header->bV5Size) goto End;

    switch (lpBmpV5Header->bV5Compression)
    {
        case BI_RGB:
            _tcscpy(stNumText, __TEXT("BI_RGB"));
            break;

        case BI_RLE8:
            _tcscpy(stNumText, __TEXT("BI_RLE8"));
            break;

        case BI_RLE4:
            _tcscpy(stNumText,__TEXT("BI_RLE4"));
            break;

        case BI_BITFIELDS:
            _tcscpy(stNumText, __TEXT("BI_BITFIELDS"));
            break;

        default:
            _tcscpy(stNumText,__TEXT("Unknown Compression"));
            break;
    }
    DebugMsg(__TEXT("Compression       %s\r\n"), stNumText);
    DebugMsg(__TEXT("SizeImage         %ld\r\n"), lpBmpV5Header->bV5SizeImage);
    DebugMsg(__TEXT("XPelsPerMeter     %ld\r\n"), lpBmpV5Header->bV5XPelsPerMeter);
    DebugMsg(__TEXT("YPelsPerMeter     %ld\r\n"), lpBmpV5Header->bV5YPelsPerMeter);
    DebugMsg(__TEXT("ClrUsed           %ld\r\n"), lpBmpV5Header->bV5ClrUsed);
    DebugMsg(__TEXT("ClrImportant      %ld\r\n"), lpBmpV5Header->bV5ClrImportant);
    if (sizeof(BITMAPINFOHEADER) == lpBmpV5Header->bV5Size) goto End;

    DebugMsg(__TEXT("Red Mask          0x%08lx\r\n"), lpBmpV5Header->bV5RedMask);
    DebugMsg(__TEXT("Green Mask        0x%08lx\r\n"), lpBmpV5Header->bV5GreenMask);
    DebugMsg(__TEXT("Blue Mask         0x%08lx\r\n"), lpBmpV5Header->bV5BlueMask);
    DebugMsg(__TEXT("Alpha Mask        0x%08lx\r\n"), lpBmpV5Header->bV5AlphaMask);

    DebugMsg(__TEXT("CS Type           "));
    switch (lpBmpV5Header->bV5CSType)
    {
        case PROFILE_LINKED:
            DebugMsg(__TEXT("LINKED\r\n"));
            break;

        case PROFILE_EMBEDDED:
            DebugMsg(__TEXT("EMBEDDED\r\n"));
            break;

        default:
            DebugMsg(__TEXT("0x%08lx\r\n"), lpBmpV5Header->bV5CSType);
            break;
    }


    DebugMsg(__TEXT("Gamma Red         %ld\r\n"), lpBmpV5Header->bV5GammaRed);
    DebugMsg(__TEXT("Gamma Green       %ld\r\n"), lpBmpV5Header->bV5GammaGreen);
    DebugMsg(__TEXT("Gamma Blue        %ld\r\n"), lpBmpV5Header->bV5GammaBlue);
    if (sizeof(BITMAPV4HEADER) == lpBmpV5Header->bV5Size) goto End;

    DebugMsg(__TEXT("Intent            %ld\r\n"), lpBmpV5Header->bV5Intent);
    DebugMsg(__TEXT("ProfileData       %ld\r\n"), lpBmpV5Header->bV5ProfileData);
    DebugMsg(__TEXT("ProfileSize       %ld\r\n"), lpBmpV5Header->bV5ProfileSize);
    DebugMsg(__TEXT("Reserved          %ld\r\n"), lpBmpV5Header->bV5Reserved);

    End:
    DebugMsg(__TEXT("///////////////////////////////////////////////////////\r\n"));
}   // End of function DumpBITMAPINFOHEADER


//////////////////////////////////////////////////////////////////////////
//  Function:  DumpLogColorSpace
//
//  Description:
//    Dumps a LOGCOLORSPACE structure.
//
//  Parameters:
//    @@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////

void DumpLogColorSpace(LPLOGCOLORSPACE pColorSpace)
{
    DebugMsg(__TEXT("/////////////////// LOGCOLORSPACE /////////////////////\r\n"));
    DebugMsg(__TEXT("lcsSignature                       %#lx\r\n"), pColorSpace->lcsSignature);
    DebugMsg(__TEXT("lcsVersion                         %#lx\r\n"), pColorSpace->lcsVersion);
    DebugMsg(__TEXT("lcsSize                            %#lx\r\n"), pColorSpace->lcsSize);
    DebugMsg(__TEXT("lcsCSType                          %#lx\r\n"), pColorSpace->lcsCSType);
    DebugMsg(__TEXT("lcsIntent                          %#lx\r\n"), pColorSpace->lcsIntent);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzRed.ciexyzX      %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzRed.ciexyzX);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzRed.ciexyzY      %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzRed.ciexyzY);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzRed.ciexyzZ      %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzRed.ciexyzZ);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzGreen.ciexyzX    %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzGreen.ciexyzX);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzGreen.ciexyzY    %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzGreen.ciexyzY);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzGreen.ciexyzZ    %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzGreen.ciexyzZ);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzBlue.ciexyzX     %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzBlue.ciexyzX);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzBlue.ciexyzY     %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzBlue.ciexyzY);
    DebugMsg(__TEXT("lcsEndpoints.ciexyzBlue.ciexyzZ     %#lx\r\n"), pColorSpace->lcsEndpoints.ciexyzBlue.ciexyzZ);
    DebugMsg(__TEXT("lcsGammaRed                        %#lx\r\n"), pColorSpace->lcsGammaRed);
    DebugMsg(__TEXT("lcsGammaGreen                      %#lx\r\n"), pColorSpace->lcsGammaGreen);
    DebugMsg(__TEXT("lcsGammaBlue                       %#lx\r\n"), pColorSpace->lcsGammaBlue);
    DebugMsg(__TEXT("lcsFilename                        %s\r\n"), pColorSpace->lcsFilename);
    DebugMsg(__TEXT("///////////////////////////////////////////////////////\r\n"));
}

//////////////////////////////////////////////////////////////////////////
//  Function:  DumpCOLORMATCHSETUP
//
//  Description:
//    Dumps COLORMATCHSETUP structure
//
//  Parameters:
//    @@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void DumpCOLORMATCHSETUP(LPCOLORMATCHSETUP lpCM)
{
    // Local variables

    //  ASSERTs and parameter validations
    DebugMsg(__TEXT("***** COLORMATCHSETUP 0x%08lx\r\n"), lpCM);
    DebugMsg(__TEXT("dwSize                        %ld\r\n"),     lpCM->dwSize);
    DebugMsg(__TEXT("dwVersion                     0x%08lx\r\n"), lpCM->dwVersion);
    DebugMsg(__TEXT("dwFlags                       0x%08lx\r\n"), lpCM->dwFlags);
    DebugMsg(__TEXT("hwndOwner                     0x%08lx\r\n"), lpCM->hwndOwner);

    DebugMsg(__TEXT("pSourceName                   0x%08lX <%s>\r\n"), lpCM->pSourceName   , lpCM->pSourceName    ? lpCM->pSourceName    : __TEXT("NULL PTR"));
    DebugMsg(__TEXT("pDisplayName                  0x%08lX <%s>\r\n"), lpCM->pDisplayName   , lpCM->pDisplayName    ? lpCM->pDisplayName    : __TEXT("NULL PTR"));
    DebugMsg(__TEXT("pPrinterName                  0x%08lX <%s>\r\n"), lpCM->pPrinterName   , lpCM->pPrinterName    ? lpCM->pPrinterName    : __TEXT("NULL PTR"));

    DebugMsg(__TEXT("dwRenderIntent                %ld\r\n"),     lpCM->dwRenderIntent);
    DebugMsg(__TEXT("dwProofingIntent              %ld\r\n"),     lpCM->dwProofingIntent);

    DebugMsg(__TEXT("pMonitorProfile               0x%08lX <%s>\r\n"), lpCM->pMonitorProfile   , lpCM->pMonitorProfile    ? lpCM->pMonitorProfile    : __TEXT("NULL PTR"));
    DebugMsg(__TEXT("ccMonitorProfile              %ld\r\n"),     lpCM->ccMonitorProfile);

    DebugMsg(__TEXT("pPrinterProfile               0x%08lX <%s>\r\n"), lpCM->pPrinterProfile   , lpCM->pPrinterProfile    ? lpCM->pPrinterProfile    : __TEXT("NULL PTR"));
    DebugMsg(__TEXT("ccPrinterProfile              %ld\r\n"),     lpCM->ccPrinterProfile);

    DebugMsg(__TEXT("pTargetProfile                0x%08lX <%s>\r\n"), lpCM->pTargetProfile   , lpCM->pTargetProfile    ? lpCM->pTargetProfile    : __TEXT("NULL PTR"));
    DebugMsg(__TEXT("ccTargetProfile               %ld\r\n"),     lpCM->ccTargetProfile);

    DebugMsg(__TEXT("lpfnHook                      0x%08lx\r\n"), lpCM->lpfnHook);
    DebugMsg(__TEXT("lParam                        0x%08lx\r\n"), lpCM->lParam);
    DebugMsg(__TEXT("***** COLORMATCHSETUP 0x%08lx\r\n"), lpCM);
} // End of function DumpCOLORMATCHSETUP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\debug.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DEBUG.H
//
//  PURPOSE:
//    Include file for DEBUG.C
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//
#ifndef _ICM_H_
    #include "icm.h"
#endif

#ifdef DBG
    #define _DEBUG
#endif

// General pre-processor macros
// Constants used by ICM_Debug functions
#define MAX_DEBUG_STRING    256

// Constants used to set unitialized values
#define UNINIT_BYTE     0x17
#define UNINIT_DWORD    0x17171717

// ASSERT macro to display problem information in DEBUG build
#ifdef _DEBUG
    #define ASSERT(exp)               \
    if(exp)                           \
    {                                 \
      NULL;                           \
    }                                 \
    else                              \
    {                                 \
      _Assert(__FILE__, __LINE__);    \
    }
#else
    #define ASSERT(exp)   NULL
#endif

#ifdef DEBUG_MEMORY
    #ifndef I_AM_DEBUG
        #define GlobalFree(hMem)   SafeFree(__FILE__, __LINE__, hMem)
        #define GlobalUnlock(hMem) SafeUnlock(__FILE__, __LINE__, hMem)
        #define GlobalLock(hMem)   SafeLock(__FILE__, __LINE__, hMem)
    #endif
#endif

// Used by FormatLastError to determine if string should be allocated
// and returned or just displayed and freed.
#define LASTERROR_ALLOC      1
#define LASTERROR_NOALLOC    2

#define DISPLAY_LASTERROR(ui,dw) FormatLastError(__FILE__, __LINE__, ui, dw)


// General STRUCTS && TYPEDEFS

// Function prototypes
void    _Assert(LPSTR lpszFile, UINT uLine);
void    DebugMsg (LPTSTR sz,...);
void    DebugMsgA (LPSTR lpszMessage,...);
int     ErrMsg (HWND hwndOwner, LPTSTR sz,...);
void    DumpMemory(LPBYTE lpbMem, UINT uiElementSize, UINT uiNumElements);
void    DumpRectangle(LPTSTR lpszDesc, LPRECT lpRect);
void    DumpProfile(PPROFILE pProfile);
void    DumpBmpHeader(LPVOID lpvBmpHeader);
void    DumpBITMAPFILEHEADER(LPBITMAPFILEHEADER lpBmpFileHeader);
void    DumpLogColorSpace(LPLOGCOLORSPACE pColorSpace);
void    DumpCOLORMATCHSETUP(LPCOLORMATCHSETUP lpCM);
HGLOBAL SafeFree(LPTSTR lpszFile, UINT uLine, HGLOBAL hMemory);
BOOL    SafeUnlock(LPTSTR lpszFile, UINT uLine, HGLOBAL hMemory);
LPVOID  SafeLock(LPTSTR lpszFile, UINT uiLine, HGLOBAL hMemory);
LPSTR   FormatLastError(LPSTR lpszFile, UINT uiLine, UINT uiOutput, DWORD dwLastError);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\dialogs.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DIALOGS.H
//
//  PURPOSE:
//    Include file for DIALOGS.C
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// General pre-processor macros
#define DIB_PROPSHEET_MIN      0
#define DIB_PROPSHEET_DISPLAY  0
#define DIB_PROPSHEET_PRINT    1
#define DIB_PROPSHEET_MAX      1
#define DIB_PROPSHEET_DEFAULT  DIB_PROPSHEET_DISPLAY

// General STRUCTS && TYPEDEFS

// Function prototypes
BOOL fOpenNewImage(HWND hWnd, LPTSTR lpszFileName, int wmCommand);
BOOL CALLBACK DlgSetICMOptionsForDevice(HWND  hwndDlg, UINT  uMsg, WPARAM  wParam, LPARAM  lParam);
int CreateDIBPropSheet(HWND hwndOwner, HINSTANCE hInst, int nStartPage, LPTSTR lpszCaption);
BOOL APIENTRY DlgDIBPropSheet(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam);
BOOL ColorMatchUI(HWND hwndOwner, LPVOID lpvDIBInfo);
void SaveDIBToFileDialog(HWND hWnd, LPDIBINFO lpDIBInfo);
BOOL GetProfileSaveName(HWND hWnd, LPSTR* ppszFileName, DWORD dwSize);
BOOL PrintDialog(HWND hWnd, HINSTANCE hInst, LPDIBINFO lpDIBInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\dibinfo.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DIBINFO.C
//
//  PURPOSE:
//
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include "icm.h"

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings

// C RunTime Header Files
#include <tchar.h>

// Local Header Files
#include "icmview.h"
#include "dibinfo.h"
#include "dibs.h"
#include "regutil.h"
#include "print.h"
#include "debug.h"

// local definitions
#ifndef ICM_DONE_OUTSIDEDC
    #define ICM_DONE_OUTSIDEDC  4
#endif

// default settings

// external functions

// external data

// public data

// private data

// public functions

// private functions

//
// Functions for DIBINFO structure
//

//////////////////////////////////////////////////////////////////////////
//  Function:  fReadDIBInfo
//
//  Description:
//    Will read a file in DIB format and return a global HANDLE
//    to it's BITMAPINFO.  This function will work with both
//    "old" (BITMAPCOREHEADER) and "new" (BITMAPINFOHEADER)
//    bitmap formats, but will always return a "new" BITMAPINFO
//
//  Parameters:
//    LPTSTR     Pointer to string containing the filename of the image.
//    LPDIBINFO Pointer to DIBINFO structure.
//
//  Returns:
//    BOOL
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

BOOL fSetupDIBInfo(HANDLE hDIB, LPDIBINFO lpDIBInfo)
{
    LPBITMAPINFOHEADER lpBmpInfoHdr = NULL;
    LPVOID             lpDibSection = NULL;

    // Get pointer to DIB.
    lpBmpInfoHdr = (LPBITMAPINFOHEADER) GlobalLock(hDIB);
    if (NULL == lpBmpInfoHdr)
    {
        GlobalFree(hDIB);
        return FALSE;
    }

    // Set values in DIBINFO structure
    if (sizeof(BITMAPCOREHEADER) == lpBmpInfoHdr->biSize)
    {
        LPBITMAPCOREHEADER  lpCoreHdr;

        lpCoreHdr = (LPBITMAPCOREHEADER) lpBmpInfoHdr;
        lpDIBInfo->uiDIBWidth   = (DWORD) lpCoreHdr->bcWidth;
        lpDIBInfo->uiDIBHeight  = (DWORD) lpCoreHdr->bcHeight;
        lpDIBInfo->dwDIBBits = lpCoreHdr->bcBitCount;

        // Determine the size of the image
        lpDIBInfo->dwSizeOfImage = (((lpCoreHdr->bcWidth * lpCoreHdr->bcBitCount + 31) & ~31) >> 3)
                                    * lpCoreHdr->bcHeight;
    }
    else
    {
        lpDIBInfo->dwDIBBits    = (DWORD)lpBmpInfoHdr->biBitCount;
        lpDIBInfo->uiDIBWidth  = abs(lpBmpInfoHdr->biWidth);
        lpDIBInfo->uiDIBHeight = abs(lpBmpInfoHdr->biHeight);

        if (0 == lpBmpInfoHdr->biSizeImage)
        {
            // Calculate size using DWORD alignment
            lpDIBInfo->dwSizeOfImage = (((lpBmpInfoHdr->biWidth * lpBmpInfoHdr->biBitCount + 31) & ~31)
                                       >> 3) * abs(lpBmpInfoHdr->biHeight);
        }
        else
        {
            lpDIBInfo->dwSizeOfImage = lpBmpInfoHdr->biSizeImage;
        }
    }

    // Set bmFormat.  Since the app only supports RGB's, pixel depth is enough
    lpDIBInfo->bmFormat = (DWORD)-1;
    switch (lpDIBInfo->dwDIBBits)
    {
        case 1:
            //lpDIBInfo->bmFormat = BM_1GRAY;
            lpDIBInfo->bmFormat = 0;
            break;
        case 16:
            // Should either be 555 or 565 bitmap.
            // Check mask if BI_BITFILEDS.
            if ( (BI_BITFIELDS == lpBmpInfoHdr->biCompression)
                 &&
                 (0x7E0 == *((LPDWORD)(lpBmpInfoHdr + 1) +1))
               )
            {
                lpDIBInfo->bmFormat = BM_565RGB;
            }
            else
            {
                lpDIBInfo->bmFormat = BM_x555RGB;
            }
            break;
        case 24:
            lpDIBInfo->bmFormat = BM_RGBTRIPLETS;  // RGB Triplets -- most significant byte is R
            break;
        case 32:
            lpDIBInfo->bmFormat = BM_xRGBQUADS;
            break;
        case 4:
        case 8:
            lpDIBInfo->bmFormat = 0;
            break;
        default:
            DebugMsg(__TEXT("fSetupDIBInfo : Unknown dwDIBBits value.\r\n"));
            break;
    }

    lpDIBInfo->hDIB = hDIB;
    lpDIBInfo->dwStretchBltMode = ICMV_STRETCH_DEFAULT;
    lpDIBInfo->bStretch = FALSE;
    lpDIBInfo->bDIBSection = FALSE;
    lpDIBInfo->hPal = CreateDIBPalette(hDIB);
    lpDIBInfo->hDIBSection = CreateDIBSection((HDC)0,
                                              (LPBITMAPINFO)lpBmpInfoHdr,
                                              DIB_RGB_COLORS,
                                              &lpDibSection,
                                              NULL, 0);

    if (lpDIBInfo->hDIBSection && lpDibSection)
    {
        CopyMemory(lpDibSection,FindDIBBits(lpBmpInfoHdr),lpDIBInfo->dwSizeOfImage);
    }

    // Unlock bmp info.
    GlobalUnlock(hDIB);
    return TRUE;
}   // End of function fSetupDIBInfo

BOOL fReadDIBInfo(LPTSTR lpszFileName, LPDIBINFO lpDIBInfo)
{
    // Local variables
    HANDLE                hDIBFile;
    HANDLE                hDIB;

    //  Initialize variables
    if ( (NULL == lpszFileName) || (NULL == lpDIBInfo) )
    {
        DebugMsg(__TEXT("fReadDIBInfo:  NULL parameter.\r\n"));
        return FALSE;
    }

    // Set the filename
    lpDIBInfo->lpszImageFileName = GlobalAlloc(GPTR,(lstrlen(lpszFileName)+1) * sizeof(TCHAR));
    if (lpDIBInfo->lpszImageFileName)
    {
        _tcscpy(lpDIBInfo->lpszImageFileName, lpszFileName);
    }

    // Open image file
    hDIBFile = CreateFile(lpszFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          (HANDLE)NULL);

    if (INVALID_HANDLE_VALUE == hDIBFile)
    {
        return FALSE;
    }

    // Read DIB from file.
    hDIB = ReadDIBFromFile(hDIBFile);

    CloseHandle(hDIBFile);

    // Make sure that DIB file read was successful.
    if (NULL == hDIB)
    {
        DebugMsg(__TEXT("fReadDIBInfo:  Failed to read DIB file.\r\n"));
        return FALSE;
    }

    // Setup DIBInfo structure.
    if (!fSetupDIBInfo(hDIB, lpDIBInfo))
    {
        GlobalUnlock(hDIB);
        GlobalFree(hDIB);
        return FALSE;
    }

    return TRUE;
}   // End of function fReadDIBInfo

BOOL fPasteDIBInfo(HWND hWnd, int wmPasteMode, LPDIBINFO lpDIBInfo)
{
    // Local variables
    HANDLE                hDIB;

    // Set the filename as NULL.
    lpDIBInfo->lpszImageFileName = NULL;

    // Read DIB from clipboard.
    hDIB = PasteDIBFromClipboard(hWnd, wmPasteMode);

    // Make sure that DIB file read was successful.
    if (NULL == hDIB)
    {
        DebugMsg(__TEXT("fPasteDIBInfo:  Failed to paste DIB file.\r\n"));
        return FALSE;
    }

    // Setup DIBInfo structure.
    if (!fSetupDIBInfo(hDIB, lpDIBInfo))
    {
        GlobalUnlock(hDIB);
        GlobalFree(hDIB);
        return FALSE;
    }

    return TRUE;
}   // End of function fReadDIBInfo

///////////////////////////////////////////////////////////////////////
//
// Function:  GetDIBInfoHandle
//
// Purpose:   Encapsulates the getting and setting of the
//            WW_DIB_HINFO value for a window since we are
//            storing a handle, and handles change from 16
//            bits in WIN16 to 32 bits in WIN32.
//
// Parms:     hWnd     == Window to retrieve the DIBINFO handle from.
//
// Returns:   The previous value.
//
///////////////////////////////////////////////////////////////////////

HGLOBAL GetDIBInfoHandle (HWND hWnd)
{
    return (HGLOBAL)GetWindowLong(hWnd, GWL_DIBINFO);
}


//////////////////////////////////////////////////////////////////////////
//  Function:  GetDIBInfoPtr
//
//  Description:
//    Gets a pointer to the DIBINFO structure of the window.
//
//  Parameters:
//    HWND    Handle to a window
//
//  Returns:
//    LPDIBINFO  Pointer to DIBINFO structure.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPDIBINFO GetDIBInfoPtr(HWND hWnd)
{
    // Local variables
    HGLOBAL     hDIBInfo;       // Handle to DIBINFO structure
    LPDIBINFO   lpDIBInfo;      // Pointer to DIBINFO structure

    //  Initialize variables
    lpDIBInfo = NULL;

    hDIBInfo = GetDIBInfoHandle(hWnd);
    if (hDIBInfo != NULL)
    {
        lpDIBInfo = GlobalLock(hDIBInfo);
        //lpDIBInfo = GlobalLock(hDIBInfo);
    }

    return(lpDIBInfo);
}   // End of function GetDIBInfoPtr


//////////////////////////////////////////////////////////////////////////
//  Function:  CreateDIBInfo
//
//  Description:
//    Initializes the window/thread by setting the ICMINFO values to the
//    current global values.  Then, the extra window information is set to
//    point to the ICMINFO structure so that any operation using this
//    window can obtain necesary information to manipulate the image.
//
//  Parameters:
//    none.
//
//  Returns:
//    HANDLE to DIBINFO structure.
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

HGLOBAL CreateDIBInfo(void)
{
    // Local variables
    HGLOBAL   hDIBInfo;           // Handle to ICMINFO structure
    LPDIBINFO lpDIBInfo;          // Pointer to ICMINFO structure

    // Allocate DIBINFO structure and get a pointer to it
    hDIBInfo = GlobalAlloc(GHND, sizeof(DIBINFO));
    if ((HGLOBAL)NULL != hDIBInfo)
    {
        if (NULL != (lpDIBInfo = GlobalLock(hDIBInfo)))
        {
            InitDIBInfo(lpDIBInfo);
        }
        else
        {
            DebugMsg(__TEXT("DIBS.C : CreateDIBInfo : Failed to lock DIBINFO\r\n"));
        }
    }
    else
    {
        DebugMsg(__TEXT("DIBS.C : CreateDIBInfo : Global alloc failed\r\n"));
        return(NULL);
    }
    GlobalUnlock(hDIBInfo);
    if (NULL == lpDIBInfo)
    {
        GlobalFree(hDIBInfo);
        hDIBInfo = NULL;
    }
    return(hDIBInfo);
}


///////////////////////////////////////////////////////////////////////////////
//  Function:  fDuplicateDIBInfo
//
//  Description:
//    Copies the source DIBINFO into the target DIBINFO.
//
//  Parameters:
//    LPDIBINFO Target DIBINFO to recieve the contents of the source DIBINFO.
//    LPDIBINFO Source DIBINFO to be copied into the target DIBINFO.
//
//  Returns:
//    void
//
//  Comments:
//
///////////////////////////////////////////////////////////////////////////////
LPDIBINFO fDuplicateDIBInfo(LPDIBINFO lpDIDest, LPDIBINFO lpDISrc)
{
    // Local variables

    // Initialize variables
    if (lpDISrc == NULL)
    {
        return(NULL);
    }
    if (lpDIDest == NULL)
    {
        lpDIDest = (LPDIBINFO)GlobalLock(CreateDIBInfo());
    }
    if (lpDIDest == (LPDIBINFO)NULL)
    {
        return(NULL);
    }

    // Now, copy the body of the DIBINFO structure
    lpDIDest->lpszImageFileName = CopyString(lpDISrc->lpszImageFileName);
    CopyRect((LPRECT)&lpDIDest->rcClip, (LPRECT)&lpDISrc->rcClip);

    lpDIDest->hWndOwner         = lpDISrc->hWndOwner;
    lpDIDest->hDIB              = lpDISrc->hDIB;
    lpDIDest->hDIBTransformed   = lpDISrc->hDIBTransformed;
    lpDIDest->hDIBSection       = lpDISrc->hDIBSection;
    lpDIDest->hPal              = lpDISrc->hPal;
    lpDIDest->dwDIBBits         = lpDISrc->dwDIBBits;
    lpDIDest->uiDIBWidth        = lpDISrc->uiDIBWidth;
    lpDIDest->uiDIBHeight       = lpDISrc->uiDIBHeight;
    lpDIDest->bmFormat          = lpDISrc->bmFormat;

    lpDIDest->bStretch          = lpDISrc->bStretch;
    lpDIDest->bDIBSection       = lpDISrc->bDIBSection;
    lpDIDest->dwStretchBltMode  = lpDISrc->dwStretchBltMode;
    lpDIDest->dwPrintOption     = lpDISrc->dwPrintOption;
    lpDIDest->dwXScale          = lpDISrc->dwXScale;
    lpDIDest->dwYScale          = lpDISrc->dwYScale;

    // Copy DEVMODE.
    if (NULL != lpDISrc->pDevMode)
    {
        HANDLE  hDevMode = GlobalHandle(lpDISrc->pDevMode);
        DWORD   dwSize = GlobalSize(hDevMode);


        lpDIDest->pDevMode = (PDEVMODE) GlobalLock(GlobalAlloc(GHND, dwSize));
        if (NULL != lpDIDest->pDevMode)
        {
            memcpy(lpDIDest->pDevMode, lpDISrc->pDevMode, dwSize);
        }
    }

    // Copy the ICM information now
    fDuplicateICMInfo(lpDIDest, lpDISrc);

    // Made it this far--return pointer to DIBINFO
    return(lpDIDest);
} // End of function fDuplicateDIBInfo

//////////////////////////////////////////////////////////////////////////
//  Function:  fDuplicateICMInfo
//
//  Description:
//    Safely copies source ICM information in a DIBINFO structure to
//    the target DIBINFO.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL fDuplicateICMInfo(LPDIBINFO lpDIDest, LPDIBINFO lpDISrc)
{
    // Local variables

    //  Initialize variables
    if (NULL == lpDIDest)
    {
        DebugMsg(__TEXT("DIBS.C : fDuplicateICMInfo : NULL Target\r\n"));
        return(FALSE);
    }
    if (NULL == lpDISrc)
    {
        DebugMsg(__TEXT("DIBS.C : fDuplicateICMInfo : NULL Source\r\n"));
        return(FALSE);
    }

    lpDIDest->dwICMFlags = lpDISrc->dwICMFlags;
    lpDIDest->hLCS = lpDISrc->hLCS;

    // Copy strings.
    UpdateString(&(lpDIDest->lpszMonitorName)   ,lpDISrc->lpszMonitorName);
    UpdateString(&(lpDIDest->lpszMonitorProfile),lpDISrc->lpszMonitorProfile);
    UpdateString(&(lpDIDest->lpszPrinterName   ),lpDISrc->lpszPrinterName);
    UpdateString(&(lpDIDest->lpszPrinterProfile),lpDISrc->lpszPrinterProfile);
    UpdateString(&(lpDIDest->lpszTargetProfile) ,lpDISrc->lpszTargetProfile);

    // Copy intents
    lpDIDest->dwRenderIntent = lpDIDest->dwRenderIntent;
    lpDIDest->dwProofingIntent = lpDIDest->dwProofingIntent;

    return(TRUE);
}   // End of function fDuplicateICMInfo


//////////////////////////////////////////////////////////////////////////
//  Function:  FreeDIBInfo
//
//  Description:
//    Frees the DIBINFO structure and its members.
//
//  Parameters:
//    HGLOBAL   Handle to DIBINFO structure@@@
//
//  Returns:
//    void
//
//  Comments:
//    This function will also deallocate the association ICMINFO
//    structure which is contained within the DIBINFO structure.
//
//////////////////////////////////////////////////////////////////////////
BOOL fFreeDIBInfo(HGLOBAL hDIBInfo, BOOL bFreeDIBHandles)
{
    // Local variables
    LPDIBINFO lpDIBInfo;
    HGLOBAL   hFreed;
    DWORD     dwLastError;

    // Initialize variables
    if (hDIBInfo == NULL)
    {
        return(TRUE);
    }

    // Obtain DIBINFO pointer
    lpDIBInfo = GlobalLock(hDIBInfo);
    if (lpDIBInfo == NULL)
    {
        return(FALSE);
    }
    // Have the pointer, let's free its members
    if (lpDIBInfo->lpszImageFileName)
        hFreed = GlobalFree(lpDIBInfo->lpszImageFileName);
    if (lpDIBInfo->lpszMonitorName)
        hFreed = GlobalFree(lpDIBInfo->lpszMonitorName);
    if (lpDIBInfo->lpszMonitorProfile)
        hFreed = GlobalFree(lpDIBInfo->lpszMonitorProfile);
    if (lpDIBInfo->lpszPrinterName)
        hFreed = GlobalFree(lpDIBInfo->lpszPrinterName);
    if (lpDIBInfo->lpszPrinterProfile)
        hFreed = GlobalFree(lpDIBInfo->lpszPrinterProfile);
    if (lpDIBInfo->lpszTargetProfile)
        hFreed = GlobalFree(lpDIBInfo->lpszTargetProfile);

    // Preserve last error if necessary
    SetLastError(0);

    if (bFreeDIBHandles)
    {
        if (NULL != lpDIBInfo->hDIB)
            GlobalFree(lpDIBInfo->hDIB);
        if (NULL != lpDIBInfo->hDIBTransformed)
            GlobalFree(lpDIBInfo->hDIBTransformed);
        if (NULL != lpDIBInfo->hDIBSection)
            DeleteObject(lpDIBInfo->hDIBSection);
    }
    GlobalUnlock(hDIBInfo);
    if (NULL != (GlobalFree(hDIBInfo))) // unsuccessful free
    {
        dwLastError = GetLastError();
        DebugMsg(__TEXT("DIBS.C : fFreeDIBInfo : GlobalFree failed, LastError = %ld\r\n"), dwLastError);
        return(FALSE);
    }
    return(TRUE);
} // End of function fFreeDIBInfo

//////////////////////////////////////////////////////////////////////////
//  Function:  InitDIBInfo
//
//  Description:
//    Given a pointer to a DIBINFO structure, this function will place
//    default values in all of its members.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL  Success / Failure.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL InitDIBInfo(LPDIBINFO lpDIBInfo)
{
    // Local variables

    //  Initialize variables
    if (NULL == lpDIBInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugMsg(__TEXT("DIBS.C : InitDIBInfo : lpDIBInfo == NULL\r\n"));
        return(FALSE);
    }
#ifdef _DEBUG
    memset(lpDIBInfo, UNINIT_BYTE, sizeof(DIBINFO));
#endif

    lpDIBInfo->hWndOwner = NULL;
    lpDIBInfo->lpszImageFileName = NULL;
    lpDIBInfo->hDIB = NULL;
    lpDIBInfo->hDIBTransformed = NULL;
    lpDIBInfo->hDIBSection = NULL;
    lpDIBInfo->hPal = NULL;

    // Image attributes
    lpDIBInfo->dwDIBBits = 0;
    lpDIBInfo->uiDIBWidth   =   0;
    lpDIBInfo->uiDIBHeight = 0;
    lpDIBInfo->bmFormat = (DWORD)-1;

    // Display options
    SetRect((LPRECT)&(lpDIBInfo->rcClip), 0, 0, 0, 0);
    lpDIBInfo->dwStretchBltMode = ICMV_STRETCH_DEFAULT;
    lpDIBInfo->bStretch = FALSE;
    lpDIBInfo->bDIBSection = FALSE;

    // Printing Options
    lpDIBInfo->dwPrintOption = ICMV_PRINT_DEFAULTSIZE;
    lpDIBInfo->dwXScale = 0;
    lpDIBInfo->dwYScale = 0;
    lpDIBInfo->pDevMode = NULL;

    // ICM Attributes
    lpDIBInfo->dwICMFlags = ICMVFLAGS_DEFAULT_ICMFLAGS;
    lpDIBInfo->hLCS = NULL;
    lpDIBInfo->lpszMonitorName = NULL;
    lpDIBInfo->lpszMonitorProfile = NULL;
    lpDIBInfo->lpszPrinterName = NULL;
    lpDIBInfo->lpszPrinterProfile = NULL;
    lpDIBInfo->lpszTargetProfile = NULL;
    lpDIBInfo->dwRenderIntent = ICMV_RENDER_INTENT_DEFAULT;
    lpDIBInfo->dwProofingIntent = ICMV_PROOFING_INTENT_DEFAULT;

    return(TRUE);
}   // End of function InitDIBInfo


//////////////////////////////////////////////////////////////////////////
//  Function:  GetDefaultICMInfo
//
//  Description:
//    Initializes the global DIBINFO structure with default profiles.
//
//  Parameters:
//    @@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL GetDefaultICMInfo(void)
{
    // Local variables
    LPDIBINFO   lpDIBInfo;
    HDC                 hDC;
    BOOL                bRC;
    LPSTR           lpszDefaultProfile;

    //  Initialize variables
    bRC = TRUE;
    lpszDefaultProfile = NULL;
    lpDIBInfo = GetDIBInfoPtr(ghAppWnd); // Lock info for writing

    // Get display DC
    hDC = GetDC(ghAppWnd);
    lpDIBInfo->lpszMonitorName = GetRegistryString(HKEY_LOCAL_MACHINE,
                                                   __TEXT("System\\CurrentControlSet\\Services\\Class\\Monitor\\0000"),
                                                   __TEXT("DriverDesc"));
    lpDIBInfo->lpszMonitorProfile = GetDefaultICMProfile(hDC);

    if (NULL == lpDIBInfo->lpszMonitorProfile)
    {
        DWORD   dwSize;

        GetStandardColorSpaceProfile(NULL, LCS_WINDOWS_COLOR_SPACE, NULL, &dwSize);
        if (0 != dwSize)
        {
            lpszDefaultProfile = GlobalAlloc(GPTR, dwSize);
            if (GetStandardColorSpaceProfile(NULL, LCS_WINDOWS_COLOR_SPACE, lpszDefaultProfile, &dwSize))
            {
                GetBaseFilename(lpszDefaultProfile, &(lpDIBInfo->lpszMonitorProfile));
            }
            else
            {
                DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
                bRC = FALSE;
                lpDIBInfo->lpszMonitorProfile = NULL;
            }
        }
        else
        {
            lpDIBInfo->lpszMonitorProfile = GlobalAlloc(GPTR, (lstrlen(DEFAULT_ICM_PROFILE) +1 ) * sizeof(TCHAR));
            _tcscpy(lpDIBInfo->lpszMonitorProfile, DEFAULT_ICM_PROFILE);
        }

        DebugMsg(__TEXT("Display DC didn't get profile.  Using <%s>\r\n"), lpDIBInfo->lpszMonitorProfile);
    }
    DebugMsg(__TEXT("GetDefaultICMInfo:  Monitor profile <%s>\r\n"), lpDIBInfo->lpszMonitorProfile);
    ReleaseDC(ghAppWnd, hDC);


    if (bRC)
    {
        // Get printer name and DC
        lpDIBInfo->lpszPrinterName = GetDefaultPrinterName();
        if (lpDIBInfo->lpszPrinterName != NULL)
        {
            hDC = GetPrinterDC(lpDIBInfo->lpszPrinterName, lpDIBInfo->pDevMode);
            if (hDC != NULL)
            {
                lpDIBInfo->lpszPrinterProfile = GetDefaultICMProfile(hDC);
                lpDIBInfo->lpszTargetProfile= lpDIBInfo->lpszPrinterProfile;
                DebugMsg(__TEXT("GetDefaultICMInfo:  Printer profile <%s>\r\n"), lpDIBInfo->lpszPrinterProfile ?
                         lpDIBInfo->lpszPrinterProfile : __TEXT("NULL"));
                DeleteDC(hDC);
                bRC = TRUE;
            }
        }
        GlobalUnlock(GlobalHandle(lpDIBInfo));
    }

    if (NULL != lpszDefaultProfile)
    {
        GlobalFree(lpszDefaultProfile);
    }
    return(bRC);
}   // End of function GetDefaultICMInfo

//////////////////////////////////////////////////////////////////////////
//  Function:  DumpDIBINFO
//
//  Description:
//    Dumps DIBInfo structure
//
//  Parameters:
//    @@@
//
//  Returns:
//    void
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
void DumpDIBINFO(LPTSTR lpszMsg, LPDIBINFO lpDIBInfo)
{
    // Local variables

    //  Initialize variables
    DebugMsg(__TEXT("\r\n******************** DumpDIBINFO ********************\r\n"));
    DebugMsg(__TEXT("***** %s \r\n"), lpszMsg);
    if (lpDIBInfo == NULL)
    {
        DebugMsg(__TEXT("lpDIBInfo                    NULL\r\n\r\n"));
        return;
    }

    DebugMsg(__TEXT("lpDIBInfo                   0x%08lx\r\n"), lpDIBInfo);
    if (lpDIBInfo->lpszImageFileName != NULL)
    {
        DebugMsg(__TEXT("lpszImageFileName           %s\r\n"), lpDIBInfo-> lpszImageFileName);
    }
    else
    {
        DebugMsg(__TEXT("lpszImageFileName           <NULL PTR>\r\n"));
    }

    DebugMsg(__TEXT("hDIB                        0x%08lx\r\n"), lpDIBInfo-> hDIB);
    DebugMsg(__TEXT("hDIBTransformed             0x%08lx\r\n"), lpDIBInfo-> hDIBTransformed);
    DebugMsg(__TEXT("hDIBSection                 0x%08lx\r\n"), lpDIBInfo-> hDIBSection);
    DebugMsg(__TEXT("hPal                        0x%08lx\r\n"), lpDIBInfo-> hPal);
    DebugMsg(__TEXT("dwDIBBits                   %lu\r\n"), lpDIBInfo-> dwDIBBits);
    DebugMsg(__TEXT("uiDIBWidth                  %lu\r\n"), lpDIBInfo-> uiDIBWidth);
    DebugMsg(__TEXT("uiDIBHeight                 %lu\r\n"), lpDIBInfo-> uiDIBHeight);
    DebugMsg(__TEXT("bmFormat                    %ld\r\n"), (DWORD)(lpDIBInfo->bmFormat));
    DumpRectangle(__TEXT("rcClip                      "), (LPRECT)&(lpDIBInfo->rcClip));
    DebugMsg(__TEXT("dwStretchBltMode            %lu\r\n"), lpDIBInfo-> dwStretchBltMode);
    DebugMsg(__TEXT("bStretch                    %lu\r\n"), lpDIBInfo-> bStretch);
    DebugMsg(__TEXT("bDIBSection                 %lu\r\n"), lpDIBInfo-> bDIBSection);
    DebugMsg(__TEXT("dwPrintOption               %lu\r\n"), lpDIBInfo-> dwPrintOption);
    DebugMsg(__TEXT("dwXScale                    %lu\r\n"), lpDIBInfo-> dwXScale);
    DebugMsg(__TEXT("dwYScale                    %lu\r\n\r\n"), lpDIBInfo-> dwYScale);
    DebugMsg(__TEXT("lpszMonitorName             0x%08lX <%s>\r\n"), lpDIBInfo->lpszMonitorName   , lpDIBInfo->lpszMonitorName    ? lpDIBInfo->lpszMonitorName    : __TEXT("NULL"));
    DebugMsg(__TEXT("lpszMonitorProfile          0x%08lX <%s>\r\n"), lpDIBInfo->lpszMonitorProfile, lpDIBInfo->lpszMonitorProfile ? lpDIBInfo->lpszMonitorProfile : __TEXT("NULL"));
    DebugMsg(__TEXT("lpszPrinterName             0x%08lX <%s>\r\n"), lpDIBInfo->lpszPrinterName   , lpDIBInfo->lpszPrinterName    ? lpDIBInfo->lpszPrinterName    : __TEXT("NULL"));
    DebugMsg(__TEXT("lpszPrinterProfile          0x%08lX <%s>\r\n"), lpDIBInfo->lpszPrinterProfile, lpDIBInfo->lpszPrinterProfile ? lpDIBInfo->lpszPrinterProfile : __TEXT("NULL"));
    DebugMsg(__TEXT("lpszTargetProfile           0x%08lX <%s>\r\n\r\n"), lpDIBInfo->lpszTargetProfile, lpDIBInfo->lpszTargetProfile ? lpDIBInfo->lpszTargetProfile : __TEXT("NULL"));
    DebugMsg(__TEXT("dwICMFlags                  %ld\r\n"), lpDIBInfo->dwICMFlags);
    DebugMsg(__TEXT("dwRenderIntent              %ld\r\n"), lpDIBInfo->dwRenderIntent);
    DebugMsg(__TEXT("dwProofingIntent            %ld\r\n"), lpDIBInfo->dwProofingIntent);
    DebugMsg(__TEXT("^^^^^^^^^^DumpDIBINFO   0x%08lx^^^^^^^^^^^^^^\r\n\r\n\r\n"), lpDIBInfo);
}   // End of function DumpDIBINFO


//////////////////////////////////////////////////////////////////////////
//  Function:  SetupDC
//
//  Description:
//    Sets up DC for drawing based on DIBINFO.  This consolidates code for both
//    printing and drawing to the screen.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL SetupDC(HDC hDC, LPDIBINFO lpDIBInfo, HPALETTE *phOldPalette, HDC *phDCPrinter)
{
    int     iICMMode;
    BOOL    bRC;
    TCHAR   stFullProfile[MAX_PATH];


    // Initialize variables.
    *phOldPalette = NULL;
    *phDCPrinter = NULL;

    // Select/Realize our palette.  Make it a background palette, so that
    // it doesn't mess up foreground palette when background windows repaint.
    if (NULL != lpDIBInfo->hPal)
    {
        *phOldPalette = SelectPalette (hDC, lpDIBInfo->hPal, TRUE);
        if (NULL == *phOldPalette)
        {
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
        }
    }

    //Only do ICM pre-processing if "Inside DC" is selected.
    if (!CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20))
    {
        if (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ENABLE_ICM))
        {
            // build the FULL pathname to the profile.
            wsprintf(stFullProfile,__TEXT("%s\\%s"), gstProfilesDir, lpDIBInfo->lpszMonitorProfile);

            if (SetICMProfile(hDC, stFullProfile))
            {
                iICMMode = SetICMMode(hDC, ICM_ON);
                if (0 == iICMMode)
                {
                    DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
                    SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), ICMVFLAGS_ENABLE_ICM, FALSE);
                }
                else
                {
                    if ((CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_PROOFING)) && (NULL != lpDIBInfo->lpszTargetProfile))
                    {
                        *phDCPrinter = GetPrinterDC(lpDIBInfo->lpszPrinterName, lpDIBInfo->pDevMode);
                        if (NULL != *phDCPrinter)
                        {
                            wsprintf(stFullProfile,__TEXT("%s\\%s"), gstProfilesDir, lpDIBInfo->lpszTargetProfile);
                            bRC = SetICMProfile(*phDCPrinter, stFullProfile);
                            if (bRC)
                            {
                                iICMMode = SetICMMode(*phDCPrinter, ICM_ON);
                                if (0 != iICMMode)
                                {
                                    bRC = ColorMatchToTarget(hDC, *phDCPrinter, CS_ENABLE);
                                    if (!bRC)
                                    {
                                        DebugMsg(__TEXT("DIBPaint:  ColorMatchToTarget w/profile %s FAILED\r\n"), stFullProfile);
                                        DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
                                    }
                                }
                                else
                                {
                                    DebugMsg(__TEXT("DIBPaint:  SetICMMode (%s, %s) FAILED!\r\n"), lpDIBInfo->lpszPrinterName, stFullProfile);
                                    DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
                                }
                            }
                            else
                            {
                                DebugMsg(__TEXT("DIBPaint:  SetICMProfile w/profile %s FAILED\r\n"), stFullProfile);
                                DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
                            }
                        }
                        else
                        {
                            DebugMsg(__TEXT("DIBPaint:  GetPrinterDC() w/printer %s FAILED\r\n"), lpDIBInfo->lpszPrinterName);
                            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
                        }
                    }

                    if (NULL != lpDIBInfo->hPal)
                    {
                        WORD    wEntries;


                        GetObject(lpDIBInfo->hPal, sizeof(wEntries), &wEntries);
                        //if(!ColorCorrectPalette(hDC, lpDIBInfo->hPal, 0, (DWORD)wEntries))
                        //{
                        //    DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
                        //}
                    }
                }
            }
            else
            {
                DebugMsg(__TEXT("DIBPaint : SetICMProfile(%s)FAILED\r\n"), stFullProfile);
                DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
            }
        }
        else
        {
            iICMMode = SetICMMode(hDC, ICM_OFF);
        }
    }
    else
    {
        iICMMode = SetICMMode(hDC, ICM_DONE_OUTSIDEDC);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\dibinfo.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DIBINFO.H
//
//  PURPOSE:
//
//
//  PLATFORMS:
//    Windows 95, Windows NT,
//
//  SPECIAL INSTRUCTIONS: N/A
//

// General pre-processor macros

// Default stretch mode
#define ICMV_STRETCH_DEFAULT                STRETCH_DELETESCANS

// LCS Intent default
#define ICMV_LCSINTENT_DEFAULT              LCS_GM_IMAGES

// ICM rendering intents
#define ICMV_RENDER_INTENT_DEFAULT      INTENT_PERCEPTUAL
#define ICMV_PROOFING_INTENT_DEFAULT    INTENT_ABSOLUTE_COLORIMETRIC

// Flags for use in the dwPrintOption member of DIBINFO
#define ICMV_PRINT_ACTUALSIZE               0x00000001
#define ICMV_PRINT_BESTFIT                  0x00000002
#define ICMV_PRINT_DEFAULTSIZE              ICMV_PRINT_ACTUALSIZE

// Flags for use in the dwICMFlags field of the ICMINFO structure
#define ICMVFLAGS_ENABLE_ICM                0x00000001
#define ICMVFLAGS_PROOFING                  0x00000002
#define ICMVFLAGS_ICM20                     0x00000004
#define ICMVFLAGS_CREATE_TRANSFORM          0x00000008
#define ICMVFLAGS_DEFAULT_ICMFLAGS          (ICMVFLAGS_ICM20 | ICMVFLAGS_ENABLE_ICM)

// General STRUCTS && TYPEDEFS
typedef struct
{
    // Handle to window which owns this structure
    HWND          hWndOwner;

    // Handles to access information
    LPTSTR        lpszImageFileName;    // Name of image to open/display
    HGLOBAL       hDIB;                 // Handle to the DIB spec
    HGLOBAL       hDIBTransformed;      // Handle to the DDB or DIBSection
    HBITMAP       hDIBSection;          // Handle to the DIB section
    HPALETTE      hPal;

    // Image attributes
    DWORD         dwDIBBits;            // Bits per pixel
    UINT          uiDIBWidth;           // Print width of the DIB
    UINT          uiDIBHeight;          // Print height of the DIB
    DWORD         dwSizeOfImage;        // Size of image
    BMFORMAT      bmFormat;             // Bitmap format used by TranslateBitmapBits

    // Display options
    RECT          rcClip;               // Clipboard cut rectangle.
    DWORD         dwStretchBltMode;     // Mode to use for StretchBlt calls
                                        // when painting.
    BOOL          bStretch;             // True = stretch to window
    BOOL          bDIBSection;          // True = bitblt from DIBSection

    // Printing options
    DWORD         dwPrintOption;        // See defines below
    DWORD         dwXScale;             // X Scale Edit control value
    DWORD         dwYScale;             // Y Scale Edit control value
    PDEVMODE      pDevMode;

    // ICM Control structure
    HCOLORSPACE   hLCS;
    LPTSTR        lpszMonitorName;
    LPTSTR        lpszMonitorProfile;
    LPTSTR        lpszPrinterName;
    LPTSTR        lpszPrinterProfile;
    LPTSTR        lpszTargetProfile;
    DWORD         dwICMFlags;
    DWORD         dwRenderIntent;
    DWORD         dwProofingIntent;

} DIBINFO, FAR *LPDIBINFO;

// Function prototypes
HGLOBAL   CreateDIBInfo(void);
BOOL      GetDefaultICMInfo(void);
LPDIBINFO GetDIBInfoPtr(HWND hWnd);
HGLOBAL   GetDIBInfoHandle (HWND hWnd);


BOOL      fFreeDIBInfo(HGLOBAL hDIBInfo, BOOL bFreeDIBHandles);LPTSTR    GetDefaultICMProfile(HDC hDC);
LPDIBINFO fDuplicateDIBInfo(LPDIBINFO lpDISource, LPDIBINFO lpDITarget);
BOOL      fDuplicateICMInfo(LPDIBINFO lpDIDest, LPDIBINFO lpDISrc);
BOOL      InitDIBInfo(LPDIBINFO lpDIBINFO);
void      CopyDIBInfo(LPDIBINFO lpDITarget, LPDIBINFO lpDISource);
BOOL      fReadDIBInfo(LPTSTR lpszFileName, LPDIBINFO lpDIBInfo);
BOOL      fPasteDIBInfo(HWND hWnd, int wmPasteMode, LPDIBINFO lpDIBInfo);
HANDLE    GetDIBHandleFromDIBInfo(HANDLE hDIBInfo);
void      DumpDIBINFO(LPTSTR lpszMsg, LPDIBINFO lpDIBInfo);

BOOL SetupDC(HDC hDC, LPDIBINFO lpDIBInfo, HPALETTE *phOldPalette, HDC *phDCPrinter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\dibs.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DIBS.C
//
//  PURPOSE:
//    DIB routines for the ICMVIEW application.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
//#include <CommCtrl.h>
#include <icm.h>

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings
#pragma warning(default:4514)   // Unreferenced inline function has been removed

// C RunTime Header Files
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <TCHAR.H>

// Local Header Files
#include "icmview.h"  // specific to this program
#include "child.h"
#include "dibinfo.h"
#include "dibs.h"      // specific to this file
#include "dialogs.h"
#include "debug.h"
#include "print.h"
#include "regutil.h"
#include "resource.h"

// local definitions
DWORD NumColorsInDIB(LPBITMAPINFOHEADER lpbi);
LONG      DIBHeight (LPBYTE lpDIB);
LONG      DIBWidth (LPBYTE lpDIB);
LPLOGCOLORSPACE GetColorSpaceFromBitmap(LPBITMAPINFOHEADER lpBitmapInfo, DWORD dwIntent, LPBOOL pbDeleteProfile);
HPROFILE  OpenColorProfileFromFile(LPTSTR lpszProfileName);
BOOL TranslateColorTable(HTRANSFORM hColorTransform, PCOLOR paInputColors, DWORD nColors, COLORTYPE ctInput, PCOLOR paOutputColors, COLORTYPE ctOutput, int biBitCount);

// default settings

// external functions

// external data

// public data

// private data

// public functions

// private functions


///////////////////////////////////////////////////////////////////////
//
// Function:   DIBPaint
//
// Purpose:    Painting routine for a DIB.  Calls StretchDIBits() or
//             SetDIBitsToDevice() to paint the DIB.  The DIB is
//             output to the specified DC, at the coordinates given
//             in lpDCRect.  The area of the DIB to be output is
//             given by lpDIBRect.  The specified palette is used.
//
// Parms:      hDC       == DC to do output to.
//             lpDCRect  == Rectangle on DC to do output to.
//             hDIB      == Handle to global memory with a DIB spec
//                          in it (either a BITMAPINFO or BITMAPCOREINFO
//                          followed by the DIB bits).
//             lpDIBRect == Rect of DIB to output into lpDCRect.
//             hPal      == Palette to be used.
//
///////////////////////////////////////////////////////////////////////

void DIBPaint (HDC hDC, LPRECT lpDCRect, HGLOBAL hDIB,LPRECT lpDIBRect,
               LPDIBINFO lpDIBInfo)
{
    HDC                 hDCPrinter;
    BOOL                bRC;
    LPBYTE              lpbDIBBits;
    HPALETTE            hOldPal;
    LPBITMAPINFOHEADER  lpDIBHdr;
    LPBITMAPINFOHEADER  lpbi;


    // Initialize variables
    if (!hDIB)
    {
        return;
    }
    ASSERT(hDC != NULL);
    hDCPrinter = NULL;
    SetLastError(0);
    hOldPal = NULL;
    lpbi = NULL;

    // Lock down DIB, get a pointer to the beginning of the bit buffer.
    lpDIBHdr  = GlobalLock(hDIB);
    if (NULL == lpDIBHdr )
    {
        goto Release;
    }
    lpbDIBBits = FindDIBBits(lpDIBHdr);
    if (NULL == lpbDIBBits)
    {
        goto Release;
    }

    // If size > BITMAPINFOHEADER header then
    // need to convert to BITMAPINFOHEADER.
    lpbi = lpDIBHdr;
#ifdef OSR2
    if (sizeof(BITMAPINFOHEADER) < lpDIBHdr->biSize)
    {
        DWORD dwColorTableSize;
        DWORD dwHeaderDataSize;

        // Allocate Bitmapinfo memory.
        dwHeaderDataSize = sizeof(BITMAPINFOHEADER) + (lpDIBHdr->biCompression == BI_BITFIELDS ? 12 : 0);
        dwColorTableSize = NumColorsInDIB(lpDIBHdr) * sizeof(RGBQUAD);
        lpbi = (LPBITMAPINFOHEADER) GlobalAlloc(GPTR, dwHeaderDataSize + dwColorTableSize);
        if (NULL == lpbi)
        {
            goto Release;
        }

        // Convert header data into bitmapinfo header.
        memcpy(lpbi, lpDIBHdr, dwHeaderDataSize);
        lpbi->biSize = sizeof(BITMAPINFOHEADER);

        // Copy color table if any.
        if (0 != dwColorTableSize)
            memcpy((LPBYTE)lpbi + dwHeaderDataSize, (LPBYTE)lpDIBHdr + lpDIBHdr->biSize, dwColorTableSize);
    }
#endif

    SetupDC(hDC, lpDIBInfo, &hOldPal, &hDCPrinter);

    // Determine whether to call StretchDIBits() or SetDIBitsToDevice().

    if (lpDIBInfo->bDIBSection)
    {
        BOOL bBltRet;

        // Only ICM 1.0 can do the BitBlt() from DIBSection with color correction

        if (lpDIBInfo->hDIBSection &&
            !CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20))
        {
            // Create compatible DC, and select DIBSection in it.

            HDC hdcCompatible = CreateCompatibleDC(hDC);
            BOOL bRet = SetICMProfile(hdcCompatible,"sRGB Color Space Profile.icm");
            HBITMAP hbmOld = SelectObject(hdcCompatible,lpDIBInfo->hDIBSection);

            if (!(lpDIBInfo->bStretch))
            {
                DebugMsg(__TEXT("DIBS.C : DIBPaint: BitBlt from DIBSECTION\r\n"));

                bBltRet = BitBlt(hDC,
                                 lpDCRect->left,               // dest upper-left x
                                 lpDCRect->top,                // dest upper-left y
                                 RECTWIDTH (lpDCRect),         // src width
                                 RECTHEIGHT (lpDCRect),        // src height
                                 hdcCompatible,
                                 lpDIBRect->left,              // src lower-left x
                                 lpDIBRect->top,               // src lower-left y
                                 SRCCOPY);
            }
            else
            {
                SetStretchBltMode (hDC, (int)lpDIBInfo->dwStretchBltMode);

                DebugMsg(__TEXT("DIBS.C : DIBPaint: StretchBlt from DIBSECTION\r\n"));

                bBltRet = StretchBlt(hDC,
                                     lpDCRect->left,               // dest upper-left x
                                     lpDCRect->top,                // dest upper-left y
                                     RECTWIDTH (lpDCRect),         // src width
                                     RECTHEIGHT (lpDCRect),        // src height
                                     hdcCompatible,
                                     lpDIBRect->left,              // src lower-left x
                                     lpDIBRect->top,               // src lower-left y
                                     RECTWIDTH (lpDIBRect),        // nStartScan
                                     RECTHEIGHT (lpDIBRect),       // nNumScans
                                     SRCCOPY);
            }

            if (bBltRet == FALSE)
            {
                DebugMsg(__TEXT("DIBS.C : DIBPaint:  BitBlt/StretchBlt failed. Error %ld\r\n"), GetLastError());
            }

            SelectObject(hdcCompatible,hbmOld);
            DeleteObject(hdcCompatible);
        }
        else
        {
            // Fill with White

            FillRect(hDC,lpDCRect,GetStockObject(WHITE_BRUSH));
        }
    }
    else
    {
        int iScanLines;

        if (!(lpDIBInfo->bStretch))
        {
            iScanLines = SetDIBitsToDevice (hDC,          // hDC
                                            lpDCRect->left,               // dest upper-left x
                                            lpDCRect->top,                // dest upper-left y
                                            RECTWIDTH (lpDCRect),         // src width
                                            RECTHEIGHT (lpDCRect),        // src height
                                            lpDIBRect->left,              // src lower-left x
                                            (int) DIBHeight((LPBYTE)lpDIBHdr) -
                                            lpDIBRect->top -
                                            RECTHEIGHT (lpDIBRect),       // src lower-left y
                                            0,                            // nStartScan
                                            (UINT) DIBHeight((LPBYTE)lpDIBHdr),   // nNumScans
                                            lpbDIBBits,                   // lpBits
                                            (LPBITMAPINFO) lpbi,      // lpBitsInfo
                                            DIB_RGB_COLORS);              // wUsage
        }
        else
        {
            // Use the specified stretch mode
            SetStretchBltMode (hDC, (int)lpDIBInfo->dwStretchBltMode);
            iScanLines = StretchDIBits (hDC,                          // hDC
                                        lpDCRect->left,               // dest upper-left x
                                        lpDCRect->top,                // dest upper-left y
                                        RECTWIDTH (lpDCRect),         // src width
                                        RECTHEIGHT (lpDCRect),        // src height
                                        lpDIBRect->left,              // src lower-left x
                                        lpDIBRect->top,               // src lower-left y
                                        RECTWIDTH (lpDIBRect),        // nStartScan
                                        RECTHEIGHT (lpDIBRect),       // nNumScans
                                        lpbDIBBits,                   // lpBits
                                        (LPBITMAPINFO)lpbi,                   // lpBitsInfo
                                        DIB_RGB_COLORS,               // wUsage
                                        SRCCOPY);                     // dwROP
        }

        if (DIBHeight((LPBYTE)lpDIBHdr) != iScanLines)
        {
            DebugMsg(__TEXT("DIBS.C : DIBPaint:  iScanLines expected %ld, returned %ld\r\n"), DIBHeight((LPBYTE)lpDIBHdr), iScanLines);
        }
    }

    // Fix up the palette.
    if ((NULL != hOldPal) && (NULL == SelectPalette (hDC, hOldPal, TRUE)))
    {
        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
    }

    Release:
    if (lpbi != lpDIBHdr)
        GlobalFree((HANDLE)lpbi);
    if (NULL != lpDIBHdr)
    {
        GlobalUnlock(hDIB);
    }
    if (hDCPrinter)
    {
        bRC = ColorMatchToTarget(hDC, hDCPrinter, CS_DISABLE);
        if (0 == bRC)
        {
            DebugMsg(__TEXT("DIBS.C : DIBPaint : ColorMatchToTarget failed to DISABLE transform.\r\n"));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
        }
        bRC = ColorMatchToTarget(hDC, hDCPrinter, CS_DELETE_TRANSFORM);
        if (0 == bRC)
        {
            DebugMsg(  __TEXT(  "DIBS.C : DIBPaint : ColorMatchToTarget failed to DELETE transform.\r\n"));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
        }
        bRC = DeleteDC(hDCPrinter);
        if (0 == bRC)
        {
            DebugMsg(__TEXT("DIBS.C : DIBPaint : Failed to delete printer DC\r\n"));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
        }
    }
}

///////////////////////////////////////////////////////////////////////
//
// Function:   CreateDIBPalette
//
// Purpose:    Given a handle to a DIB, constructs a logical palette,
//             and returns a handle to this palette.
//
//             Stolen almost verbatim from ShowDIB.
//
// Parms:      hDIB == HANDLE to global memory with a DIB header
//                     (either BITMAPINFOHEADER or BITMAPCOREHEADER)
//
///////////////////////////////////////////////////////////////////////
HPALETTE CreateDIBPalette(HANDLE hDIB)
{
    LPLOGPALETTE          lpPal;
    HGLOBAL               hLogPal;
    HPALETTE              hPal = NULL;
    UINT                  i;
    DWORD                 dwNumColors;
    LPBITMAPINFOHEADER    lpBmpInfoHdr;
    LPBITMAPINFO          lpbmi;
    LPBITMAPCOREINFO      lpbmc;
    BOOL                  bWinStyleDIB;

    if (!hDIB)
    {
        return NULL;
    }

    lpBmpInfoHdr = GlobalLock (hDIB);
    lpbmi        = (LPBITMAPINFO)lpBmpInfoHdr;
    lpbmc        = (LPBITMAPCOREINFO)lpBmpInfoHdr;
    dwNumColors  = NumColorsInDIB(lpBmpInfoHdr);
    bWinStyleDIB = IS_WIN30_DIB(lpBmpInfoHdr);

    if (0 != dwNumColors)
    {
        hLogPal = GlobalAlloc (GHND, sizeof (LOGPALETTE) + sizeof (PALETTEENTRY) * dwNumColors);
        if (!hLogPal)
        {
            GlobalUnlock(hDIB);
            return NULL;
        }

        lpPal = (LPLOGPALETTE) GlobalLock (hLogPal);
        lpPal->palVersion    = PALVERSION;
        lpPal->palNumEntries = (WORD)dwNumColors;

        for (i = 0;  i < dwNumColors;  i++)
        {
            if (bWinStyleDIB)
            {
                lpPal->palPalEntry[i].peRed   = lpbmi->bmiColors[i].rgbRed;
                lpPal->palPalEntry[i].peGreen = lpbmi->bmiColors[i].rgbGreen;
                lpPal->palPalEntry[i].peBlue  = lpbmi->bmiColors[i].rgbBlue;
                lpPal->palPalEntry[i].peFlags = 0;
            }
            else
            {
                lpPal->palPalEntry[i].peRed   = lpbmc->bmciColors[i].rgbtRed;
                lpPal->palPalEntry[i].peGreen = lpbmc->bmciColors[i].rgbtGreen;
                lpPal->palPalEntry[i].peBlue  = lpbmc->bmciColors[i].rgbtBlue;
                lpPal->palPalEntry[i].peFlags = 0;
            }
        }

        hPal = CreatePalette (lpPal);
        GlobalUnlock(hLogPal);
        GlobalFree(hLogPal);
    }
    GlobalUnlock(hDIB);
    return(hPal);
}


//////////////////////////////////////////////////////////////////////////
//  Function:  GetDefaultICMProfile
//
//  Description:
//    Uses GetICMProfile to retrieve the filename of the default ICM
//    profile for the DC.
//
//  Parameters:
//    @@@
//
//  Returns:
//    LPTSTR
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPTSTR GetDefaultICMProfile(HDC hDC)
{
    // Local variables
    LPTSTR    lpszProfileName;
    BOOL      bProfile;
    DWORD     dwProfileLen;
    TCHAR     stProfileName[MAX_PATH+1];
    HGLOBAL   hFree;

    //  Initialize variables
    lpszProfileName = NULL;
    dwProfileLen = 0;
    stProfileName[0] = __TEXT('\0');

    // Query for size of profile name string
    bProfile = GetICMProfile(hDC, &dwProfileLen, NULL);
    if (bProfile)
    {
        DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile returned TRUE on query, dwProfileLen = %ld\r\n"), dwProfileLen);
        return(FALSE);
    }

    if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
    {
        DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile set unexpected LastError %ld on query, dwProfileLen = %ld\r\n"),
                 GetLastError(), dwProfileLen);
        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
        dwProfileLen = MAX_PATH;
    }
    else
    {
        if (0 == dwProfileLen)
        {
            DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile returned FALSE on query, DID NOT SET dwProfileLen\r\n"));
            return(FALSE);
        }
    }


    // Fill in lpszProfileName with actual profile filename
    lpszProfileName = GlobalAlloc(GPTR, (dwProfileLen+1) * sizeof(TCHAR));
    if (lpszProfileName != NULL)
    {
        bProfile = GetICMProfile(hDC, &dwProfileLen, lpszProfileName);
        if (!bProfile)
        {
            DebugMsg(__TEXT("GetDefaultICMProfile:  GetICMProfile FAILED\r\n"));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
            hFree = GlobalFree(lpszProfileName);
            return(NULL);
        }
        else  // Successfully id'd default profile
        {
            TCHAR   szName[MAX_PATH], szExt[MAX_PATH];

            DebugMsg(__TEXT("Full profile name:  <%s>\r\n"), lpszProfileName);
            _tsplitpath(lpszProfileName, NULL, NULL, szName, szExt);
            wsprintf(lpszProfileName, __TEXT("%s%s"), szName, szExt);
        }
    }
    else
    {
        DebugMsg(__TEXT("GetDefaultICMProfile:  Unable to allocate lpszProfileName.\r\n"));
    }
    return(lpszProfileName);
} // End of function GetDefaultICMProfile


//////////////////////////////////////////////////////////////////////////
//  Function:  TransformDIBOutsideDC
//
//  Description:
//    Transforms the provided hDIB using the provided profile names.
//
//  Parameters:
//    HANDLE      Handle to DIB to process
//    LPTSTR      Destination profile
//    LPTSTR      Target profile
//
//  Returns:
//    HANDLE to transformed bits; NULL upon failure.
//
//  Comments:
//    Uses ICM functions
//        CreateColorTransform
//        TranslateBitmapBits
//        TranslateColors
//
//////////////////////////////////////////////////////////////////////////
HANDLE TransformDIBOutsideDC(HANDLE hDIB, BMFORMAT bmInput, LPTSTR lpszDestProfile,
                             LPTSTR lpszTargetProfile, DWORD dwIntent, PBMCALLBACKFN pBMCallback,
                             ULONG ulCallbackData)
{
    // Local variables
    HANDLE          hDIBTransformed;    // Handle to transformed DIB
    HPROFILE        hDestProfile, hTargetProfile;
    HTRANSFORM      hTransform;
    LPLOGCOLORSPACE lpLogColorSpace;
    PVOID           pSrcBits, pDestBits;
    LPBITMAPINFOHEADER  lpbSrcDIBHdr, lpbDestDIBHdr;
    BOOL            bTranslated, bProfileClosed, bDeleted, bDeleteProfile;
    DWORD           dwCopySize;

    //  Initialize variables
    ASSERT(NULL != hDIB);
    ASSERT(NULL != lpszDestProfile);
    hDIBTransformed = NULL;
    SetLastError(0);
    hTransform = NULL;
    bTranslated = FALSE;

    hDestProfile   = OpenColorProfileFromFile(lpszDestProfile );
    hTargetProfile = OpenColorProfileFromFile(lpszTargetProfile);

    if (NULL == hDestProfile)
    {
        DebugMsg(__TEXT("TransformDIBOutsideDC : NULL dest file\r\n"));
        return(NULL);
    }

    // Get bits from original DIB
    lpbSrcDIBHdr = GlobalLock(hDIB);

    pSrcBits = (PVOID)FindDIBBits(lpbSrcDIBHdr);

    // Get LPLOGCOLORSPACE for transform
    lpLogColorSpace = GetColorSpaceFromBitmap(lpbSrcDIBHdr, dwIntent, &bDeleteProfile);

    if (NULL != lpLogColorSpace)
    {
        //Create the transform to use
        SetLastError(0);
        hTransform = CreateColorTransform(lpLogColorSpace, hDestProfile, hTargetProfile, ENABLE_GAMUT_CHECKING | NORMAL_MODE | 0x80000000);

        if (NULL != hTransform)
        {
            // Allocate for new DIB
            hDIBTransformed = GlobalAlloc(GHND, GlobalSize(hDIB));
            lpbDestDIBHdr = GlobalLock(hDIBTransformed);

            switch (BITCOUNT(lpbSrcDIBHdr))
            {
                DWORD   dwSrcOffBytes, dwDestOffBytes;

                case 1: // BM_1GRAY:
                case 4:
                case 8:
                    ASSERT((((LPBITMAPV5HEADER)lpbSrcDIBHdr)->bV5ClrUsed) <= (DWORD)( 1 << ((LPBITMAPV5HEADER)lpbSrcDIBHdr)->bV5BitCount));
                    // Copy entire DIB.  Color table will be replaced by TranslateColors
                    dwCopySize = GlobalSize(hDIB);
                    memset(lpbDestDIBHdr, 0x17, dwCopySize);
                    memcpy(lpbDestDIBHdr, lpbSrcDIBHdr, dwCopySize);

                    dwSrcOffBytes = *(LPDWORD)lpbSrcDIBHdr;
                    dwDestOffBytes   = *(LPDWORD)lpbDestDIBHdr;

                    pSrcBits  = (PBYTE)lpbSrcDIBHdr  + dwSrcOffBytes;
                    pDestBits = (PBYTE)lpbDestDIBHdr + dwDestOffBytes;

                    // Needed to use different translation if BITMAPCORE bitmap.
                    if (dwSrcOffBytes >= sizeof(BITMAPINFOHEADER))
                    {
                        bTranslated = TranslateColorTable(hTransform,
                                                          (PCOLOR)pSrcBits, // paInputColors,
                                                          ((LPBITMAPV5HEADER)lpbSrcDIBHdr)->bV5ClrUsed, // nColors,
                                                          COLOR_RGB, // ctInput,
                                                          (PCOLOR)pDestBits, // paOutputColors,
                                                          COLOR_RGB,  // ctOutput)
                                                          lpbSrcDIBHdr->biBitCount);
                    }
                    else
                    {
                        bTranslated = TranslateBitmapBits(hTransform,
                                                          pSrcBits,
                                                          BM_RGBTRIPLETS,
                                                          NumColorsInDIB(lpbSrcDIBHdr),
                                                          1,
                                                          0,
                                                          pDestBits,
                                                          BM_RGBTRIPLETS,
                                                          0,
                                                          NULL,
                                                          0);
                    }

                    if (0 == bTranslated)
                    {
                        DebugMsg(__TEXT("TransformDIBOutsideDC : TranslateColors failed, :"));
                        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
                    }
                    break;

                case 16: // BM_RGBTRIPLETS:
                case 24: // BM_xRGBQUADS:
                case 32: // BM_x555RGB:

                    // Copy header from original DIB to new DIB
                    memcpy(lpbDestDIBHdr, lpbSrcDIBHdr, sizeof(BITMAPV5HEADER));
                    pDestBits = (PVOID)FindDIBBits(lpbDestDIBHdr);

                    bTranslated = TranslateBitmapBits(hTransform,
                                                      pSrcBits,
                                                      bmInput,
                                                      BITMAPWIDTH(lpbSrcDIBHdr),
                                                      abs(BITMAPHEIGHT(lpbSrcDIBHdr)),
                                                      0,
                                                      pDestBits,
                                                      bmInput,
                                                      0,
                                                      pBMCallback,
                                                      ulCallbackData);

                    if (0 == bTranslated)
                    {
                        DebugMsg(__TEXT("TransformDIBOutsideDC : TranslateBitmapBits failed:\r\n"));
                        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
                    }
                    break;

                default:  // 8bpp
                    DebugMsg(__TEXT("TransformDIBOutsideDC : Unrecognized format\r\n"));
                    bTranslated = FALSE;
                    break;
            }
            bDeleted = DeleteColorTransform(hTransform);
            if (0 == bDeleted)
            {
                DebugMsg(__TEXT("TransformDIBOutsideDC : DeleteColorTransform failed, : "));
                DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
            }
        }
        else
        {
            ErrMsg(NULL, __TEXT("TransformDIBOutsideDC : CreateColorTransform failed"));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
        }

        if (bDeleteProfile)
        {
            DeleteFile(lpLogColorSpace->lcsFilename);
        }

        GlobalFree((HANDLE)lpLogColorSpace);
    }
    else // Failed to get LOGCOLORSPACE
    {
        ErrMsg(NULL, __TEXT("TransformDIBOutsideDC : Failed to get LOGCOLORSPACE"));
    }

    if (NULL != hDestProfile)
    {
        bProfileClosed = CloseColorProfile(hDestProfile);
        if (0 == bProfileClosed)
        {
            DebugMsg(__TEXT("TransformDIBOutsideDC : Failed to close hDestProfile, "));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
        }
    }

    if (NULL != hTargetProfile)
    {
        bProfileClosed = CloseColorProfile(hTargetProfile);
        if (0 == bProfileClosed)
        {
            DebugMsg(__TEXT("TransformDIBOutsideDC : Failed to close hTargetProfile, "));
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
        }
    }
    if (NULL != hDIBTransformed)
    {
        GlobalUnlock(hDIBTransformed);
    }
    if ((NULL == hTransform) || (0 == bTranslated))
    {
        if (NULL != hDIBTransformed)
        {
            GlobalFree(hDIBTransformed);
            hDIBTransformed = NULL;
        }
        lpbDestDIBHdr = NULL;
        pDestBits = NULL;
    }
    return(hDIBTransformed);
}   // End of function TransformDIBOutsideDC

//////////////////////////////////////////////////////////////////////////
//  Function:  OpenColorProfileFromFile
//
//  Description:
//    Creates a color profile based upon the parameters passed.
//
//  Parameters:
//    LPTSTR  Profile name
//
//  Returns:
//    HPROFILE Handle to PROFILE structure, NULL if failure.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
HPROFILE OpenColorProfileFromFile(LPTSTR lpszProfileName)
{
    // Local variables
    PPROFILE  pProfile;
    HPROFILE  hProfile;
    DWORD     cbDataSize;
    DWORD     dwProfileSize;
    TCHAR     stFullProfile[MAX_PATH];
    BOOL      bValid;

    //  Initialize variables
    if (NULL == lpszProfileName)
    {
        return(NULL);
    }

    // Add COLOR dir path if profile name does not contain a path.
    if ( (NULL == _tcschr(lpszProfileName, __TEXT(':')))
         &&
         (NULL == _tcschr(lpszProfileName, __TEXT('\\')))
       )
    {
        wsprintf(stFullProfile, __TEXT("%s\\%s"), gstProfilesDir, lpszProfileName);
    }
    else
    {
        lstrcpy(stFullProfile, lpszProfileName);
    }
    dwProfileSize = sizeof(PROFILE);
    cbDataSize = (lstrlen(stFullProfile) * sizeof(TCHAR)) + sizeof(TCHAR); // String plus NULL
    pProfile = GlobalAlloc(GPTR, (dwProfileSize + cbDataSize));
#ifdef _DEBUG
    memset(pProfile, UNINIT_BYTE, (cbDataSize+dwProfileSize));
#endif

    pProfile->dwType = PROFILE_FILENAME;
    pProfile->cbDataSize = cbDataSize;
    pProfile->pProfileData = (PVOID)((LPBYTE)pProfile + dwProfileSize);
    _tcscpy(pProfile->pProfileData, stFullProfile);
    hProfile = OpenColorProfile(pProfile, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING);
    if (NULL  == hProfile)
    {
        ErrMsg(NULL,__TEXT("Unable to open color profile <%s>"), stFullProfile);
        DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
    }
    else
    {
        // Validate the profile
        bValid = IsColorProfileValid(hProfile, &bValid);
        if (0 == bValid)
        {
            ErrMsg(NULL,__TEXT("Color profile %s is not valid"), stFullProfile);
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
            CloseColorProfile(hProfile);
            hProfile = NULL;
        }
    }
    // Cleanup
    GlobalFree(GlobalHandle(pProfile));
    return(hProfile);
}   // End of function OpenColorProfileFromDisk


///////////////////////////////////////////////////////////////////////
//
// Function:   GetColorSpaceFromBitmap
//
// Purpose:    Creates a LOGCOLORSPACE based on information in bitmap.
//
//
// Parms:      lpBitmapHeader   Pointer to bitmap header and info.
//             dwIntent         Color Space Intent.
//             pbDeleteProfile  Flag, on return, will indicate if the profile needs
//                              to be deleted before LOGCOLORSPACE is freed.
//
//
///////////////////////////////////////////////////////////////////////

LPLOGCOLORSPACE GetColorSpaceFromBitmap(LPBITMAPINFOHEADER lpBitmapInfo, DWORD dwIntent,
                                        LPBOOL pbDeleteProfile)
{
    LPLOGCOLORSPACE lpColorSpace = NULL;
    PBITMAPV5HEADER lpBitmapV5 = (PBITMAPV5HEADER) lpBitmapInfo;

    // Validate parameters.
    ASSERT(NULL != lpBitmapInfo);
    if ( (NULL == lpBitmapInfo)
         ||
         (NULL == pbDeleteProfile)
         ||
         ( (sizeof(BITMAPCOREHEADER) != lpBitmapInfo->biSize)
           &&
           (sizeof(BITMAPINFOHEADER) != lpBitmapInfo->biSize)
           &&
           (sizeof(BITMAPV4HEADER) != lpBitmapInfo->biSize)
           &&
           (sizeof(BITMAPV5HEADER) != lpBitmapInfo->biSize)
         )
       )
    {
        return NULL;
    }

    // Initalize delete flag.
    *pbDeleteProfile = FALSE;

    // Allocate LOGCOLORSPACE.
    lpColorSpace = (LPLOGCOLORSPACE) GlobalAlloc(GPTR, sizeof(LOGCOLORSPACE));
    if (NULL == lpColorSpace)
    {
        return NULL;
    }

    // Initialize color space.
    lpColorSpace->lcsSignature = 'PSOC';  // The signature should always be 'PSOC'.
    lpColorSpace->lcsVersion = 0x400;
    lpColorSpace->lcsSize = sizeof(LOGCOLORSPACE);

    // If BITMAPCOREHEADER or BITMAPINFOHEADER, bitmap has no information
    // about color space; use sRGB.
    if (sizeof(BITMAPINFOHEADER) >= lpBitmapInfo->biSize)
    {
        // Set color space to default values.

        lpColorSpace->lcsCSType = LCS_sRGB;

        // Set endpoints to sRGB values.

        lpColorSpace->lcsEndpoints.ciexyzRed.ciexyzX = __FXPT2DOT30(.64);
        lpColorSpace->lcsEndpoints.ciexyzRed.ciexyzY = __FXPT2DOT30(.33);
        lpColorSpace->lcsEndpoints.ciexyzRed.ciexyzZ = __FXPT2DOT30(.03);

        lpColorSpace->lcsEndpoints.ciexyzGreen.ciexyzX = __FXPT2DOT30(.3);
        lpColorSpace->lcsEndpoints.ciexyzGreen.ciexyzY = __FXPT2DOT30(.6);
        lpColorSpace->lcsEndpoints.ciexyzGreen.ciexyzZ = __FXPT2DOT30(.1);

        lpColorSpace->lcsEndpoints.ciexyzBlue.ciexyzX   =   __FXPT2DOT30(  .15);
        lpColorSpace->lcsEndpoints.ciexyzBlue.ciexyzY = __FXPT2DOT30(.06);
        lpColorSpace->lcsEndpoints.ciexyzBlue.ciexyzZ = __FXPT2DOT30(.79);

        // Just so that if monitor has 2.2 gamma, the over all gamma is 1.0.
        lpColorSpace->lcsGammaRed = __FXPT16DOT16(0.45);
        lpColorSpace->lcsGammaGreen = __FXPT16DOT16(0.45);
        lpColorSpace->lcsGammaBlue = __FXPT16DOT16(0.45);
    }
    else
    {
        // Copy information from portion that is similar between BITMAPV4HEADERs and
        // BITMAPV5HEADERs.
        memcpy(&lpColorSpace->lcsEndpoints, &lpBitmapV5->bV5Endpoints, sizeof(CIEXYZTRIPLE));
        lpColorSpace->lcsGammaRed = lpBitmapV5->bV5GammaRed;
        lpColorSpace->lcsGammaGreen = lpBitmapV5->bV5GammaGreen;
        lpColorSpace->lcsGammaBlue = lpBitmapV5->bV5GammaBlue;

        // BITMAPV4HEADERs do not have complete color space information,
        // we need to assume some things.
        if (sizeof(BITMAPV4HEADER) == lpBitmapInfo->biSize)
        {
            // Fill in default values for fields that do not
            // have equivalents in BITMAPV4HEADER.
            lpColorSpace->lcsCSType = lpBitmapV5->bV5CSType;
            lpColorSpace->lcsIntent = LCS_GM_IMAGES;
        }
        else
        {
            // BITMAPV5HEADERs have complete color space information.
            // No assumptions to make.
            lpColorSpace->lcsIntent = lpBitmapV5->bV5Intent;

            // Look to see if no, linked, or embedded profile.
            switch (lpBitmapV5->bV5CSType)
            {
                case 'MBED':
                    // Need to create profile file and reference
                    // profile in the color space.
                    lpColorSpace->lcsCSType = LCS_CALIBRATED_RGB;

                    // Make sure that profile data offset is valid and not zero length.
                    if ( (lpBitmapV5->bV5Size > lpBitmapV5->bV5ProfileData)
                         ||
                         (0L == lpBitmapV5->bV5ProfileSize)
                       )
                    {
                        GlobalFree((HANDLE)lpColorSpace);
                        return NULL;
                    }

                    // Create unique temp name.
                    {
                        DWORD   dwWritten;
                        TCHAR   szTempPath[MAX_PATH];
                        HANDLE  hFile;

                        GetTempPath(MAX_PATH, szTempPath);
                        if (!GetTempFileName(szTempPath, __TEXT("ICM"), 0, lpColorSpace->lcsFilename))
                        {
                            GlobalFree((HANDLE)lpColorSpace);
                            return NULL;
                        }

                        // Create temp profile that contains the embedded profile.
                        hFile = CreateFile(lpColorSpace->lcsFilename, GENERIC_READ | GENERIC_WRITE,
                                           0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                        if (INVALID_HANDLE_VALUE == hFile)
                        {
                            GlobalFree((HANDLE)lpColorSpace);
                            return NULL;
                        }

                        // Write embedded profile to disk.
                        WriteFile(hFile, GETPROFILEDATA(lpBitmapV5), lpBitmapV5->bV5ProfileSize,
                                  &dwWritten, NULL);

                        // No longer need file open.
                        CloseHandle(hFile);

                        // Need to indicate to caller that this file needs to be deleted
                        // before LOGCOLORSPACE is freed.
                        *pbDeleteProfile = TRUE;
                    }
                    break;

                case 'LINK':
                    // Need to reference profile.
                    lpColorSpace->lcsCSType = LCS_CALIBRATED_RGB;
                    lstrcpyn(lpColorSpace->lcsFilename, (LPTSTR) GETPROFILEDATA(lpBitmapV5), MAX_PATH);
                    break;

                default:
                    // Just use color space type in the bitmap.
                    lpColorSpace->lcsCSType = lpBitmapV5->bV5CSType;
                    break;
            }
        }
    }
    // Set intent to default or to users selection.
    if (0xffffffffL == dwIntent)
    {
        lpColorSpace->lcsIntent = LCS_GM_IMAGES;
    }
    else
    {
        lpColorSpace->lcsIntent = dwIntent;
    }

    return(lpColorSpace);
}


//
// Functions for extracting information from DIBs
//

//////////////////////////////////////////////////////////////////////////
//  Function:  NumColorsInDIB
//
//  Description:
//    Determines the number of colors in the DIB by looking at the
//    BitCount field in the info block.
//
//  Parameters:
//    LPBINTMAPV5HEADER Pointer to BITMAPINFO structure
//
//  Returns:
//    DWORD   Number of colors in the DIB
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
DWORD NumColorsInDIB(LPBITMAPINFOHEADER lpbi)
{
    WORD    wBitCount;
    DWORD   dwColors = 0;


    // If this is a Windows style DIB, the number of colors in the
    //  color table can be less than the number of bits per pixel
    //  allows for (i.e. lpbi->biClrUsed can be set to some value).
    //  If this is the case, return the appropriate value.
    if ( (sizeof(BITMAPINFOHEADER) <= lpbi->biSize)
         &&
         (0 != lpbi->biClrUsed)
       )
    {
        dwColors = lpbi->biClrUsed;
    }
    else
    {
        // Calculate the number of colors in the color table based on
        //  the number of bits per pixel for the DIB.
        wBitCount = BITCOUNT(lpbi);
        if (MAX_BPP_COLOR_TABLE >= wBitCount)
        {
            dwColors = 1 << wBitCount;  // Colors = 2^BitCount
        }
    }

    return dwColors;
}   // End of function NumColorsInDIB


//////////////////////////////////////////////////////////////////////////
//  Function:  PaletteSize
//
//  Description:
//    Calculates the palette size in bytes.
//
//  Parameters:
//    @@@
//
//  Returns:
//    DWORD   Palette size in bytes.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////

DWORD PaletteSize(LPBITMAPINFOHEADER lpbi)
{
    DWORD   dwSize = 0L;

    if (sizeof(BITMAPINFOHEADER) <= lpbi->biSize)
    {
        dwSize = NumColorsInDIB(lpbi) * sizeof(RGBQUAD);

        if ( (lpbi->biCompression == BI_BITFIELDS)
             &&
             (sizeof(BITMAPV4HEADER) > lpbi->biSize)
           )
        {
            dwSize = 3 * sizeof(DWORD);
        }
    }
    else
    {
        dwSize = NumColorsInDIB(lpbi) * sizeof (RGBTRIPLE);
    }

    return dwSize;
}   // End of function PaletteSize


///////////////////////////////////////////////////////////////////////
//
// Function:   FindDIBBits
//
// Purpose:    Given a pointer to a DIB, returns a pointer to the
//             DIB's bitmap bits.
//
// Parms:      lpbi == pointer to DIB header (either BITMAPINFOHEADER
//                       or BITMAPCOREHEADER)
//
///////////////////////////////////////////////////////////////////////

LPBYTE FindDIBBits(LPBITMAPINFOHEADER lpbi)
{
    ASSERT(NULL != lpbi);
    return ((LPBYTE)lpbi + *(LPDWORD)lpbi + PaletteSize(lpbi) + PROFILESIZE(lpbi));
}

///////////////////////////////////////////////////////////////////////
//
// Function:   FindColorTable
//
// Purpose:    Given a pointer to a DIB, returns a pointer to the
//             DIB's color table (if present).
//
// Parms:      lpbi == pointer to DIB header (either BITMAPINFOHEADER
//                       or BITMAPCOREHEADER)
//
///////////////////////////////////////////////////////////////////////

LPBYTE FindColorTable(LPBITMAPINFOHEADER lpbi)
{
    ASSERT(NULL != lpbi);
    return ((LPBYTE)lpbi + *(LPDWORD)lpbi);
}

///////////////////////////////////////////////////////////////////////
//
// Function:   DIBHeight
//
// Purpose:    Given a pointer to a DIB, returns the ABSOLUTE VALUE of
//             its height.  Note that it returns a DWORD (since a Win30
//             DIB can have a DWORD in its height field), but under
//             Win30, the high order word isn't used!
//
// Parms:      lpDIB == pointer to DIB header (either BITMAPINFOHEADER
//                       or BITMAPCOREHEADER)
//
///////////////////////////////////////////////////////////////////////

LONG DIBHeight (LPBYTE lpDIB)
{
    LPBITMAPINFOHEADER lpbmi;
    LPBITMAPCOREHEADER lpbmc;

    lpbmi = (LPBITMAPINFOHEADER) lpDIB;
    lpbmc = (LPBITMAPCOREHEADER) lpDIB;
    if (lpbmi->biSize >= sizeof (BITMAPINFOHEADER))
    {
        return labs(lpbmi->biHeight); // biHeight can now be negative! 8/9/93
    }
    else
    {
        return (LONG) lpbmc->bcHeight;
    }
}

///////////////////////////////////////////////////////////////////////
//
// Function:   DIBWidth
//
// Purpose:    Given a pointer to a DIB, returns its width.  Note
//             that it returns a DWORD (since a Win30 DIB can have
//             a DWORD in its width field), but under Win30, the
//             high order word isn't used!
//
// Parms:      lpDIB == pointer to DIB header (either BITMAPINFOHEADER
//                       or BITMAPCOREHEADER)
//
///////////////////////////////////////////////////////////////////////

LONG DIBWidth (LPBYTE lpDIB)
{
    LPBITMAPINFOHEADER lpbmi;
    LPBITMAPCOREHEADER lpbmc;

    lpbmi = (LPBITMAPINFOHEADER) lpDIB;
    lpbmc = (LPBITMAPCOREHEADER) lpDIB;

    if (lpbmi->biSize >= sizeof (BITMAPINFOHEADER))
    {
        return lpbmi->biWidth;
    }
    else
    {
        return (LONG) lpbmc->bcWidth;
    }
}

//
//  Functions for reading DIBs
//

//////////////////////////////////////////////////////////////////////////
//  Function:  ReadDIBFile
//
//  Description:
//     Open a DIB file and create
//          -a memory DIB
//          -a memory handle containing BITMAPINFO, palette, and the bits
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    HGLOBAL Handle to DIB memory; NULL upon failure.
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

HGLOBAL ReadDIBFile(LPTSTR lpszFileName)
{
    // Local variables
    HGLOBAL             hDIBInfo;
    LPDIBINFO           lpDIBInfo;
    BOOL                bGotDIBInfo;

    //  Initialize variables
    hDIBInfo = CreateDIBInfo();
    if (hDIBInfo == NULL)
    {
        return(NULL);
    }
    lpDIBInfo = GlobalLock(hDIBInfo);
    if (lpDIBInfo == (LPDIBINFO)NULL)
    {
        GlobalFree(hDIBInfo);
        return(NULL);
    }
    bGotDIBInfo =  fReadDIBInfo(lpszFileName, lpDIBInfo);
    GlobalUnlock(hDIBInfo);
    if (0 == bGotDIBInfo)  // failed to open file
    {
        fFreeDIBInfo(hDIBInfo, TRUE);
        hDIBInfo = NULL;
    }
    return(hDIBInfo);
}   // End of function ReadDIBFile

HGLOBAL PasteDIBData(HWND hWnd, int wmPasteMode)
{
    // Local variables
    HGLOBAL             hDIBInfo;
    LPDIBINFO           lpDIBInfo;
    BOOL                bGotDIBInfo;

    //  Initialize variables
    hDIBInfo = CreateDIBInfo();
    if (hDIBInfo == NULL)
    {
        return(NULL);
    }
    lpDIBInfo = GlobalLock(hDIBInfo);
    if (lpDIBInfo == (LPDIBINFO)NULL)
    {
        GlobalFree(hDIBInfo);
        return(NULL);
    }
    bGotDIBInfo =  fPasteDIBInfo(hWnd, wmPasteMode, lpDIBInfo);
    GlobalUnlock(hDIBInfo);
    if (0 == bGotDIBInfo)  // failed to open file
    {
        fFreeDIBInfo(hDIBInfo, TRUE);
        hDIBInfo = NULL;
    }
    return(hDIBInfo);

} // End of function PasteDIBData()

HANDLE PasteDIBFromClipboard(HWND hWnd, int wmPasteMode)
{
    UINT   uFormat;
    HANDLE hDIB = NULL;

    if (wmPasteMode == IDM_FILE_PASTE_CLIPBOARD_DIB)
    {
        uFormat = CF_DIB;
    }
    else if (wmPasteMode == IDM_FILE_PASTE_CLIPBOARD_DIBV5)
    {
        uFormat = CF_DIBV5;
    }
    else
    {
        return NULL;
    }

    if (OpenClipboard(hWnd))
    {
        HANDLE hData = GetClipboardData(uFormat);

        if (hData)
        {
            DWORD dwSize = GlobalSize(hData);

            hDIB = GlobalAlloc(GHND,dwSize);

            if (hDIB)
            {
                PVOID pv1,pv2;

                if (pv1 = GlobalLock(hData))
                {
                    if (pv2 = GlobalLock(hDIB))
                    {
                        CopyMemory(pv2,pv1,dwSize);

                        DebugMsg(__TEXT("DIBS.C : PasteDIBFromClipboard: DIB is copied from clipboard.\r\n"));
                        DumpBmpHeader(pv2);

                        GlobalUnlock(pv2);
                    }

                    GlobalUnlock(pv1);
                }
            }
        }
        else
        {
            DebugMsg(__TEXT("DIBS.C : PasteDIBFromClipboard: hData is NULL.\r\n"));
        }

        CloseClipboard();
    }
    else
    {
        DebugMsg(__TEXT("DIBS.C : PasteDIBFromClipboard: Failed on OpenClipboard.\r\n"));
    }

    return hDIB;
}

//////////////////////////////////////////////////////////////////////////
//  Function:   ReadDIBFromFile
//
//  Description:
//      Reads in the bitmap information.
//
//  Parameters:
//      hFile   Handle to bitmap file.
//
//  Returns:  Handle to DIB Bitmap.  NULL on error.
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

HANDLE ReadDIBFromFile(HANDLE hFile)
{
    UINT                    nNumColors;
    DWORD                   offBits;
    DWORD                   dwRead;
    DWORD                   dwImageBytes;
    DWORD                   dwSizeImage;
    HANDLE                  hDIB;
    BITMAPFILEHEADER        BmpFileHeader;
    LPBITMAPINFOHEADER      lpbi;

    // Make sure non-null file handle.

    if (NULL == hFile)
    {
        return NULL;
    }

    // Read in Bitmap file header.
    if (0L != SetFilePointer(hFile, 0, NULL, FILE_BEGIN))
    {
        return NULL;
    }
    ReadFile(hFile, &BmpFileHeader, sizeof(BITMAPFILEHEADER), &dwRead, NULL);
    if (sizeof(BITMAPFILEHEADER) != dwRead)
    {
        return NULL;
    }

    // Make sure that the file is a bitmap file.
    if (BFT_BITMAP != BmpFileHeader.bfType)
    {
        return NULL;
    }

    // Detemine size of bitmap header.
    ReadFile(hFile, &dwImageBytes, sizeof(DWORD), &dwRead, NULL);
    if (sizeof(DWORD) != dwRead)
    {
        return NULL;
    }

    // Allocate memory for header & color table.
    // We'll enlarge this memory as needed.
    hDIB = GlobalAlloc(GHND, dwImageBytes + (256L * sizeof(RGBQUAD)));
    if (!hDIB)
    {
        return NULL;
    }
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);
    if (!lpbi)
    {
        GlobalFree(hDIB);
        return NULL;
    }

    // Back up to begining of bitmap header and read bitmap header.
    SetFilePointer(hFile, sizeof(BITMAPFILEHEADER), NULL, FILE_BEGIN);
    ReadFile(hFile, lpbi, dwImageBytes, &dwRead, NULL);
    if (dwRead != dwImageBytes)
    {
        GlobalUnlock(hDIB);
        GlobalFree(hDIB);
        return NULL;
    }

    // Dump debug info about type of bitmap opened.
#ifdef MAXDEBUG
    DumpBmpHeader((LPVOID)lpbi);
#endif

    // Check to see that it's a Windows DIB or an OS/2 DIB.
    // It assumed that anything that is not a OS/2 DIB is a Windows DIB.
    // This at least allows the opening of newer bitmap types, although GDI
    // may not handle them so we may not be able to display them.
    // More critical checking could be done by checking against
    // BITMAPV4HEADER and BITMAPV5HEADER sizes.

    if (lpbi->biSize >= sizeof(BITMAPINFOHEADER))
    {
        DWORD   dwProfileData = 0;
        DWORD   dwColorTableSize;
        HANDLE  hTemp;

        // Now determine the size of the color table and read it.  Since the
        // bitmap bits are offset in the file by bfOffBits, we need to do some
        // special processing here to make sure the bits directly follow
        // the color table (because that's the format we are susposed to pass
        // back)

        // no color table for 24-bit, default size otherwise
        nNumColors = (UINT)lpbi->biClrUsed;
        if (0 == nNumColors)
        {
            if (lpbi->biBitCount <= MAX_BPP_COLOR_TABLE)
            {
                nNumColors = 1 << lpbi->biBitCount;             // standard size table
            }
        }

        // Fill in some default values if they are zero
        if (0 == lpbi->biClrUsed)
        {
            lpbi->biClrUsed = nNumColors;
        }

        if (0 == lpbi->biSizeImage)
        {
            // Calculate size using DWORD alignment
            dwSizeImage = (((lpbi->biWidth * lpbi->biBitCount + 31) & ~31)
                           >> 3) * abs(lpbi->biHeight);
        }
        else
        {
            dwSizeImage = lpbi->biSizeImage;
        }

        // get a proper-sized buffer for header, color table and bits
        // Figure out the size of the bitmap AND it's color table.
        dwColorTableSize = PaletteSize(lpbi);

        // Calculate profile data size;
        // zero if not BITMAPV5HEADER, else in use bV5ProfileSize.
        dwProfileData =  PROFILESIZE(lpbi);

        // Resize DIB buffer.
        dwImageBytes = lpbi->biSize + dwSizeImage + dwColorTableSize + dwProfileData;
        GlobalUnlock(hDIB);
        hTemp = GlobalReAlloc(hDIB, dwImageBytes, GHND);
        DebugMsg(__TEXT("ReadDIBFromFile:  Allocating %lu bytes for header, color table, and image\r\n"), dwImageBytes);
        if (NULL == hTemp) // can't resize buffer for loading
        {
            GlobalFree(hDIB);
            return NULL;
        }

        hDIB = hTemp;
        lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

        // read the color table, if any, into buffer starting past Bitmap header.
        if (0 != dwColorTableSize)
        {
            ReadFile(hFile, (LPBYTE)lpbi + lpbi->biSize, dwColorTableSize, &dwRead, NULL);
            if (dwColorTableSize != dwRead)
            {
                GlobalUnlock(hDIB);
                GlobalFree(hDIB);
                return NULL;
            }
        }

        // Load profile data, if any.
        if (0 != dwProfileData)
        {
            // Move to profile data.
            SetFilePointer(hFile, sizeof(BITMAPFILEHEADER)
                           + ((LPBITMAPV5HEADER)lpbi)->bV5ProfileData, NULL, FILE_BEGIN);

            // Read the profile data in after the header and color table.
            ReadFile(hFile, (LPBYTE)lpbi + lpbi->biSize + dwColorTableSize, dwProfileData, &dwRead, NULL);
            if (dwProfileData != dwRead)
            {
                GlobalUnlock(hDIB);
                GlobalFree(hDIB);
                return NULL;
            }

            // Need to change the offset in the header.
            ((LPBITMAPV5HEADER)lpbi)->bV5ProfileData = lpbi->biSize + dwColorTableSize;
        }

        // offset to the bits from start of DIB header
        offBits = lpbi->biSize + dwColorTableSize + dwProfileData;
        DumpBmpHeader((LPVOID)lpbi);
    }
    else
    {
        // It's an OS/2 DIB, the color table is an array of RGBTRIPLEs.
        HANDLE                          hTemp;
        LPBITMAPCOREHEADER      lpbc = (LPBITMAPCOREHEADER) lpbi;

        // Gotta back up to beginning of color table.
        SetFilePointer(hFile, sizeof (BITMAPFILEHEADER) + sizeof (BITMAPCOREHEADER), NULL, FILE_BEGIN);

        // Now determine the size of the color table and read it.  Since the
        // bitmap bits are offset in the file by bfOffBits, we need to do some
        // special processing here to make sure the bits directly follow
        // the color table (because that's the format we are susposed to pass
        // back)

        if (lpbc->bcBitCount <= MAX_BPP_COLOR_TABLE)
        {
            nNumColors = 1 << lpbc->bcBitCount;    // standard size table
        }
        else
        {
            nNumColors = 0;
        }

        // Determine the size of the image
        dwSizeImage = (((lpbc->bcWidth * lpbc->bcBitCount + 31) & ~31) >> 3)
                      * lpbc->bcHeight;

        // get a proper-sized buffer for header, color table and bits
        GlobalUnlock(hDIB);
        hTemp = GlobalReAlloc(hDIB, lpbc->bcSize + (nNumColors * sizeof(RGBTRIPLE))
                              + dwSizeImage, GHND);
        if (!hTemp) // can't resize buffer for loading
        {
            GlobalFree(hDIB);
            return NULL;
        }

        hDIB = hTemp;
        lpbc = (LPBITMAPCOREHEADER) GlobalLock(hDIB);
        lpbi = (LPBITMAPINFOHEADER) lpbc;

        // read the color table
        ReadFile(hFile, (LPBYTE)lpbc + lpbc->bcSize, nNumColors * sizeof(RGBTRIPLE), &dwRead, NULL);
        if (nNumColors * sizeof(RGBTRIPLE) != dwRead)
        {
            GlobalUnlock(hDIB);
            GlobalFree(hDIB);
            return NULL;
        }

        // offset to the bits from start of DIB header
        offBits = lpbc->bcSize + nNumColors * sizeof(RGBTRIPLE);
    }

    // If the bfOffBits field is non-zero, then the bits might *not* be
    // directly following the color table in the file.  Use the value in
    // bfOffBits to seek the bits.

    if (BmpFileHeader.bfOffBits != 0L)
    {
        SetFilePointer(hFile, BmpFileHeader.bfOffBits, NULL, FILE_BEGIN);
    }

    // Read the actual bits
    ReadFile(hFile, (LPBYTE)lpbi + offBits, dwSizeImage, &dwRead, NULL);
    if (dwRead != dwSizeImage)
    {
        GlobalUnlock(hDIB);
        GlobalFree(hDIB);
        return NULL;
    }
    GlobalUnlock(hDIB);
    return hDIB;
}  // End of function ReadDIBFromFile

//////////////////////////////////////////////////////////////////////////
//  Function:  TranslateColorTable
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////

BOOL TranslateColorTable(HTRANSFORM hColorTransform,
                         PCOLOR    paInputColors,
                         DWORD   nColors,
                         COLORTYPE     ctInput,
                         PCOLOR    paOutputColors,
                         COLORTYPE   ctOutput,
                         int         biBitCount
                        )
{
    //  Initialize variables
    if (ctInput == COLOR_RGB)
    {
        return(TranslateBitmapBits(hColorTransform,
                                   (PVOID)paInputColors,
                                   BM_xRGBQUADS,
                                   1<<biBitCount,
                                   1,
                                   0,
                                   (PVOID)paOutputColors,
                                   BM_xRGBQUADS,
                                   0,
                                   NULL,
                                   0));
    }
    else
    {
        return(TranslateColors(hColorTransform, paInputColors, nColors, ctInput, paOutputColors, ctOutput));
    }
}   // End of function TranslateColorTable


//////////////////////////////////////////////////////////////////////////
//  Function:  SaveDIBToFile
//
//  Description:
//
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////

BOOL SaveDIBToFile(HWND hWnd, LPCTSTR lpszFileName, LPDIBINFO lpDIBInfo, DWORD dwType)
{
    BOOL                bResult = FALSE;
    HANDLE              hFile;
    HANDLE              hDIBTransformed = NULL;
    PBITMAPINFOHEADER   pBitmapInfo;


    // Validate Parameters.
    if ( (NULL == lpszFileName)
         ||
         (NULL == lpDIBInfo)
         ||
         (NULL == lpDIBInfo->hDIB)
         ||
         ( (LCS_sRGB != dwType)
           &&
           (LCS_CALIBRATED_RGB != dwType)
           &&
           (PROFILE_LINKED != dwType)
           &&
           (PROFILE_EMBEDDED != dwType)
         )
       )
    {
        return FALSE;
    }
    pBitmapInfo = (PBITMAPINFOHEADER) GlobalLock(lpDIBInfo->hDIB);

    // Open file handle.
    hFile = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        DWORD               dwBytes;
        DWORD               dwProfileSize;
        PBYTE               pProfileData;
        LPSTR               lpszProfileName;
        BITMAPV5HEADER      BitmapHeader;
        BITMAPFILEHEADER    FileHeader;


        // Initialize variables.
        dwProfileSize = PROFILESIZE(pBitmapInfo);
        pProfileData = GETPROFILEDATA(pBitmapInfo);
        lpszProfileName = NULL;
        memset(&BitmapHeader, 0, sizeof(BITMAPV5HEADER));
        memset(&FileHeader, 0, sizeof(BITMAPFILEHEADER));

        // Convert to proper type.
        if (dwType != BITMAPCSTYPE(pBitmapInfo))
        {
            if (PROFILE_LINKED == dwType)
            {
                ASSERT(PROFILE_EMBEDDED == BITMAPCSTYPE(pBitmapInfo));

                // Going from Embedded profile to linked.
                // Save embedded profile data to file.

                // Create file name from manufacture and model name of profile header.
                lpszProfileName = (LPSTR) GlobalAlloc(GPTR, 1024);

                // Get save name and save profile data.
                if (GetProfileSaveName(hWnd, &lpszProfileName, 1024))
                {
                    HANDLE  hProfile;

                    hProfile = CreateFileA(lpszProfileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                                           FILE_ATTRIBUTE_NORMAL, NULL);
                    if (INVALID_HANDLE_VALUE != hProfile)
                    {
                        WriteFile(hProfile, pProfileData, dwProfileSize, &dwBytes, NULL);
                        CloseHandle(hProfile);
                    }

                    // Change profile variables to point to linked name.
                    pProfileData = (PBYTE) lpszProfileName;
                    dwProfileSize = strlen(lpszProfileName);
                }
            }
            else if (PROFILE_EMBEDDED == dwType)
            {
                DWORD       dwSize = 0;
                PROFILE     Profile;
                HPROFILE    hProfile;


                ASSERT(PROFILE_EMBEDDED == BITMAPCSTYPE(pBitmapInfo));

                // Going from linked profile to Embedded.
                // Embed Linked profile data.

                // Open profile.
                Profile.dwType = PROFILE_FILENAME;
                Profile.pProfileData = pProfileData;
                Profile.cbDataSize = dwProfileSize;
                hProfile = OpenColorProfile(&Profile, PROFILE_READ, FILE_SHARE_READ, OPEN_EXISTING);

                // Get profile data form handle.
                if (NULL != hProfile)
                {
                    GetColorProfileFromHandle(hProfile, NULL, &dwSize);
                    lpszProfileName = (LPSTR) GlobalAlloc(GPTR, dwSize);
                    GetColorProfileFromHandle(hProfile, (PBYTE) lpszProfileName, &dwSize);

                    CloseColorProfile(hProfile);
                }

                // Change profile variables to point at data to embed.
                pProfileData = (PBYTE) lpszProfileName;
                dwProfileSize = dwSize;
            }
            else if (LCS_sRGB == dwType)
            {
                DWORD       dwSize;
                LPTSTR      pszSRGB;


                // Need to translate from current type to sRGB.

                // Open sRGB profile.
                GetStandardColorSpaceProfile(NULL, LCS_sRGB, NULL, &dwSize);
                pszSRGB = (LPTSTR) GlobalAlloc(GPTR, dwSize);
                GetStandardColorSpaceProfile(NULL, LCS_sRGB, pszSRGB, &dwSize);

                if (NULL != pszSRGB)
                {
                    // Translate DIB.
                    hDIBTransformed = TransformDIBOutsideDC(lpDIBInfo->hDIB,
                                                            lpDIBInfo->bmFormat,
                                                            pszSRGB,
                                                            NULL,
                                                            USE_BITMAP_INTENT,
                                                            NULL,
                                                            0);

                    // Clean up.
                    GlobalFree((HANDLE)pszSRGB);

                    // Change bitmap info variable to point at tranlated DIB.
                    pBitmapInfo = (PBITMAPINFOHEADER) GlobalLock(hDIBTransformed);
                }
            }
        }

        if (NULL != pBitmapInfo)
        {
            // Create file header and write it to the file.
            FileHeader.bfType = BFT_BITMAP;
            FileHeader.bfSize = sizeof(BITMAPFILEHEADER);
            FileHeader.bfSize += sizeof(BITMAPV5HEADER);
            FileHeader.bfSize += NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD);
            FileHeader.bfSize += BITMAPSIZE(pBitmapInfo);
            FileHeader.bfSize += dwProfileSize;
            FileHeader.bfOffBits = sizeof(BITMAPFILEHEADER);
            FileHeader.bfOffBits += sizeof(BITMAPV5HEADER);
            FileHeader.bfOffBits += NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD);
            WriteFile(hFile, &FileHeader, sizeof(BITMAPFILEHEADER), &dwBytes, NULL);

            // Create bitmap header and write it to file.
            BitmapHeader.bV5Size = sizeof(BITMAPV5HEADER);
            BitmapHeader.bV5Width = BITMAPWIDTH(pBitmapInfo);
            BitmapHeader.bV5Height = BITMAPHEIGHT(pBitmapInfo);
            BitmapHeader.bV5Planes = 1;
            BitmapHeader.bV5BitCount = (WORD) BITCOUNT(pBitmapInfo);
            BitmapHeader.bV5Compression = BITMAPCOMPRESSION(pBitmapInfo);
            BitmapHeader.bV5SizeImage = BITMAPIMAGESIZE(pBitmapInfo);
            BitmapHeader.bV5ClrUsed = BITMAPCLRUSED(pBitmapInfo);
            BitmapHeader.bV5ClrImportant = BITMAPCLRIMPORTANT(pBitmapInfo);
            BitmapHeader.bV5RedMask = BITMAPREDMASK(pBitmapInfo);
            BitmapHeader.bV5GreenMask = BITMAPGREENMASK(pBitmapInfo);
            BitmapHeader.bV5BlueMask = BITMAPBLUEMASK(pBitmapInfo);
            BitmapHeader.bV5CSType = dwType;
            if (sizeof(BITMAPV4HEADER) <= *(LPDWORD)pBitmapInfo)
            {
                memcpy(&BitmapHeader.bV5Endpoints, &((PBITMAPV4HEADER)pBitmapInfo)->bV4Endpoints,
                       sizeof(CIEXYZTRIPLE) + sizeof(DWORD) * 3);
            }
            BitmapHeader.bV5Intent = BITMAPINTENT(pBitmapInfo);
            BitmapHeader.bV5ProfileData = sizeof(BITMAPV5HEADER);
            BitmapHeader.bV5ProfileData += NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD);
            BitmapHeader.bV5ProfileData += BITMAPSIZE(pBitmapInfo);
            BitmapHeader.bV5ProfileSize = dwProfileSize;
            WriteFile(hFile, &BitmapHeader, sizeof(BITMAPV5HEADER), &dwBytes, NULL);

            // Write color table.
            if (!IS_BITMAPCOREHEADER(pBitmapInfo))
            {
                PBYTE   pColorTable;
                DWORD   dwColorTableSize;

                dwColorTableSize = NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD);
                pColorTable = (PBYTE)pBitmapInfo + *(LPDWORD)pBitmapInfo;
                if ( IS_BITMAPINFOHEADER(pBitmapInfo)
                     &&
                     (BI_BITFIELDS == BITMAPCOMPRESSION(pBitmapInfo))
                   )
                {
                    dwColorTableSize += sizeof(DWORD) * 3;
                }

                WriteFile(hFile, pColorTable, dwColorTableSize, &dwBytes, NULL);
            }
            else
            {
                PBYTE   pColorTable;
                DWORD   dwCount;
                RGBQUAD ColorTable[256];


                pColorTable = (PBYTE)pBitmapInfo + *(LPDWORD)pBitmapInfo;
                memset(ColorTable, 0, sizeof(ColorTable));
                for (dwCount = 0; dwCount < NumColorsInDIB(pBitmapInfo); dwCount++)
                    memcpy(ColorTable + dwCount, pColorTable + dwCount, sizeof(RGBTRIPLE));

                WriteFile(hFile, ColorTable, NumColorsInDIB(pBitmapInfo) * sizeof(RGBQUAD), &dwBytes, NULL);
            }

            // Save bitmap data.
            WriteFile(hFile, FindDIBBits(pBitmapInfo), BITMAPSIZE(pBitmapInfo), &dwBytes, NULL);

            // Save profile data.
            if (0 != dwProfileSize)
            {
                WriteFile(hFile, pProfileData, dwProfileSize, &dwBytes, NULL);
            }

            bResult = TRUE;
        }

        // Clean up.
        CloseHandle(hFile);
        if (NULL != lpszProfileName)
            GlobalFree((HANDLE)lpszProfileName);
        if (NULL != hDIBTransformed)
        {
            GlobalUnlock(hDIBTransformed);
            GlobalFree(hDIBTransformed);
        }

        // If failed, delete file.
        if (!bResult)
            DeleteFile(lpszFileName);
    }

    //Clean up.
    GlobalUnlock(lpDIBInfo->hDIB);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\dialogs.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DIALOGS.C
//
//  DESCRIPTION:
//
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS:
//

//
// Pre-processor directives
//

#define REGISTRY_CURRENT_DISPLAY "System\\CurrentControlSet\\Services\\Class\\DISPLAY\\0000"
#define TOGGLE_BOOLEAN(b) b=!b

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include <commdlg.h>
#include <commctrl.h>
#include "icm.h"

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings
#pragma warning(default:4514)   // Unreferenced inline function has been removed

// C-runtime header files
#include <TCHAR.H>
#include <stdlib.h>

// Local header files
#include "icmview.h"
#include "resource.h"
#include "DibInfo.H"
#include "Dialogs.h"
#include "CDErr.h"
#include "print.h"
#include "child.h"
#include "Dibs.H"
#include "AppInit.h"
#include "Debug.h"

// Private structures/typedefs
typedef struct tagDIBPROPSHEETINFO
{
    UINT            uiPageNum;          // Page number of propsheet
    HGLOBAL         hDIBInfo;           // Handle to DIBINFO structure
} DIBPROPSHEETINFO, *LPDIBPROPSHEETINFO;

// Private function prototypes
void            ProcessCDError(DWORD dwErrorCode, HWND hWnd);
int CALLBACK    EnumICMProfileCallback(LPCTSTR lpszFileName, LPARAM lParam);
LPTSTR          GetOpenImageName(HWND hWnd , PBOOL pbUserCancel);
void            DlgDIBInfoPaint(HWND  hDlg, LPDIBINFO lpDIBInfo);
BOOL            SaveDIBInfoDlgPage(HWND hDlg, LPDIBINFO lpDIBInfo, UINT uiPageNum);
LPTSTR          GetDlgItemString(HWND hDlg, int iControlId, LPTSTR lpszCurrentString);
DWORD           SetColorMatchUIFlags(DWORD dwDIFlags);
BOOL WINAPI     ColorSetupApply(PCOLORMATCHSETUP pcmSetup, LPARAM lParam);
VOID            ApplyColorSettings(LPDIBINFO lpDIBInfo, PCOLORMATCHSETUP pCMSetup);
BOOL CALLBACK PrintDialogProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Global external variables

// Global private variables
//UINT  guiNumProfiles = 0;
BOOL  gbOpenCanceled;


/////////////////////////////////////////////////////////////////////////////
//
//   FUNCTION: ProcessCDError(DWORD)
//
//   PURPOSE:  Processes errors from the common dialog functions.
//
//   COMMENTS:
//
//       This function is called whenever a common dialog function
//       fails.  The CommonDialogExtendedError() value is passed to
//       the function which maps the error value to a string table.
//       The string is loaded and displayed for the user.
//
//   RETURN VALUES:
//       void.
//
/////////////////////////////////////////////////////////////////////////////
void ProcessCDError(DWORD dwErrorCode, HWND hWnd)
{
    WORD  wStringID;
    TCHAR  buf[256];

    switch (dwErrorCode)
    {
        case CDERR_DIALOGFAILURE:   wStringID=IDS_DIALOGFAILURE;   break;
        case CDERR_STRUCTSIZE:      wStringID=IDS_STRUCTSIZE;      break;
        case CDERR_INITIALIZATION:  wStringID=IDS_INITIALIZATION;  break;
        case CDERR_NOTEMPLATE:      wStringID=IDS_NOTEMPLATE;      break;
        case CDERR_NOHINSTANCE:     wStringID=IDS_NOHINSTANCE;     break;
        case CDERR_LOADSTRFAILURE:  wStringID=IDS_LOADSTRFAILURE;  break;
        case CDERR_FINDRESFAILURE:  wStringID=IDS_FINDRESFAILURE;  break;
        case CDERR_LOADRESFAILURE:  wStringID=IDS_LOADRESFAILURE;  break;
        case CDERR_LOCKRESFAILURE:  wStringID=IDS_LOCKRESFAILURE;  break;
        case CDERR_MEMALLOCFAILURE: wStringID=IDS_MEMALLOCFAILURE; break;
        case CDERR_MEMLOCKFAILURE:  wStringID=IDS_MEMLOCKFAILURE;  break;
        case CDERR_NOHOOK:          wStringID=IDS_NOHOOK;          break;
        case PDERR_SETUPFAILURE:    wStringID=IDS_SETUPFAILURE;    break;
        case PDERR_PARSEFAILURE:    wStringID=IDS_PARSEFAILURE;    break;
        case PDERR_RETDEFFAILURE:   wStringID=IDS_RETDEFFAILURE;   break;
        case PDERR_LOADDRVFAILURE:  wStringID=IDS_LOADDRVFAILURE;  break;
        case PDERR_GETDEVMODEFAIL:  wStringID=IDS_GETDEVMODEFAIL;  break;
        case PDERR_INITFAILURE:     wStringID=IDS_INITFAILURE;     break;
        case PDERR_NODEVICES:       wStringID=IDS_NODEVICES;       break;
        case PDERR_NODEFAULTPRN:    wStringID=IDS_NODEFAULTPRN;    break;
        case PDERR_DNDMMISMATCH:    wStringID=IDS_DNDMMISMATCH;    break;
        case PDERR_CREATEICFAILURE: wStringID=IDS_CREATEICFAILURE; break;
        case PDERR_PRINTERNOTFOUND: wStringID=IDS_PRINTERNOTFOUND; break;
        case CFERR_NOFONTS:         wStringID=IDS_NOFONTS;         break;
        case FNERR_SUBCLASSFAILURE: wStringID=IDS_SUBCLASSFAILURE; break;
        case FNERR_INVALIDFILENAME: wStringID=IDS_INVALIDFILENAME; break;
        case FNERR_BUFFERTOOSMALL:  wStringID=IDS_BUFFERTOOSMALL;  break;

        case 0:   //User may have hit CANCEL or we got a *very* random error
            return;

        default:
            wStringID=IDS_UNKNOWNERROR;
    }

    LoadString(NULL, wStringID, buf, sizeof(buf));
    MessageBox(hWnd, buf, NULL, MB_OK);
    return;
}


//////////////////////////////////////////////////////////////////////////
//  Function:  GetOpenImageName
//
//  Description:
//    Invokes common dialog function to open a file and opens it, returning
//    the LPHANDLE to the opened file (NULL if failure) and setting the
//    LPTSTR parameter to the FULLY QUALIFIED name of the file which was opened.
//    If the user cancels out of the dialog, the bUserCancelled variable is
//    set to TRUE, allowing the calling function to discriminate between this
//    action and an actual failure of the open dialog calls.
//
//  Parameters:
//    HWND      Handle to the associated window
//    *BOOL     Indicates if user cancelled out of dialog.
//
//  Returns:
//    LPTSTR     Pointer to the buffer to hold the filename.
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

LPTSTR GetOpenImageName(HWND hWnd , PBOOL pbUserCancel)
{
    // Local variables
    OPENFILENAME    OpenFileName;   // Structure for common dialog File/Open
    TCHAR           szFilter[]=__TEXT("Images(*.BMP,*.DIB)\0*.BMP;*.DIB\0All Files(*.*)\0*.*\0\0");
    TCHAR           szFile[MAX_PATH];
    LPTSTR          lpszFileName;

    // Initialize variables
    szFile[0] = __TEXT('\0');
    OpenFileName.lStructSize       = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner         = hWnd;
    OpenFileName.hInstance         = (HANDLE) ghInst;
    OpenFileName.lpstrFilter       = szFilter;
    OpenFileName.lpstrCustomFilter = (LPTSTR) NULL;
    OpenFileName.nMaxCustFilter    = 0L;
    OpenFileName.nFilterIndex      = 1L;
    OpenFileName.lpstrFile         = szFile;
    OpenFileName.nMaxFile          = sizeof(szFile);
    OpenFileName.lpstrFileTitle    = NULL;
    OpenFileName.nMaxFileTitle     = 0;
    OpenFileName.lpstrInitialDir   = NULL;
    OpenFileName.lpstrTitle        = __TEXT("ICMVIEW:  Open Image");
    OpenFileName.nFileOffset       = 0;
    OpenFileName.nFileExtension    = 0;
    OpenFileName.lpstrDefExt       = NULL;  // No default extension
    OpenFileName.lCustData         = 0;

    OpenFileName.Flags = OFN_SHOWHELP | OFN_PATHMUSTEXIST |
                         OFN_FILEMUSTEXIST | OFN_HIDEREADONLY |
                         OFN_EXPLORER | OFN_LONGNAMES;

    if (GetOpenFileName(&OpenFileName))
    {
        *pbUserCancel = FALSE;
        // We have a valid filename, let's copy it into the buffer
        lpszFileName = GlobalAlloc(GPTR, (lstrlen(OpenFileName.lpstrFile)+1));
        if (NULL == lpszFileName)
        {
            return(NULL);
        }
        _tcscpy(lpszFileName,OpenFileName.lpstrFile);
    }
    else // User didn't select a file
    {
        *pbUserCancel = TRUE;
        ProcessCDError(CommDlgExtendedError(), hWnd );
        return (NULL);
    }
    return(lpszFileName);
}   // End of GetOpenImageName


//////////////////////////////////////////////////////////////////////////
//  Function:  fOpenNewImage
//
//  Description:
//    Performs all tasks associated with opening a new file.  This includes
//    creating the File Open common dialog, and if a file was successfully
//    opened, creating a new thread and window to handle the selected image.
//
//  Parameters:
//    HWND    Handle to associated window.
//
//  Returns:
//    BOOL    Indicates if a file was successfully opened.
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////

BOOL fOpenNewImage(HWND hWnd, LPTSTR lpszFileName, int wmCommand)
{
    // Local variables
    BOOL        bUserCancelled;   // TRUE if user cancels open dialog
    HGLOBAL     hDIBInfo, hMem;
    BOOL        bRC;
    HCURSOR     hCur;

    switch (wmCommand)
    {
    case IDM_FILE_PASTE_CLIPBOARD_DIB:
    case IDM_FILE_PASTE_CLIPBOARD_DIBV5:

        hDIBInfo = PasteDIBData(hWnd,wmCommand);
        break;

    default:

        // If lpszFileName is NULL, get file name from user.
        if (NULL == lpszFileName)
        {
            lpszFileName = GetOpenImageName(hWnd, &bUserCancelled);
            if (lpszFileName == NULL)
            {
                if (!bUserCancelled)
                {
                    ErrMsg(hWnd, __TEXT("fOpenNewImage:  lpszFileName == NULL"));
                }
                return(FALSE);
            }
        }

        START_WAIT_CURSOR(hCur);
        hDIBInfo = ReadDIBFile(lpszFileName);
        if (hDIBInfo)
        {
            // Add file to recent files list.
            AddRecentFile(hWnd, lpszFileName);
        }
        else
        {
            ErrMsg(hWnd, __TEXT("Unable to open file %s"), lpszFileName);
        }
        END_WAIT_CURSOR(hCur);
        break;
    }

    if (hDIBInfo)
    {
        LPDIBINFO lpDIBInfo, lpGlobalDIBInfo;

        // Copy ICM information from global LPDIBINFO
        lpDIBInfo = GlobalLock(hDIBInfo);
        lpGlobalDIBInfo = GetDIBInfoPtr(ghAppWnd);
        fDuplicateICMInfo(lpDIBInfo, lpGlobalDIBInfo);

        // Now copy default options
        lpDIBInfo->bStretch          = lpGlobalDIBInfo->bStretch;
        lpDIBInfo->dwStretchBltMode  = lpGlobalDIBInfo->dwStretchBltMode;
        lpDIBInfo->dwPrintOption     = lpGlobalDIBInfo->dwPrintOption;

        CreateNewImageWindow(hDIBInfo);
        GlobalUnlock(GlobalHandle(lpGlobalDIBInfo));
        GlobalUnlock(GlobalHandle(lpDIBInfo));
        bRC = TRUE;
    }
    else
    {
        bRC = (FALSE);
    }

    hMem = GlobalHandle(lpszFileName);
    GlobalFree(hMem);
    return(bRC);
}   // End of fOpenNewImage

//////////////////////////////////////////////////////////////////////////
//  Function:  CreateDIBPropSheet
//
//  Description:
//    Creates the property sheet used to describe a DIB.
//
//  Parameters:
//    HWND        Handle to the window which owns the property sheet
//    HINSTANCE   Instance handle
//
//  Returns:
//    int   Return value from the call to Win32 API PropertySheet
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////
int CreateDIBPropSheet(HWND hwndOwner, HINSTANCE hInst, int nStartPage, LPTSTR lpszCaption)
{
    // Local variables
    PROPSHEETPAGE     PropSheetPage[(DIB_PROPSHEET_MAX+1)];
    PROPSHEETHEADER   PropSheetHdr;
    DIBPROPSHEETINFO  DIBPropSheetInfo[(DIB_PROPSHEET_MAX+1)];
    int               iPropSheet;  // Return code for PropertySheet call

    // Initialize vars
    SetLastError(0);
    ASSERT((DIB_PROPSHEET_MIN <= nStartPage) && (DIB_PROPSHEET_MAX >= nStartPage));
    if ((DIB_PROPSHEET_MIN > nStartPage) && (DIB_PROPSHEET_MAX < nStartPage))
    {
        nStartPage = DIB_PROPSHEET_DEFAULT;
    }

    // Initialize PROPERTYSHEETHEADER
    PropSheetHdr.dwSize = sizeof(PROPSHEETHEADER);
    PropSheetHdr.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    PropSheetHdr.hwndParent = hwndOwner;
    PropSheetHdr.hInstance = hInst;
    PropSheetHdr.pszIcon = NULL;
    PropSheetHdr.pszCaption = lpszCaption;
    PropSheetHdr.nPages = sizeof(PropSheetPage) / sizeof(PROPSHEETPAGE);
    PropSheetHdr.ppsp = (LPCPROPSHEETPAGE)&PropSheetPage;
    PropSheetHdr.nStartPage = nStartPage;

    // Initialize DIB Display Property Sheet
    PropSheetPage[0].dwSize = sizeof(PROPSHEETPAGE);
    PropSheetPage[0].dwFlags = PSP_USETITLE;
    PropSheetPage[0].hInstance = hInst;
    PropSheetPage[0].pszTemplate = MAKEINTRESOURCE(IDD_DISPLAY);
    PropSheetPage[0].pszIcon = NULL;
    PropSheetPage[0].pfnDlgProc = DlgDIBPropSheet;
    PropSheetPage[0].pszTitle = __TEXT("Display");
    DIBPropSheetInfo[0].uiPageNum = DIB_PROPSHEET_DISPLAY;
    DIBPropSheetInfo[0].hDIBInfo = GetDIBInfoHandle(hwndOwner);
    PropSheetPage[0].lParam = (LPARAM)(LPDIBPROPSHEETINFO)&DIBPropSheetInfo[0];

    // Initialize DIB Print Property Sheet
    PropSheetPage[1].dwSize = sizeof(PROPSHEETPAGE);
    PropSheetPage[1].dwFlags = PSP_USETITLE;
    PropSheetPage[1].hInstance = hInst;
    PropSheetPage[1].pszTemplate = MAKEINTRESOURCE(IDD_PRINT);
    PropSheetPage[1].pszIcon = NULL;
    PropSheetPage[1].pfnDlgProc = DlgDIBPropSheet;
    PropSheetPage[1].pszTitle = __TEXT("Printer");
    DIBPropSheetInfo[1].uiPageNum = DIB_PROPSHEET_PRINT;
    DIBPropSheetInfo[1].hDIBInfo = GetDIBInfoHandle(hwndOwner);
    PropSheetPage[1].lParam = (LPARAM)(LPDIBPROPSHEETINFO)&DIBPropSheetInfo[1];

    // Create the property sheet and return
    iPropSheet = PropertySheet(&PropSheetHdr);
    return(iPropSheet);
} // End of function CreateDIBPropSheet


//////////////////////////////////////////////////////////////////////////
//  Function:  DlgDIBPropSheet
//
//  Description:
//    Routine to handle the DIB Display properties property sheet.
//
//  Parameters:
//    @@@
//
//  Returns:
//    @@@
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////
BOOL APIENTRY DlgDIBPropSheet(HWND hwndPSPage, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    // Local variables
    HGLOBAL           hDIBInfo;
    LPDIBINFO         lpDIBInfo;
    static  UINT      uiPageNum = (UINT)UNINIT_DWORD;
    static  LPDIBINFO lpTempDIBInfo = NULL;
    static  HWND      hwndOwner = NULL;
    static  HWND      hwndPSPagePropSheet = NULL;
    HDC     hDC;
    LPTSTR   lpszInitialProfile;
    LPDIBPROPSHEETINFO  lpDIBPropSheetInfo;

    // Init variables
    hDC = NULL;
    lpszInitialProfile = NULL;
    switch (uiMsg)
    {
        case WM_INITDIALOG:
            // Save the page number associated w/this page
            lpDIBPropSheetInfo = (LPDIBPROPSHEETINFO) ((LPPROPSHEETPAGE)lParam)->lParam;
            uiPageNum = lpDIBPropSheetInfo->uiPageNum;
            ASSERT(uiPageNum >= DIB_PROPSHEET_MIN && uiPageNum <= DIB_PROPSHEET_MAX);
            SetWindowLong(hwndPSPage, GWL_ID, uiPageNum);
            hDIBInfo = lpDIBPropSheetInfo->hDIBInfo;
            lpDIBInfo = GlobalLock(hDIBInfo);
            hwndOwner = lpDIBInfo->hWndOwner;
            lpTempDIBInfo = fDuplicateDIBInfo(lpTempDIBInfo, lpDIBInfo);

            if (uiPageNum == DIB_PROPSHEET_DISPLAY)
            {
                ASSERT(lpDIBInfo);

                // Copy the DIBINFO structure for the image to a temporary DIBINFO
                // structure.  If the user presses "OK" or "Accept" to close the
                // property sheet, the temporary DIBINFO will be copied back into the
                // image's DIBINFO to reflect any possible changes.
                ASSERT(lpTempDIBInfo);
                lpszInitialProfile = lpTempDIBInfo->lpszMonitorProfile;
            }
            else if (uiPageNum == DIB_PROPSHEET_PRINT)
            {
                lpszInitialProfile = lpTempDIBInfo->lpszPrinterProfile;
            }

            GlobalUnlock(hDIBInfo);
            break;

        case WM_DESTROY:
            ASSERT(NULL != hwndOwner);
            if (NULL != hwndOwner)
            {
                InvalidateRect(      hwndOwner,       NULL,       FALSE);
            }
            if (lpTempDIBInfo)
            {
                fFreeDIBInfo(GlobalHandle(lpTempDIBInfo), FALSE);
            }
            lpTempDIBInfo = NULL;
            break;

        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code)  // type of notification message
            {
                case PSN_SETACTIVE:
                    // Initialize the controls
                    uiPageNum = GetWindowLong(hwndPSPage,GWL_ID);
                    if (uiPageNum == DIB_PROPSHEET_PRINT)
                    {
                        PopulatePrinterCombobox(hwndPSPage, IDC_PRINT_PRINTERLIST, lpTempDIBInfo->lpszPrinterName);
                    }

                    // Update the dialog based upon the contents of lpDIBInfo
                    DlgDIBInfoPaint(hwndPSPage, lpTempDIBInfo);
                    SetDlgMsgResult(hwndPSPage, uiMsg, FALSE);
                    break;

                case PSN_KILLACTIVE:
                    SaveDIBInfoDlgPage(hwndPSPage, lpTempDIBInfo, uiPageNum);
                    SetDlgMsgResult(hwndPSPage, uiMsg, FALSE);
                    break;

                case PSN_APPLY:
                    lpDIBInfo = GetDIBInfoPtr(hwndOwner);
                    if (NULL == fDuplicateDIBInfo(lpDIBInfo, lpTempDIBInfo ))
                    {
                        ErrMsg(hwndPSPage, __TEXT("fDuplicateDIBInfo:  Failed to copy DIBINFO"));
                    }
                    ASSERT(lpDIBInfo != NULL);
                    GlobalUnlock(GlobalHandle(lpDIBInfo));
                    SetDlgMsgResult(hwndPSPage, uiMsg, PSNRET_NOERROR);
                    break;

                case PSN_RESET:
                    fFreeDIBInfo(lpTempDIBInfo, FALSE);
                    lpTempDIBInfo = NULL;
                    SetDlgMsgResult(hwndPSPage, uiMsg, FALSE);
                    break;

                default:
                    break;
            }

        case WM_COMMAND:
            {
                switch (LOWORD(wParam))
                {
                    case IDC_DISPLAY_STRETCH:
                        {
                            BOOL  bChecked;

                            bChecked = IsDlgButtonChecked(hwndPSPage, IDC_DISPLAY_STRETCH);
                            EnableWindow(GetDlgItem(hwndPSPage, IDC_DISPLAY_ANDSCAN), bChecked);
                            EnableWindow(GetDlgItem(hwndPSPage, IDC_DISPLAY_DELETESCAN), bChecked);
                            EnableWindow(GetDlgItem(hwndPSPage, IDC_DISPLAY_ORSCAN), bChecked);
                        }
                        break;

                    case IDC_PRINT_IMAGE:
                        {
                            HCURSOR hCur;
                            HGLOBAL hDIBInfo, hTempDIBInfo;

                            START_WAIT_CURSOR(hCur);
                            hDIBInfo = GetDIBInfoHandle(hwndOwner);
                            SaveDIBInfoDlgPage(hwndPSPage, lpTempDIBInfo, uiPageNum);

                            // Use current settings
                            hTempDIBInfo = GlobalHandle(lpTempDIBInfo);
                            SetWindowLong(hwndOwner, GWL_DIBINFO, (LONG)hTempDIBInfo);

                            PrintImage(hwndOwner);

                            //Restore settings
                            SetWindowLong(hwndOwner, GWL_DIBINFO, (LONG)hDIBInfo);
                            END_WAIT_CURSOR(hCur);
                        }
                        break;

                    default:
                        break;
                }

            }
        default:
            break;
    }
    return(FALSE);  // FALSE means let the system property sheet code take over
} // End of function DlgDIBPropSheet


//////////////////////////////////////////////////////////////////////////
//  Function:  DlgDIBInfoPaint
//
//  Description:
//    Update the dialog based upon the contents of lpDIBInfo.  This includes
//    determining which property sheet page is visible, and using this
//    information to populate the device profile ComboBox for the proper
//    device type.
//
//  Parameters:
//    HWND      Handle to the dialog.
//    LPDIBINFO Pointer to DIBINFO structure.
//    LPICMINFO Pointer to ICMINFO structure.
//
//  Returns:
//    void
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////
void DlgDIBInfoPaint(HWND  hDlg, LPDIBINFO lpDIBInfo)
{
    // Local variables
    UINT    uiPageNum;        // ID's which property sheet page is visible


    // Initialize variables
    ASSERT(lpDIBInfo != NULL);
    uiPageNum = GetWindowLong(hDlg, GWL_ID);
    ASSERT(uiPageNum <= DIB_PROPSHEET_MAX);

    // Update the page-specific elements first
    switch (uiPageNum)
    {
        case DIB_PROPSHEET_DISPLAY:

            // Display the display method information
            CheckDlgButton(hDlg, IDC_DISPLAY_STRETCH, lpDIBInfo->bStretch);
            CheckDlgButton(hDlg, IDC_DISPLAY_DIBSECTION, lpDIBInfo->bDIBSection);

            // Enable/Disable stretch mode buttons
            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ANDSCAN), lpDIBInfo->bStretch);
            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_DELETESCAN), lpDIBInfo->bStretch);
            EnableWindow(GetDlgItem(hDlg, IDC_DISPLAY_ORSCAN), lpDIBInfo->bStretch);

            // Select stretch mode if necessary
            ASSERT(lpDIBInfo->dwStretchBltMode >= STRETCH_ANDSCANS);
            ASSERT(lpDIBInfo->dwStretchBltMode <= STRETCH_DELETESCANS);
            switch ((int)(lpDIBInfo->dwStretchBltMode))
            {
                case STRETCH_ANDSCANS:
                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_ANDSCAN);
                    break;
                case STRETCH_DELETESCANS:
                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_DELETESCAN);
                    break;
                case STRETCH_ORSCANS:
                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_ORSCAN);
                    break;
                default:
                    CheckRadioButton(hDlg, IDC_DISPLAY_ANDSCAN, IDC_DISPLAY_ORSCAN, IDC_DISPLAY_ANDSCAN);
            }
            break;


        case DIB_PROPSHEET_PRINT:
            // Select print size
            {
                int iPrintSize = IDC_PRINT_BESTFIT;

                if (lpDIBInfo->dwPrintOption == ICMV_PRINT_ACTUALSIZE)
                {
                    iPrintSize = IDC_PRINT_ACTUALSIZE;
                }
                CheckRadioButton(hDlg, IDC_PRINT_ACTUALSIZE, IDC_PRINT_BESTFIT, iPrintSize);
            }
            break;

        default:
            break;
    }

} // End of function DlgDIBInfoPaint


//////////////////////////////////////////////////////////////////////////
//  Function:  SaveDIBInfoDlgPage
//
//  Description:
//    Saves the current page of the property sheet to the specified DIBINFO structure.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL  TRUE upon success, FALSE otherwise
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL SaveDIBInfoDlgPage(HWND hDlg, LPDIBINFO lpDIBInfo, UINT uiPageNum)
{
    switch (uiPageNum)
    {
        case DIB_PROPSHEET_DISPLAY:
            lpDIBInfo->bStretch = IsDlgButtonChecked(hDlg, IDC_DISPLAY_STRETCH);
            if (IsDlgButtonChecked(hDlg, IDC_DISPLAY_ANDSCAN))
                lpDIBInfo->dwStretchBltMode = STRETCH_ANDSCANS;
            else if (IsDlgButtonChecked(hDlg, IDC_DISPLAY_DELETESCAN))
                lpDIBInfo->dwStretchBltMode = STRETCH_DELETESCANS;
            else if (IsDlgButtonChecked(hDlg, IDC_DISPLAY_ORSCAN))
                lpDIBInfo->dwStretchBltMode = STRETCH_ORSCANS;

            lpDIBInfo->bDIBSection = IsDlgButtonChecked(hDlg, IDC_DISPLAY_DIBSECTION);

            if (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20))
            {
                SetDWFlags((LPDWORD)&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE);
            }
            break;

        case DIB_PROPSHEET_PRINT:
            {
                LPTSTR  pszTemp;


                pszTemp = GetDlgItemString(hDlg, IDC_PRINT_PRINTERLIST, NULL);
                if ( (NULL != pszTemp)
                     &&
                     (_tcscmp(pszTemp, __TEXT("No printers installed")))
                   )
                {
                    if (lstrcmpi(pszTemp, lpDIBInfo->lpszPrinterName))
                    {
                        HDC     hPrinterDC;
                        TCHAR   szProfile[MAX_PATH];
                        DWORD   dwSize = MAX_PATH;


                        GlobalFree(lpDIBInfo->lpszPrinterName);
                        lpDIBInfo->lpszPrinterName = pszTemp;
                        if (NULL != lpDIBInfo->pDevMode)
                            GlobalFree(GlobalHandle(lpDIBInfo->pDevMode));
                        lpDIBInfo->pDevMode = GetDefaultPrinterDevMode(lpDIBInfo->lpszPrinterName);

                        hPrinterDC = CreateDC(NULL, lpDIBInfo->lpszPrinterName, NULL, lpDIBInfo->pDevMode);
                        if (NULL != hPrinterDC)
                        {
                            if (GetICMProfile(hPrinterDC, &dwSize, szProfile))
                                UpdateString(&lpDIBInfo->lpszPrinterProfile, szProfile);
                            DeleteDC(hPrinterDC);
                        }
                    }
                }
                else
                {
                    if (NULL != lpDIBInfo->lpszPrinterName)
                    {
                        GlobalFree(lpDIBInfo->lpszPrinterName);
                        lpDIBInfo->lpszPrinterName = NULL;
                    }

                    if (NULL != pszTemp)
                    {
                        GlobalFree(pszTemp);
                    }
                }

                if (IsDlgButtonChecked(hDlg, IDC_PRINT_ACTUALSIZE))
                {
                    lpDIBInfo->dwPrintOption = ICMV_PRINT_ACTUALSIZE;
                }
                else
                {
                    lpDIBInfo->dwPrintOption = ICMV_PRINT_BESTFIT;
                }
            }
            break;

        default:
            DebugMsg(__TEXT("DIALOGS.C : SaveDIBInfoDlgPage : Invalid uiPageNum\r\n"));
            return(FALSE);
            break;
    }
    return(TRUE);
}   // End of function SaveDIBInfoDlgPage


//////////////////////////////////////////////////////////////////////////
//  Function:  GetDlgItemString
//
//  Description:
//    If the specified control identifier text differs from the string
//    passed in, the string will be reallocated to the proper size and
//    the currently displayed item will be copied into the string.
//
//  Parameters:
//    @@@
//
//  Returns:
//    LPTSTR
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPTSTR GetDlgItemString(HWND hDlg, int iControlId, LPTSTR lpszCurrentString)
{
    // Local variables
    TCHAR    szEditString[MAX_PATH + 1];

    //  Initialize variables
    if (lpszCurrentString == NULL)
    {
        lpszCurrentString = GlobalAlloc(GPTR, sizeof(TCHAR));
        _tcscpy(lpszCurrentString, __TEXT(""));
    }

    GetDlgItemText(hDlg, iControlId, szEditString, MAX_PATH);
    {
        if (_tcscmp(szEditString, lpszCurrentString) != 0)
        {
            // Edit control differs from current string
            HGLOBAL hNewString, hCurrentString;

            hCurrentString = GlobalHandle(lpszCurrentString);
            GlobalUnlock(hCurrentString);
            hNewString = GlobalReAlloc(hCurrentString, (lstrlen(szEditString)+1) *sizeof(TCHAR), GMEM_MOVEABLE);
            lpszCurrentString = GlobalLock(hNewString);

            _tcscpy(lpszCurrentString, szEditString);
        }
    }
    return(lpszCurrentString);
}   // End of function GetDlgItemString


//////////////////////////////////////////////////////////////////////////
//  Function:  ColorMatchUI
//
//  Description:
//    Fills in COLORMATCHSETUP structure and calls SetupColorMatching, the new ICM 2.0 UI.
//
//  Parameters:
//    HWND  Owner window; NULL if dialog to have no owner.
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////

BOOL ColorMatchUI(HWND hwndOwner, LPVOID lpvDIBInfo)
{
    // Local variables
    COLORMATCHSETUP     CMSetup;
    BOOL                bSetup;
    TCHAR               stPrinterProfile[MAX_PATH];
    TCHAR               stMonitorProfile[MAX_PATH];
    TCHAR               stTargetProfile[MAX_PATH];
    LPDIBINFO           lpDIBInfo;
    DWORD               dwICMFlags;
    LPBITMAPV5HEADER    lpbi;

    //  ASSERTs and parameter validations
    ASSERT((NULL != hwndOwner) && (NULL != lpvDIBInfo));
    if ((NULL == hwndOwner) || (NULL == lpvDIBInfo))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //  Initialize variables
#ifdef _DEBUG
    memset((PBYTE)&CMSetup, UNINIT_BYTE, sizeof(COLORMATCHSETUP));
#endif

    lpDIBInfo = (LPDIBINFO)lpvDIBInfo;
    dwICMFlags = lpDIBInfo->dwICMFlags;

    // Fill in required information
    // HACK for differnect versions of ICMUI.
    CMSetup.dwSize    = sizeof(COLORMATCHSETUP);
    CMSetup.dwVersion = COLOR_MATCH_VERSION;

    // Set ICM Flags
    CMSetup.dwFlags   = SetColorMatchUIFlags(lpDIBInfo->dwICMFlags) | CMS_USEAPPLYCALLBACK;
    CMSetup.hwndOwner = hwndOwner;

    // Fill in source name
    CMSetup.pSourceName   =  NULL;
    lpbi = (LPBITMAPV5HEADER)GlobalLock(lpDIBInfo->hDIB);
    if (IS_BITMAPV5HEADER(lpbi))
    {
        switch (lpbi->bV5CSType)
        {
            case PROFILE_LINKED:
                CMSetup.pSourceName = (LPCTSTR)GETPROFILEDATA(lpbi);
                break;

            case PROFILE_EMBEDDED:
                CMSetup.pSourceName = &(__TEXT("Embedded Profile"));
                break;

            default:
                break;
        }

    }
    GlobalUnlock(lpDIBInfo->hDIB);

    // Fill in device names
    CMSetup.pDisplayName  =  lpDIBInfo->lpszMonitorName;
    CMSetup.pPrinterName  =  lpDIBInfo->lpszPrinterName;

    // Fill in profile names.  Make local copies of the values within
    // the DIBINFO structure, as they may have been allocated to the
    // size of the actual strings.

    stPrinterProfile[0] = (TCHAR)'\0';
    if (lpDIBInfo->lpszPrinterProfile)
    {
        _tcscpy((LPTSTR)stPrinterProfile, lpDIBInfo->lpszPrinterProfile);
    }
    CMSetup.pPrinterProfile = (LPTSTR)&stPrinterProfile;
    CMSetup.ccPrinterProfile = MAX_PATH;

    stMonitorProfile[0] = (TCHAR)'\0';
    if (lpDIBInfo->lpszMonitorProfile)
    {
        _tcscpy((LPTSTR)stMonitorProfile, lpDIBInfo->lpszMonitorProfile);
    }
    CMSetup.pMonitorProfile = (LPTSTR)&stMonitorProfile;
    CMSetup.ccMonitorProfile = MAX_PATH;

    stTargetProfile[0] = (TCHAR)'\0';
    if (lpDIBInfo->lpszTargetProfile)
    {
        _tcscpy((LPTSTR)stTargetProfile, lpDIBInfo->lpszTargetProfile);
    }
    CMSetup.pTargetProfile = (LPTSTR)&stTargetProfile;
    CMSetup.ccTargetProfile = MAX_PATH;

    // Set up rendering intents
    CMSetup.dwRenderIntent = lpDIBInfo->dwRenderIntent;
    CMSetup.dwProofingIntent = lpDIBInfo->dwProofingIntent;

    // Set up for apply callback.
    CMSetup.lpfnApplyCallback = ColorSetupApply;
    CMSetup.lParamApplyCallback = (LPARAM) lpDIBInfo;

    // Clear unused items
    CMSetup.lpfnHook = NULL;
    CMSetup.lParam = (LPARAM)NULL;

    // Save ICM state before call
    dwICMFlags = lpDIBInfo->dwICMFlags;


    // Call the function to create the actual dialog
    SetLastError(0);
    bSetup = SetupColorMatching(&CMSetup);

    // Save information from dialog
    if (!bSetup)
    {
        if (ERROR_SUCCESS == GetLastError()) // User cancelled the dialog
        {
            return(TRUE);
        }
        else  // Something unexpected happened
        {
            DISPLAY_LASTERROR(LASTERROR_NOALLOC, GetLastError());
        }
    }

    ApplyColorSettings(lpDIBInfo, &CMSetup);

    return(bSetup);
} // End of function ColorMatchUI

//////////////////////////////////////////////////////////////////////////
//  Function:  SetColorMatchUIFlags
//
//  Description:
//    Function which converts a DIBINFO's dwFlags to a COLORMATCHSETUP flag.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
DWORD SetColorMatchUIFlags(DWORD dwDIFlags)
{
    // Local variables
    DWORD       dwCMFlags;      // COLORMATCHSETUP flags

    //  ASSERTs and parameter validations

    //  Initialize variables
    dwCMFlags = CMS_SETRENDERINTENT | CMS_SETPROOFINTENT | CMS_SETTARGETPROFILE
                | CMS_SETMONITORPROFILE | CMS_SETPRINTERPROFILE;

    if (!CHECK_DWFLAG(dwDIFlags, ICMVFLAGS_ENABLE_ICM))
    {
        dwCMFlags |= CMS_DISABLEICM;
    }

    if (CHECK_DWFLAG(dwDIFlags, ICMVFLAGS_PROOFING))
    {
        dwCMFlags |= CMS_ENABLEPROOFING;
    }
    return(dwCMFlags);
} // End of function SetColorMatchUIFlags


///////////////////////////////////////////////////////////////////////
//
// Function:   SaveDIBToFileDialog
//
// Purpose:    Gets file name and saves DIB to file.
//
// Parms:
//
///////////////////////////////////////////////////////////////////////

void SaveDIBToFileDialog(HWND hWnd, LPDIBINFO lpDIBInfo)
{
    TCHAR           szFileName[MAX_PATH];
    DWORD           dwSaveAs[3] = {LCS_sRGB, LCS_sRGB, LCS_sRGB};
    OPENFILENAME    OpenFileName;
    PBITMAPV5HEADER pBitmap;


    // Validate parameters.
    if (NULL == lpDIBInfo)
        return;

    // Save bitmap.
    pBitmap = (PBITMAPV5HEADER) GlobalLock(lpDIBInfo->hDIB);
    if (NULL != pBitmap)
    {
        // Initialize OPENFILENAME structure for getting save as file name.
        lstrcpy(szFileName, lpDIBInfo->lpszImageFileName);
        memset(&OpenFileName, 0, sizeof(OPENFILENAME));
        OpenFileName.lStructSize = sizeof(OPENFILENAME);
        OpenFileName.hwndOwner = hWnd;
        OpenFileName.lpstrFile = szFileName;
        OpenFileName.nMaxFile = MAX_PATH;
        OpenFileName.lpstrTitle = __TEXT("Save Bitmap As");
        OpenFileName.Flags = OFN_CREATEPROMPT | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
        OpenFileName.lpstrDefExt = __TEXT("bmp");

        if ( (sizeof(BITMAPINFOHEADER) < pBitmap->bV5Size)
             &&
             (LCS_CALIBRATED_RGB == pBitmap->bV5CSType)
           )
        {
            // INVARIANT:  Bitmap is a calibrated RGB bitmap.

            // Can save as sRGB or calibrated bitmap.
            OpenFileName.lpstrFilter = __TEXT("sRGB Bitmap (*.bmp)\0*.bmp\0Calibrated RGB Bitmap\0 (*.bmp)\0*.bmp\0");
            dwSaveAs[1] = LCS_CALIBRATED_RGB;
        }
        else if ( (sizeof(BITMAPINFOHEADER) < pBitmap->bV5Size)
                  &&
                  ( (PROFILE_LINKED == pBitmap->bV5CSType)
                    ||
                    (PROFILE_EMBEDDED == pBitmap->bV5CSType)
                  )
                )
        {
            // INVARIANT:  Bitmap is either a LINKed or MBEDed bitmap.

            // Can save as sRGB, linked or embeded,
            OpenFileName.lpstrFilter = __TEXT("sRGB Bitmap (*.bmp)\0*.bmp\0Linked Bitmap (*.bmp)\0*.bmp\0Embedded Bitmap (*.bmp)\0*.bmp\0\0");
            dwSaveAs[1] = PROFILE_LINKED;
            dwSaveAs[2] = PROFILE_EMBEDDED;
        }
        else
        {
            // Can only save as sRGB bitmap.
            OpenFileName.lpstrFilter = __TEXT("sRGB Bitmap (*.bmp)\0*.bmp\0\0");
        }

        // No longer need hDIB in this routine.
        GlobalUnlock(lpDIBInfo->hDIB);

        if (GetSaveFileName(&OpenFileName))
        {
            // INVARIANT:  User specified file and choice OK.

            // Save DIB.
            SaveDIBToFile(hWnd, OpenFileName.lpstrFile, lpDIBInfo, dwSaveAs[OpenFileName.nFilterIndex -1]);
        }

    }
} // End of function SaveDIBToFileDialog


///////////////////////////////////////////////////////////////////////
//
// Function:   GetProfileSaveName
//
// Purpose:    Gets file name to save profile to.
//
// Parms:
//
///////////////////////////////////////////////////////////////////////

BOOL GetProfileSaveName(HWND hWnd, LPSTR* ppszFileName, DWORD dwSize)
{
    OPENFILENAMEA   OpenFileName;


    // Initialize OPENFILENAME structure for getting save as file name.
    memset(&OpenFileName, 0, sizeof(OPENFILENAME));
    OpenFileName.lStructSize = sizeof(OPENFILENAME);
    OpenFileName.hwndOwner = hWnd;
    OpenFileName.lpstrFile = *ppszFileName;
    OpenFileName.nMaxFile = dwSize;
    OpenFileName.lpstrTitle = "Save Profile As";
    OpenFileName.Flags = OFN_CREATEPROMPT | OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
    OpenFileName.lpstrFilter = "ICC Color Profile (*.icm, *.icc)\0*.icm;*.icc\0\0";
    OpenFileName.lpstrDefExt = "icm";

    return GetSaveFileNameA(&OpenFileName);
}


///////////////////////////////////////////////////////////////////////
//
// Function:   ColorSetupApply
//
// Purpose:    Applies current color setup dialog values.
//
// Parms:
//
///////////////////////////////////////////////////////////////////////

BOOL WINAPI ColorSetupApply(PCOLORMATCHSETUP pcmSetup, LPARAM lParam)
{
    ApplyColorSettings((LPDIBINFO)lParam, pcmSetup);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////
//
// Function:   ApplyColorSettings
//
// Purpose:    Applies color settings to dib info.
//
// Parms:
//
///////////////////////////////////////////////////////////////////////

VOID ApplyColorSettings(LPDIBINFO lpDIBInfo, PCOLORMATCHSETUP pCMSetup)
{
    DWORD   dwICMFlags = lpDIBInfo->dwICMFlags;


    // Check if ICM and/or proofing is enabled
    SetDWFlags(&(lpDIBInfo->dwICMFlags), ICMVFLAGS_PROOFING, CHECK_DWFLAG(pCMSetup->dwFlags, CMS_ENABLEPROOFING));
    SetDWFlags(&(lpDIBInfo->dwICMFlags), ICMVFLAGS_ENABLE_ICM, (!CHECK_DWFLAG(pCMSetup->dwFlags, CMS_DISABLEICM)));
    if ((dwICMFlags != lpDIBInfo->dwICMFlags) && (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20)))
    {
        SetDWFlags(&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE);
    }

    // Update Intents
    if ((lpDIBInfo->dwRenderIntent != pCMSetup->dwRenderIntent) || (lpDIBInfo->dwProofingIntent != pCMSetup->dwProofingIntent))
    {
        SetDWFlags(&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE);
    }
    lpDIBInfo->dwRenderIntent = pCMSetup->dwRenderIntent;
    lpDIBInfo->dwProofingIntent = pCMSetup->dwProofingIntent;

    // Update DIBINFO profile strings if CMSetup strings have changed
    if (0 != _tcscmp(__TEXT(""), pCMSetup->pMonitorProfile))
    {
        UpdateString(&(lpDIBInfo->lpszMonitorProfile), pCMSetup->pMonitorProfile);
        SetDWFlags(&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE);
    }

    if (0 != _tcscmp(__TEXT(""), pCMSetup->pPrinterProfile))
    {
        UpdateString(&(lpDIBInfo->lpszPrinterProfile), pCMSetup->pPrinterProfile);
    }

    if (0 != _tcscmp(__TEXT(""), pCMSetup->pTargetProfile))
    {
        UpdateString(&(lpDIBInfo->lpszTargetProfile),  pCMSetup->pTargetProfile);
        SetDWFlags(&(lpDIBInfo->dwICMFlags), ICMVFLAGS_CREATE_TRANSFORM, TRUE);
    }

    InvalidateRect(lpDIBInfo->hWndOwner, NULL, FALSE);
}



//////////////////////////////////////////////////////////////////////////
//  Function:  PrintDialog
//
//  Description:
//    Displays printing dialog box.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL PrintDialog(HWND hWnd, HINSTANCE hInst, LPDIBINFO lpDIBInfo)
{
    PRINTDLG    Print;


    memset(&Print, 0, sizeof(PRINTDLG));
    Print.lStructSize = sizeof(PRINTDLG);
    Print.hwndOwner = hWnd;
    Print.hDevMode = GlobalHandle(lpDIBInfo->pDevMode);

    if (PrintDlg(&Print))
    {
        lpDIBInfo->pDevMode = (PDEVMODE) GlobalLock(Print.hDevMode);
        if (lstrcmpi(lpDIBInfo->lpszPrinterName, lpDIBInfo->pDevMode->dmDeviceName))
        {
            HDC     hPrinterDC;
            TCHAR   szProfile[MAX_PATH];
            DWORD   dwSize = MAX_PATH;


            UpdateString(&lpDIBInfo->lpszPrinterName, lpDIBInfo->pDevMode->dmDeviceName);
            hPrinterDC = CreateDC(NULL, lpDIBInfo->lpszPrinterName, NULL, lpDIBInfo->pDevMode);
            if (NULL != hPrinterDC)
            {
                if (GetICMProfile(hPrinterDC, &dwSize, szProfile))
                    UpdateString(&lpDIBInfo->lpszPrinterProfile, szProfile);
                DeleteDC(hPrinterDC);
            }
        }
        PrintImage(hWnd);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\dibs.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    DIBS.C
//
//  PURPOSE:
//    Include file for DIBS.H
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

#include <math.h>

//
// General pre-processor macros
//

// Calculates fixed poit from floating point.
#define __FXPTMANTISSA(d, f)  ( (DWORD)d << f )
#define __FXPTFRACTION(d, f)  ( (DWORD)ldexp((d - (DWORD)d), f) )
#define __FXPT32(d, f)      ( __FXPTMANTISSA(d, f) | __FXPTFRACTION(d, f) )

#define __FXPT2DOT30(d)   __FXPT32(d, 30)
#define __FXPT16DOT16(d)  __FXPT32(d, 16)

// Max number of color bits that will have a full color table.
#define MAX_BPP_COLOR_TABLE             8

// Macro to swap two values
#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y))

#define ABS(x)          (((x) >= 0) ? (x) : (-(x)))

#define PALVERSION      0x300
#define MAXPALETTE      256     // max. # supported palette entries

#define RECTWIDTH(lpRect)     ((lpRect)->right - (lpRect)->left)
#define RECTHEIGHT(lpRect)    ((lpRect)->bottom - (lpRect)->top)

// Header signatutes for various resources
#define BFT_BITMAP 0x4d42   // 'BM'

// Intent flag to indicate to use what ever the bitmap header intent is.
#define USE_BITMAP_INTENT       0xffffffff

// macro to determine if resource is a DIB
#define ISDIB(bft) ((bft) == BFT_BITMAP)

// Universial macros to find bitmap's width and height.
#define BITMAPWIDTH(lpbi)           (*(LPDWORD)lpbi >= sizeof(BITMAPINFOHEADER) ? lpbi->biWidth :  \
                                    ((LPBITMAPCOREHEADER)lpbi)->bcWidth)
#define BITMAPHEIGHT(lpbi)          (*(LPDWORD)lpbi >= sizeof(BITMAPINFOHEADER) ? lpbi->biHeight :  \
                                    ((LPBITMAPCOREHEADER)lpbi)->bcHeight)
#define BITMAPCOMPRESSION(lpbi)     (*(LPDWORD)lpbi >= sizeof(BITMAPINFOHEADER) ? lpbi->biCompression : BI_RGB)
#define BITMAPIMAGESIZE(lpbi)       (*(LPDWORD)lpbi >= sizeof(BITMAPINFOHEADER) ? lpbi->biSizeImage : 0)
#define BITMAPCSTYPE(lpbi)          (*(LPDWORD)lpbi >= sizeof(BITMAPV4HEADER) ? ((PBITMAPV4HEADER)lpbi)->bV4CSType : LCS_sRGB)
#define BITMAPCLRUSED(lpbi)         (*(LPDWORD)lpbi >= sizeof(BITMAPV4HEADER) ? ((PBITMAPV4HEADER)lpbi)->bV4ClrUsed : 0)
#define BITMAPCLRIMPORTANT(lpbi)    (*(LPDWORD)lpbi >= sizeof(BITMAPV4HEADER) ? ((PBITMAPV4HEADER)lpbi)->bV4ClrImportant : 0)
#define BITMAPREDMASK(lpbi)         ( (*(LPDWORD)lpbi >= sizeof(BITMAPV4HEADER)) || (BITMAPCOMPRESSION(lpbi) == BI_BITFIELDS) ?         \
                                    ((PBITMAPV4HEADER)lpbi)->bV4RedMask : 0)
#define BITMAPGREENMASK(lpbi)       ( (*(LPDWORD)lpbi >= sizeof(BITMAPV4HEADER)) || (BITMAPCOMPRESSION(lpbi) == BI_BITFIELDS) ?         \
                                    ((PBITMAPV4HEADER)lpbi)->bV4GreenMask : 0)
#define BITMAPBLUEMASK(lpbi)        ( (*(LPDWORD)lpbi >= sizeof(BITMAPV4HEADER)) || (BITMAPCOMPRESSION(lpbi) == BI_BITFIELDS) ?         \
                                    ((PBITMAPV4HEADER)lpbi)->bV4BlueMask : 0)
#define BITMAPINTENT(lpbi)          (*(LPDWORD)lpbi >= sizeof(BITMAPV5HEADER) ? ((PBITMAPV5HEADER)lpbi)->bV5Intent : LCS_GM_IMAGES)

// Macro to determine bitcount for all bitmap types.
#define BITCOUNT(lpbi)      (*(LPDWORD)lpbi >= sizeof(BITMAPINFOHEADER) ? ((LPBITMAPINFOHEADER)lpbi)->biBitCount :  \
                            ((LPBITMAPCOREHEADER)lpbi)->bcBitCount)

// Macro to determine to the DWORD aligned stride of a bitmap.
#define WIDTHBYTES(lpbi)   (((BITMAPWIDTH(lpbi) * BITCOUNT(lpbi) + 31) & ~31) >> 3)

// Macro to calculate size of bitmap.
#define BITMAPSIZE(lpbi)    ( 0 != BITMAPIMAGESIZE(lpbi) ? BITMAPIMAGESIZE(lpbi) : WIDTHBYTES(lpbi) * abs(BITMAPHEIGHT(lpbi)))

// Macros to query Bitmap header version
#define IS_BITMAPCOREHEADER(lpbi) (sizeof(BITMAPCOREHEADER) == *(LPDWORD)lpbi)
#define IS_BITMAPINFOHEADER(lpbi) (sizeof(BITMAPINFOHEADER) == *(LPDWORD)lpbi)
#define IS_BITMAPV4HEADER(lpbi)   (sizeof(BITMAPV4HEADER)   == *(LPDWORD)lpbi)
#define IS_BITMAPV5HEADER(lpbi)   (sizeof(BITMAPV5HEADER)   == *(LPDWORD)lpbi)

// Macro to determine the size of profile data.
#define PROFILESIZE(lpbi)   (*(LPDWORD)lpbi < sizeof(BITMAPV5HEADER) ? 0 :  \
                            ((LPBITMAPV5HEADER)lpbi)->bV5ProfileSize)

// Macro to that returns pointer to DIB profile data.
#define GETPROFILEDATA(lpbi)    (IS_BITMAPV5HEADER(lpbi) ? (LPBYTE)lpbi + ((LPBITMAPV5HEADER)lpbi)->bV5ProfileData : NULL)

// Given a pointer to a DIB header, return TRUE if is a Windows 3.0 style
//  DIB, false if otherwise (PM style DIB).  Assume it is a Windows DIB if
// size (the first DWORD) at least eqal to BITMAPINFOHEADER size.

#define IS_WIN30_DIB(lpbi)  ((*(LPDWORD) (lpbi)) >= sizeof (BITMAPINFOHEADER))


// General STRUCTS && TYPEDEFS

// Function prototypes
void      DIBPaint (HDC hDC, LPRECT lpDCRect, HGLOBAL hDIB,LPRECT lpDIBRect, LPDIBINFO lpDIBInfo);
HGLOBAL   ReadDIBFile(LPTSTR lpszFileName);
HGLOBAL   PasteDIBData(HWND hWnd,int wmCommand);
DWORD     PaletteSize(LPBITMAPINFOHEADER lpbi);
HANDLE    ReadDIBFromFile(HANDLE hFile);
HANDLE    PasteDIBFromClipboard(HWND hWnd, int wmPasteMode);
HPALETTE  CreateDIBPalette(HANDLE hDIB);
LPBYTE    FindDIBBits(LPBITMAPINFOHEADER lpbi);
HANDLE    TransformDIBOutsideDC(HANDLE hDIB, BMFORMAT bmInput, LPTSTR lpszDestProfile,
                                LPTSTR lpszTargetProfile, DWORD dwIntent, PBMCALLBACKFN pBMCallback,
                                ULONG ulCallbackData);
BOOL      SaveDIBToFile(HWND hWnd, LPCTSTR lpszFileName, LPDIBINFO lpDIBInfo, DWORD dwType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\icmview.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    ICMVIEW.H
//
//  PURPOSE:
//    Include file for ICMVIEW.C
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// General pre-processor macros
#define APPNAMEA    "ICMVIEW"
#define APPNAME __TEXT("ICMVIEW")

#ifndef MAX_STRING
    #define MAX_STRING    256
#endif

//
// Constants for use by Windows ICM APIs
//    These *should* be in WINGDI.H
//
//  API:  ColorMatchToTarget.
#ifndef CS_ENABLE
    #define CS_ENABLE           1
    #define CS_DISABLE          2
    #define CS_DELETE_TRANSFORM 3
#endif

// Values for BITMAPV5HEADER field bV5CSType
#ifndef PROFILE_LINKED
    #define PROFILE_LINKED          'LINK'
    #define PROFILE_EMBEDDED        'MBED'
#endif

// Makes it easier to determine appropriate code paths:
#if defined (WIN32)
    #define IS_WIN32 TRUE
#else
    #define IS_WIN32 FALSE
#endif

#define IS_NT      (0 != (IS_WIN32 && ((BOOL)(GetVersion() < 0x80000000))) )
#define IS_WIN32S  (0 != (IS_WIN32 && (BOOL)(!(IS_NT) && (LOBYTE(LOWORD(GetVersion()))<4))))
#define IS_WIN95   (0 != ((BOOL)(!(IS_NT) && !(IS_WIN32S)) && IS_WIN32))

// Support macros
#ifndef C1_GAMMA_RAMP
    #define C1_GAMMA_RAMP 0x00000020
#endif

#ifndef CAPS1
    #define CAPS1   94
#endif

#define SUPPORT_GAMMA_RAMPS(hDC) (BOOL)((GetDeviceCaps(hDC, CAPS1) & C1_GAMMA_RAMP) != 0)

// Default profile to use
#define DEFAULT_ICM_PROFILE __TEXT("sRGB Color Space Profile.ICM")

// Window extra bytes
#define GWL_DIBINFO GWL_USERDATA

// DWORD Flag macros
#define CHECK_DWFLAG(dwFlag,dwBits)((BOOL)((dwFlag & dwBits) != 0))
#define ENABLE_DWFLAG(dwFlag,dwBits)   (dwFlag |= dwBits)
#define CLEAR_DWFLAG(dwFlag,dwBits) (dwFlag &= ~dwBits)
#define SET_DWFlag(dwFlag, dwBits, bSet) (bSet ? (dwFlag |= dwBits) : (dwFlag &= ~dwFlag))

#define START_WAIT_CURSOR(hCur) hCur = SetCursor(LoadCursor(NULL,IDC_WAIT));
#define END_WAIT_CURSOR(hCur) SetCursor(hCur);

#define IVF_MAXIMIZED   0x1L

// Constants for use in converting ICC Intents to LCS Intents
#define MAX_ICC_INTENT  INTENT_ABSOLUTE_COLORIMETRIC
#define ICC_TO_LCS      0
#define LCS_TO_ICC      1

// General STRUCTS && TYPEDEFS
#ifndef ICMVIEW_INTERNAL

// Global variables for the application.
extern  HINSTANCE   ghInst;                 // Global instance handle
extern  TCHAR       gstTitle[];             // The title bar text
extern  HWND        ghAppWnd;               // Handle to application window
extern  HWND        ghWndMDIClient;
extern  DWORD       gdwLastError;           // Used to track LastError value
extern  TCHAR       gstProfilesDir[MAX_PATH];       // System directory for ICM profiles

#endif

// Function prototypes
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
LPTSTR  CopyString(LPTSTR lpszSrc);
BOOL    UpdateString(LPTSTR *lpszDest, LPTSTR lpszSrc);
BOOL    CenterWindow(HWND, HWND);
BOOL    ConvertIntent(DWORD dwOrig, DWORD dwDirection, LPDWORD lpdwXlate);
DWORD   SetDWFlags(LPDWORD lpdwFlag, DWORD dwBitValue, BOOL bSet);
HMENU   InitImageMenu(HWND hWnd);
BOOL    GetBaseFilename(LPTSTR lpszFilename, LPTSTR *lpszBaseFilename);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\print.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    PRINT.H
//
//  PURPOSE:
//    Include file for PRINT.C
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// General pre-processor macros
#define ENUM_ERROR         0x80000000
#define ERROR_ENUMPRINTERS 0x80000001

// General STRUCTS && TYPEDEFS

// Function prototypes
HDC   SelectPrinter(HWND hWnd);
LPTSTR GetDefaultPrinterName(void);
DWORD PopulatePrinterCombobox(HWND hDlg, int iControlId, LPTSTR lpszCurrentPrinter);
HDC   GetPrinterDC(LPTSTR lpszFriendlyName, PDEVMODE pDevMode);
BOOL  PrintImage(HWND HWnd);
HDC   GetDefaultPrinterDC();
PDEVMODE GetDefaultPrinterDevMode(LPTSTR lpszPrinterName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\icmview.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    ICMVIEW.C
//
//  PURPOSE:
//
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include "icm.h"

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings

// C RunTime Header Files
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

// Local Header Files
#include "Resource.h"

#define   ICMVIEW_INTERNAL
#include "ICMView.h"
#undef    ICMVIEW_INTERNAL

#include "Print.H"
#include "DibInfo.H"
#include "Dialogs.H"
#include "AppInit.H"
#include "child.h"
#include "Debug.h"


// Global Variables:
HINSTANCE   ghInst;                         // Global instance handle
TCHAR       gstTitle[MAX_STRING];           // The title bar text
HWND        ghAppWnd;                       // Handle to application window
HWND        ghWndMDIClient;
DWORD       gdwLastError;                   // Used to track last error value
TCHAR       gstProfilesDir[MAX_PATH];       // System directory for ICM profiles

// Foward declarations of functions included in this code module:
LRESULT CALLBACK About(HWND, UINT, WPARAM, LPARAM);

//
//  FUNCTION: WinMain(HANDLE, HANDLE, LPTSTR, int)
//
//  PURPOSE: Entry point for the application.
//
//  COMMENTS:
//
//      This function initializes the application and processes the
//      message loop.
//
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG msg;
    HANDLE hAccelTable;

    if (!hPrevInstance)
    {
        // Perform instance initialization:
        if (!InitApplication(hInstance))
        {
            return (FALSE);
        }
    }

    // Perform application initialization:
    if (!InitInstance(hInstance, nCmdShow))
    {
        return (FALSE);
    }

    hAccelTable = LoadAccelerators (hInstance, APPNAME);
    ASSERT(hAccelTable);

    // Main message loop:
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if ((!TranslateMDISysAccel (ghWndMDIClient, &msg))
            && (!TranslateAccelerator (msg.hwnd, hAccelTable, &msg)))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return (msg.wParam);
    lpCmdLine; // This will prevent 'unused formal parameter' warnings
}

//
//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for the main window.
//
//  MESSAGES:
//
//      WM_COMMAND - process the application menu
//      WM_PAINT - Paint the main window
//      WM_DESTROY - post a quit message and return
//      WM_DISPLAYCHANGE - message sent to Plug & Play systems when the display changes
//      WM_RBUTTONDOWN - Right mouse click -- put up context menu here if appropriate
//      WM_NCRBUTTONUP - User has clicked the right button on the application's system menu
//
//
LRESULT CALLBACK WndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    int         wmId, wmEvent;
    POINT       pnt;
    HMENU       hMenu;
    int         iDlg;

    // Init variables
    iDlg = 0;

    switch (uiMsg)
    {

        case WM_INITMENUPOPUP:
            InitImageMenu(hwnd);
            break;

        case WM_CREATE:
            {
                CLIENTCREATESTRUCT ccs;

                // Find window menu where children will be listed
                ccs.hWindowMenu  = GetSubMenu (GetMenu (hwnd), WINDOWMENU_POS);
                ccs.idFirstChild = FIRSTCHILD;

                // Create the MDI client window, which will fill the client area
                ghWndMDIClient = CreateWindow (
                                              __TEXT("MDICLIENT"),
                                              NULL,
                                              WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL,
                                              0,
                                              0,
                                              0,
                                              0,
                                              hwnd,
                                              (HMENU) 0xCAC,
                                              ghInst,
                                              (LPTSTR)&ccs);

                ShowWindow (ghWndMDIClient, SW_SHOW);
                break;
            }

        case WM_COMMAND:
            wmId    = LOWORD(wParam); // Remember, these are...
            wmEvent = HIWORD(wParam); // ...different for Win32!

            //Parse the menu selections:
            switch (wmId)
            {
                case IDM_HELP_ABOUT:
                    DialogBox(ghInst, __TEXT("AboutBox"), hwnd, (DLGPROC)About);
                    break;

                case IDM_FILE_EXIT:
                    DestroyWindow (hwnd);
                    break;

                case IDM_FILE_OPEN:
                case IDM_FILE_PASTE_CLIPBOARD_DIB:
                case IDM_FILE_PASTE_CLIPBOARD_DIBV5:
                    fOpenNewImage(hwnd, NULL, wmId);
                    break;

                case IDM_WINDOW_CASCADE:
                    SendMessage(ghWndMDIClient, WM_MDICASCADE, 0, 0);;
                    break;

                case IDM_WINDOW_TILE_HORIZONTAL:
                    SendMessage(ghWndMDIClient, WM_MDITILE, (WPARAM)MDITILE_HORIZONTAL, 0);;
                    break;

                case IDM_WINDOW_TILE_VERTICAL:
                    SendMessage(ghWndMDIClient, WM_MDITILE, (WPARAM)MDITILE_VERTICAL, 0);;
                    break;

                case IDM_WINDOW_ARRANGE:
                    SendMessage(ghWndMDIClient, WM_MDIICONARRANGE, 0, 0);
                    break;

                case IDM_FILE_RECENT:
                case IDM_FILE_RECENT1:
                case IDM_FILE_RECENT2:
                case IDM_FILE_RECENT3:
                    {
                        HANDLE  hRecent;
                        LPTSTR  *ppszRecent;
                        LPTSTR  lpszFileName;

                        // Get handle to recent file list table.
                        hRecent = GetProp(hwnd, APP_RECENT);
                        if (NULL != hRecent)
                        {
                            // Get pointer to recent file array.
                            ppszRecent = (LPTSTR*) GlobalLock(hRecent);
                            ASSERT(NULL != ppszRecent);

                            // Copy file name into buffer.
                            lpszFileName = GlobalAlloc(GPTR,(lstrlen(ppszRecent[ wmId - IDM_FILE_RECENT]) +1) * sizeof(TCHAR));

                            // Open the file.
                            if (lpszFileName != NULL)
                            {
                                // Copy recent file name to file name buffer.
                                _tcscpy(lpszFileName, ppszRecent[ wmId - IDM_FILE_RECENT]);
                                GlobalUnlock(hRecent);

                                // Open new image of recent file.
                                fOpenNewImage(hwnd, lpszFileName, wmId);
                            }
                        }
                    }
                    break;

                default:
                    {
                        HWND  hwndActiveChild;

                        hwndActiveChild = GetCurrentMDIWnd();
                        ASSERT(hwndActiveChild != NULL);
                        if (hwndActiveChild)
                        {
                            PostMessage(hwndActiveChild, uiMsg, wmId, wmEvent);
                        }
                        break;
                    }
            }
            break;

        case WM_RBUTTONDOWN: // RightClick in windows client area...
            pnt.x = LOWORD(lParam);
            pnt.y = HIWORD(lParam);
            ClientToScreen(hwnd, (LPPOINT) &pnt);
            hMenu = GetSubMenu (GetMenu (hwnd), 2);
            if (hMenu)
            {
                TrackPopupMenu (hMenu, 0, pnt.x, pnt.y, 0, hwnd, NULL);
            }
            else  // Couldn't find the menu...
            {
                MessageBeep(0);
            }
            break;

        case WM_DISPLAYCHANGE: // Only comes through on plug'n'play systems
            {
                SIZE szScreen;
                BOOL fChanged = (BOOL)wParam;

                szScreen.cx = LOWORD(lParam);
                szScreen.cy = HIWORD(lParam);
            }
            break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
            return 1L;

        case WM_DESTROY:
            {
                DWORD             dwFlags = 0L;
                HANDLE            hRecent;
                WINDOWPLACEMENT   WndPlacement;

                // Store application settings.
                dwFlags |= IsZoomed(hwnd) ? IVF_MAXIMIZED : 0L;
                WndPlacement.length = sizeof(WINDOWPLACEMENT);
                GetWindowPlacement(hwnd, &WndPlacement);
                hRecent = GetProp(hwnd, APP_RECENT);
                SetSettings(&WndPlacement.rcNormalPosition, dwFlags, hRecent);

                // Remove recent file attachment and free memory.
                RemoveProp(hwnd, APP_RECENT);
                GlobalFree(hRecent);
            }
            PostQuitMessage(0);
            break;

        case WM_QUERYNEWPALETTE:
            {
                HWND hwndActive;

                hwndActive = GetCurrentMDIWnd();
                if (NULL != hwndActive)
                {
                    return SendMessage(hwndActive, MYWM_QUERYNEWPALETTE, (WPARAM) hwnd, 0L);
                }
                return FALSE;
            }

        case WM_PALETTECHANGED:
            {
                HWND hwndMDI = GetCurrentMDIWnd();
                if (NULL != hwndMDI)
                {
                    return SendMessage(hwndMDI, MYWM_PALETTECHANGED, (WPARAM) wParam, (LPARAM) hwnd);
                }
                return FALSE;
            }

        case WM_SIZE:
            InvalidateRect(hwnd, NULL, TRUE);
            break;
    }
    return DefFrameProc(hwnd,ghWndMDIClient, uiMsg, wParam, lParam);
}

//
//  FUNCTION: About(HWND, unsigned, WORD, LONG)
//
//  PURPOSE:  Processes messages for "About" dialog box
//              This version allows greater flexibility over the contents of the 'About' box,
//              by pulling out values from the 'Version' resource.
//
//  MESSAGES:
//
//      WM_INITDIALOG - initialize dialog box
//      WM_COMMAND    - Input received
//
//
LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    static  HFONT hfontDlg;         // Font for dialog text
    static  HFONT hFinePrint;       // Font for 'fine print' in dialog
    DWORD   dwVerInfoSize;          // Size of version information block
    LPTSTR   lpVersion;              // String pointer to 'version' text
    DWORD   dwVerHnd=0;             // An 'ignored' parameter, always '0'
    UINT    uVersionLen;
    int     iRootLen;
    BOOL    bRetCode;
    int     i;
    TCHAR   szFullPath[256];
    TCHAR   szResult[256];
    TCHAR   szGetName[256];
    DWORD   dwVersion;
    TCHAR   szVersion[40];
    DWORD   dwResult;

    wParam = wParam; //Eliminate 'unused formal parameter' warning
    lParam = lParam; //Eliminate 'unused formal parameter' warning

    switch (message)
    {
        case WM_INITDIALOG:
            ShowWindow (hDlg, SW_HIDE);
            hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, __TEXT(""));
            hFinePrint = CreateFont(11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, __TEXT(""));
            CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER));
            GetModuleFileName (ghInst, szFullPath, sizeof(szFullPath));

            // Now let's dive in and pull out the version information:
            dwVerInfoSize = GetFileVersionInfoSize(szFullPath, &dwVerHnd);
            if (dwVerInfoSize)
            {
                LPTSTR   lpstrVffInfo;
                HANDLE  hMem;
                hMem = GlobalAlloc(GMEM_MOVEABLE, dwVerInfoSize);
                lpstrVffInfo  = GlobalLock(hMem);
                GetFileVersionInfo(szFullPath, dwVerHnd, dwVerInfoSize, lpstrVffInfo);

                // The below 'hex' value looks a little confusing, but
                // essentially what it is, is the hexidecimal representation
                // of a couple different values that represent the language
                // and character set that we are wanting string values for.
                // 040904E4 is a very common one, because it means:
                //   US English, Windows MultiLingual characterset
                // Or to pull it all apart:
                // 04//////        = SUBLANG_ENGLISH_USA
                // --09////        = LANG_ENGLISH
                // ////04E4 = 1252 = Codepage for Windows:Multilingual
                _tcscpy(szGetName, __TEXT("\\StringFileInfo\\040904E4\\"));
                iRootLen = lstrlen(szGetName); // Save this position

                // Set the title of the dialog:
                lstrcat (szGetName, __TEXT("ProductName"));
                bRetCode = VerQueryValue((LPVOID)lpstrVffInfo, (LPTSTR)szGetName, (LPVOID)&lpVersion, (UINT *)&uVersionLen);
                _tcscpy(szResult, __TEXT("About "));
                lstrcat(szResult, lpVersion);
                SetWindowText (hDlg, szResult);

                // Walk through the dialog items that we want to replace:
                for (i = DLG_VERFIRST; i <= DLG_VERLAST; i++)
                {
                    GetDlgItemText(hDlg, i, szResult, sizeof(szResult));
                    szGetName[iRootLen] = __TEXT('\0');
                    lstrcat (szGetName, szResult);
                    uVersionLen   = 0;
                    lpVersion     = NULL;
                    bRetCode      =  VerQueryValue((LPVOID)lpstrVffInfo, (LPTSTR)szGetName, (LPVOID)&lpVersion, (UINT *)&uVersionLen);

                    if ( bRetCode && uVersionLen && lpVersion)
                    {
                        // Replace dialog item text with version info
                        _tcscpy(szResult, lpVersion);
                        SetDlgItemText(hDlg, i, szResult);
                    }
                    else
                    {
                        dwResult = GetLastError();
                        wsprintf (szResult,__TEXT("Error %lu"), dwResult);
                        SetDlgItemText (hDlg, i, szResult);
                    }
                    SendMessage (GetDlgItem (hDlg, i), WM_SETFONT, (UINT)((i==DLG_VERLAST)?hFinePrint:hfontDlg), TRUE);
                } // for (i = DLG_VERFIRST; i <= DLG_VERLAST; i++)
                GlobalUnlock(hMem);
                GlobalFree(hMem);
            }
            else
            {
                // No version information available.
            } // if (dwVerInfoSize)

            SendMessage (GetDlgItem (hDlg, IDC_LABEL), WM_SETFONT, (WPARAM)hfontDlg,(LPARAM)TRUE);

            // We are  using GetVersion rather then GetVersionEx
            // because earlier versions of Windows NT and Win32s
            // didn't include GetVersionEx:
            dwVersion = GetVersion();
            if (dwVersion < 0x80000000)
            {
                // Windows NT
                wsprintf (szVersion,__TEXT("Microsoft Windows NT %u.%u (Build: %u)"), (DWORD)(LOBYTE(LOWORD(dwVersion))), (DWORD)(HIBYTE(LOWORD(dwVersion))),(DWORD)(HIWORD(dwVersion)) );
            }
            else
            {
                if (LOBYTE(LOWORD(dwVersion)) < 4)
                {
                    // Win32s
                    wsprintf (szVersion, __TEXT("Microsoft Win32s %u.%u (Build: %u)"), (DWORD)(LOBYTE(LOWORD(dwVersion))), (DWORD)(HIBYTE(LOWORD(dwVersion))),(DWORD)(HIWORD(dwVersion) & ~0x8000) );
                }
                else
                {
                    // Windows 95
                    wsprintf (szVersion, __TEXT("Microsoft Windows 95 %u.%u"), (DWORD)(LOBYTE(LOWORD(dwVersion))), (DWORD)(HIBYTE(LOWORD(dwVersion))) );
                }
            }
            SetWindowText (GetDlgItem(hDlg, IDC_OSVERSION), szVersion);
            ShowWindow (hDlg, SW_SHOW);
            return (TRUE);

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, TRUE);
                DeleteObject (hfontDlg);
                DeleteObject (hFinePrint);
                return (TRUE);
            }
            break;
    }
    return FALSE;
}

//
//   FUNCTION: CenterWindow(HWND, HWND)
//
//   PURPOSE: Centers one window over another.
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
//              This function will center one window over another ensuring that
//              the placement of the window is within the 'working area', meaning
//              that it is both within the display limits of the screen, and not
//              obscured by the tray or other framing elements of the desktop.
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent, rWorkArea;
    int     wChild, hChild, wParent, hParent;
    int     xNew, yNew;
    BOOL    bResult;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the limits of the 'workarea'
    bResult = SystemParametersInfo(
                                  SPI_GETWORKAREA,
                                  sizeof(RECT),
                                  &rWorkArea,
                                  0);
    if (!bResult)
    {
        rWorkArea.left = rWorkArea.top = 0;
        rWorkArea.right = GetSystemMetrics(SM_CXSCREEN);
        rWorkArea.bottom = GetSystemMetrics(SM_CYSCREEN);
    }
    // Calculate new X position, then adjust for workarea
    xNew = rParent.left + ((wParent - wChild) / 2);
    if (xNew < rWorkArea.left)
    {
        xNew = rWorkArea.left;
    }
    else if ((xNew + wChild) > rWorkArea.right)
    {
        xNew = rWorkArea.right - wChild;
    }
    // Calcualte new Y position, then adjust for workarea
    yNew = rParent.top + ((hParent - hChild) /2);
    if (yNew < rWorkArea.top)
    {
        yNew = rWorkArea.top;
    }
    else if ((yNew + hChild) > rWorkArea.bottom)
    {
        yNew = rWorkArea.bottom - hChild;
    }

    //Set it and return
    return(SetWindowPos(hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER));
}

//////////////////////////////////////////////////////////////////////////
//  Function:  CopyString
//
//  Description:
//    Allocates space and copies one LPTSTR into a new one.  Allocates
//    exactly as much memory as necessary.
//
//  Parameters:
//    LPTSTR    Source string to be copied.
//
//  Returns:
//    LPTSTR  Pointer to copy of string; NULL if failure.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPTSTR CopyString(LPTSTR  lpszSrc)
{
    // Local variables
    LPTSTR    lpszDest;
    int       iStrLen;

    //  Initialize variables
    lpszDest = NULL;

    if (lpszSrc == NULL)
    {
        DebugMsg(__TEXT("ICMVIEW.C : CopyString : lpszSrc == NULL\r\n"));
        return(NULL);
    }
    iStrLen = ((int)(lstrlen(lpszSrc) +1) * sizeof(TCHAR));
    lpszDest = GlobalAlloc(GPTR, iStrLen);
    _tcscpy(lpszDest, lpszSrc);
    return(lpszDest);
}   // End of function CopyString


//////////////////////////////////////////////////////////////////////////
//  Function:  UpdateString
//
//  Description:
//    Replaces target string with source string.  Frees target first
//    if necessary.
//
//  Parameters:
//    LPTSTR    Destination string
//    LPTSTR    Source string
//
//  Returns:
//    LPTSTR    Destination string.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL UpdateString(LPTSTR *lpszDest, LPTSTR lpszSrc)
{
    // Local variables
    HGLOBAL hMem, hDest;
    LPTSTR  lpszNew;

    //  Initialize variables
    if (NULL == lpszSrc)
    {
        DebugMsg(__TEXT("ICMVIEW.C : UpdateString : NULL source\r\n"));
        *lpszDest = NULL;
        return(FALSE);
    }

    if (NULL != *lpszDest)
    {
        hDest = GlobalHandle(*lpszDest);
        GlobalUnlock(hDest);
        GlobalFree(hDest);
    }
    hMem = GlobalAlloc(GPTR, (1 + lstrlen(lpszSrc))* sizeof(TCHAR));
    if (NULL == hMem)
    {
        DebugMsg(__TEXT("UpdateString : GlobalAlloc failed\r\n"));
        return(FALSE);
    }
    lpszNew = GlobalLock(hMem);
    _tcscpy(lpszNew, lpszSrc);
    *lpszDest = lpszNew;
    return(TRUE);
}   // End of function UpdateString



BOOL ConvertIntent(DWORD dwOrig, DWORD dwDirection, LPDWORD lpdwXlate)
{
    DWORD   adwIntents[MAX_ICC_INTENT + 1] = { LCS_GM_IMAGES, LCS_GM_GRAPHICS, LCS_GM_BUSINESS, LCS_GM_GRAPHICS};
    int     idx;

    ASSERT((ICC_TO_LCS == dwDirection) || (LCS_TO_ICC == dwDirection));
    *lpdwXlate = (DWORD)-1;

    switch (dwDirection)
    {
        case LCS_TO_ICC:
            for (idx = MAX_ICC_INTENT+1; idx >0; idx--)
            {
                if (adwIntents[idx] == dwOrig)
                {
                    *lpdwXlate = idx;
                    return(TRUE);
                }
            }
            break;

        case ICC_TO_LCS:
            if (dwOrig <= MAX_ICC_INTENT)
            {
                *lpdwXlate = adwIntents[dwOrig];
                return(TRUE);
            }
        default:
            SetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
            break;
    }
    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////
//  Function:  SetDWFlags
//
//  Description:
//    Sets flag values in a DWORD flag.
//
//  Parameters:
//    LPDWORD Pointer to flag variable to be changed.
//    DWORD   Value to be set/cleared.
//    BOOL    Indicates if value is to be set or cleared.
//
//  Returns:
//    DWORD   Value of flag variable prior to call.
//
//  Comments:
//
//////////////////////////////////////////////////////////////////////////
DWORD SetDWFlags(LPDWORD lpdwFlag, DWORD dwBitValue, BOOL bSet)
{
    // Initialize variables
    if (bSet)
    {
        (*lpdwFlag) |= dwBitValue;
    }
    else
    {
        (*lpdwFlag) &= (~dwBitValue);
    }
    return(*lpdwFlag);
} // End of function SetDWFlags


//////////////////////////////////////////////////////////////////////////
//  Function:  InitImageMenu
//
//  Description:
//    Handles the WM_CONTEXTMENU message
//
//  Parameters:
//    @@@
//
//  Returns:
//    LRESULT
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
HMENU InitImageMenu(HWND hwnd)
{
    // Local variables
    HMENU       hMenu, hActiveMenu;
    UINT        uiMenuFlag;
    LPDIBINFO   lpDIBInfo;
    HWND        hwndImage;

    //  Initialize variables
    lpDIBInfo = NULL;

    hwndImage = GetCurrentMDIWnd();
    if (hwndImage)  // we have an active child window
    {
        lpDIBInfo = GetDIBInfoPtr(hwndImage);
        if (!lpDIBInfo)
        {
            return(NULL);
        }
    }

    if (hwnd == ghAppWnd) // dealing with main app window
    {
        hMenu = GetMenu(hwnd);
        hActiveMenu = GetSubMenu(hMenu, IsZoomed(hwndImage) ? 1 : 0);
        uiMenuFlag = (hwndImage != NULL) ? MF_ENABLED : MF_GRAYED;
        EnableMenuItem(hActiveMenu, IDM_FILE_CLOSE, uiMenuFlag);
        EnableMenuItem(hActiveMenu, IDM_FILE_PRINT_SETUP, uiMenuFlag);
        EnableMenuItem(hActiveMenu, IDM_FILE_PRINT, uiMenuFlag);
        EnableMenuItem(hActiveMenu, IDM_FILE_DISPLAY, uiMenuFlag);
        EnableMenuItem(hActiveMenu, IDM_FILE_CONFIGURE_ICM, uiMenuFlag);
        EnableMenuItem(hActiveMenu, ID_FILE_SAVEAS, uiMenuFlag);
    }
    else  // dealing with child window--must init context menu
    {
        hMenu = LoadMenu(ghInst, __TEXT("ImageContext"));
        hActiveMenu = GetSubMenu(hMenu, 0);
    }

    // Check EITHER ICM 2.0 or ICM 1.0 (Inside DC or Outside DC)
    if (hActiveMenu && lpDIBInfo)
    {
        uiMenuFlag = (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20) ? MF_CHECKED : MF_UNCHECKED);
        CheckMenuItem(hActiveMenu, IDM_FILE_ICM20, uiMenuFlag);
        CheckMenuItem(hActiveMenu, IDM_FILE_ICM10, uiMenuFlag == MF_CHECKED ? MF_UNCHECKED : MF_CHECKED);
    }

    if (lpDIBInfo)
        GlobalUnlock(GlobalHandle(lpDIBInfo));

    return(hActiveMenu);
}   // End of function InitImageMenu

//////////////////////////////////////////////////////////////////////////
//  Function:  GetBaseFilename
//
//  Description:
//
//
//  Parameters:
//      @@@
//
//  Returns:
//      BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL GetBaseFilename(LPTSTR lpszFilename, LPTSTR *lpszBaseFilename)
{
    // Local variables
    TCHAR   stFile[MAX_PATH], stExt[MAX_PATH];

    //  ASSERTs and parameter validations
    ASSERT(NULL != lpszFilename);
    if (NULL == lpszFilename)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //  Initialize variables
    _tsplitpath(lpszFilename, NULL, NULL, stFile, stExt);
    (*lpszBaseFilename) = (LPTSTR)GlobalAlloc(GPTR, ((_tcslen(stFile) + _tcslen(stExt) + 1 ) * sizeof(TCHAR)));
    if (NULL != *lpszBaseFilename)
    {
        _stprintf(*lpszBaseFilename, __TEXT("%s%s"), stFile, stExt);
    }
    //  Cleanup any allocated resources
    return(NULL != *(lpszBaseFilename));
} // End of function GetBaseFilename
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\print.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    Print.c
//
//  PURPOSE:
//    Illustrates the 'minimum' functionality of a well-behaved Win32 application.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>
#include <commdlg.h>
#include <winspool.h>
#include "icm.h"

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings
#pragma warning(default:4514)   // Unreferenced inline function has been removed

// C RunTime Header Files
#include <TCHAR.H>

// Local Header Files
#include "IcmView.h"
#include "Child.h"
#include "dibinfo.h"
#include "Dibs.h"

#include "Debug.h"

#include "Print.h"
#include "RegUtil.h"
#include "Resource.h"

// local definitions

#ifndef ICM_DONE_OUTSIDEDC
    #define ICM_DONE_OUTSIDEDC  4
#endif

// default settings

// external functions

// external data

// public data

// private data
BOOL      gbUserAbort;
FARPROC   glpfnPrintDlgProc;
FARPROC   glpfnAbortProc;
HWND      ghDlgPrint;
HWND      ghWndParent;
LOGFONT   gLogFont = { 0, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, __TEXT("Arial")};

// private functions
BOOL FreeMemory(HANDLE hInfo);
LPBYTE GetMemory(LPHANDLE lphInfo, DWORD dwSize);
DWORD SPL_EnumPrinters(DWORD dwType, LPTSTR lpszName, DWORD dwLevel, LPHANDLE lphPrinterInfo);
BOOL PrintDIB (HANDLE hDIB, HDC hDC, int xOrigin, int yOrigin, int xSize, int ySize, BOOL bStretch);
static HDC PASCAL InitPrinting(HWND hWnd, LPTSTR lpszFriendlyName, PDEVMODE pDevMode);
static void PASCAL TermPrinting(HDC hDC);
BOOL FAR PASCAL PrintDlgProc (HWND hDlg, unsigned iMessage, WORD wParam, DWORD lParam);
BOOL FAR PASCAL AbortProc (HDC hPrnDC, short nCode);


extern DWORD NumColorsInDIB(LPBITMAPINFOHEADER lpbi);

// public functions

/////////////////////////////////////////////////////////////////////
//  Function:  SelectPrinter
//
//  Description:
//    Uses the Print common dialog box to provide the user with the
//    opportunity to select and set up a particular printer.
//
//  Parameters:
//    hWnd    Handle to the parent window.
//
//  Returns:
//    HDC to requested printer if successful; NULL otherwise.
//
// Comments:
//   If this function returns NULL, the caller should check
//   the latest COMMDLG error by calling CommDlgExtendedError().
//
/////////////////////////////////////////////////////////////////////

HDC SelectPrinter(HWND hWnd)
{
    // Local variables
    BOOL      bPrintDlg;        // Return code from PrintDlg function
    PRINTDLG  pd;               // Printer dialog structure
    DWORD     dwError;
    HDC       hDC;              // DC to printer

    //  Initialize variables
    hDC = NULL;
#ifdef _DEBUG
    memset(&pd, UNINIT_BYTE, sizeof(PRINTDLG));
#endif

    /* Initialize the PRINTDLG members. */

    pd.lStructSize = sizeof(PRINTDLG);
    pd.hwndOwner = hWnd;
    pd.Flags = PD_RETURNDC | PD_PRINTSETUP;
    pd.hDevMode = (HANDLE) NULL;
    pd.hDevNames = (HANDLE) NULL;
    pd.hDC = (HDC) NULL;
    pd.nFromPage = 1;
    pd.nToPage = 1;
    pd.nMinPage = 0;
    pd.nMaxPage = 0;
    pd.nCopies = 1;
    pd.hInstance = (HANDLE) NULL;
    pd.lCustData = 0L;
    pd.lpfnPrintHook = (LPPRINTHOOKPROC) NULL;
    pd.lpfnSetupHook = (LPSETUPHOOKPROC) NULL;
    pd.lpPrintTemplateName = (LPTSTR) NULL;
    pd.lpSetupTemplateName = (LPTSTR)  NULL;
    pd.hPrintTemplate = (HANDLE) NULL;
    pd.hSetupTemplate = (HANDLE) NULL;

    // Display the PRINT dialog box.
    bPrintDlg = PrintDlg(&pd);
    if (!bPrintDlg)  // Either no changes, or a common dialog error occured
    {
        dwError = CommDlgExtendedError();
        if (dwError != 0)
        {
            return(NULL);
        }
    }
    else // Passed call, set up DC
    {
        ASSERT(pd.hDC != NULL); // HDC should never be NULL if we passed the call
        hDC = pd.hDC;
    }
    return(hDC);
}   // End of SelectPrinter


// private functions


//////////////////////////////////////////////////////////////////////////
//  Function:  GetPrinterDC
//
//  Description:
//    Obtains a DC from the specified friendly name.
//
//  Parameters:
//    @@@
//
//  Returns:
//    HDC
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
HDC GetPrinterDC(LPTSTR lpszFriendlyName, PDEVMODE pDevMode)
{
    HDC     hDC;
    BOOL    bFreeDevMode = FALSE;


    //  Initialize variables
    hDC = NULL;

    if (lpszFriendlyName != NULL)
    {
        // Make sure that we have a devmode.
        if (NULL == pDevMode)
        {
            pDevMode = GetDefaultPrinterDevMode(lpszFriendlyName);
            bFreeDevMode = TRUE;
        }

        // Now get a DC for the printer
        hDC = CreateDC(NULL, lpszFriendlyName, NULL, pDevMode);

        // Free devmode if created in routine.
        if (bFreeDevMode)
        {
            GlobalFree((HANDLE)pDevMode);
        }
    }
    else
    {
        DebugMsg(__TEXT("GetPrinterDC:  lpszFriendlyName == NULL"));
    }

    return hDC;
}   // End of function GetPrinterDC

//////////////////////////////////////////////////////////////////////////
//  Function:  GetDefaultPrinterName
//
//  Description:
//    Obtains the name of the default printer.
//
//  Parameters:
//    none
//
//  Returns:
//    LPTSTR   Name of printer, or NULL if failed.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPTSTR GetDefaultPrinterName(void)
{
    // Local variables
    LPTSTR     lpszDefaultPrinter = NULL;

    if (IS_WIN95)
    {

        lpszDefaultPrinter = GetRegistryString(HKEY_CURRENT_CONFIG,
                                               __TEXT("SYSTEM\\CurrentControlSet\\Control\\Print\\Printers"),
                                               __TEXT("Default"));
    }
    else if (IS_NT)
    {
        TCHAR szTemp[MAX_PATH];
        LPTSTR lpszTemp;

        // Get Default printer name.
        GetProfileString(__TEXT("windows"), __TEXT("device"), __TEXT(""),
                         szTemp, sizeof(szTemp));

        if (lstrlen(szTemp) == 0)
        {
            // INVARIANT:  no default printer.
            return(NULL);
        }

        // Terminate at first comma, just want printer name.
        lpszTemp = _tcschr(szTemp, ',');
        if (lpszTemp != NULL)
        {
            *lpszTemp = '\x0';
        }
        lpszDefaultPrinter = CopyString((LPTSTR)szTemp);
    }
    return(lpszDefaultPrinter);
}   // End of function GetDefaultPrinterName

//////////////////////////////////////////////////////////////////////////
//  Function:  PopulatePrinterCombobox
//
//  Description:
//    Enumerates all printers into a ComboBox based upon the provided flags.
//
//  Parameters:
//    @@@
//
//  Returns:
//    DWORD Number of printers enumerated.  -1 indicates failure.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
DWORD PopulatePrinterCombobox(HWND hDlg, int iControlId, LPTSTR lpszCurrentPrinter)
{
    // Local variables
    DWORD             dwReturnCode;
    DWORD             dwIndex;
    DWORD             dwNumPRN;
    LPPRINTER_INFO_2  lpPrinterInfo2;
    HGLOBAL           hFree;

    //  Initialize variables
    lpPrinterInfo2 = NULL;

    // Initialize ComboBox
    SendDlgItemMessage(hDlg, iControlId, EM_LIMITTEXT, (WPARAM)MAX_PATH, 0L);
    SendDlgItemMessage(hDlg,  iControlId, CB_RESETCONTENT, (WPARAM)0, (LPARAM)0L);

    dwNumPRN = SPL_EnumPrinters(PRINTER_ENUM_LOCAL | PRINTER_ENUM_CONNECTIONS, NULL, 2, (LPVOID)&lpPrinterInfo2);
    EnableWindow(GetDlgItem(hDlg, iControlId), (dwNumPRN != 0));
    if (dwNumPRN <= 0)
    {
        dwReturnCode = SendDlgItemMessage(hDlg, iControlId, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)__TEXT("No printers installed"));
        dwReturnCode = SendDlgItemMessage(hDlg, iControlId, WM_SETTEXT, 0, (LPARAM)(LPTSTR)__TEXT("No printers installed"));
        return (dwNumPRN);  // No printers to deal with.  -1 if EnumPrinters call failed.
    }

    if (lpPrinterInfo2 != NULL) // Got array of PRINTER_INFO structures
    {
        for (dwIndex =0; dwIndex < dwNumPRN; dwIndex++)
        {
            dwReturnCode = SendDlgItemMessage(hDlg, iControlId, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)lpPrinterInfo2[dwIndex].pPrinterName);
            if (dwReturnCode == CB_ERR)
            {
                return((DWORD)-1);
            }

            // If this is the current printer, load it into edit control
            if (lstrcmpi((LPTSTR)lpPrinterInfo2[dwIndex].pPrinterName, lpszCurrentPrinter) == 0)
            {
                dwReturnCode = SendDlgItemMessage(hDlg, iControlId, WM_SETTEXT, 0, (LPARAM)(LPTSTR)lpPrinterInfo2[dwIndex].pPrinterName);
                if (dwReturnCode == CB_ERR)
                {
                    return((DWORD)-1);
                }  // CB_ERR
            }  // current printer
        } // for (dwIndex = 0 ...
    }  // if (lpPrinterInfo2 != NULL)
    else
    {
        return((DWORD)-1);
    }

    // Free memory
    hFree = GlobalFree(lpPrinterInfo2);
    return(dwNumPRN);
}   // End of function PopulatePrinterCombobox

////////////////////////////////////////////////////////////////////////////
//
// FunctionName: SPL_EnumPrinters()
//
// Purpose:
//
// Parameters:
//    None.
//
// Return Value:
//
// Comments:
//
////////////////////////////////////////////////////////////////////////////

DWORD SPL_EnumPrinters(DWORD dwType, LPTSTR lpszName, DWORD dwLevel, LPVOID *lpvPrinterInfo)

{
    DWORD        dwSize;
    DWORD        dwPrinters;
    DWORD        dwNeeded    = 0;
    DWORD        dwErrorCode = 0;
    BOOL         bReturnCode;
    BOOL         bRC         = FALSE;
    LPBYTE       lpInfo      = NULL;

    // Enumerate Printers.
    bReturnCode = EnumPrinters(dwType, lpszName, dwLevel, NULL, 0, &dwSize, &dwPrinters);

    // If Return Code is TRUE, there is nothing to enumerate.
    if (bReturnCode)
    {
        DebugMsg(__TEXT("EnumPrinter():  No printers found\r\n"));
        return(0);
    }

    // Since Return Code is FALSE, check LastError.
    // If LastError is any thing other than allocate size error, flag and exit.
    dwErrorCode = GetLastError();
    if (dwErrorCode != ERROR_INSUFFICIENT_BUFFER)
    {
        return((DWORD)-1);
    }

    // Loop until we have size right.
    while (!bRC)
    {
        if (NULL != (lpInfo = (LPBYTE)GlobalAlloc(GPTR, dwSize)))
        {
#ifdef _DEBUG
            memset(lpInfo, UNINIT_BYTE, dwSize);
#endif
            // Enumerate
            bRC = EnumPrinters(dwType, lpszName, dwLevel, lpInfo, dwSize, &dwNeeded, &dwPrinters);
            if (!bRC)
            {
                dwErrorCode = GetLastError();

                // If anything other than allocate size error, flag and exit.
                if (dwErrorCode != ERROR_INSUFFICIENT_BUFFER)
                {
                    return((DWORD)-1);
                }
                else
                {
                    GlobalFree(lpInfo);
                    lpInfo = NULL;
                    dwSize = dwNeeded;
                }
            } // if (!bRC)
            else  // EnumPrinters returned success
            {
                *lpvPrinterInfo = lpInfo;  // Save pointer to PRINTER_INFO structure
            }
        }
        else
        {
            return((DWORD)-1);
        }
    }
    return(dwPrinters);
}  // End of function SPL_EnumPrinters

////////////////////////////////////////////////////////////////////////////
//
//  FUNCTION:  PrintDIB(HANDLE hDIB, HDC hDC, int x, int y, int dx, int dy)
//
//  PURPOSE:  Set the DIB bits to the printer DC.
//
////////////////////////////////////////////////////////////////////////////
BOOL PrintDIB (HANDLE hDIB, HDC hDC, int xOrigin, int yOrigin, int xSize, int ySize, BOOL bStretch)
{
    int                 iBits;
    HCURSOR             hCurSave;
    LPBITMAPINFOHEADER  lpDIB;
    LPBITMAPINFOHEADER  lpbi;


    // Initailize variables
    START_WAIT_CURSOR(hCurSave);  // put up busy cursor

    lpDIB = (LPBITMAPINFOHEADER)GlobalLock(hDIB);

    // If size > BITMAPINFOHEADER header then
    // need to convert to BITMAPINFOHEADER.
    lpbi = lpDIB;
#ifdef OSR2
    if (sizeof(BITMAPINFOHEADER) < lpDIB->biSize)
    {
        DWORD dwColorTableSize;
        DWORD dwHeaderDataSize;

        // Allocate Bitmapinfo memory.
        dwHeaderDataSize = sizeof(BITMAPINFOHEADER) + (lpDIB->biCompression == BI_BITFIELDS ? 12 : 0);
        dwColorTableSize = NumColorsInDIB(lpDIB) * sizeof(RGBQUAD);
        lpbi = (LPBITMAPINFOHEADER) GlobalAlloc(GPTR, dwHeaderDataSize + dwColorTableSize);
        if (NULL == lpbi)
        {
            return FALSE;
        }

        // Convert header data into bitmapinfo header.
        memcpy(lpbi, lpDIB, dwHeaderDataSize);
        lpbi->biSize = sizeof(BITMAPINFOHEADER);

        // Copy color table if any.
        if (0 != dwColorTableSize)
            memcpy((LPBYTE)lpbi + dwHeaderDataSize, (LPBYTE)lpDIB + lpDIB->biSize, dwColorTableSize);
    }
#endif

    if (bStretch)
    {
        iBits = StretchDIBits(hDC,
                              xOrigin, yOrigin,
                              xSize, ySize,
                              0, 0,
                              BITMAPWIDTH(lpbi), abs(BITMAPHEIGHT(lpbi)),
                              FindDIBBits(lpDIB),
                              (LPBITMAPINFO)lpbi,
                              DIB_RGB_COLORS,
                              SRCCOPY);
    }
    else
    {
        iBits  =   SetDIBitsToDevice (hDC,                                  // hDC
                                      xOrigin,                              // DestX
                                      yOrigin,                              // DestY
                                      BITMAPWIDTH(lpbi),                    // nDestWidth
                                      abs(BITMAPHEIGHT(lpbi)),              // nDestHeight
                                      0,                                    // SrcX
                                      0,                                    // SrcY
                                      0,                                    // nStartScan
                                      abs(BITMAPHEIGHT(lpbi)),              // nNumScans
                                      FindDIBBits(lpDIB),
                                      (LPBITMAPINFO) lpbi,                  // lpBitsInfo
                                      DIB_RGB_COLORS);                      // wUsage
    }
    END_WAIT_CURSOR(hCurSave);   // restore cursor
    if (lpbi != lpDIB)
    {
        GlobalFree((HANDLE)lpbi);
    }
    GlobalUnlock(hDIB);
    return((iBits != 0) && (iBits != GDI_ERROR));
}

//////////////////////////////////////////////////////////////////////////
//  Function:  PrintImage
//
//  Description:
//    Prints the image to the printer specified within the DIBINFO structure.
//
//  Parameters:
//    @@@
//
//  Returns:
//    BOOL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
BOOL PrintImage(HWND hWnd)
{
    // Local variables
    LPBITMAPINFOHEADER lpBi;
    int               xSize, ySize, xRes, yRes, dx, dy;
    LPDIBINFO         lpDIBInfo;
    HDC               hDC;
    HANDLE            hDIB;
    int               iICMMode, iPrevICMMode;
    int               iXOrigin, iYOrigin;
    BOOL              bRC;                    // general return code
    BOOL              bStretch;     // TRUE if to use StretchDIBits,
                                    // FALSE if to use SetDIBitsToDevice
    TCHAR             stPrintMsg[MAX_PATH*2];
    HANDLE            hDIBPrinter;
    DWORD             dwLCSIntent;


    //  Initialize variables
    hDIBPrinter = NULL;
    lpDIBInfo = GetDIBInfoPtr(hWnd);
    if (NULL == lpDIBInfo)
    {
        SetLastError(ERROR_INVALID_DATA);;
        return(FALSE);
    }
    hDIB = lpDIBInfo->hDIB;
    if (!ConvertIntent(lpDIBInfo->dwRenderIntent, ICC_TO_LCS, &dwLCSIntent))
    {
        ErrMsg(hWnd, __TEXT("Invalid Intent.  Aborting Print process"));
    }


    if (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20)
        && (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ENABLE_ICM)))
    {
        // ICM On, using outside DC, a.k.a. ICM20
        DebugMsg(__TEXT("PrintImage:  Outside DC, ICM Enabled\r\n"));

        // Create transform of the original bits to the printer
        ASSERT(NULL != lpDIBInfo->lpszPrinterProfile);
        hDIBPrinter  = TransformDIBOutsideDC(lpDIBInfo->hDIB,
                                             lpDIBInfo->bmFormat,
                                             lpDIBInfo->lpszPrinterProfile,
                                             NULL,
                                             USE_BITMAP_INTENT, NULL, 0);
        if (NULL == hDIBPrinter)
        {
            ErrMsg(hWnd, __TEXT("PrintImage:  Unable to transform DIB"));
            return(FALSE);
        }
        else // Transform worked
        {
            hDIB = hDIBPrinter;
        }
    }
    ASSERT(NULL != hDIB);
    lpBi = GlobalLock(hDIB);

    // Initialize printing
    hDC = InitPrinting(hWnd, lpDIBInfo->lpszPrinterName, lpDIBInfo->pDevMode);
    if (NULL != hDC)
    {
        // Get addresses of dialog procs
        glpfnPrintDlgProc = (FARPROC)&PrintDlgProc;
        glpfnAbortProc = (FARPROC)&AbortProc;

        // Create the printing dialog
        ghDlgPrint = CreateDialog(ghInst, MAKEINTRESOURCE(IDD_PRINTING), ghWndParent, (DLGPROC)glpfnPrintDlgProc);

        EnableWindow( ghWndParent, FALSE);  // Disable Parent
        CenterWindow(ghDlgPrint, ghWndParent);
        wsprintf(stPrintMsg, __TEXT("Printing image\r\n\r\n%s\r\n\r\nto\r\n\r\n%s"), lpDIBInfo->lpszImageFileName, lpDIBInfo->lpszPrinterName);
        SetWindowText(GetDlgItem(ghDlgPrint, IDC_PRINT_FILENAME), (LPTSTR)stPrintMsg);
        ShowWindow(ghDlgPrint, SW_SHOW);

        // Set the abort procedure
        if (SetAbortProc(hDC, (ABORTPROC)glpfnAbortProc) == SP_ERROR)
        {
            ErrMsg(hWnd, __TEXT("InitPrinting:  SetAbortProc FAILED, LastError = %ld"), GetLastError());
        }

        // Use the printable region of the printer to determine
        // the margins.
        iXOrigin = GetDeviceCaps(hDC, PHYSICALOFFSETX);
        iYOrigin = GetDeviceCaps(hDC, PHYSICALOFFSETY);

        // Obtain info about printer resolution
        xSize = GetDeviceCaps(hDC, HORZRES);
        ySize = GetDeviceCaps(hDC, VERTRES);
        xRes  = GetDeviceCaps(hDC, LOGPIXELSX);
        yRes  = GetDeviceCaps(hDC, LOGPIXELSY);

        // Stretch to best fit, if necessary.  Maintain the same aspect ratio.
        if (CHECK_DWFLAG(lpDIBInfo->dwPrintOption,ICMV_PRINT_BESTFIT))
        {
            bStretch = TRUE;
            dy = ySize - (yRes/2);
            dx = ((int)((long)dy * BITMAPWIDTH(lpBi)/abs(BITMAPHEIGHT(lpBi)) ));

            // Make sure the image still fits.
            if (dx > xSize)
            {
                dx = xSize - xRes/2;
                dy = ((int)((long)dx * abs(BITMAPHEIGHT(lpBi))/BITMAPWIDTH(lpBi)));
            }
        }
        else // Actual size
        {
            bStretch = FALSE;
            dx = BITMAPWIDTH(lpBi);
            dy = abs(BITMAPHEIGHT(lpBi));
        }

        // Set ICM mode according to properties set in ICMINFO structure
        iICMMode = ICM_OFF;
        if (CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ENABLE_ICM))
        {
            if (!CHECK_DWFLAG(lpDIBInfo->dwICMFlags, ICMVFLAGS_ICM20))
            {
                TCHAR   stProfile[MAX_PATH];


                // ICM enabled, using ICM10--inside DC

                iICMMode = ICM_ON;
                wsprintf(stProfile, __TEXT("%s\\%s"), gstProfilesDir, lpDIBInfo->lpszPrinterProfile);
                bRC = SetICMProfile(hDC, (LPTSTR)stProfile);
                DebugMsg(__TEXT("PrintImage:  Inside DC using profile \"%s\".\r\n"), stProfile);
                if (!bRC)
                {
                    DebugMsg(__TEXT("Print.C, PrintImage:  SetICMProfile() FAILED!!\r\n"));
                }
            }
            else
            {
                iICMMode = ICM_DONE_OUTSIDEDC;
            }
        }
        iPrevICMMode = SetICMMode(hDC, iICMMode);  // Explicitly set ICMMode--don't count on any behavior
        if (0 == iPrevICMMode)
        {
            DebugMsg(__TEXT("PRINT.C : PrintImage : SetICMMode(%d) FAILED \r\n"), iICMMode);
        }
        PrintDIB(hDIB, hDC, iXOrigin, iYOrigin, dx, dy, bStretch);

        // Terminate printing and delete the printer DC
        TermPrinting(hDC);
        DeleteDC(hDC);
    }

    // Delete DIB transform for printer if necessary
    GlobalUnlock(hDIB);
    if (NULL != hDIBPrinter)
    {
        GlobalFree(hDIBPrinter);
    }

    GlobalUnlock(GlobalHandle(lpDIBInfo));

    return TRUE;
}   // End of function PrintImage


// //////////////////////////////////////////////////////////////////////////
//
//  FUNCTION:  PrintDlgProc (hWnd, unsigned , WORD , DWORD )
//
//  PURPOSE:  Dialog function for the "Cancel Printing" dialog. It sets
//              the abort flag if the user presses <Cancel>.
//
// //////////////////////////////////////////////////////////////////////////
BOOL FAR PASCAL PrintDlgProc (HWND hDlg, unsigned iMessage, WORD wParam, DWORD lParam)
{

    lParam = lParam;  // Eliminates 'unused formal parameter' warning
    wParam = wParam;  // Eliminates 'unused formal parameter' warning

    switch (iMessage)
    {
        case WM_INITDIALOG:
            EnableMenuItem (GetSystemMenu (hDlg, FALSE), SC_CLOSE, MF_GRAYED);
            break;

        case WM_COMMAND:
            gbUserAbort = TRUE;
            EnableWindow (ghWndParent, TRUE);
            DestroyWindow (hDlg);
            ghDlgPrint = 0;
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

// //////////////////////////////////////////////////////////////////////////
//
//  FUNCTION:  AbortProc (HDC hPrnDC, short nCode)
//
//  PURPOSE:  Checks message queue for messages from the "Cancel Printing"
//              dialog. If it sees a message, (this will be from a print
//              cancel command), it terminates.
//
//  RETURNS:  Inverse of Abort flag
//
// //////////////////////////////////////////////////////////////////////////
BOOL FAR PASCAL AbortProc (HDC hPrnDC, short nCode)
{
    MSG   msg;

    nCode = nCode;  // Eliminates 'unused formal paramater' warning
    hPrnDC = hPrnDC;  // Eliminates 'unused formal paramater' warning
    while (!gbUserAbort && PeekMessage (&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (!ghDlgPrint || !IsDialogMessage(ghDlgPrint, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }
    return(!gbUserAbort);
}

//////////////////////////////////////////////////////////////////////////
//  Function:  InitPrinting
//
//  Description:
//    Sets up print job.
//
//  Parameters:
//    @@@
//
//  Returns:
//    HDC PASCAL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
static HDC PASCAL InitPrinting(HWND hWnd, LPTSTR lpszFriendlyName, PDEVMODE pDevMode)
{
    // Local variables
    HDC       hDC;
    DOCINFO   diDocInfo;      // Document infor for StartDoc call
    BOOL      bRetVal;

    //  Initialize variables
    hDC = NULL;
    bRetVal = TRUE;
    gbUserAbort = FALSE;
    ghWndParent = hWnd;
    SetLastError(0);

    hDC = GetPrinterDC(lpszFriendlyName, pDevMode);
    if (hDC == NULL)
    {
        DebugMsg(__TEXT("InitPrinting : GetPrinterDC returned NULL\r\n"));
        return(NULL);
    }

    // Fill in the DOCINFO structure
    diDocInfo.cbSize = sizeof(DOCINFO);
    diDocInfo.lpszDocName = lpszFriendlyName;
    diDocInfo.lpszOutput = NULL;
    diDocInfo.lpszDatatype = NULL;
    diDocInfo.fwType = 0;

    // Start the document
    if (StartDoc(hDC, &diDocInfo)== SP_ERROR)
    {
        ErrMsg(hWnd, __TEXT("InitPrinting:  StartDoc FAILED"));
        bRetVal = FALSE;
        goto exit;
    }

    // Start the page
    if (StartPage(hDC) == SP_ERROR)
    {
        DISPLAY_LASTERROR(LASTERROR_NOALLOC,GetLastError());
        ErrMsg(hWnd, __TEXT("InitPrinting:  StartPage FAILED"));
        AbortDoc(hDC);
        bRetVal = FALSE;
    }

    exit:
    if (bRetVal == FALSE)
    {
        EnableWindow(   ghWndParent,    TRUE);
        DestroyWindow(ghDlgPrint);
    }
    return(hDC);
}   // End of function InitPrinting

//////////////////////////////////////////////////////////////////////////
//  Function:  TermPrinting
//
//  Description:
//    Terminates the print job.
//
//  Parameters:
//    @@@
//
//  Returns:
//    void PASCAL
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
static void PASCAL TermPrinting(HDC hDC)
{
    // Local variables
    if (EndPage(hDC) == SP_ERROR)
    {
        ErrMsg(NULL, __TEXT("TermPrinting:  EndPage FAILED"));
    }
    if (EndDoc(hDC) == SP_ERROR)
    {
        ErrMsg(NULL, __TEXT("TermPrinting:  EndDoc FAILED"));
    }

    // Dstroy the dialog
    EnableWindow(ghWndParent, TRUE);
    DestroyWindow(ghDlgPrint);
}   // End of function TermPrinting





//////////////////////////////////////////////////////////////////////////
//  Function:  GetDefaultPrinterDC
//
//  Description:
//    Returns a DC for the default printer.
//
//  Parameters:
//    @@@
//
//  Returns:
//    HDC
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
HDC GetDefaultPrinterDC()
{
    HDC     hDC;
    LPTSTR  lpszPrinterName;


    //  Initialize variables
    hDC = NULL;

    lpszPrinterName = GetDefaultPrinterName();
    if (lpszPrinterName != NULL)
    {
        hDC = GetPrinterDC(lpszPrinterName, NULL);
        GlobalFree(lpszPrinterName);
    }
    else
    {
        DebugMsg(__TEXT("GetDefaultPrinterDC:  Could not obtain default printer name.\r\n"));
    }

    return hDC;
}   // End of function GetDefaultPrinterDC



//////////////////////////////////////////////////////////////////////////
//  Function:  GetDefaultPrinterDevMode
//
//  Description:
//    Returns a printer's default devmode.
//
//  Parameters:
//    @@@
//
//  Returns:
//    PDEVMODE
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
PDEVMODE GetDefaultPrinterDevMode(LPTSTR lpszPrinterName)
{
    LONG        lDevModeSize;
    HANDLE      hDevMode;
    PDEVMODE    pDevMode = NULL;


    lDevModeSize = DocumentProperties(NULL, NULL, lpszPrinterName, NULL, NULL, 0);
    if (lDevModeSize > 0)
    {
        hDevMode = GlobalAlloc(GHND, lDevModeSize);
        pDevMode = (PDEVMODE) GlobalLock(hDevMode);
        DocumentProperties(NULL, NULL, lpszPrinterName, pDevMode, NULL, DM_OUT_BUFFER);
    }
    else
    {
        DebugMsg(__TEXT("GetDefaultPrinterDevMode:  Could not obtain printer's devmode.\r\n"));
    }

    return pDevMode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\regutil.c ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    REGUTIL.C
//
//  PURPOSE:
//    Registry access functions.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// Windows Header Files:
#pragma warning(disable:4001)   // Single-line comment warnings
#pragma warning(disable:4115)   // Named type definition in parentheses
#pragma warning(disable:4201)   // Nameless struct/union warning
#pragma warning(disable:4214)   // Bit field types other than int warnings
#pragma warning(disable:4514)   // Unreferenced inline function has been removed

// Windows Header Files:
#include <Windows.h>
#include <WindowsX.h>

// Restore the warnings--leave the single-line comment warning OFF
#pragma warning(default:4115)   // Named type definition in parentheses
#pragma warning(default:4201)   // Nameless struct/union warning
#pragma warning(default:4214)   // Bit field types other than int warnings

// C RunTime Header Files

// Local Header Files

// local definitions

// default settings

// external functions

// external data

// public data

// private data

// public functions

//////////////////////////////////////////////////////////////////////////
//  Function:  GetRegistryString
//
//  Description:
//    Retrieves the string associated with the specified key in the registry.
//
//  Parameters:
//    @@@
//
//  Returns:
//    LPTSTR   Pointer to registry string.  NULL upon failure.
//
//  Comments:
//
//
//////////////////////////////////////////////////////////////////////////
LPTSTR GetRegistryString(HKEY hKeyClass, LPTSTR lpszSubKey, LPTSTR lpszValueName)
{
    // Local variables
    HKEY          hKey;                 // Registry key
    LPTSTR         lpszKeyValue;         // Buffer for key name
    DWORD         dwKeySize;            // Size of key value
    DWORD         dwKeyDataType;        // Type of data stored in key
    LONG          lRC;                  // Return code

    //  Initialize variables
    dwKeyDataType = 0;
    dwKeySize = 0;
    hKey = NULL;

    lRC = RegOpenKey(hKeyClass, lpszSubKey, &hKey);
    if (lRC != ERROR_SUCCESS)
    {
        return(NULL);
    }

    // Got key, get value.  First, get the size of the key.
    lRC = RegQueryValueEx(hKey, lpszValueName, NULL, NULL, NULL, &dwKeySize);
    if (lRC != ERROR_SUCCESS)
    {
        return(NULL);
    }
    if (dwKeySize <= 1)  // Registry will return "" if no printers installed
    {
        return(NULL);
    }

    lpszKeyValue = GlobalAlloc(GPTR, (++dwKeySize));
    if (lpszKeyValue == NULL)
    {
        return(NULL);
    }

    lRC = RegQueryValueEx(hKey, lpszValueName, NULL, &dwKeyDataType, (LPBYTE)lpszKeyValue, &dwKeySize);
    return(lpszKeyValue);
}   // End of function GetRegistryString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\alpha.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   alpha.cxx

Abstract:

   alpha blending tests

Author:

   Mark Enstrom   (marke)  29-Apr-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.h"
#include <stdlib.h>
#include "disp.h"
#include "resource.h"

/**************************************************************************\
* hCreateAlphaStretchDIB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/8/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define FORMAT_ALPHA  0x01
#define FORMAT_32_RGB 0x02
#define FORMAT_32_GRB 0x04
#define FORMAT_16_555 0x08
#define FORMAT_16_565 0x10
#define FORMAT_16_664 0x20

//
// inter-test delay
//

ULONG  gAlphaSleep = 100;

extern ULONG htPalette[256];
extern ULONG htPaletteRGBQUAD[256];
extern ULONG DefPalette[20];
extern ULONG DefPaletteRGBQUAD[20];

ULONG    ulBpp[] = {          32,           32,            32,24,           16,           16,           16,8,4,1,0};
ULONG    ulFor[] = {FORMAT_ALPHA,FORMAT_32_RGB, FORMAT_32_GRB, 0,FORMAT_16_555,FORMAT_16_565,FORMAT_16_664,0,0,0,0};
PCHAR    pFormatStr[] = {
                        " 32 bpp RGBA",
                        " 32 bpp RGB",
                        " 32 bpp GRB",
                        " 24 bpp",
                        " 16 bpp 555",
                        " 16 bpp 565",
                        " 16 BPP 664",
                        "  8 bpp DIB_RGB_COLORS",
                        "  4 bpp DIB_RGB_COLORS",
                        "  1 bpp DIB_RGB_COLORS",
                        };

ULONG    ulBppDIB[] = {          32,32,24,           16,           16,8,8,4,4,1,1,0};
ULONG    ulForDIB[] = {FORMAT_ALPHA, 0, 0,FORMAT_16_555,FORMAT_16_565,0,1,0,1,0,1,0};

PCHAR    pFormatStrDIB[] = {
                        " 32 bpp RGBA",
                        " 32 bpp no Alpha",
                        " 24 bpp",
                        " 16 bpp 555",
                        " 16 bpp 565",
                        "  8 bpp DIB_RGB_COLORS",
                        "  8 bpp DIB_PAL_COLORS",
                        "  4 bpp DIB_RGB_COLORS",
                        "  4 bpp DIB_PAL_COLORS",
                        "  1 bpp DIB_RGB_COLORS",
                        "  1 bpp DIB_PAL_COLORS"
                        };

//
// translate RGB [3 3 2] into halftone palette index
//

BYTE gHalftoneColorXlate332[] = {
    0x00,0x5f,0x85,0xfc,0x21,0x65,0xa6,0xfc,0x21,0x65,0xa6,0xcd,0x27,0x6b,0x8a,0xcd,
    0x2d,0x70,0x81,0xd3,0x33,0x76,0x95,0xd9,0x33,0x76,0x95,0xd9,0xfa,0x7b,0x9b,0xfe,
    0x1d,0x60,0xa2,0xfc,0x22,0x66,0x86,0xc8,0x22,0x66,0x86,0xc8,0x28,0x6c,0x8b,0xce,
    0x2e,0x71,0x90,0xd4,0x34,0x77,0x96,0xda,0x34,0x77,0x96,0xda,0xfa,0x7c,0x9c,0xdf,
    0x1d,0x60,0xa2,0xc5,0x22,0x66,0x86,0xc8,0x22,0x13,0x86,0xc8,0x28,0x12,0x8b,0xce,
    0x2e,0x71,0x90,0xd4,0x34,0x77,0x96,0xda,0x34,0x77,0x96,0xda,0x39,0x7c,0x9c,0xdf,
    0x1e,0x61,0x87,0xc5,0x23,0x67,0x8c,0xc9,0x23,0x12,0x8c,0xc9,0x29,0x6d,0xae,0xe6,
    0x2f,0x72,0x91,0xd5,0x35,0x97,0x9d,0xdb,0x35,0x97,0x9d,0xdb,0x39,0xe4,0xc0,0xe8,

    0x1f,0x62,0x83,0xc6,0x24,0x68,0x82,0xca,0x24,0x68,0x82,0xca,0x2a,0x6e,0x8d,0xd0,
    0x30,0x73,0x92,0xd6,0x36,0x78,0xf7,0xdc,0x36,0x78,0x98,0xdc,0x3a,0x7d,0x9e,0xe1,
    0x20,0x63,0x84,0x80,0x25,0x69,0x88,0xcb,0x25,0x69,0x88,0xcb,0x2b,0x6f,0x8e,0xd1,
    0x31,0x74,0xf7,0xd7,0x37,0x79,0xef,0x09,0x37,0x79,0x08,0xdd,0x3b,0x7e,0x9f,0xe2,
    0x20,0x63,0x84,0x80,0x25,0x69,0x88,0xcb,0x25,0x69,0x88,0xcb,0x2b,0x6f,0x8e,0xd1,
    0x31,0x74,0x93,0xd7,0x37,0x79,0x99,0xdd,0x37,0x79,0x99,0xdd,0x3b,0x7e,0x9f,0xe2,
    0xf9,0x64,0x89,0xfd,0x26,0x6a,0x8f,0xcc,0x26,0x17,0x8f,0xcc,0x2c,0xe3,0xb1,0xe7,
    0x32,0x75,0x94,0xd8,0x38,0x7a,0x9a,0xde,0x38,0x7a,0x9a,0xde,0xfb,0xe5,0xa0,0xff
    };

/**************************************************************************\
* hCreateAlphaStretchBitmap - create and init DIBSection based on input
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

HBITMAP
hCreateAlphaStretchBitmap(
    HDC   hdc,
    ULONG BitsPerPixel,
    ULONG ColorFormat,
    LONG  xDib,
    LONG  yDib
    )
{
    PBITMAPINFO pbmi;
    ULONG       ux,uy;
    PULONG      pDib;
    HBITMAP     hdib = NULL;
    LONG        Compression = BI_RGB;

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    if (pbmi)
    {
        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

        //
        // prepare compression and color table
        //

        if ((BitsPerPixel == 32) && ((ColorFormat & FORMAT_32_RGB)) && 
            (Win32VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS))
        {
            pulMask[0] = 0x0000ff;
            pulMask[1] = 0x00ff00;
            pulMask[2] = 0xff0000;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 32) && ((ColorFormat & FORMAT_32_GRB)) && 
            (Win32VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS))
        {
            pulMask[0] = 0x00ff00;
            pulMask[1] = 0xff0000;
            pulMask[2] = 0x0000ff;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
        {
            pulMask[0] = 0xf800;
            pulMask[1] = 0x07e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
        {
            pulMask[0] = 0x7c00;
            pulMask[1] = 0x03e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_664))
        {
            pulMask[0] = 0xFC00;
            pulMask[1] = 0x03F0;
            pulMask[2] = 0x000f;
            Compression = BI_BITFIELDS;
        }
        else if (BitsPerPixel == 8)
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<256;ulIndex++)
            {
                pulMask[ulIndex] = htPaletteRGBQUAD[ulIndex];
            }
        }
        else if (BitsPerPixel == 4)
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<8;ulIndex++)
            {
                pulMask[ulIndex]    = DefPaletteRGBQUAD[ulIndex];
                pulMask[15-ulIndex] = DefPaletteRGBQUAD[19-ulIndex];
            }
        }
        else if (BitsPerPixel == 1)
        {
            pulMask[0] = DefPaletteRGBQUAD[0];
            pulMask[1] = DefPaletteRGBQUAD[19];
        }

        //
        // create DIB
        //

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = xDib;
        pbmi->bmiHeader.biHeight          = yDib;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = BitsPerPixel;
        pbmi->bmiHeader.biCompression     = Compression;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

        if (hdib == NULL)
        {
            CHAR tmsg[256];

            //wsprintf(tmsg,"Format = %libpp, Comp = %li",BitsPerPixel,Compression);
            //MessageBox(NULL,"Can't create stretch DIBSECTION",tmsg,MB_OK);
        }
        else
        {

            //
            // init 32 bpp dib
            //

            if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_ALPHA))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                    }
                }
            }
            else if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_32_RGB))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = (blue << 16) | (green << 8) | (red);
                    }
                }
            }
            else if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_32_GRB))
            {
                PULONG ptmp = pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = (blue) | (red << 8) | (green << 16);
                    }
                }
            }
            else if (BitsPerPixel == 24)
            {
                PBYTE ptmp  = (PBYTE)pDib;
                PBYTE pscan = ptmp;
                LONG  Delta = ((yDib * 3) + 3) & ~3;

                //
                // since scan line is 128, alignment works. If width changes, this breaks
                //

                for (uy=0;uy<yDib;uy++)
                {
                    ptmp = pscan;
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = (blue);
                        *ptmp++ = (green);
                        *ptmp++ = (red);
                    }
                    pscan += Delta;
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 8) |
                                  ((green & 0xfc) << 3) |
                                  (blue >> 3);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 7) |
                                  ((green & 0xf8) << 2) |
                                  (blue >> 3);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_664))
            {
                PUSHORT ptmp = (PUSHORT)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xfc)   << 8) |
                                  ((green & 0xfc) << 2) |
                                  (blue >> 4);
                    }
                }
            }
            else if (BitsPerPixel == 8)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<xDib;ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE blue  = (cx*2);
                        BYTE green = (cy*2);
                        BYTE red   = 255 - cx - cy;
                        *ptmp++ = gHalftoneColorXlate332[(red & 0xe0) | ((green & 0xe0) >> 3) | ((blue & 0xc0) >> 6)];
                    }
                }
            }
            else if (BitsPerPixel == 4)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<(xDib/2);ux++)
                    {
                        ULONG cx   = ux & 0x7f;
                        ULONG cy   = uy & 0x7f;
                        BYTE Color = ((cx & 0x60) >> 3) | ((cy >> 5));

                        *ptmp++ = Color | (Color << 4);
                    }
                }
            }
            else if (BitsPerPixel == 1)
            {
                PBYTE ptmp = (PBYTE)pDib;

                for (uy=0;uy<yDib;uy++)
                {
                    for (ux=0;ux<(xDib/8);ux++)
                    {
                        *ptmp++ = 0;
                    }
                }
            }
        }

        //
        // draw text into bitmap
        //

        if (hdib)
        {

            ULONG             ux,uy;

            HDC hdcm  = CreateCompatibleDC(hdc);

            //
            // display over black
            //

            HPALETTE hpal = CreateHtPalette(hdc);

            SelectObject(hdcm,hdib);

            SelectPalette(hdcm,hpal,FALSE);

            RealizePalette(hdcm);

            SelectObject(hdc,hTestFont);
            SelectObject(hdcm,hTestFont);
            SetTextColor(hdcm,RGB(255,255,255));
            SetBkMode(hdcm,TRANSPARENT);

            TextOut(hdcm,0,  0," 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F",47);
            TextOut(hdcm,0, 10,"10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F",47);
            TextOut(hdcm,0, 20,"20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F",47);
            TextOut(hdcm,0, 30,"30 33 32 33 34 33 36 37 38 39 3A 3B 3C 3D 3E 3F",47);
            TextOut(hdcm,0, 40,"40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F",47);
            TextOut(hdcm,0, 50,"50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F",47);
            TextOut(hdcm,0, 60,"60 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F",47);
            TextOut(hdcm,0, 70,"70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F",47);
            TextOut(hdcm,0, 80,"80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F",47);
            TextOut(hdcm,0, 90,"90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F",47);
            TextOut(hdcm,0,100,"a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 AA AB AC AD AE AF",47);
            TextOut(hdcm,0,110,"b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 BA BB BC BD BE BF",47);

            DeleteDC(hdcm);
            DeleteObject(hpal);
        }

        LocalFree(pbmi);
    }

    return(hdib);
}

/******************************Public*Routine******************************\
* vTestAlphaStretch - routine is called by format specific routines to do
* all drawing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunAlphaStretch(
    HDC     hdc,
    HBITMAP hdib
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};
    RECT          rect;


    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    //
    //  create a test DIBSection
    //

    {
        PBITMAPINFO       pbmi;
        ULONG             ux,uy;
        PULONG            pDib;

        HDC hdcm  = CreateCompatibleDC(hdc);

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        hpalOld = SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        SetTextColor(hdc,RGB(255,255,255));
        SetBkMode(hdc,TRANSPARENT);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = 0;
        BlendFunction.SourceConstantAlpha = Alphas[3];

        xpos = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 128,128",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0  64, 64",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 256,256",28);

        xpos =  10;
        ypos += 12;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,64,64,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,256,256,BlendFunction);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64   0 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -64 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64 -64 128,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,-64,0,128,128,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,0,-64,128,128,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, -64,-64,128,128,BlendFunction);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 192,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -32 128,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32   0 192,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,-32,-32,192,192,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,0,-32,128,192,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, -32,0,192,128,BlendFunction);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 42,42",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"128-10,128-10  10 10 41   5 ",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -1000,-1000,100",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm,-32,-32,42,42,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos+128-10,ypos+128-10,10,10,hdcm,10,10,41,5,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, -1000,-10000,1000,1000,BlendFunction);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        //
        // free objects
        //

        DeleteDC(hdcm);
    }

ErrorExit:

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
* vTestAlphaStretch - routine is called by format specific routines to do
* all drawing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunStretch(
    HDC     hdc,
    HBITMAP hdib
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};
    RECT          rect;


    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    //
    //  create a test DIBSection
    //

    {
        PBITMAPINFO       pbmi;
        ULONG             ux,uy;
        PULONG            pDib;

        HDC hdcm  = CreateCompatibleDC(hdc);

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        hpalOld = SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        SetTextColor(hdc,RGB(255,255,255));
        SetBkMode(hdc,TRANSPARENT);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
        BlendFunction.SourceConstantAlpha = Alphas[3];

        xpos = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 128,128",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0  64, 64",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 256,256",28);

        xpos =  10;
        ypos += 12;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm, 0,0,64,64,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm, 0,0,256,256,SRCCOPY);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64   0 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -64 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64 -64 128,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm,-64,0,128,128,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm,0,-64,128,128,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm, -64,-64,128,128,SRCCOPY);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 192,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -32 128,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32   0 192,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm,-32,-32,192,192,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm,0,-32,128,192,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm, -32,0,192,128,SRCCOPY);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 42,42",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"128-10,128-10  10 10 41   5 ",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -1000,-1000,100",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm,-32,-32,42,42,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos+128-10,ypos+128-10,10,10,hdcm,10,10,41,5,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchBlt(hdc,xpos      ,ypos,128,128,hdcm, -1000,-10000,1000,1000,SRCCOPY);

        xpos += 250;
        BitBlt(hdc,xpos,ypos,128,128,hdcm,0,0,SRCCOPY);

        //
        // free objects
        //

        DeleteDC(hdcm);
    }

ErrorExit:

    SelectPalette(hdc,hpalOld,FALSE);
    DeleteObject(hpal);
}

/**************************************************************************\
* pbmiCreateAlphaStretchDIB - create bitmapinfo and alloc and init bits
*                             based on input
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

PBITMAPINFO
pbmiCreateAlphaStretchDIB(
    HDC      hdc,
    ULONG    BitsPerPixel,
    ULONG    ColorFormat,
    PVOID   *pBits,
    HBITMAP *phdib
    )
{
    PBITMAPINFO pbmi;
    ULONG       ux,uy;
    HBITMAP     hdib = NULL;
    LONG        Compression = BI_RGB;
    PULONG      pDib = NULL;
    LONG        BitmapSize = 0;
    ULONG       iUsage = DIB_RGB_COLORS;

    //
    // prepare src DC log colors
    //

    HPALETTE hpal = CreateHtPalette(hdc);
    HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // alloc pbmi, caller must free
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    if (pbmi)
    {
        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];


        //
        // prepare compression and color table
        //

        if ((BitsPerPixel == 32) && (!(ColorFormat & FORMAT_ALPHA)) && 
            (Win32VersionInformation.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS))
        {
            pulMask[0] = 0x0000ff;
            pulMask[1] = 0x00ff00;
            pulMask[2] = 0xff0000;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
        {
            pulMask[0] = 0xf800;
            pulMask[1] = 0x07e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
        {
            pulMask[0] = 0x7c00;
            pulMask[1] = 0x03e0;
            pulMask[2] = 0x001f;
            Compression = BI_BITFIELDS;
        }
        else if ((BitsPerPixel == 8) && (ColorFormat == DIB_RGB_COLORS))
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<256;ulIndex++)
            {
                pulMask[ulIndex] = htPaletteRGBQUAD[ulIndex];
            }
        }
        else if ((BitsPerPixel == 8) && (ColorFormat == DIB_PAL_COLORS))
        {
            ULONG ulIndex;
            PUSHORT pusIndex = (PUSHORT)pulMask;

            for (ulIndex=0;ulIndex<256;ulIndex++)
            {
                pusIndex[ulIndex] = (USHORT)ulIndex;
            }
            iUsage = DIB_PAL_COLORS;
        }
        else if ((BitsPerPixel == 4) && (ColorFormat == DIB_RGB_COLORS))
        {
            ULONG ulIndex;

            for (ulIndex=0;ulIndex<8;ulIndex++)
            {
                pulMask[ulIndex]    = DefPaletteRGBQUAD[ulIndex];
                pulMask[15-ulIndex] = DefPaletteRGBQUAD[20-ulIndex];
            }
            BitmapSize = (128 * 128)/2;
        }
        else if ((BitsPerPixel == 4) && (ColorFormat == DIB_PAL_COLORS))
        {
            ULONG ulIndex;
            PUSHORT pusIndex = (PUSHORT)pulMask;

            for (ulIndex=0;ulIndex<8;ulIndex++)
            {
                pusIndex[ulIndex] = (USHORT)ulIndex;
                pusIndex[15-ulIndex] = (USHORT)(255-ulIndex);
            }
            iUsage = DIB_PAL_COLORS;
        }
        else if ((BitsPerPixel == 1) && (ColorFormat == DIB_RGB_COLORS))
        {
            pulMask[0] = DefPaletteRGBQUAD[0];
            pulMask[1] = DefPalette[19];
            BitmapSize = (128 * 128)/8;
        }
        else if ((BitsPerPixel == 1) && (ColorFormat == DIB_PAL_COLORS))
        {
            ULONG ulIndex;
            PUSHORT pusIndex = (PUSHORT)pulMask;

            pusIndex[0] = 0;
            pusIndex[1] = 255;
            iUsage = DIB_PAL_COLORS;
        }

        //
        // init bitmap info
        //

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = 128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = BitsPerPixel;
        pbmi->bmiHeader.biCompression     = Compression;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        hdib  = CreateDIBSection(hdc,pbmi,iUsage,(VOID **)&pDib,NULL,0);

        if (hdib == NULL)
        {
            CHAR tmsg[256];

            //wsprintf(tmsg,"Format = %libpp, Comp = %li",BitsPerPixel,Compression);
            //MessageBox(NULL,"Can't create stretchDIB DIBSECTION",tmsg,MB_OK);
            //LocalFree(pbmi);
            //return(NULL);
        }
        else
        {
            //
            // init 32 bpp dib
            //
    
            if ((BitsPerPixel == 32) && (ColorFormat & FORMAT_ALPHA))
            {
                PULONG ptmp = pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        BYTE alpha = 0xff;
                        *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                    }
                }
            }
            else if (BitsPerPixel == 32)
            {
                PULONG ptmp = pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        *ptmp++ = (blue << 16) | (green << 8) | (red);
                    }
                }
            }
            else if (BitsPerPixel == 24)
            {
                PBYTE ptmp = (PBYTE)pDib;
    
                //
                // since scan line is 128, alignment works. If width changes, this breaks
                //
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        *ptmp++ = (blue);
                        *ptmp++ = (green);
                        *ptmp++ = (red);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_565))
            {
                PUSHORT ptmp = (PUSHORT)pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 8) |
                                  ((green & 0xfc) << 3) |
                                  (blue >> 3);
                    }
                }
            }
            else if ((BitsPerPixel == 16) && (ColorFormat & FORMAT_16_555))
            {
                PUSHORT ptmp = (PUSHORT)pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        BYTE alpha = 0xff;
                        *ptmp++ = ((red & 0xf8)   << 7) |
                                  ((green & 0xf8) << 2) |
                                  (blue >> 3);
                    }
                }
            }
            else if (BitsPerPixel == 8)
            {
                PBYTE ptmp = (PBYTE)pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        BYTE blue  = (ux*2);
                        BYTE green = (uy*2);
                        BYTE red   = 255 - ux - uy;
                        *ptmp++ = gHalftoneColorXlate332[(red & 0xe0) | ((green & 0xe0) >> 3) | ((blue & 0xc0) >> 6)];
                    }
                }
            }
            else if (BitsPerPixel == 4)
            {
                PBYTE ptmp = (PBYTE)pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<(128/2);ux++)
                    {
                        BYTE Color = ((ux & 0x60) >> 3) | ((uy >> 5));
    
                        *ptmp++ = Color | (Color << 4);
                    }
                }
            }
            else if (BitsPerPixel == 1)
            {
                PBYTE ptmp = (PBYTE)pDib;
    
                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<(128/8);ux++)
                    {
                        *ptmp++ = 0;
                    }
                }
            }
        }
    }

    //
    //  create a test memory DC
    //

    if (hdib)
    {
        //
        // write text into DIB
        //

        SelectObject(hdc,hTestFont);

        HDC hdcm  = CreateCompatibleDC(hdc);

        //
        // display over black
        //

        SelectObject(hdcm,hdib);
        SelectPalette(hdcm,hpal,FALSE);
        RealizePalette(hdcm);

        SelectObject(hdcm,hTestFont);

        SetTextColor(hdcm,RGB(255,255,255));
        SetBkMode(hdcm,TRANSPARENT);

        TextOut(hdcm,0,  0," 0  1  2  3  4  5  6  7  8  9 ",30);
        TextOut(hdcm,0, 10,"10 11 12 13 14 15 16 17 18 19 ",30);
        TextOut(hdcm,0, 20,"20 21 22 23 24 25 26 27 28 29 ",30);
        TextOut(hdcm,0, 30,"30 33 32 33 34 33 36 37 38 39 ",30);
        TextOut(hdcm,0, 40,"40 41 42 43 44 45 46 47 48 49 ",30);
        TextOut(hdcm,0, 50,"50 51 52 53 54 55 56 57 58 59 ",30);
        TextOut(hdcm,0, 60,"60 61 62 63 64 65 66 67 68 69 ",30);
        TextOut(hdcm,0, 70,"70 71 72 73 74 75 76 77 78 79 ",30);
        TextOut(hdcm,0, 80,"80 81 82 83 84 85 86 87 88 89 ",30);
        TextOut(hdcm,0, 90,"90 91 92 93 94 95 96 97 98 99 ",30);
        TextOut(hdcm,0,100,"a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 ",30);
        TextOut(hdcm,0,110,"b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ",30);

        DeleteDC(hdcm);
    }

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);

    *pBits = (PVOID)pDib;
    *phdib = hdib;

    if (hdib == NULL)
    {
        LocalFree(pbmi);
        pbmi = NULL;
    }

    return(pbmi);
}

/******************************Public*Routine******************************\
* vTestAlphaStretch - routine is called by format specific routines to do
* all drawing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunAlphaStretchDIB(
    HDC         hdc,
    PBITMAPINFO pbmi,
    PVOID       pBits,
    ULONG       iUsage
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};
    RECT          rect;

    if ((iUsage != DIB_RGB_COLORS) && (iUsage != DIB_PAL_COLORS))
    {
        iUsage = DIB_RGB_COLORS;
    }

    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    {
        ULONG             ux,uy;

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        hpalOld = SelectPalette(hdc,hpal,FALSE);

        RealizePalette(hdc);

        SetTextColor(hdc,RGB(255,255,255));
        SetBkMode(hdc,TRANSPARENT);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
        BlendFunction.SourceConstantAlpha = Alphas[3];

        xpos = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 128,128",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0  64, 64",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 256,256",28);

        xpos =  10;
        ypos += 12;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage, 0,0,128,128,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage, 0,0,64,64,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage, 0,0,256,256,BlendFunction);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64   0 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -64 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64 -64 128,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage,-64,0,128,128,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage,0,-64,128,128,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage, -64,-64,128,128,BlendFunction);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 192,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -32 128,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32   0 192,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage,-32,-32,192,192,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage,0,-32,128,192,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage, -32,0,192,128,BlendFunction);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 42,42",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"128-10,128-10  10 10 41   5 ",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -1000,-1000,100",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage,-32,-32,42,42,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos+128-10,ypos+128-10,10,10,pBits,pbmi,iUsage,10,10,41,5,BlendFunction);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pBits,pbmi,iUsage, -1000,-10000,1000,1000,BlendFunction);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        //
        // free objects
        //

    }

ErrorExit:

    SelectPalette(hdc,hpalOld,TRUE);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
* vTestAlphaStretch - routine is called by format specific routines to do
* all drawing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunStretchDIB(
    HDC         hdc,
    PBITMAPINFO pbmi,
    PVOID       pBits,
    ULONG       iUsage
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal;
    HPALETTE      hpalOld;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};
    RECT          rect;

    if ((iUsage != DIB_RGB_COLORS) && (iUsage != DIB_PAL_COLORS))
    {
        iUsage = DIB_RGB_COLORS;
    }

    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    {
        ULONG             ux,uy;

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        hpalOld = SelectPalette(hdc,hpal,FALSE);

        RealizePalette(hdc);

        SetTextColor(hdc,RGB(255,255,255));
        SetBkMode(hdc,TRANSPARENT);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
        BlendFunction.SourceConstantAlpha = Alphas[3];

        xpos = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 128,128",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0  64, 64",28);

        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0   0 256,256",28);

        xpos =  10;
        ypos += 12;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128, 0,0,128,128,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128, 0,0,64,64,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128, 0,0,256,256,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64   0 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -64 128,128",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -64 -64 128,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128,-64,0,128,128,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128,0,-64,128,128,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128, -64,-64,128,128,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 192,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128,   0 -32 128,192",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32   0 192,128",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128,-32,-32,192,192,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128,0,-32,128,192,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128, -32,0,192,128,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        ypos += 180;
        xpos  = 10;

        TextOut(hdc,xpos,ypos,"- - 128 128, -32 -32 42,42",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"128-10,128-10  10 10 41   5 ",28);
        xpos += 250;

        TextOut(hdc,xpos,ypos,"- - 128 128, -1000,-1000,100",28);

        ypos += 12;
        xpos = 10;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128,-32,-32,42,42,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos+128-10,ypos+128-10,10,10,10,10,41,5,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;

        PatBlt(hdc,xpos,ypos,128,128,PATCOPY);
        StretchDIBits(hdc,xpos      ,ypos,128,128, -1000,-10000,1000,1000,pBits,pbmi,iUsage,SRCCOPY);

        xpos += 250;
        SetDIBitsToDevice(hdc,xpos,ypos,128,128,0,0,0,128,pBits,pbmi,iUsage);

        //
        // free objects
        //

    }

ErrorExit:

    SelectPalette(hdc,hpalOld,FALSE);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestAlphaStretch
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaStretch(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunAlphaStretch(hdc,hdib);
            DeleteObject(hdib);
        }
    }
    else 
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunAlphaStretch(hdc,hdib);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestStretch
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestStretch(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunStretch(hdc,hdib);
            DeleteObject(hdib);
        }
    }
    else 
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunStretch(hdc,hdib);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestAlphaStretchDIB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaStretchDIB(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);


    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        PVOID       pBits = NULL;
        PBITMAPINFO pbmi  = NULL;
        HBITMAP     hdib  = NULL;
        
        pbmi = pbmiCreateAlphaStretchDIB(hdc,ulBppDIB[ulIndex],ulForDIB[ulIndex],&pBits,&hdib);
        
        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStrDIB[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);
        
            vRunAlphaStretchDIB(hdc,pbmi,pBits,ulForDIB[ulIndex]);
            DeleteObject(hdib);
        }
    }
    else
    {
        while (ulBppDIB[ulIndex] != 0)
        {
           PVOID       pBits = NULL;
           PBITMAPINFO pbmi  = NULL;
           HBITMAP     hdib  = NULL;
    
            pbmi = pbmiCreateAlphaStretchDIB(hdc,ulBppDIB[ulIndex],ulForDIB[ulIndex],&pBits,&hdib);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStrDIB[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunAlphaStretchDIB(hdc,pbmi,pBits,ulForDIB[ulIndex]);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestStretchDIB
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestStretchDIB(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        PVOID       pBits = NULL;
        PBITMAPINFO pbmi  = NULL;
        HBITMAP     hdib  = NULL;

        pbmi = pbmiCreateAlphaStretchDIB(hdc,ulBppDIB[ulIndex],ulForDIB[ulIndex],&pBits,&hdib);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStrDIB[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunStretchDIB(hdc,pbmi,pBits,ulForDIB[ulIndex]);
            DeleteObject(hdib);
        }
    }
    else
    {
        while (ulBppDIB[ulIndex] != 0)
        {
           PVOID       pBits = NULL;
           PBITMAPINFO pbmi  = NULL;
           HBITMAP     hdib  = NULL;
    
            pbmi = pbmiCreateAlphaStretchDIB(hdc,ulBppDIB[ulIndex],ulForDIB[ulIndex],&pBits,&hdib);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStrDIB[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunStretchDIB(hdc,pbmi,pBits,ulForDIB[ulIndex]);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}


/**************************************************************************\
* vTestAlphaMapMode
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define XPOS ((xpos * ViewExt[ulIndex])/WindowExt[ulIndex])
#define YPOS ((ypos * ViewExt[ulIndex])/WindowExt[ulIndex])

VOID
vTestAlphaIsotropic(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    if (pCallData->Param != -1)
    {
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdib != NULL)
        {
            HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
            LONG     xpos = 10;
            LONG     ypos = 10;
            RECT     rcl = {0,0,10000,10000};
    
            BLENDFUNCTION BlendFunction = {0,0,0,0};
    
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.AlphaFormat         = 0;
            BlendFunction.SourceConstantAlpha = 192;
    
            FillTransformedRect(hdc,&rcl,hbrFillCars);
    
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcm,hdib);
            SelectPalette(hdcm,hpal,FALSE);
            PCHAR pcMode[] = {
                               "ISO 1-1",
                               "ISO 2-3",
                               "ISO 1-2",
                               "ISO 3-2",
                               "ISO 4-3",
                               NULL
                             };

            LONG  WindowExt[] = {1000,
                                 2000,
                                 1000,
                                 3000,
                                 4000
                                 };

            LONG  ViewExt[] = {1000,
                               3000,
                               2000,
                               2000,
                               3000
                               };


           lstrcpy(NewTitle,Title);
           lstrcat(NewTitle,pFormatStr[ulIndex]);
           SetWindowText(pCallData->hwnd,NewTitle);



            RealizePalette(hdc);
            RealizePalette(hdcm);

            SetMapMode(hdc,MM_ISOTROPIC);
            SetBkMode(hdc,TRANSPARENT);
            SetWindowOrgEx(hdc,0,0,NULL);
            SetViewportOrgEx(hdc,0,0,NULL);

            ULONG ulIndex = 0;


            while (pcMode[ulIndex] != NULL)
            {
                xpos = 10;

                SetWindowExtEx(hdc,ViewExt[ulIndex],ViewExt[ulIndex],NULL);
                SetViewportExtEx(hdc,WindowExt[ulIndex],WindowExt[ulIndex],NULL);

                TextOut(hdc,XPOS,YPOS,pcMode[ulIndex],strlen(pcMode[ulIndex]));

                ypos += (20 * WindowExt[ulIndex])/ViewExt[ulIndex];

                StretchBlt(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,SRCCOPY);

                xpos += (140 * WindowExt[ulIndex])/ViewExt[ulIndex];

                BlendFunction.SourceConstantAlpha = 192;
                AlphaBlend(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,BlendFunction);

                xpos += (140 * WindowExt[ulIndex])/ViewExt[ulIndex];

                BlendFunction.SourceConstantAlpha = 100;
                AlphaBlend(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,BlendFunction);

                ypos += (140 * WindowExt[ulIndex])/ViewExt[ulIndex];
                ulIndex++;
            }

            SelectObject(hdcm,hbmOld);
            DeleteObject(hdib);
        }

    }
    else
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);
    
            if (hdib != NULL)
            {
                HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
                LONG     xpos = 10;
                LONG     ypos = 10;
                RECT     rcl = {0,0,10000,10000};
        
                BLENDFUNCTION BlendFunction = {0,0,0,0};
        
                BlendFunction.BlendOp             = AC_SRC_OVER;
                BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
                BlendFunction.SourceConstantAlpha = 192;
        
                FillTransformedRect(hdc,&rcl,hbrFillCars);
        
                HBITMAP hbmOld = (HBITMAP)SelectObject(hdcm,hdib);
                SelectPalette(hdcm,hpal,FALSE);
                PCHAR pcMode[] = {
                                   "ISO 1-1",
                                   "ISO 2-3",
                                   "ISO 1-2",
                                   "ISO 3-2",
                                   "ISO 4-3",
                                   NULL
                                 };
    
                LONG  WindowExt[] = {1000,
                                     2000,
                                     1000,
                                     3000,
                                     4000
                                     };
    
                LONG  ViewExt[] = {1000,
                                   3000,
                                   2000,
                                   2000,
                                   3000
                                   };
    
    
               lstrcpy(NewTitle,Title);
               lstrcat(NewTitle,pFormatStr[ulIndex]);
               SetWindowText(pCallData->hwnd,NewTitle);
    
    
    
                RealizePalette(hdc);
                RealizePalette(hdcm);
    
                SetMapMode(hdc,MM_ISOTROPIC);
                SetBkMode(hdc,TRANSPARENT);
                SetWindowOrgEx(hdc,0,0,NULL);
                SetViewportOrgEx(hdc,0,0,NULL);
    
                ULONG ulIndex = 0;
    
    
                while (pcMode[ulIndex] != NULL)
                {
                    xpos = 10;
    
                    SetWindowExtEx(hdc,ViewExt[ulIndex],ViewExt[ulIndex],NULL);
                    SetViewportExtEx(hdc,WindowExt[ulIndex],WindowExt[ulIndex],NULL);
    
                    TextOut(hdc,XPOS,YPOS,pcMode[ulIndex],strlen(pcMode[ulIndex]));
    
                    ypos += (20 * WindowExt[ulIndex])/ViewExt[ulIndex];
    
                    StretchBlt(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,SRCCOPY);
    
                    xpos += (140 * WindowExt[ulIndex])/ViewExt[ulIndex];
    
                    BlendFunction.SourceConstantAlpha = 192;
                    AlphaBlend(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,BlendFunction);
    
                    xpos += (140 * WindowExt[ulIndex])/ViewExt[ulIndex];
    
                    BlendFunction.SourceConstantAlpha = 100;
                    AlphaBlend(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,BlendFunction);
    
                    ypos += (140 * WindowExt[ulIndex])/ViewExt[ulIndex];
                    ulIndex++;
                }
    
                SelectObject(hdcm,hbmOld);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

#undef XPOS
#undef YPOS


#define XPOS ((xpos * ViewExtX[ulIndex])/WindowExtX[ulIndex])
#define YPOS ((ypos * ViewExtY[ulIndex])/WindowExtY[ulIndex])

/**************************************************************************\
* vTestAlphaAnisotropic
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/9/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaAnisotropic(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdib != NULL)
        {
            HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
            LONG     xpos = 10;
            LONG     ypos = 10;
            RECT     rcl = {0,0,10000,10000};
    
            BLENDFUNCTION BlendFunction = {0,0,0,0};
    
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.AlphaFormat         = 0;
            BlendFunction.SourceConstantAlpha = 192;
    
            FillTransformedRect(hdc,&rcl,hbrFillCars);
    
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcm,hdib);
            SelectPalette(hdcm,hpal,FALSE);
            PCHAR pcMode[] = {
                               "ISO 1-1",
                               "ISO 2-3",
                               "ISO 1-2",
                               "ISO 3-2",
                               "ISO 4-3",
                               NULL
                             };

            LONG  WindowExtX[] = {1000,
                                  2000,
                                  1000,
                                  3000,
                                  4000
                                 };

            LONG  ViewExtX[] = {1000,
                                3000,
                                2000,
                                2000,
                                3000
                               };

           LONG  WindowExtY[] = {1000,
                                 2000,
                                 2500,
                                  800,
                                  500
                                };

           LONG  ViewExtY[] = {2000,
                               2000,
                               2000,
                               2000,
                               2000
                              };

          lstrcpy(NewTitle,Title);
          lstrcat(NewTitle,pFormatStr[ulIndex]);
          SetWindowText(pCallData->hwnd,NewTitle);

            RealizePalette(hdc);
            RealizePalette(hdcm);

            SetMapMode(hdc,MM_ANISOTROPIC);
            SetBkMode(hdc,TRANSPARENT);
            SetWindowOrgEx(hdc,0,0,NULL);
            SetViewportOrgEx(hdc,0,0,NULL);

            ULONG ulIndex = 0;


            while (pcMode[ulIndex] != NULL)
            {
                xpos = 10;

                SetWindowExtEx(hdc,ViewExtX[ulIndex],ViewExtY[ulIndex],NULL);
                SetViewportExtEx(hdc,WindowExtX[ulIndex],WindowExtY[ulIndex],NULL);

                TextOut(hdc,XPOS,YPOS,pcMode[ulIndex],strlen(pcMode[ulIndex]));

                ypos += (20 * WindowExtY[ulIndex])/ViewExtY[ulIndex];

                StretchBlt(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,SRCCOPY);

                xpos += (140 * WindowExtX[ulIndex])/ViewExtX[ulIndex];

                AlphaBlend(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,BlendFunction);

                ypos += (140 * WindowExtY[ulIndex])/ViewExtY[ulIndex];
                ulIndex++;
            }

            SelectObject(hdcm,hbmOld);
            DeleteObject(hdib);
        }
    }
    else
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);
    
            if (hdib != NULL)
            {
                HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
                LONG     xpos = 10;
                LONG     ypos = 10;
                RECT     rcl = {0,0,10000,10000};
        
                BLENDFUNCTION BlendFunction = {0,0,0,0};
        
                BlendFunction.BlendOp             = AC_SRC_OVER;
                BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
                BlendFunction.SourceConstantAlpha = 192;
        
                FillTransformedRect(hdc,&rcl,hbrFillCars);
        
                HBITMAP hbmOld = (HBITMAP)SelectObject(hdcm,hdib);
                SelectPalette(hdcm,hpal,FALSE);
                PCHAR pcMode[] = {
                                   "ISO 1-1",
                                   "ISO 2-3",
                                   "ISO 1-2",
                                   "ISO 3-2",
                                   "ISO 4-3",
                                   NULL
                                 };
    
                LONG  WindowExtX[] = {1000,
                                      2000,
                                      1000,
                                      3000,
                                      4000
                                     };
    
                LONG  ViewExtX[] = {1000,
                                    3000,
                                    2000,
                                    2000,
                                    3000
                                   };
    
               LONG  WindowExtY[] = {1000,
                                     2000,
                                     2500,
                                      800,
                                      500
                                    };
    
               LONG  ViewExtY[] = {2000,
                                   2000,
                                   2000,
                                   2000,
                                   2000
                                  };
    
              lstrcpy(NewTitle,Title);
              lstrcat(NewTitle,pFormatStr[ulIndex]);
              SetWindowText(pCallData->hwnd,NewTitle);
    
                RealizePalette(hdc);
                RealizePalette(hdcm);
    
                SetMapMode(hdc,MM_ANISOTROPIC);
                SetBkMode(hdc,TRANSPARENT);
                SetWindowOrgEx(hdc,0,0,NULL);
                SetViewportOrgEx(hdc,0,0,NULL);
    
                ULONG ulIndex = 0;
    
    
                while (pcMode[ulIndex] != NULL)
                {
                    xpos = 10;
    
                    SetWindowExtEx(hdc,ViewExtX[ulIndex],ViewExtY[ulIndex],NULL);
                    SetViewportExtEx(hdc,WindowExtX[ulIndex],WindowExtY[ulIndex],NULL);
    
                    TextOut(hdc,XPOS,YPOS,pcMode[ulIndex],strlen(pcMode[ulIndex]));
    
                    ypos += (20 * WindowExtY[ulIndex])/ViewExtY[ulIndex];
    
                    StretchBlt(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,SRCCOPY);
    
                    xpos += (140 * WindowExtX[ulIndex])/ViewExtX[ulIndex];
    
                    AlphaBlend(hdc,XPOS,YPOS,128,128,hdcm,0,0,128,128,BlendFunction);
    
                    ypos += (140 * WindowExtY[ulIndex])/ViewExtY[ulIndex];
                    ulIndex++;
                }
    
                SelectObject(hdcm,hbmOld);
                DeleteObject(hdib);
            }
    
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
* vTestAlphaWidth
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaWidth(
    TEST_CALL_DATA *pCallData
    )
{
    HDC           hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG         xpos  = 0;
    ULONG         ypos  = 8;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal  = CreateHtPalette(hdc);
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};
    ULONG         ulIndex;
    RECT          rect;
    CHAR          Title[256];
    CHAR          NewTitle[256];


    GetWindowText(pCallData->hwnd,Title,256);

    GetClientRect(pCallData->hwnd,&rect);

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    BlendFunction.BlendOp             = AC_SRC_OVER;
    BlendFunction.SourceConstantAlpha = 192;
    BlendFunction.AlphaFormat         = 0;

    HDC      hdcmA = CreateCompatibleDC(hdc);

    ulIndex = 0;

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
        HBITMAP  hdibA = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdibA != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);
    
            SelectObject(hdcmA,hdibA);
            SelectPalette(hdcmA,hpal,FALSE);
            RealizePalette(hdcmA);
    
    
            LONG Width,Height;
    
            for (ypos=10,Height = 0;ypos+Height < rect.bottom - 32;ypos++)
            {
                for (xpos=10,Width = 0;xpos+Width<rect.right;xpos += 32)
                {
                    AlphaBlend(hdc,xpos,ypos,Width,Height,hdcmA,0,0,Width,Height,BlendFunction);
                    Width+= 1;
                }
    
                Height++;
                ypos+= 32;
            }
    
            //
            // free objects
            //
    
            DeleteObject(hdibA);
        }

    }
    else
    {
        while (ulBpp[ulIndex] != 0)
        {
            FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
            HBITMAP  hdibA = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);
    
            if (hdibA != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
        
                SelectObject(hdcmA,hdibA);
                SelectPalette(hdcmA,hpal,FALSE);
                RealizePalette(hdcmA);
        
        
                LONG Width,Height;
        
                for (ypos=10,Height = 0;ypos+Height < rect.bottom - 32;ypos++)
                {
                    for (xpos=10,Width = 0;xpos+Width<rect.right;xpos += 32)
                    {
                        AlphaBlend(hdc,xpos,ypos,Width,Height,hdcmA,0,0,Width,Height,BlendFunction);
                        Width+= 1;
                    }
        
                    Height++;
                    ypos+= 32;
                }
        
                //
                // free objects
                //
        
                DeleteObject(hdibA);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }
    }


    DeleteDC(hdcmA);

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
* vTestAlphaOffset
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaOffset(
    TEST_CALL_DATA *pCallData
    )
{
    HDC           hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG         xpos  = 0;
    ULONG         ypos  = 8;
    ULONG         dy    = 136;
    ULONG         dx    = 128+5;
    HPALETTE      hpal  = CreateHtPalette(hdc);
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};
    ULONG         ulIndex;
    RECT          rect;
    CHAR          Title[256];
    CHAR          NewTitle[256];


    GetWindowText(pCallData->hwnd,Title,256);

    GetClientRect(pCallData->hwnd,&rect);

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    BlendFunction.BlendOp             = AC_SRC_OVER;
    BlendFunction.SourceConstantAlpha = 192;
    BlendFunction.AlphaFormat         = 0;

    HDC      hdcmA = CreateCompatibleDC(hdc);

    ulIndex = 0;

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;

        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
        HBITMAP  hdibA = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);

        if (hdibA != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);
    
            SelectObject(hdcmA,hdibA);
            SelectPalette(hdcmA,hpal,FALSE);
            RealizePalette(hdcmA);
    
            LONG xOffset,yOffset;
            CHAR          tmps[256];
    
            SetBkMode(hdc,TRANSPARENT);
    
            for (ypos=10,yOffset=-128;ypos<rect.bottom-128;ypos+=138,yOffset+=64)
            {
                for (xpos=10,xOffset=-128;xpos < rect.right-128;xpos+=138,xOffset+=64)
                {
                    BitBlt(hdc,xpos,ypos,128,128,hdcmA,xOffset,yOffset,0xff0000);
                    wsprintf(tmps,"%4li,%4li",xOffset,yOffset);
                    TextOut(hdc,xpos,ypos,tmps,strlen(tmps));
                }
            }
    
            for (ypos=10,yOffset=-128;ypos<rect.bottom-128;ypos+=138,yOffset+=64)
            {
                for (xpos=10,xOffset=-128;xpos < rect.right-128;xpos+=138,xOffset+=64)
                {
                    AlphaBlend(hdc,xpos,ypos,128,128,hdcmA,xOffset,yOffset,128,128,BlendFunction);
                }
            }
        }

        //
        // free objects
        //

        DeleteObject(hdibA);
    }
    else
    {
        while (ulBpp[ulIndex] != 0)
        {
            FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
            HBITMAP  hdibA = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],128,128);
    
            if (hdibA != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
        
                SelectObject(hdcmA,hdibA);
                SelectPalette(hdcmA,hpal,FALSE);
                RealizePalette(hdcmA);
        
                LONG xOffset,yOffset;
                CHAR          tmps[256];
        
                SetBkMode(hdc,TRANSPARENT);
        
                for (ypos=10,yOffset=-128;ypos<rect.bottom-128;ypos+=138,yOffset+=64)
                {
                    for (xpos=10,xOffset=-128;xpos < rect.right-128;xpos+=138,xOffset+=64)
                    {
                        BitBlt(hdc,xpos,ypos,128,128,hdcmA,xOffset,yOffset,0xff0000);
                        wsprintf(tmps,"%4li,%4li",xOffset,yOffset);
                        TextOut(hdc,xpos,ypos,tmps,strlen(tmps));
                    }
                }
        
                for (ypos=10,yOffset=-128;ypos<rect.bottom-128;ypos+=138,yOffset+=64)
                {
                    for (xpos=10,xOffset=-128;xpos < rect.right-128;xpos+=138,xOffset+=64)
                    {
                        AlphaBlend(hdc,xpos,ypos,128,128,hdcmA,xOffset,yOffset,128,128,BlendFunction);
                    }
                }
            }
    
    
            Sleep(gAlphaSleep);
    
            //
            // free objects
            //
    
            DeleteObject(hdibA);
    
            ulIndex++;
        }
    }

    DeleteDC(hdcmA);

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}


/******************************Public*Routine******************************\
* vTestAlpha
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlpha(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    HPALETTE     hpal;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};

    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);
        rect.bottom = ypos+dy+dy-4;
        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO       pbmi;
        PBITMAPINFOHEADER pbmih;
        HBITMAP hdib;
        HBITMAP hdibA;
        ULONG ux,uy;
        PULONG pDib,pDibA;

        HDC hdcm  = CreateCompatibleDC(hdc);
        HDC hdcmA = CreateCompatibleDC(hdc);


        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

        pbmih->biSize            = sizeof(BITMAPINFOHEADER);
        pbmih->biWidth           = 128;
        pbmih->biHeight          = 128;
        pbmih->biPlanes          = 1;
        pbmih->biBitCount        = 32;
        pbmih->biCompression     = BI_BITFIELDS;
        pbmih->biSizeImage       = 0;
        pbmih->biXPelsPerMeter   = 0;
        pbmih->biYPelsPerMeter   = 0;
        pbmih->biClrUsed         = 0;
        pbmih->biClrImportant    = 0;

        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];
        pulMask[0] = 0x00ff0000;
        pulMask[1] = 0x0000ff00;
        pulMask[2] = 0x000000ff;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

        hdibA = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

        if ((hdib == NULL) || (hdibA == NULL))
        {
            MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
            goto ErrorExit;
        }

        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
		  BYTE blue  = (ux*2);
		  BYTE green = (uy*2);
		  BYTE red   = 0;
		  BYTE alpha = 0xff;
                     *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDib) = 0x80800000;


            ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

        //
        // inter per-pixel alpha DIB
        //

        {
            PULONG ptmp = pDibA;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE  Alpha  = (ux * 2);
                    float fAlpha = (float)Alpha;
                    int   blue   = ux * 2;
                    int   green  = uy * 2;
                    int   red    = 0;

                    blue  = (int)((float)blue  * (fAlpha/255.0) + 0.5);
                    green = (int)((float)green * (fAlpha/255.0) + 0.5);

                    *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                }
            }

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x00000000;
                }
            }
        }

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectObject(hdcmA,hdibA);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);
        SelectPalette(hdcmA,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);
        RealizePalette(hdcmA);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        BlendFunction.BlendOp         = AC_SRC_OVER;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        // display over cars
        //

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        #if 0

            {
                HBRUSH hbrR = CreateSolidBrush(RGB(255,0,0));
                HBRUSH hbrG = CreateSolidBrush(RGB(0,255,0));
                HBRUSH hbrB = CreateSolidBrush(RGB(0,0,255));
                PatBlt(hdc,xpos,ypos,128,10,BLACKNESS);
                SelectObject(hdc,hbrR);
                PatBlt(hdc,xpos,ypos+50,128,10,PATCOPY);
                SelectObject(hdc,hbrG);
                PatBlt(hdc,xpos,ypos+60,128,10,PATCOPY);
                SelectObject(hdc,hbrB);
                PatBlt(hdc,xpos,ypos+70,128,10,PATCOPY);
                PatBlt(hdc,xpos,ypos+80,128,10,WHITENESS);
                DeleteObject(hbrR);
                DeleteObject(hbrG);
                DeleteObject(hbrB);
            }

        #endif

        BlendFunction.BlendOp         = AC_SRC_OVER;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        // draw it again with clipping
        //

        {
            HRGN hrgn1 = CreateEllipticRgn(xpos+10 ,ypos+10,xpos+128-10 ,ypos+128-10);

	    ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);

            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaBlend(hdc,xpos ,ypos,128,128,hdcm ,0,0,128,128,BlendFunction);

            ExtSelectClipRgn(hdc,NULL,RGN_COPY);

            DeleteObject(hrgn1);
        }

        xpos += 128+32;

        //
        // stretch
        //

        {
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaBlend(hdc,xpos, ypos,128,128,hdcm ,0,0,128,128,BlendFunction);
        }

        //
        // free objects
        //

        DeleteDC(hdcm);
        DeleteDC(hdcmA);
        DeleteObject(hdib);
        DeleteObject(hdibA);
        LocalFree(pbmi);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}


/******************************Public*Routine******************************\
* vTestAlphaDefPal
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaDefPal(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,255};

    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);
        rect.bottom = ypos+dy+dy-4;
        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO       pbmi;
        PBITMAPINFOHEADER pbmih;
        HBITMAP hdib;
        HBITMAP hdibA;
        ULONG ux,uy;
        PULONG pDib,pDibA;

        HDC hdcm  = CreateCompatibleDC(hdc);
        HDC hdcmA = CreateCompatibleDC(hdc);


        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

        pbmih->biSize            = sizeof(BITMAPINFOHEADER);
        pbmih->biWidth           = 128;
        pbmih->biHeight          = 128;
        pbmih->biPlanes          = 1;
        pbmih->biBitCount        = 32;
        pbmih->biCompression     = BI_BITFIELDS;
        pbmih->biSizeImage       = 0;
        pbmih->biXPelsPerMeter   = 0;
        pbmih->biYPelsPerMeter   = 0;
        pbmih->biClrUsed         = 0;
        pbmih->biClrImportant    = 0;

        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];
        pulMask[0] = 0x00ff0000;
        pulMask[1] = 0x0000ff00;
        pulMask[2] = 0x000000ff;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

        hdibA = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

        if ((hdib == NULL) || (hdibA == NULL))
        {
            MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
            goto ErrorExit;
        }

        SelectObject(hdcm,hdib);
        SelectObject(hdcmA,hdibA);

        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE blue  = (ux*2);
                    BYTE green = (uy*2);
                    BYTE red   = 0;
                    BYTE alpha = 0xff;
                    *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDib) = 0x80800000;


            ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

        //
        // inter per-pixel aplha DIB
        //

        {
            PULONG ptmp = pDibA;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE  Alpha  = (ux * 2);
                    float fAlpha = (float)Alpha;
                    int   blue   = ux * 2;
                    int   green  = uy * 2;
                    int   red    = 0;

                    blue  = (int)((float)blue  * (fAlpha/255.0) + 0.5);
                    green = (int)((float)green * (fAlpha/255.0) + 0.5);

                    *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                }
            }

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x00000000;
                }
            }
        }

        //
        // display over black
        //

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        BlendFunction.BlendOp         = AC_SRC_OVER;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        // display over cars
        //

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        #if 0

            {
                HBRUSH hbrR = CreateSolidBrush(RGB(255,0,0));
                HBRUSH hbrG = CreateSolidBrush(RGB(0,255,0));
                HBRUSH hbrB = CreateSolidBrush(RGB(0,0,255));
                PatBlt(hdc,xpos,ypos,128,10,BLACKNESS);
                SelectObject(hdc,hbrR);
                PatBlt(hdc,xpos,ypos+50,128,10,PATCOPY);
                SelectObject(hdc,hbrG);
                PatBlt(hdc,xpos,ypos+60,128,10,PATCOPY);
                SelectObject(hdc,hbrB);
                PatBlt(hdc,xpos,ypos+70,128,10,PATCOPY);
                PatBlt(hdc,xpos,ypos+80,128,10,WHITENESS);
                DeleteObject(hbrR);
                DeleteObject(hbrG);
                DeleteObject(hbrB);
            }

        #endif

        BlendFunction.BlendOp         = AC_SRC_OVER;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        // draw it again with clipping
        //

        {
            HRGN hrgn1 = CreateEllipticRgn(xpos+10 ,ypos+10,xpos+128-10 ,ypos+128-10);

            ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);

            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaBlend(hdc,xpos ,ypos,128,128,hdcm ,0,0,128,128,BlendFunction);

            ExtSelectClipRgn(hdc,NULL,RGN_COPY);

            DeleteObject(hrgn1);
        }

        xpos += 128+32;

        //
        // stretch
        //

        {
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaBlend(hdc,xpos, ypos,128,128,hdcm ,10,10,10,200,BlendFunction);
        }

        //
        // free objects
        //

        DeleteDC(hdcm);
        DeleteDC(hdcmA);
        DeleteObject(hdib);
        DeleteObject(hdibA);
        LocalFree(pbmi);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
}


/******************************Public*Routine******************************\
* vTestAlphaPopup
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaPopup32(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc      = GetDCAndTransform(pCallData->hwnd);
    ULONG   xpos     = 100;
    ULONG   ypos     = 100;
    ULONG   dy       = 136;
    ULONG   dx       = 164;
    HANDLE  hFile    = NULL;
    HANDLE  hMap     = NULL;
    HBITMAP hbmPopup = NULL;
    HBITMAP hbmSrc   = NULL;
    ULONG   hx,hy;
    PVOID   pFile    = NULL;

    hFile = CreateFile("c:\\dev\\disp\\popup.bmp",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile)
    {
        hMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 0,
                                 NULL
                                 );
        if (hMap)
        {
            pFile = MapViewOfFile(hMap,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  NULL
                                  );

            if (pFile)
            {
                BITMAPINFO          bmiDIB;
                PBITMAPFILEHEADER   pbmf = (PBITMAPFILEHEADER)pFile;
                PBITMAPINFO         pbmi = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));
                PBYTE               pbits = (PBYTE)pbmf + pbmf->bfOffBits;

                ULONG ulSize = sizeof(BITMAPINFO);

                //
                // calc color table size
                //

                if (pbmi->bmiHeader.biCompression == BI_RGB)
                {
                    if (pbmi->bmiHeader.biBitCount == 1)
                    {
                        ulSize += 1 * sizeof(ULONG);
                    }
                    else if (pbmi->bmiHeader.biBitCount == 4)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 16)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 15 * sizeof(ULONG);
                        }
                    }
                    else if (pbmi->bmiHeader.biBitCount == 8)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 256)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 255 * sizeof(ULONG);
                        }
                    }
                }
                else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                {
                    ulSize += 2 * sizeof(ULONG);
                }

                memcpy(&bmiDIB,pbmi,ulSize);

                {
                    BITMAPINFO bmDibSec;
                    PVOID      pdib = NULL;
                    PVOID      psrc;
                    LONG       Height = bmiDIB.bmiHeader.biHeight;

                    if (Height > 0)
                    {
                        Height = -Height;
                    }

                    bmDibSec.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                    bmDibSec.bmiHeader.biWidth           = bmiDIB.bmiHeader.biWidth;
                    bmDibSec.bmiHeader.biHeight          = Height;
                    bmDibSec.bmiHeader.biPlanes          = 1;
                    bmDibSec.bmiHeader.biBitCount        = 32;
                    //bmDibSec.bmiHeader.biCompression     = BI_BGRA;
                    bmDibSec.bmiHeader.biCompression     = BI_RGB;
                    bmDibSec.bmiHeader.biSizeImage       = 0;
                    bmDibSec.bmiHeader.biXPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biYPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biClrUsed         = 0;
                    bmDibSec.bmiHeader.biClrImportant    = 0;

                    hx = bmDibSec.bmiHeader.biWidth;
                    hy = - Height;


                    //hbmPopup = CreateDIBSection(hdc,&bmDibSec,DIB_RGB_COLORS,&pdib,NULL,0);
                    //hbmPopup = CreateDIBitmap(hdc,&bmDibSec.bmiHeader,0,NULL,&bmDibSec,DIB_RGB_COLORS);
                    hbmPopup = CreateCompatibleBitmap(hdc,hx,hy);
                    hbmSrc   = CreateDIBSection(hdc,&bmDibSec,DIB_RGB_COLORS,&psrc,NULL,0);
                    SetDIBits(hdc,hbmPopup,0,Height,pbits,&bmiDIB,DIB_RGB_COLORS);
                }

                UnmapViewOfFile(pFile);
            }

            CloseHandle(hMap);
        }
        else
        {
            CHAR msg[256];

            wsprintf(msg,"MapViewOfFile Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
        }
        CloseHandle(hFile);
    }

    //
    // tile screen
    //

    if (hbmPopup)
    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        //
        // alpha blt
        //

        {
            INIT_TIMER;
            BLENDFUNCTION BlendFunction = {0,0,0,0};
            HDC hdcm = CreateCompatibleDC(hdc);
            HDC hdcs = CreateCompatibleDC(hdc);
            ULONG Index;
            //BYTE  AlphaValue[] = {8,16,20,24,28,32,26,40,44,48,52,56,64,80,96,112,144,176,208,240,255,0};
            BYTE  AlphaValue[] = {16,32,64,96,112,148,176,255,0};
            char  msg[255];
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.AlphaFormat         = 0;

            SelectObject(hdcm,hbmPopup);
            SelectObject(hdcs,hbmSrc);

            xpos = 0;
            ypos = 0;

            BitBlt(hdcs,0,0,hx,hy,hdc,xpos,ypos,SRCCOPY);
            Index = 0;

            START_TIMER;

            do
            {
                BlendFunction.SourceConstantAlpha= AlphaValue[Index];
                AlphaBlend(hdcs,0,0,hx,hy,hdcm, 0,0,hx,hy,BlendFunction);
                Index++;
            }while (AlphaValue[Index] != 0);

            Iter = 1;

            END_TIMER;

            //ypos += (hy + 10); mem doesn't display

            wsprintf(msg,"MEM exec time = %li for %li blends",(LONG)StopTime,Index);
            TextOut(hdc,xpos+10,ypos,msg,strlen(msg));
            ypos += 20;

            LONG ElapsedTime = (LONG)StopTime;

            wsprintf(msg,"Time per pixel = %li ns",(int)(((double(ElapsedTime) * 1000.0)/ double(Index))/(hx * hy)));
            TextOut(hdc,xpos+10,ypos,msg,strlen(msg));

            ypos += 20;
            Index = 0;

            START_TIMER;

            do
            {
                BlendFunction.SourceConstantAlpha= AlphaValue[Index];
                AlphaBlend(hdc,xpos,ypos,hx,hy,hdcm, 0,0,hx,hy,BlendFunction);
                Index++;
            }while (AlphaValue[Index] != 0);

            Iter = 1;

            END_TIMER;

            ypos += (hy + 10);

            wsprintf(msg,"SCREEN exec time = %li for %li blends",(LONG)StopTime,Index);
            TextOut(hdc,xpos+10,ypos,msg,strlen(msg));

            ypos += 20;

            ElapsedTime = (LONG)StopTime;

            wsprintf(msg,"Time per pixel = %li ns",(int)(((double(ElapsedTime) * 1000.0)/ double(Index))/(hx * hy)));
            TextOut(hdc,xpos+10,ypos,msg,strlen(msg));



            DeleteDC(hdcm);
            DeleteDC(hdcs);
        }

    }

    DeleteObject(hbmPopup);
    DeleteObject(hbmSrc);

    ReleaseDC(pCallData->hwnd,hdc);
}

/******************************Public*Routine******************************\
* vTestAlphaPopup24
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaPopup24(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc      = GetDCAndTransform(pCallData->hwnd);
    ULONG   xpos     = 100;
    ULONG   ypos     = 100;
    ULONG   dy       = 136;
    ULONG   dx       = 164;
    HANDLE  hFile    = NULL;
    HANDLE  hMap     = NULL;
    HBITMAP hbmPopup = NULL;
    HBITMAP hbmSrc   = NULL;
    ULONG   hx,hy;
    PVOID   pFile    = NULL;

    hFile = CreateFile("c:\\dev\\disp\\popup.bmp",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile)
    {
        hMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 0,
                                 NULL
                                 );
        if (hMap)
        {
            pFile = MapViewOfFile(hMap,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  NULL
                                  );

            if (pFile)
            {
                BITMAPINFO          bmiDIB;
                PBITMAPFILEHEADER   pbmf = (PBITMAPFILEHEADER)pFile;
                PBITMAPINFO         pbmi = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));
                PBYTE               pbits = (PBYTE)pbmf + pbmf->bfOffBits;

                ULONG ulSize = sizeof(BITMAPINFO);

                //
                // calc color table size
                //

                if (pbmi->bmiHeader.biCompression == BI_RGB)
                {
                    if (pbmi->bmiHeader.biBitCount == 1)
                    {
                        ulSize += 1 * sizeof(ULONG);
                    }
                    else if (pbmi->bmiHeader.biBitCount == 4)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 16)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 15 * sizeof(ULONG);
                        }
                    }
                    else if (pbmi->bmiHeader.biBitCount == 8)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 256)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 255 * sizeof(ULONG);
                        }
                    }
                }
                else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                {
                    ulSize += 2 * sizeof(ULONG);
                }

                memcpy(&bmiDIB,pbmi,ulSize);

                {
                    BITMAPINFO bmDibSec;
                    PVOID      pdib = NULL;
                    PVOID      psrc;
                    LONG       Height = bmiDIB.bmiHeader.biHeight;

                    if (Height > 0)
                    {
                        Height = -Height;
                    }

                    bmDibSec.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                    bmDibSec.bmiHeader.biWidth           = bmiDIB.bmiHeader.biWidth;
                    bmDibSec.bmiHeader.biHeight          = Height;
                    bmDibSec.bmiHeader.biPlanes          = 1;
                    bmDibSec.bmiHeader.biBitCount        = 24;
                    bmDibSec.bmiHeader.biCompression     = BI_RGB;
                    bmDibSec.bmiHeader.biSizeImage       = 0;
                    bmDibSec.bmiHeader.biXPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biYPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biClrUsed         = 0;
                    bmDibSec.bmiHeader.biClrImportant    = 0;

                    hx = bmDibSec.bmiHeader.biWidth;
                    hy = - Height;


                    hbmPopup = CreateDIBSection(hdc,&bmDibSec,DIB_RGB_COLORS,&pdib,NULL,0);
                    hbmSrc   = CreateDIBSection(hdc,&bmDibSec,DIB_RGB_COLORS,&psrc,NULL,0);
                    SetDIBits(hdc,hbmPopup,0,Height,pbits,&bmiDIB,DIB_RGB_COLORS);
                }

                UnmapViewOfFile(pFile);
            }

            CloseHandle(hMap);
        }
        else
        {
            CHAR msg[256];

            wsprintf(msg,"MapViewOfFile Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
        }
        CloseHandle(hFile);
    }

    //
    // tile screen
    //

    if (hbmPopup)
    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        //
        // alpha blt
        //

        {
            INIT_TIMER;
            BLENDFUNCTION BlendFunction = {0,0,0,0};
            HDC hdcm = CreateCompatibleDC(hdc);
            HDC hdcs = CreateCompatibleDC(hdc);
            ULONG Index;
            //BYTE  AlphaValue[] = {8,16,20,24,28,32,26,40,44,48,52,56,64,80,96,112,144,176,208,240,255,0};
            BYTE  AlphaValue[] = {16,32,64,96,112,148,176,255,0};
            char  msg[255];
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.AlphaFormat         = 0;

            SelectObject(hdcm,hbmPopup);
            SelectObject(hdcs,hbmSrc);

            BitBlt(hdcs,0,0,hx,hy,hdc,xpos,ypos,SRCCOPY);
            Index = 0;

            START_TIMER;

            do
            {
                BlendFunction.SourceConstantAlpha= AlphaValue[Index];
                AlphaBlend(hdcs,0,0,hx,hy,hdcm, 0,0,hx,hy,BlendFunction);
                Index++;
            }while (AlphaValue[Index] != 0);

            Iter = 1;

            END_TIMER;

            wsprintf(msg,"exec time = %li for %li blends",(LONG)StopTime,Index);
            TextOut(hdc,10,10,msg,strlen(msg));

            LONG ElapsedTime = (LONG)StopTime;

            wsprintf(msg,"Time per pixel = %li ns",(int)(((double(ElapsedTime) * 1000.0)/ double(Index))/(hx * hy)));
            TextOut(hdc,10,30,msg,strlen(msg));

            //
            // display loop
            //

            BitBlt(hdcs,0,0,hx,hy,hdc,xpos,ypos,SRCCOPY);
            Index = 0;

            do
            {
                BlendFunction.SourceConstantAlpha= AlphaValue[Index];
                AlphaBlend(hdcs,0,0,hx,hy,hdcm, 0,0,hx,hy,BlendFunction);
                BitBlt(hdc,xpos,ypos,hx,hy,hdcs, 0,0,SRCCOPY);
                Index++;
            }while (AlphaValue[Index] != 0);


            DeleteDC(hdcm);
            DeleteDC(hdcs);
        }

    }

    DeleteObject(hbmPopup);
    DeleteObject(hbmSrc);

    ReleaseDC(pCallData->hwnd,hdc);
}

/******************************Public*Routine******************************\
* vTestAlphaPopup16
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaPopup16_555(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc      = GetDCAndTransform(pCallData->hwnd);
    ULONG   xpos     = 100;
    ULONG   ypos     = 100;
    ULONG   dy       = 136;
    ULONG   dx       = 164;
    HANDLE  hFile    = NULL;
    HANDLE  hMap     = NULL;
    HBITMAP hbmPopup = NULL;
    HBITMAP hbmSrc   = NULL;
    ULONG   hx,hy;
    PVOID   pFile    = NULL;

    hFile = CreateFile("c:\\dev\\disp\\popup.bmp",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile)
    {
        hMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 0,
                                 NULL
                                 );
        if (hMap)
        {
            pFile = MapViewOfFile(hMap,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  NULL
                                  );

            if (pFile)
            {
                BITMAPINFO          bmiDIB;
                PBITMAPFILEHEADER   pbmf = (PBITMAPFILEHEADER)pFile;
                PBITMAPINFO         pbmi = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));
                PBYTE               pbits = (PBYTE)pbmf + pbmf->bfOffBits;

                ULONG ulSize = sizeof(BITMAPINFO);

                //
                // calc color table size
                //

                if (pbmi->bmiHeader.biCompression == BI_RGB)
                {
                    if (pbmi->bmiHeader.biBitCount == 1)
                    {
                        ulSize += 1 * sizeof(ULONG);
                    }
                    else if (pbmi->bmiHeader.biBitCount == 4)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 16)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 15 * sizeof(ULONG);
                        }
                    }
                    else if (pbmi->bmiHeader.biBitCount == 8)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 256)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 255 * sizeof(ULONG);
                        }
                    }
                }
                else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                {
                    ulSize += 2 * sizeof(ULONG);
                }

                memcpy(&bmiDIB,pbmi,ulSize);

                {
                    PBITMAPINFO pbmDibSec = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 3 * sizeof(ULONG));
                    PVOID      pdib = NULL;
                    PVOID      psrc;
                    LONG       Height = bmiDIB.bmiHeader.biHeight;

                    if (Height > 0)
                    {
                        Height = -Height;
                    }

                    pbmDibSec->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                    pbmDibSec->bmiHeader.biWidth           = bmiDIB.bmiHeader.biWidth;
                    pbmDibSec->bmiHeader.biHeight          = Height;
                    pbmDibSec->bmiHeader.biPlanes          = 1;
                    pbmDibSec->bmiHeader.biBitCount        = 16;
                    pbmDibSec->bmiHeader.biCompression     = BI_BITFIELDS;
                    pbmDibSec->bmiHeader.biSizeImage       = 0;
                    pbmDibSec->bmiHeader.biXPelsPerMeter   = 100;
                    pbmDibSec->bmiHeader.biYPelsPerMeter   = 100;
                    pbmDibSec->bmiHeader.biClrUsed         = 0;
                    pbmDibSec->bmiHeader.biClrImportant    = 0;

                    PULONG pulMask = (PULONG)&pbmDibSec->bmiColors[0];

                    pulMask[0]         = 0x00007c00;
                    pulMask[1]         = 0x000003e0;
                    pulMask[2]         = 0x0000001f;

                    hx = pbmDibSec->bmiHeader.biWidth;
                    hy = - Height;


                    hbmPopup = CreateDIBSection(hdc,pbmDibSec,DIB_RGB_COLORS,&pdib,NULL,0);
                    hbmSrc   = CreateDIBSection(hdc,pbmDibSec,DIB_RGB_COLORS,&psrc,NULL,0);
                    SetDIBits(hdc,hbmPopup,0,Height,pbits,&bmiDIB,DIB_RGB_COLORS);

                    LocalFree(pbmDibSec);
                }

                UnmapViewOfFile(pFile);
            }

            CloseHandle(hMap);
        }
        else
        {
            CHAR msg[256];

            wsprintf(msg,"MapViewOfFile Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
        }
        CloseHandle(hFile);
    }

    //
    // tile screen
    //

    if (hbmPopup)
    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        //
        // alpha blt
        //

        {
            INIT_TIMER;
            BLENDFUNCTION BlendFunction = {0,0,0,0};
            HDC hdcm = CreateCompatibleDC(hdc);
            HDC hdcs = CreateCompatibleDC(hdc);
            ULONG Index;
            BYTE  AlphaValue[] = {8,16,20,24,28,32,26,40,44,48,52,56,64,80,96,112,144,176,208,240,255,0};
            //BYTE  AlphaValue[] = {16,32,64,96,112,148,176,255,0};
            char  msg[255];
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.AlphaFormat         = 0;

            SelectObject(hdcm,hbmPopup);
            SelectObject(hdcs,hbmSrc);


            //
            // timed loop
            //

            Index = 0;
            BitBlt(hdcs,0,0,hx,hy,hdc,xpos,ypos,SRCCOPY);

            START_TIMER;

            do
            {
                BlendFunction.SourceConstantAlpha= AlphaValue[Index];
                AlphaBlend(hdcs,0,0,hx,hy,hdcm, 0,0,hx,hy,BlendFunction);
                Index++;
            }while (AlphaValue[Index] != 0);

            Iter = 1;

            END_TIMER;

            wsprintf(msg,"exec time = %li for %li blends bm = %li x %li",(LONG)StopTime,Index,hx,hy);
            TextOut(hdc,10,10,msg,strlen(msg));

            LONG ElapsedTime = (LONG)StopTime;

            wsprintf(msg,"Time per pixel = %li ns",(int)(((double(ElapsedTime) * 1000.0)/ double(Index))/(hx * hy)));
            TextOut(hdc,10,30,msg,strlen(msg));

            //
            // display loop
            //

            Index = 0;
            BitBlt(hdcs,0,0,hx,hy,hdc,xpos,ypos,SRCCOPY);

            do
            {
                BlendFunction.SourceConstantAlpha= AlphaValue[Index];
                AlphaBlend(hdcs,0,0,hx,hy,hdcm, 0,0,hx,hy,BlendFunction);
                BitBlt(hdc,xpos,ypos,hx,hy,hdcs, 0,0,SRCCOPY);
                Index++;
            }while (AlphaValue[Index] != 0);

            DeleteDC(hdcm);
            DeleteDC(hdcs);
        }

    }

    DeleteObject(hbmPopup);
    DeleteObject(hbmSrc);

    ReleaseDC(pCallData->hwnd,hdc);
}

/******************************Public*Routine******************************\
* vTestAlphaDIB
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaDIB(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    HPALETTE     hpal;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,240};

    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        rect.bottom = ypos+dy+dy-4;

        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO pbmi;
        ULONG ux,uy;
        PULONG pDib,pDibA;

        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib = (PULONG)LocalAlloc(0,128*128*4);
        pDibA = (PULONG)LocalAlloc(0,128*128*4);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = 128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        //pbmi->bmiHeader.biCompression     = BI_BGRA;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE blue  = (ux*2);
                    BYTE green = (uy*2);
                    BYTE red   = 0;
                    BYTE alpha = 0xff;
                    *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDib) = 0x80800000;


            ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

        //
        // inter per-pixel aplha DIB
        //

        {
            PULONG ptmp = pDibA;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE  Alpha  = (ux * 2);
                    float fAlpha = (float)Alpha;
                    int   blue   = ux * 2;
                    int   green  = uy * 2;
                    int   red    = 0;

                    blue  = (int)((float)blue  * (fAlpha/255.0) + 0.5);
                    green = (int)((float)green * (fAlpha/255.0) + 0.5);

                    *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                }
            }

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x00000000;
                }
            }
        }

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        SelectPalette(hdc,hpal,FALSE);

        RealizePalette(hdc);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;


        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaDIBBlend(hdc,xpos+dx   ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaDIBBlend(hdc,xpos+2*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaDIBBlend(hdc,xpos+3*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaDIBBlend(hdc,xpos+4*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaDIBBlend(hdc,xpos+5*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);

        ypos += dy;

        BlendFunction.BlendOp         = AC_SRC_OVER;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaDIBBlend(hdc,xpos+dx   ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaDIBBlend(hdc,xpos+2*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaDIBBlend(hdc,xpos+3*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaDIBBlend(hdc,xpos+4*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaDIBBlend(hdc,xpos+5*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);

        ypos += dy;

        //
        // display over cars
        //

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaDIBBlend(hdc,xpos+dx   ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaDIBBlend(hdc,xpos+2*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaDIBBlend(hdc,xpos+3*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaDIBBlend(hdc,xpos+4*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaDIBBlend(hdc,xpos+5*dx ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);

        ypos += dy;

        BlendFunction.BlendOp         = AC_SRC_OVER;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaDIBBlend(hdc,xpos+dx   ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaDIBBlend(hdc,xpos+2*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaDIBBlend(hdc,xpos+3*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaDIBBlend(hdc,xpos+4*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaDIBBlend(hdc,xpos+5*dx ,ypos,128,128,pDibA,pbmi,DIB_RGB_COLORS, 0,0,128,128,BlendFunction);

        ypos += dy;

        //
        // draw it again with clipping
        //

        {
            HRGN hrgn1 = CreateEllipticRgn(xpos+10 ,ypos+10,xpos+128-10 ,ypos+128-10);

            ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);

            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaDIBBlend(hdc,xpos ,ypos,128,128,pDib,pbmi,DIB_RGB_COLORS,0,0,128,128,BlendFunction);

            ExtSelectClipRgn(hdc,NULL,RGN_COPY);

            DeleteObject(hrgn1);
        }

        xpos += 128+32;

        //
        // stretch
        //

        {
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaDIBBlend(hdc,xpos, ypos,128,128,pDib,pbmi,DIB_RGB_COLORS,10,-10,20,400,BlendFunction);
        }

        //
        // free objects
        //

        LocalFree(pbmi);
        LocalFree(pDib);
        LocalFree(pDibA);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
*  vTestAlphaDIB_PAL_COLORS
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaDIB_PAL_COLORS(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    HPALETTE     hpal;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,240};

    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        rect.bottom = ypos+dy+dy-4;

        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO pbmi;
        ULONG       ux,uy;
        PBYTE       pDib,pDibA;
        PUSHORT     pusColors;

        pbmi  = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib  = (PBYTE)LocalAlloc(0,128*128);

        pusColors = (PUSHORT)&pbmi->bmiColors[0];

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = 128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 8;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        for (ux=0;ux<256;ux++)
        {
            pusColors[ux] = ux;
        }

        //
        // init 8 bpp dib
        //

        {
            PBYTE ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = (BYTE)(ux + uy);
                }
            }
        }

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        SelectPalette(hdc,hpal,FALSE);

        RealizePalette(hdc);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaDIBBlend(hdc,xpos+dx   ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaDIBBlend(hdc,xpos+2*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaDIBBlend(hdc,xpos+3*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaDIBBlend(hdc,xpos+4*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaDIBBlend(hdc,xpos+5*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);

        SetDIBitsToDevice(hdc,xpos+6*dx,ypos,128,128,0,0,0,128,pDib,pbmi,DIB_PAL_COLORS);

        ypos += dy;
        ypos += dy;

        //
        // display over cars
        //

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaDIBBlend(hdc,xpos      ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaDIBBlend(hdc,xpos+dx   ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaDIBBlend(hdc,xpos+2*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaDIBBlend(hdc,xpos+3*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaDIBBlend(hdc,xpos+4*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaDIBBlend(hdc,xpos+5*dx ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS, 0,0,128,128,BlendFunction);

        SetDIBitsToDevice(hdc,xpos+6*dx,ypos,128,128,0,0,0,128,pDib,pbmi,DIB_PAL_COLORS);

        ypos += dy;
        ypos += dy;

        //
        // draw it again with clipping
        //

        {
            HRGN hrgn1 = CreateEllipticRgn(xpos+10 ,ypos+10,xpos+128-10 ,ypos+128-10);

            ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);

            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaDIBBlend(hdc,xpos ,ypos,128,128,pDib,pbmi,DIB_PAL_COLORS,0,0,128,128,BlendFunction);


            ExtSelectClipRgn(hdc,NULL,RGN_COPY);

            DeleteObject(hrgn1);
        }

        xpos += 128+32;

        //
        // stretch
        //

        {
            BlendFunction.BlendOp             = AC_SRC_OVER;
            BlendFunction.SourceConstantAlpha = 220;
            AlphaDIBBlend(hdc,xpos, ypos,128,128,pDib,pbmi,DIB_PAL_COLORS,10,0,20,400,BlendFunction);

            StretchDIBits(hdc,xpos+dx,ypos,128,128,10,0,20,400,pDib,pbmi,DIB_PAL_COLORS,SRCCOPY);
        }

        //
        // free objects
        //

        LocalFree(pbmi);
        LocalFree(pDib);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/******************************Public*Routine******************************\
*  vTestAlpha1
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlpha1(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    HPALETTE     hpal;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {64,128,160,192,224,240,255};


    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        rect.bottom = ypos+dy+dy-4;

        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO       pbmi;
        PBITMAPINFOHEADER pbih;
        HBITMAP hdib;
        HBITMAP hdibA;
        HBITMAP hdib1;
        ULONG ux,uy;
        PULONG pDib,pDibA;
        PBYTE  pDib1;
        PULONG pulColors;


        HDC hdcm  = CreateCompatibleDC(hdc);
        HDC hdcmA = CreateCompatibleDC(hdc);
        HDC hdcm1 = CreateCompatibleDC(hdc);


        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        pbih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

        pulColors = (PULONG)&pbmi->bmiColors[0];

        pbih->biSize            = sizeof(BITMAPINFOHEADER);
        pbih->biWidth           = 128;
        pbih->biHeight          = 128;
        pbih->biPlanes          = 1;
        pbih->biBitCount        = 32;
        pbih->biCompression     = BI_BITFIELDS;
        pbih->biSizeImage       = 0;
        pbih->biXPelsPerMeter   = 0;
        pbih->biYPelsPerMeter   = 0;
        pbih->biClrUsed         = 0;
        pbih->biClrImportant    = 0;

        pulColors[0]             = 0x00ff0000;
        pulColors[1]             = 0x0000ff00;
        pulColors[2]             = 0x000000ff;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);
        hdibA = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

        pbih->biCompression   = BI_RGB;
        pbih->biBitCount        = 1;
        pulColors[0]             = 0x00ffffff;
        pulColors[1]             = 0x0000ff00;

        hdib1 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib1,NULL,0);

        if ((hdib == NULL) || (hdibA == NULL) || (hdib1 == NULL))
        {
            MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
            goto ErrorExit;
        }

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);
        SelectObject(hdcmA,hdibA);
        SelectObject(hdcm1,hdib1);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);
        SelectPalette(hdcmA,hpal,FALSE);
        SelectPalette(hdcm1,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);
        RealizePalette(hdcmA);
        RealizePalette(hdcm1);


        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE blue  = (ux*2);
                    BYTE green = (uy*2);
                    BYTE red   = 0;
                    BYTE alpha = 0xff;
                    *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDib) = 0x80800000;


            ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

        //
        // inter per-pixel aplha DIB
        //

        {
            PULONG ptmp = pDibA;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE  Alpha  = (ux * 2);
                    float fAlpha = (float)Alpha;
                    int   blue   = ux * 2;
                    int   green  = uy * 2;
                    int   red    = 0;

                    blue  = (int)((float)blue  * (fAlpha/255.0) + 0.5);
                    green = (int)((float)green * (fAlpha/255.0) + 0.5);

                    *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                }
            }

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x00000000;
                }
            }
        }

        BlendFunction.BlendOp                  = AC_SRC_OVER;
        BlendFunction.AlphaFormat              = AC_SRC_ALPHA;

        {
            PBYTE ptmp = pDib1;
            for (uy=0;uy<((128 * 128)/8);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdcm1,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos,ypos,128,128,hdcm1,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib1;
            for (uy=0;uy<((128 * 128)/8);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdcm1,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+dx,ypos,128,128,hdcm1,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib1;
            for (uy=0;uy<((128 * 128)/8);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdcm1,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+2*dx,ypos,128,128,hdcm1,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib1;
            for (uy=0;uy<((128 * 128)/8);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdcm1,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+3*dx,ypos,128,128,hdcm1,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib1;
            for (uy=0;uy<((128 * 128)/8);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdcm1,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+4*dx,ypos,128,128,hdcm1,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib1;
            for (uy=0;uy<((128 * 128)/8);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdcm1,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+5*dx,ypos,128,128,hdcm1,0,0,SRCCOPY);

        ypos += dy;

        //
        // blend 1bpp source
        //

        //
        // inter per-pixel aplha DIB
        //

        {
            PBYTE ptmp = pDib1;

            for (uy=0;uy<((128 * 64)/8);uy++)
            {
                    *ptmp++ = 0;
            }

            while (uy++ < ((128*128)/8))
            {
                *ptmp++ = 0xff;
            }
        }
        
        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+1*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[6];
        AlphaBlend(hdc,xpos+6*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        ypos += dy;

        //
        // blend 1bpp source
        //
        //
        // inter per-pixel aplha DIB
        //
        // display over background
        //

        {
            PBYTE ptmp = pDib1;

            for (uy=0;uy<((128 * 64)/8);uy++)
            {
                    *ptmp++ = 0;
            }

            while (uy++ < ((128*128)/8))
            {
                *ptmp++ = 0xff;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+1*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[6];
        AlphaBlend(hdc,xpos+6*dx,ypos,128,128,hdcm1,0,0,128,128,BlendFunction);


        //
        // free objects
        //

        DeleteDC(hdcm);
        DeleteDC(hdcm1);
        DeleteDC(hdcmA);
        DeleteObject(hdib);
        DeleteObject(hdibA);
        DeleteObject(hdib1);
        LocalFree(pbmi);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlpha4(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    HPALETTE     hpal;
    BYTE          Alphas[] = {64,128,160,192,224,240,255};
    BLENDFUNCTION BlendFunction = {0,0,0,0};

    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);

        rect.bottom = ypos+dy+dy-4;

        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO       pbmi;
        PBITMAPINFOHEADER pbih;
        HBITMAP hdib;
        HBITMAP hdibA;
        HBITMAP hdib4;
        ULONG ux,uy;
        PULONG pDib,pDibA;
        PBYTE  pDib4;
        PULONG pulColors;
        ULONG  ulVGA[] = {
                            0x00000000,
                            0x00800000,
                            0x00008000,
                            0x00808000,
                            0x00000080,
                            0x00800080,
                            0x00008080,
                            0x00C0C0C0,
                            0x00808080,
                            0x00FF0000,
                            0x0000FF00,
                            0x00FFFF00,
                            0x000000FF,
                            0x00FF00FF,
                            0x0000FFFF,
                            0x00ffffff
                            };


        HDC hdcm  = CreateCompatibleDC(hdc);
        HDC hdcmA = CreateCompatibleDC(hdc);
        HDC hdcm4 = CreateCompatibleDC(hdc);


        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        pbih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

        pulColors = (PULONG)&pbmi->bmiColors[0];

        pbih->biSize            = sizeof(BITMAPINFOHEADER);
        pbih->biWidth           = 128;
        pbih->biHeight          = 128;
        pbih->biPlanes          = 1;
        pbih->biBitCount        = 32;
        pbih->biCompression     = BI_BITFIELDS;
        pbih->biSizeImage       = 0;
        pbih->biXPelsPerMeter   = 0;
        pbih->biYPelsPerMeter   = 0;
        pbih->biClrUsed         = 0;
        pbih->biClrImportant    = 0;

        pulColors[0]             = 0x00ff0000;
        pulColors[1]             = 0x0000ff00;
        pulColors[2]             = 0x000000ff;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);
        hdibA = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

        pbih->biCompression      = BI_RGB;
        pbih->biBitCount         = 4;

        memcpy(pulColors,&ulVGA[0],16*4);

        hdib4 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib4,NULL,0);

        if ((hdib == NULL) || (hdibA == NULL) || (hdib4 == NULL))
        {
            MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
            goto ErrorExit;
        }

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);
        SelectObject(hdcmA,hdibA);
        SelectObject(hdcm4,hdib4);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);
        SelectPalette(hdcmA,hpal,FALSE);
        SelectPalette(hdcm4,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);
        RealizePalette(hdcmA);
        RealizePalette(hdcm4);


        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE blue  = (ux*2);
                    BYTE green = (uy*2);
                    BYTE red   = 0;
                    BYTE alpha = 0xff;
                    *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDib) = 0x80800000;


            ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

        //
        // inter per-pixel aplha DIB
        //

        {
            PULONG ptmp = pDibA;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE  Alpha  = (ux * 2);
                    float fAlpha = (float)Alpha;
                    int   blue   = ux * 2;
                    int   green  = uy * 2;
                    int   red    = 0;

                    blue  = (int)((float)blue  * (fAlpha/255.0) + 0.5);
                    green = (int)((float)green * (fAlpha/255.0) + 0.5);

                    *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                }
            }

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x00000000;
                }
            }
        }

        //
        // display over black
        //

        SelectObject(hdcm,hdib);
        SelectObject(hdcmA,hdibA);

        BlendFunction.BlendOp                  = AC_SRC_OVER;
        BlendFunction.AlphaFormat              = AC_SRC_ALPHA;

        {
            PBYTE ptmp = pDib4;
            for (uy=0;uy<((128 * 128)/2);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdcm4,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos,ypos,128,128,hdcm4,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib4;
            for (uy=0;uy<((128 * 128)/2);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdcm4,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+dx,ypos,128,128,hdcm4,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib4;
            for (uy=0;uy<((128 * 128)/2);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdcm4,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+2*dx,ypos,128,128,hdcm4,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib4;
            for (uy=0;uy<((128 * 128)/2);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdcm4,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+3*dx,ypos,128,128,hdcm4,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib4;
            for (uy=0;uy<((128 * 128)/2);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdcm4,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+4*dx,ypos,128,128,hdcm4,0,0,SRCCOPY);

        {
            PBYTE ptmp = pDib4;
            for (uy=0;uy<((128 * 128)/2);uy++)
            {
                    *ptmp++ = 0;
            }
        }

        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdcm4,0,0,128,128,hdcm, 0,0,128,128,BlendFunction);
        BitBlt(hdc,xpos+5*dx,ypos,128,128,hdcm4,0,0,SRCCOPY);

        ypos += dy;

        //
        // blend 1bpp source
        //

        //
        // inter per-pixel aplha DIB
        //

        {
            PBYTE ptmp = pDib4;

            for (uy=0;uy<8192;uy++)
            {
                    *ptmp++ = (((uy/512) << 4) | (uy/512));
            }

        }

        //
        // display over black
        //
        
        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+1*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[6];
        AlphaBlend(hdc,xpos+6*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        ypos += dy;

        //
        // display over bitmap
        //

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+1*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);

        BlendFunction.SourceConstantAlpha = Alphas[6];
        AlphaBlend(hdc,xpos+6*dx,ypos,128,128,hdcm4,0,0,128,128,BlendFunction);


        //
        // free objects
        //

        DeleteDC(hdcm);
        DeleteDC(hdcm4);
        DeleteDC(hdcmA);
        DeleteObject(hdib);
        DeleteObject(hdibA);
        DeleteObject(hdib4);
        LocalFree(pbmi);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaBitmapFormats(
    TEST_CALL_DATA *pCallData
    )
{
    ULONG         NumLoops = 10;
    HDC           hdc   = GetDCAndTransform(pCallData->hwnd);
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    RECT          rect;
    BYTE          SourceAlpha   = 32;

    BlendFunction.BlendOp                  = AC_SRC_OVER;
    BlendFunction.AlphaFormat              = 0;


    GetClientRect(pCallData->hwnd,&rect);


    FillTransformedRect(hdc,&rect,hbrFillCars);

    //
    //  create DIBSections to test drawing
    //

    while (SourceAlpha != 0)
    {
        HDC                hdcm  = CreateCompatibleDC(hdc);
        ULONG ux,uy;
        PBITMAPINFO        pbmi;
        PBITMAPINFOHEADER  pbmih;
        HPALETTE           hpal;
        HPALETTE           hpalDef;
        HBITMAP            hdib32RGB;
        HBITMAP            hdib32BGR;
        HBITMAP            hdib32RBG;
        HBITMAP            hdib24RGB;
        HBITMAP            hdib16_565;
        HBITMAP            hdib16_555;
        HBITMAP            hdib16_466;
        PULONG             pDib32RGB;
        PULONG             pDib32BGR;
        PULONG             pDib32RBG;
        PULONG             pDib24RGB;
        PULONG             pDib16_565;
        PULONG             pDib16_555;
        PULONG             pDib16_466;

        ULONG              xpos  = 0;
        ULONG              ypos  = 8;


        BlendFunction.SourceConstantAlpha      = SourceAlpha;
        SourceAlpha += 32;

        hpal = CreateHtPalette(hdc);

        hpalDef = SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,TRUE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

        pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

        pbmih->biSize            = sizeof(BITMAPINFOHEADER);
        pbmih->biWidth           = 128;
        pbmih->biHeight          = 128;
        pbmih->biPlanes          = 1;
        pbmih->biBitCount        = 32;
        pbmih->biCompression     = BI_RGB;
        pbmih->biSizeImage       = 0;
        pbmih->biXPelsPerMeter   = 0;
        pbmih->biYPelsPerMeter   = 0;
        pbmih->biClrUsed         = 0;
        pbmih->biClrImportant    = 0;

        hdib32RGB  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32RGB,NULL,0);

        if (hdib32RGB != NULL)
        {
            vInitDib((PUCHAR)pDib32RGB,32,0,128,128);
        }


        pbmih->biCompression     = BI_BITFIELDS;

        pulMask[0]        = 0x00ff0000;
        pulMask[1]        = 0x0000ff00;
        pulMask[2]        = 0x000000ff;

        hdib32BGR  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32BGR,NULL,0);

        if (hdib32BGR != NULL)
        {
            vInitDib((PUCHAR)pDib32BGR,32,0,128,128);
        }

        pbmih->biCompression     = BI_BITFIELDS;

        pulMask[0]         = 0x000000ff;
        pulMask[1]         = 0x00ff0000;
        pulMask[2]         = 0x0000ff00;

        hdib32RBG  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32RBG,NULL,0);

        if (hdib32RBG != NULL)
        {
            vInitDib((PUCHAR)pDib32RBG,32,0,128,128);
        }

        pbmih->biBitCount        = 24;
        pbmih->biCompression     = BI_RGB;

        hdib24RGB  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib24RGB,NULL,0);

        if (hdib24RGB != NULL)
        {
            vInitDib((PUCHAR)pDib24RGB,24,0,128,128);
        }

        pbmih->biBitCount        = 16;
        pbmih->biCompression     = BI_BITFIELDS;

        pulMask[0]         = 0x0000f800;
        pulMask[1]         = 0x000007e0;
        pulMask[2]         = 0x0000001f;

        hdib16_565 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib16_565,NULL,0);

        if (hdib16_565 != NULL)
        {
            vInitDib((PUCHAR)pDib16_565,16,T565,128,128);
        }

        pulMask[0]         = 0x00007c00;
        pulMask[1]         = 0x000003e0;
        pulMask[2]         = 0x0000001f;

        hdib16_555 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib16_555,NULL,0);

        if (hdib16_555 != NULL)
        {
            vInitDib((PUCHAR)pDib16_555,16,T555,128,128);
        }


        pulMask[0]         = 0x0000f000;
        pulMask[1]         = 0x00000fc0;
        pulMask[2]         = 0x0000003f;

        hdib16_466 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib16_466,NULL,0);

        if (hdib16_466 != NULL)
        {
            vInitDib((PUCHAR)pDib16_466,16,T466,128,128);
        }

        SelectObject(hdcm,hdib32RGB);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos += 200;

        SelectObject(hdcm,hdib32BGR);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos += 200;

        SelectObject(hdcm,hdib32RBG);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos = 0;
        ypos += 200;

        SelectObject(hdcm,hdib24RGB);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos = 0;
        ypos += 200;

        SelectObject(hdcm,hdib16_555);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos += 200;

        SelectObject(hdcm,hdib16_565);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos += 200;

        SelectObject(hdcm,hdib16_466);
        AlphaBlend(hdc,xpos,ypos,128,128,hdcm,0,0,128,128,BlendFunction);

        xpos = 0;
        ypos += 200;

        //
        // free objects
        //

bmFormatCleanup:

        if (pbmi)
        {
            LocalFree(pbmi);
        }

        DeleteDC(hdcm);

        if (hdib32RGB)
        {
            DeleteObject(hdib32RGB);
        }

        if (hdib32BGR)
        {
            DeleteObject(hdib32BGR);
        }

        if (hdib32RBG)
        {
            DeleteObject(hdib32RBG);
        }

        if (hdib24RGB)
        {
            DeleteObject(hdib24RGB);
        }

        if (hdib16_565)
        {
            DeleteObject(hdib16_565);
        }

        if (hdib16_555)
        {
            DeleteObject(hdib16_555);
        }

        if (hdib16_466)
        {
            DeleteObject(hdib16_466);
        }

        SelectPalette(hdc,hpalDef,FALSE);
        DeleteObject(hpal);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
* vTestReadAndConvert
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestReadAndConvert(
    TEST_CALL_DATA *pCallData
    )
{
    HDC         hdc      = GetDCAndTransform(pCallData->hwnd);
    ULONG       xpos     = 100;
    ULONG       ypos     = 100;
    ULONG       dy       = 136;
    ULONG       dx       = 164;
    HANDLE      hFile    = NULL;
    HANDLE      hMap     = NULL;
    HBITMAP     hbm8     = NULL;
    HBITMAP     hbm32    = NULL;
    ULONG       hx,hy;
    PVOID       pFile    = NULL;
    PBITMAPINFO pbmiDIB8 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
    CHAR        msg[256];

    if (pbmiDIB8 == NULL)
    {
        ReleaseDC(pCallData->hwnd,hdc);
        return;
    }

    hFile = CreateFile("c:\\river.bmp",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile == NULL)
    {
        TextOut(hdc,10,10,"Can't open c:\\river.bmp",24);
        ReleaseDC(pCallData->hwnd,hdc);
        return;
    }

    hMap = CreateFileMapping(hFile,
                             NULL,
                             PAGE_READWRITE,
                             0,
                             0,
                             NULL
                             );
    if (hMap)
    {
        pFile = MapViewOfFile(hMap,
                              FILE_MAP_READ,
                              0,
                              0,
                              NULL
                              );

        if (pFile)
        {
            PBITMAPFILEHEADER   pbmf = (PBITMAPFILEHEADER)pFile;
            PBITMAPINFO         pbmi = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));
            PBYTE               pbmFileBits = (PBYTE)pbmf + pbmf->bfOffBits;

            ULONG ulSize = sizeof(BITMAPINFO);

            //
            // calc color table size
            //

            if (pbmi->bmiHeader.biCompression == BI_RGB)
            {
                if (pbmi->bmiHeader.biBitCount == 1)
                {
                    ulSize += 1 * sizeof(ULONG);
                }
                else if (pbmi->bmiHeader.biBitCount == 4)
                {
                    if (pbmi->bmiHeader.biClrUsed <= 16)
                    {
                        ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                    }
                    else
                    {
                        ulSize += 15 * sizeof(ULONG);
                    }
                }
                else if (pbmi->bmiHeader.biBitCount == 8)
                {
                    if (pbmi->bmiHeader.biClrUsed <= 256)
                    {
                        ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                    }
                    else
                    {
                        ulSize += 255 * sizeof(ULONG);
                    }
                }
            }
            else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
            {
                ulSize += 2 * sizeof(ULONG);
            }

            LONG       Height = pbmi->bmiHeader.biHeight;
            LONG       Width  = pbmi->bmiHeader.biWidth;
            PVOID      pdib8  = NULL;
            PVOID      pdib32 = NULL;
            BITMAPINFO bmDibSec32;

            bmDibSec32.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
            bmDibSec32.bmiHeader.biWidth           = Width;
            bmDibSec32.bmiHeader.biHeight          = Height;
            bmDibSec32.bmiHeader.biPlanes          = 1;
            bmDibSec32.bmiHeader.biBitCount        = 32;
            bmDibSec32.bmiHeader.biCompression     = BI_RGB;
            bmDibSec32.bmiHeader.biSizeImage       = 0;
            bmDibSec32.bmiHeader.biXPelsPerMeter   = 100;
            bmDibSec32.bmiHeader.biYPelsPerMeter   = 100;
            bmDibSec32.bmiHeader.biClrUsed         = 0;
            bmDibSec32.bmiHeader.biClrImportant    = 0;

            pbmiDIB8->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
            pbmiDIB8->bmiHeader.biWidth           = Width;
            pbmiDIB8->bmiHeader.biHeight          = Height;
            pbmiDIB8->bmiHeader.biPlanes          = 1;
            pbmiDIB8->bmiHeader.biBitCount        = 8;
            pbmiDIB8->bmiHeader.biCompression     = BI_RGB;
            pbmiDIB8->bmiHeader.biSizeImage       = 0;
            pbmiDIB8->bmiHeader.biXPelsPerMeter   = 100;
            pbmiDIB8->bmiHeader.biYPelsPerMeter   = 100;
            pbmiDIB8->bmiHeader.biClrUsed         = 0;
            pbmiDIB8->bmiHeader.biClrImportant    = 0;

            //
            // halftone palette
            // 

            memcpy(&pbmiDIB8->bmiColors[0],htPaletteRGBQUAD,256 * sizeof(RGBQUAD));

            hx = bmDibSec32.bmiHeader.biWidth;
            hy = Height;

            hbm8    = CreateDIBSection(hdc,pbmiDIB8,DIB_RGB_COLORS,&pdib8,NULL,0);
            hbm32   = CreateDIBSection(hdc,&bmDibSec32,DIB_RGB_COLORS,&pdib32,NULL,0);
            SetDIBits(hdc,hbm32,0,Height,pbmFileBits,pbmi,DIB_RGB_COLORS);

            //
            // stretch into hmb8 using halftone
            //

            HDC hdcm8  = CreateCompatibleDC(hdc);
            HDC hdcm32 = CreateCompatibleDC(hdc);
            HPALETTE hpal = CreateHalftonePalette(hdc);

            SelectObject(hdcm8,hbm8);
            SelectObject(hdcm32,hbm32);

            SelectPalette(hdcm8,hpal,FALSE);
            SelectPalette(hdc,hpal,FALSE);
            RealizePalette(hdcm8);
            RealizePalette(hdc);

            SetStretchBltMode(hdc,HALFTONE);

            StretchBlt(hdcm8,0,0,hx,hy,hdcm32,0,0,hx,hy,SRCCOPY);

            //
            // display image
            //

            BitBlt(hdc,0,0,hx,hy,hdcm8,0,0,SRCCOPY);

            //
            // free 
            //

            DeleteDC(hdcm8);
            DeleteDC(hdcm32);
            SelectPalette(hdc,(HPALETTE)GetStockObject(DEFAULT_PALETTE),TRUE);
            DeleteObject(hpal);

            UnmapViewOfFile(pFile);
            CloseHandle(hMap);
            CloseHandle(hFile);

            //
            // Write new image out
            //


            hFile = CreateFile("c:\\riverHT.bmp",
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        
            if (hFile != NULL)
            {
                ULONG FileSize = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD) + hx * hy;

                hMap = CreateFileMapping(hFile,
                                         NULL,
                                         PAGE_READWRITE,
                                         0,
                                         FileSize,
                                         NULL
                                         );
                if (hMap)
                {
                    pFile = MapViewOfFile(hMap,
                                          FILE_MAP_WRITE,
                                          0,
                                          0,
                                          NULL
                                          );
            
                    if (pFile)
                    {
                        PBITMAPFILEHEADER   pbmfOut = (PBITMAPFILEHEADER)pFile;
                        PBITMAPINFO         pbmiOut = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));

                        pbmfOut->bfType    = 'MB';
                        pbmfOut->bfSize    = FileSize;
                        pbmfOut->bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD);

                        PBYTE pbmFileBitsOut = (PBYTE)pbmfOut + pbmfOut->bfOffBits;

                        memcpy(pbmiOut,pbmiDIB8,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

                        //
                        // copy bitmap
                        //

                        memcpy(pbmFileBitsOut,pdib8,hx * hy);

                        UnmapViewOfFile(pFile);
                        CloseHandle(hMap);
                        CloseHandle(hFile);
                    }
                    else
                    {
                        wsprintf(msg,"MapViewOfFile riverht failed");
                        TextOut(hdc,10,10,msg,strlen(msg));
                    }
                }
                else
                {
                    wsprintf(msg,"CreateFileMapping riverht failed");
                    TextOut(hdc,10,10,msg,strlen(msg));
                }
            }
            else
            {
                wsprintf(msg,"CreateFile riverht failed");
                TextOut(hdc,10,10,msg,strlen(msg));
            }
        }
        else
        {
            wsprintf(msg,"MapViewOfFile Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
        }
    }
    else
    {
        wsprintf(msg,"CreateFileMapping Error = %li    ",GetLastError());
        TextOut(hdc,10,10,msg,strlen(msg));
    }

    DeleteObject(hbm8);
    DeleteObject(hbm32);
    ReleaseDC(pCallData->hwnd,hdc);
    LocalFree(pbmiDIB8);
}

/******************************Public*Routine******************************\
* vTestAlphaOverflow
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestAlphaOverflow(
    TEST_CALL_DATA *pCallData
    )
{
    HDC          hdc   = GetDCAndTransform(pCallData->hwnd);
    ULONG        xpos  = 0;
    ULONG        ypos  = 8;
    ULONG        dy    = 136;
    ULONG        dx    = 128+5;
    HPALETTE     hpal;
    BLENDFUNCTION BlendFunction = {0,0,0,0};
    BYTE          Alphas[] = {0xf0,0xf8,0xfc,0xfd,0xfe,0xff};

    //
    // tile screen
    //

    {
        RECT rect;
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFillCars);
        rect.bottom = ypos+dy+dy-4;
        FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    }

    //
    //  create a DIBSection to test transparent drawing
    //

    {
        PBITMAPINFO       pbmi;
        PBITMAPINFOHEADER pbmih;
        HBITMAP hdib;
        HBITMAP hdibA;
        ULONG ux,uy;
        PULONG pDib,pDibA;

        HDC hdcm  = CreateCompatibleDC(hdc);
        HDC hdcmA = CreateCompatibleDC(hdc);

        pbmi  = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

        pbmih->biSize            = sizeof(BITMAPINFOHEADER);
        pbmih->biWidth           = 128;
        pbmih->biHeight          = 128;
        pbmih->biPlanes          = 1;
        pbmih->biBitCount        = 32;
        pbmih->biCompression     = BI_BITFIELDS;
        pbmih->biSizeImage       = 0;
        pbmih->biXPelsPerMeter   = 0;
        pbmih->biYPelsPerMeter   = 0;
        pbmih->biClrUsed         = 0;
        pbmih->biClrImportant    = 0;

        PULONG pulMask = (PULONG)&pbmi->bmiColors[0];
        pulMask[0] = 0x00ff0000;
        pulMask[1] = 0x0000ff00;
        pulMask[2] = 0x000000ff;

        hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

        hdibA = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

        if ((hdib == NULL) || (hdibA == NULL))
        {
            MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
            goto ErrorExit;
        }

        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDib;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                  //BYTE blue  = (ux*2);
                  //BYTE green = (uy*2);
                  //BYTE red   = 0;
                  //BYTE alpha = 0xff;
                  BYTE blue  = 0xff;
                  BYTE green = 0xff;
                  BYTE red   = 0x80;
                  BYTE alpha = 0xff;
                  *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }
        }

        //
        // inter per-pixel aplha DIB
        //

        {
            PULONG ptmp = pDibA;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE  Alpha  = (ux * 2);
                    float fAlpha = (float)Alpha;
                    int   blue   = ux * 2;
                    int   green  = uy * 2;
                    int   red    = 0;

                    blue  = (int)((float)blue  * (fAlpha/255.0) + 0.5);
                    green = (int)((float)green * (fAlpha/255.0) + 0.5);

                    *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                }
            }

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x00000000;
                }
            }
        }

        //
        // display over black
        //

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectObject(hdcmA,hdibA);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);
        SelectPalette(hdcmA,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);
        RealizePalette(hdcmA);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = 0;


        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        // display over cars
        //

        BlendFunction.AlphaFormat         = 0;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcm, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        //
        //

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        BlendFunction.SourceConstantAlpha = Alphas[0];
        AlphaBlend(hdc,xpos      ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[1];
        AlphaBlend(hdc,xpos+dx   ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[2];
        AlphaBlend(hdc,xpos+2*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[3];
        AlphaBlend(hdc,xpos+3*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[4];
        AlphaBlend(hdc,xpos+4*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);
        BlendFunction.SourceConstantAlpha = Alphas[5];
        AlphaBlend(hdc,xpos+5*dx ,ypos,128,128,hdcmA, 0,0,128,128,BlendFunction);

        BitBlt(hdc,xpos+6*dx,ypos,128,128,hdcm,0,0,SRCCOPY);

        ypos += dy;

        //
        // free objects
        //

        DeleteDC(hdcm);
        DeleteDC(hdcmA);
        DeleteObject(hdib);
        DeleteObject(hdibA);
        LocalFree(pbmi);
    }

ErrorExit:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vInitPopupDIB
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    5/30/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vInitPopupDIB(
    HDC     hdc,
    HBITMAP hDIB
    )
{
    HANDLE  hFile    = NULL;
    HANDLE  hMap     = NULL;
    ULONG   hx,hy;
    PVOID   pFile    = NULL;

    hFile = CreateFile("c:\\dev\\disp\\popup.bmp",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile)
    {
        hMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 0,
                                 NULL
                                 );
        if (hMap)
        {
            pFile = MapViewOfFile(hMap,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  NULL
                                  );

            if (pFile)
            {
                BITMAPINFO          bmiDIB;
                PBITMAPFILEHEADER   pbmf = (PBITMAPFILEHEADER)pFile;
                PBITMAPINFO         pbmi = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));
                PBYTE               pbits = (PBYTE)pbmf + pbmf->bfOffBits;

                ULONG ulSize = sizeof(BITMAPINFO);

                //
                // calc color table size
                //

                if (pbmi->bmiHeader.biCompression == BI_RGB)
                {
                    if (pbmi->bmiHeader.biBitCount == 1)
                    {
                        ulSize += 1 * sizeof(ULONG);
                    }
                    else if (pbmi->bmiHeader.biBitCount == 4)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 16)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 15 * sizeof(ULONG);
                        }
                    }
                    else if (pbmi->bmiHeader.biBitCount == 8)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 256)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 255 * sizeof(ULONG);
                        }
                    }
                }
                else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                {
                    ulSize += 2 * sizeof(ULONG);
                }

                memcpy(&bmiDIB,pbmi,ulSize);

                {
                    BITMAPINFO bmDibSec;
                    PVOID      pdib = NULL;
                    PVOID      psrc;
                    LONG       Height = bmiDIB.bmiHeader.biHeight;

                    if (Height > 0)
                    {
                        Height = -Height;
                    }

                    bmDibSec.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                    bmDibSec.bmiHeader.biWidth           = bmiDIB.bmiHeader.biWidth;
                    bmDibSec.bmiHeader.biHeight          = Height;
                    bmDibSec.bmiHeader.biPlanes          = 1;
                    bmDibSec.bmiHeader.biBitCount        = 32;
                    bmDibSec.bmiHeader.biCompression     = BI_RGB;
                    bmDibSec.bmiHeader.biSizeImage       = 0;
                    bmDibSec.bmiHeader.biXPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biYPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biClrUsed         = 0;
                    bmDibSec.bmiHeader.biClrImportant    = 0;

                    hx = bmDibSec.bmiHeader.biWidth;
                    hy = - Height;


                    SetDIBits(hdc,hDIB,0,Height,pbits,&bmiDIB,DIB_RGB_COLORS);
                }

                UnmapViewOfFile(pFile);
            }

            CloseHandle(hMap);
        }
        else
        {
            CHAR msg[256];

            wsprintf(msg,"MapViewOfFile Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
        }
        CloseHandle(hFile);
    }
}


/******************************Public*Routine******************************\
* vRunPopupTests
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4-Jun-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vRunPopupTests(
    HDC     hdcScreen,
    HDC     hdcSrc,
    HBITMAP hbmSrc,
    HDC     hdcDst
    )
{
    ULONG   xpos     = 100;
    ULONG   ypos     = 100;
    ULONG   dy       = 136;
    ULONG   dx       = 164;
    ULONG   hx       = 256;
    ULONG   hy       = 256;

    RECT rect = {0,0,10000,10000};
    FillTransformedRect(hdcScreen,&rect,hbrFillCars);

    vInitPopupDIB(hdcSrc,hbmSrc);

    {
        ULONGLONG StartTime,StopTime;
        ULONG ix;
        ULONG Iter = 1;

        BLENDFUNCTION BlendFunction = {0,0,0,0};

        ULONG Index;
        BYTE  AlphaValue[] = {16,32,64,96,112,148,176,255,0};
        char  msg[255];                
        BlendFunction.BlendOp                 = AC_SRC_OVER;
        BlendFunction.AlphaFormat         = 0;
    
        xpos = 0;
        ypos = 0;
    
        BitBlt(hdcDst,0,0,hx,hy,hdcScreen,xpos,ypos,SRCCOPY);

        //
        // timed section
        //
    
        START_TIMER;
    
        Index = 0;
        do
        {
            BlendFunction.SourceConstantAlpha= AlphaValue[Index];
            AlphaBlend(hdcDst,0,0,hx,hy,hdcSrc, 0,0,hx,hy,BlendFunction);
            Index++;
        }while (AlphaValue[Index] != 0);
    
        END_TIMER;

        //
        // untimed display loop
        //

        BitBlt(hdcDst,0,0,hx,hy,hdcScreen,xpos,ypos,SRCCOPY);

        Index = 0;
        do
        {
            BlendFunction.SourceConstantAlpha= AlphaValue[Index];
            AlphaBlend(hdcDst,0,0,hx,hy,hdcSrc, 0,0,hx,hy,BlendFunction);
            BitBlt(hdcScreen,xpos,ypos,hx,hy,hdcDst,0,0,SRCCOPY);
            Index++;
        }while (AlphaValue[Index] != 0);


        ypos += (hy + 20);

        //
        // end timed section
        //
    
        wsprintf(msg,"MEM exec time = %li for %li blends",(LONG)StopTime,Index);
        TextOut(hdcScreen,xpos+10,ypos,msg,strlen(msg));
        ypos += 20;
    
        LONG ElapsedTime = (LONG)StopTime;
    
        wsprintf(msg,"Time per pixel = %li ns",(int)(((double(ElapsedTime) * 1000.0)/ double(Index))/(hx * hy)));
        TextOut(hdcScreen,xpos+10,ypos,msg,strlen(msg));
    
        ypos += 20;
    }
}

/**************************************************************************\
* vTestPopups
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestPopups(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HDC      hdcm = CreateCompatibleDC(hdc);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        HBITMAP  hdibSrc = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
        HBITMAP  hdibDst = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
        HDC      hdcSrc  = CreateCompatibleDC(hdc);
        HDC      hdcDst  = CreateCompatibleDC(hdc);

        SelectObject(hdcSrc,hdibSrc);
        SelectObject(hdcDst,hdibDst);

        if ((hdibSrc != NULL) && (hdibDst != NULL))
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunPopupTests(hdc,hdcSrc,hdibSrc,hdcDst);

            DeleteDC(hdcSrc);
            DeleteDC(hdcDst);
            DeleteObject(hdibSrc);
            DeleteObject(hdibDst);
        }
    }
    else 
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdibSrc = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
            HBITMAP  hdibDst = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
            HDC      hdcSrc  = CreateCompatibleDC(hdc);
            HDC      hdcDst  = CreateCompatibleDC(hdc);
    
            SelectObject(hdcSrc,hdibSrc);
            SelectObject(hdcDst,hdibDst);
    
            if ((hdibSrc != NULL) && (hdibDst != NULL))
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunPopupTests(hdc,hdcSrc,hdibSrc,hdcDst);
    
                DeleteDC(hdcSrc);
                DeleteDC(hdcDst);
                DeleteObject(hdibSrc);
                DeleteObject(hdibDst);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }
    }

    DeleteDC(hdcm);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

//
// TEST_ENTRY controls automatic menu generation
//
// [Menu Level, Test Param, Stress Enable, Test Name, Test Function Pointer]
//
// Menu Level 
//      used to autoamtically generate sub-menus.
//      1   = 1rst level menu
//      -n  = start n-level sub menu
//      n   = continue sub menu
// 
// Test Param
//      passed as parameter to test
//
//
// Stress Ensable
//      if 1, test is run in stress mode
//      if 0, test is not run (tests that require input or runforever)
//
//  
// Test Name
//      ascii test name for menu
//  
// Test Function Pointer
//      pfn
//




TEST_ENTRY  gTestAlphaEntry[] = {
{ 1,  0,1,(PUCHAR)"vTestAlphaOverflow             ", (PFN_DISP)vTestAlphaOverflow},
{-2,  0,1,(PUCHAR)"Multi-res Alpha Tests          ", (PFN_DISP)vTestDummy},

{-3,  0,1,(PUCHAR)" Test Alpha Popup DIB-DIB      ", (PFN_DISP)vTestDummy},
{ 3, -1,0,(PUCHAR)"vTestPopupst All               ", (PFN_DISP)vTestPopups},
{ 3,  0,1,(PUCHAR)"vTestPopupst 32BGRA            ", (PFN_DISP)vTestPopups},
{ 3,  1,1,(PUCHAR)"vTestPopupst 32RGB             ", (PFN_DISP)vTestPopups},
{ 3,  2,1,(PUCHAR)"vTestPopupst 32GRB             ", (PFN_DISP)vTestPopups},
{ 3,  3,1,(PUCHAR)"vTestPopupst 24                ", (PFN_DISP)vTestPopups},
{ 3,  4,1,(PUCHAR)"vTestPopupst 16_555            ", (PFN_DISP)vTestPopups},
{ 3,  5,1,(PUCHAR)"vTestPopupst 16_565            ", (PFN_DISP)vTestPopups},
{ 3,  6,1,(PUCHAR)"vTestPopupst 16_664            ", (PFN_DISP)vTestPopups},
{ 3,  7,1,(PUCHAR)"vTestPopupst 8                 ", (PFN_DISP)vTestPopups},
{ 3,  8,1,(PUCHAR)"vTestPopupst 4                 ", (PFN_DISP)vTestPopups},
{ 3,  9,1,(PUCHAR)"vTestPopupst 1                 ", (PFN_DISP)vTestPopups},

{-3,  0,1,(PUCHAR)" Test Alpha Width              ", (PFN_DISP)vTestDummy},
{ 3, -1,0,(PUCHAR)"vTestAlphaWidtht All           ", (PFN_DISP)vTestAlphaWidth},
{ 3,  0,1,(PUCHAR)"vTestAlphaWidtht 32BGRA        ", (PFN_DISP)vTestAlphaWidth},
{ 3,  1,1,(PUCHAR)"vTestAlphaWidtht 32RGB         ", (PFN_DISP)vTestAlphaWidth},
{ 3,  2,1,(PUCHAR)"vTestAlphaWidtht 32GRB         ", (PFN_DISP)vTestAlphaWidth},
{ 3,  3,1,(PUCHAR)"vTestAlphaWidtht 24            ", (PFN_DISP)vTestAlphaWidth},
{ 3,  4,1,(PUCHAR)"vTestAlphaWidtht 16_555        ", (PFN_DISP)vTestAlphaWidth},
{ 3,  5,1,(PUCHAR)"vTestAlphaWidtht 16_565        ", (PFN_DISP)vTestAlphaWidth},
{ 3,  6,1,(PUCHAR)"vTestAlphaWidtht 16_664        ", (PFN_DISP)vTestAlphaWidth},
{ 3,  7,1,(PUCHAR)"vTestAlphaWidtht 8             ", (PFN_DISP)vTestAlphaWidth},
{ 3,  8,1,(PUCHAR)"vTestAlphaWidtht 4             ", (PFN_DISP)vTestAlphaWidth},
{ 3,  9,1,(PUCHAR)"vTestAlphaWidtht 1             ", (PFN_DISP)vTestAlphaWidth},
{-3,  0,1,(PUCHAR)"Test Alpha Offset              ", (PFN_DISP)vTestDummy},     
{ 3, -1,0,(PUCHAR)"vTestAlphaOffset All           ", (PFN_DISP)vTestAlphaOffset},
{ 3,  0,1,(PUCHAR)"vTestAlphaOffset 32BGRA        ", (PFN_DISP)vTestAlphaOffset},
{ 3,  1,1,(PUCHAR)"vTestAlphaOffset 32RGB         ", (PFN_DISP)vTestAlphaOffset},
{ 3,  2,1,(PUCHAR)"vTestAlphaOffset 32GRB         ", (PFN_DISP)vTestAlphaOffset},
{ 3,  3,1,(PUCHAR)"vTestAlphaOffset 24            ", (PFN_DISP)vTestAlphaOffset},
{ 3,  4,1,(PUCHAR)"vTestAlphaOffset 16_555        ", (PFN_DISP)vTestAlphaOffset},
{ 3,  5,1,(PUCHAR)"vTestAlphaOffset 16_565        ", (PFN_DISP)vTestAlphaOffset},
{ 3,  6,1,(PUCHAR)"vTestAlphaOffset 16_664        ", (PFN_DISP)vTestAlphaOffset},
{ 3,  7,1,(PUCHAR)"vTestAlphaOffset 8             ", (PFN_DISP)vTestAlphaOffset},
{ 3,  8,1,(PUCHAR)"vTestAlphaOffset 4             ", (PFN_DISP)vTestAlphaOffset},
{ 3,  9,1,(PUCHAR)"vTestAlphaOffset 1             ", (PFN_DISP)vTestAlphaOffset},
{-3,  0,1,(PUCHAR)"vTestAlphaStretch              ", (PFN_DISP)vTestDummy},
{ 3, -1,0,(PUCHAR)"vTestAlphaStretch All          ", (PFN_DISP)vTestAlphaStretch},
{ 3,  0,1,(PUCHAR)"vTestAlphaStretch 32BGRA       ", (PFN_DISP)vTestAlphaStretch},
{ 3,  1,1,(PUCHAR)"vTestAlphaStretch 32RGB        ", (PFN_DISP)vTestAlphaStretch},
{ 3,  2,1,(PUCHAR)"vTestAlphaStretch 32GRB        ", (PFN_DISP)vTestAlphaStretch},
{ 3,  3,1,(PUCHAR)"vTestAlphaStretch 24           ", (PFN_DISP)vTestAlphaStretch},
{ 3,  4,1,(PUCHAR)"vTestAlphaStretch 16_555       ", (PFN_DISP)vTestAlphaStretch},
{ 3,  5,1,(PUCHAR)"vTestAlphaStretch 16_565       ", (PFN_DISP)vTestAlphaStretch},
{ 3,  6,1,(PUCHAR)"vTestAlphaStretch 16_664       ", (PFN_DISP)vTestAlphaStretch},
{ 3,  7,1,(PUCHAR)"vTestAlphaStretch 8            ", (PFN_DISP)vTestAlphaStretch},
{ 3,  8,1,(PUCHAR)"vTestAlphaStretch 4            ", (PFN_DISP)vTestAlphaStretch},
{ 3,  9,1,(PUCHAR)"vTestAlphaStretch 1            ", (PFN_DISP)vTestAlphaStretch},
{-3,  0,1,(PUCHAR)"vTestStretch                   ", (PFN_DISP)vTestDummy},     
{ 3, -1,0,(PUCHAR)"vTestStretch All               ", (PFN_DISP)vTestStretch},
{ 3,  0,1,(PUCHAR)"vTestStretch 32BGRA            ", (PFN_DISP)vTestStretch},
{ 3,  1,1,(PUCHAR)"vTestStretch 32RGB             ", (PFN_DISP)vTestStretch},
{ 3,  2,1,(PUCHAR)"vTestStretch 32GRB             ", (PFN_DISP)vTestStretch},
{ 3,  3,1,(PUCHAR)"vTestStretch 24                ", (PFN_DISP)vTestStretch},
{ 3,  4,1,(PUCHAR)"vTestStretch 16_555            ", (PFN_DISP)vTestStretch},
{ 3,  5,1,(PUCHAR)"vTestStretch 16_565            ", (PFN_DISP)vTestStretch},
{ 3,  6,1,(PUCHAR)"vTestStretch 16_664            ", (PFN_DISP)vTestStretch},
{ 3,  7,1,(PUCHAR)"vTestStretch 8                 ", (PFN_DISP)vTestStretch},
{ 3,  8,1,(PUCHAR)"vTestStretch 4                 ", (PFN_DISP)vTestStretch},
{ 3,  9,1,(PUCHAR)"vTestStretch 1                 ", (PFN_DISP)vTestStretch},
{-3,  0,1,(PUCHAR)"vTestAlphaStretchDIB           ", (PFN_DISP)vTestDummy}, 
{ 3, -1,0,(PUCHAR)"vTestAlphaStretchDIB All       ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  0,1,(PUCHAR)"vTestAlphaStretchDIB 32BGRA    ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  1,1,(PUCHAR)"vTestAlphaStretchDIB 32RGB     ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  2,1,(PUCHAR)"vTestAlphaStretchDIB 32GRB     ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  3,1,(PUCHAR)"vTestAlphaStretchDIB 24        ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  4,1,(PUCHAR)"vTestAlphaStretchDIB 16_555    ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  5,1,(PUCHAR)"vTestAlphaStretchDIB 16_565    ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  6,1,(PUCHAR)"vTestAlphaStretchDIB 16_664    ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  7,1,(PUCHAR)"vTestAlphaStretchDIB 8         ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  8,1,(PUCHAR)"vTestAlphaStretchDIB 4         ", (PFN_DISP)vTestAlphaStretchDIB},
{ 3,  9,1,(PUCHAR)"vTestAlphaStretchDIB 1         ", (PFN_DISP)vTestAlphaStretchDIB},
{-3,  0,1,(PUCHAR)"vTestStretchDIB                ", (PFN_DISP)vTestDummy},                  
{ 3, -1,0,(PUCHAR)"vTestStretchDIB All            ", (PFN_DISP)vTestStretchDIB},
{ 3,  0,1,(PUCHAR)"vTestStretchDIB 32BGRA         ", (PFN_DISP)vTestStretchDIB},
{ 3,  1,1,(PUCHAR)"vTestStretchDIB 32RGB          ", (PFN_DISP)vTestStretchDIB},
{ 3,  2,1,(PUCHAR)"vTestStretchDIB 32GRB          ", (PFN_DISP)vTestStretchDIB},
{ 3,  3,1,(PUCHAR)"vTestStretchDIB 24             ", (PFN_DISP)vTestStretchDIB},
{ 3,  4,1,(PUCHAR)"vTestStretchDIB 16_555         ", (PFN_DISP)vTestStretchDIB},
{ 3,  5,1,(PUCHAR)"vTestStretchDIB 16_565         ", (PFN_DISP)vTestStretchDIB},
{ 3,  6,1,(PUCHAR)"vTestStretchDIB 16_664         ", (PFN_DISP)vTestStretchDIB},
{ 3,  7,1,(PUCHAR)"vTestStretchDIB 8              ", (PFN_DISP)vTestStretchDIB},
{ 3,  8,1,(PUCHAR)"vTestStretchDIB 4              ", (PFN_DISP)vTestStretchDIB},
{ 3,  9,1,(PUCHAR)"vTestStretchDIB 1              ", (PFN_DISP)vTestStretchDIB},
{-3,  0,1,(PUCHAR)"vTestAlphaIsotropic            ", (PFN_DISP)vTestDummy},                  
{ 3, -1,0,(PUCHAR)"vTestAlphaIsotropic All        ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  0,1,(PUCHAR)"vTestAlphaIsotropic 32BGRA     ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  1,1,(PUCHAR)"vTestAlphaIsotropic 32RGB      ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  2,1,(PUCHAR)"vTestAlphaIsotropic 32GRB      ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  3,1,(PUCHAR)"vTestAlphaIsotropic 24         ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  4,1,(PUCHAR)"vTestAlphaIsotropic 16_555     ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  5,1,(PUCHAR)"vTestAlphaIsotropic 16_565     ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  6,1,(PUCHAR)"vTestAlphaIsotropic 16_664     ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  7,1,(PUCHAR)"vTestAlphaIsotropic 8          ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  8,1,(PUCHAR)"vTestAlphaIsotropic 4          ", (PFN_DISP)vTestAlphaIsotropic },
{ 3,  9,1,(PUCHAR)"vTestAlphaIsotropic 1          ", (PFN_DISP)vTestAlphaIsotropic },
{-3,  0,1,(PUCHAR)"vTestAlphaAnisotropic          ", (PFN_DISP)vTestDummy},                  
{ 3, -1,0,(PUCHAR)"vTestAlphaAnisotropic All      ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  0,1,(PUCHAR)"vTestAlphaAnisotropic 32BGRA   ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  1,1,(PUCHAR)"vTestAlphaAnisotropic 32RGB    ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  2,1,(PUCHAR)"vTestAlphaAnisotropic 32GRB    ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  3,1,(PUCHAR)"vTestAlphaAnisotropic 24       ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  4,1,(PUCHAR)"vTestAlphaAnisotropic 16_555   ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  5,1,(PUCHAR)"vTestAlphaAnisotropic 16_565   ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  6,1,(PUCHAR)"vTestAlphaAnisotropic 16_664   ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  7,1,(PUCHAR)"vTestAlphaAnisotropic 8        ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  8,1,(PUCHAR)"vTestAlphaAnisotropic 4        ", (PFN_DISP)vTestAlphaAnisotropic },
{ 3,  9,1,(PUCHAR)"vTestAlphaAnisotropic 1        ", (PFN_DISP)vTestAlphaAnisotropic },
{ 1,  0,1,(PUCHAR)"vTestAlpha                     ", (PFN_DISP)vTestAlpha },
{ 1,  0,1,(PUCHAR)"vTestAlphaDefPal               ", (PFN_DISP)vTestAlphaDefPal },
{ 1,  0,1,(PUCHAR)"vTestAlpha1                    ", (PFN_DISP)vTestAlpha1 },
{ 1,  0,1,(PUCHAR)"vTestAlpha4                    ", (PFN_DISP)vTestAlpha4 },
{ 1,  0,1,(PUCHAR)"vTestAlphaDIB                  ", (PFN_DISP)vTestAlphaDIB },
{ 1,  0,1,(PUCHAR)"vTestAlphaDIB_PAL_COLORS       ", (PFN_DISP)vTestAlphaDIB_PAL_COLORS},
{-2,  0,1,(PUCHAR)" Test Popup                    ", (PFN_DISP)vTestDummy},
{ 2,  0,1,(PUCHAR)"vTestAlphaPopup32              ", (PFN_DISP)vTestAlphaPopup32},
{ 2,  0,1,(PUCHAR)"vTestAlphaPopup24              ", (PFN_DISP)vTestAlphaPopup24},
{ 2,  0,1,(PUCHAR)"vTestAlphaPopup16_555          ", (PFN_DISP)vTestAlphaPopup16_555},
{ 1,  0,1,(PUCHAR)"vTestAlphaBitmapFormats        ", (PFN_DISP)vTestAlphaBitmapFormats},
{ 0,  0,1,(PUCHAR)"                               ", (PFN_DISP)vTestDummy},
};

ULONG gNumAlphaTests = sizeof(gTestAlphaEntry)/sizeof(TEST_ENTRY);
ULONG gNumAutoAlphaTests = gNumAlphaTests;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\dispguid.h ===
DEFINE_GUID(IID_IEnumRECT,  0x00021140, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ICMView.rc
//
#define IDM_FILE_CLOSE                  100
#define IDM_FILE_EXIT                   101
#define IDM_FILE_OPEN                   102
#define IDM_FILE_PRINT                  104
#define IDM_FILE_RECENT                 105
#define IDM_FILE_RECENT1                106
#define IDM_FILE_RECENT2                107
#define IDM_FILE_RECENT3                108
#define IDM_HELP_ABOUT                  109
#define IDM_HELPCONTENTS                110
#define IDM_HELPTOPICS                  111
#define IDD_TRANSLATE                   111
#define IDM_WINDOW_ARRANGE              119
#define IDM_WINDOW_CASCADE              120
#define IDM_WINDOW_TILE_HORIZONTAL      121
#define IDM_WINDOW_TILE_VERTICAL        122

#define DLG_VERFIRST                    400
#define IDC_COMPANY                     400
#define IDC_FILEDESC                    401
#define IDC_PRODVER                     402
#define IDC_COPYRIGHT                   403
#define IDC_OSVERSION                   404
#define IDC_TRADEMARK                   405
#define DLG_VERLAST                     406
#define IDC_LABEL                       406
#define IDD_DISPLAY                     1000
#define IDC_DISPLAY_STRETCH             1001
#define IDC_DISPLAY_ANDSCAN             1002
#define IDC_DISPLAY_DELETESCAN          1003
#define IDC_DISPLAY_ORSCAN              1004
#define IDC_DISPLAY_DIBSECTION          1005
#define IDC_PRINT_IMAGE                 1053
#define IDC_PROGRESS                    1054

#define IDD_PRINT                       2000
#define IDC_PRINT_FILENAME              2001
#define IDC_PRINT_PRINTERLIST           2002
#define IDC_PRINT_ACTUALSIZE            2003
#define IDC_PRINT_BESTFIT               2004
#define IDD_PRINTING                    3000

#define IDS_BUFFERTOOSMALL              10000
#define IDS_CREATEICFAILURE             10001
#define IDS_DIALOGFAILURE               10002
#define IDS_DNDMMISMATCH                10003
#define IDS_FILTERSTRING                10004
#define IDS_FINDRESFAILURE              10005
#define IDS_GETDEVMODEFAIL              10006
#define IDS_INITFAILURE                 10007
#define IDS_INITIALIZATION              10008
#define IDS_INVALIDFILENAME             10009
#define IDS_LOADDRVFAILURE              10010
#define IDS_LOADRESFAILURE              10011
#define IDS_LOADSTRFAILURE              10012
#define IDS_LOCKRESFAILURE              10013
#define IDS_MEMALLOCFAILURE             10014
#define IDS_MEMLOCKFAILURE              10015
#define IDS_NODEFAULTPRN                10016
#define IDS_NODEVICES                   10017
#define IDS_NOFONTS                     10018
#define IDS_NOHINSTANCE                 10019
#define IDS_NOHOOK                      10020
#define IDS_NOTEMPLATE                  10021
#define IDS_PARSEFAILURE                10022
#define IDS_PRINTERNOTFOUND             10023
#define IDS_RETDEFFAILURE               10024
#define IDS_SETUPFAILURE                10025
#define IDS_STRUCTSIZE                  10026
#define IDS_SUBCLASSFAILURE             10027
#define IDS_UNKNOWNERROR                10028

#define ID_TEST                         40038
#define IDM_FILE_ICM10                  40056
#define IDM_FILE_ICM20                  40057
#define IDM_FILE_CONFIGURE_ICM          40060
#define IDM_FILE_DISPLAY                40061
#define ID_FILE_SAVEAS                  40065
#define IDM_FILE_PRINT_SETUP            40066
#define IDM_FILE_COPY_CLIPBOARD_DDB     40067 
#define IDM_FILE_COPY_CLIPBOARD_DIB     40068 
#define IDM_FILE_COPY_CLIPBOARD_DIBSECT 40069 
#define IDM_FILE_PASTE_CLIPBOARD_DIB    40070
#define IDM_FILE_PASTE_CLIPBOARD_DIBV5  40071

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
    #ifndef APSTUDIO_READONLY_SYMBOLS
        #define _APS_NO_MFC                     1
        #define _APS_NEXT_RESOURCE_VALUE        112
        #define _APS_NEXT_COMMAND_VALUE         40072
        #define _APS_NEXT_CONTROL_VALUE         1055
        #define _APS_NEXT_SYMED_VALUE           105
    #endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\bitmap.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   test.c

Abstract:

    Small, independent windows test programs

Author:

   Mark Enstrom   (marke)  29-Apr-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.h"
#include <stdlib.h>
#include "disp.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\disp.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    pal.h

Abstract:



Author:

    Mark Enstrom (marke) 14-Feb-1994

Revision History:

--*/


#define TransparentDIBits(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) 1
#define AlphaDIBBlend(a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13) 1


BOOL
FillTransformedRect(
    HDC hdc,
    CONST RECT *lprc,
    HBRUSH hbr
    );

HDC
GetDCAndTransform(
    HWND hwnd
    );

int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR szCmdLine,
    int cmdShow
    );

LONG FAR
PASCAL WndProc(
    HWND        hWnd,
    unsigned    msg,
    UINT        wParam,
    LONG        lParam
    );

VOID
TestTextMetrics(
    HWND    hwnd
    );


BOOL
APIENTRY
ResultsDlgProc(
    HWND hwnd,
    UINT msg,
    UINT wParam,
    LONG lParam);

VOID
vInitDib(
    PUCHAR pdib,
    ULONG  bpp,
    ULONG  Type,
    ULONG  cx,
    ULONG  cy
    );

HBITMAP
hCreateBGR32AlphaSurface(
    HDC   hdc,
    LONG  cx,
    LONG  cy,
    PVOID *ppvBitmap,
    BOOL  bPerPixelAlpha
    );


extern ULONG    ulBpp[];
extern ULONG    ulFor[];
extern PCHAR    pFormatStr[];
extern ULONG    ulBppDIB[];
extern ULONG    ulForDIB[];
extern PCHAR    pFormatStrDIB[];

HBITMAP
hCreateAlphaStretchBitmap(
    HDC   hdc,
    ULONG BitsPerPixel,
    ULONG ColorFormat,
    LONG  xDib,
    LONG  yDib
    );

PBITMAPINFO
pbmiCreateAlphaStretchDIB(
    HDC      hdc,
    ULONG    BitsPerPixel,
    ULONG    ColorFormat,
    PVOID   *pBits,
    HBITMAP *phdib
    );


//
// alpha tests
//

VOID vTestAlphaStretch32BGRA(HWND);
VOID vTestAlphaStretch32RGB(HWND);
VOID vTestAlphaStretch16(HWND);
VOID vTestAlpha4(HWND);
VOID vTestAlpha1(HWND);
VOID vTestAlphaDIB_PAL_COLORS(HWND);
VOID vTestAlphaDIB(HWND);
VOID vTestAlphaPopup(HWND);
VOID vTestAlphaFilter(HWND);
VOID vTestAlpha(HWND);
VOID vTestAlphaWidth(HWND);
VOID vTestAlphaOffset(HWND);
VOID vTestAlphaDefPal(HWND);
VOID vTestAlphaBitmapFormats(HWND hwnd);

//
// transparentblt and transparentdibits tests
//
VOID vTest1(HWND hWnd);
VOID vTest3(HWND hWnd);
VOID vTest4(HWND hWnd);



//
// error message
//

#define ASSERT(e,s) if(e) MessageBox(NULL,s,"ERROR",MB_OK);

HPALETTE
CreateHtPalette(HDC hdc);


//
// display tests
//

//
// timer tests
//

typedef struct _TIMER_RESULT
{
    LONG        TestTime;
    LONG        ImageSize;
    LONG        TimerPerPixel;
    LONG        Bandwidth;
}TIMER_RESULT,*PTIMER_RESULT;

typedef struct _TEST_CALL_DATA
{
    HWND          hwnd;
    LONG          Param;
    ULONGLONG     ullTestTime;
    PTIMER_RESULT pTimerResult;
}TEST_CALL_DATA,*PTEST_CALL_DATA;

typedef VOID (*PFN_DISP)(TEST_CALL_DATA *);

VOID vTestDummy(TEST_CALL_DATA *);

typedef struct _TEST_ENTRY
{
    LONG      Level;
    LONG      Param;
    LONG      Auto;
    PUCHAR    Api;
    PFN_DISP  pfn;
}TEST_ENTRY,*PTEST_ENTRY;

#define NUM_TESTS sizeof(gTestEntry)/sizeof(TEST_ENTRY)

extern TEST_ENTRY    gTestEntry[];
extern TEST_ENTRY    gTestAlphaEntry[];
extern TEST_ENTRY    gTestTranEntry[];
extern TEST_ENTRY   gTimerEntry[];
extern PTIMER_RESULT gpTimerResult;

extern HBITMAP hbmCars;
extern HBRUSH  hbrFillCars;
extern HFONT   hTestFont;

VOID
vTestTessel(
    TEST_CALL_DATA *pCallData
    );

//
// graphics objects
//

typedef union _RGBU
{
    ULONG    ul;
    RGBQUAD  rgb;
}RGBU,*PRGBU;


extern HWND        hWndMain;
extern HINSTANCE   hInstMain;
extern ULONG       InitialTest;
extern ULONG       gNumTests;
extern ULONG       gNumTranTests;
extern ULONG       gNumAlphaTests;
extern ULONG       gNumTimers;
extern BOOL        bThreadActive;
extern HANDLE      gThreadHandle;
extern BOOL        gfPentium;

#define T565 0
#define T555 1
#define T466 2

//
// file save
//

VOID
SaveResults();

PCHAR
SelectOutFileName(HWND hWnd);


VOID 
WriteBatchResults(FILE *,ULONG);

ULONG
ulDetermineScreenFormat(
    HWND    hwnd
    );

#define SCR_UNKNOWN 0
#define SCR_1       1
#define SCR_4       2
#define SCR_8       3
#define SCR_16_555  4
#define SCR_16_565  5
#define SCR_24      6
#define SCR_32_RGB  7
#define SCR_32_BGR  8

extern PCHAR pScreenDef[];


#define WINNT_PLATFORM Win32VersionInformation.dwPlatformId	== VER_PLATFORM_WIN32_NT
extern OSVERSIONINFO Win32VersionInformation;	/* OS Version Info */



/*
**  Cycle count overhead. This is a number of cycles required to actually
**  calculate the cycle count. To get the actual number of net cycles between
**  two calls to GetCycleCount, subtract CCNT_OVERHEAD.
**
**  For example:
**
**  __int64 start, finish, actual_cycle_count;
**
**  start = GetCycleCount ();
**
**      ... do some stuff ...
**
**  finish = GetCycleCount ();
**
**  actual_cycle_count = finish - start - CCNT_OVERHEAD;
**
**
*/

#define CCNT_OVERHEAD 8

#ifdef _X86_

#pragma warning( disable: 4035 )    /* Don't complain about lack of return value */

__inline __int64 GetCycleCount ()
{
__asm   _emit   0x0F
__asm   _emit   0x31    /* rdtsc */
    // return EDX:EAX       causes annoying warning
};

__inline unsigned GetCycleCount32 ()  // enough for about 40 seconds
{
__asm   push    EDX
__asm   _emit   0x0F
__asm   _emit   0x31    /* rdtsc */
__asm   pop     EDX
    // return EAX       causes annoying warning
};

#pragma warning( default: 4035 )

#endif // _X86_

extern _int64  PerformanceFreq;        /* Timer Frequency  */

#define INIT_TIMER   ULONG Iter = pCallData->Param; \
                     ULONGLONG StartTime,StopTime;  \
                     ULONG ix;


#define START_TIMER  StartTime = BeginTimeMeasurement()

#define END_TIMER    StopTime = EndTimeMeasurement(StartTime,Iter); \


_int64
BeginTimeMeasurement();

ULONGLONG
EndTimeMeasurement(
    _int64  StartTime,
    ULONG      Iter);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\icmview\regutil.h ===
//THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
//ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
//THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
//  FILE:
//    REGUTIL.H
//
//  PURPOSE:
//    Registry utility functions.
//
//  PLATFORMS:
//    Windows 95, Windows NT
//
//  SPECIAL INSTRUCTIONS: N/A
//

// General pre-processor macros

// General STRUCTS && TYPEDEFS

// Function prototypes
LPTSTR GetRegistryString(HKEY hKeyClass, LPTSTR lpszSubKey, LPTSTR lpszValueName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\disp.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    disp.c

Abstract:

    Template for simple windows program

Author:

   Mark Enstrom  (marke)

Environment:

    C

Revision History:

   08-26-92     Initial version



--*/

#include "precomp.h"
#include "disp.h"
#include <wchar.h>
#include "resource.h"

HWND             hWndMain;
HINSTANCE        hInstMain;
ULONG            InitialTest     = 0;
PFN_DISP         pfnLast         = NULL;
BOOL             bThreadActive   = FALSE;
HANDLE           gThreadHandle   = 0;
DWORD            dwThreadID      = 0;
BOOL             gfPentium       = FALSE;
BOOL             gfUseCycleCount = FALSE;
CRITICAL_SECTION ThreadCritSect;
SYSTEM_INFO      SystemInfo;
_int64           PerformanceFreq = 1;
OSVERSIONINFO    Win32VersionInformation;
PTIMER_RESULT    gpTimerResult;
HBITMAP          hbmCars;
HBRUSH           hbrFillCars;
HFONT            hTestFont;
TEST_CALL_DATA   TestCallData;
XFORM            rotationXform = {1.0, 0.0, 0.0, 1.0, 0.0, 0.0};

#define DISP_SUBITEM(fmt, v)                                                     \
                sprintf(szT, fmt, v);                                            \
                ListView_SetItemText(hwndList, lvl.iItem, ++lvl.iSubItem, szT);


/******************************Public*Routine******************************\
* GetDCAndTransform
*   Calls GetDC and sets the world transform to the current rotation.
*
* Arguments:
*   hwnd
*
*
* Return Value:
*   hdc
*
*
* History:
*
*    2-Jul-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/
HDC
GetDCAndTransform(
    HWND hwnd
    )
{
    HDC hdc;

    hdc = GetDC(hwnd);
    SetGraphicsMode(hdc, GM_ADVANCED);
    SetWorldTransform(hdc, &rotationXform);
    return hdc;
}


/******************************Public*Routine******************************\
* FillTransformedRect
*   Same as FillRect except that it obeys the current world transform.  This
*   is achieved by calling Rectangle instead of FillRect.
*
* Arguments:
*   hdc
*   lprc
*   hbr
*
* Return Value:
*   Success or failure
*
*
* History:
*
*    2-Jul-1997 -by- Ori Gershony [orig]
*
\**************************************************************************/
BOOL
FillTransformedRect(
    HDC hdc,
    CONST RECT *lprc,
    HBRUSH hbr
    )
{
    HBRUSH oldHbr;
    BOOL retValue;

    oldHbr = (HBRUSH) SelectObject(hdc, hbr);
    retValue = Rectangle(hdc, lprc->left, lprc->top, lprc->right, lprc->bottom); 
    SelectObject(hdc, oldHbr);

    return retValue;
}



/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    26-Apr-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

int PASCAL
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrev,
    LPSTR szCmdLine,
    int cmdShow
)
{
    MSG         msg;
    WNDCLASS    wc;
    HWND        hWndDesktop;
    RECT        WindowRect;

    hInstMain =  hInst;

    //
    // read command line params to determine initial test
    //
    // [-t x]
    //

    InitCommonControls();

    pfnLast = gTestEntry[0].pfn;

    if (szCmdLine)
    {
        PUCHAR p = (PUCHAR)szCmdLine;

        while (*p != '\0')
        {
            if (*p == '-')
            {
                p++;

                if ((*p == 't') || (*p == 'T'))
                {
                    ULONG iret,test;

                    p++;
                    iret = sscanf((const char *)p," %i",&test);

                    if ((iret == 1) && (test < gNumTests))
                    {
                        pfnLast = gTestEntry[test].pfn;
                    }

                    break;
                }
            }
            else
            {
                p++;
            }
        }
    }

    //
    // determine processor type for timer measurements
    //

    #ifdef _X86_

        GetSystemInfo(&SystemInfo);

        if (gfUseCycleCount&&(PROCESSOR_INTEL_PENTIUM==SystemInfo.dwProcessorType))
        {
            gfPentium = TRUE;
        }

    #endif

    //
    // Calculate Timer Frequency For Current Machine and
    // Convert to MicroSeconds (Actual time will be presented in units of 100ns)
    //

    BOOL Status = QueryPerformanceFrequency((LARGE_INTEGER *)&PerformanceFreq);

    if(Status)
    {
        PerformanceFreq /= 1000000;
    }
    else
    {
        PerformanceFreq = 1;
    }

    //
    // Create (if no prev instance) and Register the class
    //

    if (!hPrev)
    {
        wc.hCursor        = LoadCursor((HINSTANCE)NULL, IDC_ARROW);
        wc.hIcon          = (HICON)NULL;
        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_PAL_MENU);
        wc.lpszClassName  = "palClass";
        wc.hbrBackground  = (HBRUSH)GetStockObject(LTGRAY_BRUSH);
        wc.hInstance      = hInst;
        wc.style          = 0;
        wc.lpfnWndProc    = WndProc;
        wc.cbWndExtra     = 0;
        wc.cbClsExtra     = 0;


        if (!RegisterClass(&wc)) {
            return FALSE;
        }
    }

    //
    // determine screen width
    //

    hWndDesktop = GetDesktopWindow();
    GetWindowRect(hWndDesktop,&WindowRect);

    //
    // Create and show the main window
    //

    hWndMain = CreateWindow ("palClass",         // class name
                            "DC Test",           // caption
                            WS_OVERLAPPEDWINDOW, // style bits
                            0,                   // horizontal position.
                            0,                   // vertical position.
                            WindowRect.right,    // width.
                            WindowRect.bottom - 64,// height.
                            (HWND)NULL,          // parent window
                            (HMENU)NULL,         // use class menu
                            (HINSTANCE)hInst,    // instance handle
                            (LPSTR)NULL          // no params to pass on
                           );

    if (hWndMain == NULL) {
        return(FALSE);
    }

    //
    //  Show the window
    //

    ShowWindow(hWndMain,cmdShow);
    UpdateWindow(hWndMain);
    SetFocus(hWndMain);

    //
    // init thread data
    //

    InitializeCriticalSection(&ThreadCritSect);

    bThreadActive = FALSE;
    gThreadHandle = NULL;
    dwThreadID = 0;

    //
    // Main message loop
    //

    while (GetMessage(&msg,(HWND)NULL,0,0))
    {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
    }

  return msg.wParam;
}


/**************************************************************************\
* DisplayTime
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/1/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vDisplayTime(
    HDC           hdc,
    PTIMER_RESULT ptimer
    )
{
    //
    // display memory bandwidth
    //

    CHAR     tmsg[256];
    double   fImageSize    = (double)ptimer->ImageSize;

    wsprintf(tmsg,"Time = %8li",ptimer->TestTime);
    TextOut(hdc,10,10,tmsg,strlen(tmsg));

    if (ptimer->ImageSize != 0)
    {
        double   fTimePerPixel = (ptimer->TestTime * 1000) / fImageSize;
        double   fbw = (4.0 * 1000000000.0)/fTimePerPixel;

        ptimer->TimerPerPixel = (LONG)fTimePerPixel;

        if (ptimer->TimerPerPixel < 20)
        {
            ptimer->Bandwidth     = 0;
        }
        else
        {
            ptimer->Bandwidth     = (LONG)fbw;
        }

        wsprintf(tmsg,"Time per pixel = %li ns, bw = %li bytes/s",ptimer->TimerPerPixel,ptimer->Bandwidth);
        TextOut(hdc,10,40,tmsg,strlen(tmsg));
    }
}


/**************************************************************************\
* RunAllTimerTests
*
*   This routine is called on a separate thread to run all timer tests
*
* Arguments:
*
*   hwnd
*
* Return Value:
*
*
*
* History:
*
*    2/28/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
RunAllTimerTests(HWND hwnd)
{
    ULONG iTest;
    PFN_DISP pfnTimer = NULL;
    HDC   hdc = GetDC(hwnd);

    ShowCursor(FALSE);

    for (iTest = 0;iTest < gNumTimers; iTest++)
    {
        ULONGLONG      ululTime;

        if (gTimerEntry[iTest].Auto == 1)
        {
            SetWindowText(hwnd,(CHAR *)gTimerEntry[iTest].Api);
            pfnTimer = gTimerEntry[iTest].pfn;
            PatBlt(hdc,0,0,2000,2000,BLACKNESS);
            TestCallData.Param = gTimerEntry[iTest].Param;
            TestCallData.pTimerResult = &gpTimerResult[iTest];
            (*pfnTimer)(&TestCallData);
            vDisplayTime(hdc,&gpTimerResult[iTest]);
        }
    }

    ShowCursor(TRUE);

    DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hwnd, (DLGPROC)ResultsDlgProc);
    ReleaseDC(hwnd,hdc);
}


/**************************************************************************\
* RunAlls
*
*   This routine called on separate thread to run through each functionality
*   test
*
* Arguments:
*
*   hwnd
*
* Return Value:
*
*
*
* History:
*
*    2/28/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
RunAllFunctionalityTests(HWND hwnd)
{
    PFN_DISP pfnDisp;
    ULONG iTest;
    HDC   hdc = GetDC(hwnd);

    for (iTest = 0;iTest < gNumTests; iTest++)
    {
        if (gTestEntry[iTest].Auto == 1)
        {
            pfnDisp = gTestEntry[iTest].pfn;
            TestCallData.Param = gTestEntry[iTest].Param;
            SetWindowText(hwnd,(CHAR *)gTestEntry[iTest].Api);
            PatBlt(hdc,0,0,2000,2000,BLACKNESS);
            (*pfnDisp)(&TestCallData);
        }
    }

    ReleaseDC(hwnd,hdc);
}

/**************************************************************************\
* RunAllAlphaTests
*
*   This routine called on separate thread to run through each functionality
*   test
*
* Arguments:
*
*   hwnd
*
* Return Value:
*
*
*
* History:
*
*    2/28/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
RunAllAlphaTests(HWND hwnd)
{
    PFN_DISP pfnDisp;
    ULONG iTest;
    HDC   hdc = GetDC(hwnd);

    for (iTest = 0;iTest < gNumAlphaTests; iTest++)
    {
        if (gTestAlphaEntry[iTest].Auto == 1)
        {
            pfnDisp = gTestAlphaEntry[iTest].pfn;
            TestCallData.Param = gTestAlphaEntry[iTest].Param;
            SetWindowText(hwnd,(CHAR *)gTestAlphaEntry[iTest].Api);
            PatBlt(hdc,0,0,2000,2000,BLACKNESS);
            (*pfnDisp)(&TestCallData);
            Sleep(500);
        }
    }

    ReleaseDC(hwnd,hdc);
}

/**************************************************************************\
* RunAllTranTests
*
*   This routine called on separate thread to run through each functionality
*   test
*
* Arguments:
*
*   hwnd
*
* Return Value:
*
*
*
* History:
*
*    2/28/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
RunAllTranTests(HWND hwnd)
{
    PFN_DISP pfnDisp;
    ULONG iTest;
    HDC   hdc = GetDC(hwnd);

    for (iTest = 0;iTest < gNumTranTests; iTest++)
    {
        if (gTestTranEntry[iTest].Auto == 1)
        {
            pfnDisp = gTestTranEntry[iTest].pfn;
            TestCallData.Param = gTestTranEntry[iTest].Param;
            SetWindowText(hwnd,(CHAR *)gTestTranEntry[iTest].Api);
            PatBlt(hdc,0,0,2000,2000,BLACKNESS);
            (*pfnDisp)(&TestCallData);
        }
    }

    ReleaseDC(hwnd,hdc);
}

/**************************************************************************\
* RunStress
*
*   run all tests forever
*
* Arguments:
*
*   hwnd
*
* Return Value:
*
*
*
* History:
*
*    2/28/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
RunStress(HWND hwnd)
{
    PFN_DISP pfnDisp;
    PFN_DISP pfnTimer = NULL;
    ULONG iTest;
    HDC   hdc = GetDC(hwnd);

    ULONG StressSleep = 100;


    while (TRUE)
    {
        for (iTest = 0;iTest < gNumTests; iTest++)
        {
            if (gTestEntry[iTest].Auto == 1)
            {
                pfnDisp = gTestEntry[iTest].pfn;
                TestCallData.Param = gTestEntry[iTest].Param;
                SetWindowText(hwnd,(CHAR *)gTestEntry[iTest].Api);
                PatBlt(hdc,0,0,2000,2000,BLACKNESS);
                (*pfnDisp)(&TestCallData);
                Sleep(StressSleep);
            }
        }
    
        for (iTest = 0;iTest < gNumAlphaTests; iTest++)
        {
            if (gTestAlphaEntry[iTest].Auto == 1)
            {
                pfnDisp = gTestAlphaEntry[iTest].pfn;
                TestCallData.Param = gTestAlphaEntry[iTest].Param;
                SetWindowText(hwnd,(CHAR *)gTestAlphaEntry[iTest].Api);
                PatBlt(hdc,0,0,2000,2000,BLACKNESS);
                (*pfnDisp)(&TestCallData);
                Sleep(StressSleep);
            }
        }
    
        for (iTest = 0;iTest < gNumTranTests; iTest++)
        {
            if (gTestTranEntry[iTest].Auto == 1)
            {
                pfnDisp = gTestTranEntry[iTest].pfn;
                TestCallData.Param = gTestTranEntry[iTest].Param;
                PatBlt(hdc,0,0,2000,2000,BLACKNESS);
                SetWindowText(hwnd,(CHAR *)gTestTranEntry[iTest].Api);
                (*pfnDisp)(&TestCallData);
                Sleep(StressSleep);
            }
        }
    
        for (iTest = 0;iTest < gNumTimers; iTest++)
        {
            ULONGLONG      ululTime;
    
            if (gTimerEntry[iTest].Auto == 1)
            {
                pfnTimer = gTimerEntry[iTest].pfn;
                SetWindowText(hwnd,(CHAR *)gTimerEntry[iTest].Api);
                PatBlt(hdc,0,0,2000,2000,BLACKNESS);
                TestCallData.Param = gTimerEntry[iTest].Param;
                TestCallData.pTimerResult = &gpTimerResult[iTest]; 
                (*pfnTimer)(&TestCallData);
                vDisplayTime(hdc,&gpTimerResult[iTest]);
                Sleep(StressSleep);
            }
    
        }
    }

    ReleaseDC(hwnd,hdc);
}

#define ABS(X) (((X) < 0 ) ? -(X) : (X))


LONG
CreateSubMenu(
    HMENU        hAdd,
    PTEST_ENTRY  pTestEntry,
    LONG        Level,
    LONG        ix,
    LONG        Start_ID
    )
{
    CHAR tmsg[256];

    //
    // validate
    //

    if (ABS(pTestEntry[ix].Level) != Level)
    {
        wsprintf(tmsg,"Level: %li, ix: %i: %s",Level,ix,pTestEntry[ix].Api);
        MessageBox(NULL,"CreateSubMenu Error",tmsg,MB_OK);
        return(0);
    }

    //
    // create sub menu
    //

    HMENU hCreate = CreateMenu();
    wsprintf(tmsg,"T%i: %s",ix,pTestEntry[ix].Api);
    AppendMenu(hAdd, MF_POPUP,(UINT)hCreate,(const char *)tmsg);
 
    ix++;
 
    do
    {
        if (pTestEntry[ix].Level == Level)
        {
            wsprintf(tmsg,"T%i: %s",ix,pTestEntry[ix].Api);
            AppendMenu(hCreate, MF_STRING | MF_ENABLED, Start_ID + ix,(const char *)tmsg); 
            ix++;
        }
        else if (ABS(pTestEntry[ix].Level) > Level)
        {
            ix = CreateSubMenu(hCreate,pTestEntry,ABS(pTestEntry[ix].Level),ix,Start_ID);
        }
        else
        {
            return(ix);
        }
    }
    while (TRUE);
}



/**************************************************************************\
* ExpandMenu
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    5/29/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
ExpandMenu(
    HMENU       hAdd,
    PTEST_ENTRY pTestEntry,
    ULONG       Start_ID
    )
{
    CHAR tmsg[256];
    LONG ix = 0;

    while(pTestEntry[ix].Level != 0)
    {
        LONG CurLevel = pTestEntry[ix].Level;

        if (ABS(CurLevel) > 1)
        {
           ix = CreateSubMenu(hAdd,pTestEntry,ABS(CurLevel),ix,Start_ID);

           if (ix == 0)
           {
               return;
           }
        }
        else if (CurLevel == 1)
        {
           wsprintf(tmsg,"T%i: %s",ix,pTestEntry[ix].Api);
           AppendMenu(hAdd, MF_STRING | MF_ENABLED, Start_ID + ix,(const char *)tmsg);
           ix++;
        }
        else
        {
            wsprintf(tmsg,"Level = %lu, API = %s",CurLevel,pTestEntry[ix].Api);
            MessageBox(NULL,"Error in menu creation at line",tmsg,MB_OK);
            ix++;
        }
    }
}

/**************************************************************************\
* WinMain
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/28/1997 Mark Enstrom [marke]
*
\**************************************************************************/


LONG FAR
PASCAL WndProc(
    HWND        hwnd,
    unsigned    msg,
    UINT        wParam,
    LONG        lParam)

/*++

Routine Description:

   Process messages.

Arguments:

   hwnd    - window hande
   msg     - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation


Revision History:

      02-17-91      Initial code

--*/

{
    TestCallData.hwnd = hwnd;
    static HFONT   hFont;

    //
    // message loop
    //

    switch (msg) {

    case WM_CREATE:
    {
        HDC hdc = GetDC(hwnd);

        hFont = (HFONT) GetStockObject(SYSTEM_FIXED_FONT);

        HMENU hAdd = GetSubMenu(GetMenu(hwnd),1);
        ExpandMenu(hAdd,gTestEntry,ID_TEST_START);

        hAdd = GetSubMenu(GetMenu(hwnd),2);
        ExpandMenu(hAdd,gTestAlphaEntry,ID_ALPHA_START);


        hAdd = GetSubMenu(GetMenu(hwnd),3);
        ExpandMenu(hAdd,gTestTranEntry,ID_TRAN_START);

        hAdd = GetSubMenu(GetMenu(hwnd),4);
        ExpandMenu(hAdd,gTimerEntry,ID_TIMER_START);

        gpTimerResult = (PTIMER_RESULT)LocalAlloc(0,gNumTimers * sizeof(TIMER_RESULT));
        memset(gpTimerResult,0,gNumTimers * sizeof(TIMER_RESULT));

        //
        // global fill brush
        //

        hbmCars = LoadBitmap(hInstMain,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH      lgBrush;
    
        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (LONG)hbmCars;
    
        hbrFillCars = CreateBrushIndirect(&lgBrush);

        //
        // global font
        //

        LOGFONT lf = {
                     12,              // h
                      8,              // w
                      0,              // Esc
                      0,              // Ori
                      0,              // Weight
                      0,              // itallic
                      0,              // underline
                      0,              // strile
                      OEM_CHARSET,
                      OUT_DEFAULT_PRECIS,
                      CLIP_DEFAULT_PRECIS,
                      DEFAULT_QUALITY,
                      FIXED_PITCH,
                      "Terminal"
                      };
    
        HFONT       hTestFont = CreateFontIndirect(&lf);

        ReleaseDC(hwnd,hdc);
    }
    break;

    case WM_COMMAND:
        {
            switch (LOWORD(wParam)){

            case IDM_EXIT:

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                SendMessage(hwnd,WM_CLOSE,0,0L);
                break;

            case IDM_REDRAW:
                //
                // kill old thread if active
                //

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)pfnLast,&TestCallData,0,&dwThreadID);

                break;

            case IDM_SHOW:
                DialogBox(hInstMain, (LPSTR)IDD_RESULTS, hwnd, (DLGPROC)ResultsDlgProc);
                break;


            case IDM_ALL_TIMERS:

                //
                // kill old thread if active
                //

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)RunAllTimerTests,hwnd,0,&dwThreadID);

                break;

            case IDM_STRESS:

                //
                // kill old thread if active
                //

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)RunStress,hwnd,0,&dwThreadID);

                break;

            case IDM_RUN:

                //
                // kill old thread if active
                //

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)RunAllFunctionalityTests,hwnd,0,&dwThreadID);

                break;

            case IDM_RUN_ALPHA:

                //
                // kill old thread if active
                //

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)RunAllAlphaTests,hwnd,0,&dwThreadID);

                break;


            case IDM_RUN_TRAN:

                //
                // kill old thread if active
                //

                if (gThreadHandle != NULL)
                {
                    TerminateThread(gThreadHandle,0);
                }

                gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)RunAllTranTests,hwnd,0,&dwThreadID);

                break;

            case IDM_ROTATE0:
            case IDM_ROTATE10:
            case IDM_ROTATE20:
            case IDM_ROTATE30:
            case IDM_ROTATE40:
            case IDM_ROTATE50:
            case IDM_ROTATE60:
            case IDM_ROTATE70:
            case IDM_ROTATE80:
            case IDM_ROTATE90:
                {
                    double rotationAngle = (LOWORD(wParam) - IDM_ROTATE0) * 10;
                    rotationAngle *= 2 * 3.1415 / 360;  // Radians

                    rotationXform.eM11 = (float) cos(rotationAngle);
                    rotationXform.eM12 = (float) sin(rotationAngle);
                    rotationXform.eM21 = (float) -sin(rotationAngle);
                    rotationXform.eM22 = (float) cos(rotationAngle);
                
                    rotationXform.eDx = 0;
                    rotationXform.eDy = 0;
                
                }

                break;

            //
            // Tests
            //

            default:
            {
                ULONG Test      = LOWORD(wParam) - ID_TEST_START;
                ULONG TestAlpha = LOWORD(wParam) - ID_ALPHA_START;
                ULONG TestTran  = LOWORD(wParam) - ID_TRAN_START;
                ULONG TestTimer = LOWORD(wParam) - ID_TIMER_START;
                ULONG Index;
                RECT CliRect;

                //
                // display tests
                //

                if (Test < gNumTests)
                {
                    pfnLast = gTestEntry[Test].pfn;

                    SetWindowText(hwnd,(CHAR *)gTestEntry[Test].Api);

                    TestCallData.Param = gTestEntry[Test].Param;

                    //
                    // kill old thread if active
                    //

                    if (gThreadHandle != NULL)
                    {
                        TerminateThread(gThreadHandle,0);
                    }

                    gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)pfnLast,&TestCallData,0,&dwThreadID);
                }
                else if (TestAlpha < gNumAlphaTests)
                {
                    pfnLast = gTestAlphaEntry[TestAlpha].pfn;
                    SetWindowText(hwnd,(CHAR *)gTestAlphaEntry[TestAlpha].Api);
                    TestCallData.Param = gTestAlphaEntry[TestAlpha].Param;

                    //
                    // kill old thread if active
                    //

                    if (gThreadHandle != NULL)
                    {
                        TerminateThread(gThreadHandle,0);
                    }

                    gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)pfnLast,&TestCallData,0,&dwThreadID);
                }
                else if (TestTran < gNumTranTests)
                {
                    pfnLast = gTestTranEntry[TestTran].pfn;
                    TestCallData.Param = gTestTranEntry[TestTran].Param;
                    SetWindowText(hwnd,(CHAR *)gTestTranEntry[TestTran].Api);

                    //
                    // kill old thread if active
                    //

                    if (gThreadHandle != NULL)
                    {
                        TerminateThread(gThreadHandle,0);
                    }

                    gThreadHandle = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)pfnLast,&TestCallData,0,&dwThreadID);
                }
                else if (TestTimer < gNumTimers)
                {
                    //
                    // timer tests, run on main thread
                    // kill old thread if active
                    //

                    if (gThreadHandle != NULL)
                    {
                        TerminateThread(gThreadHandle,0);
                    }

                    HDC   hdc = GetDC(hwnd);
                    CHAR  szBuffer[255];

                    PFN_DISP pfnTimer = NULL;

                    pfnTimer = gTimerEntry[TestTimer].pfn;
                    TestCallData.Param = gTimerEntry[TestTimer].Param;
                    TestCallData.pTimerResult = &gpTimerResult[TestTimer];
                    SetWindowText(hwnd,(CHAR *)gTimerEntry[TestTimer].Api);

                    (*pfnTimer)(&TestCallData);

                    vDisplayTime(hdc,&gpTimerResult[TestTimer]);

                    ReleaseDC(hwnd,hdc);
                }

            }
            break;

            }
        }
        break;

    case WM_SIZE:

        if (gThreadHandle != NULL)
        {
            TerminateThread(gThreadHandle,0);
        }

        InvalidateRect(hwnd,NULL,TRUE);
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC     hdc = BeginPaint(hwnd,&ps);

            //(*pfnLast)(hwnd);

            EndPaint(hwnd,&ps);

        }
        break;

    case WM_DESTROY:
            PostQuitMessage(0);
            break;

    default:

        //
        // Passes message on if unproccessed
        //

        return (DefWindowProc(hwnd, msg, wParam, lParam));
    }

    return ((LONG)NULL);

}

/**************************************************************************\
* ResultsDlgProc
*
*   Show results of time run
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    1/27/1997 Mark Enstrom [marke]
*
\**************************************************************************/


BOOL
APIENTRY
ResultsDlgProc(
    HWND hwnd,
    UINT msg,
    UINT wParam,
    LONG lParam)
{
    ULONG ix;
    char szT[180];
    BOOL fResults;
    int aiT[2];

    switch (msg) {
    case WM_INITDIALOG:
        aiT[0] = 100;
        aiT[1] = 190;
        fResults = FALSE;

        {
            LV_COLUMN lvc;
            LV_ITEM   lvl;
            UINT      width;
            RECT      rc;
            HWND      hwndList = GetDlgItem(hwnd, IDC_RESULTSLIST);
            int       i;

            static LPCSTR title[] =
            {
                "Function",
                "Time(1us)",
                "Iterations"
            };

            //
            // check if using pentium counters
            //

            #ifdef _X86_
               if (gfPentium)
               {
                   title[1] = "Cycle Counts";
               }
            #endif

            if (hwndList == NULL)
            {
                break;
            }

            GetClientRect(hwndList, &rc);

            //
            // only first column has doubled width. Save space menu
            //

            width = ((rc.right - rc.left) / (sizeof title / sizeof *title + 1)) - 32;

            lvc.cx       = width * 2;
            lvc.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
            lvc.fmt      = LVCFMT_LEFT;
            lvc.iSubItem = 0;

            for (i = 0; i < sizeof title / sizeof *title; ++i)
            {
                int iRet;
                lvc.pszText = (LPSTR)title[i];
                lvc.cchTextMax = strlen((LPSTR)title[i]);
                iRet = ListView_InsertColumn(hwndList, i, &lvc);

                if (iRet == -1)
                {
                  MessageBox(hwnd, "ListView_InsertColumn failed","disp",MB_OK);
                }

                //
                // normal width, right aligned
                //

                lvc.cx   = width;
                lvc.fmt  = LVCFMT_RIGHT;
            }

            lvl.iItem = 0;
            lvl.mask = LVIF_TEXT;

            for (ix = 0; ix < gNumTimers; ix++)
            {
                if (gpTimerResult[ix].TestTime == 0)
                {
                    // no measuement, skip
                    continue;
                }

                lvl.iSubItem = 0;
                lvl.pszText = (CHAR *)gTimerEntry[ix].Api;

                ListView_InsertItem(hwndList, &lvl);

                DISP_SUBITEM("%ld",gpTimerResult[ix].TestTime);
                DISP_SUBITEM("%ld",gTimerEntry[ix].Param);

                ++lvl.iItem;
                fResults = TRUE;
            }

            if (!fResults)
            {
               MessageBox(hwnd, "No results have been generated yet or Test may have failed!",
                    "UsrBench", MB_OK | MB_ICONEXCLAMATION);
            }
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;

        case IDM_SAVERESULTS:
            SaveResults();
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


/*++

Routine Description:

    Save results to file

Arguments

    none

Return Value

    none

--*/

VOID
SaveResults()
{
    static OPENFILENAME ofn;
    static char szFilename[256];
    static char szDirname[256];
    char CurDir[256];
    char szT[80];
    int i, hfile;
    FILE *fpOut;

    ULONG ulScreenFormat = ulDetermineScreenFormat(NULL);

    GetCurrentDirectory(256,CurDir);

    memset(&ofn,0,sizeof(OPENFILENAME));

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWndMain;
    ofn.hInstance = hInstMain;

    ofn.lpstrFilter = "Text (*.txt)\0*.txt\0All Files\0*.*\0\0";
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;

    //ofn.lpstrInitialDir = szDirname;
    //lstrcpy(szDirname,"D:\\nt\\private\\ntos\\w32\\ntgdi\\test\\imgtest");

    ofn.lpstrInitialDir = CurDir;

    ofn.Flags = 0;
    ofn.lpstrDefExt = "txt";
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    lstrcpy(szFilename,"Disp_");
    lstrcat(szFilename,pScreenDef[ulScreenFormat]);

    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = sizeof(szFilename);
    ofn.lpstrTitle = "Save As";

    if (!GetSaveFileName(&ofn))
    {
        return;
    }

    fpOut = fopen(szFilename, "w+");

    if(NULL != fpOut)
    {
        WriteBatchResults(fpOut,ulScreenFormat);
        fclose(fpOut);
    }
    else
    {
        MessageBox(hWndMain,"Cannot Open File to Save Results", "Output File Creation Error",MB_ICONSTOP|MB_OK);
    }
}

/*++

Routine Description:

    WriteBatchResults - Save Batch results to file

Arguments

    FILE *fpOutFile
    int  TestType

Return Value

    none

--*/


VOID
WriteBatchResults(
    FILE *fpOut,
    ULONG ulScreenFormat
    )
{
    char   szT[180];
    MEMORYSTATUS MemoryStatus;
    char   ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG  SizBuf = MAX_COMPUTERNAME_LENGTH + 1;
    int    i,j;
    ULONG  ix;
    char  *pszOSName;
    ULONG  ixStart = 0;
    ULONG  ixEnd   = gNumTimers;

    //
    // Write out the build information and current date.
    //

    Win32VersionInformation.dwOSVersionInfoSize = sizeof(Win32VersionInformation);

    if (GetVersionEx(&Win32VersionInformation))
    {
        switch (Win32VersionInformation.dwPlatformId)
        {
            case VER_PLATFORM_WIN32s:
                pszOSName = "WIN32S";
                break;
            case VER_PLATFORM_WIN32_WINDOWS:
                pszOSName = "Windows 95";
                break;
            case VER_PLATFORM_WIN32_NT:
                pszOSName = "Windows NT";
                break;
            default:
                pszOSName = "Windows ???";
                break;
        }

        GetComputerName(ComputerName, &SizBuf);

        wsprintf(szT, "\n\n///////////////   ");

        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT, "%s Version %d.%d Build %d ", pszOSName,
        Win32VersionInformation.dwMajorVersion,
        Win32VersionInformation.dwMinorVersion,
        Win32VersionInformation.dwBuildNumber);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        MemoryStatus.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus(&MemoryStatus);

        wsprintf(szT, "Physical Memory = %dKB   ////////////////\n", MemoryStatus.dwTotalPhys/1024);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        wsprintf(szT,"\nComputer Name = %s", ComputerName);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

        //
        // determine and output screen type
        //

        ULONG ulScreenFormat = ulDetermineScreenFormat(NULL);

        wsprintf(szT,"\nScreen Format = %s\n", pScreenDef[ulScreenFormat]);
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

    }

    #if 0
        #ifdef _X86_
            //
            // Print the Names of the event monitored
            // Needs to detect CPU for Pentium or up later
            // a-ifkao
            //
            if(gfCPUEventMonitor) {
                wsprintf(szT, "\nThe CPU Events monitored are <%s> and <%s>",PerfName[0], PerfName[1]);
                fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
            }
        #endif
    #endif

    wsprintf(szT,"\n\n\n");
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    wsprintf(szT,"Function Name                     Iterations        Time      PixelTime           bw    ImageSize\n");
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    wsprintf(szT,"\n");
    fwrite(szT, sizeof(char), lstrlen(szT), fpOut);

    ULONG uix;

    for (uix=0;uix<gNumTimers;uix++)
    {
        wsprintf(szT,"%s%8li       %8li    %8li      %10li     %8li\n",
                                gTimerEntry[uix].Api,
                                gTimerEntry[uix].Param,
                                gpTimerResult[uix].TestTime,
                                gpTimerResult[uix].TimerPerPixel,
                                gpTimerResult[uix].Bandwidth,
                                gpTimerResult[uix].ImageSize
                                );
        fwrite(szT, sizeof(char), lstrlen(szT), fpOut);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <string.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <commctrl.h>
#include <winspool.h>
#include <wingdi.h>
#include <malloc.h>
#include <limits.h>
#include <ntverp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\resource.h ===
/*--

Copyright (c) 1990  Microsoft Corporation

Module Name:

    resource.h

Abstract:

    defines for resource file

Author:

    Mark Enstrom (marke) 30-Dec-1992

Revision History:

--*/


#define IDR_PAL_MENU     101
#define IDM_EXIT         102
#define IC_WARNING       103
#define SYSPAL_ICON      104
#define IDM_REDRAW       105
#define IDM_RUN          106
#define IDM_ALL_TIMERS   107
#define IDD_RESULTS      108
#define IDM_SAVERESULTS  109
#define IDC_RESULTSLIST  110
#define CAR_BITMAP       112
#define POPUP_BITMAP     113
#define IDM_SHOW         114
#define IDD_TRIANGLE_DLG 115
#define IDD_TRI1_X       116
#define IDD_TRI1_Y       117
#define IDD_TRI1_R       118
#define IDD_TRI1_G       119
#define IDD_TRI1_B       120
#define IDD_TRI2_X       121
#define IDD_TRI2_Y       122
#define IDD_TRI2_R       123
#define IDD_TRI2_G       124
#define IDD_TRI2_B       125
#define IDD_TRI3_X       126
#define IDD_TRI3_Y       127
#define IDD_TRI3_R       128
#define IDD_TRI3_G       129
#define IDD_TRI3_B       130
#define MONITOR_BITMAP   131
#define IDM_STRESS       132
#define IDM_RUN_TRAN     133
#define IDM_RUN_ALPHA    134
#define CHART_BITMAP     135
#define SCREEN_BITMAP    136

#define IDM_ROTATE0      137
#define IDM_ROTATE10     138
#define IDM_ROTATE20     139
#define IDM_ROTATE30     140
#define IDM_ROTATE40     141
#define IDM_ROTATE50     142
#define IDM_ROTATE60     143
#define IDM_ROTATE70     144
#define IDM_ROTATE80     145
#define IDM_ROTATE90     146

//
// do not add entries from 200 - 600, auto menu
// uses these values.
//

#define ID_TEST_START    200
#define ID_ALPHA_START   300
#define ID_TRAN_START    450
#define ID_TIMER_START   500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\tessel.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   test.c

Abstract:

    Small, independent windows test programs

Author:

   Mark Enstrom   (marke)  29-Apr-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.h"
#include <stdlib.h>
#include "disp.h"
#include "resource.h"

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

#define MAX_TRI  100
#define MAX_VERT 100
#define MAX_RAND_POS 0x40
#define MAX_RAND_COLOR 0x1000
#define RandPos()   ((rand() & (MAX_RAND_POS-1)) - MAX_RAND_POS/2)
#define RandColor(c) (0xffff & ( c + ((rand() & (MAX_RAND_COLOR -1)) - (MAX_RAND_COLOR/2))))

#define DISP_INTERMEDIATE 0

ULONG ulDbg = 0;

typedef struct _EDGE_ARRAY
{
    USHORT p1;
    USHORT p2;
    USHORT vertex;
    USHORT fill;
}EDGE_ARRAY,*PEDGE_ARRAY;

/**************************************************************************\
* AddToEdgeArray
*
*  easy array to keep track of common shared edges
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
AddToEdgeArray(
    PEDGE_ARRAY pEdge,
    ULONG       TriIndex0,
    ULONG       TriIndex1,
    ULONG       TriIndexNew,
    ULONG       NumTri
    )
{
    //
    // look for empty space
    //

    ULONG Index = 0;

    while (Index < 3 * NumTri)
    {
        if ((pEdge->p1 == 0) && (pEdge->p2 == 0))
        {
            pEdge->p1     = (USHORT)TriIndex0;
            pEdge->p2     = (USHORT)TriIndex1;
            pEdge->vertex = (USHORT)TriIndexNew;
            return(TRUE);
        }

        pEdge++;
        Index++;
    }
    return(FALSE);
}

/**************************************************************************\
* SearchEdgeArray
*
*   easy search
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/

USHORT
SearchEdgeArray(
    PEDGE_ARRAY pEdge,
    LONG        TriIndex0,
    LONG        TriIndex1,
    ULONG       NumTri
    )
{
    ULONG  Index = 0;
    USHORT usRet = 0;

    while (Index < 3 * NumTri)
    {
        if ((pEdge->p1 == (USHORT)TriIndex0) && (pEdge->p2 == (USHORT)TriIndex1))
        {
            usRet = pEdge->vertex;
            break;
        }

        if ((pEdge->p1 == (USHORT)TriIndex1) && (pEdge->p2 == (USHORT)TriIndex0))
        {
            usRet = pEdge->vertex;
            break;
        }

        if (pEdge->p1 == pEdge->p2)
        {
            break;
        }

        Index++;
        pEdge++;
    }
    return(usRet);
}


/**************************************************************************\
* vTestTessel
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    2/26/1997 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vTestTessel(
   TEST_CALL_DATA *pCallData
    )
{
    HDC                hdc = GetDCAndTransform(pCallData->hwnd);
    PGRADIENT_TRIANGLE pTri  = NULL;
    PTRIVERTEX         pvert = NULL;
    HPALETTE           hpal = CreateHalftonePalette(hdc);
    RECT               rect;
    int                NumTri = 1;
    int                NumVertex = 3;

    //
    // init
    //

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // clear screen
    //

    GetClientRect(pCallData->hwnd,&rect);
    FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));

    pTri = (PGRADIENT_TRIANGLE)LocalAlloc(0,sizeof(GRADIENT_TRIANGLE));
    pvert = (PTRIVERTEX)LocalAlloc(0,MAX_VERT * sizeof(TRIVERTEX));

    if ((pTri == NULL) || (pvert == NULL))
    {
        goto TesselError;
    }

    //do
    //{

        //
        // init first triangle
        //

        pvert[0].x     = rect.right/2;
        pvert[0].y     = 10;
        pvert[0].Red   = 0xff00;
        pvert[0].Green = 0x0000;
        pvert[0].Blue  = 0x0000;
        pvert[0].Alpha = 0xaaaa;

        pvert[1].x     = 10;
        pvert[1].y     = rect.bottom - 10;
        pvert[1].Red   = 0x0000;
        pvert[1].Green = 0xff00;
        pvert[1].Blue  = 0x0000;
        pvert[1].Alpha = 0xaaaa;

        pvert[2].x     = rect.right - 10;
        pvert[2].y     = rect.bottom - 10;
        pvert[2].Red   = 0x0000;
        pvert[2].Green = 0x0000;
        pvert[2].Blue  = 0xff00;
        pvert[2].Alpha = 0xaaaa;

        pTri[0].Vertex1 = 0;
        pTri[0].Vertex2 = 1;
        pTri[0].Vertex3 = 2;

        if (DISP_INTERMEDIATE)
        {
            GradientFill(hdc,pvert,NumVertex,pTri,NumTri,GRADIENT_FILL_TRIANGLE);
        }

        if (ulDbg)
        {
            DbgPrint("pvert = 0x%lx\n",pvert);
        }

        do
        {
            ULONG InputTriangle;
            ULONG OutputTriangle = 0;

            //
            // break each triangle into 4
            //

            PGRADIENT_TRIANGLE pNewTri = (PGRADIENT_TRIANGLE)LocalAlloc(0,4 * NumTri * sizeof(GRADIENT_TRIANGLE));
            PEDGE_ARRAY        pEdge   = (PEDGE_ARRAY)LocalAlloc(0,NumTri * 3 * sizeof(EDGE_ARRAY));

            memset(pEdge,0,NumTri * 3 * sizeof(EDGE_ARRAY));

            if (ulDbg)
            {
                DbgPrint("alloc = 0x%lx, size = %lx\n",pNewTri,4 * 3 * NumTri * sizeof(USHORT));
            }

            for (InputTriangle=0;InputTriangle<NumTri;InputTriangle++)
            {
                ULONG TriIndex0 = pTri[InputTriangle].Vertex1;
                ULONG TriIndex1 = pTri[InputTriangle].Vertex2;
                ULONG TriIndex2 = pTri[InputTriangle].Vertex3;

                ULONG TriIndex3;
                ULONG TriIndex4;
                ULONG TriIndex5;

                if (ulDbg >=2)
                {
                    DbgPrint("Triangle     = %i,%i,%i\n",TriIndex0,TriIndex1,TriIndex2);
                    DbgPrint("x,y,r,g,b:     %4li,%4li,0x%lx,0x%lx,0x%lx\n",pvert[TriIndex0].x,pvert[TriIndex0].y,pvert[TriIndex0].Red,pvert[TriIndex0].Green,pvert[TriIndex0].Blue);
                    DbgPrint("x,y,r,g,b:     %4li,%4li,0x%lx,0x%lx,0x%lx\n",pvert[TriIndex1].x,pvert[TriIndex1].y,pvert[TriIndex1].Red,pvert[TriIndex1].Green,pvert[TriIndex1].Blue);
                    DbgPrint("x,y,r,g,b:     %4li,%4li,0x%lx,0x%lx,0x%lx\n",pvert[TriIndex2].x,pvert[TriIndex2].y,pvert[TriIndex2].Red,pvert[TriIndex2].Green,pvert[TriIndex2].Blue);

                    DbgPrint("New Triangle = %i,%i,%i\n",TriIndex3,TriIndex4,TriIndex5);
                }

                //
                // look in edge array for TriIndex0,TriIndex1
                //

                TriIndex3 = SearchEdgeArray(pEdge,TriIndex0,TriIndex1,NumTri);

                if (TriIndex3 == 0)
                {
                    TriIndex3 = NumVertex;
                    NumVertex++;

                    //
                    // add new vertex locations
                    //

                    double fx3 = (double)pvert[TriIndex0].x;
                    double fy3 = (double)pvert[TriIndex0].y;

                    fx3 += ((double)pvert[TriIndex1].x - (double)pvert[TriIndex0].x)/2.0;
                    fy3 += ((double)pvert[TriIndex1].y - (double)pvert[TriIndex0].y)/2.0;

                    double fr  = (double)pvert[TriIndex0].Red;
                    double fg  =(double)pvert[TriIndex0].Green;
                    double fb  = (double)pvert[TriIndex0].Blue;

                    fr += (((double)pvert[TriIndex1].Red   - (double)pvert[TriIndex0].Red)/2.0);
                    fg += (((double)pvert[TriIndex1].Green - (double)pvert[TriIndex0].Green)/2.0);
                    fb += (((double)pvert[TriIndex1].Blue  - (double)pvert[TriIndex0].Blue)/2.0);


                    pvert[TriIndex3].x     = (LONG)fx3 + RandPos();
                    pvert[TriIndex3].y     = (LONG)fy3 + RandPos();
                    pvert[TriIndex3].Red   = RandColor(((ULONG)fr));
                    pvert[TriIndex3].Green = RandColor(((ULONG)fg));
                    pvert[TriIndex3].Blue  = RandColor(((ULONG)fb));
                    pvert[TriIndex3].Alpha = 0xaaaa;

                    AddToEdgeArray(pEdge,TriIndex0,TriIndex1,TriIndex3,NumTri);
                }

                //
                // search edge array for TriIndex0,TriIndex2
                //

                TriIndex4 = SearchEdgeArray(pEdge,TriIndex0,TriIndex2,NumTri);

                if (TriIndex4 == 0)
                {
                    TriIndex4 = NumVertex;
                    NumVertex++;

                    double fx4 = (double)pvert[TriIndex0].x;
                    double fy4 = (double)pvert[TriIndex0].y;

                    fx4 += ((double)pvert[TriIndex2].x - (double)pvert[TriIndex0].x)/2.0;
                    fy4 += ((double)pvert[TriIndex2].y - (double)pvert[TriIndex0].y)/2.0;

                    double fr  = (double)pvert[TriIndex0].Red;
                    double fg  = (double)pvert[TriIndex0].Green;
                    double fb  = (double)pvert[TriIndex0].Blue;

                    fr += (((double)pvert[TriIndex2].Red   - (double)pvert[TriIndex0].Red)/2.0);
                    fg += (((double)pvert[TriIndex2].Green - (double)pvert[TriIndex0].Green)/2.0);
                    fb += (((double)pvert[TriIndex2].Blue  - (double)pvert[TriIndex0].Blue)/2.0);

                    pvert[TriIndex4].x     = (LONG)fx4 + RandPos();
                    pvert[TriIndex4].y     = (LONG)fy4 + RandPos();
                    pvert[TriIndex4].Red   = RandColor(((ULONG)fr));
                    pvert[TriIndex4].Green = RandColor(((ULONG)fg));
                    pvert[TriIndex4].Blue  = RandColor(((ULONG)fb));
                    pvert[TriIndex4].Alpha = 0xaaaa;

                    AddToEdgeArray(pEdge,TriIndex0,TriIndex2,TriIndex4,NumTri);
                }

                //
                // search edge array for TriIndex1,TriIndex2
                //

                TriIndex5 = SearchEdgeArray(pEdge,TriIndex1,TriIndex2,NumTri);

                if (TriIndex5 == 0)
                {
                    TriIndex5 = NumVertex;
                    NumVertex++;

                    double fx5 = (double)pvert[TriIndex1].x;
                    double fy5 = (double)pvert[TriIndex1].y;

                    fx5 += ((double)pvert[TriIndex2].x - (double)pvert[TriIndex1].x)/2.0;
                    fy5 += ((double)pvert[TriIndex2].y - (double)pvert[TriIndex1].y)/2.0;

                    double fr  = (double)pvert[TriIndex1].Red;
                    double fg  = (double)pvert[TriIndex1].Green;
                    double fb  = (double)pvert[TriIndex1].Blue;

                    fr += (((double)pvert[TriIndex2].Red   - (double)pvert[TriIndex1].Red)/2.0);
                    fg += (((double)pvert[TriIndex2].Green - (double)pvert[TriIndex1].Green)/2.0);
                    fb += (((double)pvert[TriIndex2].Blue  - (double)pvert[TriIndex1].Blue)/2.0);

                    pvert[TriIndex5].x     = (LONG)fx5 + RandPos();
                    pvert[TriIndex5].y     = (LONG)fy5 + RandPos();
                    pvert[TriIndex5].Red   = RandColor(((ULONG)fr));
                    pvert[TriIndex5].Green = RandColor(((ULONG)fg));
                    pvert[TriIndex5].Blue  = RandColor(((ULONG)fb));
                    pvert[TriIndex5].Alpha = 0xaaaa;

                    AddToEdgeArray(pEdge,TriIndex1,TriIndex2,TriIndex5,NumTri);
                }

                //
                // add four new vertex structs
                //

                pNewTri[OutputTriangle].Vertex1 = TriIndex0;
                pNewTri[OutputTriangle].Vertex2 = TriIndex3;
                pNewTri[OutputTriangle].Vertex3 = TriIndex4;

                OutputTriangle++;
                pNewTri[OutputTriangle].Vertex1 = TriIndex1;
                pNewTri[OutputTriangle].Vertex2 = TriIndex3;
                pNewTri[OutputTriangle].Vertex3 = TriIndex5;

                OutputTriangle++;
                pNewTri[OutputTriangle].Vertex1 = TriIndex3;
                pNewTri[OutputTriangle].Vertex2 = TriIndex4;
                pNewTri[OutputTriangle].Vertex3 = TriIndex5;

                OutputTriangle++;
                pNewTri[OutputTriangle].Vertex1 = TriIndex4;
                pNewTri[OutputTriangle].Vertex2 = TriIndex2;
                pNewTri[OutputTriangle].Vertex3 = TriIndex5;
                OutputTriangle++;
            }

            NumTri = NumTri*4;

            if (ulDbg)
            {
                DbgPrint("Free 0x%lx, NumVertex = %li, NumTri = %li\n",pTri,NumVertex,NumTri);
            }

            LocalFree(pTri);
            LocalFree(pEdge);

            pTri = pNewTri;

            FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));

            if (DISP_INTERMEDIATE)
            {
                GradientFill(hdc,pvert,NumVertex,pTri,NumTri,GRADIENT_FILL_TRIANGLE);
            }

        } while ((NumTri < (MAX_TRI/4)) && (NumVertex < (MAX_VERT-3)));

        GradientFill(hdc,pvert,NumVertex,pTri,NumTri,GRADIENT_FILL_TRIANGLE);

    //    Sleep(5000);
    //} while (TRUE);


TesselError:

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\util.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   util.c

Abstract:



Author:

   Mark Enstrom   (marke)  13-Jul-1996

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.h"
#include "disp.h"
#include "resource.h"

ULONG DefPalette[20] = { 0x00000000,0x00000080,0x00008000,0x00008080,
                         0x00800000,0x00800080,0x00808000,0x00c0c0c0,
                         0x00c0dcc0,0x00f0caa6,0x00f0fbff,0x00a4a0a0,
                         0x00808080,0x000000ff,0x0000ff00,0x0000ffff,
                         0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff
                       };
ULONG DefPaletteRGBQUAD[20] = { 0x00000000,0x00800000,0x00008000,0x00808000,
                                0x00000080,0x00800080,0x00008080,0x00c0c0c0,
                                0x00c0dcc0,0x00a6caf0,0x00fffbf0,0x00a0a0a4,
                                0x00808080,0x00ff0000,0x0000ff00,0x00ffff00,
                                0x000000ff,0x00ff00ff,0x0000ffff,0x00ffffff
                              };

ULONG htPalette[256] = {
     0x00000000,0x00000080,0x00008000,0x00008080,
     0x00800000,0x00800080,0x00808000,0x00c0c0c0,
     0x00c0dcc0,0x00f0caa6,0x04040404,0x04080808,
     0x040c0c0c,0x04111111,0x04161616,0x041c1c1c,
     0x04222222,0x04292929,0x04555555,0x044d4d4d,
     0x04424242,0x04393939,0x04807CFF,0x045050FF,
     0x049300D6,0x04FFECCC,0x04C6D6EF,0x04D6E7E7,
     0x0490A9AD,0x04000033,0x04000066,0x04000099,
     0x040000cc,0x04003300,0x04003333,0x04003366,
     0x04003399,0x040033cc,0x040033ff,0x04006600,
     0x04006633,0x04006666,0x04006699,0x040066cc,
     0x040066ff,0x04009900,0x04009933,0x04009966,
     0x04009999,0x040099cc,0x040099ff,0x0400cc00,
     0x0400cc33,0x0400cc66,0x0400cc99,0x0400cccc,
     0x0400ccff,0x0400ff66,0x0400ff99,0x0400ffcc,
     0x04330000,0x04330033,0x04330066,0x04330099,
     0x043300cc,0x043300ff,0x04333300,0x04333333,
     0x04333366,0x04333399,0x043333cc,0x043333ff,
     0x04336600,0x04336633,0x04336666,0x04336699,
     0x043366cc,0x043366ff,0x04339900,0x04339933,
     0x04339966,0x04339999,0x043399cc,0x043399ff,
     0x0433cc00,0x0433cc33,0x0433cc66,0x0433cc99,
     0x0433cccc,0x0433ccff,0x0433ff33,0x0433ff66,
     0x0433ff99,0x0433ffcc,0x0433ffff,0x04660000,
     0x04660033,0x04660066,0x04660099,0x046600cc,
     0x046600ff,0x04663300,0x04663333,0x04663366,
     0x04663399,0x046633cc,0x046633ff,0x04666600,
     0x04666633,0x04666666,0x04666699,0x046666cc,
     0x04669900,0x04669933,0x04669966,0x04669999,
     0x046699cc,0x046699ff,0x0466cc00,0x0466cc33,
     0x0466cc99,0x0466cccc,0x0466ccff,0x0466ff00,
     0x0466ff33,0x0466ff99,0x0466ffcc,0x04cc00ff,
     0x04ff00cc,0x04999900,0x04993399,0x04990099,
     0x049900cc,0x04990000,0x04993333,0x04990066,
     0x049933cc,0x049900ff,0x04996600,0x04996633,
     0x04993366,0x04996699,0x049966cc,0x049933ff,
     0x04999933,0x04999966,0x04999999,0x049999cc,
     0x049999ff,0x0499cc00,0x0499cc33,0x0466cc66,
     0x0499cc99,0x0499cccc,0x0499ccff,0x0499ff00,
     0x0499ff33,0x0499cc66,0x0499ff99,0x0499ffcc,
     0x0499ffff,0x04cc0000,0x04990033,0x04cc0066,
     0x04cc0099,0x04cc00cc,0x04993300,0x04cc3333,
     0x04cc3366,0x04cc3399,0x04cc33cc,0x04cc33ff,
     0x04cc6600,0x04cc6633,0x04996666,0x04cc6699,
     0x04cc66cc,0x049966ff,0x04cc9900,0x04cc9933,
     0x04cc9966,0x04cc9999,0x04cc99cc,0x04cc99ff,
     0x04cccc00,0x04cccc33,0x04cccc66,0x04cccc99,
     0x04cccccc,0x04ccccff,0x04ccff00,0x04ccff33,
     0x0499ff66,0x04ccff99,0x04ccffcc,0x04ccffff,
     0x04cc0033,0x04ff0066,0x04ff0099,0x04cc3300,
     0x04ff3333,0x04ff3366,0x04ff3399,0x04ff33cc,
     0x04ff33ff,0x04ff6600,0x04ff6633,0x04cc6666,
     0x04ff6699,0x04ff66cc,0x04cc66ff,0x04ff9900,
     0x04ff9933,0x04ff9966,0x04ff9999,0x04ff99cc,
     0x04ff99ff,0x04ffcc00,0x04ffcc33,0x04ffcc66,
     0x04ffcc99,0x04ffcccc,0x04ffccff,0x04ffff33,
     0x04ccff66,0x04ffff99,0x04ffffcc,0x046666ff,
     0x0466ff66,0x0466ffff,0x04ff6666,0x04ff66ff,
     0x04ffff66,0x042100A5,0x045f5f5f,0x04777777,
     0x04868686,0x04969696,0x04cbcbcb,0x04b2b2b2,
     0x04d7d7d7,0x04dddddd,0x04e3e3e3,0x04eaeaea,
     0x04f1f1f1,0x04f8f8f8,0x00f0fbff,0x00a4a0a0,
     0x00808080,0x000000ff,0x0000ff00,0x0000ffff,
     0x00ff0000,0x00ff00ff,0x00ffff00,0x00ffffff
     };

ULONG htPaletteRGBQUAD[256] = {
     0x00000000,0x00800000,0x00008000,0x00808000,
     0x00000080,0x00800080,0x00008080,0x00c0c0c0,
     0x00c0dcc0,0x00a6caf0,0x04040404,0x04080808,
     0x040c0c0c,0x04111111,0x04161616,0x041c1c1c,
     0x04222222,0x04292929,0x04555555,0x044d4d4d,
     0x04424242,0x04393939,0x04FF7C80,0x04FF5050,
     0x04D60093,0x04CCECFF,0x04EFD6C6,0x04E7E7D6,
     0x04ADA990,0x04330000,0x04660000,0x04990000,
     0x04cc0000,0x04003300,0x04333300,0x04663300,
     0x04993300,0x04cc3300,0x04ff3300,0x04006600,
     0x04336600,0x04666600,0x04996600,0x04cc6600,
     0x04ff6600,0x04009900,0x04339900,0x04669900,
     0x04999900,0x04cc9900,0x04ff9900,0x0400cc00,
     0x0433cc00,0x0466cc00,0x0499cc00,0x04cccc00,
     0x04ffcc00,0x0466ff00,0x0499ff00,0x04ccff00,
     0x04000033,0x04330033,0x04660033,0x04990033,
     0x04cc0033,0x04ff0033,0x04003333,0x04333333,
     0x04663333,0x04993333,0x04cc3333,0x04ff3333,
     0x04006633,0x04336633,0x04666633,0x04996633,
     0x04cc6633,0x04ff6633,0x04009933,0x04339933,
     0x04669933,0x04999933,0x04cc9933,0x04ff9933,
     0x0400cc33,0x0433cc33,0x0466cc33,0x0499cc33,
     0x04cccc33,0x04ffcc33,0x0433ff33,0x0466ff33,
     0x0499ff33,0x04ccff33,0x04ffff33,0x04000066,
     0x04330066,0x04660066,0x04990066,0x04cc0066,
     0x04ff0066,0x04003366,0x04333366,0x04663366,
     0x04993366,0x04cc3366,0x04ff3366,0x04006666,
     0x04336666,0x04666666,0x04996666,0x04cc6666,
     0x04009966,0x04339966,0x04669966,0x04999966,
     0x04cc9966,0x04ff9966,0x0400cc66,0x0433cc66,
     0x0499cc66,0x04cccc66,0x04ffcc66,0x0400ff66,
     0x0433ff66,0x0499ff66,0x04ccff66,0x04ff00cc,
     0x04cc00ff,0x04009999,0x04993399,0x04990099,
     0x04cc0099,0x04000099,0x04333399,0x04660099,
     0x04cc3399,0x04ff0099,0x04006699,0x04336699,
     0x04663399,0x04996699,0x04cc6699,0x04ff3399,
     0x04339999,0x04669999,0x04999999,0x04cc9999,
     0x04ff9999,0x0400cc99,0x0433cc99,0x0466cc66,
     0x0499cc99,0x04cccc99,0x04ffcc99,0x0400ff99,
     0x0433ff99,0x0466cc99,0x0499ff99,0x04ccff99,
     0x04ffff99,0x040000cc,0x04330099,0x046600cc,
     0x049900cc,0x04cc00cc,0x04003399,0x043333cc,
     0x046633cc,0x049933cc,0x04cc33cc,0x04ff33cc,
     0x040066cc,0x043366cc,0x04666699,0x049966cc,
     0x04cc66cc,0x04ff6699,0x040099cc,0x043399cc,
     0x046699cc,0x049999cc,0x04cc99cc,0x04ff99cc,
     0x0400cccc,0x0433cccc,0x0466cccc,0x0499cccc,
     0x04cccccc,0x04ffcccc,0x0400ffcc,0x0433ffcc,
     0x0466ff99,0x0499ffcc,0x04ccffcc,0x04ffffcc,
     0x043300cc,0x046600ff,0x049900ff,0x040033cc,
     0x043333ff,0x046633ff,0x049933ff,0x04cc33ff,
     0x04ff33ff,0x040066ff,0x043366ff,0x046666cc,
     0x049966ff,0x04cc66ff,0x04ff66cc,0x040099ff,
     0x043399ff,0x046699ff,0x049999ff,0x04cc99ff,
     0x04ff99ff,0x0400ccff,0x0433ccff,0x0466ccff,
     0x0499ccff,0x04ccccff,0x04ffccff,0x0433ffff,
     0x0466ffcc,0x0499ffff,0x04ccffff,0x04ff6666,
     0x0466ff66,0x04ffff66,0x046666ff,0x04ff66ff,
     0x0466ffff,0x04A50021,0x045f5f5f,0x04777777,
     0x04868686,0x04969696,0x04cbcbcb,0x04b2b2b2,
     0x04d7d7d7,0x04dddddd,0x04e3e3e3,0x04eaeaea,
     0x04f1f1f1,0x04f8f8f8,0x00fffbf0,0x00a0a0a4,
     0x00808080,0x00ff0000,0x0000ff00,0x00ffff00,
     0x000000ff,0x00ff00ff,0x0000ffff,0x00ffffff
     };        

PLOGPALETTE gpLogPal = NULL;

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    13-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


HPALETTE
CreateHtPalette(HDC hdc)
{
    HPALETTE    hPal;// = CreateHalftonePalette(hdc);
    UINT        NumEntries;
    ULONG       ux;

    if (gpLogPal)
    {
        LocalFree(gpLogPal);
    }
    
    gpLogPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED,sizeof(LOGPALETTE) + 256 * sizeof(PALETTEENTRY));
    
    if (gpLogPal == NULL) {
        return(NULL);
    }
    
    gpLogPal->palVersion    = 0x300;
    gpLogPal->palNumEntries = 256;
    
    memcpy(&gpLogPal->palPalEntry[0],&htPalette[0],256*4);
    
    hPal = CreatePalette(gpLogPal);

    return(hPal);
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    13-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


HPALETTE
CreateSystemPalette(HDC hdc)
{
    PLOGPALETTE pPal;
    HPALETTE    hPal;
    UINT        NumEntries;

    pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED,sizeof(LOGPALETTE) + 256 * sizeof(PALETTEENTRY));

    if (pPal == NULL) {
        return(NULL);
    }

    pPal->palVersion = 0x300;
    pPal->palNumEntries = 256;

    NumEntries = GetSystemPaletteEntries(hdc,0,256,&pPal->palPalEntry[0]);

    hPal = CreatePalette(pPal);

    LocalFree(pPal);

    return(hPal);
}



/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    13-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


HPALETTE
CreateColorPalette(HDC hdc)
{
    HPALETTE    hPal;
    UINT        NumEntries;
    ULONG       Index,PalIndex;

    //
    // free old palette
    //

    if (gpLogPal != NULL)
    {
        LocalFree(gpLogPal);
    }

    gpLogPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED,sizeof(LOGPALETTE) + 256 * sizeof(PALETTEENTRY));

    if (gpLogPal == NULL) {
        return(NULL);
    }

    gpLogPal->palVersion = 0x300;
    gpLogPal->palNumEntries = 256;

    for (Index=0;Index<10;Index++)
    {
        ((PULONG)(&gpLogPal->palPalEntry))[Index] = DefPalette[Index];
        ((PULONG)(&gpLogPal->palPalEntry))[256-Index] = DefPalette[20-Index];
    }


    PalIndex = 0;

    for (Index=0;Index<10;Index++)
    {
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 10

    for (Index=0;Index<32;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex].peGreen   = 0;
        gpLogPal->palPalEntry[PalIndex].peBlue    = 0;
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 42

    for (Index=0;Index<32;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = 0;
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = 0;
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 74

    for (Index=0;Index<32;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = 0;
        gpLogPal->palPalEntry[PalIndex].peGreen   = 0;
        gpLogPal->palPalEntry[PalIndex].peBlue    = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 106

    for (Index=0;Index<32;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 138

    for (Index=0;Index<16;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = 0;
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 154

    for (Index=0;Index<16;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex].peGreen   = 0;
        gpLogPal->palPalEntry[PalIndex].peBlue    = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 170

    for (Index=0;Index<16;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = 0;
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 186

    for (Index=0;Index<16;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = 0;
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 202

    for (Index=0;Index<16;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = 0;
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 218

    for (Index=0;Index<16;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = (BYTE)(16*Index);
        gpLogPal->palPalEntry[PalIndex].peGreen   = (BYTE)(8*Index);
        gpLogPal->palPalEntry[PalIndex].peBlue    = 0;
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    // PalIndex = 226

    for (Index=0;Index<11;Index++)
    {
        gpLogPal->palPalEntry[PalIndex].peRed     = 0;
        gpLogPal->palPalEntry[PalIndex].peGreen   = 0;
        gpLogPal->palPalEntry[PalIndex].peBlue    = 0;
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }


    // PalIndex = 245

    for (Index=0;Index<10;Index++)
    {
        gpLogPal->palPalEntry[PalIndex++].peFlags = PC_NOCOLLAPSE;
    }

    hPal = CreatePalette(gpLogPal);

    return(hPal);
}


/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    13-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/



VOID
DisplayPalette(
    HDC  hdc,
    LONG left,
    LONG top,
    LONG right,
    LONG bottom
    )
{

    HBRUSH  hTmp,hOld;
    ULONG   Index = 0;
    LONG    dx    = right - left;
    LONG    dy    = bottom - top;
    PUSHORT pus;

    PBITMAPINFO ptbi8  = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(USHORT));
    PBYTE pdib8        = (PBYTE)LocalAlloc(0,256 * (4));

    //
    // fill in bitmapinfoheader and palette
    //

    ptbi8->bmiHeader.biSize             = sizeof(BITMAPINFOHEADER);
    ptbi8->bmiHeader.biWidth            = 256;
    ptbi8->bmiHeader.biHeight           = -4;
    ptbi8->bmiHeader.biPlanes           = 1;
    ptbi8->bmiHeader.biBitCount         = 8;
    ptbi8->bmiHeader.biCompression      = BI_RGB;
    ptbi8->bmiHeader.biSizeImage        = 0;
    ptbi8->bmiHeader.biXPelsPerMeter    = 100;
    ptbi8->bmiHeader.biYPelsPerMeter    = 100;
    ptbi8->bmiHeader.biClrUsed          = 0;
    ptbi8->bmiHeader.biClrImportant     = 0;

    pus = (PUSHORT)(&ptbi8->bmiColors[0]);

    for (Index=0;Index<256;Index++)
    {
        pus[Index] = Index;
    }

    //
    // fill in DIB BITS
    //

    for (Index=0;Index<256;Index++)
    {
        pdib8[Index]       = (BYTE)Index;
        pdib8[256+Index]   = (BYTE)Index;
        pdib8[2*256+Index] = (BYTE)Index;
        pdib8[3*256+Index] = (BYTE)Index;
    }

    StretchDIBits(hdc,left,top,dx,dy,0,0,256,4,pdib8,ptbi8,DIB_PAL_COLORS,SRCCOPY);

    LocalFree(pdib8);
    LocalFree(ptbi8);
}

/**************************************************************************\
* vInitDib
*       initialize memory in dibsections
*       
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    2/25/1997 Mark Enstrom [marke]
*
\**************************************************************************/


VOID
vInitDib(
    PUCHAR pdib,
    ULONG  bpp,
    ULONG  Type,
    ULONG  cx,
    ULONG  cy
    )
{
    ULONG ix,iy;

    switch (bpp)
    {
    case 8:
        for (iy=0;iy<cy;iy++)
        {
            for (ix=0;ix<cx;ix++)
            {
                *pdib++ = (BYTE)((127.0 * (double)ix/(double)cx) + 
                                 (127.0 * (double)iy/(double)cy));
            }
        }
        break;

    case 16:
        {
            PUSHORT pus = (PUSHORT)pdib;

            switch (Type)
            {
            case T565:
                for (iy=0;iy<cy;iy++)
                {
                    for (ix=0;ix<cx;ix++)
                    {
                        *pus++ = (USHORT)(((iy & 0xf8) >> 3) |
                                          ((ix & 0xfc) << 3) |
                                          (((ix | iy) & 0xf8) << 8));
                    }
                }
                break;

            case T555:
                for (iy=0;iy<cy;iy++)
                {
                    for (ix=0;ix<cx;ix++)
                    {
                        *pus++ = (USHORT)(((iy & 0xf8) >> 3) |
                                          ((ix & 0xf8) << 2) |
                                          (((ix | iy) & 0xf8) << 7));
                    }
                }
                break;
            case T466:
                for (iy=0;iy<cy;iy++)
                {
                    for (ix=0;ix<cx;ix++)
                    {
                        *pus++ = (USHORT)(((iy & 0xfc) >> 2) |
                                          ((ix & 0xfc) << 4) |
                                          (((ix | iy) & 0xf0) << 8));
                    }
                }
            }

        }
        break;

    case 24:
        {
            for (iy=0;iy<cy;iy++)
            {
                for (ix=0;ix<cx;ix++)
                {
                    *pdib++ = (BYTE)iy;
                    *pdib++ = (BYTE)ix;
                    *pdib++ = (BYTE)(ix | iy);
                }
            }
        }
        break;
    case 32:
        {
            PULONG pul = (PULONG)pdib;

            for (iy=0;iy<cy;iy++)
            {
                for (ix=0;ix<cx;ix++)
                {
                    *pul++ = 0xff000000 | 
                             (
                               ((ix | iy) << 16) | 
                               (ix << 8)         |
                               (iy)
                             );
                }
            }
        }
        break;
        break;
    }
}

/**************************************************************************\
* hCreateBGR32AlphaSurface
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Mark Enstrom [marke]
*
\**************************************************************************/

HBITMAP
hCreateBGR32AlphaSurface(
    HDC   hdc,
    LONG  cx,
    LONG  cy,
    PVOID *ppvBitmap,
    BOOL  bPerPixelAlpha
    )
{
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbih;
    HBITMAP           hdib;
    ULONG             ux,uy;
    PULONG            pDib;
    PULONG            pulColors;
    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
    pbih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;
    pulColors = (PULONG)&pbmi->bmiColors[0];

    pbih->biSize            = sizeof(BITMAPINFOHEADER);
    pbih->biWidth           = cx;
    pbih->biHeight          = cy;
    pbih->biPlanes          = 1;
    pbih->biBitCount        = 32;
    pbih->biCompression     = BI_BITFIELDS;
    pbih->biSizeImage       = 0;
    pbih->biXPelsPerMeter   = 0;
    pbih->biYPelsPerMeter   = 0;
    pbih->biClrUsed         = 0;
    pbih->biClrImportant    = 0;

    pulColors[0]            = 0x00ff0000;
    pulColors[1]            = 0x0000ff00;
    pulColors[2]            = 0x000000ff;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib != NULL)
    {
        *ppvBitmap = pDib;

        //
        // init 32 bpp dib
        //

        if (bPerPixelAlpha)
        {
            //
            // inter per-pixel aplha DIB
            //

            double fdx = 255.0 / cx;
            double fdy = 255.0 / cy;
            double fcx = 0.0;
            double fcy = 0.0;

            {
                PULONG ptmp = pDib;

                for (uy=0;uy<cy;uy++)
                {
                    for (ux=0;ux<cx;ux++)
                    {
                        double fAlpha = (double)ux/double(cx);
                        BYTE   Alpha  = (BYTE)(255.0 * fAlpha + 0.50);
                        int    blue   = (int)(fdx * (double)ux);
                        int    green  = (int)(fdy * (double)uy);
                        int    red    = 0;

                        blue  = (int)((float)blue  * (fAlpha) + 0.5);
                        green = (int)((float)green * (fAlpha) + 0.5);

                        *ptmp++ = (Alpha << 24) | ((BYTE)(red) << 16) | (((BYTE)green) << 8) | (BYTE)blue;
                    }
                }

                ptmp = (PULONG)((PBYTE)pDib + 32 * (cy *4));

                for (uy=32;uy<42;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        *ptmp++ = 0x00000000;
                    }
                }
            }
        }
        else
        {
            //
            // init DIB with alpha set to 0xFF
            //

            PULONG ptmp = pDib;

            for (uy=0;uy<cy;uy++)
            {
                for (ux=0;ux<cx;ux++)
                {
                    BYTE blue  = (ux*2);
                    BYTE green = (uy*2);
                    BYTE red   = 0;
                    BYTE alpha = 0xff;
                    *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDib) = 0x80800000;


            ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

    }

    LocalFree(pbmi);
    return(hdib);
}

/**************************************************************************\
* ulDetermineScreenFormat
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    4/1/1997 Mark Enstrom [marke]
*
\**************************************************************************/

#define SCR_UNKNOWN 0
#define SCR_1       1
#define SCR_4       2
#define SCR_8       3
#define SCR_16_555  4
#define SCR_16_565  5
#define SCR_24      6
#define SCR_32_RGB  7
#define SCR_32_BGR  8

PCHAR pScreenDef[] = {
    "Unknown",
    "1 Bit per pixel",
    "4 Bit per pixel",
    "8 bit per pixel",
    "16 bit per pixel 555",
    "16 bit per pixel 565",
    "24 bit per pixel",
    "32 bit per pixel RGB",
    "32 bit per pixel BGR"
    };


ULONG
ulDetermineScreenFormat(
    HWND    hwnd
    )
{
    HDC         hdc     = GetDC(hwnd);
    PBITMAPINFO pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(ULONG));
    HBITMAP     hbm;
    ULONG       ulRet = SCR_UNKNOWN;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ((hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL)
    {
        memset(pbmi,0,sizeof(BITMAPINFO) + 255 * sizeof(ULONG));

        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //
        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        if (( pbmi->bmiHeader.biBitCount <= 8 ) || ( pbmi->bmiHeader.biCompression == BI_BITFIELDS ))
        {
            //
            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            //

            GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                      DIB_RGB_COLORS);
        }

        switch (pbmi->bmiHeader.biBitCount)
        {
            case 1: ulRet = SCR_1;
            break;

            case 4: ulRet = SCR_4;
            break;

            case 8:  ulRet = SCR_8;
            break;

            case 16:
            {
                PULONG pul = (PULONG)&pbmi->bmiColors[0];

                if (
                     (pul[0] == 0x7c00) &&
                     (pul[1] == 0x03e0) &&
                     (pul[2] == 0x001f)
                   )
                {
                    ulRet = SCR_16_555;
                }
                else if (
                          (pul[0] == 0xf800) &&
                          (pul[1] == 0x07e0) &&
                          (pul[2] == 0x001f)
                        )
                {
                    ulRet = SCR_16_565;
                }
            }
            break;

            case 24:

                ulRet = SCR_24;
                break;

            case 32:
            {
                PULONG pul = (PULONG)&pbmi->bmiColors[0];

                if (pbmi->bmiHeader.biCompression == BI_RGB)
                {
                    ulRet = SCR_32_BGR;
                }
                else if (
                     (pul[0] == 0xff0000) &&
                     (pul[1] == 0x00ff00) &&
                     (pul[2] == 0x0000ff)
                   )
                {
                    ulRet = SCR_32_BGR;
                }
                else if (
                          (pul[0] == 0x0000ff) &&
                          (pul[1] == 0x00ff00) &&
                          (pul[2] == 0xff0000)
                        )
                {
                    ulRet = SCR_32_RGB;
                }
            }
        }

        DeleteObject(hbm);
    }

    ReleaseDC(hwnd,hdc);
    LocalFree(pbmi);

    return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\tranblt.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   tranblt.cxx

Abstract:

   transparentblt tests

Author:

   Lingyun Wang   (lingyunw) 3/21/97

Enviornment:

   User Mode

Revision History:

--*/

#include "precomp.h"
#include <stdlib.h>
#include "disp.h"
#include "resource.h"
#include <dciman.h>

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

typedef struct _LOGPALETTE256
{
    USHORT palVersion;
    USHORT palNumEntries;
    PALETTEENTRY palPalEntry[256];
} LOGPALETTE256;

static UINT
MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries,
                          LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    //
    // Some 4bpp displays will fail the GetSystemPaletteEntries call.
    // So if detected, return the hardcoded table.
    //

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}




/******************************Public*Routine******************************\
* bFillColorTable
*
* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors
* are set to the current system palette.
*
* Note: call only valid for displays of 8bpp or less.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    BOOL bRet = FALSE;
    BYTE aj[sizeof(PALETTEENTRY) * 256];
    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
    RGBQUAD *prgb = (RGBQUAD *) &pbmi->bmiColors[0];
    ULONG cColors;

    cColors = 1 << pbmi->bmiHeader.biBitCount;
    if ( cColors <= 256 )
    {
        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe)
                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) )
        {
            UINT i;

            for (i = 0; i < cColors; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }

            bRet = TRUE;
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* bFillBitmapInfo
*
* Fills in the fields of a BITMAPINFO so that we can create a bitmap
* that matches the format of the display.
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static BOOL
bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi)
{
    HBITMAP hbm;
    BOOL    bRet = FALSE;

    //
    // Create a dummy bitmap from which we can query color format info
    // about the device surface.
    //

    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
    {
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        //
        // Call first time to fill in BITMAPINFO header.
        //

        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

        {
            {
                //
                // Call a second time to get the color masks/color table.
                // It's a GetDIBits Win32 "feature".
                //

                GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL, pbmi,
                          DIB_RGB_COLORS);
            }

            bRet = TRUE;
        }

        DeleteObject(hbm);
    }

    return bRet;
}


/******************************Public*Routine******************************\
* CreateCompatibleDIB
*
* Create a DIB section with an optimal format w.r.t. the specified hdc.
*
* If DIB <= 8bpp, then the DIB color table is initialized based on the
* specified palette.  If the palette handle is NULL, then the system
* palette is used.
*
* Note: The hdc must be a direct DC (not an info or memory DC).
*
* Note: On palettized displays, if the system palette changes the
*       UpdateDIBColorTable function should be called to maintain
*       the identity palette mapping between the DIB and the display.
*
* Returns:
*   Valid bitmap handle if successful, NULL if error.
*
* History:
*  23-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP APIENTRY
CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight,
                    PVOID *ppvBits)
{
    HBITMAP hbmRet = (HBITMAP) NULL;
    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)];
    BITMAPINFO *pbmi = (BITMAPINFO *) aj;
    UINT iUsage;

    //
    // Validate hdc.
    //

    if ( GetObjectType(hdc) != OBJ_DC )
    {
        return hbmRet;
    }

    memset(aj, 0, sizeof(aj));

    if ( bFillBitmapInfo(hdc, hpal, pbmi) )
    {
        //
        // Change bitmap size to match specified dimensions.
        //

        pbmi->bmiHeader.biWidth = ulWidth;
        pbmi->bmiHeader.biHeight = ulHeight;
        if (pbmi->bmiHeader.biCompression == BI_RGB)
        {
            pbmi->bmiHeader.biSizeImage = 0;
        }
        else
        {
            if ( pbmi->bmiHeader.biBitCount == 16 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 2;
            else if ( pbmi->bmiHeader.biBitCount == 32 )
                pbmi->bmiHeader.biSizeImage = ulWidth * ulHeight * 4;
            else
                pbmi->bmiHeader.biSizeImage = 0;
        }
        pbmi->bmiHeader.biClrUsed = 0;
        pbmi->bmiHeader.biClrImportant = 0;

        //
        // Create the DIB section.  Let Win32 allocate the memory and return
        // a pointer to the bitmap surface.
        //

        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0);
    }

    return hbmRet;
}

#if 0
/******************************Public*Routine******************************\
* DCISurfInfo
*
* Output information about the DCI primary surface.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void DCISurfInfo(
                    TEST_CALL_DATA *pCallData
                 )
{
// If DCI surface info exists, output it to the list box.

    if ( pDCISurfInfo )
    {

        HDC hdc = GetDCAndTransform(pCallData->hwnd);

        CHAR msg[256];

        wsprintf(msg, "DCISURFACEINFO:");
        TextOut(hdc,10,10,msg,strlen(msg));

        wsprintf(msg, "    dwSize        = 0x%lx",pDCISurfInfo->dwSize       );
        TextOut(hdc,10,30,msg,strlen(msg));

        wsprintf(msg, "    dwDCICaps     = 0x%lx",pDCISurfInfo->dwDCICaps    );
        TextOut(hdc,10,50,msg,strlen(msg));

        wsprintf(msg, "    dwCompression = %ld"  ,pDCISurfInfo->dwCompression);
        TextOut(hdc,10,70,msg,strlen(msg));

        wsprintf(msg, "    dwMask        = (0x%lx, 0x%lx, 0x%lx)",
                                      pDCISurfInfo->dwMask[0],
                                      pDCISurfInfo->dwMask[1],
                                      pDCISurfInfo->dwMask[2]           );
        TextOut(hdc,10,90,msg,strlen(msg));

        wsprintf(msg, "    dwWidth       = %ld"  ,pDCISurfInfo->dwWidth      );
        TextOut(hdc,10,110,msg,strlen(msg));

        wsprintf(msg, "    dwHeight      = %ld"  ,pDCISurfInfo->dwHeight     );
        TextOut(hdc,10,130,msg,strlen(msg));

        wsprintf(msg, "    lStride       = 0x%lx",pDCISurfInfo->lStride      );
        TextOut(hdc,10,150,msg,strlen(msg));

        wsprintf(msg, "    dwBitCount    = %ld"  ,pDCISurfInfo->dwBitCount   );
        TextOut(hdc,10,170,msg,strlen(msg));

        wsprintf(msg, "    dwOffSurface  = 0x%lx",pDCISurfInfo->dwOffSurface );
        TextOut(hdc,10,190,msg,strlen(msg));

        wsprintf(msg, "    wSelSurface  = 0x%lx",pDCISurfInfo->wSelSurface );
        TextOut(hdc,10,210,msg,strlen(msg));


    }
}

/******************************Public*Routine******************************\
* InitDCI
*
* Initialize DCI.  hdcDCI and pDCISurfInfo are global data which are valid
* only if this function succeeds.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void InitDCI(pCallData->hwnd)
{
    if ( hdcDCI = DCIOpenProvider() )
    {
        if (
            (DCICreatePrimary(hdcDCI, &pDCISurfInfo) == DCI_OK) &&
            (pDCISurfInfo != (LPDCISURFACEINFO) NULL)
           )
        {
            DCISurfInfo(pCallData->hwnd);
        }
    }
    return;
}


/******************************Public*Routine******************************\
* CloseDCI
*
* Shutdown DCI access.  hdcDCI and pDCISurfInfo will be invalid afterwards.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void CloseDCI()
{

    if (pDCISurfInfo)
    {
        DCIDestroy(pDCISurfInfo);
        pDCISurfInfo = (LPDCISURFACEINFO) NULL;
    }

    if (hdcDCI)
    {
        DCICloseProvider(hdcDCI);
        hdcDCI = (HDC) NULL;
    }
}

DCIRVAL DCIInfo(
                TEST_CALL_DATA *pCallData
                )
{
    DCIRVAL dciRet = 0;
    RECT    rc, rcDst;
    POINT   pt, ptDst;
    ULONG   ulError = 0;
    INT     i;
    int     j;
    PBYTE   pStart, pStartTmp;
    HDC hdc = GetDCAndTransform(pCallData->hwnd);
    CHAR msg[256];



// Quick out -- is DCI enabled?

    if ( !pDCISurfInfo )
        return;

    GetClientRect(pCallData->hwnd, &rc);

    pt.x = 0; pt.y = 0;
    ClientToScreen(pCallData->hwnd, &pt);

    ptDst.x = rc.left;
    ptDst.y = rc.top;
    ClientToScreen(pCallData->hwnd, &ptDst);

    rcDst.right = ptDst.x + (rc.right-rc.left);
    rcDst.bottom = ptDst.y + (rc.bottom-rc.top);
    rcDst.left = ptDst.x;
    rcDst.top = ptDst.y;


    dciRet = DCIBeginAccess(
                pDCISurfInfo,
                pt.x,
                pt.y,
                rc.right-rc.left,
                rc.bottom - rc.top
               );

    if ( dciRet >= 0 )
    {
       pStart = (PBYTE)(pDCISurfInfo->dwOffSurface + pDCISurfInfo->lStride*pt.y)
                         + pt.x * (pDCISurfInfo->dwBitCount >> 3);

       wsprintf(msg, "    pStart  = 0x%lx",pStart );
       TextOut(hdc,10,230,msg,strlen(msg));


       for (j=0; j < 10; j++)
       {
           pStartTmp = pStart;
           for (i=0;i < rc.right-rc.left; i++)
           {
               *pStartTmp++ = 0x7c;
           }
           pStart = (PBYTE)pStart+pDCISurfInfo->lStride;
       }


       DCIEndAccess(pDCISurfInfo);
     }

    return(dciRet);
}


VOID Test_DCI (
    TEST_CALL_DATA *pCallData
    )
{
    InitDCI(pCallData->hwnd);

    DCIInfo (pCallData->hwnd);

    CloseDCI();

    return;
}
#endif

HBITMAP
LoadDIB(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc      = GetDCAndTransform(pCallData->hwnd);
    HANDLE  hFile    = NULL;
    HANDLE  hMap     = NULL;
    HBITMAP hbm      = NULL;
    ULONG   hx,hy;
    PVOID   pFile    = NULL;

    hFile = CreateFile("C:\\monitor.bmp",
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile)
    {
        hMap = CreateFileMapping(hFile,
                                 NULL,
                                 PAGE_READWRITE,
                                 0,
                                 0,
                                 NULL
                                 );
        if (hMap)
        {
            pFile = MapViewOfFile(hMap,
                                  FILE_MAP_READ,
                                  0,
                                  0,
                                  NULL
                                  );

            if (pFile)
            {
                BITMAPINFO          bmiDIB;
                PBITMAPFILEHEADER   pbmf = (PBITMAPFILEHEADER)pFile;
                PBITMAPINFO         pbmi = (PBITMAPINFO)((PBYTE)pFile + sizeof(BITMAPFILEHEADER));
                PBYTE               pbits = (PBYTE)pbmf + pbmf->bfOffBits;

                ULONG ulSize = sizeof(BITMAPINFO);

                //
                // calc color table size
                //

                if (pbmi->bmiHeader.biCompression == BI_RGB)
                {
                    if (pbmi->bmiHeader.biBitCount == 1)
                    {
                        ulSize += 1 * sizeof(ULONG);
                    }
                    else if (pbmi->bmiHeader.biBitCount == 4)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 16)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 15 * sizeof(ULONG);
                        }
                    }
                    else if (pbmi->bmiHeader.biBitCount == 8)
                    {
                        if (pbmi->bmiHeader.biClrUsed <= 256)
                        {
                            ulSize += pbmi->bmiHeader.biClrUsed * sizeof(ULONG);
                        }
                        else
                        {
                            ulSize += 255 * sizeof(ULONG);
                        }
                    }
                }
                else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
                {
                    ulSize += 2 * sizeof(ULONG);
                }

                memcpy(&bmiDIB,pbmi,ulSize);

                {
                    BITMAPINFO bmDibSec;
                    PVOID      pdib = NULL;
                    LONG       Height = bmiDIB.bmiHeader.biHeight;

                    if (Height > 0)
                    {
                        Height = -Height;
                    }

                    bmDibSec.bmiHeader.biSize            = sizeof(BITMAPINFO);
                    bmDibSec.bmiHeader.biWidth           = bmiDIB.bmiHeader.biWidth;
                    bmDibSec.bmiHeader.biHeight          = Height;
                    bmDibSec.bmiHeader.biPlanes          = 1;
                    bmDibSec.bmiHeader.biBitCount        = 32;
                    //bmDibSec.bmiHeader.biCompression     = BI_BGRA;
                    bmDibSec.bmiHeader.biCompression     = BI_RGB;
                    bmDibSec.bmiHeader.biSizeImage       = 0;
                    bmDibSec.bmiHeader.biXPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biYPelsPerMeter   = 100;
                    bmDibSec.bmiHeader.biClrUsed         = 0;
                    bmDibSec.bmiHeader.biClrImportant    = 0;

                    hx = bmDibSec.bmiHeader.biWidth;
                    hy = Height;


                    hbm = CreateDIBSection(hdc,&bmDibSec,DIB_RGB_COLORS,&pdib,NULL,0);
                    SetDIBits(hdc,hbm,0,Height,pbits,&bmiDIB,DIB_RGB_COLORS);

                    {
                        ULONG ix,iy;
                        PULONG pulDIB = (PULONG)pdib;

                        for (iy=0;iy<hy;iy++)
                        {
                            for (ix=0;ix<hx;ix++)
                            {
                                *pulDIB = *pulDIB | 0xff000000;
                                pulDIB++;
                            }
                        }
                    }

                }

                UnmapViewOfFile(pFile);
            }

            CloseHandle(hMap);
        }
        else
        {
            CHAR msg[256];

            wsprintf(msg,"MapViewOfFile Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
        }

        CloseHandle(hFile);
    }
    else
   {
            CHAR msg[256];

            wsprintf(msg,"FileMapping Error = %li    ",GetLastError());
            TextOut(hdc,10,10,msg,strlen(msg));
    }
    return (hbm);
}

// test compatible bitmap to display -- create two DIBs
VOID vTestTranBltOffset(
                        TEST_CALL_DATA *pCallData
                        )
{
     HBITMAP    hbm;
     HDC        hdc, hdcSrc;


     //
     // Clear screen
     //

     hdc = GetDCAndTransform (pCallData->hwnd);

     SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));

     PatBlt(hdc,0,0,2000,2000,PATCOPY);

     hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

     hdcSrc = CreateCompatibleDC (hdc);

     SelectObject (hdcSrc, hbm);

     SetViewportOrgEx (hdc, 100, 100, NULL);
     TransparentBlt (hdc, -100, -100, 200, 200, hdcSrc, 0, 0, 200, 200, RGB(0xff,0xff,0));


     // blt negative dest offset
     TransparentBlt (hdc, -20, -20, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     StretchBlt (hdc, 184-20, -20, 184, 170, hdcSrc, 0, 0, 184, 170, SRCCOPY);

     // no offset
     TransparentBlt (hdc, 184+184, 0, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     StretchBlt (hdc, 184+184+184, 0, 184, 170, hdcSrc, 0, 0, 184, 170, SRCCOPY);

     // offset
     TransparentBlt (hdc, 184+184+184+184-10, -10, 184, 170, hdcSrc, -10, -10, 184, 170, RGB(0xff,0xff,0));
     StretchBlt (hdc, 184+184+184+184+184-10, -10, 184, 170, hdcSrc, -10, -10, 184, 170, SRCCOPY);


     //blt positive src offset
     TransparentBlt (hdc, 0, 170, 184, 170, hdcSrc, 20, 20, 184, 170, RGB(0xff,0xff,0));
     StretchBlt (hdc, 200, 170, 184, 170, hdcSrc, 20, 20, 184, 170, SRCCOPY);

     //blt negative src offset
     TransparentBlt (hdc, 200+200, 170, 184, 170, hdcSrc, -20, -20, 184, 170, RGB(0xff,0xff,0));
     StretchBlt (hdc, 200+200+200, 170, 184, 170, hdcSrc, -20, -20, 184, 170, SRCCOPY);

     // blt negative dest/src offsets
     TransparentBlt (hdc, -20, 400, 184, 170, hdcSrc, -10, 0, 184, 170, RGB(0xff,0xff,0));
     BitBlt (hdc, 100-20, 400, 184, 170, hdcSrc, -10, 0, SRCCOPY);

     TransparentBlt (hdc, 300, 400, 200, 200, hdcSrc, 50, 50, 200, 200, RGB(0xff,0xff,0));
     StretchBlt (hdc, 500, 400, 200, 200, hdcSrc, 50, 50, 200, 200, SRCCOPY);

     // smaller exts
     TransparentBlt (hdc, 600, 400,100, 100, hdcSrc, -20, -20, 100, 100, RGB(0xff,0xff,0));
     StretchBlt (hdc, 700, 400, 100, 100, hdcSrc, -20, -20, 100, 100, SRCCOPY);


     DeleteObject (hbm);
     ReleaseDC (pCallData->hwnd,hdc);
     DeleteDC (hdcSrc);
}

VOID vTestTranBltStretch(
                         TEST_CALL_DATA *pCallData
                         )
{
     HBITMAP    hbm;
     HDC        hdc, hdcSrc;

     hdc = GetDCAndTransform (pCallData->hwnd);

     // clear screen
     SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
     PatBlt(hdc,0,0,2000,2000,PATCOPY);

     hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

     hdcSrc = CreateCompatibleDC (hdc);

     SelectObject (hdcSrc, hbm);

     // stretching larger
     TransparentBlt (hdc, 0, -20, 200, 200, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     StretchBlt (hdc, 200, -20, 200, 200, hdcSrc, 0, 0, 184, 170, SRCCOPY);

     // stretch smaller

     //no stretch
     TransparentBlt (hdc, 0, 200, 200, 200, hdcSrc, 0, 0, 200, 200, RGB(0xff,0xff,0));
     StretchBlt (hdc, 200, 200, 200, 200, hdcSrc, 0, 0, 200, 200, SRCCOPY);

     //blt negative src offsets
     TransparentBlt (hdc, 200+200, 200, 184, 170, hdcSrc, 0, 0, 200, 200, RGB(0xff,0xff,0));
     StretchBlt (hdc, 200+200+200, 200, 184, 170, hdcSrc, 0, 0, 200, 200, SRCCOPY);

     // blt smaller cx cy
     TransparentBlt (hdc, 0, 400, 200, 200, hdcSrc, 0, 0, 100, 100, RGB(0xff,0xff,0));
     StretchBlt (hdc, 200, 400, 200, 200, hdcSrc, 0, 0, 100, 100, SRCCOPY);

     TransparentBlt (hdc, 400, 400, 300, 300, hdcSrc, -20, -20, 100, 100, RGB(0xff,0xff,0));
     StretchBlt (hdc, 500, 400, 300, 300, hdcSrc, -20, -20, 100, 100, SRCCOPY);

     DeleteObject (hbm);
     ReleaseDC (pCallData->hwnd,hdc);
     DeleteDC (hdcSrc);
}

// test dib sections bitmap to display -- create two DIBs
VOID vTestTranDIBOffset(
                        TEST_CALL_DATA *pCallData
                        )
{
     HBITMAP    hbm, hDib;
     HDC        hdc, hdcSrc, hdcTemp;
     PBITMAPINFO pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
     PULONG pDib = (PULONG)LocalAlloc(0,128*128);

     pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
     pbmi->bmiHeader.biWidth           = 0;
     pbmi->bmiHeader.biHeight          = 0;
     pbmi->bmiHeader.biPlanes          = 0;
     pbmi->bmiHeader.biBitCount        = 0;
     pbmi->bmiHeader.biCompression     = 0;
     pbmi->bmiHeader.biSizeImage       = 0;
     pbmi->bmiHeader.biXPelsPerMeter   = 0;
     pbmi->bmiHeader.biYPelsPerMeter   = 0;
     pbmi->bmiHeader.biClrUsed         = 0;
     pbmi->bmiHeader.biClrImportant    = 0;


     //
     // Clear screen
     //

     hdc = GetDCAndTransform (pCallData->hwnd);

     SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));

     PatBlt(hdc,0,0,2000,2000,PATCOPY);

     hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));


     hdcSrc = CreateCompatibleDC (hdc);
     hdcTemp = CreateCompatibleDC (hdc);

     SelectObject (hdcSrc, hbm);


     GetDIBits (hdcSrc, hbm, 0, 170, NULL, pbmi, DIB_RGB_COLORS);
     GetDIBits (hdcSrc, hbm, 0, 170, NULL, pbmi, DIB_RGB_COLORS);

     hDib = CreateDIBSection (hdcTemp, pbmi, DIB_RGB_COLORS, (PVOID *)&pDib, NULL, 0);

     GetDIBits (hdcSrc, hbm, 0, 170, pDib, pbmi, DIB_RGB_COLORS);

     //SelectObject (hdcTemp, hDib);

     //BitBlt (hdcTemp, 0, 0, 184, 170, hdcSrc, 0, 0, SRCCOPY);

     LOGPALETTE256 logpal;

     logpal.palVersion = 0x300;
     logpal.palNumEntries = 256;

     for (ULONG i=0; i<256; i++)
     {
         logpal.palPalEntry[i].peRed = pbmi->bmiColors[i].rgbRed;
         logpal.palPalEntry[i].peGreen = pbmi->bmiColors[i].rgbGreen;
         logpal.palPalEntry[i].peBlue = pbmi->bmiColors[i].rgbBlue;
         logpal.palPalEntry[i].peFlags = 0;
     }

     HPALETTE hpal = CreatePalette((LOGPALETTE *)&logpal);

     ULONG index = GetNearestPaletteIndex(hpal,RGB(255,255,0));

     // blt negative dest offset
     TransparentDIBits (hdc, -20, -20, 184, 170, pDib, pbmi, DIB_RGB_COLORS, 0, 0, 184, 170, index);
     StretchDIBits (hdc, 184-20, -20, 184, 170, 0, 0, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     // no offset
     TransparentDIBits (hdc, 184+184, 0, 184, 170, pDib, pbmi, DIB_RGB_COLORS, 0, 0, 184, 170, index);
     StretchDIBits (hdc, 184+184+184, 0, 184, 170, 0, 0, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     // offset
     TransparentDIBits (hdc, 184+184+184+184-10, -10, 184, 170, pDib, pbmi, DIB_RGB_COLORS, -10, -10, 184, 170, index);
     StretchDIBits (hdc, 184+184+184+184+184-10, -10, 184, 170, -10, -10, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);


     //blt positive src offset
     TransparentDIBits (hdc, 0, 170, 184, 170, pDib, pbmi, DIB_RGB_COLORS, 20, 20, 184, 170, index);
     StretchDIBits (hdc, 200, 170, 184, 170, 20, 20, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     //blt negative src offset
     TransparentDIBits (hdc, 200+200, 170, 184, 170, pDib, pbmi, DIB_RGB_COLORS, -20, -20, 184, 170, index);
     StretchDIBits (hdc, 200+200+200, 170, 184, 170, -20, -20, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     // blt negative dest/src offsets
     TransparentDIBits (hdc, -20, 400, 184, 170, pDib, pbmi, DIB_RGB_COLORS, -10, 0, 184, 170, index);
     StretchDIBits (hdc, 100-20, 400, 184, 170, -10, 0, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     TransparentDIBits (hdc, 300, 400, 200, 200, pDib, pbmi, DIB_RGB_COLORS, 50, 50, 200, 200, index);
     StretchDIBits (hdc, 500, 400, 200, 200, 50, 50, 200, 200, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     // smaller exts
     TransparentDIBits (hdc, 600, 400,100, 100, pDib, pbmi, DIB_RGB_COLORS, -20, -20, 100, 100, index);
     StretchDIBits (hdc, 700, 400, 100, 100, -20, -20, 100, 100, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     DeleteObject (hDib);     
     DeleteObject (hbm);
     DeleteDC (hdcSrc);
     DeleteDC (hdcTemp);
     ReleaseDC (pCallData->hwnd,hdc);
}

VOID vTestTranDIBStretch(
                         TEST_CALL_DATA *pCallData
                         )
{
     HBITMAP    hbm;
     HDC        hdc, hdcSrc,hdcTemp;
     HANDLE     hDib;
     PBITMAPINFO pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
     PULONG pDib = (PULONG)LocalAlloc(0,128*128);

     pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
     pbmi->bmiHeader.biWidth           = 0;
     pbmi->bmiHeader.biHeight          = 0;
     pbmi->bmiHeader.biPlanes          = 0;
     pbmi->bmiHeader.biBitCount        = 0;
     pbmi->bmiHeader.biCompression     = 0;
     pbmi->bmiHeader.biSizeImage       = 0;
     pbmi->bmiHeader.biXPelsPerMeter   = 0;
     pbmi->bmiHeader.biYPelsPerMeter   = 0;
     pbmi->bmiHeader.biClrUsed         = 0;
     pbmi->bmiHeader.biClrImportant    = 0;

     //
     // Clear screen
     //

     hdc = GetDCAndTransform (pCallData->hwnd);

     SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));

     PatBlt(hdc,0,0,2000,2000,PATCOPY);

     hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

     hdcSrc = CreateCompatibleDC (hdc);
     hdcTemp = CreateCompatibleDC (hdc);

     SelectObject (hdcSrc, hbm);

     GetDIBits (hdcSrc, hbm, 0, 170, NULL, pbmi, DIB_RGB_COLORS);
     GetDIBits (hdcSrc, hbm, 0, 170, NULL, pbmi, DIB_RGB_COLORS);

     pbmi->bmiHeader.biHeight          = -pbmi->bmiHeader.biHeight;

     hDib = CreateDIBSection (hdcTemp, pbmi, DIB_RGB_COLORS, (PVOID *)&pDib, NULL, 0);

     GetDIBits (hdcSrc, hbm, 0, 170, pDib, pbmi, DIB_RGB_COLORS);

     //SelectObject (hdcTemp, hDib);

     //BitBlt (hdcTemp, 0, 0, 184, 170, hdcSrc, 0, 0, SRCCOPY);

     LOGPALETTE256 logpal;

     logpal.palVersion = 0x300;
     logpal.palNumEntries = 256;

     for (ULONG i=0; i<256; i++)
     {
         logpal.palPalEntry[i].peRed = pbmi->bmiColors[i].rgbRed;
         logpal.palPalEntry[i].peGreen = pbmi->bmiColors[i].rgbGreen;
         logpal.palPalEntry[i].peBlue = pbmi->bmiColors[i].rgbBlue;
         logpal.palPalEntry[i].peFlags = 0;
     }

     HPALETTE hpal = CreatePalette((LOGPALETTE *)&logpal);

     ULONG index = GetNearestPaletteIndex(hpal,RGB(255,255,0));

     // clear screen
     SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
     PatBlt(hdc,0,0,2000,2000,PATCOPY);

     hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

     hdcSrc = CreateCompatibleDC (hdc);

     SelectObject (hdcSrc, hbm);

     // stretching larger
     TransparentDIBits (hdc, 0, -20, 200, 200, pDib, pbmi, DIB_RGB_COLORS, 0, 0, 184, 170, 0x0f);
     StretchDIBits (hdc, 200, -20, 200, 200, 0, 0, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     // stretch smaller

     TransparentDIBits (hdc, 400, 0, 100, 100, pDib, pbmi, DIB_RGB_COLORS, 20, 20, 184, 170, index);
     StretchDIBits (hdc, 500, 0, 100, 100, 20, 20, 184, 170, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     //no stretch
     TransparentDIBits (hdc, 0, 200, 200, 200, pDib, pbmi, DIB_RGB_COLORS, 0, 0, 200, 200, index);
     StretchDIBits (hdc, 200, 200, 200, 200, 0, 0, 200, 200, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     //blt negative src offsets
     TransparentDIBits (hdc, 400, 200, 184, 170, pDib, pbmi, DIB_RGB_COLORS, 0, 0, 200, 200, index);
     StretchDIBits (hdc,600, 200, 184, 170, 0, 0, 200, 200, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     // blt smaller cx cy
     TransparentDIBits (hdc, 0, 400, 200, 200, pDib, pbmi, DIB_RGB_COLORS, 0, 0, 100, 100, index);
     StretchDIBits (hdc,200, 400, 200, 200, 0, 0, 100, 100, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     TransparentDIBits (hdc, 400, 400, 300, 300, pDib, pbmi, DIB_RGB_COLORS, -20, -20, 100, 100, index);
     StretchDIBits (hdc,500, 400, 300, 300, -20, -20, 100, 100, pDib, pbmi, DIB_RGB_COLORS, SRCCOPY);

     DeleteObject (hDib);
     DeleteObject (hbm);
     DeleteDC (hdcSrc);
     DeleteDC (hdcTemp);
     ReleaseDC (pCallData->hwnd,hdc);
}



VOID vTest2 (
             TEST_CALL_DATA *pCallData
             )
{
     HDC hdc, hdcSrc, hdcTmp;
     HBITMAP hbm,hdib;
     CHAR msg[256];
     PBITMAPINFO pbmi;
     PVOID pvBits;

     hdc = GetDCAndTransform (pCallData->hwnd);

     hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

     hdcSrc = CreateCompatibleDC (hdc);
     hdcTmp = CreateCompatibleDC (hdc);

     if (!hbm || !hdcSrc)
     {
         wsprintf(msg," bad hbm = %x or hdcSrc = %x    ", hbm, hdcSrc);
         TextOut(hdc,10,10,msg,strlen(msg));
     }

     SelectObject (hdcSrc, hbm);

     pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

     pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
     pbmi->bmiHeader.biWidth           = 500;
     pbmi->bmiHeader.biHeight          = 200;
     pbmi->bmiHeader.biPlanes          = 1;
     pbmi->bmiHeader.biBitCount        = 32;
     pbmi->bmiHeader.biCompression     = BI_RGB;
     pbmi->bmiHeader.biSizeImage       = 0;
     pbmi->bmiHeader.biXPelsPerMeter   = 0;
     pbmi->bmiHeader.biYPelsPerMeter   = 0;
     pbmi->bmiHeader.biClrUsed         = 0;
     pbmi->bmiHeader.biClrImportant    = 0;

     hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,&pvBits,NULL,0);

     SelectObject (hdcTmp, hdib);

     PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

     TransparentBlt (hdcTmp, 0, 0, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     TransparentBlt (hdcTmp, 184, 0, 200, 200, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     TransparentBlt (hdcTmp, 384, 0, 100, 100, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));

     BitBlt (hdc, 0, 0, 500, 200, hdcTmp, 0, 0, SRCCOPY);


     pbmi->bmiHeader.biBitCount        = 24;
     hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,&pvBits,NULL,0);

     DeleteObject (SelectObject (hdcTmp, hdib));

     PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

     TransparentBlt (hdcTmp, 0, 0, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     TransparentBlt (hdcTmp, 184, 0, 200, 200, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     TransparentBlt (hdcTmp, 384, 0, 100, 100, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));

     BitBlt (hdc, 0, 0, 500, 200, hdcTmp, 0, 0, SRCCOPY);

     pbmi->bmiHeader.biBitCount        = 16;
     hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,&pvBits,NULL,0);

     DeleteObject (SelectObject (hdcTmp, hdib));

     PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

     TransparentBlt (hdcTmp, 0, 0, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     TransparentBlt (hdcTmp, 184, 0, 200, 200, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
     TransparentBlt (hdcTmp, 384, 0, 100, 100, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));

     BitBlt (hdc, 0, 0, 500, 200, hdcTmp, 0, 0, SRCCOPY);

     LocalFree(pbmi);

     DeleteObject (hbm);
     DeleteDC (hdcSrc);
     DeleteDC (hdcTmp);
     DeleteObject(hdib);
     ReleaseDC (pCallData->hwnd,hdc);
}

VOID vTest3 (
             TEST_CALL_DATA *pCallData
             )
{
    HDC hdc     = GetDCAndTransform(pCallData->hwnd);
    RGBQUAD palentry[16] =
{
    { 0,   0,   0,   0 },
    { 0x80,0,   0,   0 },
    { 0,   0x80,0,   0 },
    { 0x80,0x80,0,   0 },
    { 0,   0,   0x80,0 },
    { 0x80,0,   0x80,0 },
    { 0,   0x80,0x80,0 },
    { 0x80,0x80,0x80,0 },

    { 0xC0,0xC0,0xC0,0 },
    { 0xFF,0,   0,   0 },
    { 0,   0xFF,0,   0 },
    { 0xFF,0xFF,0,   0 },
    { 0,   0,   0xFF,0 },
    { 0xFF,0,   0xFF,0 },
    { 0,   0xFF,0xFF,0 },
    { 0xFF,0xFF,0xFF,0 }
};


    //
    //  create a DIBSection to test transparent drawing
    //
    {
        PBITMAPINFO pbmi, pbmi2,pbmi3,pbmi4,pbmi5,pbmi6,pbmi7,pbmi8;
        ULONG ux,uy;
        PULONG pDib,pDib2,pDib3,pDib4, pDib5, pDib6,pDib7,pDib8;
        HDC hdc1, hdc2, hdc3, hdc4, hdc5, hdc6, hdc7, hdc8;
        HBITMAP hdib1,hdib2,hdib3,hdib4, hdib5, hdib6, hdib7, hdib8;
        PULONG ptmp;
        int i=0;

        ULONG xpos  = 0;
        ULONG xpos2 = 200;
        ULONG xpos3 = 400;
        ULONG xpos4 = 600;
        ULONG xpos5 = 800;
        ULONG xpos6 = 1000;
        ULONG ypos  = 32;
        ULONG dy    = 164;
        ULONG dx    = 164;


        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib = (PULONG)LocalAlloc(0,4*128*128);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = -128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        pbmi2 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib2 = (PULONG)LocalAlloc(0,3*128*128);


        pbmi2->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi2->bmiHeader.biWidth           = 128;
        pbmi2->bmiHeader.biHeight          = -128;
        pbmi2->bmiHeader.biPlanes          = 1;
        pbmi2->bmiHeader.biBitCount        = 24;
        pbmi2->bmiHeader.biCompression     = BI_RGB;
        pbmi2->bmiHeader.biSizeImage       = 0;
        pbmi2->bmiHeader.biXPelsPerMeter   = 0;
        pbmi2->bmiHeader.biYPelsPerMeter   = 0;
        pbmi2->bmiHeader.biClrUsed         = 0;
        pbmi2->bmiHeader.biClrImportant    = 0;

        pbmi3 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib3 = (PULONG)LocalAlloc(0,2*128*128);

        pbmi3->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi3->bmiHeader.biWidth           = 128;
        pbmi3->bmiHeader.biHeight          = -128;
        pbmi3->bmiHeader.biPlanes          = 1;
        pbmi3->bmiHeader.biBitCount        = 16;
        pbmi3->bmiHeader.biCompression     = BI_RGB;
        pbmi3->bmiHeader.biSizeImage       = 0;
        pbmi3->bmiHeader.biXPelsPerMeter   = 0;
        pbmi3->bmiHeader.biYPelsPerMeter   = 0;
        pbmi3->bmiHeader.biClrUsed         = 0;
        pbmi3->bmiHeader.biClrImportant    = 0;

        pbmi4 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib4 = (PULONG)LocalAlloc(0,128*128);

        pbmi4->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi4->bmiHeader.biWidth           = 128;
        pbmi4->bmiHeader.biHeight          = -128;
        pbmi4->bmiHeader.biPlanes          = 1;
        pbmi4->bmiHeader.biBitCount        = 8;
        pbmi4->bmiHeader.biCompression     = BI_RGB;
        pbmi4->bmiHeader.biSizeImage       = 0;
        pbmi4->bmiHeader.biXPelsPerMeter   = 0;
        pbmi4->bmiHeader.biYPelsPerMeter   = 0;
        pbmi4->bmiHeader.biClrUsed         = 0;
        pbmi4->bmiHeader.biClrImportant    = 0;

        for (ux=0;ux<256;ux++)
        {
            pbmi4->bmiColors[ux].rgbRed       = (BYTE)ux;
            pbmi4->bmiColors[ux].rgbGreen     = 0;
            pbmi4->bmiColors[ux].rgbBlue      = (BYTE)ux;
#if 0
            pbmi4->bmiColors[ux].rgbRed       = (BYTE)(ux & 7) << 5;
            pbmi4->bmiColors[ux].rgbGreen     = (BYTE)((ux >> 3) & 7) << 5;
            pbmi4->bmiColors[ux].rgbBlue      = (BYTE)((ux >> 6) << 6);
#endif
            pbmi4->bmiColors[ux].rgbReserved  = 0;
        }

        //
        // tran color
        //

        pbmi4->bmiColors[255].rgbRed       = 255;
        pbmi4->bmiColors[255].rgbGreen     = 0;
        pbmi4->bmiColors[255].rgbBlue      = 0;
        pbmi4->bmiColors[255].rgbReserved  = 0;


        pbmi5 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib5 = (PULONG)LocalAlloc(0,128*64);

        pbmi5->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi5->bmiHeader.biWidth           = 128;
        pbmi5->bmiHeader.biHeight          = -128;
        pbmi5->bmiHeader.biPlanes          = 1;
        pbmi5->bmiHeader.biBitCount        = 4;
        pbmi5->bmiHeader.biCompression     = BI_RGB;
        pbmi5->bmiHeader.biSizeImage       = 0;
        pbmi5->bmiHeader.biXPelsPerMeter   = 0;
        pbmi5->bmiHeader.biYPelsPerMeter   = 0;
        pbmi5->bmiHeader.biClrUsed         = 0;
        pbmi5->bmiHeader.biClrImportant    = 0;

        memcpy (pbmi5->bmiColors, palentry, sizeof(RGBQUAD)*16);

        pbmi6 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib6 = (PULONG)LocalAlloc(0,128*16);

        pbmi6->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi6->bmiHeader.biWidth           = 128;
        pbmi6->bmiHeader.biHeight          = -128;
        pbmi6->bmiHeader.biPlanes          = 1;
        pbmi6->bmiHeader.biBitCount        = 1;
        pbmi6->bmiHeader.biCompression     = BI_RGB;
        pbmi6->bmiHeader.biSizeImage       = 0;
        pbmi6->bmiHeader.biXPelsPerMeter   = 0;
        pbmi6->bmiHeader.biYPelsPerMeter   = 0;
        pbmi6->bmiHeader.biClrUsed         = 0;
        pbmi6->bmiHeader.biClrImportant    = 0;

        pbmi6->bmiColors[0].rgbRed = 0;
        pbmi6->bmiColors[0].rgbGreen = 0xFF;
        pbmi6->bmiColors[0].rgbBlue = 0;
        pbmi6->bmiColors[0].rgbReserved = 0;

        pbmi6->bmiColors[1].rgbRed = 0xFF;
        pbmi6->bmiColors[1].rgbGreen = 0x0;
        pbmi6->bmiColors[1].rgbBlue = 0x0;
        pbmi6->bmiColors[1].rgbReserved = 0;

        // DIB_PAL_COLORS
        pbmi7 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib7 = (PULONG)LocalAlloc(0,128*128);

        pbmi7->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi7->bmiHeader.biWidth           = 128;
        pbmi7->bmiHeader.biHeight          = -128;
        pbmi7->bmiHeader.biPlanes          = 1;
        pbmi7->bmiHeader.biBitCount        = 8;
        pbmi7->bmiHeader.biCompression     = BI_RGB;
        pbmi7->bmiHeader.biSizeImage       = 0;
        pbmi7->bmiHeader.biXPelsPerMeter   = 0;
        pbmi7->bmiHeader.biYPelsPerMeter   = 0;
        pbmi7->bmiHeader.biClrUsed         = 0;
        pbmi7->bmiHeader.biClrImportant    = 0;


        for (ux=0;ux<256;ux++)
        {
            pbmi7->bmiColors[ux] = *(RGBQUAD *)&i;
            i++;
            if (i>20) {
                i=0;
            }
        }

        //
        // create dib, select them in
        //
        hdc1 = CreateCompatibleDC (hdc);
        hdib1 = CreateDIBSection(hdc1,pbmi,DIB_RGB_COLORS,(PVOID *)&pDib,NULL,0);
        SelectObject (hdc1,hdib1);

        hdc2 = CreateCompatibleDC (hdc);
        hdib2 = CreateDIBSection(hdc2,pbmi2,DIB_RGB_COLORS,(PVOID *)&pDib2,NULL,0);
        SelectObject (hdc2,hdib2);

        hdc3 = CreateCompatibleDC (hdc);
        hdib3 = CreateDIBSection(hdc3,pbmi3,DIB_RGB_COLORS,(PVOID *)&pDib3,NULL,0);
        SelectObject (hdc3,hdib3);

        hdc4 = CreateCompatibleDC (hdc);
        hdib4 = CreateDIBSection(hdc4,pbmi4,DIB_RGB_COLORS,(PVOID *)&pDib4,NULL,0);
        SelectObject (hdc4,hdib4);

        hdc5 = CreateCompatibleDC (hdc);
        hdib5 = CreateDIBSection(hdc5,pbmi5,DIB_RGB_COLORS,(PVOID *)&pDib5,NULL,0);
        SelectObject (hdc5,hdib5);

        hdc6 = CreateCompatibleDC (hdc);
        hdib6 = CreateDIBSection(hdc5,pbmi6,DIB_RGB_COLORS,(PVOID *)&pDib6,NULL,0);
        SelectObject (hdc6,hdib6);

        // DIB_PAL_COLORS for 4,8bpp
        hdc7 = CreateCompatibleDC (hdc);
        hdib7 = CreateDIBSection(hdc7,pbmi7,DIB_PAL_COLORS,(PVOID *)&pDib7,NULL,0);
        SelectObject (hdc7,hdib7);

        //
        // init 32 bpp dib 1
        //

        ptmp = pDib;

        for (uy=0;uy<128;uy++)
        {
            for (ux=0;ux<128;ux++)
            {
                *ptmp++ = (ux*2) + ((uy*2) << 8);
            }
        }

        ptmp = (PULONG)pDib + 32 * 128;

        for (uy=0;uy<10;uy++)
        {
            for (ux=0;ux<128;ux++)
            {
                *ptmp++ = 0xff0000;
            }
        }

        //
        // init 24bpp DIB
        //

        {
            PBYTE p24;
            ULONG stride = 3*128;

            //
            // init 32 bpp dib 1
            //

            p24 = (PBYTE)pDib2;

            for (uy=0;uy<128;uy++)
            {
                p24 = (PBYTE)pDib2 + stride * uy;

                for (ux=0;ux<128;ux++)
                {
                    *p24++ = (BYTE)(ux + uy);
                    *p24++ = (BYTE)(ux + uy);
                    *p24++ = (BYTE)(ux + uy);
                }
            }


            p24 = (PBYTE)pDib2 + stride * 32;
            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *p24++ = 0x00;
                    *p24++ = 0x00;
                    *p24++ = 0xff;
                }
            }
        }

        //
        // init 16 bit DIB
        //
        {
            PSHORT p16 = (PSHORT)pDib3;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *p16++ =(SHORT)(ux + uy);
                }
            }

            p16 = (PSHORT)((PBYTE)pDib3 + 32 * (128 *2));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *p16++ = 0x7c00;
                }
            }
        }

        //
        // init 8bpp DIB
        //
        {
            PBYTE  pt8;
            pt8 = (PBYTE)pDib4;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = (BYTE)(ux + uy/2);
                }
            }

            pt8 = (PBYTE)pDib4 + 32 * 128;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = 255;
                }
            }
        }

        //
        // init 4bpp DIB
        //
        {
            PBYTE  pt4;
            pt4 = (PBYTE)pDib5;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<64;ux++)
                {
                    *pt4++ = (BYTE)(ux + uy);
                }
            }

            pt4 = (PBYTE)pDib5 + 32 * 64;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<64;ux++)
                {
                    *pt4++ = 0xcc;
                }
            }
        }


        //
        // init 1bpp DIB
        //
        {
            PBYTE  pt1;
            pt1 = (PBYTE)pDib6;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<16;ux++)
                {
                    *pt1++ = 0x0;
                }
            }


            pt1 = (PBYTE)pDib6 + 32 * 16;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<16;ux++)
                {
                    *pt1++ = 0xFF;
                }
            }
        }

        //
        // init 8bpp DIB_PAL_COLORS DIB
        //
        {
            PBYTE  pt8;
            pt8 = (PBYTE)pDib7;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = (BYTE)ux;
                }
            }

            pt8 = (PBYTE)pDib7 + 32 * 128;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = 32;
                }
            }
        }

        // clear screen
        SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
        PatBlt(hdc,0,0,2000,2000,PATCOPY);

        for (i=-32; i<32; i++)
        {
            TransparentBlt(hdc,xpos+i+10 ,ypos,i,i,hdc4, i,0,i,i,PALETTERGB(255,0,0));
            TransparentBlt(hdc,xpos2+i+10,ypos,i,i,hdc5, i,0,i,i,PALETTERGB(255,0,0));
            TransparentBlt(hdc,xpos3+i+10,ypos,i,i,hdc7, i,0,i,i,PALETTERGB(0,0,255));
        }


        ypos += dy;

        for (i=-32; i<32; i++)
        {
           TransparentBlt(hdc,xpos+i ,ypos,128+i,128+i,hdc4, i,0,128+i,128+i, RGB(255,0,0));
           TransparentBlt(hdc,xpos2+i,ypos,128+i,128+i,hdc5, i,0,128+i,128+i, RGB(255,0,0));
           TransparentBlt(hdc,xpos3+i,ypos,128+i,128+i,hdc7, i,0,128+i,128+i, RGB(0,0,255));
        }

        ypos += dy;

        for (i=-32; i<32; i++)
        {
           HRGN hrgn1 = CreateEllipticRgn(xpos+10 ,ypos+10,xpos+128-10 ,ypos+128-10);
           HRGN hrgn2 = CreateEllipticRgn(xpos2+10,ypos+10,xpos2+128-10,ypos+128-10);
           HRGN hrgn3 = CreateEllipticRgn(xpos3+10,ypos+10,xpos3+128-10,ypos+128-10);
           HRGN hrgn4 = CreateEllipticRgn(xpos4+10,ypos+10,xpos4+128-10,ypos+128-10);
           HRGN hrgn5 = CreateEllipticRgn(xpos5+10,ypos+10,xpos5+128-10,ypos+128-10);
           HRGN hrgn6 = CreateEllipticRgn(xpos6+10,ypos+10,xpos6+128-10,ypos+128-10);

           ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);
           TransparentBlt(hdc,xpos+i ,ypos,128,128,hdc4, i,0,128,128,PALETTERGB(255,0,0));

           ExtSelectClipRgn(hdc,hrgn2,RGN_COPY);
           TransparentBlt(hdc,xpos2+i,ypos,128,128,hdc5, i,0,128,128,PALETTERGB(255,0,0));

           ExtSelectClipRgn(hdc,hrgn3,RGN_COPY);
           TransparentBlt(hdc,xpos3+i,ypos,128,128,hdc7, i,0,128,128,PALETTERGB(0,0,255));

           ExtSelectClipRgn(hdc,NULL,RGN_COPY);

           DeleteObject (hrgn1);
           DeleteObject (hrgn2);
           DeleteObject (hrgn3);
           DeleteObject (hrgn4);
           DeleteObject (hrgn5);
           DeleteObject (hrgn6);
        }

        DeleteDC (hdc1);
        DeleteDC (hdc2);
        DeleteDC (hdc3);
        DeleteDC (hdc4);
        DeleteDC (hdc5);
        DeleteDC (hdc6);
        DeleteDC (hdc7);

        LocalFree(pbmi);
        LocalFree(pbmi2);
        LocalFree(pbmi3);
        LocalFree(pbmi4);
        LocalFree(pbmi5);
        LocalFree(pbmi6);
        LocalFree(pbmi7);

        DeleteObject (hdib1);
        DeleteObject (hdib2);
        DeleteObject (hdib3);
        DeleteObject (hdib4);
        DeleteObject (hdib5);
        DeleteObject (hdib6);
        DeleteObject (hdib7);
    }
    ReleaseDC(pCallData->hwnd,hdc);
}

VOID
vTest4(
    TEST_CALL_DATA *pCallData
    )
{
    HDC hdc     = GetDCAndTransform(pCallData->hwnd);
    RGBQUAD palentry[16] =
{
    { 0,   0,   0,   0 },
    { 0x80,0,   0,   0 },
    { 0,   0x80,0,   0 },
    { 0x80,0x80,0,   0 },
    { 0,   0,   0x80,0 },
    { 0x80,0,   0x80,0 },
    { 0,   0x80,0x80,0 },
    { 0x80,0x80,0x80,0 },

    { 0xC0,0xC0,0xC0,0 },
    { 0xFF,0,   0,   0 },
    { 0,   0xFF,0,   0 },
    { 0xFF,0xFF,0,   0 },
    { 0,   0,   0xFF,0 },
    { 0xFF,0,   0xFF,0 },
    { 0,   0xFF,0xFF,0 },
    { 0xFF,0xFF,0xFF,0 }
};


    //
    //  create a DIBSection to test transparent drawing
    //
    {
        PBITMAPINFO pbmi, pbmi2,pbmi3,pbmi4,pbmi5,pbmi6,pbmi7,pbmi8;
        ULONG ux,uy;
        PULONG pDib,pDib2,pDib3,pDib4, pDib5, pDib6,pDib7,pDib8;
        HDC hdc1, hdc2, hdc3, hdc4, hdc5, hdc6, hdc7, hdc8;
        HBITMAP hdib1,hdib2,hdib3,hdib4, hdib5, hdib6, hdib7, hdib8;
        PULONG ptmp;
        int i=0;

        ULONG xpos  = 0;
        ULONG xpos2 = 200;
        ULONG xpos3 = 400;
        ULONG xpos4 = 600;
        ULONG xpos5 = 800;
        ULONG xpos6 = 1000;
        ULONG ypos  = 32;
        ULONG dy    = 164;
        ULONG dx    = 164;


        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib = (PULONG)LocalAlloc(0,4*128*128);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = -128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        pbmi2 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib2 = (PULONG)LocalAlloc(0,3*128*128);


        pbmi2->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi2->bmiHeader.biWidth           = 128;
        pbmi2->bmiHeader.biHeight          = -128;
        pbmi2->bmiHeader.biPlanes          = 1;
        pbmi2->bmiHeader.biBitCount        = 24;
        pbmi2->bmiHeader.biCompression     = BI_RGB;
        pbmi2->bmiHeader.biSizeImage       = 0;
        pbmi2->bmiHeader.biXPelsPerMeter   = 0;
        pbmi2->bmiHeader.biYPelsPerMeter   = 0;
        pbmi2->bmiHeader.biClrUsed         = 0;
        pbmi2->bmiHeader.biClrImportant    = 0;

        pbmi3 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib3 = (PULONG)LocalAlloc(0,2*128*128);

        pbmi3->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi3->bmiHeader.biWidth           = 128;
        pbmi3->bmiHeader.biHeight          = -128;
        pbmi3->bmiHeader.biPlanes          = 1;
        pbmi3->bmiHeader.biBitCount        = 16;
        pbmi3->bmiHeader.biCompression     = BI_RGB;
        pbmi3->bmiHeader.biSizeImage       = 0;
        pbmi3->bmiHeader.biXPelsPerMeter   = 0;
        pbmi3->bmiHeader.biYPelsPerMeter   = 0;
        pbmi3->bmiHeader.biClrUsed         = 0;
        pbmi3->bmiHeader.biClrImportant    = 0;

        pbmi4 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib4 = (PULONG)LocalAlloc(0,128*128);

        pbmi4->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi4->bmiHeader.biWidth           = 128;
        pbmi4->bmiHeader.biHeight          = -128;
        pbmi4->bmiHeader.biPlanes          = 1;
        pbmi4->bmiHeader.biBitCount        = 8;
        pbmi4->bmiHeader.biCompression     = BI_RGB;
        pbmi4->bmiHeader.biSizeImage       = 0;
        pbmi4->bmiHeader.biXPelsPerMeter   = 0;
        pbmi4->bmiHeader.biYPelsPerMeter   = 0;
        pbmi4->bmiHeader.biClrUsed         = 0;
        pbmi4->bmiHeader.biClrImportant    = 0;

        for (ux=0;ux<256;ux++)
        {
            pbmi4->bmiColors[ux].rgbRed       = (BYTE)ux;
            pbmi4->bmiColors[ux].rgbGreen     = 0;
            pbmi4->bmiColors[ux].rgbBlue      = (BYTE)ux;
#if 0
            pbmi4->bmiColors[ux].rgbRed       = (BYTE)(ux & 7) << 5;
            pbmi4->bmiColors[ux].rgbGreen     = (BYTE)((ux >> 3) & 7) << 5;
            pbmi4->bmiColors[ux].rgbBlue      = (BYTE)((ux >> 6) << 6);
#endif
            pbmi4->bmiColors[ux].rgbReserved  = 0;
        }

        //
        // tran color
        //

        pbmi4->bmiColors[255].rgbRed       = 255;
        pbmi4->bmiColors[255].rgbGreen     = 0;
        pbmi4->bmiColors[255].rgbBlue      = 0;
        pbmi4->bmiColors[255].rgbReserved  = 0;


        pbmi5 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib5 = (PULONG)LocalAlloc(0,128*64);

        pbmi5->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi5->bmiHeader.biWidth           = 128;
        pbmi5->bmiHeader.biHeight          = -128;
        pbmi5->bmiHeader.biPlanes          = 1;
        pbmi5->bmiHeader.biBitCount        = 4;
        pbmi5->bmiHeader.biCompression     = BI_RGB;
        pbmi5->bmiHeader.biSizeImage       = 0;
        pbmi5->bmiHeader.biXPelsPerMeter   = 0;
        pbmi5->bmiHeader.biYPelsPerMeter   = 0;
        pbmi5->bmiHeader.biClrUsed         = 0;
        pbmi5->bmiHeader.biClrImportant    = 0;

        memcpy (pbmi5->bmiColors, palentry, sizeof(RGBQUAD)*16);

        pbmi6 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib6 = (PULONG)LocalAlloc(0,128*16);

        pbmi6->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi6->bmiHeader.biWidth           = 128;
        pbmi6->bmiHeader.biHeight          = -128;
        pbmi6->bmiHeader.biPlanes          = 1;
        pbmi6->bmiHeader.biBitCount        = 1;
        pbmi6->bmiHeader.biCompression     = BI_RGB;
        pbmi6->bmiHeader.biSizeImage       = 0;
        pbmi6->bmiHeader.biXPelsPerMeter   = 0;
        pbmi6->bmiHeader.biYPelsPerMeter   = 0;
        pbmi6->bmiHeader.biClrUsed         = 0;
        pbmi6->bmiHeader.biClrImportant    = 0;

        pbmi6->bmiColors[0].rgbRed = 0;
        pbmi6->bmiColors[0].rgbGreen = 0xFF;
        pbmi6->bmiColors[0].rgbBlue = 0;
        pbmi6->bmiColors[0].rgbReserved = 0;

        pbmi6->bmiColors[1].rgbRed = 0xFF;
        pbmi6->bmiColors[1].rgbGreen = 0x0;
        pbmi6->bmiColors[1].rgbBlue = 0x0;
        pbmi6->bmiColors[1].rgbReserved = 0;

        // DIB_PAL_COLORS
        pbmi7 = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib7 = (PULONG)LocalAlloc(0,128*128);

        pbmi7->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi7->bmiHeader.biWidth           = 128;
        pbmi7->bmiHeader.biHeight          = -128;
        pbmi7->bmiHeader.biPlanes          = 1;
        pbmi7->bmiHeader.biBitCount        = 8;
        pbmi7->bmiHeader.biCompression     = BI_RGB;
        pbmi7->bmiHeader.biSizeImage       = 0;
        pbmi7->bmiHeader.biXPelsPerMeter   = 0;
        pbmi7->bmiHeader.biYPelsPerMeter   = 0;
        pbmi7->bmiHeader.biClrUsed         = 0;
        pbmi7->bmiHeader.biClrImportant    = 0;


        for (ux=0;ux<256;ux++)
        {
            pbmi7->bmiColors[ux] = *(RGBQUAD *)&i;
            i++;
            if (i>20) {
                i=0;
            }
        }

        //
        // create dib, select them in
        //
        hdc1 = CreateCompatibleDC (hdc);
        hdib1 = CreateDIBSection(hdc1,pbmi,DIB_RGB_COLORS,(PVOID *)&pDib,NULL,0);
        SelectObject (hdc1,hdib1);

        hdc2 = CreateCompatibleDC (hdc);
        hdib2 = CreateDIBSection(hdc2,pbmi2,DIB_RGB_COLORS,(PVOID *)&pDib2,NULL,0);
        SelectObject (hdc2,hdib2);

        hdc3 = CreateCompatibleDC (hdc);
        hdib3 = CreateDIBSection(hdc3,pbmi3,DIB_RGB_COLORS,(PVOID *)&pDib3,NULL,0);
        SelectObject (hdc3,hdib3);

        hdc4 = CreateCompatibleDC (hdc);
        hdib4 = CreateDIBSection(hdc4,pbmi4,DIB_RGB_COLORS,(PVOID *)&pDib4,NULL,0);
        SelectObject (hdc4,hdib4);

        hdc5 = CreateCompatibleDC (hdc);
        hdib5 = CreateDIBSection(hdc5,pbmi5,DIB_RGB_COLORS,(PVOID *)&pDib5,NULL,0);
        SelectObject (hdc5,hdib5);

        hdc6 = CreateCompatibleDC (hdc);
        hdib6 = CreateDIBSection(hdc5,pbmi6,DIB_RGB_COLORS,(PVOID *)&pDib6,NULL,0);
        SelectObject (hdc6,hdib6);

        // DIB_PAL_COLORS for 4,8bpp
        hdc7 = CreateCompatibleDC (hdc);
        hdib7 = CreateDIBSection(hdc7,pbmi7,DIB_PAL_COLORS,(PVOID *)&pDib7,NULL,0);
        SelectObject (hdc7,hdib7);

        //
        // init 32 bpp dib 1
        //

        ptmp = pDib;

        for (uy=0;uy<128;uy++)
        {
            for (ux=0;ux<128;ux++)
            {
                *ptmp++ = (ux*2) + ((uy*2) << 8);
            }
        }

        ptmp = (PULONG)pDib + 32 * 128;

        for (uy=0;uy<10;uy++)
        {
            for (ux=0;ux<128;ux++)
            {
                *ptmp++ = 0xff0000;
            }
        }

        //
        // init 24bpp DIB
        //

        {
            PBYTE p24;
            ULONG stride = 3*128;

            //
            // init 32 bpp dib 1
            //

            p24 = (PBYTE)pDib2;

            for (uy=0;uy<128;uy++)
            {
                p24 = (PBYTE)pDib2 + stride * uy;

                for (ux=0;ux<128;ux++)
                {
                    *p24++ = (BYTE)(ux + uy);
                    *p24++ = (BYTE)(ux + uy);
                    *p24++ = (BYTE)(ux + uy);
                }
            }


            p24 = (PBYTE)pDib2 + stride * 32;
            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *p24++ = 0x00;
                    *p24++ = 0x00;
                    *p24++ = 0xff;
                }
            }
        }

        //
        // init 16 bit DIB
        //
        {
            PSHORT p16 = (PSHORT)pDib3;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *p16++ =(SHORT)(ux + uy);
                }
            }

            p16 = (PSHORT)((PBYTE)pDib3 + 32 * (128 *2));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *p16++ = 0x7c00;
                }
            }
        }

        //
        // init 8bpp DIB
        //
        {
            PBYTE  pt8;
            pt8 = (PBYTE)pDib4;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = (BYTE)(ux + uy/2);
                }
            }

            pt8 = (PBYTE)pDib4 + 32 * 128;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = 255;
                }
            }
        }

        //
        // init 4bpp DIB
        //
        {
            PBYTE  pt4;
            pt4 = (PBYTE)pDib5;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<64;ux++)
                {
                    *pt4++ = (BYTE)(ux + uy);
                }
            }

            pt4 = (PBYTE)pDib5 + 32 * 64;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<64;ux++)
                {
                    *pt4++ = 0xcc;
                }
            }
        }


        //
        // init 1bpp DIB
        //
        {
            PBYTE  pt1;
            pt1 = (PBYTE)pDib6;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<16;ux++)
                {
                    *pt1++ = 0x0;
                }
            }


            pt1 = (PBYTE)pDib6 + 32 * 16;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<16;ux++)
                {
                    *pt1++ = 0xFF;
                }
            }
        }

        //
        // init 8bpp DIB_PAL_COLORS DIB
        //
        {
            PBYTE  pt8;
            pt8 = (PBYTE)pDib7;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = (BYTE)ux;
                }
            }

            pt8 = (PBYTE)pDib7 + 32 * 128;

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *pt8++ = 32;
                }
            }
        }

        //
        // display
        //
        for (i=1; i<=32; i++)
        {
           TransparentDIBits(hdc,xpos+i ,ypos,i,i,pDib4,pbmi4,DIB_RGB_COLORS,i,i,i,i,PALETTEINDEX(255));
           TransparentDIBits(hdc,xpos2+i ,ypos,i,i,pDib5,pbmi5,DIB_RGB_COLORS,i,i,i,i,PALETTEINDEX(12));
           TransparentDIBits(hdc,xpos3+i ,ypos,i,i,pDib7,pbmi7,DIB_PAL_COLORS,i,i,i,i,32);
        }
        //SetDIBitsToDevice (hdc, xpos4, ypos, 128, 128, 0, 0, 0, 128, pDib7, pbmi7, DIB_PAL_COLORS);

        ypos += dy;

        for (i=0; i<32; i++)
        {
           TransparentDIBits(hdc,xpos+i ,ypos,128+i,128+i,pDib4,pbmi4,DIB_RGB_COLORS,i,0,128+i,128+i,PALETTEINDEX(255));
           TransparentDIBits(hdc,xpos2+i ,ypos,128+i,128+i,pDib5,pbmi5,DIB_RGB_COLORS,i,0,128+i,128+i,PALETTEINDEX(12));
           TransparentDIBits(hdc,xpos3+i ,ypos,128+i,128+i,pDib7,pbmi7,DIB_PAL_COLORS,i,0,128+i,128+i,32);
        }

        ypos += dy;

        for (i=0; i<32; i++)
        {
           HRGN hrgn1 = CreateEllipticRgn(xpos+10 ,ypos+10,xpos+128-10 ,ypos+128-10);
           HRGN hrgn2 = CreateEllipticRgn(xpos2+10,ypos+10,xpos2+128-10,ypos+128-10);
           HRGN hrgn3 = CreateEllipticRgn(xpos3+10,ypos+10,xpos3+128-10,ypos+128-10);
           HRGN hrgn4 = CreateEllipticRgn(xpos4+10,ypos+10,xpos4+128-10,ypos+128-10);
           HRGN hrgn5 = CreateEllipticRgn(xpos5+10,ypos+10,xpos5+128-10,ypos+128-10);
           HRGN hrgn6 = CreateEllipticRgn(xpos6+10,ypos+10,xpos6+128-10,ypos+128-10);

           ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);
           TransparentBlt(hdc,xpos+i,ypos,128+i,128,hdc4, 0,0,128+i,128,PALETTERGB(255,0,0));

           ExtSelectClipRgn(hdc,hrgn2,RGN_COPY);
           TransparentBlt(hdc,xpos2+i,ypos,128+i,128,hdc5, 0,0,128+i,128,PALETTERGB(255,0,0));

           ExtSelectClipRgn(hdc,hrgn3,RGN_COPY);
           TransparentBlt(hdc,xpos3+i,ypos,128+i,128,hdc7, 0,0,128+i,128,PALETTERGB(0,0,255));

           //ExtSelectClipRgn(hdc,hrgn3,RGN_COPY);
           //TransparentBlt(hdc,xpos3,ypos,128,128,hdc3, 0,0,128,128,PALETTERGB(255,0,0),0);

           //ExtSelectClipRgn(hdc,hrgn4,RGN_COPY);
           //TransparentBlt(hdc,xpos4,ypos,128,128,hdc4, 0,0,128,128,PALETTERGB(255,0,0),0);

           //ExtSelectClipRgn(hdc,hrgn5,RGN_COPY);
           //TransparentBlt(hdc,xpos5,ypos,128,128,hdc5, 0,0,128,128,PALETTERGB(255,0,0),0);

           ExtSelectClipRgn(hdc,hrgn6,RGN_COPY);
           //TransparentBlt(hdc,xpos6,ypos,128,128,hdc6, 0,0,128,128,PALETTERGB(255,0,0),0);

           ExtSelectClipRgn(hdc,NULL,RGN_COPY);

           DeleteObject (hrgn1);
           DeleteObject (hrgn2);
           DeleteObject (hrgn3);
           DeleteObject (hrgn4);
           DeleteObject (hrgn5);
           DeleteObject (hrgn6);

        }

        DeleteDC (hdc1);
        DeleteDC (hdc2);
        DeleteDC (hdc3);
        DeleteDC (hdc4);
        DeleteDC (hdc5);
        DeleteDC (hdc6);
        DeleteDC (hdc7);
        DeleteDC (hdc8);

        LocalFree(pbmi);
        LocalFree(pbmi2);
        LocalFree(pbmi3);
        LocalFree(pbmi4);
        LocalFree(pbmi5);
        LocalFree(pbmi6);
        LocalFree(pbmi7);

        DeleteObject (hdib1);
        DeleteObject (hdib2);
        DeleteObject (hdib3);
        DeleteObject (hdib4);
        DeleteObject (hdib5);
        DeleteObject (hdib6);
        DeleteObject (hdib7);
    }
    ReleaseDC(pCallData->hwnd,hdc);
}

VOID
vTest5(
    TEST_CALL_DATA *pCallData
    )
{
    DWORD dwStart, dwStop;
    DWORD dwElapsed;
    HDC hdc     = GetDCAndTransform(pCallData->hwnd);
    int i, j;

    CHAR msg[256];

    //
    //  create a DIBSection to test 32 bpp transparent drawing
    //  beginning at different pos with different length

    {
        PBITMAPINFO pbmi, pbmi2,pbmi3,pbmi4;
        ULONG ux,uy;
        PULONG pDib,pDib2,pDib3,pDib4;
        PULONG ptmp;

        ULONG xpos  = 0;
        ULONG xpos2 = 200;
        ULONG xpos3 = 400;
        ULONG xpos4 = 600;
        ULONG ypos  = 32;
        ULONG dy    = 164;
        ULONG dx    = 164;

        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
        pDib = (PULONG)LocalAlloc(0,4*128*128);

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = -128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;


        //
        // init 32 bpp dib 1
        //

        ptmp = pDib;

        for (uy=0;uy<128;uy++)
        {
            for (ux=0;ux<128;ux++)
            {
                *ptmp++ = (ux*2) + ((uy*2) << 8);
            }
        }

        ptmp = (PULONG)((PBYTE)pDib + 32 * (128 *4));

        for (uy=32;uy<42;uy++)
        {
            for (ux=0;ux<128;ux++)
            {
                *ptmp++ = 0xff0000;
            }
        }

        //
        // display
        //
        SetBkColor(hdc,PALETTERGB(255,0,0));

        xpos = 0; ypos = 0;

        dwStart = GetTickCount();

        for (j = 1; j <10; j++)
        {
           for (i = 1; i < 100; i++)
           {
              #if 0
              TransparentDIBits(hdc, xpos+i*10,ypos,128+i,128+i,pDib, pbmi,
                                  DIB_RGB_COLORS, i,i,128-i,128-i,PALETTERGB(255,0,0),0);
              #endif
           }
        }

        dwStop = GetTickCount ();

        wsprintf(msg, "Average call time : %x", (dwStop-dwStart)/1000);
        TextOut(hdc,10,10,msg,strlen(msg));


        LocalFree(pbmi);
    }

    ReleaseDC(pCallData->hwnd,hdc);
}


/******************************Public*Routine******************************\
* vPlayMetaFileTran
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/13/1997 Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID
vPlayMetaFileTran(
    TEST_CALL_DATA *pCallData
    )
{

    HDC  hdc     = GetDCAndTransform(pCallData->hwnd);
    HDC  hdcm;
    RECT rcl;
    ULONG ypos = 0;
    ULONG xpos = 0;
    LPCTSTR lpFilename = "MetaTran.EMF";
    LPCTSTR lpDescription = "Transparent test metafile";
    HENHMETAFILE hemf;

    GetClientRect(pCallData->hwnd,&rcl);
    FillTransformedRect(hdc,&rcl,(HBRUSH)GetStockObject(GRAY_BRUSH));

    SetTextColor(hdc,0);
    SetBkMode(hdc,TRANSPARENT);

    rcl.left   = 0;
    rcl.top    = 0;
    rcl.right  = 184;
    rcl.bottom = 170;


    hemf = GetEnhMetaFile(lpFilename);
    if (hemf)
    {
        PlayEnhMetaFile(hdc,hemf,&rcl);
    }


    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}




/******************************Public*Routine******************************\
* vCreateMetaFileTranBlt
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/7/1996 Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID
vCreateMetaFileTranBlt(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc = GetDCAndTransform(pCallData->hwnd);
    HDC     hdcSrc;
    HDC     hdcm;
    RECT    rcl;
    ULONG   ypos = 0;
    ULONG   xpos = 0;
    LPCTSTR lpFilename = "MetaTran.EMF";
    LPCTSTR lpDescription = "Transparent test metafile";
    HBITMAP hbm;

    GetClientRect(pCallData->hwnd,&rcl);
    FillTransformedRect(hdc,&rcl,(HBRUSH)GetStockObject(GRAY_BRUSH));

    rcl.right =  (184 *  (GetDeviceCaps(hdc, HORZSIZE) * 100)) / GetDeviceCaps(hdc, HORZRES);
    rcl.bottom = (170 * (GetDeviceCaps(hdc, VERTSIZE) * 100)) / GetDeviceCaps(hdc, VERTRES);

    rcl.left =0;
    rcl.top = 0;

    SetTextColor(hdc,0);
    SetBkMode(hdc,TRANSPARENT);

    //
    // Create metafile DC
    //

    hdcm = CreateEnhMetaFile(hdc,lpFilename,&rcl,lpDescription);

    if (hdcm != NULL)
    {
        hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

        hdcSrc = CreateCompatibleDC (hdc);

        SelectObject (hdcSrc, hbm);

        //BitBlt (hdcm, 0, 0, 184, 170, hdcSrc, 0, 0, SRCCOPY);

        TransparentBlt (hdcm, 0, 0, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));

        DeleteObject (hbm);
    }

    {
        HENHMETAFILE hemf = CloseEnhMetaFile(hdcm);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}


/******************************Public*Routine******************************\
* vTestMetaFileTranDIBits
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/7/1996 Lingyun Wang [lingyunw]
*
\**************************************************************************/

VOID
vTestMetaFileTranDIBits(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc = GetDCAndTransform(pCallData->hwnd);
    HDC     hdcm;
    RECT    rcl;
    ULONG   ux,uy;
    LPCTSTR lpFilename = "MetaTranDIB.EMF";
    LPCTSTR lpDescription = "TransparentDIB test metafile";
    HBITMAP hbm, hdib;
    PULONG  pDib;
    PBITMAPINFO pbmi;
    HENHMETAFILE  hemf;

    GetClientRect(pCallData->hwnd,&rcl);
    FillTransformedRect(hdc,&rcl,(HBRUSH)GetStockObject(GRAY_BRUSH));

    rcl.right =  (128 *  (GetDeviceCaps(hdc, HORZSIZE) * 100)) / GetDeviceCaps(hdc, HORZRES);
    rcl.bottom = (128 * (GetDeviceCaps(hdc, VERTSIZE) * 100)) / GetDeviceCaps(hdc, VERTRES);

    rcl.left =0;
    rcl.top = 0;

    SetTextColor(hdc,0);
    SetBkMode(hdc,TRANSPARENT);

     pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

     pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
     pbmi->bmiHeader.biWidth           = 128;
     pbmi->bmiHeader.biHeight          = 128;
     pbmi->bmiHeader.biPlanes          = 1;
     pbmi->bmiHeader.biBitCount        = 8;
     pbmi->bmiHeader.biCompression     = BI_RGB;
     pbmi->bmiHeader.biSizeImage       = 0;
     pbmi->bmiHeader.biXPelsPerMeter   = 0;
     pbmi->bmiHeader.biYPelsPerMeter   = 0;
     pbmi->bmiHeader.biClrUsed         = 0;
     pbmi->bmiHeader.biClrImportant    = 0;

     for (ux=0;ux<256;ux++)
     {
         pbmi->bmiColors[ux].rgbRed       = (BYTE)ux;
         pbmi->bmiColors[ux].rgbGreen     = 0;
         pbmi->bmiColors[ux].rgbBlue      = (BYTE)ux;
         pbmi->bmiColors[ux].rgbReserved  = 0;
     }

     //
     // tran color
     //
     pbmi->bmiColors[32].rgbRed       = 255;
     pbmi->bmiColors[32].rgbGreen     = 0;
     pbmi->bmiColors[32].rgbBlue      = 0;
     pbmi->bmiColors[32].rgbReserved  = 0;

     hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

     //
     // init 8bpp DIB
     //
     {
         PBYTE  pt8;
         pt8 = (PBYTE)pDib;

         for (uy=0;uy<128;uy++)
         {
             for (ux=0;ux<128;ux++)
             {
                 *pt8++ = (BYTE)(ux +uy);
             }
         }

         pt8 = (PBYTE)pDib + 32 * 128;

         for (uy=32;uy<42;uy++)
         {
             for (ux=0;ux<128;ux++)
             {
                 *pt8++ = 32;
             }
         }
     }

    //
    // Create metafile DC
    //
    hdcm = CreateEnhMetaFile(hdc,lpFilename,&rcl,lpDescription);

    if (hdcm != NULL)
    {
        //SetDIBitsToDevice (hdc, 0, 0, 128, 128, 0, 0, 0, 128, pDib, pbmi, DIB_RGB_COLORS);


        TransparentDIBits(hdcm, 0 ,0, 128, 128,pDib,pbmi,DIB_RGB_COLORS,0,0,128, 128,32);;

        DeleteObject (hbm);
    }

    {
        hemf = CloseEnhMetaFile(hdcm);
    }

    hemf = GetEnhMetaFile(lpFilename);

    if (hemf)
    {
        rcl.left   = 0;
        rcl.top    = 0;
        rcl.right  = 128;
        rcl.bottom = 128;

        PlayEnhMetaFile(hdc,hemf,&rcl);
    }

    LocalFree(pbmi);

    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}

//
// TEST_ENTRY controls automatic menu generation
//
// [Menu Level, Test Param, Stress Enable, Test Name, Test Function Pointer]
//
// Menu Level
//      used to autoamtically generate sub-menus.
//      1   = 1rst level menu
//      -n  = start n-level sub menu
//      n   = continue sub menu
//
// Test Param
//      passed as parameter to test
//
//
// Stress Ensable
//      if 1, test is run in stress mode
//      if 0, test is not run (tests that require input or runforever)
//
//
// Test Name
//      ascii test name for menu
//
// Test Function Pointer
//      pfn
//

TEST_ENTRY  gTestTranEntry[] = {
{1,  1,1,(PUCHAR)"vTestTranBltOffset      ", (PFN_DISP)vTestTranBltOffset},
{1,  1,1,(PUCHAR)"vTestTranBltStretch     ", (PFN_DISP)vTestTranBltStretch},
{1,  1,1,(PUCHAR)"vTestTranDIBOffset      ", (PFN_DISP)vTestTranDIBOffset},
{1,  1,1,(PUCHAR)"vTestTranDIBStretch     ", (PFN_DISP)vTestTranDIBStretch},
{1,  1,1,(PUCHAR)"vTestTransBlt           ", (PFN_DISP)vTest3},
{1,  1,1,(PUCHAR)"vTestTransDIB           ", (PFN_DISP)vTest4},
{1,  1,1,(PUCHAR)"vCreateMetaFileTranBlt  ", (PFN_DISP)vCreateMetaFileTranBlt},
{1,  1,1,(PUCHAR)"vTestMetaFileTranDIBits ", (PFN_DISP)vTestMetaFileTranDIBits},
{1,  1,1,(PUCHAR)"vPlayMetaFileTran       ", (PFN_DISP)vPlayMetaFileTran},
{0,  1,1,(PUCHAR)"                        ", (PFN_DISP)vTestDummy},
};

ULONG gNumTranTests = sizeof(gTestTranEntry)/sizeof(TEST_ENTRY);
ULONG gNumAutoTranTests = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\test.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   test.c

Abstract:

    Small, independent windows test programs

Author:

   Mark Enstrom   (marke)  29-Apr-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.h"
#include <stdlib.h>
#include "disp.h"
#include "resource.h"

extern ULONG  gAlphaSleep;

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTri(
    TEST_CALL_DATA *pCallData
    )
{
    HDC               hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE Tri[10];
    TRIVERTEX         vert[32];
    HPALETTE          hpal;
    RECT              rect;
    RECT              dibRect;
    HDC hdcm  =       CreateCompatibleDC(hdc);
    HDC hdcmA =       CreateCompatibleDC(hdc);
    PBITMAPINFO       pbmi;
    HBITMAP           hdib;
    HBITMAP           hdibA;
    PBYTE             pDib;
    PBYTE             pDibA;
    BLENDFUNCTION     BlendFunction;
    LONG              xpos    = 10;
    LONG              ypos    = 10;
    LONG              xposDib = 0;
    LONG              yposDib = 0;

    //
    // tile screen
    //

    {
        RECT rect;
        HBITMAP  hbmCars = LoadBitmap(hInstMain,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH lgBrush;
        HBRUSH   hbrFill;

        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (LONG)hbmCars;

        hbrFill = CreateBrushIndirect(&lgBrush);
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFill);

        DeleteObject(hbrFill);
        DeleteObject(hbmCars);
    }

    //
    // init drawing modes
    //

    SetStretchBltMode(hdc,COLORONCOLOR);

    BlendFunction.BlendOp             = AC_SRC_OVER;
    BlendFunction.BlendFlags               = 0;
    BlendFunction.SourceConstantAlpha = 255;
    BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
    
    SetGraphicsMode(hdc,GM_ADVANCED);

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    //
    // select and realize palette
    //

    hpal = CreateHtPalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi    = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 3 * sizeof(RGBQUAD));

    PBITMAPINFOHEADER pbmih   = &pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = rect.right;
    pbmih->biHeight          = 200;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 32;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    hdib   = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);
    hdibA  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

    if ((hdib == NULL) && (hdibA != NULL))
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }

        if (SelectObject(hdcmA,hdibA) == NULL)
        {
            MessageBox(NULL,"error selecting Alpha DIB","Error",MB_OK);
        }
    }

    vert[0].x     = xpos;
    vert[0].y     = ypos;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = xpos + 100;
    vert[1].y     = ypos;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x7000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = xpos + 100;
    vert[2].y     = ypos + 100;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x7000;
    vert[2].Blue  = 0x7000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = xpos;
    vert[3].y     = ypos;
    vert[3].Red   = 0xff00;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    vert[4].x     = xpos+100;
    vert[4].y     = ypos+100;
    vert[4].Red   = 0x0000;
    vert[4].Green = 0x7000;
    vert[4].Blue  = 0x7000;
    vert[4].Alpha = 0x0000;

    vert[5].x     = xpos;
    vert[5].y     = ypos+100;
    vert[5].Red   = 0x0000;
    vert[5].Green = 0x0000;
    vert[5].Blue  = 0x7000;
    vert[5].Alpha = 0x0000;

    Tri[0].Vertex1 = 0;
    Tri[0].Vertex2 = 1;
    Tri[0].Vertex3 = 2;

    Tri[1].Vertex1 = 3;
    Tri[1].Vertex2 = 4;
    Tri[1].Vertex3 = 5;

    xpos += 400;

    GradientFill(hdc,vert,6,(PVOID)Tri,2,GRADIENT_FILL_TRIANGLE);

    xposDib = 0;
    yposDib = 0;

    vert[0].x = xposDib;      vert[0].y = yposDib;
    vert[1].x = xposDib+100;  vert[1].y = yposDib;
    vert[2].x = xposDib+100;  vert[2].y = yposDib+100;
    vert[3].x = xposDib;      vert[3].y = yposDib;
    vert[4].x = xposDib+100;  vert[4].y = yposDib+100;
    vert[5].x = xposDib;      vert[5].y = yposDib+100;

    GradientFill(hdcm,vert,6,(PVOID)Tri,2,GRADIENT_FILL_TRIANGLE);
    StretchBlt(hdc,xpos,ypos,100,100,hdcm,0,0,100,100,SRCCOPY);

    //
    // add alpha
    //

    vert[0].Alpha = 0xff00;
    vert[1].Alpha = 0x7000;
    vert[2].Alpha = 0x7000;
    vert[3].Alpha = 0xff00;
    vert[4].Alpha = 0x7000;
    vert[5].Alpha = 0x7000;

    xpos += 110;

    GradientFill(hdcmA,vert,6,(PVOID)Tri,2,GRADIENT_FILL_TRIANGLE);
    AlphaBlend(hdc,xpos,ypos,100,100,hdcmA,0,0,100,100,BlendFunction);

    xpos = 10+50;
    ypos += (110 + 50);

    vert[0].x     = xpos;  //50,200
    vert[0].y     = ypos;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0xff00;

    vert[1].x     = xpos;
    vert[1].y     = ypos-50;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = xpos+50;
    vert[2].y     = ypos-25;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0xff00;

    vert[3].x     = xpos+50;
    vert[3].y     = ypos+25;
    vert[3].Red   = 0xff00;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0xff00;
    vert[3].Alpha = 0xff00;

    vert[4].x     = xpos;
    vert[4].y     = ypos+50;
    vert[4].Red   = 0x0000;
    vert[4].Green = 0x0000;
    vert[4].Blue  = 0xff00;
    vert[4].Alpha = 0xff00;

    vert[5].x     = xpos-50;
    vert[5].y     = ypos+25;
    vert[5].Red   = 0x0000;
    vert[5].Green = 0xff00;
    vert[5].Blue  = 0xff00;
    vert[5].Alpha = 0xff00;

    vert[6].x     = xpos-50;
    vert[6].y     = ypos-25;
    vert[6].Red   = 0x0000;
    vert[6].Green = 0xff00;
    vert[6].Blue  = 0x0000;
    vert[6].Alpha = 0xff00;

    Tri[0].Vertex1 = 0;
    Tri[0].Vertex2 = 1;
    Tri[0].Vertex3 = 2;

    Tri[1].Vertex1 = 0;
    Tri[1].Vertex2 = 2;
    Tri[1].Vertex3 = 3;

    Tri[2].Vertex1 = 0;
    Tri[2].Vertex2 = 3;
    Tri[2].Vertex3 = 4;

    Tri[3].Vertex1 = 0;
    Tri[3].Vertex2 = 4;
    Tri[3].Vertex3 = 5;

    Tri[4].Vertex1 = 0;
    Tri[4].Vertex2 = 5;
    Tri[4].Vertex3 = 6;

    Tri[5].Vertex1 = 0;
    Tri[5].Vertex2 = 6;
    Tri[5].Vertex3 = 1;

    GradientFill(hdc,vert,7,(PVOID)Tri,6,GRADIENT_FILL_TRIANGLE);

    vert[0].x += 110;
    vert[1].x += 110;
    vert[2].x += 110;
    vert[3].x += 110;
    vert[4].x += 110;
    vert[5].x += 110;
    vert[6].x += 110;

    Tri[0].Vertex1 = 1;
    Tri[0].Vertex2 = 2;
    Tri[0].Vertex3 = 0;

    Tri[1].Vertex1 = 2;
    Tri[1].Vertex2 = 3;
    Tri[1].Vertex3 = 0;

    Tri[2].Vertex1 = 3;
    Tri[2].Vertex2 = 4;
    Tri[2].Vertex3 = 0;

    Tri[3].Vertex1 = 4;
    Tri[3].Vertex2 = 5;
    Tri[3].Vertex3 = 0;

    Tri[4].Vertex1 = 5;
    Tri[4].Vertex2 = 6;
    Tri[4].Vertex3 = 0;

    Tri[5].Vertex1 = 6;
    Tri[5].Vertex2 = 1;
    Tri[5].Vertex3 = 0;

    GradientFill(hdc,vert,7,(PVOID)Tri,6,GRADIENT_FILL_TRIANGLE);

    vert[0].x += 110;
    vert[1].x += 110;
    vert[2].x += 110;
    vert[3].x += 110;
    vert[4].x += 110;
    vert[5].x += 110;
    vert[6].x += 110;

    Tri[0].Vertex1 = 2;
    Tri[0].Vertex2 = 1;
    Tri[0].Vertex3 = 0;

    Tri[1].Vertex1 = 3;
    Tri[1].Vertex2 = 2;
    Tri[1].Vertex3 = 0;

    Tri[2].Vertex1 = 4;
    Tri[2].Vertex2 = 3;
    Tri[2].Vertex3 = 0;

    Tri[3].Vertex1 = 5;
    Tri[3].Vertex2 = 4;
    Tri[3].Vertex3 = 0;

    Tri[4].Vertex1 = 6;
    Tri[4].Vertex2 = 5;
    Tri[4].Vertex3 = 0;

    Tri[5].Vertex1 = 1;
    Tri[5].Vertex2 = 6;
    Tri[5].Vertex3 = 0;

    GradientFill(hdc,vert,7,(PVOID)Tri,6,GRADIENT_FILL_TRIANGLE);

    vert[0].y     = 200 - 150;
    vert[1].y     = 150 - 150;
    vert[2].y     = 175 - 150;
    vert[3].y     = 225 - 150;
    vert[4].y     = 250 - 150;
    vert[5].y     = 225 - 150;
    vert[6].y     = 175 - 150;

    //
    // draw to DIB
    //

    xpos = 10;
    ypos += (110-50);

    xposDib = 50;
    yposDib = 50;

    vert[0].x     = xposDib;
    vert[0].y     = yposDib;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0xff00;

    vert[1].x     = xposDib;
    vert[1].y     = yposDib-50;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = xposDib+50;
    vert[2].y     = yposDib-25;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0xff00;

    vert[3].x     = xposDib+50;
    vert[3].y     = yposDib+25;
    vert[3].Red   = 0xff00;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0xff00;
    vert[3].Alpha = 0xff00;

    vert[4].x     = xposDib;
    vert[4].y     = yposDib+50;
    vert[4].Red   = 0x0000;
    vert[4].Green = 0x0000;
    vert[4].Blue  = 0xff00;
    vert[4].Alpha = 0xff00;

    vert[5].x     = xposDib-50;
    vert[5].y     = yposDib+25;
    vert[5].Red   = 0x0000;
    vert[5].Green = 0xff00;
    vert[5].Blue  = 0xff00;
    vert[5].Alpha = 0xff00;

    vert[6].x     = xposDib-50;
    vert[6].y     = yposDib-25;
    vert[6].Red   = 0x0000;
    vert[6].Green = 0xff00;
    vert[6].Blue  = 0x0000;
    vert[6].Alpha = 0xff00;

    BitBlt(hdcm,0,0,128,128,hdc,xpos,ypos,SRCCOPY);
    BitBlt(hdcmA,0,0,128,128,hdc,xpos,ypos,SRCCOPY);

    GradientFill(hdcm,vert,7,(PVOID)Tri,6,GRADIENT_FILL_TRIANGLE);

    //
    // add alpha
    //

    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0xff00;

    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].Red   = 0xc000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0xc000;

    vert[3].Red   = 0x8000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x8000;
    vert[3].Alpha = 0x8000;

    vert[4].Red   = 0x0000;
    vert[4].Green = 0x0000;
    vert[4].Blue  = 0xc000;
    vert[4].Alpha = 0xc000;

    vert[5].Red   = 0x0000;
    vert[5].Green = 0xf000;
    vert[5].Blue  = 0xf000;
    vert[5].Alpha = 0xf000;

    vert[6].Red   = 0x0000;
    vert[6].Green = 0x8000;
    vert[6].Blue  = 0x0000;
    vert[6].Alpha = 0x8000;

    PatBlt(hdcmA,0,0,2000,2000,0);

    GradientFill(hdcmA,vert,7,(PVOID)Tri,6,GRADIENT_FILL_TRIANGLE);

    StretchBlt(hdc,xpos,ypos,100,100,hdcm,0,0,100,100,SRCCOPY);

    xpos += 110;

    AlphaBlend(hdc,xpos,ypos,100,100,hdcmA,0,0,100,100,BlendFunction);
    BitBlt    (hdc,xpos+200,ypos,100,100,hdcmA,0,0,SRCCOPY);
    AlphaBlend(hdc,xpos+400,ypos,50,50,hdcmA,10,10,80,80,BlendFunction);

    xpos = 0;
    ypos += 110;

    vert[0].x     = xpos;
    vert[0].y     = ypos;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x1000;
    vert[0].Alpha = 0x2000;

    vert[1].x     = rect.right;
    vert[1].y     = ypos;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x8000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = rect.right;
    vert[2].y     = ypos+16;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x8000;
    vert[2].Alpha = 0xff00;

    vert[3].x     = xpos;
    vert[3].y     = ypos+16;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x1000;
    vert[3].Alpha = 0x2000;

    Tri[0].Vertex1  = 0;
    Tri[0].Vertex2  = 1;
    Tri[0].Vertex3  = 2;

    Tri[1].Vertex1  = 0;
    Tri[1].Vertex2  = 2;
    Tri[1].Vertex3  = 3;

    GradientFill(hdc,vert,4,(PVOID)Tri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].y     = 0;
    vert[1].y     = 0;
    vert[2].y     = 16;
    vert[3].y     = 16;

    FillTransformedRect(hdcm,&dibRect,(HBRUSH)GetStockObject(BLACK_BRUSH));
    FillTransformedRect(hdcmA,&dibRect,(HBRUSH)GetStockObject(BLACK_BRUSH));

    GradientFill(hdcm,vert,4,(PVOID)Tri,2,GRADIENT_FILL_TRIANGLE);
    GradientFill(hdcmA,vert,4,(PVOID)Tri,2,GRADIENT_FILL_TRIANGLE);

    ypos += 20;

    StretchBlt(hdc,xpos,ypos,rect.right,16,hdcm,0,0,rect.right,16,SRCCOPY);

    ypos += 20;

    AlphaBlend(hdc,xpos,ypos,rect.right,16,hdcmA,0,0,rect.right,16,BlendFunction);

    ypos += 20;

    //
    // rectangular clipped triangle
    //

    vert[0].x     = 300;
    vert[0].y     = ypos;
    vert[0].Red   = 0xc000;
    vert[0].Green = 0xc000;
    vert[0].Blue  = 0xc000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 4000;
    vert[1].y     = 3000;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = xpos;
    vert[2].y     = ypos+100;
    vert[2].Red   = 0x4000;
    vert[2].Green = 0x4000;
    vert[2].Blue  = 0x4000;
    vert[2].Alpha = 0x0000;

    Tri[0].Vertex1  = 0;
    Tri[0].Vertex2  = 1;
    Tri[0].Vertex3  = 2;

    GradientFill(hdc,vert,3,(PVOID)Tri,1,GRADIENT_FILL_TRIANGLE);

    ypos += 110;

    //
    // complex clipping
    //

    {
        HRGN hrgn1 = CreateEllipticRgn(xpos,ypos,xpos+100,ypos+100);

        ExtSelectClipRgn(hdc,hrgn1,RGN_COPY);

        vert[0].x     = 166;
        vert[0].y     = ypos;
        vert[0].Red   = 0xc000;
        vert[0].Green = 0x0000;
        vert[0].Blue  = 0x0000;
        vert[0].Alpha = 0x0000;

        vert[1].x     = 140;
        vert[1].y     = ypos+120;
        vert[1].Red   = 0x8000;
        vert[1].Green = 0x0000;
        vert[1].Blue  = 0x0000;
        vert[1].Alpha = 0x0000;

        vert[2].x     = 80;
        vert[2].y     = ypos+50;
        vert[2].Red   = 0x4000;
        vert[2].Green = 0x0000;
        vert[2].Blue  = 0x4000;
        vert[2].Alpha = 0x0000;

        Tri[0].Vertex1  = 0;
        Tri[0].Vertex2  = 1;
        Tri[0].Vertex3  = 2;

        GradientFill(hdc,vert,3,(PVOID)Tri,1,GRADIENT_FILL_TRIANGLE);


        ExtSelectClipRgn(hdc,NULL,RGN_COPY);

        DeleteObject(hrgn1);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    DeleteDC(hdcm);
    DeleteDC(hdcmA);
    DeleteObject(hdib);
    DeleteObject(hdibA);
    bThreadActive = FALSE;
}


/**************************************************************************\
* vRunGradMap
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    4/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vTestGradMap(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     msg[255];
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // grad fill and patblt rects with different map modes and origins
    //

    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 10;
    ULONG         dx    = 10;
    RECT          rect;

    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
    GRADIENT_RECT     gRect = {0,1};
    TRIVERTEX vert[6];

    //
    // fill screen background
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x4000;
    vert[0].Green = 0x8000;
    vert[0].Blue  = 0xc000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 80;
    vert[1].y     = 80;
    vert[1].Red   = 0xc000;
    vert[1].Green = 0x8000;
    vert[1].Blue  = 0x4000;
    vert[1].Alpha = 0x0000;

    //
    // MM_TEXT
    //

    LONG ux,uy;

    for (uy = -400; uy <= 400;uy += 100)
    {
        for (ux = -400; ux <= 400;ux += 100)
        {
            SetWindowOrgEx(hdc,ux,uy,NULL);
            GradientFill(hdc,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
            PatBlt(hdc,30,30,20,20,PATCOPY);
            wsprintf(msg,"%li,%li",ux,uy);
            TextOut(hdc,10,10,msg,strlen(msg));
        }
    }

    SetWindowOrgEx(hdc,0,0,NULL);

    Sleep(gAlphaSleep);

    //
    // isotropic stretch
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    SetMapMode(hdc,MM_ISOTROPIC);

    SetViewportExtEx(hdc,1000,1000,NULL);
    SetViewportOrgEx(hdc,0,0,NULL);
    SetWindowExtEx(hdc,2000,2000,NULL);
    SetWindowOrgEx(hdc,0,0,NULL);

    for (uy = -400; uy <= 400;uy += 100)
    {
        for (ux = -400; ux <= 400;ux += 100)
        {
            SetWindowOrgEx(hdc,ux,uy,NULL);
            GradientFill(hdc,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
            PatBlt(hdc,30,30,20,20,PATCOPY);
            wsprintf(msg,"%li,%li",ux,uy);
            TextOut(hdc,10,10,msg,strlen(msg));
        }
    }

    SetWindowOrgEx(hdc,0,0,NULL);
    SetMapMode(hdc,MM_TEXT);

    Sleep(gAlphaSleep);

    //
    // isotropic shrink
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    SetMapMode(hdc,MM_ISOTROPIC);
    SetViewportExtEx(hdc,1500,1500,NULL);
    SetViewportOrgEx(hdc,0,0,NULL);
    SetWindowExtEx(hdc,1000,1000,NULL);
    SetWindowOrgEx(hdc,0,0,NULL);

    for (uy = -400; uy <= 400;uy += 100)
    {
        for (ux = -400; ux <= 400;ux += 100)
        {
            SetWindowOrgEx(hdc,ux,uy,NULL);
            GradientFill(hdc,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
            PatBlt(hdc,30,30,20,20,PATCOPY);
            wsprintf(msg,"%li,%li",ux,uy);
            TextOut(hdc,10,10,msg,strlen(msg));
        }
    }

    SetWindowOrgEx(hdc,0,0,NULL);
    SetMapMode(hdc,MM_TEXT);

    Sleep(gAlphaSleep);

    //
    // anisotropic
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    SetMapMode(hdc,MM_ANISOTROPIC);
    SetViewportExtEx(hdc,2000,1000,NULL);
    SetViewportOrgEx(hdc,0,0,NULL);
    SetWindowExtEx(hdc,1000,2000,NULL);
    SetWindowOrgEx(hdc,0,0,NULL);

    for (uy = -400; uy <= 400;uy += 100)
    {
        for (ux = -400; ux <= 400;ux += 100)
        {
            SetWindowOrgEx(hdc,ux,uy,NULL);
            GradientFill(hdc,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
            PatBlt(hdc,30,30,20,20,PATCOPY);
            wsprintf(msg,"%li,%li",ux,uy);
            TextOut(hdc,10,10,msg,strlen(msg));
        }
    }

    SetWindowOrgEx(hdc,0,0,NULL);
    SetMapMode(hdc,MM_TEXT);

    //
    // free objects
    //

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestOverflow
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    4/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vTestOverflow(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     msg[255];
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // grad fill and patblt rects with different map modes and origins
    //

    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dx    = 120;
    ULONG         dy    = 20;
    RECT          rect;

    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(LTGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
    GRADIENT_RECT     gRect[]= {{0,1},{2,3},{4,5},{6,7}};
    TRIVERTEX         vert[6];

    vert[0].x     = xpos;
    vert[0].y     = ypos;
    vert[0].Red   = 0xa000;
    vert[0].Green = 0xc000;
    vert[0].Blue  = 0xc000;
    vert[0].Alpha = 0x0000;
    
    vert[1].x     = xpos+dx;
    vert[1].y     = ypos;
    vert[1].Red   = 0xc000;
    vert[1].Green = 0xc000;
    vert[1].Blue  = 0xc000;
    vert[1].Alpha = 0x0000;
    
    vert[2].x     = xpos+dx;
    vert[2].y     = ypos+dy;
    vert[2].Red   = 0xc000;
    vert[2].Green = 0xc000;
    vert[2].Blue  = 0xc000;
    vert[2].Alpha = 0x0000;
    
    vert[3].x     = xpos;   
    vert[3].y     = ypos+dy;
    vert[3].Red   = 0xa000;
    vert[3].Green = 0xc000;
    vert[3].Blue  = 0xc000;
    vert[3].Alpha = 0x0000;
    
    GradientFill(hdc,vert,4,&gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = xpos;
    vert[0].y     = ypos+dy;
    vert[0].Red   = 0x8000;
    vert[0].Green = 0x8000;
    vert[0].Blue  = 0x8000;
    vert[0].Alpha = 0x0000;
    
    vert[1].x     = xpos+dx+2;
    vert[1].y     = ypos+dy+2;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;
    
    GradientFill(hdc,vert,8,&gRect,1,GRADIENT_FILL_RECT_V);

    vert[0].x     = xpos+dx;
    vert[0].y     = ypos;
    vert[0].Red   = 0x8000;
    vert[0].Green = 0x8000;
    vert[0].Blue  = 0x8000;
    vert[0].Alpha = 0x0000;
    
    vert[1].x     = xpos+dx+2;
    vert[1].y     = ypos+dy;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = xpos;
    vert[2].y     = ypos;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0xff00;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0x0000;
    
    vert[3].x     = xpos+dx+1;
    vert[3].y     = ypos+1;
    vert[3].Red   = 0xff00;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0xff00;
    vert[3].Alpha = 0x0000;


    vert[4].x     = xpos;
    vert[4].y     = ypos;
    vert[4].Red   = 0xff00;
    vert[4].Green = 0xff00;
    vert[4].Blue  = 0xff00;
    vert[4].Alpha = 0x0000;
    
    vert[5].x     = xpos+1;
    vert[5].y     = ypos+dy+1;
    vert[5].Red   = 0xff00;
    vert[5].Green = 0xff00;
    vert[5].Blue  = 0xff00;
    vert[5].Alpha = 0x0000;

    GradientFill(hdc,vert,8,&gRect,3,GRADIENT_FILL_RECT_H);

    //
    // free objects
    //

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}


/**************************************************************************\
* vTestCircle1
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestCircle1(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);


    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
    GRADIENT_RECT     gRect = {0,1};
    TRIVERTEX         vert[6];

    POINT  pos     = {150,150};
    double fr      = 300.0;
    double fTheta  = 0.0;
    double fdTheta = 0.01;

    PatBlt(hdc,0,0,5000,5000,0);

    //
    // fade to back at 0,0
    //

    fTheta  = 0.0;  

    vert[0].x     = pos.x;
    vert[0].y     = pos.y;
    vert[0].Red   = 0x2000;
    vert[0].Green = 0xa000;
    vert[0].Blue  = 0xe000;
    vert[0].Alpha = 0x0000;

    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    fTheta  = 0;
    double fLimit = (2.0 * fdTheta) * 4.0;

    while (fTheta < (2.0 * 3.14159265))
    {
        vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
        vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 

        fTheta += fdTheta;

        vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
        vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 
        GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestCircle2
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestCircle2(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);
    RECT     rcl;
    GetClientRect(pCallData->hwnd,&rcl);

    //
    // repeat for each src format
    //

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
    GRADIENT_RECT     gRect = {0,1};
    TRIVERTEX         vert[6];

    POINT  pos     = {100,100};
    double fr      = 1000.0;
    double fTheta  = 0.0;
    double fdTheta = 0.001;

    PatBlt(hdc,0,0,5000,5000,0);

    //
    // solid color
    //

    fr      = 100.0;
    fTheta  = 0.0;  

    vert[0].x     = pos.x;
    vert[0].y     = pos.y;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].Red   = 0x0000;
    vert[1].Green = 0xcf00;
    vert[1].Blue  = 0xcf00;
    vert[1].Alpha = 0x0000;

    vert[2].Red   = 0x0000;
    vert[2].Green = 0xcf00;
    vert[2].Blue  = 0xcf00;
    vert[2].Alpha = 0x0000;

    while (fTheta < (2.0 * 3.14159265))
    {
        vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
        vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 

        vert[1].Red   = 0x8000 + (SHORT)((double)0x7f00 * cos(fTheta));
        vert[1].Green = 0x8000 + (SHORT)((double)0x7f00 * sin(fTheta)); 
        vert[1].Blue  = 0x8000 + (SHORT)((double)0x3f00 * cos(fTheta)) + (SHORT)((double)0x3f00 * sin(fTheta));  

        fTheta += fdTheta;

        vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
        vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 

        vert[2].Red   = 0x8000 + (SHORT)((double)0x7f00 * cos(fTheta));  
        vert[2].Green = 0x8000 + (SHORT)((double)0x7f00 * sin(fTheta));  
        vert[2].Blue  = 0x8000 + (SHORT)((double)0x3f00 * cos(fTheta)) + (SHORT)((double)0x3f00 * sin(fTheta));   

        GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
    }

    //
    // separate triangles
    //

    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0x0000;

    fr      = 500.0; 
    fTheta  = 0.0;   
    fdTheta = 0.02;  

    pos.x = rcl.right/2;
    pos.y = rcl.bottom/2;

    while (fTheta < (2.0 * 3.14159265))
    {
        vert[0].x     = (LONG)(pos.x + 20.0 * cos(fTheta));  
        vert[0].y     = (LONG)(pos.y + 20.0 * sin(fTheta));  

        vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
        vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 

        fTheta += fdTheta;

        vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
        vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 

        fTheta += fdTheta;

        GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestCircle3
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestCircle3(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);
    RECT     rcl;
    GetClientRect(pCallData->hwnd,&rcl);

    //
    // repeat for each src format
    //

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
    GRADIENT_RECT     gRect = {0,1};
    TRIVERTEX         vert[6];

    //double fr      = 65536.0;
    double fr      = 200.0;
    double fTheta  = 0.0;
    double fdTheta = 0.01;
    POINT pos = {0,0};


    //
    // separate triangles
    //

    vert[0].Red   = 0xcc00;
    vert[0].Green = 0x4400;
    vert[0].Blue  = 0x6600;
    vert[0].Alpha = 0x0000;

    vert[1].Red   = 0x6600;
    vert[1].Green = 0xcc00;
    vert[1].Blue  = 0x4400;
    vert[1].Alpha = 0x0000;

    vert[2].Red   = 0x4400;
    vert[2].Green = 0x6600;
    vert[2].Blue  = 0xcc00;
    vert[2].Alpha = 0x0000;

    do
    {
        PatBlt(hdc,0,0,5000,5000,0);

        pos.x = 0;
        pos.y = 0;
        fTheta = 0.0;

        while (fTheta < (2.0 * 3.14159265))
        {
            vert[0].x     = (LONG)(pos.x + 20.0 * cos(fTheta));  
            vert[0].y     = (LONG)(pos.y + 20.0 * sin(fTheta));  
    
            vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
        }
    
        Sleep(200);
        PatBlt(hdc,0,0,5000,5000,0);
    
        pos.x = rcl.right;
        pos.y = 0;
        fTheta = 0.0;
    
        while (fTheta < (2.0 * 3.14159265))
        {
            vert[0].x     = (LONG)(pos.x + 20.0 * cos(fTheta));  
            vert[0].y     = (LONG)(pos.y + 20.0 * sin(fTheta));  
    
            vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
        }
    
        Sleep(200);
        PatBlt(hdc,0,0,5000,5000,0);
    
        pos.x = rcl.right;
        pos.y = rcl.bottom;
        fTheta = 0.0;
    
        while (fTheta < (2.0 * 3.14159265))
        {
            vert[0].x     = (LONG)(pos.x + 20.0 * cos(fTheta));  
            vert[0].y     = (LONG)(pos.y + 20.0 * sin(fTheta));  
    
            vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
        }
    
        Sleep(200);
        PatBlt(hdc,0,0,5000,5000,0);
    
        pos.x = 0;
        pos.y = rcl.bottom;
        fTheta = 0.0;
    
        while (fTheta < (2.0 * 3.14159265))
        {
            vert[0].x     = (LONG)(pos.x + 20.0 * cos(fTheta));  
            vert[0].y     = (LONG)(pos.y + 20.0 * sin(fTheta));  
    
            vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
            vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 
    
            fTheta += fdTheta;
    
            GradientFill(hdc,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
        }
    
        Sleep(200);

        fr *= 2.0;

    } while (fr < 131072.0);

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestMenu
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    5/15/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestMenu(
    TEST_CALL_DATA *pCallData
    )
{
     HDC  hdc  = GetDCAndTransform(pCallData->hwnd);
     LONG xpos = 0;
     MENUINFO mi;

     {
         mi.cbSize = sizeof(mi);
         mi.fMask = MIM_BACKGROUND | MIM_APPLYTOSUBMENUS;
         mi.hbrBack = CreateHatchBrush(HS_BDIAGONAL, RGB(255, 0, 0));
        // mi.hbrBack = CreateSolidBrush(RGB(255, 0, 0));
         SetMenuInfo(GetMenu(pCallData->hwnd), &mi);
     }

     HBRUSH hbr1 = CreateHatchBrush(HS_BDIAGONAL, RGB(255, 0, 0));
     HBRUSH hbr2 = CreateHatchBrush(HS_BDIAGONAL, RGB(  0, 255, 0));
     HBRUSH hbr3 = CreateHatchBrush(HS_BDIAGONAL, RGB(  0, 0, 255));
     HBRUSH hbr4 = CreateSolidBrush(RGB(255,255,0));

     PatBlt(hdc,0,0,5000,5000,0);


     SetBkColor(hdc,RGB(0,0,0));

     SelectObject(hdc,hbr1);
     PatBlt(hdc,xpos,0,8,8,PATCOPY);

     SelectObject(hdc,hbr2);
     PatBlt(hdc,xpos,16,8,8,PATCOPY);

     SelectObject(hdc,hbr3);
     PatBlt(hdc,xpos,32,8,8,PATCOPY);

     SelectObject(hdc,hbr4);
     PatBlt(hdc,xpos,48,8,8,PATCOPY);

     SetBkColor(hdc,RGB(255,0,0));
     xpos += 16;
     SelectObject(hdc,hbr1);
     PatBlt(hdc,xpos,0,8,8,PATCOPY);

     SelectObject(hdc,hbr2);
     PatBlt(hdc,xpos,16,8,8,PATCOPY);

     SelectObject(hdc,hbr3);
     PatBlt(hdc,xpos,32,8,8,PATCOPY);

     SelectObject(hdc,hbr4);
     PatBlt(hdc,xpos,48,8,8,PATCOPY);


     SetBkColor(hdc,RGB(0,255,0));
     xpos += 16;
     SelectObject(hdc,hbr1);
     PatBlt(hdc,xpos,0,8,8,PATCOPY);

     SelectObject(hdc,hbr2);
     PatBlt(hdc,xpos,16,8,8,PATCOPY);

     SelectObject(hdc,hbr3);
     PatBlt(hdc,xpos,32,8,8,PATCOPY);

     SelectObject(hdc,hbr4);
     PatBlt(hdc,xpos,48,8,8,PATCOPY);

     SetBkColor(hdc,RGB(0,0,255));
     xpos += 16;
     SelectObject(hdc,hbr1);
     PatBlt(hdc,xpos,0,8,8,PATCOPY);

     SelectObject(hdc,hbr2);
     PatBlt(hdc,xpos,16,8,8,PATCOPY);

     SelectObject(hdc,hbr3);
     PatBlt(hdc,xpos,32,8,8,PATCOPY);

     SelectObject(hdc,hbr4);
     PatBlt(hdc,xpos,48,8,8,PATCOPY);

     SetBkColor(hdc,RGB(255,255,255));
     xpos += 16;
     SelectObject(hdc,hbr1);
     PatBlt(hdc,xpos,0,8,8,PATCOPY);

     SelectObject(hdc,hbr2);
     PatBlt(hdc,xpos,16,8,8,PATCOPY);

     SelectObject(hdc,hbr3);
     PatBlt(hdc,xpos,32,8,8,PATCOPY);

     SelectObject(hdc,hbr4);
     PatBlt(hdc,xpos,48,8,8,PATCOPY);



     ReleaseDC(pCallData->hwnd,hdc);

     DeleteObject(hbr1);
     DeleteObject(hbr2);
     DeleteObject(hbr3);
     DeleteObject(hbr4);
 }

/**************************************************************************\
* vTestDiamond
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    5/15/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestDiamond(
    TEST_CALL_DATA *pCallData
    )
{
     HDC      hdc  = GetDCAndTransform(pCallData->hwnd);

     GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
     GRADIENT_RECT     gRect = {0,1};
     TRIVERTEX         vert[6];
     RECT              rcl;

     GetClientRect(pCallData->hwnd,&rcl);

     //
     // background
     //
 
     vert[0].x     = 0x0;
     vert[0].y     = 0x0;
     vert[0].Red   = 0x0000;
     vert[0].Green = 0x8000;
     vert[0].Blue  = 0x8000;
     vert[0].Alpha = 0x0000;
 
     vert[1].x     = rcl.right;
     vert[1].y     = 0;
     vert[1].Red   = 0x0000;
     vert[1].Green = 0x4000;
     vert[1].Blue  = 0x8000;
     vert[1].Alpha = 0x0000;
 
     vert[2].x     = rcl.right;
     vert[2].y     = rcl.bottom;
     vert[2].Red   = 0x0000;
     vert[2].Green = 0x0000;
     vert[2].Blue  = 0x8000;
     vert[2].Alpha = 0x0000;

     vert[3].x     = 0;
     vert[3].y     = rcl.bottom;
     vert[3].Red   = 0x0000;
     vert[3].Green = 0x4000;
     vert[3].Blue  = 0x8000;
     vert[3].Alpha = 0x0000;

     GradientFill(hdc,vert,4,&gTri,2,GRADIENT_FILL_TRIANGLE);

     //
     // Diamond
     //
 
     vert[0].x     = 70;
     vert[0].y     = 150;
     vert[0].Red   = 0xff00;
     vert[0].Green = 0xa000;
     vert[0].Blue  = 0x0000;
     vert[0].Alpha = 0x0000;
 
     vert[1].x     = 100;
     vert[1].y     = 100;
     vert[1].Red   = 0xff00;
     vert[1].Green = 0x0000;
     vert[1].Blue  = 0x0000;
     vert[1].Alpha = 0x0000;
 
     vert[2].x     = 130;
     vert[2].y     = 150;
     vert[2].Red   = 0xff00;
     vert[2].Green = 0x6000;
     vert[2].Blue  = 0x0000;
     vert[2].Alpha = 0x0000;

     vert[3].x     = 100;
     vert[3].y     = 200;
     vert[3].Red   = 0xff00;
     vert[3].Green = 0xff00;
     vert[3].Blue  = 0x0000;
     vert[3].Alpha = 0x0000;

     GradientFill(hdc,vert,4,&gTri,2,GRADIENT_FILL_TRIANGLE);

     //
     // circle with alpha
     //

     BITMAPINFO bmi;
     PBITMAPINFOHEADER pbmih = &bmi.bmiHeader;

     pbmih->biSize            = sizeof(BITMAPINFOHEADER);
     pbmih->biWidth           = 128;
     pbmih->biHeight          = 128;
     pbmih->biPlanes          = 1;
     pbmih->biBitCount        = 32;
     pbmih->biCompression     = BI_RGB;
     pbmih->biSizeImage       = 0;
     pbmih->biXPelsPerMeter   = 0;
     pbmih->biYPelsPerMeter   = 0;
     pbmih->biClrUsed         = 0;
     pbmih->biClrImportant    = 0;

     PULONG  pDib32RGB;
     HBITMAP hdib32RGB  = CreateDIBSection(hdc,&bmi,DIB_RGB_COLORS,(VOID **)&pDib32RGB,NULL,0);
     HDC     hdcm       = CreateCompatibleDC(hdc);

     SelectObject(hdcm,hdib32RGB);
     PatBlt(hdcm,0,0,5000,5000,0);


     POINT  pos     = {64,64};

     double fr      = 32.0;
     double fTheta  = 0.0;
     double fdTheta = 0.1;
 
     //
     // fade to back at 0,0
     //
 
     fTheta  = 0.0;  
 
     vert[0].x     = pos.x;
     vert[0].y     = pos.y;
     vert[0].Red   = 0xff00;
     vert[0].Green = 0xff00;
     vert[0].Blue  = 0xff00;
     vert[0].Alpha = 0xff00;
 
     vert[1].Red   = 0x0000;
     vert[1].Green = 0x0000;
     vert[1].Blue  = 0x0000;
     vert[1].Alpha = 0x0000;
 
     vert[2].Red   = 0x0000;
     vert[2].Green = 0x0000;
     vert[2].Blue  = 0x0000;
     vert[2].Alpha = 0x0000;
 
     fTheta  = 0;
     double fLimit = (2.0 * fdTheta) * 4.0;
 
     while (fTheta < (2.0 * 3.14159265))
     {
         vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
         vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 
 
         fTheta += fdTheta;
 
         vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
         vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 
         GradientFill(hdcm,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
     }

     BLENDFUNCTION BlendFunction;

     BlendFunction.BlendOp                  = AC_SRC_OVER;
     BlendFunction.BlendFlags               = 0;
     BlendFunction.SourceConstantAlpha      = 0xfe;
     BlendFunction.AlphaFormat              = AC_SRC_ALPHA;

     AlphaBlend(hdc,100-64,100-64,128,128,hdcm,0,0,128,128,BlendFunction);

     DeleteDC(hdcm);
     DeleteObject(hdib32RGB);

     ReleaseDC(pCallData->hwnd,hdc);
 }

/**************************************************************************\
* vTestBitBlt
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    5/15/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestBitBlt(
    TEST_CALL_DATA *pCallData
    )
{
     HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    
     //
     // tile screen
     //
 
     {
         RECT rect;
         GetClientRect(pCallData->hwnd,&rect);
         FillTransformedRect(hdc,&rect,hbrFillCars);
     }

     BitBlt(hdc,100,100,200,200,hdc,0,0,NOTSRCCOPY);

     BitBlt(hdc,400,100,200,200,hdc,500,0,NOTSRCCOPY);

     BitBlt(hdc,100,400,200,200,hdc,0,500,NOTSRCCOPY);

     BitBlt(hdc,400,400,200,200,hdc,500,500,NOTSRCCOPY);

     ReleaseDC(pCallData->hwnd,hdc);
}

VOID
vTestBitBlt2(
    TEST_CALL_DATA *pCallData
    )
{
     HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    
     //
     // tile screen
     //
 
     {
         RECT rect;
         GetClientRect(pCallData->hwnd,&rect);
         FillTransformedRect(hdc,&rect,hbrFillCars);
     }

     BitBlt(hdc,100,100,200,200,hdc,0,0,NOTSRCCOPY);

     BitBlt(hdc,200,000,200,200,hdc,100,100,NOTSRCCOPY);

     ReleaseDC(pCallData->hwnd,hdc);
 }

VOID
vTestBitBlt3(
    TEST_CALL_DATA *pCallData
    )
{
     HDC      hdc  = GetDCAndTransform(pCallData->hwnd);

     GdiSetBatchLimit(1);
    
     //
     // tile screen
     //
 
     ULONG    ulIndex = 0;
     HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],350,350);
     HDC      hdcm = CreateCompatibleDC(hdc);
     SelectObject(hdcm,hdib);

     PatBlt(hdc ,0,0,5000,5000,0);
     PatBlt(hdcm,0,0,5000,5000,0);

     HBRUSH hBrush = (HBRUSH)SelectObject(hdcm,CreateSolidBrush(RGB(255, 255, 255 )));		 
     Rectangle(hdcm, 0, 0, 200, 200);

     hBrush = (HBRUSH)SelectObject(hdcm,CreateSolidBrush(RGB(255, 0,0 )));
     Ellipse(hdcm, 50, 50, 350, 350);
     BitBlt( hdcm, 100, 100, 200, 200, hdcm, 0, 0, NOTSRCCOPY );

     BitBlt( hdc,0,0, 350, 350, hdcm, 0, 0, SRCCOPY );


     GdiSetBatchLimit(0);

     ReleaseDC(pCallData->hwnd,hdc);
 }

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRectH(
    TEST_CALL_DATA *pCallData
    )
{
    HDC                 hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_RECT       gRect[10];
    GRADIENT_TRIANGLE   gTri[10];
    TRIVERTEX           vert[32];
    HPALETTE            hpal;
    RECT                rect;
    RECT                dibRect;
    HDC hdcm  =         CreateCompatibleDC(hdc);
    HDC hdcmA =         CreateCompatibleDC(hdc);
    PBITMAPINFO         pbmi;
    PBITMAPINFOHEADER   pbmih;
    HBITMAP             hdib;
    HBITMAP             hdibA;
    PBYTE               pDib;
    PBYTE               pDibA;
    BLENDFUNCTION       BlendFunction;

    //
    // tile screen
    //

    {
        RECT rect;
        HBITMAP  hbmCars = LoadBitmap(hInstMain,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH lgBrush;
        HBRUSH   hbrFill;

        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (LONG)hbmCars;

        hbrFill = CreateBrushIndirect(&lgBrush);
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFill);

        DeleteObject(hbrFill);
        DeleteObject(hbmCars);
    }

    //
    // init drawing modes
    //

    SetStretchBltMode(hdc,HALFTONE);

    BlendFunction.BlendOp             = AC_SRC_OVER;
    BlendFunction.BlendFlags          = 0;
    BlendFunction.SourceConstantAlpha = 255;

    SetGraphicsMode(hdc,GM_ADVANCED);

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    //
    // select and realize palette
    //

    hpal = CreateHtPalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi  = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = rect.right;
    pbmih->biHeight          = 200;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 32;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];
    pulMask[0] = 0x00ff0000;
    pulMask[1] = 0x0000ff00;
    pulMask[2] = 0x000000ff;

    pbmih->biCompression   = BI_BITFIELDS;

    hdibA  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

    if ((hdib == NULL) && (hdibA != NULL))
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }

        if (SelectObject(hdcmA,hdibA) == NULL)
        {
            MessageBox(NULL,"error selecting Alpha DIB","Error",MB_OK);
        }
    }

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 100;
    vert[1].y     = 100;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    gRect[0].UpperLeft  = 0;
    gRect[0].LowerRight = 1;

    GradientFill(hdc,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_H);

    GradientFill(hdcm,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_H);

    SetStretchBltMode(hdc,COLORONCOLOR);
    StretchBlt(hdc,120,  0,100,100,hdcm,0,0,100,100,SRCCOPY);
    SetStretchBltMode(hdc,HALFTONE);
    StretchBlt(hdc,240,  0,100,100,hdcm,0,0,100,100,SRCCOPY);

    //
    // add alpha
    //

    vert[0].Red   = 0x8400;
    vert[0].Alpha = 0x8400;
    vert[1].Green = 0x4000;
    vert[1].Alpha = 0x4000;

    GradientFill(hdcmA,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_H);
    AlphaBlend(hdc,360,0,100,100,hdcmA,0,0,100,100,BlendFunction);
    BitBlt(hdc,480,0,100,100,hdcmA,0,0,SRCCOPY);

    vert[0].x     = 0;
    vert[0].y     = 110;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 100;
    vert[1].y     = 110;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 100;
    vert[2].y     = 210;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0xff00;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 210;
    vert[3].Red   = 0xff00;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    gTri[0].Vertex1 = 0;
    gTri[0].Vertex2 = 1;
    gTri[0].Vertex3 = 2;

    gTri[1].Vertex1 = 0;
    gTri[1].Vertex2 = 2;
    gTri[1].Vertex3 = 3;

    GradientFill(hdc,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // zero offset
    //

    vert[0].y     =   0;
    vert[1].y     =   0;
    vert[2].y     = 100;
    vert[3].y     = 100;


    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    SetStretchBltMode(hdc,COLORONCOLOR);
    StretchBlt(hdc,120,110,100,100,hdcm,0,0,100,100,SRCCOPY);
    SetStretchBltMode(hdc,HALFTONE);
    StretchBlt(hdc,240,110,100,100,hdcm,0,0,100,100,SRCCOPY);

    //
    // add alpha
    //

    vert[0].Red   = 0x8400;
    vert[0].Alpha = 0x8400;
    vert[1].Green = 0x4000;
    vert[1].Alpha = 0x4000;
    vert[2].Green = 0x4000;
    vert[2].Alpha = 0x4000;
    vert[3].Red   = 0x8400;
    vert[3].Alpha = 0x8400;

    GradientFill(hdcmA,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);
    AlphaBlend(hdc,360,110,100,100,hdcmA,0,0,100,100,BlendFunction);
    BitBlt(hdc,480,110,100,100,hdcmA,0,0,SRCCOPY);

    //
    // banners
    //

    vert[0].x     = 0;
    vert[0].y     = 300;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 600;
    vert[1].y     = 330;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 0;
    vert[2].y     = 332;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0xff00;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 600;
    vert[3].y     = 362;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    vert[4].x     = 0;
    vert[4].y     = 364;
    vert[4].Red   = 0x0000;
    vert[4].Green = 0x0000;
    vert[4].Blue  = 0xff00;
    vert[4].Alpha = 0x0000;

    vert[5].x     = 600;
    vert[5].y     = 395;
    vert[5].Red   = 0x0000;
    vert[5].Green = 0x0000;
    vert[5].Blue  = 0x0000;
    vert[5].Alpha = 0x0000;

    vert[6].x     = 0;
    vert[6].y     = 400;
    vert[6].Red   = 0x0000;
    vert[6].Green = 0x0000;
    vert[6].Blue  = 0xff00;
    vert[6].Alpha = 0x0000;

    vert[7].x     = 600;
    vert[7].y     = 430;
    vert[7].Red   = 0xff00;
    vert[7].Green = 0xff00;
    vert[7].Blue  = 0x0000;
    vert[7].Alpha = 0x0000;

    gRect[0].UpperLeft  = 0;
    gRect[0].LowerRight = 1;

    gRect[1].UpperLeft  = 2;
    gRect[1].LowerRight = 3;

    gRect[2].UpperLeft  = 4;
    gRect[2].LowerRight = 5;

    gRect[3].UpperLeft  = 6;
    gRect[3].LowerRight = 7;

    GradientFill(hdc,vert,8,(PVOID)gRect,4,GRADIENT_FILL_RECT_H);

    //
    // banner triangles
    //

    vert[0].x     = 0;
    vert[0].y     = 432;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 600;
    vert[1].y     = 432;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 600;
    vert[2].y     = 463;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 463;
    vert[3].Red   = 0xff00;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    gTri[0].Vertex1 = 0;
    gTri[0].Vertex2 = 1;
    gTri[0].Vertex3 = 2;

    gTri[1].Vertex1 = 0;
    gTri[1].Vertex2 = 2;
    gTri[1].Vertex3 = 3;

    GradientFill(hdc,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = 0;
    vert[0].y     = 464;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 600;
    vert[1].y     = 464;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 600;
    vert[2].y     = 495;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 495;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdc,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = 0;
    vert[0].y     = 500;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 600;
    vert[1].y     = 500;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 600;
    vert[2].y     = 530;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 530;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0xff00;
    vert[3].Alpha = 0x0000;

    GradientFill(hdc,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = 0;
    vert[0].y     = 532;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 600;
    vert[1].y     = 532;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 600;
    vert[2].y     = 563;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0xff00;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 0;
    vert[3].y     = 563;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0xff00;
    vert[3].Alpha = 0x0000;

    GradientFill(hdc,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    DeleteDC(hdcm);
    DeleteDC(hdcmA);
    DeleteObject(hdib);
    DeleteObject(hdibA);
    bThreadActive = FALSE;
}


/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRectV(
    TEST_CALL_DATA *pCallData
    )
{
    HDC             hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_RECT   gRect[10];
    TRIVERTEX       vert[32];
    HPALETTE        hpal;
    RECT            rect;
    RECT            dibRect;
    HDC hdcm  =     CreateCompatibleDC(hdc);
    HDC hdcmA =     CreateCompatibleDC(hdc);
    PBITMAPINFO     pbmi;
    PBITMAPINFOHEADER pbmih;
    HBITMAP         hdib;
    HBITMAP         hdibA;
    PBYTE           pDib;
    PBYTE           pDibA;
    BLENDFUNCTION   BlendFunction;
    LONG            xAlign;
    LONG            xpos = 0;
    LONG            ypos = 0;

    //
    // tile screen
    //

    {
        RECT rect;
        HBITMAP  hbmCars = LoadBitmap(hInstMain,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH lgBrush;
        HBRUSH   hbrFill;

        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (LONG)hbmCars;

        hbrFill = CreateBrushIndirect(&lgBrush);
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFill);

        DeleteObject(hbrFill);
        DeleteObject(hbmCars);
    }

    //
    // init drawing modes
    //

    SetStretchBltMode(hdc,HALFTONE);

    BlendFunction.BlendOp             = AC_SRC_OVER;
    BlendFunction.BlendFlags          = 0;
    BlendFunction.SourceConstantAlpha = 255;

    SetGraphicsMode(hdc,GM_ADVANCED);

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    //
    // select and realize palette
    //

    hpal = CreateHtPalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi  = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = rect.right;
    pbmih->biHeight          = 200;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 32;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];
    pulMask[0] = 0x00ff0000;
    pulMask[1] = 0x0000ff00;
    pulMask[2] = 0x000000ff;

    pbmih->biCompression   = BI_BITFIELDS;

    hdibA  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

    if ((hdib == NULL) && (hdibA != NULL))
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }

        if (SelectObject(hdcmA,hdibA) == NULL)
        {
            MessageBox(NULL,"error selecting Alpha DIB","Error",MB_OK);
        }
    }

    vert[0].x     = -100;
    vert[0].y     = -100;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 1300;
    vert[1].y     = 100;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    gRect[0].UpperLeft  = 0;
    gRect[0].LowerRight = 1;

    GradientFill(hdc,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_V);

    xpos = 0;
    ypos = 110;

    for (xAlign=0;xAlign<8;xAlign++)
    {
        vert[0].x     = xAlign;
        vert[0].y     = ypos;
        vert[0].Red   = 0x8000;
        vert[0].Green = 0xc000;
        vert[0].Blue  = 0x0000;
        vert[0].Alpha = 0xff00;

        ypos += 30;

        vert[1].x     = vert[0].x + 31;
        vert[1].y     = ypos+2;
        vert[1].Red   = 0x0000;
        vert[1].Green = 0xff00;
        vert[1].Blue  = 0x0000;
        vert[1].Alpha = 0xff00;

        ypos += 5;

        vert[2].x     = vert[0].x + 7;
        vert[2].y     = ypos;
        vert[2].Red   = 0x0000;
        vert[2].Green = 0x0000;
        vert[2].Blue  = 0x0000;
        vert[2].Alpha = 0xff00;

        ypos += 30;

        vert[3].x     = vert[2].x + 32;
        vert[3].y     = ypos+3;
        vert[3].Red   = 0x0000;
        vert[3].Green = 0xff00;
        vert[3].Blue  = 0x0000;
        vert[3].Alpha = 0xff00;

        gRect[0].UpperLeft  = 0;
        gRect[0].LowerRight = 1;

        gRect[1].UpperLeft  = 2;
        gRect[1].LowerRight = 3;

        GradientFill(hdc,vert,4,(PVOID)gRect,2,GRADIENT_FILL_RECT_V);

        ypos += 5;
    }

    ypos = 110;
    xpos = 100;

    {
        LONG xAlign;

        for (xAlign=0;xAlign<8;xAlign++)
        {
            LONG ix,iy;
            LONG width = 1;

            for (ix=xpos+xAlign;ix<2000;ix+=32)
            {
                vert[0].x     = ix;
                vert[0].y     = ypos;
                vert[0].Red   = 0x4000;
                vert[0].Green = 0x4000;
                vert[0].Blue  = 0x4000;
                vert[0].Alpha = 0xff00;

                vert[1].x     = ix + width;
                vert[1].y     = ypos+32;
                vert[1].Red   = 0xc000;
                vert[1].Green = 0xc000;
                vert[1].Blue  = 0xc000;
                vert[1].Alpha = 0xff00;

                GradientFill(hdc,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_V);

                width++;
            }

            ypos += 40;
        }
    }


    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    DeleteDC(hdcm);
    DeleteDC(hdcmA);
    DeleteObject(hdibA);
    DeleteObject(hdib);
    bThreadActive = FALSE;
}


/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRect4(
    TEST_CALL_DATA *pCallData
    )
{

    HDC               hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_RECT     gRect[2] = {{0,1},{2,3}};
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{3,4,5}};
    TRIVERTEX         vert[32];
    HPALETTE          hpal;
    RECT              rect;
    RECT              dibRect;
    HDC hdcm4 =       CreateCompatibleDC(hdc);
    HBITMAP           hdib4;
    PBYTE             pDib4;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbih;
    ULONG   ux,uy;
    PULONG  pulColors;
    ULONG   ulVGA[] = {
                        0x00000000,
                        0x00800000,
                        0x00008000,
                        0x00808000,
                        0x00000080,
                        0x00800080,
                        0x00008080,
                        0x00C0C0C0,
                        0x00808080,
                        0x00FF0000,
                        0x0000FF00,
                        0x00FFFF00,
                        0x000000FF,
                        0x00FF00FF,
                        0x0000FFFF,
                        0x00ffffff
                        };

    //
    // tile screen
    //

    {
        RECT rect;
        HBITMAP  hbmCars = LoadBitmap(hInstMain,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH lgBrush;
        HBRUSH   hbrFill;

        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (LONG)hbmCars;

        hbrFill = CreateBrushIndirect(&lgBrush);
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFill);

        DeleteObject(hbrFill);
        DeleteObject(hbmCars);
    }

    //
    // init drawing modes
    //

    SetStretchBltMode(hdc,HALFTONE);

    SetGraphicsMode(hdc,GM_ADVANCED);

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    //
    // select and realize palette
    //

    hpal = CreateHtPalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    pbih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pulColors = (PULONG)&pbmi->bmiColors[0];

    pbih->biSize            = sizeof(BITMAPINFOHEADER);
    pbih->biWidth           = 512;
    pbih->biHeight          = 256;
    pbih->biPlanes          = 1;
    pbih->biBitCount        = 4;
    pbih->biCompression     = BI_RGB;
    pbih->biSizeImage       = 0;
    pbih->biXPelsPerMeter   = 0;
    pbih->biYPelsPerMeter   = 0;
    pbih->biClrUsed         = 0;
    pbih->biClrImportant    = 0;

    memcpy(pulColors,&ulVGA[0],16*4);

    hdib4 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib4,NULL,0);
    SelectObject(hdcm4,hdib4);


    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 100;
    vert[1].y     = 100;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0xff00;

    PatBlt(hdcm4,0,0,128,128,BLACKNESS);
    GradientFill(hdcm4,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_H);

    BitBlt(hdc,0,0,128,128,hdcm4,0,0,SRCCOPY);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 100;
    vert[1].y     = 100;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    PatBlt(hdcm4,0,0,128,128,BLACKNESS);
    GradientFill(hdcm4,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_H);

    BitBlt(hdc,0,128+10,128,128,hdcm4,0,0,SRCCOPY);

    //
    // triangle
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 100;
    vert[1].y     = 0;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 100;
    vert[2].y     = 100;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0xff00;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0x0000;

    vert[3].x     = 100;
    vert[3].y     =  10;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    vert[4].x     = 100;
    vert[4].y     = 110;
    vert[4].Red   = 0x0000;
    vert[4].Green = 0xff00;
    vert[4].Blue  = 0x0000;
    vert[4].Alpha = 0x0000;

    vert[5].x     =   0;
    vert[5].y     = 110;
    vert[5].Red   = 0x0000;
    vert[5].Green = 0xff00;
    vert[5].Blue  = 0x0000;
    vert[5].Alpha = 0x0000;

    PatBlt(hdcm4,0,0,128,128,BLACKNESS);
    GradientFill(hdcm4,vert,6,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    BitBlt(hdc,200,0,128,128,hdcm4,0,0,SRCCOPY);

    //
    // r,g,b,grey gradient
    //

    {
        GRADIENT_TRIANGLE gradTri[8] = {
                                        { 0, 1, 2},{ 1, 2, 3},
                                        { 4, 5, 6},{ 5, 6, 7},
                                        { 8, 9,10},{ 9,10,11},
                                        {12,13,14},{13,14,15}
                                       };

        int dy = 64;

        // clear

        PatBlt(hdcm4,0,0,1000,1000,BLACKNESS);

        // Blue

        vert[0].x     = 0;
        vert[0].y     = dy * 0;
        vert[0].Red   = 0x0000;
        vert[0].Green = 0x0000;
        vert[0].Blue  = 0xff00;
        vert[0].Alpha = 0x0000;

        vert[1].x     = 512;
        vert[1].y     = dy * 0;0;
        vert[1].Red   = 0x0000;
        vert[1].Green = 0x0000;
        vert[1].Blue  = 0x0000;
        vert[1].Alpha = 0x0000;

        vert[2].x     = 0;
        vert[2].y     = dy * 0 + (dy-4);
        vert[2].Red   = 0x0000;
        vert[2].Green = 0x0000;
        vert[2].Blue  = 0xff00;
        vert[2].Alpha = 0x0000;

        vert[3].x     = 512;
        vert[3].y     = dy * 0 + (dy-4);
        vert[3].Red   = 0x0000;
        vert[3].Green = 0x0000;
        vert[3].Blue  = 0x0000;
        vert[3].Alpha = 0x0000;

        // red

        vert[4].x     = 0;
        vert[4].y     = dy * 1;
        vert[4].Red   = 0xff00;
        vert[4].Green = 0x0000;
        vert[4].Blue  = 0x0000;
        vert[4].Alpha = 0x0000;

        vert[5].x     = 512;
        vert[5].y     = dy * 1;
        vert[5].Red   = 0x0000;
        vert[5].Green = 0x0000;
        vert[5].Blue  = 0x0000;
        vert[5].Alpha = 0x0000;

        vert[6].x     = 0;
        vert[6].y     = dy * 1 + (dy-4);
        vert[6].Red   = 0xff00;
        vert[6].Green = 0x0000;
        vert[6].Blue  = 0x0000;
        vert[6].Alpha = 0x0000;

        vert[7].x     = 512;
        vert[7].y     = dy * 1 + (dy-4);
        vert[7].Red   = 0x0000;
        vert[7].Green = 0x0000;
        vert[7].Blue  = 0x0000;
        vert[7].Alpha = 0x0000;

        // green

        vert[8].x     = 0;
        vert[8].y     = dy * 2;
        vert[8].Red   = 0x0000;
        vert[8].Green = 0xff00;
        vert[8].Blue  = 0x0000;
        vert[8].Alpha = 0x0000;

        vert[9].x     = 512;
        vert[9].y     = dy * 2;
        vert[9].Red   = 0x0000;
        vert[9].Green = 0x0000;
        vert[9].Blue  = 0x0000;
        vert[9].Alpha = 0x0000;

        vert[10].x     = 0;
        vert[10].y     = dy * 2 + (dy-4);
        vert[10].Red   = 0x0000;
        vert[10].Green = 0xff00;
        vert[10].Blue  = 0x0000;
        vert[10].Alpha = 0x0000;

        vert[11].x     = 512;
        vert[11].y     = dy * 2 + (dy-4);
        vert[11].Red   = 0x0000;
        vert[11].Green = 0x0000;
        vert[11].Blue  = 0x0000;
        vert[11].Alpha = 0x0000;

        // grey

        vert[12].x     = 0;
        vert[12].y     = dy * 3;
        vert[12].Red   = 0xff00;
        vert[12].Green = 0xff00;
        vert[12].Blue  = 0xff00;
        vert[12].Alpha = 0x0000;

        vert[13].x     = 512;
        vert[13].y     = dy * 3;
        vert[13].Red   = 0x0000;
        vert[13].Green = 0x0000;
        vert[13].Blue  = 0x0000;
        vert[13].Alpha = 0x0000;

        vert[14].x     = 0;
        vert[14].y     = dy * 3 + (dy-4);
        vert[14].Red   = 0xff00;
        vert[14].Green = 0xff00;
        vert[14].Blue  = 0xff00;
        vert[14].Alpha = 0x0000;

        vert[15].x     = 512;
        vert[15].y     = dy * 3 + (dy-4);
        vert[15].Red   = 0x0000;
        vert[15].Green = 0x0000;
        vert[15].Blue  = 0x0000;
        vert[15].Alpha = 0x0000;

        GradientFill(hdcm4,vert,16,(PVOID)gradTri,8,GRADIENT_FILL_TRIANGLE);

        BitBlt(hdc,200,128+10,512,256,hdcm4,0,0,SRCCOPY);
    }


    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    DeleteDC(hdcm4);
    DeleteObject(hdib4);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRect1(
    TEST_CALL_DATA *pCallData
    )
{
    HDC               hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_RECT     gRect[2] = {{0,1},{2,3}};
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{3,4,5}};
    TRIVERTEX         vert[32];
    HPALETTE          hpal;
    RECT              rect;
    RECT              dibRect;
    HDC hdcm1 =       CreateCompatibleDC(hdc);
    HBITMAP           hdib1;
    PBYTE             pDib1;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbih;
    ULONG   ux,uy;
    PULONG  pulColors;
    ULONG   ulVGA[] = {
                        0x00000000,
                        0x00ffffff,
                        0x00008000,
                        0x00808000,
                        0x00000080,
                        0x00800080,
                        0x00008080,
                        0x00C0C0C0,
                        0x00808080,
                        0x00FF0000,
                        0x0000FF00,
                        0x00FFFF00,
                        0x000000FF,
                        0x00FF00FF,
                        0x0000FFFF,
                        0x00ffffff
                        };

    //
    // tile screen
    //

    {
        RECT rect;
        HBITMAP  hbmCars = LoadBitmap(hInstMain,MAKEINTRESOURCE(CAR_BITMAP));
        LOGBRUSH lgBrush;
        HBRUSH   hbrFill;

        lgBrush.lbStyle = BS_PATTERN;
        lgBrush.lbColor = 0;
        lgBrush.lbHatch = (LONG)hbmCars;

        hbrFill = CreateBrushIndirect(&lgBrush);
        GetClientRect(pCallData->hwnd,&rect);
        FillTransformedRect(hdc,&rect,hbrFill);

        DeleteObject(hbrFill);
        DeleteObject(hbmCars);
    }

    //
    // init drawing modes
    //

    SetStretchBltMode(hdc,HALFTONE);

    SetGraphicsMode(hdc,GM_ADVANCED);

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    //
    // select and realize palette
    //

    hpal = CreateHtPalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    pbih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pulColors = (PULONG)&pbmi->bmiColors[0];

    pbih->biSize            = sizeof(BITMAPINFOHEADER);
    pbih->biWidth           = 128;
    pbih->biHeight          = 128;
    pbih->biPlanes          = 1;
    pbih->biBitCount        = 1;
    pbih->biCompression     = BI_RGB;
    pbih->biSizeImage       = 0;
    pbih->biXPelsPerMeter   = 0;
    pbih->biYPelsPerMeter   = 0;
    pbih->biClrUsed         = 0;
    pbih->biClrImportant    = 0;

    memcpy(pulColors,&ulVGA[0],2*4);

    hdib1 = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib1,NULL,0);
    SelectObject(hdcm1,hdib1);

    PatBlt(hdcm1,0,0,128,128,BLACKNESS);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 100;
    vert[1].y     = 100;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0xff00;

    GradientFill(hdcm1,vert,2,(PVOID)gRect,1,GRADIENT_FILL_RECT_H);

    BitBlt(hdc,0,0,128,128,hdcm1,0,0,SRCCOPY);

    PatBlt(hdcm1,0,0,128,128,BLACKNESS);

    //
    // triangle
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0xff00;
    vert[0].Blue  = 0xff00;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 100;
    vert[1].y     = 0;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 100;
    vert[2].y     = 100;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0xff00;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0x0000;

    GradientFill(hdcm1,vert,3,(PVOID)gTri,1,GRADIENT_FILL_TRIANGLE);

    BitBlt(hdc,200,0,128,128,hdcm1,0,0,SRCCOPY);

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
    DeleteDC(hdcm1);
    DeleteObject(hdib1);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

LONG 
GEN_RAND_VERT(
    LONG Limit
    )
{
    LONG l1 = rand() & 0xffff;
    LONG l2 = rand() & 0xffff;

    l1 = (l1 << 16) | l2;

    l1 = l1 % Limit;

    return(l1);
}


VOID
vTestRandTri(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[4] = {{0,1,2},{0,2,3},{0,3,4},{0,4,5}};
    TRIVERTEX vert[32];
    HPALETTE  hpal;
    RECT rect;
    RECT dibRect;
    HDC hdcm = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    HBITMAP hdib;
    PBYTE   pDib;

    SetStretchBltMode(hdc,HALFTONE);
    SetGraphicsMode(hdc,GM_ADVANCED);

    //
    // clear screen
    //

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));


    //
    // select and realize palette
    //

    hpal = CreateHalftonePalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = rect.right;
    pbmi->bmiHeader.biHeight          = -200;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 32;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }
    }

    srand(11);

    LONG MaxVert1 = 0xffffffff;
    LONG MaxVert2 = 0x000007ff;
    LONG vIndex   = 0;
    LONG MaxVert = MaxVert2;

    //#define GEN_RAND_VERT(v) ((((rand() & 0xffff) << 16) | (rand() & 0xffff)) & v - (v/2))


    do
    {
        vIndex++;
        if (vIndex > 100)
        {
            vIndex = 0;

            if (MaxVert == MaxVert1)
            {
                MaxVert = MaxVert2;
            }
            else
            {
                MaxVert = MaxVert1;
            }
        }

        vert[0].x     = GEN_RAND_VERT(MaxVert);
        vert[0].y     = GEN_RAND_VERT(MaxVert);
        vert[0].Red   = rand() & 0xffff;
        vert[0].Green = rand() & 0xffff;
        vert[0].Blue  = rand() & 0xffff;
        vert[0].Alpha = rand() & 0xffff;

        vert[1].x     = -vert[0].x;
        vert[1].y     = -vert[0].y;
        vert[1].Red   = rand() & 0xffff;
        vert[1].Green = rand() & 0xffff;
        vert[1].Blue  = rand() & 0xffff;
        vert[1].Alpha = rand() & 0xffff;

        vert[2].x     = GEN_RAND_VERT(MaxVert);
        vert[2].y     = GEN_RAND_VERT(MaxVert);
        vert[2].Red   = rand() & 0xffff;
        vert[2].Green = rand() & 0xffff;
        vert[2].Blue  = rand() & 0xffff;
        vert[2].Alpha = rand() & 0xffff;

        vert[3].x     = GEN_RAND_VERT(MaxVert);
        vert[3].y     = GEN_RAND_VERT(MaxVert);
        vert[3].Red   = rand() & 0xffff;
        vert[3].Green = rand() & 0xffff;
        vert[3].Blue  = rand() & 0xffff;
        vert[3].Alpha = rand() & 0xffff;

        vert[4].x     = GEN_RAND_VERT(MaxVert);
        vert[4].y     = GEN_RAND_VERT(MaxVert);
        vert[4].Red   = rand() & 0xffff;
        vert[4].Green = rand() & 0xffff;
        vert[4].Blue  = rand() & 0xffff;
        vert[4].Alpha = rand() & 0xffff;

        vert[5].x     = GEN_RAND_VERT(MaxVert);
                vert[5].y     = GEN_RAND_VERT(MaxVert);
        vert[5].Red   = rand() & 0xffff;
        vert[5].Green = rand() & 0xffff;
        vert[5].Blue  = rand() & 0xffff;
        vert[5].Alpha = rand() & 0xffff;

        GradientFill(hdc,vert,6,(PVOID)gTri,4,GRADIENT_FILL_TRIANGLE);
        #if 0
        DbgPrint("vTestRandTri:\n\n");
        DbgPrint("vTestRandTri:vert[0].x     = %li   \n",vert[0].x);
        DbgPrint("vTestRandTri:vert[0].y     = %li   \n",vert[0].y);
        DbgPrint("vTestRandTri:vert[0].Red   = %li   \n",vert[0].Red);
        DbgPrint("vTestRandTri:vert[0].Green = %li   \n",vert[0].Green);
        DbgPrint("vTestRandTri:vert[0].Blue  = %li   \n",vert[0].Blue);
        DbgPrint("vTestRandTri:vert[0].Alpha = %li   \n",vert[0].Alpha);

        DbgPrint("vTestRandTri:vert[1].x     = %li   \n",vert[1].x);
        DbgPrint("vTestRandTri:vert[1].y     = %li   \n",vert[1].y);
        DbgPrint("vTestRandTri:vert[1].Red   = %li   \n",vert[1].Red);
        DbgPrint("vTestRandTri:vert[1].Green = %li   \n",vert[1].Green);
        DbgPrint("vTestRandTri:vert[1].Blue  = %li   \n",vert[1].Blue);
        DbgPrint("vTestRandTri:vert[1].Alpha = %li   \n",vert[1].Alpha);

        DbgPrint("vTestRandTri:vert[2].x     = %li   \n",vert[2].x);
        DbgPrint("vTestRandTri:vert[2].y     = %li   \n",vert[2].y);
        DbgPrint("vTestRandTri:vert[2].Red   = %li   \n",vert[2].Red);
        DbgPrint("vTestRandTri:vert[2].Green = %li   \n",vert[2].Green);
        DbgPrint("vTestRandTri:vert[2].Blue  = %li   \n",vert[2].Blue);
        DbgPrint("vTestRandTri:vert[2].Alpha = %li   \n",vert[2].Alpha);
        #endif

    } while (TRUE);

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteObject(hpal);
    DeleteObject(hdib);
    bThreadActive = FALSE;
}

TRIVERTEX gvert[3] = {
    {
      10,
      10,
      0,
      0,
      0,
      0
    },
    {
      1100,
      10,
      0xff00,
      0,
      0,
      0
     },
     {
      100,
      100,
      0,
      0,
      0,
      0
     }
    };



BOOL
APIENTRY GetOptionDlgProc(
   HWND hDlg,
   unsigned message,
   DWORD wParam,
   LONG lParam
   )

/*++

Routine Description:

   Process message for about box, show a dialog box that says what the
   name of the program is.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    CHAR    msg[255];
    CHAR    EditTextInput[255];
    ULONG   i;
    ULONG   TmpInput;

    switch (message) {
    case WM_INITDIALOG:

            wsprintf(msg,"%i",gvert[0].x);
            SetDlgItemText(hDlg,IDD_TRI1_X,msg);

            wsprintf(msg,"%i",gvert[0].y);
            SetDlgItemText(hDlg,IDD_TRI1_Y,msg);

            wsprintf(msg,"%i",gvert[0].Red/256);
            SetDlgItemText(hDlg,IDD_TRI1_R,msg);

            wsprintf(msg,"%i",gvert[0].Green/256);
            SetDlgItemText(hDlg,IDD_TRI1_G,msg);

            wsprintf(msg,"%i",gvert[0].Blue/256);
            SetDlgItemText(hDlg,IDD_TRI1_B,msg);

            wsprintf(msg,"%i",gvert[1].x);
            SetDlgItemText(hDlg,IDD_TRI2_X,msg);

            wsprintf(msg,"%i",gvert[1].y);
            SetDlgItemText(hDlg,IDD_TRI2_Y,msg);

            wsprintf(msg,"%i",gvert[1].Red/256);
            SetDlgItemText(hDlg,IDD_TRI2_R,msg);

            wsprintf(msg,"%i",gvert[1].Green/256);
            SetDlgItemText(hDlg,IDD_TRI2_G,msg);

            wsprintf(msg,"%i",gvert[1].Blue/256);
            SetDlgItemText(hDlg,IDD_TRI2_B,msg);

            wsprintf(msg,"%i",gvert[2].x);
            SetDlgItemText(hDlg,IDD_TRI3_X,msg);

            wsprintf(msg,"%i",gvert[2].y);
            SetDlgItemText(hDlg,IDD_TRI3_Y,msg);

            wsprintf(msg,"%i",gvert[2].Red/256);
            SetDlgItemText(hDlg,IDD_TRI3_R,msg);

            wsprintf(msg,"%i",gvert[2].Green/256);
            SetDlgItemText(hDlg,IDD_TRI3_G,msg);

            wsprintf(msg,"%i",gvert[2].Blue/256);
            SetDlgItemText(hDlg,IDD_TRI3_B,msg);

            return (TRUE);

        case WM_COMMAND:
           switch(wParam) {

               //
               // end function
               //

               case IDOK:
               {
                   ULONG  ix;

                   for (ix = IDD_TRI1_X;ix <= IDD_TRI3_B;ix++)
                   {
                       GetDlgItemText(hDlg,ix,EditTextInput,20);
                       i = sscanf(EditTextInput,"%i",&TmpInput);
                       if (i == 1)
                       {
                           switch (ix)
                           {
                           case IDD_TRI1_X:
                               gvert[0].x = TmpInput;
                               break;
                           case IDD_TRI1_Y:
                               gvert[0].y = TmpInput;
                               break;
                           case IDD_TRI1_R:
                               gvert[0].Red = TmpInput * 256;
                               break;
                           case IDD_TRI1_G:
                               gvert[0].Green = TmpInput * 256;
                               break;
                           case IDD_TRI1_B:
                               gvert[0].Blue = TmpInput * 256;
                               break;

                           case IDD_TRI2_X:
                               gvert[1].x = TmpInput;
                               break;
                           case IDD_TRI2_Y:
                               gvert[1].y = TmpInput;
                               break;
                           case IDD_TRI2_R:
                               gvert[1].Red = TmpInput * 256;
                               break;
                           case IDD_TRI2_G:
                               gvert[1].Green = TmpInput * 256;
                               break;
                           case IDD_TRI2_B:
                               gvert[1].Blue = TmpInput * 256;
                               break;

                           case IDD_TRI3_X:
                               gvert[2].x = TmpInput;
                               break;
                           case IDD_TRI3_Y:
                               gvert[2].y = TmpInput;
                               break;
                           case IDD_TRI3_R:
                               gvert[2].Red = TmpInput * 256;
                               break;
                           case IDD_TRI3_G:
                               gvert[2].Green = TmpInput * 256;
                               break;
                           case IDD_TRI3_B:
                               gvert[2].Blue = TmpInput * 256;
                               break;
                           }
                       }
                   }
               }
               EndDialog(hDlg, TRUE);
               return (TRUE);

               case IDCANCEL:
                   EndDialog(hDlg, FALSE);
                   return (TRUE);

               //
               // change text
               //

               case IDD_TRI1_X:
               case IDD_TRI1_Y:
               case IDD_TRI1_R:
               case IDD_TRI1_G:
               case IDD_TRI1_B:
               case IDD_TRI2_X:
               case IDD_TRI2_Y:
               case IDD_TRI2_R:
               case IDD_TRI2_G:
               case IDD_TRI2_B:
               case IDD_TRI3_X:
               case IDD_TRI3_Y:
               case IDD_TRI3_R:
               case IDD_TRI3_G:
               case IDD_TRI3_B:

                  if (HIWORD(lParam) == EN_CHANGE)
                  {
                      EnableWindow(GetDlgItem(hDlg,IDOK),
                                   (BOOL)SendMessage((HWND)(LOWORD(lParam)),
                                                     WM_GETTEXTLENGTH,
                                                     0,
                                                     0L));
                  }

                  return(TRUE);

            }
            break;
    }
    return (FALSE);
}




/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestInputTri(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
        GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{3,4,5}};
    TRIVERTEX vert[32];
    HPALETTE  hpal;
    RECT rect;
    RECT dibRect;
    HDC hdcm = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    HBITMAP hdib;
    PBYTE   pDib;

    SetStretchBltMode(hdc,HALFTONE);
    SetGraphicsMode(hdc,GM_ADVANCED);

    //
    // clear screen
    //

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));

    DialogBox(hInstMain, (LPSTR)IDD_TRIANGLE_DLG, pCallData->hwnd, (DLGPROC)GetOptionDlgProc);

    //
    // select and realize palette
    //

    hpal = CreateHalftonePalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = rect.right;
    pbmi->bmiHeader.biHeight          = -200;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 32;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }
    }

#if 0
    vert[0].x     = 174     ;
    vert[0].y     = 10023   ;
    vert[0].Red   = 4365    ;
    vert[0].Green = 18055   ;
    vert[0].Blue  = 21674   ;
    vert[0].Alpha = 12218   ;

    vert[1].x     = 5802  ;
    vert[1].y     = -835  ;
    vert[1].Red   = 19082 ;
    vert[1].Green = 26799 ;
    vert[1].Blue  = 2609  ;
    vert[1].Alpha = 9098  ;

    vert[2].x     = 17644 ;
    vert[2].y     = 60    ;
    vert[2].Red   = 4890  ;
    vert[2].Green = 7222  ;
    vert[2].Blue  = 13531 ;
    vert[2].Alpha = 7987  ;

    vert[0].x     = -16777216;
    vert[0].y     = 10;
    vert[0].Red   = 0;
    vert[0].Green = 0;
    vert[0].Blue  = 0;
    vert[0].Alpha = 0;

    vert[1].x     = 16777216;
    vert[1].y     = 10;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0;
    vert[1].Blue  = 0;
    vert[1].Alpha = 0;

    vert[2].x     = -16777216;
    vert[2].y     = 20;
    vert[2].Red   = 0;
    vert[2].Green = 0;
    vert[2].Blue  = 0;
    vert[2].Alpha = 0;

#endif

    GradientFill(hdc,gvert,3,(PVOID)gTri,1,GRADIENT_FILL_TRIANGLE);

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteObject(hpal);
    DeleteObject(hdib);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB32(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{0,2,3}};
    TRIVERTEX vert[32];
    HPALETTE  hpal;
    RECT rect;
    RECT dibRect;
    HDC hdcm = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    HBITMAP hdib;
    PBYTE   pDib;

    SetStretchBltMode(hdc,COLORONCOLOR);

    //
    // clear screen
    //

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));


    //
    // select and realize palette
    //

    hpal = CreateHalftonePalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = rect.right;
    pbmi->bmiHeader.biHeight          = -200;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 32;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }
    }

    vert[0].x     = 10;
    vert[0].y     = 10;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = rect.right-10;
    vert[1].y     =  10;
    vert[1].Red   = 0xc000;
    vert[1].Green = 0xc000;
    vert[1].Blue  = 0xc000;
    vert[1].Alpha = 0xc000;

    vert[2].x     = rect.right-10;
    vert[2].y     =  30;
    vert[2].Red   = 0xc000;
    vert[2].Green = 0xc000;
    vert[2].Blue  = 0xc000;
    vert[2].Alpha = 0xc000;

    vert[3].x     =  10;
    vert[3].y     =  30;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = 10;
    vert[0].y     = 40;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x6000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = rect.right-10;
    vert[1].y     =  40;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x6000;
    vert[1].Blue  = 0xf000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = rect.right-10;
    vert[2].y     = 200-10;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x6000;
    vert[2].Blue  = 0xf000;
    vert[2].Alpha = 0xf000;

    vert[3].x     =  10;
    vert[3].y     =  200-10;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x6000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);
    StretchBlt(hdc,0,0,rect.right,200,hdcm,0,0,rect.right,200,SRCCOPY);



    LocalFree(pbmi);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteObject(hpal);
    DeleteObject(hdib);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB8Halftone(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[8] = {{0,1,2},{0,2,3},
                                 {4,5,6},{4,6,7},
                                 {8,9,10},{8,10,11},
                                 {12,13,14},{12,14,15}
                                };
    TRIVERTEX vert[32];
    HPALETTE  hpal;
    RECT rect;
    RECT dibRect;
    HDC hdcm   = CreateCompatibleDC(hdc);
    HDC hdcm32 = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    PULONG  pulColors;
    LPPALETTEENTRY pePalette;
    HBITMAP hdib,hdib32;
    PBYTE   pDib,pDib32;
    ULONG   ulIndex;
    HBRUSH hbr = CreateSolidBrush(PALETTERGB(128,128,128));

    SetStretchBltMode(hdc,COLORONCOLOR);

    //
    // get screen dimensions
    //

    GetClientRect(pCallData->hwnd,&rect);

    //
    // dib dimensions are screen in x and 1/2 screen in y
    //

    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom/2;

    //
    // select and realize palette
    //

    hpal = CreateHalftonePalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);
    SelectPalette(hdcm,hpal,TRUE);
    RealizePalette(hdcm);
    SelectPalette(hdcm32,hpal,TRUE);
    RealizePalette(hdcm32);

    //
    // fill background
    //

    FillTransformedRect(hdc,&rect,hbr);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
    pulColors = (PULONG)&pbmi->bmiColors[0];
    pePalette = (LPPALETTEENTRY)pulColors;

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = dibRect.right;
    pbmi->bmiHeader.biHeight          = -dibRect.bottom;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 8;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    GetPaletteEntries(hpal,0,256,pePalette);

    for (ulIndex=0;ulIndex<256;ulIndex++)
    {
        BYTE temp = pePalette[ulIndex].peRed;
        pePalette[ulIndex].peRed  = pePalette[ulIndex].peBlue;
        pePalette[ulIndex].peBlue = temp;
    }

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    pbmi->bmiHeader.biBitCount        = 32;
    hdib32  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32,NULL,0);

    if ((hdib == NULL) || (hdib32 == NULL))
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }

        if (SelectObject(hdcm32,hdib32) == NULL)
        {
            MessageBox(NULL,"error selecting 32  bpp DIB","Error",MB_OK);
        }
    }

    //
    // init DIBs
    //

    FillTransformedRect(hdcm,&dibRect,hbr);
    FillTransformedRect(hdcm32,&dibRect,hbr);

    //
    // draw grey scale and r,g and b scales
    //

    {
        LONG ScaleHeight = (dibRect.bottom -50)/4;
        LONG ypos = 10;

        //
        // grey
        //

        vert[0].x     = 10;
        vert[0].y     = ypos;
        vert[0].Red   = 0x0000;
        vert[0].Green = 0x0000;
        vert[0].Blue  = 0x0000;
        vert[0].Alpha = 0x0000;

        vert[1].x     = rect.right-10;
        vert[1].y     = ypos;
        vert[1].Red   = 0xff00;
        vert[1].Green = 0xff00;
        vert[1].Blue  = 0xff00;
        vert[1].Alpha = 0x0000;

        vert[2].x     = rect.right-10;
        vert[2].y     = ypos + ScaleHeight;
        vert[2].Red   = 0xff00;
        vert[2].Green = 0xff00;
        vert[2].Blue  = 0xff00;
        vert[2].Alpha = 0x0000;

        vert[3].x     = 10;
        vert[3].y     = ypos + ScaleHeight;
        vert[3].Red   = 0x0000;
        vert[3].Green = 0x0000;
        vert[3].Blue  = 0x0000;
        vert[3].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        //
        // red
        //

        vert[4].x     = 10;
        vert[4].y     = ypos;
        vert[4].Red   = 0x0000;
        vert[4].Green = 0x0000;
        vert[4].Blue  = 0x0000;
        vert[4].Alpha = 0x0000;

        vert[5].x     = rect.right-10;
        vert[5].y     = ypos;
        vert[5].Red   = 0xff00;
        vert[5].Green = 0x0000;
        vert[5].Blue  = 0x0000;
        vert[5].Alpha = 0x0000;

        vert[6].x     = rect.right-10;
        vert[6].y     = ypos + ScaleHeight;
        vert[6].Red   = 0xff00;
        vert[6].Green = 0x0000;
        vert[6].Blue  = 0x0000;
        vert[6].Alpha = 0x0000;

        vert[7].x     = 10;
        vert[7].y     = ypos + ScaleHeight;
        vert[7].Red   = 0x0000;
        vert[7].Green = 0x0000;
        vert[7].Blue  = 0x0000;
        vert[7].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        vert[8].x     = 10;
        vert[8].y     = ypos;
        vert[8].Red   = 0x0000;
        vert[8].Green = 0x0000;
        vert[8].Blue  = 0x0000;
        vert[8].Alpha = 0x0000;

        vert[9].x     = rect.right-10;
        vert[9].y     = ypos;
        vert[9].Red   = 0x0000;
        vert[9].Green = 0xff00;
        vert[9].Blue  = 0x0000;
        vert[9].Alpha = 0x0000;

        vert[10].x     = rect.right-10;
        vert[10].y     = ypos + ScaleHeight;
        vert[10].Red   = 0x0000;
        vert[10].Green = 0xff00;
        vert[10].Blue  = 0x0000;
        vert[10].Alpha = 0x0000;

        vert[11].x     = 10;
        vert[11].y     = ypos + ScaleHeight;
        vert[11].Red   = 0x0000;
        vert[11].Green = 0x0000;
        vert[11].Blue  = 0x0000;
        vert[11].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        vert[12].x     = 10;
        vert[12].y     = ypos;
        vert[12].Red   = 0x0000;
        vert[12].Green = 0x0000;
        vert[12].Blue  = 0x0000;
        vert[12].Alpha = 0x0000;

        vert[13].x     = rect.right-10;
        vert[13].y     = ypos;
        vert[13].Red   = 0x0000;
        vert[13].Green = 0x0000;
        vert[13].Blue  = 0xff00;
        vert[13].Alpha = 0x0000;

        vert[14].x     = rect.right-10;
        vert[14].y     = ypos + ScaleHeight;
        vert[14].Red   = 0x0000;
        vert[14].Green = 0x0000;
        vert[14].Blue  = 0xff00;
        vert[14].Alpha = 0x0000;

        vert[15].x     = 10;
        vert[15].y     = ypos + ScaleHeight;
        vert[15].Red   = 0x0000;
        vert[15].Green = 0x0000;
        vert[15].Blue  = 0x0000;
        vert[15].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        GradientFill(hdcm  ,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);
        GradientFill(hdcm32,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);

        StretchBlt(hdc,0,0,rect.right,dibRect.bottom,hdcm,0,0,rect.right,dibRect.bottom,SRCCOPY);

        SetStretchBltMode(hdc,HALFTONE);

        StretchBlt(hdc,0,dibRect.bottom,rect.right,dibRect.bottom,hdcm32,0,0,rect.right,dibRect.bottom,SRCCOPY);

        SetStretchBltMode(hdc,COLORONCOLOR);
    }

    DeleteObject(hbr);
    LocalFree(pbmi);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteDC(hdcm32);
    DeleteObject(hpal);
    DeleteObject(hdib);
    DeleteObject(hdib32);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB8DefPal(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[8] = {{0,1,2},{0,2,3},
                                 {4,5,6},{4,6,7},
                                 {8,9,10},{8,10,11},
                                 {12,13,14},{12,14,15}
                                };
    TRIVERTEX vert[32];
    RECT rect;
    RECT dibRect;
    HDC hdcm   = CreateCompatibleDC(hdc);
    HDC hdcm32 = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    PULONG  pulColors;
    LPPALETTEENTRY pePalette;
    HBITMAP hdib,hdib32;
    PBYTE   pDib,pDib32;
    ULONG   ulIndex;
    HBRUSH hbr = CreateSolidBrush(PALETTERGB(128,128,128));

    SetStretchBltMode(hdc,COLORONCOLOR);

    //
    // get screen dimensions
    //

    GetClientRect(pCallData->hwnd,&rect);

    //
    // dib dimensions are screen in x and 1/2 screen in y
    //

    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom/2;

    //
    // fill background
    //

    FillTransformedRect(hdc,&rect,hbr);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    if (pbmi)
    {
        pulColors = (PULONG)&pbmi->bmiColors[0];
        pePalette = (LPPALETTEENTRY)pulColors;
    
        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = dibRect.right;
        pbmi->bmiHeader.biHeight          = -dibRect.bottom;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 8;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 16;
        pbmi->bmiHeader.biClrImportant    = 0;
    
        UINT uiRet = GetPaletteEntries((HPALETTE)GetStockObject(DEFAULT_PALETTE),0,16,pePalette);
    
        if (uiRet == 16)
        {
            for (ulIndex=0;ulIndex<16;ulIndex++)
            {
                BYTE temp = pePalette[ulIndex].peRed;
                pePalette[ulIndex].peRed  = pePalette[ulIndex].peBlue;
                pePalette[ulIndex].peBlue = temp;
            }
        
            hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);
        
            pbmi->bmiHeader.biBitCount        = 32;
            hdib32  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32,NULL,0);
        
            if ((hdib == NULL) || (hdib32 == NULL))
            {
                MessageBox(NULL,"error Creating DIB","Error",MB_OK);
            }
            else
            {
                if (SelectObject(hdcm,hdib) == NULL)
                {
                    MessageBox(NULL,"error selecting DIB","Error",MB_OK);
                }
        
                if (SelectObject(hdcm32,hdib32) == NULL)
                {
                    MessageBox(NULL,"error selecting 32  bpp DIB","Error",MB_OK);
                }
            }
        
            //
            // init DIBs
            //
        
            FillTransformedRect(hdcm,&dibRect,hbr);
            FillTransformedRect(hdcm32,&dibRect,hbr);
        
            //
            // draw grey scale and r,g and b scales
            //
        
            {
                LONG ScaleHeight = (dibRect.bottom -50)/4;
                LONG ypos = 10;
        
                //
                // grey
                //
        
                vert[0].x     = 10;
                vert[0].y     = ypos;
                vert[0].Red   = 0x0000;
                vert[0].Green = 0x0000;
                vert[0].Blue  = 0x0000;
                vert[0].Alpha = 0x0000;
        
                vert[1].x     = rect.right-10;
                vert[1].y     = ypos;
                vert[1].Red   = 0xff00;
                vert[1].Green = 0xff00;
                vert[1].Blue  = 0xff00;
                vert[1].Alpha = 0x0000;
        
                vert[2].x     = rect.right-10;
                vert[2].y     = ypos + ScaleHeight;
                vert[2].Red   = 0xff00;
                vert[2].Green = 0xff00;
                vert[2].Blue  = 0xff00;
                vert[2].Alpha = 0x0000;
        
                vert[3].x     = 10;
                vert[3].y     = ypos + ScaleHeight;
                vert[3].Red   = 0x0000;
                vert[3].Green = 0x0000;
                vert[3].Blue  = 0x0000;
                vert[3].Alpha = 0x0000;
        
                ypos += (10 + ScaleHeight);
        
                //
                // red
                //
        
                vert[4].x     = 10;
                vert[4].y     = ypos;
                vert[4].Red   = 0x0000;
                vert[4].Green = 0x0000;
                vert[4].Blue  = 0x0000;
                vert[4].Alpha = 0x0000;
        
                vert[5].x     = rect.right-10;
                vert[5].y     = ypos;
                vert[5].Red   = 0xff00;
                vert[5].Green = 0x0000;
                vert[5].Blue  = 0x0000;
                vert[5].Alpha = 0x0000;
        
                vert[6].x     = rect.right-10;
                vert[6].y     = ypos + ScaleHeight;
                vert[6].Red   = 0xff00;
                vert[6].Green = 0x0000;
                vert[6].Blue  = 0x0000;
                vert[6].Alpha = 0x0000;
        
                vert[7].x     = 10;
                vert[7].y     = ypos + ScaleHeight;
                vert[7].Red   = 0x0000;
                vert[7].Green = 0x0000;
                vert[7].Blue  = 0x0000;
                vert[7].Alpha = 0x0000;
        
                ypos += (10 + ScaleHeight);
        
                vert[8].x     = 10;
                vert[8].y     = ypos;
                vert[8].Red   = 0x0000;
                vert[8].Green = 0x0000;
                vert[8].Blue  = 0x0000;
                vert[8].Alpha = 0x0000;
        
                vert[9].x     = rect.right-10;
                vert[9].y     = ypos;
                vert[9].Red   = 0x0000;
                vert[9].Green = 0xff00;
                vert[9].Blue  = 0x0000;
                vert[9].Alpha = 0x0000;
        
                vert[10].x     = rect.right-10;
                vert[10].y     = ypos + ScaleHeight;
                vert[10].Red   = 0x0000;
                vert[10].Green = 0xff00;
                vert[10].Blue  = 0x0000;
                vert[10].Alpha = 0x0000;
        
                vert[11].x     = 10;
                vert[11].y     = ypos + ScaleHeight;
                vert[11].Red   = 0x0000;
                vert[11].Green = 0x0000;
                vert[11].Blue  = 0x0000;
                vert[11].Alpha = 0x0000;
        
                ypos += (10 + ScaleHeight);
        
                vert[12].x     = 10;
                vert[12].y     = ypos;
                vert[12].Red   = 0x0000;
                vert[12].Green = 0x0000;
                vert[12].Blue  = 0x0000;
                vert[12].Alpha = 0x0000;
        
                vert[13].x     = rect.right-10;
                vert[13].y     = ypos;
                vert[13].Red   = 0x0000;
                vert[13].Green = 0x0000;
                vert[13].Blue  = 0xff00;
                vert[13].Alpha = 0x0000;
        
                vert[14].x     = rect.right-10;
                vert[14].y     = ypos + ScaleHeight;
                vert[14].Red   = 0x0000;
                vert[14].Green = 0x0000;
                vert[14].Blue  = 0xff00;
                vert[14].Alpha = 0x0000;
        
                vert[15].x     = 10;
                vert[15].y     = ypos + ScaleHeight;
                vert[15].Red   = 0x0000;
                vert[15].Green = 0x0000;
                vert[15].Blue  = 0x0000;
                vert[15].Alpha = 0x0000;
        
                ypos += (10 + ScaleHeight);
        
                GradientFill(hdcm  ,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);
                GradientFill(hdcm32,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);
        
                StretchBlt(hdc,0,0,rect.right,dibRect.bottom,hdcm,0,0,rect.right,dibRect.bottom,SRCCOPY);
        
                SetStretchBltMode(hdc,HALFTONE);
        
                StretchBlt(hdc,0,dibRect.bottom,rect.right,dibRect.bottom,hdcm32,0,0,rect.right,dibRect.bottom,SRCCOPY);
        
                SetStretchBltMode(hdc,COLORONCOLOR);
            }
        }
    
        LocalFree(pbmi);
    }
    DeleteObject(hbr);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteDC(hdcm32);
    DeleteObject(hdib);
    DeleteObject(hdib32);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB4(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[8] = {{0,1,2},{0,2,3},
                                 {4,5,6},{4,6,7},
                                 {8,9,10},{8,10,11},
                                 {12,13,14},{12,14,15}
                                };
    TRIVERTEX vert[32];
    RECT rect;
    RECT dibRect;
    HDC hdcm   = CreateCompatibleDC(hdc);
    HDC hdcm32 = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    PULONG  pulColors;
    LPPALETTEENTRY pePalette;
    HBITMAP hdib,hdib32;
    PBYTE   pDib,pDib32;
    ULONG   ulIndex;
    HBRUSH hbr = CreateSolidBrush(PALETTERGB(128,128,128));

    SetStretchBltMode(hdc,COLORONCOLOR);

    //
    // get screen dimensions
    //

    GetClientRect(pCallData->hwnd,&rect);

    //
    // dib dimensions are screen in x and 1/2 screen in y
    //

    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom/2;

    //
    // fill background
    //

    FillTransformedRect(hdc,&rect,hbr);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
    pulColors = (PULONG)&pbmi->bmiColors[0];
    pePalette = (LPPALETTEENTRY)pulColors;

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = dibRect.right;
    pbmi->bmiHeader.biHeight          = -dibRect.bottom;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 4;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    GetSystemPaletteEntries(hdc,0,256,pePalette);

    for (ulIndex=0;ulIndex<8;ulIndex++)
    {
        BYTE temp = pePalette[ulIndex].peRed;
        pePalette[ulIndex].peRed  = pePalette[ulIndex].peBlue;
        pePalette[ulIndex].peBlue = temp;

        pePalette[8 + ulIndex].peGreen = pePalette[255-ulIndex].peGreen;
        pePalette[8 + ulIndex].peRed   = pePalette[255-ulIndex].peBlue;
        pePalette[8 + ulIndex].peBlue  = pePalette[255-ulIndex].peRed;
    }

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    pbmi->bmiHeader.biBitCount        = 32;
    hdib32  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32,NULL,0);

    if ((hdib == NULL) || (hdib32 == NULL))
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }

        if (SelectObject(hdcm32,hdib32) == NULL)
        {
            MessageBox(NULL,"error selecting 32  bpp DIB","Error",MB_OK);
        }
    }

    //
    // init DIBs
    //

    FillTransformedRect(hdcm,&dibRect,hbr);
    FillTransformedRect(hdcm32,&dibRect,hbr);

    //
    // draw grey scale and r,g and b scales
    //

    {
        LONG ScaleHeight = (dibRect.bottom -50)/4;
        LONG ypos = 10;

        //
        // grey
        //

        vert[0].x     = 10;
        vert[0].y     = ypos;
        vert[0].Red   = 0x0000;
        vert[0].Green = 0x0000;
        vert[0].Blue  = 0x0000;
        vert[0].Alpha = 0x0000;

        vert[1].x     = rect.right-10;
        vert[1].y     = ypos;
        vert[1].Red   = 0xff00;
        vert[1].Green = 0xff00;
        vert[1].Blue  = 0xff00;
        vert[1].Alpha = 0x0000;

        vert[2].x     = rect.right-10;
        vert[2].y     = ypos + ScaleHeight;
        vert[2].Red   = 0xff00;
        vert[2].Green = 0xff00;
        vert[2].Blue  = 0xff00;
        vert[2].Alpha = 0x0000;

        vert[3].x     = 10;
        vert[3].y     = ypos + ScaleHeight;
        vert[3].Red   = 0x0000;
        vert[3].Green = 0x0000;
        vert[3].Blue  = 0x0000;
        vert[3].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        //
        // red
        //

        vert[4].x     = 10;
        vert[4].y     = ypos;
        vert[4].Red   = 0x0000;
        vert[4].Green = 0x0000;
        vert[4].Blue  = 0x0000;
        vert[4].Alpha = 0x0000;

        vert[5].x     = rect.right-10;
        vert[5].y     = ypos;
        vert[5].Red   = 0xff00;
        vert[5].Green = 0x0000;
        vert[5].Blue  = 0x0000;
        vert[5].Alpha = 0x0000;

        vert[6].x     = rect.right-10;
        vert[6].y     = ypos + ScaleHeight;
        vert[6].Red   = 0xff00;
        vert[6].Green = 0x0000;
        vert[6].Blue  = 0x0000;
        vert[6].Alpha = 0x0000;

        vert[7].x     = 10;
        vert[7].y     = ypos + ScaleHeight;
        vert[7].Red   = 0x0000;
        vert[7].Green = 0x0000;
        vert[7].Blue  = 0x0000;
        vert[7].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        vert[8].x     = 10;
        vert[8].y     = ypos;
        vert[8].Red   = 0x0000;
        vert[8].Green = 0x0000;
        vert[8].Blue  = 0x0000;
        vert[8].Alpha = 0x0000;

        vert[9].x     = rect.right-10;
        vert[9].y     = ypos;
        vert[9].Red   = 0x0000;
        vert[9].Green = 0xff00;
        vert[9].Blue  = 0x0000;
        vert[9].Alpha = 0x0000;

        vert[10].x     = rect.right-10;
        vert[10].y     = ypos + ScaleHeight;
        vert[10].Red   = 0x0000;
        vert[10].Green = 0xff00;
        vert[10].Blue  = 0x0000;
        vert[10].Alpha = 0x0000;

        vert[11].x     = 10;
        vert[11].y     = ypos + ScaleHeight;
        vert[11].Red   = 0x0000;
        vert[11].Green = 0x0000;
        vert[11].Blue  = 0x0000;
        vert[11].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        vert[12].x     = 10;
        vert[12].y     = ypos;
        vert[12].Red   = 0x0000;
        vert[12].Green = 0x0000;
        vert[12].Blue  = 0x0000;
        vert[12].Alpha = 0x0000;

        vert[13].x     = rect.right-10;
        vert[13].y     = ypos;
        vert[13].Red   = 0x0000;
        vert[13].Green = 0x0000;
        vert[13].Blue  = 0xff00;
        vert[13].Alpha = 0x0000;

        vert[14].x     = rect.right-10;
        vert[14].y     = ypos + ScaleHeight;
        vert[14].Red   = 0x0000;
        vert[14].Green = 0x0000;
        vert[14].Blue  = 0xff00;
        vert[14].Alpha = 0x0000;

        vert[15].x     = 10;
        vert[15].y     = ypos + ScaleHeight;
        vert[15].Red   = 0x0000;
        vert[15].Green = 0x0000;
        vert[15].Blue  = 0x0000;
        vert[15].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        GradientFill(hdcm  ,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);
        GradientFill(hdcm32,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);

        StretchBlt(hdc,0,0,rect.right,dibRect.bottom,hdcm,0,0,rect.right,dibRect.bottom,SRCCOPY);

        SetStretchBltMode(hdc,HALFTONE);

        StretchBlt(hdc,0,dibRect.bottom,rect.right,dibRect.bottom,hdcm32,0,0,rect.right,dibRect.bottom,SRCCOPY);

        SetStretchBltMode(hdc,COLORONCOLOR);
    }

    DeleteObject(hbr);
    LocalFree(pbmi);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteDC(hdcm32);
    DeleteObject(hdib);
    DeleteObject(hdib32);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB1(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[8] = {{0,1,2},{0,2,3},
                                 {4,5,6},{4,6,7},
                                 {8,9,10},{8,10,11},
                                 {12,13,14},{12,14,15}
                                };
    TRIVERTEX vert[32];
    RECT rect;
    RECT dibRect;
    HDC hdcm   = CreateCompatibleDC(hdc);
    HDC hdcm32 = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    PULONG  pulColors;
    LPPALETTEENTRY pePalette;
    HBITMAP hdib,hdib32;
    PBYTE   pDib,pDib32;
    ULONG   ulIndex;
    HBRUSH hbr = CreateSolidBrush(PALETTERGB(128,128,128));

    SetStretchBltMode(hdc,COLORONCOLOR);

    //
    // get screen dimensions
    //

    GetClientRect(pCallData->hwnd,&rect);

    //
    // dib dimensions are screen in x and 1/2 screen in y
    //

    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom/2;

    //
    // fill background
    //

    FillTransformedRect(hdc,&rect,hbr);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));
    pulColors = (PULONG)&pbmi->bmiColors[0];
    pePalette = (LPPALETTEENTRY)pulColors;

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = dibRect.right;
    pbmi->bmiHeader.biHeight          = -dibRect.bottom;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 1;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    pePalette[0].peGreen = 0x00;
    pePalette[0].peRed   = 0x00;
    pePalette[0].peBlue  = 0x00;
    pePalette[0].peFlags = 0x00;

    pePalette[1].peGreen = 0xff;
    pePalette[1].peRed   = 0xff;
    pePalette[1].peBlue  = 0xff;
    pePalette[1].peFlags = 0x00;

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    pbmi->bmiHeader.biBitCount        = 32;
    hdib32  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib32,NULL,0);

    if ((hdib == NULL) || (hdib32 == NULL))
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }

        if (SelectObject(hdcm32,hdib32) == NULL)
        {
            MessageBox(NULL,"error selecting 32  bpp DIB","Error",MB_OK);
        }
    }

    //
    // init DIBs
    //

    FillTransformedRect(hdcm,&dibRect,hbr);
    FillTransformedRect(hdcm32,&dibRect,hbr);

    //
    // draw grey scale and r,g and b scales
    //

    {
        LONG ScaleHeight = (dibRect.bottom -50)/4;
        LONG ypos = 10;

        //
        // grey
        //

        vert[0].x     = 10;
        vert[0].y     = ypos;
        vert[0].Red   = 0x0000;
        vert[0].Green = 0x0000;
        vert[0].Blue  = 0x0000;
        vert[0].Alpha = 0x0000;

        vert[1].x     = rect.right-10;
        vert[1].y     = ypos;
        vert[1].Red   = 0xff00;
        vert[1].Green = 0xff00;
        vert[1].Blue  = 0xff00;
        vert[1].Alpha = 0x0000;

        vert[2].x     = rect.right-10;
        vert[2].y     = ypos + ScaleHeight;
        vert[2].Red   = 0xff00;
        vert[2].Green = 0xff00;
        vert[2].Blue  = 0xff00;
        vert[2].Alpha = 0x0000;

        vert[3].x     = 10;
        vert[3].y     = ypos + ScaleHeight;
        vert[3].Red   = 0x0000;
        vert[3].Green = 0x0000;
        vert[3].Blue  = 0x0000;
        vert[3].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        //
        // red
        //

        vert[4].x     = 10;
        vert[4].y     = ypos;
        vert[4].Red   = 0x0000;
        vert[4].Green = 0x0000;
        vert[4].Blue  = 0x0000;
        vert[4].Alpha = 0x0000;

        vert[5].x     = rect.right-10;
        vert[5].y     = ypos;
        vert[5].Red   = 0xff00;
        vert[5].Green = 0xff00;
        vert[5].Blue  = 0x0000;
        vert[5].Alpha = 0x0000;

        vert[6].x     = rect.right-10;
        vert[6].y     = ypos + ScaleHeight;
        vert[6].Red   = 0xff00;
        vert[6].Green = 0xff00;
        vert[6].Blue  = 0x0000;
        vert[6].Alpha = 0x0000;

        vert[7].x     = 10;
        vert[7].y     = ypos + ScaleHeight;
        vert[7].Red   = 0x0000;
        vert[7].Green = 0x0000;
        vert[7].Blue  = 0x0000;
        vert[7].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        vert[8].x     = 10;
        vert[8].y     = ypos;
        vert[8].Red   = 0x0000;
        vert[8].Green = 0x0000;
        vert[8].Blue  = 0x0000;
        vert[8].Alpha = 0x0000;

        vert[9].x     = rect.right-10;
        vert[9].y     = ypos;
        vert[9].Red   = 0x0000;
        vert[9].Green = 0xff00;
        vert[9].Blue  = 0x0000;
        vert[9].Alpha = 0x0000;

        vert[10].x     = rect.right-10;
        vert[10].y     = ypos + ScaleHeight;
        vert[10].Red   = 0x0000;
        vert[10].Green = 0xff00;
        vert[10].Blue  = 0x0000;
        vert[10].Alpha = 0x0000;

        vert[11].x     = 10;
        vert[11].y     = ypos + ScaleHeight;
        vert[11].Red   = 0x0000;
        vert[11].Green = 0x0000;
        vert[11].Blue  = 0x0000;
        vert[11].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        vert[12].x     = 10;
        vert[12].y     = ypos;
        vert[12].Red   = 0x0000;
        vert[12].Green = 0x0000;
        vert[12].Blue  = 0x0000;
        vert[12].Alpha = 0x0000;

        vert[13].x     = rect.right-10;
        vert[13].y     = ypos;
        vert[13].Red   = 0x0000;
        vert[13].Green = 0x0000;
        vert[13].Blue  = 0xff00;
        vert[13].Alpha = 0x0000;

        vert[14].x     = rect.right-10;
        vert[14].y     = ypos + ScaleHeight;
        vert[14].Red   = 0x0000;
        vert[14].Green = 0x0000;
        vert[14].Blue  = 0xff00;
        vert[14].Alpha = 0x0000;

        vert[15].x     = 10;
        vert[15].y     = ypos + ScaleHeight;
        vert[15].Red   = 0x0000;
        vert[15].Green = 0x0000;
        vert[15].Blue  = 0x0000;
        vert[15].Alpha = 0x0000;

        ypos += (10 + ScaleHeight);

        GradientFill(hdcm  ,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);
        GradientFill(hdcm32,vert,16,(PVOID)gTri,8,GRADIENT_FILL_TRIANGLE);

        StretchBlt(hdc,0,0,rect.right,dibRect.bottom,hdcm,0,0,rect.right,dibRect.bottom,SRCCOPY);

        SetStretchBltMode(hdc,HALFTONE);

        StretchBlt(hdc,0,dibRect.bottom,rect.right,dibRect.bottom,hdcm32,0,0,rect.right,dibRect.bottom,SRCCOPY);

        SetStretchBltMode(hdc,COLORONCOLOR);
    }

    DeleteObject(hbr);
    LocalFree(pbmi);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteDC(hdcm32);
    DeleteObject(hdib);
    DeleteObject(hdib32);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB16565(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{0,2,3}};
    TRIVERTEX vert[32];
    HPALETTE  hpal;
    RECT rect;
    RECT dibRect;
    HDC hdcm = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    HBITMAP hdib;
    PBYTE   pDib;

    SetStretchBltMode(hdc,COLORONCOLOR);

    //
    // clear screen
    //

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));


    //
    // select and realize palette
    //

    hpal = CreateHalftonePalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 3 * sizeof(ULONG));

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = rect.right;
    pbmi->bmiHeader.biHeight          = -200;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 16;
    pbmi->bmiHeader.biCompression     = BI_BITFIELDS;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    {
        PULONG pbitfields = (PULONG)&pbmi->bmiColors[0];
        pbitfields[0] = 0xf800;
        pbitfields[1] = 0x07e0;
        pbitfields[2] = 0x001f;
    }

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }
    }

    vert[0].x     = 10;
    vert[0].y     = 10;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = rect.right-10;
    vert[1].y     =  10;
    vert[1].Red   = 0xc000;
    vert[1].Green = 0xc000;
    vert[1].Blue  = 0xc000;
    vert[1].Alpha = 0xc000;

    vert[2].x     = rect.right-10;
    vert[2].y     =  30;
    vert[2].Red   = 0xc000;
    vert[2].Green = 0xc000;
    vert[2].Blue  = 0xc000;
    vert[2].Alpha = 0xc000;

    vert[3].x     =  10;
    vert[3].y     =  30;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = 10;
    vert[0].y     = 40;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x6000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = rect.right-10;
    vert[1].y     =  40;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x6000;
    vert[1].Blue  = 0xf000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = rect.right-10;
    vert[2].y     = 200-10;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x6000;
    vert[2].Blue  = 0xf000;
    vert[2].Alpha = 0xf000;

    vert[3].x     =  10;
    vert[3].y     =  200-10;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x6000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);
    StretchBlt(hdc,0,0,rect.right,200,hdcm,0,0,rect.right,200,SRCCOPY);

    LocalFree(pbmi);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteObject(hpal);
    DeleteObject(hdib);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    18-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestTriDIB16555(
    TEST_CALL_DATA *pCallData
    )
{
    HDC       hdc     = GetDCAndTransform(pCallData->hwnd);
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{0,2,3}};
    TRIVERTEX vert[32];
    HPALETTE  hpal;
    RECT rect;
    RECT dibRect;
    HDC hdcm = CreateCompatibleDC(hdc);
    PBITMAPINFO pbmi;
    HBITMAP hdib;
    PBYTE   pDib;

    SetStretchBltMode(hdc,COLORONCOLOR);
    SetGraphicsMode(hdc,GM_ADVANCED);

    //
    // clear screen
    //

    GetClientRect(pCallData->hwnd,&rect);
    dibRect.left   = 0;
    dibRect.right  = rect.right;
    dibRect.top    = 0;
    dibRect.bottom = rect.bottom;

    FillTransformedRect(hdc,&rect,(HBRUSH)GetStockObject(BLACK_BRUSH));


    //
    // select and realize palette
    //

    hpal = CreateHalftonePalette(hdc);
    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // create temp DIB
    //

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 3 * sizeof(ULONG));

    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = rect.right;
    pbmi->bmiHeader.biHeight          = -200;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = 16;
    pbmi->bmiHeader.biCompression     = BI_BITFIELDS;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;

    {
        PULONG pbitfields = (PULONG)&pbmi->bmiColors[0];
        pbitfields[0] = 0x7c00;
        pbitfields[1] = 0x03e0;
        pbitfields[2] = 0x001f;
    }

    hdib  = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"error Creating DIB","Error",MB_OK);
    }
    else
    {
        if (SelectObject(hdcm,hdib) == NULL)
        {
            MessageBox(NULL,"error selecting DIB","Error",MB_OK);
        }
    }

    vert[0].x     = 10;
    vert[0].y     = 10;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = rect.right-10;
    vert[1].y     =  10;
    vert[1].Red   = 0xc000;
    vert[1].Green = 0xc000;
    vert[1].Blue  = 0xc000;
    vert[1].Alpha = 0xc000;

    vert[2].x     = rect.right-10;
    vert[2].y     =  30;
    vert[2].Red   = 0xc000;
    vert[2].Green = 0xc000;
    vert[2].Blue  = 0xc000;
    vert[2].Alpha = 0xc000;

    vert[3].x     =  10;
    vert[3].y     =  30;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    vert[0].x     = 10;
    vert[0].y     = 40;
    vert[0].Red   = 0x0000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x6000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = rect.right-10;
    vert[1].y     =  40;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0x6000;
    vert[1].Blue  = 0xf000;
    vert[1].Alpha = 0x0000;

    vert[2].x     = rect.right-10;
    vert[2].y     = 200-10;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x6000;
    vert[2].Blue  = 0xf000;
    vert[2].Alpha = 0xf000;

    vert[3].x     =  10;
    vert[3].y     =  200-10;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x0000;
    vert[3].Blue  = 0x6000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdcm,vert,4,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);
    StretchBlt(hdc,0,0,rect.right,200,hdcm,0,0,rect.right,200,SRCCOPY);

    LocalFree(pbmi);
    ReleaseDC(pCallData->hwnd,hdc);
    DeleteDC(hdcm);
    DeleteObject(hpal);
    DeleteObject(hdib);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
* vDrawMetafile
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vDrawMetafile(
    HDC     hdc,
    HDC     hdcm
    )
{
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{0,2,3}};
    TRIVERTEX vert[4];

    //
    // draw using alpha and shading APIs
    //

    vert[0].x     = 10;
    vert[0].y     = 10;
    vert[0].Red   = 0x4000;
    vert[0].Green = 0x8000;
    vert[0].Blue  = 0xc000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 390;
    vert[1].y     = 10;
    vert[1].Red   = 0xc000;
    vert[1].Green = 0x8000;
    vert[1].Blue  = 0x4000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = 390;
    vert[2].y     = 390;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0x0000;
    vert[2].Alpha = 0xff00;

    vert[3].x     =  10;
    vert[3].y     =  390;
    vert[3].Red   =  0x0000;
    vert[3].Green =  0x0000;
    vert[3].Blue  =  0xff00;
    vert[3].Alpha =  0xff00;

    PatBlt(hdcm,000,000,400,400,BLACKNESS);
    GradientFill(hdcm,vert,6,(PVOID)gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // alpha blending
    //

    {
        PBITMAPINFO   pbmi;
        HBITMAP       hdibA;
        HDC           hdcA = CreateCompatibleDC(hdc);
        PULONG        pDibA;
        BLENDFUNCTION BlendFunction;

        pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth           = 128;
        pbmi->bmiHeader.biHeight          = -128;
        pbmi->bmiHeader.biPlanes          = 1;
        pbmi->bmiHeader.biBitCount        = 32;
        pbmi->bmiHeader.biCompression     = BI_RGB;
        pbmi->bmiHeader.biSizeImage       = 0;
        pbmi->bmiHeader.biXPelsPerMeter   = 0;
        pbmi->bmiHeader.biYPelsPerMeter   = 0;
        pbmi->bmiHeader.biClrUsed         = 0;
        pbmi->bmiHeader.biClrImportant    = 0;

        hdibA = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibA,NULL,0);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.BlendFlags          = 0;
        BlendFunction.SourceConstantAlpha = 128;

        //
        // init 32 bpp dib
        //

        {
            PULONG ptmp = pDibA;
            ULONG ux,uy;

            for (uy=0;uy<128;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    BYTE blue  = (ux*2);
                    BYTE green = (uy*2);
                    BYTE red   = 0;
                    BYTE alpha = 0xff;
                    *ptmp++ = (alpha << 24) | (red << 16) | (green << 8) | (blue);
                }
            }

            *((PULONG)pDibA) = 0x80800000;

            ptmp = (PULONG)((PBYTE)pDibA + 32 * (128 *4));

            for (uy=32;uy<42;uy++)
            {
                for (ux=0;ux<128;ux++)
                {
                    *ptmp++ = 0x80800000;
                }
            }
        }

        HPALETTE hpal = CreateHalftonePalette(hdc);

        SelectObject(hdcA,hdibA);

        HPALETTE hpalOld = SelectPalette(hdcm,hpal,FALSE);

        SelectPalette(hdcA,hpal,FALSE);


        RealizePalette(hdcm);
        RealizePalette(hdcA);

        AlphaBlend(hdcm,100,100,128,128,hdcA, 0,0,128,128,BlendFunction);
        BitBlt(hdcm,100,250,128,128,hdcA,0,0,SRCCOPY);
        AlphaBlend(hdcm,250,250,128,128,hdcA, 0,0,128,128,BlendFunction);

        {
            RECT rcl = {10,60,100,100};
            DrawTextExW(hdcm,L"Fred",4,&rcl,0,NULL);
        }


        DeleteDC(hdcA);

        DeleteObject(hdibA);

        SelectPalette(hdcm,hpalOld,TRUE);


        DeleteObject(hpal);
        LocalFree(pbmi);
    }
}

/******************************Public*Routine******************************\
* vCreateMetaFile
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vCreateMetaFile(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc = GetDCAndTransform(pCallData->hwnd);
    HDC     hdcm;
    RECT    rcl;
    ULONG   ypos = 0;
    ULONG   xpos = 0;
    LPCTSTR lpFilename = "MetaBlend.EMF";
    LPCTSTR lpDescription = "Alpha Blending test metafile";

    GetClientRect(pCallData->hwnd,&rcl);
    FillTransformedRect(hdc,&rcl,(HBRUSH)GetStockObject(GRAY_BRUSH));

    SetTextColor(hdc,0);
    SetBkMode(hdc,TRANSPARENT);

    //
    // Create metafile DC
    //

    hdcm = CreateEnhMetaFile(hdc,lpFilename,NULL,lpDescription);

    if (hdcm != NULL)
    {
        vDrawMetafile(hdc,hdcm);
        vDrawMetafile(hdc,hdc);

        {
            HENHMETAFILE hemf = CloseEnhMetaFile(hdcm);

            if (hemf)
            {
                PCHAR pstr = "Metafile creation successful";
                DeleteEnhMetaFile(hemf);
                TextOut(hdc,10,10,pstr,strlen(pstr));
            }
            else
            {
                MessageBox(NULL,"Error closing metafile","Error",MB_OK);
            }
        }
    }
    else
    {
        MessageBox(NULL,"Error creating metafile","Error",MB_OK);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
* vPlayMetaFile
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    12/4/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vPlayMetaFile(
    TEST_CALL_DATA *pCallData
    )
{

    HDC  hdc     = GetDCAndTransform(pCallData->hwnd);
    RECT rcl;
    ULONG ypos = 0;
    ULONG xpos = 0;
    LPCTSTR lpFilename = "MetaBlend.EMF";
    LPCTSTR lpDescription = "Alpha Blending test metafile";
    HENHMETAFILE hemf;

    GetClientRect(pCallData->hwnd,&rcl);
    FillTransformedRect(hdc,&rcl,(HBRUSH)GetStockObject(GRAY_BRUSH));

    SetTextColor(hdc,0);
    SetBkMode(hdc,TRANSPARENT);

    hemf = GetEnhMetaFile(lpFilename);


    if (hemf)
    {
        rcl.left   = 0;
        rcl.top    = 0;
        rcl.right  = 16;
        rcl.bottom = 16;

        PlayEnhMetaFile(hdc,hemf,&rcl);

        rcl.left   = 16;
        rcl.top    = 16;
        rcl.right  = 80;
        rcl.bottom = 80;

        PlayEnhMetaFile(hdc,hemf,&rcl);

        rcl.left   = 100;
        rcl.top    = 0;
        rcl.right  = 500;
        rcl.bottom = 400;

        PlayEnhMetaFile(hdc,hemf,&rcl);
        DeleteEnhMetaFile(hemf);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
* vTestRASDD
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    9/19/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestRASDD(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdcScreen = GetDCAndTransform(pCallData->hwnd);
    HDC     hdcPrn;
    RECT    rcl;
    ULONG   ypos = 0;
    ULONG   xpos = 0;
    LPCTSTR lpPrinterName = "HP Color";
    DOCINFO docInfo = {sizeof(DOCINFO),
                       "Doc1",
                       NULL
                       };



    hdcPrn = CreateDC(NULL,lpPrinterName,NULL,NULL);

    if (hdcPrn == NULL)
    {
        MessageBox(NULL,"Couldn't create DC",lpPrinterName,MB_OK);
    }
    else
    {

        LONG iJobID = StartDoc(hdcPrn,&docInfo);

        if (iJobID == SP_ERROR)
        {
            MessageBox(NULL,"StartDoc fails","error",MB_OK);
        }
        else
        {
            LONG iRet = StartPage(hdcPrn);

            if (iRet == SP_ERROR)
            {
                MessageBox(NULL,"StartPage fails","error",MB_OK);
            }
            else
            {
                ULONG ulIndex = 0;

                HBITMAP hbmPrn1    = hCreateAlphaStretchBitmap(hdcPrn,ulBpp[ulIndex],ulFor[ulIndex],600,600); 
                HDC     hdcPrnMem1 = CreateCompatibleDC(hdcPrn);

                HBITMAP hbmPrn2    = hCreateAlphaStretchBitmap(hdcPrn,ulBpp[ulIndex],ulFor[ulIndex],600,600);  
                HDC     hdcPrnMem2 = CreateCompatibleDC(hdcPrn);

                HBITMAP hbm1         = CreateCompatibleBitmap(hdcScreen,600,600);
                HDC     hdcScreenMem = CreateCompatibleDC(hdcScreen);

                GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{3,4,5}};
                GRADIENT_RECT     gRect[2] = {{0,1},{2,3}};
                TRIVERTEX vert[6];

                //
                // draw using alpha and shading APIs
                //

                POINT  pos     = {300,300};
                double fr      = 300.0;
                double fTheta  = 0.0;
                double fdTheta = 0.05;
            
                SelectObject(hdcPrnMem1,hbmPrn1);
                SelectObject(hdcPrnMem2,hbmPrn2);
                SelectObject(hdcScreenMem,hbm1);
            
                PatBlt(hdcPrnMem1,0,0,5000,5000,0xff0000);
                PatBlt(hdcPrnMem2,0,0,5000,5000,0xff0000);
                PatBlt(hdcScreenMem,0,0,5000,5000,0xff0000);
                PatBlt(hdcScreen,0,0,5000,5000,0xff0000);
                PatBlt(hdcPrn,0,0,5000,5000,0xff0000);

                //
                // fill visible area with gradient
                //

                vert[0].x     = 0;
                vert[0].y     = 0;
                vert[0].Red   = 0x8000;
                vert[0].Green = 0x8000;
                vert[0].Blue  = 0x8000;
                vert[0].Alpha = 0x0000;

                vert[1].x     = 900;
                vert[1].y     = 900;
                vert[1].Red   = 0xc000;
                vert[1].Green = 0xc000;
                vert[1].Blue  = 0xc000;
                vert[1].Alpha = 0x0000;

                GradientFill(hdcScreen   ,vert,2,&gRect,1,GRADIENT_FILL_RECT_V);
                GradientFill(hdcPrn      ,vert,2,&gRect,1,GRADIENT_FILL_RECT_V);
                GradientFill(hdcPrnMem1  ,vert,2,&gRect,1,GRADIENT_FILL_RECT_V);
                GradientFill(hdcPrnMem2  ,vert,2,&gRect,1,GRADIENT_FILL_RECT_V);
                GradientFill(hdcScreenMem,vert,2,&gRect,1,GRADIENT_FILL_RECT_V);

                vert[0].x     = 200;
                vert[0].y     = 200;
                vert[0].Red   = 0x1000;
                vert[0].Green = 0x1000;
                vert[0].Blue  = 0x1000;
                vert[0].Alpha = 0x0000;

                vert[1].x     = 300;
                vert[1].y     = 700;
                vert[1].Red   = 0x2000;
                vert[1].Green = 0x2000;
                vert[1].Blue  = 0x2000;
                vert[1].Alpha = 0x0000;

                vert[2].x     = 140;
                vert[2].y     = 420;
                vert[2].Red   = 0x1500;
                vert[2].Green = 0x1500;
                vert[2].Blue  = 0x1500;
                vert[2].Alpha = 0x0000;

                vert[3].x     = 200;
                vert[3].y     = 200;
                vert[3].Red   = 0x1000;
                vert[3].Green = 0x1000;
                vert[3].Blue  = 0x1000;
                vert[3].Alpha = 0x0000;

                vert[4].x     = 100;
                vert[4].y     = 700;
                vert[4].Red   = 0x2000;
                vert[4].Green = 0x2000;
                vert[4].Blue  = 0x2000;
                vert[4].Alpha = 0x0000;

                vert[5].x     = 260;
                vert[5].y     = 420;
                vert[5].Red   = 0x1500;
                vert[5].Green = 0x1500;
                vert[5].Blue  = 0x1500;
                vert[5].Alpha = 0x0000;

                GradientFill(hdcScreen,vert,6,&gTri,2,GRADIENT_FILL_TRIANGLE);
                GradientFill(hdcPrn,vert,6,&gTri,2,GRADIENT_FILL_TRIANGLE);
                GradientFill(hdcPrnMem1,vert,6,&gTri,2,GRADIENT_FILL_TRIANGLE);

                Sleep(2000);
            
                //
                // draw gradient circle in memory
                //

                vert[0].x     = pos.x;
                vert[0].y     = pos.y;
                vert[0].Red   = 0x6000;
                vert[0].Green = 0x6000;
                vert[0].Blue  = 0x6000;
                vert[0].Alpha = 0x0000;
            
                vert[1].Red   = 0xcf00;
                vert[1].Green = 0xcf00;
                vert[1].Blue  = 0xcf00;
                vert[1].Alpha = 0x0000;
            
                vert[2].Red   = 0xcf00;
                vert[2].Green = 0xcf00;
                vert[2].Blue  = 0xcf00;
                vert[2].Alpha = 0x0000;
            
                fTheta  = 0;
                double fLimit = (2.0 * fdTheta) * 4.0;
            
                while (fTheta < (2.0 * 3.14159265))
                {
                    vert[0].x     = pos.x;
                    vert[0].y     = pos.y;

                    vert[1].x     = (LONG)(pos.x + fr * cos(fTheta));
                    vert[1].y     = (LONG)(pos.y + fr * sin(fTheta)); 
            
                    fTheta += fdTheta;
            
                    vert[2].x     = (LONG)(pos.x + fr * cos(fTheta));
                    vert[2].y     = (LONG)(pos.y + fr * sin(fTheta)); 

                    GradientFill(hdcPrnMem2  ,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
                    GradientFill(hdcScreenMem,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);

                    vert[0].x *= 2;
                    vert[0].y  = 2 * vert[0].y + 2000;
                    vert[1].x *= 2;
                    vert[1].y  = 2 * vert[1].y + 2000; 
                    vert[2].x *= 2;
                    vert[2].y  = 2 * vert[2].y + 2000; 

                    GradientFill(hdcPrn,vert,3,&gTri,1,GRADIENT_FILL_TRIANGLE);
                }

                //
                // blend alpha over data (0/1 in 1bpp)
                //

                {
                    BLENDFUNCTION BlendFunction;

                    BlendFunction.BlendOp             = AC_SRC_OVER;
                    BlendFunction.BlendFlags          = 0;
                    BlendFunction.AlphaFormat         = 0;

                    //
                    //  blend printer data
                    //

                    SetStretchBltMode(hdcScreen,HALFTONE);
                    SetStretchBltMode(hdcPrn,HALFTONE);

                    BlendFunction.SourceConstantAlpha = 0x10;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,1000,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);

                    Sleep(1000);

                    BlendFunction.SourceConstantAlpha = 0x40;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,2000,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);

                    Sleep(1000);

                    BlendFunction.SourceConstantAlpha = 0x70;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,3000,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                           
                    Sleep(1000);

                    BlendFunction.SourceConstantAlpha = 0xa0;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,4000,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);

                    Sleep(1000);

                    BlendFunction.SourceConstantAlpha = 0xc0;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,0000,1000,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);

                    Sleep(1000);

                    BlendFunction.SourceConstantAlpha = 0xe0;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,1000,1000,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);

                    Sleep(1000);

                    BlendFunction.SourceConstantAlpha = 0xfe;
                    AlphaBlend(hdcPrnMem1,0,0,600,600,hdcPrnMem2,0,0,600,600,BlendFunction);
                    StretchBlt(hdcPrn,2000,1000,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem1,0,0,900,900,SRCCOPY);

                    Sleep(1000);

                    StretchBlt(hdcPrn,30000,1000,900,900,hdcPrnMem2,0,0,900,900,SRCCOPY);
                    StretchBlt(hdcScreen,0,0,900,900,hdcPrnMem2,0,0,900,900,SRCCOPY);
                }

                DeleteDC(hdcPrnMem1);
                DeleteDC(hdcPrnMem2);
                DeleteObject(hbmPrn1);
                DeleteObject(hbmPrn2);
                DeleteDC(hdcScreenMem);
                DeleteObject(hbm1);
                EndPage(hdcPrn);
            }

            EndDoc(hdcPrn);
        }

        DeleteDC(hdcPrn);
    }

    ReleaseDC(pCallData->hwnd,hdcScreen);
    bThreadActive = FALSE;
}

VOID
vTestTranPrint(
    TEST_CALL_DATA *pCallData
    )
{
    HDC     hdc = GetDCAndTransform(pCallData->hwnd);
    HDC     hdcm;
    RECT    rcl;
    ULONG   ypos = 0;
    ULONG   xpos = 0;
    LPCTSTR lpPrinterName = "HP Color";
    DOCINFO docInfo = {sizeof(DOCINFO),
                       "Doc1",
                       NULL
                       };



    hdcm = CreateDC(NULL,lpPrinterName,NULL,NULL);

    if (hdcm == NULL)
    {
        MessageBox(NULL,"Couldn't create DC",lpPrinterName,MB_OK);
    }
    else
    {

        LONG iJobID = StartDoc(hdcm,&docInfo);

        if (iJobID == SP_ERROR)
        {
            MessageBox(NULL,"StartDoc fails","error",MB_OK);
        }
        else
        {
            LONG iRet = StartPage(hdcm);

            if (iRet == SP_ERROR)
            {
                MessageBox(NULL,"StartPage fails","error",MB_OK);
            }
            else
            {
                HBITMAP hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));
                HDC     hdcPrnMem2 = CreateCompatibleDC(hdcm);


                BitBlt (hdcm, 0, 0, 184, 170, hdcPrnMem2, 0, 0, SRCCOPY);

                SelectObject(hdcPrnMem2,hbm);

                DeleteDC(hdcPrnMem2);
                DeleteObject(hbm);
                EndPage(hdcm);
            }

            EndDoc(hdcm);
        }

        DeleteDC(hdcm);
    }

    ReleaseDC(pCallData->hwnd,hdc);
    bThreadActive = FALSE;
}


/**************************************************************************\
* vRunGradHorz
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    4/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vRunGradRectHorz(
    HDC     hdc,
    HBITMAP hdib,
    ULONG   ulRectMode
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 10;
    ULONG         dx    = 10;
    HPALETTE      hpal;
    RECT          rect;

    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    //
    //  create mem dc, select test DIBSection
    //

    ULONG   ux,uy;
    ULONG   dibx,diby;
    PULONG  pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    //
    // display over black
    //

    hpal = CreateHtPalette(hdc);

    SelectObject(hdcm,hdib);
    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);

    GRADIENT_RECT gRect = {0,1};
    TRIVERTEX vert[6];

    //
    // fill screen background
    //

    vert[0].x     = -101;
    vert[0].y     = -102;
    vert[0].Red   = 0x4000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x8000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 2000;
    vert[1].y     = 3004;
    vert[1].Red   = 0xff00;
    vert[1].Green = 0x0000;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0x0000;

    GradientFill(hdc,vert,2,(PVOID)&gRect,1,ulRectMode);

    //
    // test widths and heights 
    //

    diby = 16; 

    for (uy=0;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0x0000;
            vert[0].Blue  = 0x0000;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + ux;
            vert[1].y     = diby + ux;
            vert[1].Red   = 0xff00;
            vert[1].Green = 0x0000;
            vert[1].Blue  = 0xff00;
            vert[1].Alpha = 0x0000;

            GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    //
    // test Solid Widths and heights
    //

    xpos = xpos + (256 + 16);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0xff00;
            vert[0].Blue  = 0xff00;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + uy;
            vert[1].y     = diby + uy;
            vert[1].Red   = 0x0000;
            vert[1].Green = 0xff00;
            vert[1].Blue  = 0xff00;
            vert[1].Alpha = 0x0000;

            GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // xor copy
    //

    xpos += (256+16);

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);
    
    //
    // Draw same thing with solid brush and xor
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    HBRUSH hbrCyan = CreateSolidBrush(RGB(0,255,255));
    SelectObject(hdcm,hbrCyan);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            PatBlt(hdcm,dibx,diby,uy,uy,PATCOPY);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    DeleteObject(hbrCyan);

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // XOR
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,0x660000);


    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    //
    //
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x8000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 256;        
    vert[1].y     = 256;
    vert[1].Red   = 0x8000;
    vert[1].Green = 0x8000;
    vert[1].Blue  = 0x8000;
    vert[1].Alpha = 0x0000;

    GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //

    LONG OffsetX = 0;
    LONG OffsetY = 0;

    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while (OffsetX < 128)
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x8000;
        vert[0].Green = 0x0000 + (128 * OffsetX);
        vert[0].Blue  = 0x0000 + (128 * OffsetX);
        vert[0].Alpha = 0x0000;

        vert[1].x     = 256-OffsetX;        
        vert[1].y     = 256-OffsetY;
        vert[1].Red   = 0x8000;
        vert[1].Green = 0x8000 - (128 * OffsetX);
        vert[1].Blue  = 0x8000 - (128 * OffsetX);
        vert[1].Alpha = 0x0000;

        GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    // Use Complex Clip
    //
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    HRGN hrgn1 = CreateEllipticRgn(10,10,246,246);
    ExtSelectClipRgn(hdcm,hrgn1,RGN_COPY);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x8000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 256;        
    vert[1].y     = 256;
    vert[1].Red   = 0x8000;
    vert[1].Green = 0x8000;
    vert[1].Blue  = 0x8000;
    vert[1].Alpha = 0x0000;

    GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //

    OffsetX = 0;
    OffsetY = 0;

    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while (OffsetX < 128)
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x8000;
        vert[0].Green = 0x0000 + (128 * OffsetX);
        vert[0].Blue  = 0x0000 + (128 * OffsetX);
        vert[0].Alpha = 0x0000;

        vert[1].x     = 256-OffsetX;        
        vert[1].y     = 256-OffsetY;
        vert[1].Red   = 0x8000;
        vert[1].Green = 0x8000 - (128 * OffsetX);
        vert[1].Blue  = 0x8000 - (128 * OffsetX);
        vert[1].Alpha = 0x0000;

        GradientFill(hdcm,vert,2,(PVOID)&gRect,1,ulRectMode);

        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    ExtSelectClipRgn(hdcm,NULL,RGN_COPY);
    DeleteObject(hrgn1);

    xpos = 16;
    ypos += (256+16);

    SelectPalette(hdc,hpalOld,TRUE);

    DeleteObject(hdcm);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestGradHorz
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRectHorz(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunGradRectHorz(hdc,hdib,GRADIENT_FILL_RECT_H);
            DeleteObject(hdib);
        }
    }
    else
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunGradRectHorz(hdc,hdib,GRADIENT_FILL_RECT_H);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestGradVert
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradRectVert(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);
    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    ULONG    ulIndex = 0;

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    //
    // repeat for each src format
    //

    if (pCallData->Param != -1)
    {
        ulIndex = pCallData->Param;
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[ulIndex]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunGradRectHorz(hdc,hdib,GRADIENT_FILL_RECT_V);
            DeleteObject(hdib);
        }
    }
    else
    {
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunGradRectHorz(hdc,hdib,GRADIENT_FILL_RECT_V);
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }
    }


    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vRunGradTriangle
*   
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    4/17/1997 Mark Enstrom [marke]
*
\**************************************************************************/
VOID
vRunGradTriangle(
    HDC     hdc,
    HBITMAP hdib
    )
{
    ULONG         xpos  = 10;
    ULONG         ypos  = 10;
    ULONG         dy    = 10;
    ULONG         dx    = 10;
    HPALETTE      hpal;
    RECT          rect;

    SelectObject(hdc,hTestFont);

    //
    // Clear screen
    //

    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdc,0,0,2000,2000,PATCOPY);
    SelectObject(hdc,hbrFillCars);

    //
    //  create mem dc, select test DIBSection
    //

    ULONG   ux,uy;
    ULONG   dibx,diby;
    PULONG  pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    //
    // display over black
    //

    hpal = CreateHtPalette(hdc);


    SelectObject(hdcm,hdib);
    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    HPALETTE hpalOld = SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    SetTextColor(hdc,RGB(255,255,255));
    SetBkMode(hdc,TRANSPARENT);

    GRADIENT_TRIANGLE gTri[2] ={{0,1,2},{0,2,3}};
    TRIVERTEX vert[6];

    //
    // fill screen background
    //

    vert[0].x     = -101;
    vert[0].y     = -102;
    vert[0].Red   = 0x4000;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x8000;
    vert[0].Alpha = 0x0000;

    vert[1].x     = 2000;
    vert[1].y     = -102;
    vert[1].Red   = 0x4400;
    vert[1].Green = 0x4400;
    vert[1].Blue  = 0xff00;
    vert[1].Alpha = 0x0000;

    vert[2].x     = 2000;
    vert[2].y     = 1000;
    vert[2].Red   = 0xff00;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0x0000;

    vert[3].x     = -101;
    vert[3].y     = 1000;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0x4300;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    GradientFill(hdc,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // test widths and heights 
    //

    diby = 16; 

    for (uy=0;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0x0000;
            vert[0].Blue  = 0x0000;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + ux;
            vert[1].y     = diby;
            vert[1].Red   = 0xff00;
            vert[1].Green = 0x0000;
            vert[1].Blue  = 0x0000;
            vert[1].Alpha = 0x0000;

            vert[2].x     = dibx + ux;
            vert[2].y     = diby + ux;
            vert[2].Red   = 0xff00;
            vert[2].Green = 0x0000;
            vert[2].Blue  = 0xff00;
            vert[2].Alpha = 0x0000;

            vert[3].x     = dibx;        
            vert[3].y     = diby + ux;
            vert[3].Red   = 0x0000;
            vert[3].Green = 0x0000;
            vert[3].Blue  = 0xff00;
            vert[3].Alpha = 0x0000;

            GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);
    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    //
    // test Solid Widths and heights
    //

    xpos = xpos + (256 + 16);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            vert[0].x     = dibx;
            vert[0].y     = diby;
            vert[0].Red   = 0x0000;
            vert[0].Green = 0xff00;
            vert[0].Blue  = 0xff00;
            vert[0].Alpha = 0x0000;

            vert[1].x     = dibx + uy;
            vert[1].y     = diby;
            vert[1].Red   = 0x0000;
            vert[1].Green = 0xff00;
            vert[1].Blue  = 0xff00;
            vert[1].Alpha = 0x0000;

            vert[2].x     = dibx + uy;
            vert[2].y     = diby + uy;
            vert[2].Red   = 0x0000;
            vert[2].Green = 0xff00;
            vert[2].Blue  = 0xff00;
            vert[2].Alpha = 0x0000;

            vert[3].x     = dibx;
            vert[3].y     = diby + uy;
            vert[3].Red   = 0x0000;
            vert[3].Green = 0xff00;
            vert[3].Blue  = 0xff00;
            vert[3].Alpha = 0x0000;

            GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // xor copy
    //

    xpos += (256+16);

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);
    
    //
    // Draw same thing with solid brush and xor
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    HBRUSH hbrCyan = CreateSolidBrush(RGB(0,255,255));
    SelectObject(hdcm,hbrCyan);

    diby = 16;

    for (uy=1;uy<16;uy++)
    {
        dibx = 16;

        for (ux=1;ux<17;ux++)
        {
            PatBlt(hdcm,dibx,diby,uy,uy,PATCOPY);

            dibx = dibx + 17;
        }

        diby += 20;
    }

    SelectObject(hdcm,GetStockObject(DKGRAY_BRUSH));
    DeleteObject(hbrCyan);

    //
    // display
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // XOR
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,0x660000);


    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    //
    //
    //

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x0000;                   
    vert[0].Green = 0x0000;                   
    vert[0].Blue  = 0x0000;                   
    vert[0].Alpha = 0x0000;                   

    vert[1].x     = 256;        
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;                   
    vert[1].Green = 0x0000;                   
    vert[1].Blue  = 0x0000;                   
    vert[1].Alpha = 0x0000;                   

    vert[2].x     = 256;        
    vert[2].y     = 256;
    vert[2].Red   = 0xfe00;                   
    vert[2].Green = 0xfe00;                   
    vert[2].Blue  = 0xfe00;                   
    vert[2].Alpha = 0x0000;                   

    vert[3].x     = 0;        
    vert[3].y     = 256;
    vert[3].Red   = 0xfe00;                   
    vert[3].Green = 0xfe00;                   
    vert[3].Blue  = 0xfe00;                   
    vert[3].Alpha = 0x0000;                   

    GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //

    LONG OffsetX = 0;
    LONG OffsetY = 0;

    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while ((OffsetX < 100) && (OffsetY < 100))
    {
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x0000 + (254 * OffsetY);                   
        vert[0].Green = 0x0000 + (254 * OffsetY);                   
        vert[0].Blue  = 0x0000 + (254 * OffsetY);                   
        vert[0].Alpha = 0x0000;                   
    
        vert[1].x     = 256-OffsetX;        
        vert[1].y     = OffsetY;
        vert[1].Red   = 0x0000 + (254 * OffsetY);                   
        vert[1].Green = 0x0000 + (254 * OffsetY);                   
        vert[1].Blue  = 0x0000 + (254 * OffsetY);                   
        vert[1].Alpha = 0x0000;                   
    
        vert[2].x     = 256-OffsetX;        
        vert[2].y     = 256-OffsetY;
        vert[2].Red   = 0xfe00 - (254 * OffsetY);                   
        vert[2].Green = 0xfe00 - (254 * OffsetY);                   
        vert[2].Blue  = 0xfe00 - (254 * OffsetY);                   
        vert[2].Alpha = 0x0000;                   
    
        vert[3].x     = OffsetX;        
        vert[3].y     = 256-OffsetY;
        vert[3].Red   = 0xfe00 - (254 * OffsetY);                   
        vert[3].Green = 0xfe00 - (254 * OffsetY);                   
        vert[3].Blue  = 0xfe00 - (254 * OffsetY);                   
        vert[3].Alpha = 0x0000;                   

        GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);


        OffsetX += 9;
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    xpos = 16;
    ypos += (16+256);

    //
    // draw a single rectangle, then draw same rectangle by drawing
    // smaller rectangles inside each other. XOR to compare
    //
    //
    // Use Complex Clip
    //
    //

    PatBlt(hdcm,0,0,2000,2000,PATCOPY);

    HRGN hrgn1 = CreateEllipticRgn(10,10,246,246);
    ExtSelectClipRgn(hdcm,hrgn1,RGN_COPY);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0x0000;                   
    vert[0].Green = 0x0000;                   
    vert[0].Blue  = 0x0000;                   
    vert[0].Alpha = 0x0000;                   

    vert[1].x     = 256;        
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;                   
    vert[1].Green = 0x0000;                   
    vert[1].Blue  = 0x0000;                   
    vert[1].Alpha = 0x0000;                   

    vert[2].x     = 256;        
    vert[2].y     = 256;
    vert[2].Red   = 0xfe00;                   
    vert[2].Green = 0xfe00;                   
    vert[2].Blue  = 0xfe00;                   
    vert[2].Alpha = 0x0000;                   

    vert[3].x     = 0;        
    vert[3].y     = 256;
    vert[3].Red   = 0xfe00;                   
    vert[3].Green = 0xfe00;                   
    vert[3].Blue  = 0xfe00;                   
    vert[3].Alpha = 0x0000;                   

    GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos+256+16,ypos,256,256,hdcm,0,0,SRCCOPY);

    //
    // draw rectangles inside rectangles to test dither org
    //

    OffsetX = 0;
    OffsetY = 0;

    //
    // range in x = 256, range in color = 0xfe00 (256 * 128)
    //

    while ((OffsetX < 100) && (OffsetY < 100))
    {   
        vert[0].x     = OffsetX;
        vert[0].y     = OffsetY;
        vert[0].Red   = 0x0000 + (254 * OffsetY);                   
        vert[0].Green = 0x0000 + (254 * OffsetY);                   
        vert[0].Blue  = 0x0000 + (254 * OffsetY);                   
        vert[0].Alpha = 0x0000;                   
    
        vert[1].x     = 256-OffsetX;        
        vert[1].y     = OffsetY;
        vert[1].Red   = 0x0000 + (254 * OffsetY);                   
        vert[1].Green = 0x0000 + (254 * OffsetY);                   
        vert[1].Blue  = 0x0000 + (254 * OffsetY);                   
        vert[1].Alpha = 0x0000;                   
    
        vert[2].x     = 256-OffsetX;        
        vert[2].y     = 256-OffsetY;
        vert[2].Red   = 0xfe00 - (254 * OffsetY);                   
        vert[2].Green = 0xfe00 - (254 * OffsetY);                   
        vert[2].Blue  = 0xfe00 - (254 * OffsetY);                   
        vert[2].Alpha = 0x0000;                   
    
        vert[3].x     = OffsetX;        
        vert[3].y     = 256-OffsetY;
        vert[3].Red   = 0xfe00 - (254 * OffsetY);                   
        vert[3].Green = 0xfe00 - (254 * OffsetY);                   
        vert[3].Blue  = 0xfe00 - (254 * OffsetY);                   
        vert[3].Alpha = 0x0000;                   

        GradientFill(hdcm,vert,4,(PVOID)&gTri,2,GRADIENT_FILL_TRIANGLE);

        OffsetX += 9;         
        OffsetY += 9;
    }

    //
    // display copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,SRCCOPY);

    xpos += (256+16);

    //
    // xor copy
    //

    BitBlt(hdc,xpos,ypos,256,256,hdcm,0,0,0x660000);

    ExtSelectClipRgn(hdcm,NULL,RGN_COPY);
    DeleteObject(hrgn1);

    xpos = 16;
    ypos += (256+16);

    SelectPalette(hdc,hpalOld,TRUE);

    BOOL bRet1 = DeleteObject(hdcm);
    BOOL bRet2 = DeleteObject(hpal);

}

/**************************************************************************\
* vTestTriangle
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestGradTriangle(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);
    HPALETTE hpal = CreateHtPalette(hdc);


    CHAR     Title[256];
    CHAR     NewTitle[256];
    GetWindowText(pCallData->hwnd,Title,256);

    //
    // repeat for each src format
    //

    if (pCallData->Param != -1)
    {
        HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[pCallData->Param],ulFor[pCallData->Param],256,256);

        if (hdib != NULL)
        {
            lstrcpy(NewTitle,Title);
            lstrcat(NewTitle,pFormatStr[pCallData->Param]);
            SetWindowText(pCallData->hwnd,NewTitle);

            vRunGradTriangle(hdc,hdib);

            DeleteObject(hdib);
        }
    }
    else
    {
    
        ULONG    ulIndex = 0;
    
        SelectPalette(hdc,hpal,FALSE);
        RealizePalette(hdc);
    
        while (ulBpp[ulIndex] != 0)
        {
            HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[ulIndex],ulFor[ulIndex],256,256);
    
            if (hdib != NULL)
            {
                lstrcpy(NewTitle,Title);
                lstrcat(NewTitle,pFormatStr[ulIndex]);
                SetWindowText(pCallData->hwnd,NewTitle);
    
                vRunGradTriangle(hdc,hdib);
    
                DeleteObject(hdib);
            }
    
            Sleep(gAlphaSleep);
            ulIndex++;
        }

    }

    ReleaseDC(pCallData->hwnd,hdc);
    DeleteObject(hpal);
}

/**************************************************************************\
* vTestCaps
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestCaps(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);

    CHAR     Title[256];
    CHAR     NewTitle[256];

    ULONG ShadeCaps = GetDeviceCaps(hdc,SHADEBLENDCAPS);

    wsprintf(Title,"Caps = 0x%08lx",ShadeCaps);

    TextOut(hdc,10,10,Title,strlen(Title));

    ReleaseDC(pCallData->hwnd,hdc);
}

/**************************************************************************\
* vTestBrushOrg
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    4/11/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestBrushOrg(
    TEST_CALL_DATA *pCallData
    )
{
    HDC      hdc  = GetDCAndTransform(pCallData->hwnd);

    CHAR        Title[256];
    CHAR        NewTitle[256];
    PBYTE       pPack = (PBYTE)LocalAlloc(0,sizeof(BITMAPINFO) + 8*8*4);
    PBITMAPINFO pbmi  = (PBITMAPINFO)pPack;
    PBITMAPINFOHEADER pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;
    PULONG      pul   = (PULONG)(pPack + sizeof(BITMAPINFO));

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 8;
    pbmih->biHeight          = -8;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 32;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    //
    // init brush data
    //

    {
        int ix,iy;
        PULONG pulTmp = pul;

        for (iy=0;iy<8;iy++)
        {
            for (ix=0;ix<8;ix++)
            {
                *pul++ = (((iy * (256/8)) << 16) | (ix * (256/8)));
                //*pul++ = 0xffbb55;
            }
        }
    }


    HBITMAP  hdib = hCreateAlphaStretchBitmap(hdc,ulBpp[0],ulFor[0],256,256);
    HDC      hdcm = CreateCompatibleDC(hdc);
    SelectObject(hdcm,hdib);

    HBRUSH hbr = CreateDIBPatternBrushPt(pPack,DIB_RGB_COLORS);
    SelectObject(hdcm,hbr);

    PatBlt(hdcm,0,0,64,64,0);
    GdiFlush();

    SetBrushOrgEx(hdcm,0,0,NULL);
    GdiFlush();
    PatBlt(hdcm,0,0,8,8,PATCOPY);
    GdiFlush();

    SetBrushOrgEx(hdcm,1,1,NULL);
    GdiFlush();
    PatBlt(hdcm,0,16,8,8,PATCOPY);
    GdiFlush();

    SetBrushOrgEx(hdcm,0,0,NULL);
    GdiFlush();
    PatBlt(hdcm,0,32,8,8,PATCOPY);
    GdiFlush();

    SetBrushOrgEx(hdcm,4,4,NULL);
    GdiFlush();
    PatBlt(hdcm,0,48,8,8,PATCOPY);
    GdiFlush();


    BitBlt(hdc,0,0,64,64,hdcm,0,0,SRCCOPY);


    DeleteObject(hbr);
    DeleteDC(hdcm);
    DeleteObject(hdib);
    ReleaseDC(pCallData->hwnd,hdc);
}

/**************************************************************************\
* vTestDummy
*   
*   used in menu for locations that should no do anything
*   
* Arguments:
*   
*
*
* Return Value:
*
*
*
* History:
*
*    6/3/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTestDummy(
    TEST_CALL_DATA *pCallData
    )
{
    
}

//
// TEST_ENTRY controls automatic menu generation
//
// [Menu Level, Test Param, Stress Enable, Test Name, Test Function Pointer]
//
// Menu Level 
//      used to autoamtically generate sub-menus.
//      1   = 1rst level menu
//      -n  = start n-level sub menu
//      n   = continue sub menu
// 
// Test Param
//      passed as parameter to test
//
//
// Stress Ensable
//      if 1, test is run in stress mode
//      if 0, test is not run (tests that require input or runforever)
//
//  
// Test Name
//      ascii test name for menu
//  
// Test Function Pointer
//      pfn
//

TEST_ENTRY  gTestEntry[] = {
{ 1,  0,1,(PUCHAR)"vTestBrushOrg           ", (PFN_DISP)vTestBrushOrg},
{ 1,  0,1,(PUCHAR)"vTestCaps               ", (PFN_DISP)vTestCaps},
{ 1,  0,1,(PUCHAR)"vTestMenu               ", (PFN_DISP)vTestMenu},
{ 1,  0,1,(PUCHAR)"vTestDiamond            ", (PFN_DISP)vTestDiamond},
{-2,  0,1,(PUCHAR)"Test Circle Gradients   ", (PFN_DISP)vTestDummy},
{ 2,  0,1,(PUCHAR)"vTestCircle1            ", (PFN_DISP)vTestCircle1},
{ 2,  0,1,(PUCHAR)"vTestCircle2            ", (PFN_DISP)vTestCircle2},
{ 2,  0,1,(PUCHAR)"vTestCircle3            ", (PFN_DISP)vTestCircle3},
{ 1,  0,1,(PUCHAR)"vTestOverflow           ", (PFN_DISP)vTestOverflow},
{ 1,  0,1,(PUCHAR)"vTestTessel             ", (PFN_DISP)vTestTessel},
{ 1,  0,1,(PUCHAR)"vTestTri                ", (PFN_DISP)vTestTri   },
{-2,  0,1,(PUCHAR)"Grad Rect Tests         ", (PFN_DISP)vTestDummy },
{ 2,  0,1,(PUCHAR)"vTestGradRect1          ", (PFN_DISP)vTestGradRect1},
{ 2,  0,1,(PUCHAR)"vTestGradRect4          ", (PFN_DISP)vTestGradRect4},
{ 2,  0,1,(PUCHAR)"vTestGradRectH          ", (PFN_DISP)vTestGradRectH},
{ 2,  0,1,(PUCHAR)"vTestGradRectV          ", (PFN_DISP)vTestGradRectV},
{ 2,  0,1,(PUCHAR)"vTestGradMap            ", (PFN_DISP)vTestGradMap},
{-2,  0,1,(PUCHAR)"Multi-Res Tests         ", (PFN_DISP)vTestDummy},
{-3,  0,1,(PUCHAR)"Test Grad Triangle      ", (PFN_DISP)vTestDummy},
{ 3, -1,0,(PUCHAR)"vTestGradTriangle All   ", (PFN_DISP)vTestGradTriangle},
{ 3,  0,1,(PUCHAR)"vTestGradTriangle 32BGRA", (PFN_DISP)vTestGradTriangle},
{ 3,  1,1,(PUCHAR)"vTestGradTriangle 32RGB ", (PFN_DISP)vTestGradTriangle},
{ 3,  2,1,(PUCHAR)"vTestGradTriangle 32GRB ", (PFN_DISP)vTestGradTriangle},
{ 3,  3,1,(PUCHAR)"vTestGradTriangle 24    ", (PFN_DISP)vTestGradTriangle},
{ 3,  4,1,(PUCHAR)"vTestGradTriangle 16_555", (PFN_DISP)vTestGradTriangle},
{ 3,  5,1,(PUCHAR)"vTestGradTriangle 16_565", (PFN_DISP)vTestGradTriangle},
{ 3,  6,1,(PUCHAR)"vTestGradTriangle 16_664", (PFN_DISP)vTestGradTriangle},
{ 3,  7,1,(PUCHAR)"vTestGradTriangle 8     ", (PFN_DISP)vTestGradTriangle},
{ 3,  8,1,(PUCHAR)"vTestGradTriangle 4     ", (PFN_DISP)vTestGradTriangle},
{ 3,  9,1,(PUCHAR)"vTestGradTriangle 1     ", (PFN_DISP)vTestGradTriangle},
{-3,  0,1,(PUCHAR)"Test Grad Rect Horz     ", (PFN_DISP)vTestDummy},
{ 3, -1,0,(PUCHAR)"vTestGradRectHorz All   ", (PFN_DISP)vTestGradRectHorz},
{ 3,  0,1,(PUCHAR)"vTestGradRectHorz 32BGRA", (PFN_DISP)vTestGradRectHorz},
{ 3,  1,1,(PUCHAR)"vTestGradRectHorz 32RGB ", (PFN_DISP)vTestGradRectHorz},
{ 3,  2,1,(PUCHAR)"vTestGradRectHorz 32GRB ", (PFN_DISP)vTestGradRectHorz},
{ 3,  3,1,(PUCHAR)"vTestGradRectHorz 24    ", (PFN_DISP)vTestGradRectHorz},
{ 3,  4,1,(PUCHAR)"vTestGradRectHorz 16_555", (PFN_DISP)vTestGradRectHorz},
{ 3,  5,1,(PUCHAR)"vTestGradRectHorz 16_565", (PFN_DISP)vTestGradRectHorz},
{ 3,  6,1,(PUCHAR)"vTestGradRectHorz 16_664", (PFN_DISP)vTestGradRectHorz},
{ 3,  7,1,(PUCHAR)"vTestGradRectHorz 8     ", (PFN_DISP)vTestGradRectHorz},
{ 3,  8,1,(PUCHAR)"vTestGradRectHorz 4     ", (PFN_DISP)vTestGradRectHorz},
{ 3,  9,1,(PUCHAR)"vTestGradRectHorz 1     ", (PFN_DISP)vTestGradRectHorz},
{-3,  0,1,(PUCHAR)"Test Grad Rect Vert     ", (PFN_DISP)vTestDummy},
{ 3, -1,0,(PUCHAR)"vTestGradRectVert All   ", (PFN_DISP)vTestGradRectVert},
{ 3,  0,1,(PUCHAR)"vTestGradRectVert 32BGRA", (PFN_DISP)vTestGradRectVert},
{ 3,  1,1,(PUCHAR)"vTestGradRectVert 32RGB ", (PFN_DISP)vTestGradRectVert},
{ 3,  2,1,(PUCHAR)"vTestGradRectVert 32GRB ", (PFN_DISP)vTestGradRectVert},
{ 3,  3,1,(PUCHAR)"vTestGradRectVert 24    ", (PFN_DISP)vTestGradRectVert},
{ 3,  4,1,(PUCHAR)"vTestGradRectVert 16_555", (PFN_DISP)vTestGradRectVert},
{ 3,  5,1,(PUCHAR)"vTestGradRectVert 16_565", (PFN_DISP)vTestGradRectVert},
{ 3,  6,1,(PUCHAR)"vTestGradRectVert 16_664", (PFN_DISP)vTestGradRectVert},
{ 3,  7,1,(PUCHAR)"vTestGradRectVert 8     ", (PFN_DISP)vTestGradRectVert},
{ 3,  8,1,(PUCHAR)"vTestGradRectVert 4     ", (PFN_DISP)vTestGradRectVert},
{ 3,  9,1,(PUCHAR)"vTestGradRectVert 1     ", (PFN_DISP)vTestGradRectVert},
{-2,  0,1,(PUCHAR)"TRI DIB                 ", (PFN_DISP)vTestDummy },
{ 2,  0,1,(PUCHAR)"vTestTriDIB32           ", (PFN_DISP)vTestTriDIB32},
{ 2,  0,1,(PUCHAR)"vTestTriDIB16565        ", (PFN_DISP)vTestTriDIB16565},
{ 2,  0,1,(PUCHAR)"vTestTriDIB16555        ", (PFN_DISP)vTestTriDIB16555},
{ 2,  0,1,(PUCHAR)"vTestTriDIB8Halftone    ", (PFN_DISP)vTestTriDIB8Halftone},
{ 2,  0,1,(PUCHAR)"vTestTriDIB8DefPal      ", (PFN_DISP)vTestTriDIB8DefPal},
{-2,  0,1,(PUCHAR)"MetaFile                ", (PFN_DISP)vTestDummy },
{ 2,  0,1,(PUCHAR)"vCreateMetaFile         ", (PFN_DISP)vCreateMetaFile},
{ 2,  0,1,(PUCHAR)"vPlayMetaFile           ", (PFN_DISP)vPlayMetaFile},
{-2,  0,0,(PUCHAR)"Printing                ", (PFN_DISP)vTestDummy },
{ 2,  0,0,(PUCHAR)"vTestRASDD              ", (PFN_DISP)vTestRASDD},
{ 2,  0,0,(PUCHAR)"vTestTranPrint          ", (PFN_DISP)vTestTranPrint},
{ 1,  0,0,(PUCHAR)"vTestInputTri           ", (PFN_DISP)vTestInputTri},
{ 1,  0,0,(PUCHAR)"vTestRandTri            ", (PFN_DISP)vTestRandTri},
{-2,  0,0,(PUCHAR)"Test BltLnk Bug         ", (PFN_DISP)vTestDummy},
{ 2,  0,0,(PUCHAR)"vTestBitBlt             ", (PFN_DISP)vTestBitBlt},
{ 2,  0,0,(PUCHAR)"vTestBitBlt2            ", (PFN_DISP)vTestBitBlt2},
{ 2,  0,0,(PUCHAR)"vTestBitBlt3            ", (PFN_DISP)vTestBitBlt3},
{ 0,  0,1,(PUCHAR)"                        ", (PFN_DISP)vTestDummy}
};

ULONG gNumTests = sizeof(gTestEntry)/sizeof(TEST_ENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\lpk\lpk.c ===
/****************************************************************************
* Module Name: lpk.c
*
* Created: 21-Oct-1996
* Author: Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1990 Microsoft Corporation
*****************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <wingdip.h>

#define QUICK_BUFFER_SIZE  100

#ifdef DBG
#define WARNING(X)  DbgPrint(X);
#else
#define WARNING(X)
#endif


BOOL LpkInitialize()
{
    DbgPrint("Initialized LPK\n");
    return(TRUE);
}    


BOOL TranslateAndSubstitute(
    HDC hdc, 
    WORD *pGlyphIndexBuffer,
    WCHAR *pString,
    INT cCount
    )
{
    BOOL bRet = FALSE;
    WORD IndexForB = (WCHAR) 'B';
    int i;

    if(GetGlyphIndicesW(hdc, &IndexForB, 1, &IndexForB, 1) &&
       GetGlyphIndicesW(hdc, pString, cCount, pGlyphIndexBuffer, 0))
    {
        for(i = 0; i < cCount; i++)
        {
            if(pString[i] == (WCHAR) 'a')
            {
                pGlyphIndexBuffer[i] = IndexForB;
            }
        }

        bRet = TRUE;
    }
    
    return(bRet);
}


BOOL LpkExtTextOut(
    HDC         hdc,
    int         x,
    int         y,
    UINT        fuOptions,
    CONST RECT  *lprc,
    LPWSTR      lpString,
    UINT        cCount,
    CONST INT   *lpDx ,
    int         Charset
    )
{
    BOOL bRet = FALSE;
    USHORT GlyphIndexBuffer[QUICK_BUFFER_SIZE];
    USHORT *pGlyphIndexBuffer;
    
    pGlyphIndexBuffer = (cCount < QUICK_BUFFER_SIZE) ?
      GlyphIndexBuffer : LocalAlloc(LMEM_FIXED,cCount * sizeof(USHORT));
    
    if(pGlyphIndexBuffer)
    {
        if(TranslateAndSubstitute(hdc, pGlyphIndexBuffer, lpString, cCount))
        {

            bRet = ExtTextOutW(hdc, x, y, fuOptions | ETO_GLYPH_INDEX,
                               lprc,(WCHAR*) pGlyphIndexBuffer, cCount, lpDx);
        }
    }
    else
    {
        WARNING("LpkExtTextOut: out of memory\n");
        GdiSetLastError(ERROR_OUTOFMEMORY);
    }

    if(pGlyphIndexBuffer != GlyphIndexBuffer)
    {
        LocalFree(pGlyphIndexBuffer);
    }
    
    return(bRet);
}

        
           
                               
BOOL LpkGetTextExtentExPoint(
    HDC  hdc,         
    LPWSTR lpszStr,   
    int cchString ,   
    int nMaxExtent,   
    LPINT lpnFit,     
    LPINT alpDx,      
    LPSIZE lpSize,    
    FLONG fl,
    int Charset       
) 
{
    
    BOOL bRet = FALSE;
    USHORT GlyphIndexBuffer[QUICK_BUFFER_SIZE];
    USHORT *pGlyphIndexBuffer;
    REALIZATION_INFO ri;
    
    pGlyphIndexBuffer = (cchString < QUICK_BUFFER_SIZE) ?
      GlyphIndexBuffer : LocalAlloc(LMEM_FIXED,cchString * sizeof(USHORT));
    
    if(pGlyphIndexBuffer)
    {
        if(TranslateAndSubstitute(hdc, pGlyphIndexBuffer, lpszStr, cchString))
        {

            bRet = GetTextExtentExPointI(hdc, pGlyphIndexBuffer, cchString, nMaxExtent,
                                         lpnFit, alpDx, lpSize);
        }
    }
    else
    {
        WARNING("LpkGetTextExtentPointW: out of memory\n");
        GdiSetLastError(ERROR_OUTOFMEMORY);
    }
    
    if(pGlyphIndexBuffer != GlyphIndexBuffer)
    {
        LocalFree(pGlyphIndexBuffer);
    }

    return(bRet);
}


DWORD LpkGetCharacterPlacement(
    HDC hdc,
    LPWSTR lpString,
    int nCount,
    int nMaxExtent,
    LPGCP_RESULTS *lpResults,
    DWORD dwFlags,
    int Charset
    )
{
// not implemented for the sample LPK

    GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    
    return(0);
}


LONG LpkTabbedTextOut(
    HDC  hdc,
    int  x,
    int  y,
    LPWSTR  lpString,
    int  nCount,
    int  nTabPositions,
    LPINT  lpnTabStopPositions,
    int  nTabOrigin, 
    BOOL fDrawTheText,
    int cxCharWidth,
    int cyCharHeight,
    int Charset
) 
{
// not implemented for the sample LPK
    
    GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(0);                       
}

    

void LpkPSMTextOut(
    HDC hdc,
    int xLeft,
    int yTop,
    LPWSTR  lpString,
    int  nCount,
    int Charset
)
{
        
// not implemented for the sample LPK
    

}



LpkDrawTextEx(
    HDC hdc,
    LPWSTR lpString,
    int cchText,
    LPRECT lpRect,
    UINT format,
    LPDRAWTEXTPARAMS lpdtp,
    int Charset
)
{
    
// not implemented for the sample LPK
    
    GdiSetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(0);                           
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\imgtest\timer.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name

   test.c

Abstract:

    Small, independent windows test programs

Author:

   Mark Enstrom   (marke)  29-Apr-1996

Enviornment:

   User Mode

Revision History:

--*/


#include "precomp.h"
#include <stdlib.h>
#include "disp.h"
#include "resource.h"

/*++

Routine Description:

    Measure start count

Arguments



Return Value - Performance Count


--*/

_int64
BeginTimeMeasurement()
{
    _int64 PerformanceCount;
    extern BOOL gfPentium;
    extern BOOL gfUseCycleCount;

#ifdef _X86_
                if(gfPentium)
                    PerformanceCount = GetCycleCount();
                else
#endif
                QueryPerformanceCounter((LARGE_INTEGER *)&PerformanceCount);

    return(PerformanceCount);
}

/*++

Routine Description:

    Measure stop count and return the calculated time difference

Arguments

    StartTime   = Start Time Count
    Iter        = No. of Test Iterations

Return Value - Test Time per Iteration, in 100 nano-second units


--*/

ULONGLONG
EndTimeMeasurement(
    _int64  StartTime,
    ULONG      Iter)
{

   _int64 PerformanceCount;
   extern  _int64 PerformanceFreq;
   extern  BOOL gfPentium;

#ifdef _X86_
                if(gfPentium)
                {
                    PerformanceCount = GetCycleCount();
                    PerformanceCount -= CCNT_OVERHEAD;
                }
                else
#endif
                    QueryPerformanceCounter((LARGE_INTEGER *)&PerformanceCount);

   PerformanceCount -= StartTime ;

#ifdef _X86_
                if(gfPentium)
                    PerformanceCount /= Iter;
                else
#endif
                    PerformanceCount /= (PerformanceFreq * Iter);

   return((ULONGLONG)PerformanceCount);
}


/******************************Public*Routine******************************\
* vTimerAlpha32BGRAtoScreen255
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoScreen255(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    PULONG            pDib;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,TRUE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 255;

        PatBlt(hdc,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,256,256,hdcm, 0,0,256,256,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;
    pCallData->ullTestTime = StopTime;

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoMem255(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);


    HBITMAP           hdibS;
    HBITMAP           hdibD;
    ULONG             ux,uy;
    PULONG            pDibS;
    PULONG            pDibD;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcmS  = CreateCompatibleDC(hdc);
    HDC hdcmD  = CreateCompatibleDC(hdc);

    hdibS  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDibS,TRUE);
    hdibD  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDibD,TRUE);

    if ((hdibS == NULL) || (hdibD == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcmS,hdibS);
        SelectObject(hdcmD,hdibD);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcmS,hpal,FALSE);
        SelectPalette(hdcmD,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcmS);
        RealizePalette(hdcmD);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 255;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        PatBlt(hdc,0,0,2000,2000,0);
        for (ux=0;ux<256*256;ux++)
        {
            *(pDibD + ux) = 0xFF000000;
        }

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdcmD,0,0,256,256,hdcmS, 0,0,256,256,BlendFunction);
            //BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

        BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcmS);
    DeleteObject(hdcmD);
    DeleteObject(hdibS);
    DeleteObject(hdibD);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha32BGRAtoScreen128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoScreen128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    PULONG            pDib;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,TRUE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 128;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;


        //
        // begin timed segment
        //

        PatBlt(hdc,0,0,2000,2000,0);

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,256,256,hdcm, 0,0,256,256,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha32BGRAtoMem128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoMem128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdibS;
    HBITMAP           hdibD;
    ULONG             ux,uy;
    PULONG            pDibS;
    PULONG            pDibD;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcmS  = CreateCompatibleDC(hdc);
    HDC hdcmD  = CreateCompatibleDC(hdc);

    hdibS  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDibS,TRUE);
    hdibD  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDibD,TRUE);

    if ((hdibS == NULL) || (hdibD == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcmD,hdibD);
        SelectObject(hdcmS,hdibS);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcmS,hpal,FALSE);
        SelectPalette(hdcmD,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcmS);
        RealizePalette(hdcmD);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 128;
        BlendFunction.AlphaFormat         = AC_SRC_ALPHA;

        //
        // begin timed segment
        //

        PatBlt(hdc,0,0,2000,2000,0);
        for (ux=0;ux<256*256;ux++)
        {
            *(pDibD + ux) = 0xFF000000;
        }

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdcmD,0,0,256,256,hdcmS, 0,0,256,256,BlendFunction);
            //BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

        BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcmS);
    DeleteObject(hdcmD);
    DeleteObject(hdibS);
    DeleteObject(hdibD);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha32BGRAtoScreen128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoScreen128_NA(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    PULONG            pDib;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,TRUE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 128;
        BlendFunction.AlphaFormat         = 0;

        //
        // begin timed segment
        //

        PatBlt(hdc,0,0,2000,2000,0);

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,256,256,hdcm, 0,0,256,256,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha32BGRAtoMem128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoMem128_NA(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdibS;
    HBITMAP           hdibD;
    ULONG             ux,uy;
    PULONG            pDib;

    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcmS  = CreateCompatibleDC(hdc);
    HDC hdcmD  = CreateCompatibleDC(hdc);

    hdibS  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,TRUE);
    hdibD  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,TRUE);

    if ((hdibS == NULL) || (hdibD == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcmD,hdibD);
        SelectObject(hdcmS,hdibS);


        SelectPalette(hdc,hpal,FALSE);

        SelectPalette(hdcmS,hpal,FALSE);
        SelectPalette(hdcmD,hpal,FALSE);


        RealizePalette(hdc);

        RealizePalette(hdcmS);
        RealizePalette(hdcmD);


        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 128;
        BlendFunction.AlphaFormat         = 0;

        //
        // begin timed segment
        //

        PatBlt(hdc,0,0,2000,2000,0);
        PatBlt(hdcmD,0,0,2000,2000,0);

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdcmD,0,0,256,256,hdcmS, 0,0,256,256,BlendFunction);
            //BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

        BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcmS);
    DeleteObject(hdibS);
    DeleteObject(hdcmD);
    DeleteObject(hdibD);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}






















/******************************Public*Routine******************************\
* vTimerAlpha16_555toScreen128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha16_555toScreen128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbmih;
    PBYTE             pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 256;
    pbmih->biHeight          = 256;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 16;
    pbmih->biCompression     = BI_BITFIELDS;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    pulMask[0]         = 0x00007c00;
    pulMask[1]         = 0x000003e0;
    pulMask[2]         = 0x0000001f;

    hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        vInitDib((PUCHAR)pDib,16,0,256,256);

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 20;

        PatBlt(hdc,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,256,256,hdcm, 0,0,256,256,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;

    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    LocalFree(pbmi);

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha16_555toMem128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha16_555toMem128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdibS;
    HBITMAP           hdibD;
    ULONG             ux,uy;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbmih;
    PBYTE             pDib;

    HDC hdcmS  = CreateCompatibleDC(hdc);
    HDC hdcmD  = CreateCompatibleDC(hdc);

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 256;
    pbmih->biHeight          = 256;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 16;
    pbmih->biCompression     = BI_BITFIELDS;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    pulMask[0]         = 0x00007c00;
    pulMask[1]         = 0x000003e0;
    pulMask[2]         = 0x0000001f;

    hdibS = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);
    hdibD = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)NULL,NULL,0);

    if ((hdibS == NULL) || (hdibD == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        vInitDib((PUCHAR)pDib,16,T555,256,256);

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcmS,hdibS);
        SelectObject(hdcmD,hdibD);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcmS,hpal,FALSE);
        SelectPalette(hdcmD,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcmS);
        RealizePalette(hdcmD);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 20;
        BlendFunction.AlphaFormat         = 0;

        PatBlt(hdc,0,0,2000,2000,0);
        PatBlt(hdcmD,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdcmD,0,0,256,256,hdcmS, 0,0,256,256,BlendFunction);
            //BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

        BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    LocalFree(pbmi);

    DeleteObject(hdcmS);
    DeleteObject(hdibS);
    DeleteObject(hdcmD);
    DeleteObject(hdibD);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha16_565toScreen128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha16_565toScreen128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbmih;
    PBYTE             pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 256;
    pbmih->biHeight          = 256;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 16;
    pbmih->biCompression     = BI_BITFIELDS;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    pulMask[0]         = 0x0000f800;
    pulMask[1]         = 0x000007e0;
    pulMask[2]         = 0x0000001f;

    hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        vInitDib((PUCHAR)pDib,16,T565,256,256);

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 20;

        PatBlt(hdc,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,256,256,hdcm, 0,0,256,256,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;

    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    LocalFree(pbmi);

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha16_565toMem128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha16_565toMem128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdibS;
    HBITMAP           hdibD;
    ULONG             ux,uy;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbmih;
    PBYTE             pDib;

    HDC hdcmS  = CreateCompatibleDC(hdc);
    HDC hdcmD  = CreateCompatibleDC(hdc);

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 256;
    pbmih->biHeight          = 256;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 16;
    pbmih->biCompression     = BI_BITFIELDS;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    pulMask[0]         = 0x0000f800;
    pulMask[1]         = 0x000007e0;
    pulMask[2]         = 0x0000001f;

    hdibS = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);
    hdibD = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)NULL,NULL,0);

    if ((hdibS == NULL) || (hdibD == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        vInitDib((PUCHAR)pDib,16,T565,256,256);

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcmS,hdibS);
        SelectObject(hdcmD,hdibD);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcmS,hpal,FALSE);
        SelectPalette(hdcmD,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcmS);
        RealizePalette(hdcmD);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 20;
        BlendFunction.AlphaFormat         = 0;

        PatBlt(hdc,0,0,2000,2000,0);
        PatBlt(hdcmD,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdcmD,0,0,256,256,hdcmS, 0,0,256,256,BlendFunction);
            //BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

        BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    LocalFree(pbmi);

    DeleteObject(hdcmS);
    DeleteObject(hdibS);
    DeleteObject(hdcmD);
    DeleteObject(hdibD);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}
/******************************Public*Routine******************************\
* vTimerAlpha24toScreen128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha24toScreen128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbmih;
    PBYTE             pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 256;
    pbmih->biHeight          = 256;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 24;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;

    hdib = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDib,NULL,0);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        vInitDib((PUCHAR)pDib,24,0,256,256);

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 20;

        PatBlt(hdc,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,256,256,hdcm, 0,0,256,256,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;

    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    LocalFree(pbmi);

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerAlpha24toMem128
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha24toMem128(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdibS;
    HBITMAP           hdibD;
    ULONG             ux,uy;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;
    PBITMAPINFO       pbmi;
    PBITMAPINFOHEADER pbmih;
    PBYTE             pDibS;
    PBYTE             pDibD;

    HDC hdcmS  = CreateCompatibleDC(hdc);
    HDC hdcmD  = CreateCompatibleDC(hdc);

    pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

    PULONG pulMask = (PULONG)&pbmi->bmiColors[0];

    pbmih = (PBITMAPINFOHEADER)&pbmi->bmiHeader;

    pbmih->biSize            = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth           = 256;
    pbmih->biHeight          = 256;
    pbmih->biPlanes          = 1;
    pbmih->biBitCount        = 24;
    pbmih->biCompression     = BI_RGB;
    pbmih->biSizeImage       = 0;
    pbmih->biXPelsPerMeter   = 0;
    pbmih->biYPelsPerMeter   = 0;
    pbmih->biClrUsed         = 0;
    pbmih->biClrImportant    = 0;


    hdibS = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibS,NULL,0);
    hdibD = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(VOID **)&pDibD,NULL,0);

    if ((hdibS == NULL) || (hdibD == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        vInitDib((PUCHAR)pDibS,24,0,256,256);

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcmS,hdibS);
        SelectObject(hdcmD,hdibD);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcmS,hpal,FALSE);
        SelectPalette(hdcmD,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcmS);
        RealizePalette(hdcmD);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 20;
        BlendFunction.AlphaFormat         = 0;

        PatBlt(hdc,0,0,2000,2000,0);
        PatBlt(hdcmD,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdcmD,0,0,256,256,hdcmS, 0,0,256,256,BlendFunction);
            //BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

        BitBlt(hdc,0,0,256,256,hdcmD,0,0,SRCCOPY);
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    LocalFree(pbmi);

    DeleteObject(hdcmS);
    DeleteObject(hdibS);
    DeleteObject(hdcmD);
    DeleteObject(hdibD);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerAlpha32BGRAtoScreenSmall(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    PULONG            pDib;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,TRUE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {
        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 255;

        PatBlt(hdc,0,0,2000,2000,0);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            AlphaBlend(hdc,0,0,1,1,hdcm, 0,0,1,1,BlendFunction);
        }

        //
        // end timed segment
        //

        END_TIMER;
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerTriangleToScreenLarge(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG              TempIter = Iter;
    GRADIENT_TRIANGLE  gTri[2] = {{0,1,2},{1,2,3}};
    TRIVERTEX          vert[32];
    HDC                hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE           hpal = CreateHtPalette(hdc);

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 250;
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = 0;
    vert[2].y     = 250;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0xff00;

    vert[3].x     = 250;
    vert[3].y     = 250;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdc,vert,4,gTri,2,GRADIENT_FILL_TRIANGLE);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerTriangleToScreenSmall(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG             TempIter = Iter;
    GRADIENT_TRIANGLE  gTri[2] = {{0,1,2},{1,2,3}};
    TRIVERTEX   vert[32];
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE    hpal = CreateHtPalette(hdc);

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 2;
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = 0;
    vert[2].y     = 2;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0xff00;

    vert[3].x     = 2;
    vert[3].y     = 2;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdc,vert,4,gTri,2,GRADIENT_FILL_TRIANGLE);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerTriangleTo32BGRALarge(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG             TempIter = Iter;
    GRADIENT_TRIANGLE  gTri[2] = {{0,1,2},{1,2,3}};
    TRIVERTEX   vert[32];
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE    hpal = CreateHtPalette(hdc);
    HBITMAP           hdib;
    PULONG            pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,FALSE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }

    SelectObject(hdcm,hdib);

    SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 250;
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = 0;
    vert[2].y     = 250;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0xff00;

    vert[3].x     = 250;
    vert[3].y     = 250;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdcm,vert,4,gTri,2,GRADIENT_FILL_TRIANGLE);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcm);
    DeleteObject(hdib);
    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerTriangleTo32BGRASmall(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG             TempIter = Iter;
    GRADIENT_TRIANGLE gTri[2] = {{0,1,2},{1,2,3}};
    TRIVERTEX         vert[32];
    HDC               hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE          hpal = CreateHtPalette(hdc);
    HBITMAP           hdib;
    PULONG            pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,FALSE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }

    SelectObject(hdcm,hdib);

    SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 2;
    vert[1].y     = 0;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    vert[2].x     = 0;
    vert[2].y     = 2;
    vert[2].Red   = 0x0000;
    vert[2].Green = 0x0000;
    vert[2].Blue  = 0xff00;
    vert[2].Alpha = 0xff00;

    vert[3].x     = 2;
    vert[3].y     = 2;
    vert[3].Red   = 0x0000;
    vert[3].Green = 0xff00;
    vert[3].Blue  = 0x0000;
    vert[3].Alpha = 0x0000;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdcm,vert,4,gTri,2,GRADIENT_FILL_TRIANGLE);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcm);
    DeleteObject(hdib);
    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerRectangleToScreenLarge(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG         TempIter = Iter;
    GRADIENT_RECT gRect = {0,1};
    TRIVERTEX     vert[32];
    HDC           hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE      hpal = CreateHtPalette(hdc);

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 250;
    vert[1].y     = 250;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdc,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerRectangleToScreenSmall(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG             TempIter = Iter;
    GRADIENT_RECT gRect = {0,1};
    TRIVERTEX   vert[32];
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE    hpal = CreateHtPalette(hdc);

    SelectPalette(hdc,hpal,FALSE);
    RealizePalette(hdc);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 2;
    vert[1].y     = 2;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdc,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerRectangleTo32BGRALarge(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG             TempIter = Iter;
    GRADIENT_RECT gRect = {0,1};
    TRIVERTEX   vert[32];
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE    hpal = CreateHtPalette(hdc);
    HBITMAP           hdib;
    PULONG            pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,FALSE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }

    SelectObject(hdcm,hdib);

    SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 250;
    vert[1].y     = 250;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdcm,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcm);
    DeleteObject(hdib);
    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerRectangleTo32BGRASmall(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG             TempIter = Iter;
    GRADIENT_RECT gRect = {0,1};
    TRIVERTEX   vert[32];
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HPALETTE    hpal = CreateHtPalette(hdc);
    HBITMAP           hdib;
    PULONG            pDib;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,FALSE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }

    SelectObject(hdcm,hdib);

    SelectPalette(hdc,hpal,FALSE);
    SelectPalette(hdcm,hpal,FALSE);

    RealizePalette(hdc);
    RealizePalette(hdcm);

    vert[0].x     = 0;
    vert[0].y     = 0;
    vert[0].Red   = 0xff00;
    vert[0].Green = 0x0000;
    vert[0].Blue  = 0x0000;
    vert[0].Alpha = 0xff00;

    vert[1].x     = 2;
    vert[1].y     = 2;
    vert[1].Red   = 0x0000;
    vert[1].Green = 0xff00;
    vert[1].Blue  = 0x0000;
    vert[1].Alpha = 0xff00;

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        GradientFill(hdcm,vert,2,(PVOID)&gRect,1,GRADIENT_FILL_RECT_H);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcm);
    DeleteObject(hdib);
    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/
HBITMAP hCreate4TranSurface(HDC hdc, PBITMAPINFO *ppbmi, PULONG *ppDib)
{
        HBITMAP     hbm = NULL;

        RGBQUAD palentry[16] =
{
    { 0,   0,   0,   0 },
    { 0x80,0,   0,   0 },
    { 0,   0x80,0,   0 },
    { 0x80,0x80,0,   0 },
    { 0,   0,   0x80,0 },
    { 0x80,0,   0x80,0 },
    { 0,   0x80,0x80,0 },
    { 0x80,0x80,0x80,0 },

    { 0xC0,0xC0,0xC0,0 },
    { 0xFF,0,   0,   0 },
    { 0,   0xFF,0,   0 },
    { 0xFF,0xFF,0,   0 },
    { 0,   0,   0xFF,0 },
    { 0xFF,0,   0xFF,0 },
    { 0,   0xFF,0xFF,0 },
    { 0xFF,0xFF,0xFF,0 }
};


        PBITMAPINFO pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        if (pbmi)
        {
            PULONG pDib = NULL;
            ULONG  ux, uy;

            pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
            pbmi->bmiHeader.biWidth           = 128;
            pbmi->bmiHeader.biHeight          = -128;
            pbmi->bmiHeader.biPlanes          = 1;
            pbmi->bmiHeader.biBitCount        = 4;
            pbmi->bmiHeader.biCompression     = BI_RGB;
            pbmi->bmiHeader.biSizeImage       = 0;
            pbmi->bmiHeader.biXPelsPerMeter   = 0;
            pbmi->bmiHeader.biYPelsPerMeter   = 0;
            pbmi->bmiHeader.biClrUsed         = 0;
            pbmi->bmiHeader.biClrImportant    = 0;

            memcpy (pbmi->bmiColors, palentry, sizeof(RGBQUAD)*16);

            hbm = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(PVOID *)&pDib,NULL,0);

            {
                PBYTE  pt4;
                pt4 = (PBYTE)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<64;ux++)
                    {
                        *pt4++ = (BYTE)(ux + uy);
                    }
                }

                pt4 = (PBYTE)pDib + 32 * 64;

                for (uy=32;uy<42;uy++)
                {
                    for (ux=0;ux<64;ux++)
                    {
                        *pt4++ = 0xcc;
                    }
                }
            }

            *ppbmi = pbmi;

            *ppDib = pDib;
        }


        return(hbm);
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/5/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/

VOID
vTimerTransparentBltDIB4(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG       TempIter = 200;
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HBITMAP     hbm;
    PBITMAPINFO pbmi = NULL;
    PULONG      pDib;

    HDC hdcSrc  = CreateCompatibleDC(hdc);

    hbm = hCreate4TranSurface(hdcSrc, &pbmi, &pDib);

    if (hbm == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }

    SelectObject(hdcSrc,hbm);

    PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        TransparentBlt (hdc, 0, 0, 128, 128, hdcSrc, 0, 0,128, 128,  RGB(0xff,0,0));
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    if (pbmi)
    {
        LocalFree(pbmi);
    }

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcSrc);
    DeleteObject(hbm);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/
HBITMAP hCreate8TranSurface(HDC hdc, PBITMAPINFO *ppbmi, PULONG *ppDib)
{
        HBITMAP     hbm = NULL;

        PBITMAPINFO pbmi = (PBITMAPINFO)LocalAlloc(0,sizeof(BITMAPINFO) + 255 * sizeof(RGBQUAD));

        if (pbmi)
        {
            PULONG pDib = NULL;
            ULONG  ux, uy;

            pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
            pbmi->bmiHeader.biWidth           = 128;
            pbmi->bmiHeader.biHeight          = -128;
            pbmi->bmiHeader.biPlanes          = 1;
            pbmi->bmiHeader.biBitCount        = 8;
            pbmi->bmiHeader.biCompression     = BI_RGB;
            pbmi->bmiHeader.biSizeImage       = 0;
            pbmi->bmiHeader.biXPelsPerMeter   = 0;
            pbmi->bmiHeader.biYPelsPerMeter   = 0;
            pbmi->bmiHeader.biClrUsed         = 0;
            pbmi->bmiHeader.biClrImportant    = 0;

            for (ux=0;ux<256;ux++)
            {
                pbmi->bmiColors[ux].rgbRed       = (BYTE)ux;
                pbmi->bmiColors[ux].rgbGreen     = 0;
                pbmi->bmiColors[ux].rgbBlue      = (BYTE)ux;
                pbmi->bmiColors[ux].rgbReserved  = 0;
            }

            //
            // tran color
            //

            pbmi->bmiColors[255].rgbRed       = 255;
            pbmi->bmiColors[255].rgbGreen     = 0;
            pbmi->bmiColors[255].rgbBlue      = 0;
            pbmi->bmiColors[255].rgbReserved  = 0;

            hbm = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(PVOID *)&pDib,NULL,0);

            //
            // init 8bpp DIB
            //
            {
                PBYTE  pt8;
                pt8 = (PBYTE)pDib;

                for (uy=0;uy<128;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        *pt8++ = (BYTE)(ux + uy/2);
                    }
                }

                pt8 = (PBYTE)pDib + 32 * 128;

                for (uy=32;uy<42;uy++)
                {
                    for (ux=0;ux<128;ux++)
                    {
                        *pt8++ = 255;
                    }
                }
            }

            *ppbmi = pbmi;
            *ppDib = pDib;
        }

        return(hbm);
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/

VOID
vTimerTransparentBltDIB8(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG       TempIter = 200;
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HBITMAP     hbm;
    PBITMAPINFO pbmi = NULL;
    PULONG      pDib;

    HDC hdcSrc  = CreateCompatibleDC(hdc);

    hbm = hCreate8TranSurface(hdcSrc, &pbmi, &pDib);

    if (hbm == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }

    SelectObject(hdcSrc,hbm);

    PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        TransparentBlt (hdc, 0, 0, 128, 128, hdcSrc, 0, 0, 128, 128, RGB(0xff,0xff,0));
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    if (pbmi)
    {
        LocalFree(pbmi);
    }

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcSrc);
    DeleteObject(hbm);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/

VOID
vTimerTransparentDIBits8(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG       TempIter = 200;
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    PULONG      pDib;
    PBITMAPINFO pbmi;
    HBITMAP     hbm;

    HDC hdcSrc  = CreateCompatibleDC(hdc);

    hbm = hCreate8TranSurface(hdcSrc, &pbmi, &pDib);


    PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        TransparentDIBits (hdc, 0, 0, 128, 128, pDib, pbmi, DIB_RGB_COLORS, 0,0,128, 128, 255);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcSrc);
    DeleteObject(hbm);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/

VOID
vTimerTransparentDIBits4(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG       TempIter = 200;
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    PULONG      pDib;
    PBITMAPINFO pbmi;
    HBITMAP     hbm;

    HDC hdcSrc  = CreateCompatibleDC(hdc);

    hbm = hCreate4TranSurface(hdcSrc, &pbmi, &pDib);


    PatBlt (hdc, 0, 0, 500, 200, WHITENESS);

    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        TransparentDIBits (hdc, 0, 0, 128, 128, pDib, pbmi, DIB_RGB_COLORS,0,0,128, 128, 12);
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcSrc);
    DeleteObject(hbm);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    3/3/1997 Lingyun Wang [LingyunW]
*
\**************************************************************************/

VOID
vTimerTransparentBltComp(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;
    ULONG       TempIter = 200;
    HDC         hdc     = GetDCAndTransform(pCallData->hwnd);
    HBITMAP     hbm;

    HDC hdcSrc  = CreateCompatibleDC(hdc);

    hbm = LoadBitmap (hInstMain, MAKEINTRESOURCE(MONITOR_BITMAP));

    SelectObject(hdcSrc,hbm);

    PatBlt (hdc, 0, 0, 500, 200, WHITENESS);
    //
    // begin timed segment
    //

    START_TIMER;

    while (TempIter--)
    {
        TransparentBlt (hdc, 0, 0, 184, 170, hdcSrc, 0, 0, 184, 170, RGB(0xff,0xff,0));
    }

    //
    // end timed segment
    //

    END_TIMER;

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hdcSrc);
    DeleteObject(hbm);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}


/******************************Public*Routine******************************\
* vTimerBitBlt32src
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerBitBlt32src(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    ULONG             ux,uy;
    PULONG            pDib;
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcm  = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,FALSE);

    if (hdib == NULL)
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            BitBlt(hdc,0,0,256,256,hdcm,0,0,SRCCOPY);
        }

        //
        // end timed segment
        //

        END_TIMER;

    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcm);
    DeleteObject(hdib);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;


    pCallData->ullTestTime = StopTime;;
}

/******************************Public*Routine******************************\
* vTimerBitBlt32srcXOR
*
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    10/9/1996 Mark Enstrom [marke]
*
\**************************************************************************/

VOID
vTimerBitBlt32srcXOR(
    PTEST_CALL_DATA pCallData
    )
{
    INIT_TIMER;

    HDC hdc     = GetDCAndTransform(pCallData->hwnd);

    HBITMAP           hdib;
    HBITMAP           hdibA;
    ULONG             ux,uy;
    PULONG            pDib,pDibA;
    BLENDFUNCTION     BlendFunction = {0,0,0,0};
    ULONG             TempIter = Iter;
    HPALETTE          hpal;

    HDC hdcm  = CreateCompatibleDC(hdc);
    HDC hdcmA = CreateCompatibleDC(hdc);

    hdib  = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDib,FALSE);
    hdibA = hCreateBGR32AlphaSurface(hdc,256,256,(VOID **)&pDibA,FALSE);

    if ((hdib == NULL) || (hdibA == NULL))
    {
        MessageBox(NULL,"Can't create DIBSECTION","Error",MB_OK);
    }
    else
    {

        hpal = CreateHtPalette(hdc);

        SelectObject(hdcm,hdib);
        SelectObject(hdcmA,hdibA);

        SelectPalette(hdc,hpal,FALSE);
        SelectPalette(hdcm,hpal,FALSE);
        SelectPalette(hdcmA,hpal,FALSE);

        RealizePalette(hdc);
        RealizePalette(hdcm);
        RealizePalette(hdcmA);

        BlendFunction.BlendOp             = AC_SRC_OVER;
        BlendFunction.SourceConstantAlpha = 128;

        //
        // begin timed segment
        //

        START_TIMER;

        while (TempIter--)
        {
            BitBlt(hdc,0,0,256,256,hdcm,0,0,SRCINVERT);
        }

        //
        // end timed segment
        //

        END_TIMER;
    }

    pCallData->pTimerResult->TestTime = (LONG)StopTime;
    pCallData->pTimerResult->ImageSize = 256 * 256;

    DeleteObject(hdcm);
    DeleteObject(hdcmA);
    DeleteObject(hdib);
    DeleteObject(hdibA);

    ReleaseDC(pCallData->hwnd,hdc);

    DeleteObject(hpal);
    bThreadActive = FALSE;

    pCallData->ullTestTime = StopTime;;
}

//
// TEST_ENTRY controls automatic menu generation
//
// [Menu Level, Test Param, Stress Enable, Test Name, Test Function Pointer]
//
// Menu Level 
//      used to autoamtically generate sub-menus.
//      1   = 1rst level menu
//      -n  = start n-level sub menu
//      n   = continue sub menu
// 
// Test Param
//      passed as parameter to test
//
//
// Stress Ensable
//      if 1, test is run in stress mode
//      if 0, test is not run (tests that require input or runforever)
//
//  
// Test Name
//      ascii test name for menu
//  
// Test Function Pointer
//      pfn
//

TEST_ENTRY  gTimerEntry[] = {

{-2, 200,1,(PUCHAR)"BitBlt tests                     " , (PFN_DISP)vTestDummy},
{ 2, 100,1,(PUCHAR)"vTimerBitBlt32src                " , (PFN_DISP)vTimerBitBlt32src},
{ 2, 100,1,(PUCHAR)"vTimerBitBlt32srcXOR             " , (PFN_DISP)vTimerBitBlt32srcXOR},

{-2, 200,1,(PUCHAR)"Alpha  tests                     " , (PFN_DISP)vTestDummy},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoScreen255     " , (PFN_DISP)vTimerAlpha32BGRAtoScreen255},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoMem255        " , (PFN_DISP)vTimerAlpha32BGRAtoMem255},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoScreen128     " , (PFN_DISP)vTimerAlpha32BGRAtoScreen128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoMem128        " , (PFN_DISP)vTimerAlpha32BGRAtoMem128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoScreen128_NA  " , (PFN_DISP)vTimerAlpha32BGRAtoScreen128_NA},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoMem128_NA     " , (PFN_DISP)vTimerAlpha32BGRAtoMem128_NA},
{ 2, 100,1,(PUCHAR)"vTimerAlpha16_555toScreen128     " , (PFN_DISP)vTimerAlpha16_555toScreen128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha16_555toMem128        " , (PFN_DISP)vTimerAlpha16_555toMem128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha16_565toScreen128     " , (PFN_DISP)vTimerAlpha16_565toScreen128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha16_565toMem128        " , (PFN_DISP)vTimerAlpha16_565toMem128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha24toScreen128         " , (PFN_DISP)vTimerAlpha24toScreen128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha24toMem128            " , (PFN_DISP)vTimerAlpha24toMem128},
{ 2, 100,1,(PUCHAR)"vTimerAlpha32BGRAtoScreenSmall   " , (PFN_DISP)vTimerAlpha32BGRAtoScreenSmall},

{-2, 200,1,(PUCHAR)"Grad Triangle tests              " , (PFN_DISP)vTestDummy},
{ 2, 200,1,(PUCHAR)"vTimerTriangleToScreenLarge      " , (PFN_DISP)vTimerTriangleToScreenLarge},
{ 2, 200,1,(PUCHAR)"vTimerTriangleToScreenSmall      " , (PFN_DISP)vTimerTriangleToScreenSmall},
{ 2, 200,1,(PUCHAR)"vTimerTriangleTo32BGRALarge      " , (PFN_DISP)vTimerTriangleTo32BGRALarge},
{ 2, 200,1,(PUCHAR)"vTimerTriangleTo32BGRASmall      " , (PFN_DISP)vTimerTriangleTo32BGRASmall},

{-2, 200,1,(PUCHAR)"Grad Rectangle tests             " , (PFN_DISP)vTestDummy},
{ 2, 200,1,(PUCHAR)"vTimerRectangleToScreenLarge     " , (PFN_DISP)vTimerRectangleToScreenLarge},
{ 2, 200,1,(PUCHAR)"vTimerRectangleToScreenSmall     " , (PFN_DISP)vTimerRectangleToScreenSmall},
{ 2, 200,1,(PUCHAR)"vTimerRectangleTo32BGRALarge     " , (PFN_DISP)vTimerRectangleTo32BGRALarge},
{ 2, 200,1,(PUCHAR)"vTimerRectangleTo32BGRASmall     " , (PFN_DISP)vTimerRectangleTo32BGRASmall},

{-2, 200,0,(PUCHAR)"Transparent                      " , (PFN_DISP)vTestDummy},
{ 2, 200,0,(PUCHAR)"vTimerTransparentBltComp         " , (PFN_DISP)vTimerTransparentBltComp},
{ 2, 200,0,(PUCHAR)"vTimerTransparentBltDIB8         " , (PFN_DISP)vTimerTransparentBltDIB8},
{ 2, 200,0,(PUCHAR)"vTimerTransparentBltDIB4         " , (PFN_DISP)vTimerTransparentBltDIB4},
{ 2, 200,0,(PUCHAR)"vTimerTransparentDIBits8         " , (PFN_DISP)vTimerTransparentDIBits8},
{ 2, 200,0,(PUCHAR)"vTimerTransparentDIBIts4         " , (PFN_DISP)vTimerTransparentDIBits4},
{ 0, 000,0,(PUCHAR)"                                 " , (PFN_DISP)vTestDummy} 
};

ULONG gNumTimers = sizeof(gTimerEntry)/sizeof(TEST_ENTRY);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\sprite\perpixel.cxx ===
/******************************Module*Header*******************************\
* Module Name: perpixel.c
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

extern "C" {
    #include <windows.h>
    
    #include <stdio.h>
    #include <commdlg.h>
    
    #include <wndstuff.h>
};

class PERPIXELDRAW
{
private:
    ULONG       cPixels;
    HBITMAP     hbmDraw;
    HBITMAP     hbmPerPixel;
    RGBQUAD*    pDrawBits;
    RGBQUAD*    pPerPixelBits;

public:
    PERPIXELDRAW(HDC hdcScreen, LONG cx, LONG cy);
   ~PERPIXELDRAW();
    VOID vConvertGrayScaleToPerPixelAlpha(COLORREF color);
    VOID vConvertColorToPerPixelAlpha(ULONG alpha);

    HBITMAP hbmDrawBitmap()         { return(hbmDraw); }
    HBITMAP hbmPerPixelBitmap()     { return(hbmPerPixel); }
};

/******************************Public*Routine******************************\
* PERPIXELDRAW::PERPIXELDRAW
*
* Contains all the state required to allow GDI to do per-pixel alpha drawing.
*
\**************************************************************************/

PERPIXELDRAW::PERPIXELDRAW(
HDC     hdcScreen,
LONG    width,
LONG    height)
{
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BITMAPINFO      bmi;
    RGBQUAD*        pRGB;
    ULONG           i;

    cPixels = width * height;
    
    RtlZeroMemory(&bmi, sizeof(bmi));

    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = width;
    bmi.bmiHeader.biHeight      = height;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbmDraw = CreateDIBSection(hdcScreen,
                               &bmi,
                               DIB_RGB_COLORS,
                               (VOID**) &pDrawBits,
                               NULL,
                               0);

    hbmPerPixel = CreateDIBSection(hdcScreen,
                                   &bmi,
                                   DIB_RGB_COLORS,
                                   (VOID**) &pPerPixelBits,
                                   NULL,
                                   0);

    // Initialize the alpha of the 'draw bits' bitmap to a unique pattern.  
    // This way we'll know what pixels have been drawn to the next time
    // 'vConvertColorToPerPixelAlpha' is called:

    if (pDrawBits)
    {
        for (pRGB = pDrawBits, i = cPixels; i != 0; pRGB++, i--)
        {
            pRGB->rgbReserved = 0xaa;
        }
    }
}

/******************************Public*Routine******************************\
* PERPIXELDRAW::~PERPIXELDRAW
*
\**************************************************************************/

PERPIXELDRAW::~PERPIXELDRAW()
{
    DeleteObject(hbmDraw);
    DeleteObject(hbmPerPixel);
}

/******************************Public*Routine******************************\
* VOID PERPIXELDRAW::vConvertGrayScaleToPerPixelAlpha
*
* Takes any pixels that were drawn into the 'draw' bitmap, interprets them
* as gray-scale, and updates the corresponding pixels in the resultant
* 'per-pixel' bitmap using the specified color and an alpha based on the
* drawn pixel's intensity.
*
* This routine is intended specifically to allow anti-aliased drawing of
* text into the resultant 32-bpp RGBA bitmap.  If you draw to the 'draw'
* bitmap using white anti-aliased text, this will convert that text to
* the appropriate color and alpha value.
*
\**************************************************************************/

VOID PERPIXELDRAW::vConvertGrayScaleToPerPixelAlpha(
COLORREF color)
{
    RGBQUAD*    pDraw;
    RGBQUAD*    pPerPixel;
    ULONG       i;
    ULONG       ulAlpha;
    ULONG       ulRed;
    ULONG       ulGreen;
    ULONG       ulBlue;
    ULONG       ulDelta;

    if ((pDrawBits) && (pPerPixelBits))
    {
        pDraw     = pDrawBits;
        pPerPixel = pPerPixelBits;

        ulRed   = GetRValue(color);
        ulGreen = GetGValue(color);
        ulBlue  = GetBValue(color);

        for (i = cPixels; i != 0; i--, pDraw++, pPerPixel++)
        {
            if (pDraw->rgbReserved != 0xaa)
            {
                // The alpha value is simply the intensity of the color.
                // We assume the color is grey-scale, meaning that red,
                // green, and blue are equivalent, so we can simply 
                // take red:

                ulDelta = 255 - pPerPixel->rgbReserved;
                ulAlpha = pPerPixel->rgbReserved 
                        + ((ulDelta * pDraw->rgbRed) + 128) / 255;

                // ulAlpha = pDraw->rgbRed; // !!!

                // Now set the color, remembering that it must be 
                // pre-multiplied with the alpha:

                pPerPixel->rgbReserved = ulAlpha;
                pPerPixel->rgbRed      = ((ulRed   * ulAlpha) + 128) / 255;
                pPerPixel->rgbGreen    = ((ulGreen * ulAlpha) + 128) / 255;
                pPerPixel->rgbBlue     = ((ulBlue  * ulAlpha) + 128) / 255;

                // Finally, reset the 'draw' pixel:

                pDraw->rgbReserved = 0xaa;
                pDraw->rgbRed      = 0;
                pDraw->rgbGreen    = 0;
                pDraw->rgbBlue     = 0;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID PERPIXELDRAW::vConvertColorToPerPixelAlpha
*
* Takes any pixels that were drawn by GDI into the 'draw' bitmap, and
* copies them to the 'per-pixel' bitmap, along with a specified alpha.
*
* This routine is intended specifically to allow GDI to draw to the
* resultant 32-bpp RGBA bitmap with an arbitrary alpha value for all
* drawing.
*
\**************************************************************************/

VOID PERPIXELDRAW::vConvertColorToPerPixelAlpha(
ULONG alpha)
{
    RGBQUAD*    pDraw;
    RGBQUAD*    pPerPixel;
    ULONG       i;

    if ((pDrawBits) && (pPerPixelBits))
    {
        pDraw     = pDrawBits;
        pPerPixel = pPerPixelBits;

        for (i = cPixels; i != 0; i--, pDraw++, pPerPixel++)
        {
            if (pDraw->rgbReserved != 0xaa)
            {
                // Ah ha, this pixel was drawn over.  Add it to the 'per-pixel'
                // buffer:

                pPerPixel->rgbReserved = alpha;
                pPerPixel->rgbRed      = ((pDraw->rgbRed   * alpha) + 128) / 255;
                pPerPixel->rgbGreen    = ((pDraw->rgbGreen * alpha) + 128) / 255;
                pPerPixel->rgbBlue     = ((pDraw->rgbBlue  * alpha) + 128) / 255;

                // Finally, reset the 'draw' pixel:

                pDraw->rgbReserved = 0xaa;
                pDraw->rgbRed      = 0;
                pDraw->rgbGreen    = 0;
                pDraw->rgbBlue     = 0;
            }
        }
    }
}

extern "C" VOID vPerPixelAlpha(
HWND hwnd)
{
    LOGFONT         logfont;
    HFONT           hfont;
    HDC             hdcScreen;
    HDC             hdc;
    CHAR            achAliased[] = "Aliased text.";
    CHAR            achAntialiased[] = "Antialiased text.";
    BLENDFUNCTION   blend;
    RECT            rclSrc;
    HBRUSH          hbrush;
    SIZE            siz;
    POINT           ptlSrc;

    hdcScreen = GetDC(hwnd);

    PERPIXELDRAW draw(hdcScreen, 600, 400);

    hdc = CreateCompatibleDC(hdcScreen);

    SelectObject(hdc, draw.hbmDrawBitmap());

    ///////////////////////////////////////////////////////////////////////////
    // First, draw opaque aliased text:

    RtlZeroMemory(&logfont, sizeof(logfont));

    logfont.lfHeight = 100;

    hfont = CreateFontIndirect(&logfont);
    SelectObject(hdc, hfont);

    // We want red transparent text:

    SetTextColor(hdc, RGB(255, 0, 0));
    SetBkMode(hdc, TRANSPARENT);

    ExtTextOut(hdc, 0, 0, 0, NULL, achAliased, strlen(achAliased), NULL);
    DeleteObject(hfont);

    // Make what we've drawn opaque by using an alpha of 255:

    draw.vConvertColorToPerPixelAlpha(255);

    ///////////////////////////////////////////////////////////////////////////
    // Next, draw opaque anti-aliased text:

    RtlZeroMemory(&logfont, sizeof(logfont));

    logfont.lfHeight = 100;
    logfont.lfQuality = ANTIALIASED_QUALITY;

    hfont = CreateFontIndirect(&logfont);
    SelectObject(hdc, hfont);

    // For 'vConvertGrayScaleToPerPixelAlpha', we must draw in black and white.
    // Switch to opaque text mode for a better result:

    SetTextColor(hdc, RGB(255, 255, 255));
    SetBkColor(hdc, RGB(0, 0, 0));
    SetBkMode(hdc, OPAQUE);

    ExtTextOut(hdc, 0, 100, 0, NULL, achAntialiased, strlen(achAntialiased), NULL);
    DeleteObject(hfont);

    // Note that this is where we choose the color -- it will be red:

    draw.vConvertGrayScaleToPerPixelAlpha(RGB(255, 0, 0));

    ///////////////////////////////////////////////////////////////////////////
    // Now, draw opaque aliased text with an alpha background rectangle:

    // First, draw the background rectangle.  We'll use a red brush with an
    // alpha of ~40%:

    hbrush = CreateSolidBrush(RGB(128, 0, 0));
    SelectObject(hdc, hbrush);
    PatBlt(hdc, 0, 200, 1024, 100, PATCOPY);
    DeleteObject(hbrush);

    draw.vConvertColorToPerPixelAlpha(0x60);

    // Now, draw the text:

    RtlZeroMemory(&logfont, sizeof(logfont));

    logfont.lfHeight = 100;
    hfont = CreateFontIndirect(&logfont);
    SelectObject(hdc, hfont);
    SetTextColor(hdc, RGB(255, 0, 0));
    SetBkMode(hdc, TRANSPARENT);

    ExtTextOut(hdc, 0, 200, 0, NULL, achAliased, strlen(achAliased), NULL);
    DeleteObject(hfont);

    // Make what we've drawn opaque by using an alpha of 255:

    draw.vConvertColorToPerPixelAlpha(255);

    ///////////////////////////////////////////////////////////////////////////
    // Now, draw opaque antialiased text with an alpha background rectangle:

    // First, draw the background rectangle.  We'll use a red brush with an
    // alpha of ~40%:

    hbrush = CreateSolidBrush(RGB(128, 0, 0));
    SelectObject(hdc, hbrush);
    PatBlt(hdc, 0, 300, 1024, 100, PATCOPY);
    DeleteObject(hbrush);

    draw.vConvertColorToPerPixelAlpha(0x60);

    // Now, draw the text:

    RtlZeroMemory(&logfont, sizeof(logfont));

    logfont.lfHeight = 100;
    logfont.lfQuality = ANTIALIASED_QUALITY;
    hfont = CreateFontIndirect(&logfont);
    SelectObject(hdc, hfont);

    // For 'vConvertGrayScaleToPerPixelAlpha', we must draw in black and white.
    // We have to use 'transparent' text mode, otherwise we'll overwrite the
    // background color we just drew:

    SetTextColor(hdc, RGB(255, 255, 255));
    SetBkMode(hdc, TRANSPARENT);
    ExtTextOut(hdc, 0, 300, 0, NULL, achAntialiased, strlen(achAntialiased), NULL);
    DeleteObject(hfont);

    // Note that this is where we choose the color -- it will be red:

    draw.vConvertGrayScaleToPerPixelAlpha(RGB(255, 0, 0));

    ///////////////////////////////////////////////////////////////////////////
    // Finally, convert everything to a per-pixel sprite:

    SelectObject(hdc, draw.hbmPerPixelBitmap());

    blend.BlendOp             = AC_SRC_OVER;
    blend.BlendFlags          = 0;
    blend.SourceConstantAlpha = 0xff;           // No constant alpha
    blend.AlphaFormat         = AC_SRC_ALPHA;   // There's a per-pixel alpha

    vCreateSprite(hdcScreen, 0, 0);

    ptlSrc.x = 0;
    ptlSrc.y = 0;
    siz.cx = 600;
    siz.cy = 400;

    blend.BlendOp             = AC_SRC_OVER;
    blend.BlendFlags          = 0;
    blend.SourceConstantAlpha = 0x80; // !!! 0xff;           // No constant alpha
    blend.AlphaFormat         = AC_SRC_ALPHA;   // There's a per-pixel alpha

    if (!UpdateLayeredWindow(ghSprite,
                             hdcScreen,
                             &gptlSprite,
                             &siz,
                             hdc,
                             &ptlSrc,
                             0,
                             &blend,
                             ULW_ALPHA))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    ReleaseDC(hwnd, hdcScreen);

    DeleteObject(hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\sprite\persp.c ===
/******************************Module*Header*******************************\
* Module Name: persp.c
*
* Code to do perspective tranform animations.
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <commdlg.h>
#include <wndstuff.h>
#include <time.h>
#include <math.h>

BOOL bComputePerspectiveTransform(
FLOAT       eAngle,     // z-rotation, in degrees
LONG        zDistance,  // Distance from viewport, affects amount of perspective
                        //   warping
POINTL*     pptlLeft,   // Defines the left and right edges, in screen
POINTL*     pptlRight,  //   coordinates, of the resulting bitmap at
                        //   the vertical center of the bitmap
LONG        cxSource,   // Width of source
LONG        cySource,   // Height of source
POINTL*     aptlResult) // Resulting points description
{
    FLOAT cx = cxSource;
    FLOAT cy = cySource;
    FLOAT xA;
    FLOAT yA;
    FLOAT zA;
    FLOAT xB;
    FLOAT yB;
    FLOAT zB;
    FLOAT cxDst;
    FLOAT eScale;
    LONG  dx;
    LONG  dy;

    if ((pptlLeft->y != pptlRight->y) ||
        (pptlLeft->x >= pptlRight->x))
    {
        return(FALSE);
    }

    eAngle *= 3.1415926535897932384626433832795f / 180.0f;

    xA = cx / 2;
    yA = 0;
    zA = 0;

    xB = cx / 2;
    yB = (cy / 2) * cos(eAngle);
    zB = (cy / 2) * sin(eAngle);

    // Apply the perspective transform.  Yes, this could be simplified:

    xA = (xA * zDistance) / (zA + zDistance);
    yA = (yA * zDistance) / (zA + zDistance);

    xB = (xB * zDistance) / (zB + zDistance);
    yB = (yB * zDistance) / (zB + zDistance);
    
    // Scale A and B appropriately:

    cxDst = pptlRight->x - pptlLeft->x;
    
    eScale = (cxDst / 2) / xA;
    
    dx = (xA - xB) * eScale;
    dy = yB * eScale;

    aptlResult[0].x = pptlLeft->x  - dx;
    aptlResult[0].y = pptlLeft->y  - dy;
    aptlResult[1].x = pptlRight->x + dx;
    aptlResult[1].y = pptlRight->y - dy;
    aptlResult[2].x = pptlLeft->x  + dx;
    aptlResult[2].y = pptlLeft->y  + dy;

    return(TRUE);
}

VOID vMinimize(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    POINTL          aptl[3];
    POINTL          ptlLeft;
    POINTL          ptlRight;
    POINTL          ptlStartLeft;
    POINTL          ptlStartRight;
    POINTL          ptlEndLeft;
    POINTL          ptlEndRight;
    FLOAT           eAngle;
    FLOAT           eStartAngle;
    FLOAT           eEndAngle;
    LONG            cIterations;
    LONG            i;

    hdcScreen = GetDC(hwnd);

    hdcShape = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(POPUP_BITMAP));

    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    // Create a wider sprite up front to account for the expanding window:

    vCreateSprite(hdcScreen, (4 * bmShape.bmWidth) / 3, bmShape.bmHeight + 20);

    rclSrc.left   = 0;
    rclSrc.top    = 0;
    rclSrc.right  = bmShape.bmWidth;
    rclSrc.bottom = bmShape.bmHeight;

    gcxPersp = bmShape.bmWidth;
    gcyPersp = bmShape.bmHeight;

    // This sets the number of frames:

    cIterations = 60;

    // This defines the start and end position:

    ptlStartLeft.x  = gptlSprite.x;
    ptlStartLeft.y  = gptlSprite.y + (bmShape.bmHeight / 2);
    ptlStartRight.x = gptlSprite.x + (bmShape.bmWidth);
    ptlStartRight.y = ptlStartLeft.y;

    ptlEndLeft.x  = 200;
    ptlEndLeft.y  = GetDeviceCaps(hdcScreen, VERTRES);
    ptlEndRight.x = 210;
    ptlEndRight.y = ptlEndLeft.y;

    // This defines the start and end angles:

    eStartAngle = 0.0f;
    eEndAngle = 360.0f;

    for (i = 0; i <= cIterations; i++)
    {
        // Linearly interpolate between the start and end positions and angles:

        ptlLeft.x  = ptlStartLeft.x  + (((ptlEndLeft.x - ptlStartLeft.x) * i) / cIterations);
        ptlLeft.y  = ptlStartLeft.y  + (((ptlEndLeft.y - ptlStartLeft.y) * i) / cIterations);
        ptlRight.x = ptlStartRight.x + (((ptlEndRight.x - ptlStartRight.x) * i) / cIterations);
        ptlRight.y = ptlLeft.y;
        
        eAngle = eStartAngle + (((eEndAngle - eStartAngle) * i) / cIterations);
    
        if (!bComputePerspectiveTransform(eAngle, 
                                          1000, 
                                          &ptlLeft, 
                                          &ptlRight, 
                                          bmShape.bmWidth, 
                                          bmShape.bmHeight,
                                          aptl))
        {
            MessageBox(0, "Does not compute", "Does not compute", MB_OK);
        }
        else
        {
        #if 0
            if (!UpdateSprite(ghSprite,
                              dwShape | US_UPDATE_TRANSFORM,
                              US_SHAPE_OPAQUE,
                              hdcScreen,
                              hdcShape,
                              &rclSrc,
                              0,
                              blend,
                              US_TRANSFORM_PERSPECTIVE,
                              &aptl[0],
                              0,
                              NULL))
            {
                MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            }
        #endif
        }


        // It's faster not to set the shape again on subsequent calls:

    }

#if 0
    if (!UpdateSprite(ghSprite,
                      US_UPDATE_TRANSFORM,
                      US_SHAPE_OPAQUE,
                      hdcScreen,
                      hdcShape,
                      &rclSrc,
                      0,
                      blend,
                      US_TRANSFORM_TRANSLATE,
                      &gptlSprite,
                      0,
                      NULL))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }
#endif

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
}

VOID vFlip(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    POINTL          aptl[3];
    POINTL          ptlLeft;
    POINTL          ptlRight;
    DWORD           dwShape;
    FLOAT           eAngle;
    ULONG           cIterations;
    ULONG           i;

    hdcScreen = GetDC(hwnd);

    hdcShape = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(POPUP_BITMAP));

    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    // Create a wider sprite up front to account for the expanding window:

    vCreateSprite(hdcScreen, (4 * bmShape.bmWidth) / 3, bmShape.bmHeight + 20);

    rclSrc.left   = 0;
    rclSrc.top    = 0;
    rclSrc.right  = bmShape.bmWidth;
    rclSrc.bottom = bmShape.bmHeight;

    gcxPersp = bmShape.bmWidth;
    gcyPersp = bmShape.bmHeight;

    eAngle = 0.0f;
    cIterations = 30;

    for (i = cIterations; i != 0; i--)
    {
        ptlLeft.x  = gptlSprite.x;
        ptlLeft.y  = gptlSprite.y + (bmShape.bmHeight / 2);
        ptlRight.x = gptlSprite.x + (bmShape.bmWidth);
        ptlRight.y = gptlSprite.y + (bmShape.bmHeight / 2);

        eAngle += (360.0f / cIterations);
    
        bComputePerspectiveTransform(eAngle, 
                                     1000, 
                                     &ptlLeft, 
                                     &ptlRight, 
                                     bmShape.bmWidth, 
                                     bmShape.bmHeight,
                                     aptl);

    #if 0
        if (!UpdateSprite(ghSprite,
                          dwShape | US_UPDATE_TRANSFORM,
                          US_SHAPE_OPAQUE,
                          hdcScreen,
                          hdcShape,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_PERSPECTIVE,
                          &aptl[0],
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    #endif

        // It's faster not to set the shape again on subsequent calls:

        dwShape = 0;
    }

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
}

VOID vPerspectiveTimer(
HWND hwnd,
BOOL bPerspective)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    POINTL          aptl[3];
    ULONG           cIterations;
    ULONG           i;
    LONG            tStart;
    LONG            tEnd;
    LONG            tTotal;
    LONG            cBitsPixel;
    ULONG           cBytes;
    ULONG           cBytesPerSecond;
    FLOAT           eMegsPerSecond;
    CHAR            achBuf[200];

    hdcScreen = GetDC(hwnd);

    hdcShape = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(POPUP_BITMAP));

    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    vDelete(hwnd);

    // Create a wider sprite up front to account for the expanding window:

    vCreateSprite(hdcScreen, (4 * bmShape.bmWidth) / 3, bmShape.bmHeight + 20);

    rclSrc.left   = 0;
    rclSrc.top    = 0;
    rclSrc.right  = bmShape.bmWidth;
    rclSrc.bottom = bmShape.bmHeight;

    aptl[0].x = gptlSprite.x;
    aptl[0].y = gptlSprite.y;
    aptl[1].x = aptl[0].x + 256;
    aptl[1].y = aptl[0].y;
    aptl[2].x = aptl[0].x;
    aptl[2].y = aptl[0].y + 256;

#if 0
    if (!UpdateSprite(ghSprite,
                      US_UPDATE_SHAPE | US_UPDATE_TRANSFORM,
                      US_SHAPE_OPAQUE,
                      hdcScreen,
                      hdcShape,
                      &rclSrc,
                      0,
                      blend,
                      (bPerspective) ? US_TRANSFORM_PERSPECTIVE
                                     : US_TRANSFORM_NONPERSPECTIVE,
                      &aptl[0],
                      0,
                      NULL))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }
#endif

    cIterations = 1000;

    tStart = GetTickCount();

#if 0
    for (i = cIterations; i != 0; i--)
    {
        if (!UpdateSprite(ghSprite,
                          US_UPDATE_TRANSFORM,
                          US_SHAPE_OPAQUE,
                          hdcScreen,
                          hdcShape,
                          &rclSrc,
                          0,
                          blend,
                          (bPerspective) ? US_TRANSFORM_PERSPECTIVE
                                         : US_TRANSFORM_NONPERSPECTIVE,
                          &aptl[0],
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            break;
        }
    }
#endif

    tEnd = GetTickCount();
    tTotal = tEnd - tStart;
    cBitsPixel = GetDeviceCaps(hdcScreen, BITSPIXEL);
    cBytes = 256 * 256 * cIterations * ((cBitsPixel + 1) / 8);
    eMegsPerSecond = ((FLOAT) 1000 * (FLOAT) cBytes) / ((FLOAT) (1024 * 1024) * (FLOAT) (tTotal));

    sprintf(achBuf, "%li 256x256 %libpp transforms in %li ms is %1.2f MB/s",
        cIterations,
        cBitsPixel,
        tTotal,
        eMegsPerSecond);

    MessageBox(0, achBuf, "Timing is done!", MB_OK);

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
}
    
#define ITERATIONS 100

VOID vTimeRefresh(
HWND    hwnd)
{
    RECT    rc;
    HDC     hdcScreen;
    HBITMAP hbm;
    HDC     hdc;
    DWORD   dwStart;
    DWORD   dwTime;
    ULONG   i;
    LONG    cx;
    LONG    cy;
    LONG    cjPixel;
    CHAR    achBuf[100];

    hdcScreen = GetDC(hwnd);

    cjPixel = (GetDeviceCaps(hdcScreen, BITSPIXEL) + 1) / 8;

    GetClientRect(hwnd, &rc);

    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    hbm = CreateCompatibleBitmap(hdcScreen, cx, cy | 0x01000000);
    hdc = CreateCompatibleDC(hdcScreen);
    SelectObject(hdc, hbm);

    dwStart = GetTickCount();

    for (i = ITERATIONS; i != 0; i--)
    {
        BitBlt(hdcScreen, 0, 0, cx, cy, hdc, 0, 0, SRCCOPY);
    }

    dwTime = GetTickCount() - dwStart;

    sprintf(achBuf, "%.2f refreshes/s, %.2f MB/s",
        (1000.0f * ITERATIONS) / dwTime, 
        (1000.0f * cx * cy * cjPixel * ITERATIONS) / (dwTime * 1024.0f * 1024.0f));

    MessageBox(0, achBuf, "Timing is done!", MB_OK);

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdc);
    DeleteObject(hbm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\sprite\test.c ===
/******************************Module*Header*******************************\
* Module Name: test.c
*
* Created: 09-Dec-1992 10:51:46
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
* Contains the test
*
* Dependencies:
*
\**************************************************************************/

#include <windows.h>

#include <stdlib.h>
#include <stdio.h>
#include <commdlg.h>

#include <wndstuff.h>

////////////////////////////////////////////////////////////////////////////
// Test routines

HWND ghSprite;        // Handle of current sprite
POINT gptlSprite;      // Position of current sprite
BOOL gbClip;            // TRUE if currently clipping
LONG gcxHint;
LONG gcyHint;
LONG gcxPersp;
LONG gcyPersp;
HDC ghdcApp;
HBITMAP ghbmApp;
HDC ghdcNoise;
HBITMAP ghbmNoise;
POINT gptlZero;

VOID vMove(
LONG    x,
LONG    y)
{
    BLENDFUNCTION   blend;
    POINT          aptl[3];

    gptlSprite.x = x;
    gptlSprite.y = y + 50;

    if (ghSprite)
    {
        if (!UpdateLayeredWindow(ghSprite, NULL, &gptlSprite, NULL, NULL, NULL, 0, NULL, 0))
        {
            MessageBox(0, "Move failed", "Uh oh", MB_OK);
        }
    }
}

VOID vCreateSprite(
HDC     hdcScreen,
LONG    cxHint,
LONG    cyHint)
{
    gcxPersp = 0;
    gcyPersp = 0;

    if ((cxHint > gcxHint) || (cyHint > gcyHint))
    {
        DestroyWindow(ghSprite);
        ghSprite = 0;
    }

    if (ghSprite == 0)
    {
        gcxHint  = cxHint;
        gcyHint  = cyHint;
        ghSprite = CreateWindowEx(WS_EX_LAYERED | WS_EX_TOPMOST | WS_EX_TRANSPARENT, 
                                  "TestClass",
                                  "Win32 Test",
                                  WS_POPUP, 
                                  20, 20, 
                                  cxHint, cyHint, 
                                  0, 0, ghInstance, 0);
        if (ghSprite == 0)
        {
            MessageBox(0, "CreateSprite failed", "Uh oh", MB_OK);
        }
        else
        {
            SetWindowPos(ghSprite, HWND_TOPMOST, 0, 0, 0, 0, 
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE | SWP_SHOWWINDOW);
        }
    }
}

VOID vDelete(
HWND hwnd)
{
    HDC hdcScreen;

    if (!DestroyWindow(ghSprite))
    {
        if (ghSprite != NULL)
        {
            MessageBox(0, "DestroyWindow failed", "Uh oh", MB_OK);
        }
    }

    ghSprite = 0;
}

VOID vConstantAlpha(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    SIZE            siz;
    POINT          ptlSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;

    hdcScreen = GetDC(hwnd);

    hdcShape = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(POPUP_BITMAP));

    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    vCreateSprite(hdcScreen, 0, 0);

    ptlSrc.x = 0;
    ptlSrc.y = 0;
    siz.cx   = bmShape.bmWidth;
    siz.cy   = bmShape.bmHeight;

    blend.BlendOp             = AC_SRC_OVER;
    blend.BlendFlags          = 0;
    blend.SourceConstantAlpha = 0x80; // e0       // 88% blend
    blend.AlphaFormat         = 0;

    if (!UpdateLayeredWindow(ghSprite,
                             hdcScreen,
                             &gptlSprite,
                             &siz,
                             hdcShape,
                             &ptlSrc,
                             0,
                             &blend,
                             ULW_ALPHA))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
}

BOOL SuperDuperUpdateLayeredWindow(
    HWND hWnd,
    HDC hdcDst,     // Must be passed in if both ULW_ALPHA and ULW_COLORKEY specified
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags)
{
    BITMAPINFO      bmi;
    HDC             hdcRGBA;
    HBITMAP         hbmRGBA;
    VOID*           pBits;
    RGBQUAD*        pRGBA;
    LONG            i;
    BLENDFUNCTION   blend;
    ULONG           ulTransparent;
    ULONG*          pul;
    POINT           ptSrc;
    BOOL            bRet;

    hdcRGBA = NULL;

    if ((dwFlags & (ULW_ALPHA | ULW_COLORKEY)) == (ULW_ALPHA | ULW_COLORKEY))
    {
        if (hdcSrc)
        {
            RtlZeroMemory(&bmi, sizeof(bmi));
        
            bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
            bmi.bmiHeader.biWidth       = psize->cx;
            bmi.bmiHeader.biHeight      = psize->cy;
            bmi.bmiHeader.biPlanes      = 1;
            bmi.bmiHeader.biBitCount    = 32;
            bmi.bmiHeader.biCompression = BI_RGB;
        
            hbmRGBA = CreateDIBSection(hdcDst,
                                       &bmi,
                                       DIB_RGB_COLORS,
                                       &pBits,
                                       NULL,
                                       0);
    
            hdcRGBA = CreateCompatibleDC(hdcDst);
    
            if (!hbmRGBA || !hdcRGBA)
            {
                DeleteObject(hbmRGBA);
                DeleteObject(hdcRGBA);
                return(FALSE);
            }
    
            SelectObject(hdcRGBA, hbmRGBA);
    
            BitBlt(hdcRGBA, 0, 0, psize->cx, psize->cy,
                   hdcSrc, pptSrc->x, pptSrc->y, SRCCOPY);
    
            ulTransparent = ((crKey & 0xff0000) >> 16)
                          | ((crKey & 0x00ff00))
                          | ((crKey & 0x0000ff) << 16);
            pul           = pBits;
    
            for (i = psize->cx * psize->cy; i != 0; i--)
            {
                if (*pul == ulTransparent)
                {
                    // Write a pre-multiplied value of 0:

                    *pul = 0;
                }
                else
                {
                    // Where the bitmap is not the transparent color, change the
                    // alpha value to opaque:
    
                    ((RGBQUAD*) pul)->rgbReserved = 0xff;
                }
    
                pul++;
            }

            // Change the parameters to account for the fact that we're now
            // providing only a 32-bit per-pixel alpha source:

            ptSrc.x = 0;
            ptSrc.y = 0;
            pptSrc = &ptSrc;
            hdcSrc = hdcRGBA;
        }

        blend = *pblend;
        blend.AlphaFormat = AC_SRC_ALPHA;   

        pblend = &blend;
        dwFlags = ULW_ALPHA;
    }

    bRet = UpdateLayeredWindow(hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, 
                               crKey, pblend, dwFlags);

    if (hdcRGBA)
    {
        DeleteObject(hdcRGBA);
        DeleteObject(hbmRGBA);
    }

    return(bRet);
}

VOID vPerPixelPopup(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    BITMAPINFO      bmi;
    HDC             ghdcApp;
    HBITMAP         ghbmApp;
    VOID*           pBits;
    RGBQUAD*        pRGB;
    LONG            i;
    LONG            j;
    SIZE            siz;

    hdcScreen = GetDC(hwnd);

    hdcShape = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(SMALL_BITMAP));

    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    ghdcApp = CreateCompatibleDC(hdcScreen);

    RtlZeroMemory(&bmi, sizeof(bmi));

    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = bmShape.bmWidth;
    bmi.bmiHeader.biHeight      = bmShape.bmHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    ghbmApp = CreateDIBSection(hdcScreen,
                              &bmi,
                              DIB_RGB_COLORS,
                              &pBits,
                              NULL,
                              0);

    SelectObject(ghdcApp, ghbmApp);

    BitBlt(ghdcApp, 0, 0, bmShape.bmWidth, bmShape.bmHeight, 
           hdcShape, 0, 0, SRCCOPY);

    if ((pBits) && (bmShape.bmWidth != 0))
    {
        for (pRGB = pBits, j = 0; j != bmShape.bmHeight; j++)
        {
            // On each row, increase the alpha from 0 to 255 going left to
            // right on the scan.  Leave the very first pixel in the row
            // as opaque to demark the start.

            pRGB[0].rgbReserved = 255;    

            for (i = 1; i != bmShape.bmWidth; i++)
            {
                pRGB[i].rgbReserved = (BYTE) (i * 256 / bmShape.bmWidth);
            }

            // Advance to the next row:
    
            pRGB += bmShape.bmWidth;
        }

        // Don't forget that GDI takes only pre-multiplied alpha sources, so
        // we have to go through and pre-multiply every pixel's color 
        // components:

        for (pRGB = pBits, j = 0; j != bmShape.bmHeight; j++)
        {
            for (i = 0; i != bmShape.bmWidth; i++)
            {
                pRGB[i].rgbRed   = ((pRGB[i].rgbRed   * pRGB[i].rgbReserved) + 128) / 255;
                pRGB[i].rgbGreen = ((pRGB[i].rgbGreen * pRGB[i].rgbReserved) + 128) / 255;
                pRGB[i].rgbBlue  = ((pRGB[i].rgbBlue  * pRGB[i].rgbReserved) + 128) / 255;
            }

            // Advance to the next row:
    
            pRGB += bmShape.bmWidth;
        }
    }

    vCreateSprite(hdcScreen, 0, 0);

    siz.cx = bmShape.bmWidth;
    siz.cy = bmShape.bmHeight;

    blend.BlendOp             = AC_SRC_OVER;
    blend.BlendFlags          = 0;
    blend.SourceConstantAlpha = 0x80; // !!! 0xff;           // No constant alpha
    blend.AlphaFormat         = AC_SRC_ALPHA;   // There's a per-pixel alpha

// AlphaBlend(hdcScreen, 0, 0, bmShape.bmWidth, bmShape.bmHeight,
//           ghdcApp, 0, 0, bmShape.bmWidth, bmShape.bmHeight,
//           blend);
    
    if (!UpdateLayeredWindow(ghSprite,
                             hdcScreen,
                             &gptlSprite,
                             &siz,
                             ghdcApp,
                             &gptlZero,
                             0,
                             &blend,
                             ULW_ALPHA))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
    DeleteObject(ghdcApp);
    DeleteObject(ghbmApp);
}

// This function creates an ellipse at 

HDC hdcCreateSimpleTransparency(
HDC hdcScreen)
{
    HDC     hdc;
    HBITMAP hbm;
    HBRUSH  hbrOld;
    HBRUSH  hbrRed;
    HBRUSH  hbrGreen;
    HBRUSH  hbrBlue;

    hbm = CreateCompatibleBitmap(hdcScreen, 400, 400);
    hdc = CreateCompatibleDC(hdcScreen);
    SelectObject(hdc, hbm);

    // Fill the entire bitmap to green, our transprency color:

    hbrRed = CreateSolidBrush(RGB(255, 0, 0));
    hbrGreen = CreateSolidBrush(RGB(0, 255, 0)); 
    hbrBlue = CreateSolidBrush(RGB(0, 0, 255));

    hbrOld = SelectObject(hdc, hbrGreen);
    PatBlt(hdc, 0, 0, 400, 400, PATCOPY);

    SelectObject(hdc, hbrRed);
    Ellipse(hdc, 0, 50, 200, 150);

    SelectObject(hdc, hbrBlue);
    Ellipse(hdc, 250, 200, 350, 400);
    SelectObject(hdc, hbrOld);

    DeleteObject(hbm);      // Mark the bitmap for lazy deletion
    DeleteObject(hbrRed);
    DeleteObject(hbrGreen);
    DeleteObject(hbrBlue);

    return(hdc);
}

VOID vOpaque1(
HWND hwnd)
{
    HDC             hdcScreen;
    HDC             hdcShape;
    POINT           ptlSrc;
    SIZE            siz;

    hdcScreen = GetDC(hwnd);
    hdcShape  = hdcCreateSimpleTransparency(hdcScreen);

    vCreateSprite(hdcScreen, 0, 0);

    ptlSrc.x = 0;
    ptlSrc.y = 50;
    siz.cx = 200;
    siz.cy = 100;

    if (!UpdateLayeredWindow(ghSprite,
                             hdcScreen,
                             NULL, // !!! &gptlSprite,
                             &siz,
                             hdcShape,
                             &ptlSrc,
                             0,
                             NULL,
                             ULW_OPAQUE))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    DeleteObject(hdcShape);
    ReleaseDC(hwnd, hdcScreen);
}

#define NOVIDEOMEMORY 0x01000000

VOID vAlphaWash(
HWND hwnd)
{
    HDC             hdcScreen;
    HDC             hdcScratch;
    HDC             hdcBlack;
    HDC             hdcBack;
    HBITMAP         hbmScratch;
    HBITMAP         hbmBack;
    HBITMAP         hbmBlack;
    BLENDFUNCTION   blend;
    int             cx;
    int             cy;
    int             i;

    hdcScreen = GetDC(0);

    cx = GetDeviceCaps(hdcScreen, HORZRES);
    cy = GetDeviceCaps(hdcScreen, VERTRES);

    hbmBlack = CreateCompatibleBitmap(hdcScreen,
                                      cx,
                                      1 | NOVIDEOMEMORY);

    hdcBlack = CreateCompatibleDC(hdcScreen);

    SelectObject(hdcBlack, hbmBlack);

    hbmScratch = CreateCompatibleBitmap(hdcScreen, 
                                        cx, 
                                        1 | NOVIDEOMEMORY);

    hdcScratch = CreateCompatibleDC(hdcScreen);

    SelectObject(hdcScratch, hbmScratch);

    hbmBack = CreateCompatibleBitmap(hdcScreen, 
                                     cx,
                                     cy | NOVIDEOMEMORY);

    hdcBack = CreateCompatibleDC(hdcScreen);

    SelectObject(hdcBack, hbmBack);

    // Snatch a copy of the screen:

    BitBlt(hdcBack, 0, 0, cx, cy, hdcScreen, 0, 0, SRCCOPY);

    // Iterate through and blend blackness:

    blend.BlendOp             = AC_SRC_OVER;
    blend.BlendFlags          = 0;
    blend.SourceConstantAlpha = 0x80; // e0       // 88% blend
    blend.AlphaFormat         = 0;

    for (i = 0; i < cy; i++)
    {
        BitBlt(hdcScratch, 0, 0, cx, 1, hdcBack, 0, i, SRCCOPY);

        AlphaBlend(hdcScratch, 0, 0, cx, 1, hdcBlack, 0, 0, cx, 1, blend);

        BitBlt(hdcScreen, 0, i, cx, 1, hdcScratch, 0, 0, SRCCOPY);
    }

    // Put up the popup:

    MessageBox(0, "This is a popup!", "Ta da!", MB_OK);

    // We're done, so restore the backing bitmap:

    BitBlt(hdcScreen, 0, 0, cx, cy, hdcBack, 0, 0, SRCCOPY);

    DeleteObject(hdcBlack);
    DeleteObject(hdcScratch);
    DeleteObject(hdcBack);
    DeleteObject(hbmBlack);
    DeleteObject(hbmScratch);
    DeleteObject(hbmBack);
}

VOID vEndlessColorKey1(
HWND hwnd)
{
    HDC hdcScreen;

    hdcScreen = GetDC(NULL);

    while (TRUE)
    {
        SetPixel(hdcScreen, -1024, 0, 0);
        SetPixel(hdcScreen, -1024, 0, 0xffffff);
    }
}

VOID vColorKey1(
HWND hwnd)
{
    HDC             hdcScreen;
    HDC             hdcShape;
    SIZE            siz;
    POINT           ptlSrc;
    BLENDFUNCTION   blend;

    hdcScreen = GetDC(hwnd);
    hdcShape  = hdcCreateSimpleTransparency(hdcScreen);

    vCreateSprite(hdcScreen, 0, 0);

    ptlSrc.x = 250;
    ptlSrc.y = 200;
    siz.cx = 100;
    siz.cy = 200;

    blend.BlendOp             = AC_SRC_OVER;
    blend.BlendFlags          = 0;
    blend.SourceConstantAlpha = 0xc0;
    blend.AlphaFormat         = 0;   

    // Try a deliberate error:

    blend.AlphaFormat = AC_SRC_ALPHA;

    if (UpdateLayeredWindow(ghSprite,
                            hdcScreen,
                            &gptlSprite,
                            &siz,
                            hdcShape,
                            &ptlSrc,
                            RGB(0, 255, 0),
                            &blend,
                            ULW_ALPHA | ULW_COLORKEY))
    {
        MessageBox(0, "UpdateSprite should have failed", "Uh oh", MB_OK);
    }

    blend.AlphaFormat = 0;

    if (!UpdateLayeredWindow(ghSprite,
                             hdcScreen,
                             &gptlSprite,
                             &siz,
                             hdcShape,
                             &ptlSrc,
                             RGB(0, 0, 255),
                             &blend,
                             ULW_ALPHA | ULW_COLORKEY))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    MessageBox(0, "Paused", "Okay", MB_OK);

    blend.SourceConstantAlpha = 0x40;

    if (!UpdateLayeredWindow(ghSprite,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             0,
                             &blend,
                             ULW_ALPHA | ULW_COLORKEY))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    DeleteObject(hdcShape);
    ReleaseDC(hwnd, hdcScreen);
}

VOID vClip()
{
}

BOOL gbFadeIn;

typedef union _BITS {
    BITMAPINFO  bmi;
    CHAR        achSpace[sizeof(BITMAPINFO) + 4];
} BITS;

VOID vCreateGlobals(
HDC     hdcScreen,
HDC     hdcShape,
LONG    cx,
LONG    cy)
{
    BITS    bits;
    ULONG*  pul;
    BYTE*   pByte;
    ULONG   i;
    HBITMAP hbmDIB;
    HDC     hdcDIB;
    
    ghdcApp = CreateCompatibleDC(hdcScreen);
    ghbmApp = CreateCompatibleBitmap(hdcScreen, 
                                     cx, 
                                     cy | 0x01000000);
    SelectObject(ghdcApp, ghbmApp);
    BitBlt(ghdcApp, 0, 0, cx, cy, hdcShape, 0, 0, SRCCOPY);

    RtlZeroMemory(&bits.bmi, sizeof(bits.bmi));
    pul = (ULONG*) &bits.bmi.bmiColors;
    pul[0] = 0;
    pul[1] = RGB(255, 255, 255);

    bits.bmi.bmiHeader.biSize        = sizeof(bits.bmi.bmiHeader);
    bits.bmi.bmiHeader.biWidth       = cx;
    bits.bmi.bmiHeader.biHeight      = cy;
    bits.bmi.bmiHeader.biPlanes      = 1;
    bits.bmi.bmiHeader.biBitCount    = 1;
    bits.bmi.bmiHeader.biCompression = BI_RGB;

    hbmDIB = CreateDIBSection(hdcScreen, 
                     &bits.bmi,
                     DIB_RGB_COLORS,
                     &pByte,
                     0,
                     0);
    if (!hbmDIB)
    {
        MessageBox(0, "Noise failed", "Uh oh", MB_OK);
    }
    else
    {
        for (i = ((cx + 31) & ~31) * cy / 8; i != 0; i--)
        {
            *pByte++ = (BYTE) rand();
        }
    }

    hdcDIB = CreateCompatibleDC(hdcScreen);
    SelectObject(hdcDIB, hbmDIB);

    ghdcNoise = CreateCompatibleDC(hdcScreen);
    ghbmNoise = CreateCompatibleBitmap(hdcScreen, 
                                     cx, 
                                     cy | 0x01000000);
    SelectObject(ghdcNoise, ghbmNoise);
    BitBlt(ghdcNoise, 0, 0, cx, cy, hdcDIB, 0, 0, SRCCOPY);

    // Create a wider sprite up front to account for the expanding window:

    vDelete(0);

    vCreateSprite(hdcScreen, cx, cy);
}

VOID vFade(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    ULONG           c;
    SIZE            siz;

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(hwnd);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

    siz.cx = bmShape.bmWidth;
    siz.cy = 28;

    c = 80;

    for (i = 1; i <= c; i++)
    {
        blend.BlendOp             = AC_SRC_OVER;
        blend.BlendFlags          = 0;
        blend.AlphaFormat         = 0;

        if (gbFadeIn)
            blend.SourceConstantAlpha = (i * 255) / c;
        else
            blend.SourceConstantAlpha = ((c - i) * 255) / c;

        if (i == 1)
        {
            if (!UpdateLayeredWindow(ghSprite,
                                     hdcScreen,
                                     &gptlSprite,
                                     &siz,
                                     ghdcApp,
                                     &gptlZero,
                                     0,
                                     &blend,
                                     ULW_ALPHA))
            {
                MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            }
        }
        else
        {
            if (!UpdateLayeredWindow(ghSprite,
                                     0, // hdcScreen,
                                     0,
                                     0,
                                     0,
                                     0,
                                     0,
                                     &blend,
                                     ULW_ALPHA))
            {
                MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            }
        }
    }

    if (gbFadeIn)
    {
        siz.cy = bmShape.bmHeight;
    
        if (!UpdateLayeredWindow(ghSprite,
                                 hdcScreen,
                                 &gptlSprite,
                                 &siz,
                                 ghdcApp,
                                 &gptlZero,
                                 0,
                                 NULL,
                                 ULW_OPAQUE))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
}

VOID vBzzt(
HWND hwnd)
{

#if 0

    HDC             hdcScreen;
    UPDATESPRITE    Update;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    DWORD           dwUpdate;
    ULONG           c;
    POINT          ptlDst;

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(hwnd);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

    rclSrc.left   = 0;
    rclSrc.top    = 0;
    rclSrc.right  = bmShape.bmWidth;
    rclSrc.bottom = 28;

    dwUpdate = US_UPDATE_TRANSFORM | US_UPDATE_SHAPE;

    c = 15;

    for (i = 1; i <= c; i++)
    {
        if (gbFadeIn)
        {
            ptlDst.x      = gptlSprite.x;
            ptlDst.y      = gptlSprite.y + ((c - i) * (bmShape.bmHeight / 2)) / c;
            rclSrc.bottom = (i * bmShape.bmHeight) / c;
        }
        else
        {
            ptlDst.x      = gptlSprite.x;
            ptlDst.y      = gptlSprite.y + (i * (bmShape.bmHeight / 2)) / c;
            rclSrc.bottom = ((c - i + 1) * bmShape.bmHeight) / c;
        }

        if (!UpdateSprite(ghSprite,
                          dwUpdate,
                          US_SHAPE_OPAQUE,
                          hdcScreen,
                          ghdcNoise,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_TRANSLATE,
                          &ptlDst,
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }

        BitBlt(ghdcNoise, 0, 0, bmShape.bmWidth - 1, bmShape.bmHeight - 1, ghdcNoise, 1, 1, 0x660000); 

        // PatBlt(ghdcNoise, 0, 0, bmShape.bmWidth, bmShape.bmHeight, 0x550000);
    
        // dwUpdate = US_UPDATE_TRANSFORM;
    }

    if (gbFadeIn)
    {
        rclSrc.bottom = bmShape.bmHeight;
    
        if (!UpdateSprite(ghSprite,
                          dwUpdate,
                          US_SHAPE_OPAQUE,
                          hdcScreen,
                          ghdcApp,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_TRANSLATE,
                          &gptlSprite,
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }
    else
    {
        if (!UpdateSprite(ghSprite,
                          US_UPDATE_TRANSFORM,
                          0,
                          hdcScreen,
                          ghdcApp,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_HIDE,
                          &gptlSprite,
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);

#endif

}

#define WIPE1_ITERATIONS 20

#define GLOWING 0
#define GLOW_HEIGHT 3
#define GLOW_FADES  4000

VOID vWipe1(
HWND hwnd)
{

#if 0

    HDC             hdcScreen;
    UPDATESPRITE    Update;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    DWORD           dwUpdate;
    ULONG           c;
    POINT          pt;

#if GLOWING
    HANDLE          ahSprite[2];
    HDC             hdcGlow;
    HBITMAP         hbmGlow;
    HBRUSH          hbrGlow;
    RECTL           rclGlow;
    POINT          ptlGlow;
    BLENDFUNCTION   blendGlow;
#endif

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(hwnd);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

#if GLOWING
    for (i = 0; i < 2; i++)
    {
        ahSprite[i] = CreateSprite(hdcScreen, 0, 0, 0, 0);
    }

    hdcGlow = CreateCompatibleDC(hdcScreen);
    hbmGlow = CreateCompatibleBitmap(hdcScreen, bmShape.bmWidth + 4, GLOW_HEIGHT | 0x01000000);
    hbrGlow = CreateSolidBrush(RGB(255, 255, 255));

    rclGlow.left   = 0;
    rclGlow.right  = bmShape.bmWidth + 4;
    rclGlow.top    = 0;
    rclGlow.bottom = GLOW_HEIGHT;

    blendGlow.BlendOp             = AC_SRC_OVER;
    blendGlow.BlendFlags          = 0;
    blendGlow.AlphaFormat         = 0;
    blendGlow.SourceConstantAlpha = 0xc0;
    
    SelectObject(hdcGlow, hbmGlow);
    SelectObject(hdcGlow, hbrGlow);
    PatBlt(hdcGlow, 0, 0, bmShape.bmWidth + 4, GLOW_HEIGHT, PATCOPY);
#endif

    dwUpdate = US_UPDATE_TRANSFORM | US_UPDATE_SHAPE;

    c = 15;

    for (i = 1; i <= c; i++)
    {
        rclSrc.left   = 0;
        rclSrc.right  = bmShape.bmWidth;

        if (gbFadeIn)
        {
            rclSrc.top    = ((bmShape.bmHeight / 2) * (c - i)) / c;
            rclSrc.bottom = bmShape.bmHeight - ((bmShape.bmHeight / 2) * (c - i)) / c;
        }
        else
        {
            rclSrc.top    = ((bmShape.bmHeight / 2) * i) / c;
            rclSrc.bottom = bmShape.bmHeight - ((bmShape.bmHeight / 2) * i) / c;
        }

    #if 0
        ptlGlow.x = gptlSprite.x - 2;
        ptlGlow.y = gptlSprite.y + rclSrc.top - GLOW_HEIGHT;
        if (!UpdateSprite(ahSprite[0], dwUpdate, US_SHAPE_ALPHA, hdcScreen,
                          hdcGlow, &rclGlow, 0, blendGlow, US_TRANSFORM_TRANSLATE,
                          &ptlGlow, 0, NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    
        ptlGlow.x = gptlSprite.x - 2;
        ptlGlow.y = gptlSprite.y + rclSrc.bottom;
        if (!UpdateSprite(ahSprite[1], dwUpdate, US_SHAPE_ALPHA, hdcScreen,
                          hdcGlow, &rclGlow, 0, blendGlow, US_TRANSFORM_TRANSLATE,
                          &ptlGlow, 0, NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    #endif

        pt.x = gptlSprite.x;
        pt.y = gptlSprite.y + rclSrc.top;
    
        if (!UpdateSprite(ghSprite,
                          dwUpdate,
                          US_SHAPE_OPAQUE,
                          hdcScreen,
                          ghdcApp,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_TRANSLATE,
                          &pt,
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }

        // MessageBox(0, "Paused...", "Waiting", MB_OK);
    }

    if (!gbFadeIn)
    {
        if (!UpdateSprite(ghSprite,
                          US_UPDATE_TRANSFORM,
                          0,
                          hdcScreen,
                          ghdcApp,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_HIDE,
                          &gptlSprite,
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }

    #if GLOWING
    
        if (!gbFadeIn)
        {
            ptlGlow.x = gptlSprite.x - 2;
            ptlGlow.y = gptlSprite.y + ((bmShape.bmHeight - GLOW_HEIGHT) / 2);

        DeleteSprite(ahSprite[1]); // !!!

            for (i = 0; i < GLOW_FADES; i++)
            {
                blendGlow.SourceConstantAlpha = ((GLOW_FADES - i) * 255) / GLOW_FADES;

                if (!UpdateSprite(ahSprite[0], dwUpdate, US_SHAPE_ALPHA, hdcScreen,
                                  hdcGlow, &rclGlow, 0, blendGlow, US_TRANSFORM_TRANSLATE,
                                  &ptlGlow, 0, NULL))
                {
                    MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
                }
            }
        }
    #endif

#if GLOWING
    DeleteObject(hdcGlow);
    DeleteObject(hbrGlow);
    DeleteObject(hbmGlow);
    DeleteSprite(ahSprite[0]);
    DeleteSprite(ahSprite[1]);
#endif

    ReleaseDC(hwnd, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);

#endif

}

VOID vWipe2(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HDC             hdcSave;
    HBITMAP         hbmShape;
    HBITMAP         hbmSave;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    DWORD           dwUpdate;
    ULONG           c;
    POINT          ptlDst;
    HBRUSH          hbrAlpha;
    HBITMAP         hbmAlpha;
    HBRUSH          hbrOld;
    DWORD           adwHatch[] = { 0xaaaa5555, 0xaaaa5555, 0xaaaa5555, 0xaaaa5555 };

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(NULL);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

    if (!UpdateLayeredWindow(ghSprite, 0, NULL, NULL, 0, NULL, 0, NULL, 0))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    hdcSave = CreateCompatibleDC(hdcScreen);
    hbmSave = CreateCompatibleBitmap(hdcScreen, bmShape.bmWidth, bmShape.bmHeight);
    SelectObject(hdcSave, hbmSave);
    BitBlt(hdcSave, 0, 0, bmShape.bmWidth, bmShape.bmHeight, 
           hdcScreen, gptlSprite.x, gptlSprite.y, SRCCOPY);

    SetBkMode(hdcScreen, TRANSPARENT); 
    hbmAlpha = CreateBitmap(8, 8, 1, 1, adwHatch);
    hbrAlpha = CreatePatternBrush(hbmAlpha);
    hbrOld = SelectObject(hdcScreen, hbrAlpha);

    rclSrc.left   = 0;
    rclSrc.top    = 0;
    rclSrc.right  = bmShape.bmWidth;
    rclSrc.bottom = 28;

    c = 100;

    if (!gbFadeIn)
    {
        BitBlt(hdcScreen, gptlSprite.x, gptlSprite.y, bmShape.bmWidth, bmShape.bmHeight,
               ghdcApp, 0, 0, SRCCOPY);
        PatBlt(hdcScreen, gptlSprite.x, gptlSprite.y, bmShape.bmWidth, bmShape.bmHeight, 
               0x0a0000);
    }

    for (i = 1; i <= c; i++)
    {
        if (gbFadeIn)
        {
            ptlDst.x      = gptlSprite.x;
            ptlDst.y      = gptlSprite.y + ((c - i) * (bmShape.bmHeight / 2)) / c;
            rclSrc.bottom = (i * bmShape.bmHeight) / c;

            PatBlt(hdcScreen, ptlDst.x, ptlDst.y, rclSrc.right, rclSrc.bottom, 0x0a0000);
        }
        else
        {
            LONG yBottom;

            ptlDst.x      = gptlSprite.x;
            ptlDst.y      = gptlSprite.y + (i * (bmShape.bmHeight / 2)) / c;
            yBottom       = bmShape.bmHeight - (i * (bmShape.bmHeight / 2)) / c;

            BitBlt(hdcScreen, gptlSprite.x, gptlSprite.y, 
                              bmShape.bmWidth, ptlDst.y - gptlSprite.y,
                   hdcSave, 0, 0, SRCCOPY);

            BitBlt(hdcScreen, gptlSprite.x, gptlSprite.y + yBottom,
                              bmShape.bmWidth, bmShape.bmHeight - yBottom,
                   hdcSave, 0, yBottom, SRCCOPY);

            // MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }

    }

    if (gbFadeIn)
    {
        SIZE siz;

        rclSrc.bottom = bmShape.bmHeight;

        siz.cx = bmShape.bmWidth;
        siz.cy = bmShape.bmHeight;
    
        if (!UpdateLayeredWindow(ghSprite,
                                 hdcScreen,
                                 &gptlSprite,
                                 &siz,
                                 ghdcApp,
                                 &gptlZero,
                                 0,
                                 NULL,
                                 ULW_OPAQUE))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }
    else
    {
        if (!UpdateLayeredWindow(ghSprite,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          NULL,
                          0))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }

    BitBlt(hdcScreen, gptlSprite.x, gptlSprite.y, bmShape.bmWidth, bmShape.bmHeight,
           hdcSave, 0, 0, SRCCOPY);

    ReleaseDC(NULL, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
    DeleteObject(hbmSave);
    DeleteObject(hdcSave);
}

#define WIPE3_ITERATIONS 10
#define WIPE3_BANDS      5
#define WIPE3_BANDSIZE   5

VOID vWipe3(
HWND hwnd)
{

#if 0

    HDC             hdcScreen;
    UPDATESPRITE    Update;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    DWORD           dwUpdate;
    ULONG           c;
    POINT          ptlDst;
    HANDLE          ahSprite[WIPE3_BANDS];
    BLENDFUNCTION   ablend[WIPE3_BANDS];
    RECTL           arcl[WIPE3_BANDS];
    POINT          apt[WIPE3_BANDS];
    LONG            yInc;
    BOOL            bGrew;
    POINT          pt;
    ULONG           cIterations;
    ULONG           cBands;

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(hwnd);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

    if (!UpdateSprite(ghSprite,
                      US_UPDATE_TRANSFORM,
                      0,
                      hdcScreen,
                      ghdcApp,
                      &rclSrc,
                      0,
                      blend,
                      US_TRANSFORM_HIDE,
                      &gptlSprite,
                      0,
                      NULL))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    for (i = 0; i < WIPE3_BANDS; i++)
    {
        ahSprite[i]    = CreateSprite(hdcScreen, bmShape.bmWidth, (bmShape.bmHeight / WIPE3_BANDS) + 8, 0, 0);
        arcl[i].left   = 0;
        arcl[i].right  = bmShape.bmWidth;
        arcl[i].top    = ((bmShape.bmHeight * 2 * i + bmShape.bmHeight) / (2 * WIPE3_BANDS));
        arcl[i].bottom = arcl[i].top + 1;
    }

    dwUpdate = US_UPDATE_TRANSFORM | US_UPDATE_SHAPE;

    cIterations = 0;
    do {
        bGrew = FALSE;
        cIterations++;
        cBands = min((cIterations / 10) + 1, WIPE3_BANDS);

        for (i = 0; i < cBands; i++)
        {
            pt.x = gptlSprite.x;
            pt.y = gptlSprite.y + arcl[i].top;
        
            if (!UpdateSprite(ahSprite[i],
                              dwUpdate,
                              US_SHAPE_OPAQUE,
                              hdcScreen,
                              ghdcApp,
                              &arcl[i],
                              0,
                              blend,
                              US_TRANSFORM_TRANSLATE,
                              &pt,
                              0,
                              NULL))
            {
                MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            }
        }

        // MessageBox(0, "Paused...", "Ok", MB_OK);

        for (i = 0; i < cBands; i++)
        {
            if ((arcl[i].top > 0) &&
                ((i == 0) || (arcl[i].top > arcl[i - 1].bottom)))
            {
                bGrew = TRUE;
                arcl[i].top--;
            }
            if ((arcl[i].bottom < bmShape.bmHeight) &&
                ((i == WIPE3_BANDS - 1) || (arcl[i].bottom < arcl[i + 1].top)))
            {
                bGrew = TRUE;
                arcl[i].bottom++;
            }
        }
    } while (bGrew);

    if (!gbFadeIn)
    {
        if (!UpdateSprite(ghSprite,
                          US_UPDATE_TRANSFORM,
                          0,
                          hdcScreen,
                          ghdcApp,
                          &rclSrc,
                          0,
                          blend,
                          US_TRANSFORM_HIDE,
                          &gptlSprite,
                          0,
                          NULL))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }
    
    for (i = 0; i < WIPE3_BANDS; i++)
    {
        DeleteSprite(ahSprite[i]);
    }

#endif

}

#define ALPHA2_ITERATIONS 10
#define ALPHA2_BANDS      5
#define ALPHA2_BANDSIZE   5

VOID vCrappyAlphaWipe2(
HWND hwnd)
{

#if 0

    HDC             hdcScreen;
    UPDATESPRITE    Update;
    RECTL           rclSrc;
    HDC             hdcShape;
    HBITMAP         hbmShape;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    DWORD           dwUpdate;
    ULONG           c;
    POINT          ptlDst;
    HANDLE          ahSprite[ALPHA2_BANDS];
    BLENDFUNCTION   ablend[ALPHA2_BANDS];
    RECTL           arcl[ALPHA2_BANDS];
    POINT          apt[ALPHA2_BANDS];
    LONG            yInc;

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(hwnd);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

    if (!UpdateSprite(ghSprite,
                      US_UPDATE_TRANSFORM,
                      0,
                      hdcScreen,
                      ghdcApp,
                      &rclSrc,
                      0,
                      blend,
                      US_TRANSFORM_HIDE,
                      &gptlSprite,
                      0,
                      NULL))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    for (i = 0; i < ALPHA2_BANDS; i++)
    {
        yInc = (bmShape.bmHeight / (ALPHA2_BANDSIZE * ALPHA2_BANDS)) + 1;

        ahSprite[i]                   = CreateSprite(hdcScreen, 0, 0, 0, 0);
        ablend[i].BlendOp             = AC_SRC_OVER;
        ablend[i].BlendFlags          = 0;
        ablend[i].AlphaFormat         = 0;
        ablend[i].SourceConstantAlpha = (255 * (ALPHA2_BANDS - i)) / (ALPHA2_BANDS + 1);
        arcl[i].left                  = 0;
        arcl[i].right                 = bmShape.bmWidth;
        arcl[i].top                   = yInc * i;
        arcl[i].bottom                = yInc * (i + 1);

        if (FALSE)
        {
            LONG yTop = arcl[i].top;

            arcl[i].top                   = bmShape.bmHeight - arcl[i].bottom;
            arcl[i].bottom                = bmShape.bmHeight - yTop;
            ablend[i].SourceConstantAlpha = 255 - ablend[i].SourceConstantAlpha;
        }

        apt[i].x                      = gptlSprite.x;
        apt[i].y                      = gptlSprite.y + arcl[i].top;
    }

    dwUpdate = US_UPDATE_TRANSFORM | US_UPDATE_SHAPE;

    if (TRUE)
    {
        do {
            for (i = 0; i < ALPHA2_BANDS; i++)
            {
                if (arcl[i].bottom >= bmShape.bmHeight)
                    arcl[i].bottom = bmShape.bmHeight;
                if (arcl[i].top < arcl[i].bottom)
                {
                    if (!UpdateSprite(ahSprite[i],
                                      dwUpdate,
                                      US_SHAPE_ALPHA,
                                      hdcScreen,
                                      ghdcApp,
                                      &arcl[i],
                                      0,
                                      ablend[i],
                                      US_TRANSFORM_TRANSLATE,
                                      &apt[i],
                                      0,
                                      NULL))
                    {
                        MessageBox(0, "UpdateSprite 1 failed", "Uh oh", MB_OK);
                    }
                }
                else
                {
                    DeleteSprite(ahSprite[i]);
                }
    
                arcl[i].top    += yInc;
                arcl[i].bottom += yInc;
                apt[i].y       += yInc;
            }
    
            // MessageBox(0, "Paused...", "Ok", MB_OK);
    
            rclSrc.left   = 0;
            rclSrc.right  = bmShape.bmWidth;
            rclSrc.top    = 0;
            rclSrc.bottom = min(arcl[0].top, bmShape.bmHeight);
    
            if (!UpdateSprite(ghSprite,
                              dwUpdate,
                              US_SHAPE_OPAQUE,
                              hdcScreen,
                              ghdcApp,
                              &rclSrc,
                              0,
                              blend,
                              US_TRANSFORM_TRANSLATE,
                              &gptlSprite,
                              0,
                              NULL))
            {
                MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            }
        } while (arcl[0].top < bmShape.bmHeight);
    }
    else
    {
        do {
            for (i = 0; i < ALPHA2_BANDS; i++)
            {
                if (arcl[i].top <= 0)
                    arcl[i].top = 0;
                if (arcl[i].top < arcl[i].bottom)
                {
                    if (!UpdateSprite(ahSprite[i],
                                      dwUpdate,
                                      US_SHAPE_ALPHA,
                                      hdcScreen,
                                      ghdcApp,
                                      &arcl[i],
                                      0,
                                      ablend[i],
                                      US_TRANSFORM_TRANSLATE,
                                      &apt[i],
                                      0,
                                      NULL))
                    {
                        MessageBox(0, "UpdateSprite 1 failed", "Uh oh", MB_OK);
                    }
                }
                else
                {
                    DeleteSprite(ahSprite[i]);
                }
    
                arcl[i].top    -= yInc;
                arcl[i].bottom -= yInc;
                apt[i].y       -= yInc;
            }
    
            // MessageBox(0, "Paused...", "Ok", MB_OK);
    
            rclSrc.left   = 0;
            rclSrc.right  = bmShape.bmWidth;
            rclSrc.top    = 0;
            rclSrc.bottom = min(arcl[ALPHA2_BANDS - 1].top, bmShape.bmHeight);
    
            if (!UpdateSprite(ghSprite,
                              dwUpdate,
                              US_SHAPE_OPAQUE,
                              hdcScreen,
                              ghdcApp,
                              &rclSrc,
                              0,
                              blend,
                              US_TRANSFORM_TRANSLATE,
                              &gptlSprite,
                              0,
                              NULL))
            {
                MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
            }
        } while (arcl[ALPHA2_BANDS - 1].bottom > 0);
    }

    DeleteSprite(ahSprite[0]);

#endif

}

#define WIPE4_ITERATIONS 50

VOID vWipe4(
HWND hwnd)
{
    HDC             hdcScreen;
    RECTL           rclSrc;
    HDC             hdcShape;
    HDC             hdcSave;
    HBITMAP         hbmShape;
    HBITMAP         hbmSave;
    BITMAP          bmShape;
    BLENDFUNCTION   blend;
    ULONG           i;
    DWORD           dwUpdate;
    ULONG           c;
    POINT          ptlDst;
    HBRUSH          hbrAlpha;
    HBITMAP         hbmAlpha;
    HBRUSH          hbrOld;
    FLOAT           Increment;
    FLOAT           Proportion;
    CHAR            achBuf[200];

    gbFadeIn = !gbFadeIn;

    hdcScreen = GetDC(NULL);
    hdcShape  = CreateCompatibleDC(hdcScreen);

    hbmShape = LoadBitmap(GetModuleHandle(NULL), MAKEINTRESOURCE(APP_BITMAP));
    SelectObject(hdcShape, hbmShape);

    GetObject(hbmShape, sizeof(BITMAP), &bmShape);

    if (ghdcApp == NULL)
    {
        vCreateGlobals(hdcScreen, hdcShape, bmShape.bmWidth, bmShape.bmHeight);
    }

    if (!UpdateLayeredWindow(ghSprite, 0, NULL, NULL, 0, NULL, 0, NULL, 0))
    {
        MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
    }

    hdcSave = CreateCompatibleDC(hdcScreen);
    hbmSave = CreateCompatibleBitmap(hdcScreen, bmShape.bmWidth, bmShape.bmHeight);
    SelectObject(hdcSave, hbmSave);
    BitBlt(hdcSave, 0, 0, bmShape.bmWidth, bmShape.bmHeight, 
           hdcScreen, gptlSprite.x, gptlSprite.y, SRCCOPY);

    Increment = (1.0f / WIPE4_ITERATIONS);
    Proportion = 1.0f;

    for (i = 0; i < WIPE4_ITERATIONS; i++)
    {
        blend.BlendOp             = AC_SRC_OVER;
        blend.BlendFlags          = 0;
        blend.AlphaFormat         = 0;
        blend.SourceConstantAlpha = 255 - (BYTE) (255.0f * (Proportion - Increment) / Proportion);

        Proportion -= Increment;

        // sprintf(achBuf, "Alpha: %li", blend.SourceConstantAlpha);
        // MessageBox(0, achBuf, "Alpha", MB_OK);

        if (!AlphaBlend(hdcScreen, gptlSprite.x, gptlSprite.y, bmShape.bmWidth, bmShape.bmHeight,
                        ghdcApp, 0, 0, bmShape.bmWidth, bmShape.bmHeight, blend))
        {
            MessageBox(0, "AlphaBlend failed", "Uh oh", MB_OK);
        }
    }   

    if (gbFadeIn)
    {
        SIZE siz;

        rclSrc.bottom = bmShape.bmHeight;

        siz.cx = bmShape.bmWidth;
        siz.cy = bmShape.bmHeight;
    
        if (!UpdateLayeredWindow(ghSprite,
                                 hdcScreen,
                                 &gptlSprite,
                                 &siz,
                                 ghdcApp,
                                 &gptlZero,
                                 0,
                                 NULL,
                                 ULW_OPAQUE))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }
    else
    {
        if (!UpdateLayeredWindow(ghSprite,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          0,
                          NULL,
                          0))
        {
            MessageBox(0, "UpdateSprite failed", "Uh oh", MB_OK);
        }
    }

    BitBlt(hdcScreen, gptlSprite.x, gptlSprite.y, bmShape.bmWidth, bmShape.bmHeight,
           hdcSave, 0, 0, SRCCOPY);

    ReleaseDC(NULL, hdcScreen);
    DeleteObject(hdcShape);
    DeleteObject(hbmShape);
    DeleteObject(hbmSave);
    DeleteObject(hdcSave);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\mrmath\mrmath.c ===
/****************************** Module Header ******************************\
* Module Name: mrmath.c
*
* Copyright (c) 1992, Microsoft Corporation
*
* Simple test program for stressing the FPU.
*
* History:
*  18-Jul-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

#include <windows.h>
#include <stdlib.h>
#include <time.h>
#include <stdio.h>

// Number of math operations to do in every pass.  Should be a multiple of 4:

#define NUM_OPS 64

ULONG gulSeed;

/******************************Public*Routine******************************\
* ULONG ulRandom()
\**************************************************************************/

ULONG ulRandom()
{
    gulSeed *= 69069;
    gulSeed++;
    return(gulSeed);
}

VOID vTestFPU()
{
    double adArgs[NUM_OPS][2];
    double adResult[NUM_OPS][2];

    while (TRUE)
    {
        LONG ii;

        for (ii = 0; ii < NUM_OPS; ii++)
        {
            adArgs[ii][0] = (double) (ulRandom() + 1L);
            adArgs[ii][1] = (double) (ulRandom() + 1L);
        }

        for (ii = 0; ii < NUM_OPS; ii += 4)
        {
            adResult[ii + 0][0] = adArgs[ii + 0][0] + adArgs[ii + 0][1];
            adResult[ii + 1][0] = adArgs[ii + 1][0] - adArgs[ii + 1][1];
            adResult[ii + 2][0] = adArgs[ii + 2][0] * adArgs[ii + 2][1];
            adResult[ii + 3][0] = adArgs[ii + 3][0] / adArgs[ii + 3][1];
        }

        for (ii -= 4; ii >= 0; ii -= 4)
        {
            adResult[ii + 0][1] = adArgs[ii + 0][0] + adArgs[ii + 0][1];
            adResult[ii + 1][1] = adArgs[ii + 1][0] - adArgs[ii + 1][1];
            adResult[ii + 2][1] = adArgs[ii + 2][0] * adArgs[ii + 2][1];
            adResult[ii + 3][1] = adArgs[ii + 3][0] / adArgs[ii + 3][1];
        }

        for (ii = 0; ii < NUM_OPS; ii++)
        {
            if (adResult[ii][0] != adResult[ii][1])
            {
                CHAR ch;
                CHAR achBuf[80];

                switch(ii % 4)
                {
                case 0: ch = '+'; break;
                case 1: ch = '-'; break;
                case 2: ch = '*'; break;
                case 3: ch = '/'; break;
                }

                sprintf(achBuf, "%.0f %c %.0f = %f or %f",
                         adArgs[ii][0], ch, adArgs[ii][1],
                         adResult[ii][0], adResult[ii][1]);

                printf("MRMATH floating point error: %s\n", achBuf);
            }
        }
    }
}

int __cdecl main(int argc, char** argv)
{
    ULONG cThreads = 1;

    ULONG i;

    gulSeed = (ULONG) time(NULL);

    while (--argc > 0)
    {
        CHAR* pchArg   = *++argv;
        CHAR* pchValue;
        int   iValue;

        if (strlen(pchArg) < 2 || *pchArg != '/')
        {
            printf("Illegal switch: '%s'\nTry -?\n", pchArg);
            exit(0);
        }

    // Handle '/x<n>' or '/x <n>'

        if (strlen(pchArg) == 2 && --argc > 0)
            pchValue = *++argv;
        else
            pchValue = pchArg + 2;

        iValue = atoi(pchValue);
        if (iValue < 0)
        {
            printf("Illegal value: '%s'\n", pchValue);
            exit(0);
        }

        switch(*(pchArg + 1))
        {
        case 'n':
            cThreads = iValue;
            break;
        case '?':
            printf("MRMATH -- Stress the FPU\n\n");
            printf("Switches:\n\n");
            printf("    /n <n>   - Start <n> threads\n");
            exit(0);
        default:
            printf("Illegal switch: '%s'\nTry -?\n", pchArg);
            exit(0);
        }
    }

    printf("MRMATH: %li threads\n", cThreads);

    for (i = 0; i < cThreads; i++)
    {
        DWORD iThreadId;

        CreateThread(NULL,
                     0,
                     (LPTHREAD_START_ROUTINE) vTestFPU,
                     (LPVOID) i,
                     0,
                     &iThreadId);
    }

    while (TRUE)
    {
        Sleep(10000000);
    }

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\sprite\wndstuff.c ===
/******************************Module*Header*******************************\
* Module Name: wndstuff.c
*
* This file contains the code to support a simple window that has
* a menu with a single item called "Test". When "Test" is selected
* vTest(HWND) is called.
*
* Created: 09-Dec-1992 10:44:31
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1991 Microsoft Corporation
*
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "wndstuff.h"

HANDLE  ghInstance;
HWND    ghwndMain;
HBRUSH  ghbrWhite;

/***************************************************************************\
* main(argc, argv[])
*
* Sets up the message loop.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

_cdecl
main(
    INT   argc,
    PCHAR argv[])
{
    MSG    msg;
    HANDLE haccel;

    DONTUSE(argc);
    DONTUSE(argv);

    ghInstance = GetModuleHandle(NULL);

    if (!bInitApp())
    {
        return(0);
    }

    haccel = LoadAccelerators(ghInstance, MAKEINTRESOURCE(1));
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(msg.hwnd, haccel, &msg))
        {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }
    return(1);
}

/***************************************************************************\
* bInitApp()
*
* Initializes app.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

BOOL bInitApp(VOID)
{
    WNDCLASS wc;

    ghbrWhite = CreateSolidBrush(RGB(0xFF,0xFF,0xFF));

    wc.style            = 0;
    wc.lpfnWndProc      = lMainWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = 0;
    wc.hInstance        = ghInstance;
    wc.hIcon            = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = ghbrWhite;
    wc.lpszMenuName     = "MainMenu";
    wc.lpszClassName    = "TestClass";
    if (!RegisterClass(&wc))
    {
        return(FALSE);
    }
    ghwndMain =
      CreateWindowEx(
        0,
        "TestClass",
        "Win32 Test",
        MY_WINDOWSTYLE_FLAGS,
        80,
        70,
        400,
        80,
        NULL,
        NULL,
        ghInstance,
        NULL
        );
    if (ghwndMain == NULL)
    {
        return(FALSE);
    }
    SetFocus(ghwndMain);
    return(TRUE);
}

/***************************************************************************\
* lMainWindowProc(hwnd, message, wParam, lParam)
*
* Processes all messages for the main window.
*
* History:
*  04-07-91 -by- KentD
* Wrote it.
\***************************************************************************/

LONG
lMainWindowProc(
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    if (hwnd == ghwndMain)
    {
        switch (message)
        {
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
            case MM_DELETE:         vDelete(hwnd);           break;
            case MM_CONSTANTALPHA:  vConstantAlpha(hwnd);    break;
            case MM_PERPIXELALPHA:  vPerPixelAlpha(hwnd);    break;
            case MM_OPAQUE1:        vOpaque1(hwnd);          break;
            case MM_COLORKEY1:      vColorKey1(hwnd);        break;
            case MM_FLIP:           vFlip(hwnd);             break;
            case MM_MINIMIZE:       vMinimize(hwnd);         break;
            case MM_FADE:           vFade(hwnd);             break;
            case MM_BZZT:           vBzzt(hwnd);             break;
            case MM_WIPE1:          vWipe1(hwnd);            break;
            case MM_WIPE2:          vWipe2(hwnd);            break;
            case MM_WIPE3:          vWipe3(hwnd);            break;
            case MM_WIPE4:          vWipe4(hwnd);            break;
            case MM_TIMEREFRESH:    vTimeRefresh(hwnd);      break;
            }
            break;
    
        case WM_MOVE:
            vMove((short) LOWORD(lParam), (short) HIWORD(lParam));
            break;
    
        case WM_DESTROY:
    
            DeleteObject(ghbrWhite);
            PostQuitMessage(0);
            return(DefWindowProc(hwnd, message, wParam, lParam));
    
        default:
    
            return(DefWindowProc(hwnd, message, wParam, lParam));
        }
    }
    else
    {
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\sprite\wndstuff.h ===
/****************************** Module Header ******************************\
* Module Name: hello.h
*
* Kent's Window Test.  To be used as a program template.
*
* Created: 09-May-91
* Author: KentD
*
* Copyright (c) 1991 Microsoft Corporation
\***************************************************************************/

#define DONTUSE(x) (x)

#define MM_NEW              0x8001
#define MM_EXIT             0x8002
#define MM_DELETE           0x8003
#define MM_CONSTANTALPHA    0x8004
#define MM_OPAQUE1          0x8005
#define MM_COLORKEY1        0x8006
#define MM_CLIP             0x8007
#define MM_FLIP             0x8008
#define MM_MINIMIZE         0x8009
#define MM_PERPIXELALPHA    0x800a
#define MM_FADE             0x800b
#define MM_BZZT             0x800c
#define MM_WIPE1            0x800d
#define MM_WIPE2            0x800e
#define MM_WIPE3            0x800f
#define MM_WIPE4            0x8010
#define MM_TIMEREFRESH      0x8011

#define POPUP_BITMAP        0x9000
#define SMALL_BITMAP        0x9001
#define APP_BITMAP          0x9002

BOOL bInitApp(VOID);
LONG lMainWindowProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

#define MY_WINDOWSTYLE_FLAGS       \
            (                      \
                WS_OVERLAPPED   |  \
                WS_CAPTION      |  \
                WS_BORDER       |  \
                WS_THICKFRAME   |  \
                WS_MAXIMIZEBOX  |  \
                WS_MINIMIZEBOX  |  \
                WS_CLIPCHILDREN |  \
                WS_VISIBLE      |  \
                WS_SYSMENU         \
            )

VOID vCreateSprite(HDC, LONG, LONG);
VOID vDelete(HWND);
VOID vConstantAlpha(HWND);
VOID vPerPixelAlpha(HWND);
VOID vOpaque1(HWND);
VOID vColorKey1(HWND);
VOID vClip();
VOID vMove(LONG, LONG);
VOID vMinimize(HWND);
VOID vFlip(HWND);
VOID vFade(HWND);
VOID vBzzt(HWND);
VOID vWipe1(HWND);
VOID vWipe2(HWND);
VOID vWipe3(HWND);
VOID vWipe4(HWND);
VOID vTimeRefresh(HWND);

POINT gptlSprite;
HWND ghSprite;
LONG gcxPersp;
LONG gcyPersp;
HANDLE ghInstance;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\gen-shap.cpp ===
//	gen-shap.cpp:	template for the generic CTE_GenShape class

#include <stdafx.h>
#include <gen-shap.h>
#include <te-globals.h>
#include <te-outline.h>
#include <te-placement.h>
#include <te-image.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_GenShape::CTE_GenShape()
{
	//	init...
	CreateParameters();
}

CTE_GenShape::CTE_GenShape(CTE_GenShape const& te)
{
	//	te heap objects require new
	//	init...
	CreateParameters();
}

CTE_GenShape::CTE_GenShape(CString const& name)
{
	SetName(name);
	//	init...
	CreateParameters();
}

CTE_GenShape::~CTE_GenShape()
{
	//	delete heap objects
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods


//////////////////////////////////////////////////////////////////////////////
//	Generic CTE_Shape operations

void
CTE_GenShape::CreateParameters(void)
{
}

void	
CTE_GenShape::Dump(void) const
{
	CTE_Shape::Dump();

	//	Dump effect-specific data...
}

//////////////////////////////////////////////////////////////////////////////
//	Effect-specific operations

void
CTE_GenShape::Modify
(
	CTE_Outline const& outline, 
	CTE_Placement const& pl
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\gen-oper.h ===
//	gen-oper.h:	template for the generic CTE_GenOperator class

//	To add a new operator effect:
//		(1) globally replace GenOperator with the effect name,
//		(2) add effect-specific data members and access methods (if required),
//		(3)	implement the copy constructor,
//		(4) implement Dump(),
//		(5) implement Apply(),
//		(6) add effect-specific operations (if required).

#ifndef TE_GEN_OPERATOR_DEFINED
#define TE_GEN_OPERATOR_DEFINED

#include <te-operator.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_GenOperator : public CTE_Operator
{
//	Interface:
public:
	CTE_GenOperator();
	CTE_GenOperator(CString const& name);
	CTE_GenOperator(CTE_GenOperator const& te);
	virtual ~CTE_GenOperator();

	//	Data access methods

	//	Operations
	virtual	void	CreateParameters(void);
	virtual	void	Dump(void) const;
	void			Combine
					(
						CTE_Outline const& outline,
						CTE_Placement const& pl, 
						CTE_Image args[],
						CTE_Image& result
					);

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\gen-shap.h ===
//	gen-shap.h:	template for the generic CTE_GenShape class

//	To add a new shape effect:
//		(1) globally replace GenShape with the effect name,
//		(2) add effect-specific data members and access methods (if required),
//		(3)	implement the copy constructor,
//		(4) implement Dump(),
//		(5) implement Apply(),
//		(6) add effect-specific operations (if required).

#ifndef TE_GEN_SHAPE_DEFINED
#define TE_GEN_SHAPE_DEFINED

#include <te-shape.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_GenShape : public CTE_Shape
{
//	Interface:
public:
	CTE_GenShape();
	CTE_GenShape(CString const& name);
	CTE_GenShape(CTE_GenShape const& te);
	virtual ~CTE_GenShape();

	//	Data access methods

	//	Operations
	virtual	void	CreateParameters(void);
	virtual	void	Dump(void) const;
	void			Modify
					(
						CTE_Outline const& outline, 
						CTE_Placement const& pl
					);

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\gen-text.h ===
//	gen-text.h:	template for the generic CTE_GenTexture class

//	To add a new texture effect:
//		(1) globally replace GenTexture with the effect name,
//		(2) add effect-specific data members and access methods (if required),
//		(3)	implement the copy constructor,
//		(4) implement Dump(),
//		(5) implement Apply(),
//		(6) add effect-specific operations (if required).

#ifndef TE_GEN_TEXTURE_DEFINED
#define TE_GEN_TEXTURE_DEFINED

#include <te-texture.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_GenTexture : public CTE_Texture
{
//	Interface:
public:
	CTE_GenTexture();
	CTE_GenTexture(CTE_GenTexture const& te);
	CTE_GenTexture(CString const& name);
	virtual ~CTE_GenTexture();

	//	Data access methods

	//	Operations
	virtual void	CreateParameters(void);
	virtual	void	Dump(void) const;
	void	Generate
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					);

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\gen-text.cpp ===
//	gen-text.cpp:	template for the generic CTE_GenTexture class

#include <stdafx.h>
#include <gen-text.h>
#include <te-globals.h>
#include <te-image.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_GenTexture::CTE_GenTexture()
{
	//	init...
	CreateParameters();
}

CTE_GenTexture::CTE_GenTexture(CTE_GenTexture const& te)
{
	//	te heap objects require new
	//	init...
	CreateParameters();
}

CTE_GenTexture::CTE_GenTexture(CString const& name)
{
	SetName(name);
	//	init...
	CreateParameters();
}
	
CTE_GenTexture::~CTE_GenTexture()
{
	//	delete heap objects
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods


//////////////////////////////////////////////////////////////////////////////
//	Generic CTE_Texture operations

void
CTE_GenTexture::CreateParameters(void)
{
}

void	
CTE_GenTexture::Dump(void) const
{
	CTE_Texture::Dump();

	//	Dump effect-specific data...
}

//////////////////////////////////////////////////////////////////////////////
//	Effect-specific operations

void	
CTE_GenTexture::Generate
(
	CTE_Outline const& outline,	// copy may be passed on
	CTE_Placement const& pl, 
	CTE_Image& result
)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\gen-oper.cpp ===
//	gen-oper.cpp:	template for the generic CTE_GenOperator class

#include <stdafx.h>
#include <gen-oper.h>
#include <te-globals.h>
#include <te-image.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_GenOperator::CTE_GenOperator()
{
	//	init...
	CreateParameters();
}

CTE_GenOperator::CTE_GenOperator(CTE_GenOperator const& te)
{
	//	te heap objects require new
	//	init...
	CreateParameters();
}

CTE_GenOperator::CTE_GenOperator(CString const& name)
{
	SetName(name);
	//	init...
	CreateParameters();
}	

CTE_GenOperator::~CTE_GenOperator()
{
	//	delete heap objects
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods


//////////////////////////////////////////////////////////////////////////////
//	Generic CTE_Operator operations

void
CTE_GenOperator::CreateParameters(void)
{
}

void	
CTE_GenOperator::Dump(void) const
{
	CTE_Operator::Dump();

	//	Dump effect-specific data...
}

//////////////////////////////////////////////////////////////////////////////
//	Effect-specific operations

void
CTE_GenOperator::Combine
(
	CTE_Outline const& outline,
	CTE_Placement const& pl, 
	CTE_Image args[],
	CTE_Image& result
)
{
	//	Combine child images (args) to give result
	for (int i = 0; i < GetNumChildren(); i++)
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\box.h ===
// box.h:	definition of the CBox class

//	Cameron Browne
//	10/20/1998	

#ifndef CBOX_DEFINED
#define CBOX_DEFINED

#include <math.h>

//////////////////////////////////////////////////////////////////////////////

class CBox
{
//	Interface:
public:
	//	Constructors/destructor
	CBox()	{ m_Left = m_Top = m_Right = m_Bottom = 0.0; }
	CBox(CBox const& box)
	{
		m_Left = box.m_Left;
		m_Top = box.m_Top;
		m_Right = box.m_Right;
		m_Bottom = box.m_Bottom;
	}
	CBox(double  l, double  t, double  r, double  b)
	{
		m_Left = l;  m_Top = t;  m_Right = r;  m_Bottom = b; 
	}
	~CBox()	{}

	//	Set/get size of box
	void	SetBox(double  l, double  t, double  r, double  b)
			{
				m_Left = l;  m_Top = t;  m_Right = r;  m_Bottom = b; 
			}
	void	GetBox(double& l, double& t, double& r, double& b) const
			{
				l = m_Left;  t = m_Top;  r = m_Right;  b = m_Bottom; 
			}
	
	//	Get box boundaries
	double	Left(void) const			{ return m_Left; }
	double	Top(void) const				{ return m_Top; }
	double	Right(void) const			{ return m_Right; }
	double	Bottom(void) const			{ return m_Bottom; }
		
	//	Get box characteristics
	double	Width(void) const			{ return fabs(m_Right - m_Left); }
	double	Height(void) const			{ return fabs(m_Bottom - m_Top); }
	void	Centre(double& x, double& y) const		
			{ 
				x = (m_Left + m_Right) * 0.5; 
				y = (m_Top + m_Bottom) * 0.5; 
			}
	double	Area(void) const			{ return Width() * Height(); }

	//	Expand uniformly in all directions
	void	Expand(double all)
			{
				m_Left -= all;
				m_Top -= all;
				m_Right += all;
				m_Bottom += all;
			}

	//	Expand at different rates in the horz and vert direction
	void	Expand(double horz, double vert)
			{
				m_Left -= horz;
				m_Top -= vert;
				m_Right += horz;
				m_Bottom += vert;
			}

	//	Expand at different rates in all four directions
	void	Expand(double l, double t, double r, double b)
			{
				m_Left -= l;
				m_Top -= t;
				m_Right += r;
				m_Bottom += b;
			}

	//	Returns:
	//		Whether the specified box overlaps with this one
	BOOL	Overlap(CBox const& box) const
			{
				if (m_Right < box.m_Left)
					return FALSE;
				if (box.m_Right < m_Left)
					return FALSE;
				if (m_Bottom < box.m_Top)
					return FALSE;
				if (box.m_Bottom < m_Top)
					return FALSE;
				return TRUE;
			}
	
	//	Returns:
	//		Whether the point(x, y) is inside this box (or on its boundary)
	BOOL	PtInBox(double x, double y) const
			{
				return 
				(
					x >= m_Left && x <= m_Right 
					&& 
					y >= m_Top && y <= m_Bottom
				);
			}
	
	CBox const&	operator= (CBox const& box)
			{
				if (this != &box)
				{
					m_Left = box.m_Left;
					m_Top = box.m_Top;
					m_Right = box.m_Right;
					m_Bottom = box.m_Bottom;
				}
				return *this;
			}

	void	Dump(void) const
			{
				TRACE
				(
					"[(%.3f,%.3f),(%.3f,%.3f)] ", 
					m_Left, m_Top, m_Right, m_Bottom
				);
			}

//	Private data members:
private:
	double		m_Left;
	double		m_Top;
	double		m_Right;
	double		m_Bottom;
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "te.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by TE.RC
//
#define IDD_ABOUTBOX				100
#define IDR_MAINFRAME				128
#define IDR_TETYPE				129

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS			1
#define _APS_NEXT_RESOURCE_VALUE	130
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__C312667C_63A7_11D2_9138_00A0C970228E__INCLUDED_)
#define AFX_MAINFRM_H__C312667C_63A7_11D2_9138_00A0C970228E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__C312667C_63A7_11D2_9138_00A0C970228E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__C312667A_63A7_11D2_9138_00A0C970228E__INCLUDED_)
#define AFX_STDAFX_H__C312667A_63A7_11D2_9138_00A0C970228E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C312667A_63A7_11D2_9138_00A0C970228E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-branch.cpp ===
//	te-Branch.cpp:	implementation of the CTE_Branch class

#include <stdafx.h>
#include <te-Branch.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

//	No children
CTE_Branch::CTE_Branch()		
{
}

//	N children
CTE_Branch::CTE_Branch(int num, CTE_Effect** ppChild)
{ 
	for (int i = 0; i < num; i++)
		m_pChildren.push_back(ppChild[i]);
}
	
//	1 child
CTE_Branch::CTE_Branch(CTE_Effect* pChild)
{
	m_pChildren.push_back(pChild);
}

//	2 children	
CTE_Branch::CTE_Branch(CTE_Effect* pChild0, CTE_Effect* pChild1)
{
	m_pChildren.push_back(pChild0);	
	m_pChildren.push_back(pChild1);	
}

//	3 children
CTE_Branch::CTE_Branch
(
	CTE_Effect* pChild0, 
	CTE_Effect* pChild1, 
	CTE_Effect* pChild2
)
{
	m_pChildren.push_back(pChild0);	
	m_pChildren.push_back(pChild1);	
	m_pChildren.push_back(pChild2);	
}

//	4 children
CTE_Branch::CTE_Branch
(
	CTE_Effect* pChild0, 
	CTE_Effect* pChild1, 
	CTE_Effect* pChild2, 
	CTE_Effect* pChild3
)
{
	m_pChildren.push_back(pChild0);	
	m_pChildren.push_back(pChild1);	
	m_pChildren.push_back(pChild2);	
	m_pChildren.push_back(pChild3);
}

CTE_Branch::~CTE_Branch()		
{ 
	DeleteChildren(); 
}

//////////////////////////////////////////////////////////////////////////////
//	Data member access

//	Set first child
void		
CTE_Branch::SetChild(CTE_Effect* pChild) 
{	
	if (m_pChildren.size() <= 0)
	{
		//	Add new child pointer
		m_pChildren.push_back(pChild);
	}
	else
	{
		//	Replace existing child pointer
		m_pChildren[0] = pChild; 
	}
}

//	Convenient way to set 2 children
void		
CTE_Branch::SetChildren(CTE_Effect* pChild0, CTE_Effect* pChild1) 
{	
	int num_children = 2; 
	for (int n = 0; n < num_children; n++)
	{
		CTE_Effect* pChild;
		switch(n)
		{
		case 0:		pChild = pChild0;	break;
		case 1:		pChild = pChild1;	break;
		default:	break;
		}
		
		if (m_pChildren.size() <= n)
		{	
			//	Add new child pointer
			m_pChildren.push_back(pChild);
		}
		else
		{
			//	Replace existing child pointer
			m_pChildren[n] = pChild; 
		}
	}
}

//	Convenient way to set 3 children
void		
CTE_Branch::SetChildren
(
	CTE_Effect* pChild0, 
	CTE_Effect* pChild1, 
	CTE_Effect* pChild2
) 
{	
	int num_children = 3; 
	for (int n = 0; n < num_children; n++)
	{
		CTE_Effect* pChild;
		switch(n)
		{
		case 0:		pChild = pChild0;	break;
		case 1:		pChild = pChild1;	break;
		case 2:		pChild = pChild2;	break;
		default:	break;
		}
		
		if (m_pChildren.size() <= n)
		{	
			//	Add new child pointer
			m_pChildren.push_back(pChild);
		}
		else
		{
			//	Replace existing child pointer
			m_pChildren[n] = pChild; 
		}
	}
}

//	Convenient way to set 4 children
void		
CTE_Branch::SetChildren
(
	CTE_Effect* pChild0, 
	CTE_Effect* pChild1, 
	CTE_Effect* pChild2, 
	CTE_Effect* pChild3
) 
{	
	int num_children = 4; 
	for (int n = 0; n < num_children; n++)
	{
		CTE_Effect* pChild;
		switch(n)
		{
		case 0:		pChild = pChild0;	break;
		case 1:		pChild = pChild1;	break;
		case 2:		pChild = pChild2;	break;
		case 3:		pChild = pChild3;	break;
		default:	break;
		}
		
		if (m_pChildren.size() <= n)
		{	
			//	Add new child pointer
			m_pChildren.push_back(pChild);
		}
		else
		{
			//	Replace existing child pointer
			m_pChildren[n] = pChild; 
		}
	}
}

void		
CTE_Branch::ReplaceChild(int i, CTE_Effect* pChild) 
{	
	ASSERT(i >= 0 && i < m_pChildren.size()); 
	delete m_pChildren[i];	//??
	m_pChildren[i] = pChild; 
}

//////////////////////////////////////////////////////////////////////////////
//	Operations

void		
CTE_Branch::DeleteChildren(void)
{
	//	Delete heap objects
	for (int i = 0; i < m_pChildren.size(); i++)
		delete m_pChildren[i];

	//	Delete collection of pointers
	m_pChildren.empty();
}

void	
CTE_Branch::Dump(void) const
{
	CTE_Primitive::Dump();

	TRACE("\nCTE_Branch: has %d children %d.", m_pChildren.size());
	for (int i = 0; i < m_pChildren.size(); i++)
	{
		TRACE("\n  child %d is %p.", i, m_pChildren[i]);
		if (m_pChildren[i] != NULL)
		m_pChildren[i]->Dump();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	te.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-branch.h ===
//	te-branch.h:	definition of the CTE_Branch class

//	CTE_Branch is a generic class for primitive effects that are 
//	branches in the expressiont tree (ie. they have children):
//		(1)	CTE_Shape effects
//		(2)	CTE_Operator effects

#ifndef TE_BRANCH_DEFINED
#define TE_BRANCH_DEFINED

#include <te-primitive.h>
#include <vector>

//////////////////////////////////////////////////////////////////////////////

class CTE_Branch : public CTE_Primitive
{
//	Interface:
public:
	CTE_Branch();
	CTE_Branch(int num, CTE_Effect** ppChild);
	CTE_Branch(CTE_Effect* pChild);
	CTE_Branch(CTE_Effect* pChild0, CTE_Effect* pChild1);
	CTE_Branch
	(
		CTE_Effect* pChild0, 
		CTE_Effect* pChild1, 
		CTE_Effect* pChild2
	);
	CTE_Branch
	(
		CTE_Effect* pChild0, 
		CTE_Effect* pChild1, 
		CTE_Effect* pChild2, 
		CTE_Effect* pChild3
	);
	virtual ~CTE_Branch();

	int			GetNumChildren(void) const		
				{ 
					return m_pChildren.size(); 
				}
	CTE_Effect*	GetChild(int i) const
				{	
					ASSERT(i >= 0 && i < m_pChildren.size()); 
					return m_pChildren[i]; 
				}
	void		SetChild(int i, CTE_Effect* pChild)
				{
					ASSERT(i >= 0 && i < m_pChildren.size()); 
					m_pChildren[i] = pChild; 
				}
	CTE_Effect*	GetChild(void) const
				{
					ASSERT(m_pChildren.size() >= 1); 
					return m_pChildren[0]; 
				}
	void		SetChild(CTE_Effect* pChild);
	void		SetChildren(CTE_Effect* pChild0, CTE_Effect* pChild1);
	void		SetChildren
				(
					CTE_Effect* pChild0, 
					CTE_Effect* pChild1, 
					CTE_Effect* pChild2
				);
	void		SetChildren
				(
					CTE_Effect* pChild0, 
					CTE_Effect* pChild1, 
					CTE_Effect* pChild2, 
					CTE_Effect* pChild3
				);
	void		ReplaceChild(int i, CTE_Effect* pChild);
	BOOL		AddChild(CTE_Effect* pChild)
				{
					m_pChildren.push_back(pChild); 
				}

	void		DeleteChildren(void);

	virtual	void	CreateParameters(void) = 0;
	virtual	void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					) = 0;

//	Private data members:
private:
	std::vector<CTE_Effect *>	m_pChildren;	//  child effects or arguments
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-effect.cpp ===
// te-effect.cpp:	implementation of the CTE_Effect class

#include <stdafx.h>
#include <te-effect.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Effect::CTE_Effect()	
{
	m_Name = "unknown";
	m_Category = "general";
	SetSpace(TE_DEFAULT_SPACE);
	m_Index = -1;
}

CTE_Effect::CTE_Effect(CString const& name, CString const& cat, TE_SpaceTypes space, int index)
{ 
	m_Name = name; 
	m_Category = cat; 
	SetSpace(space);
	m_Index = index;
}

CTE_Effect::~CTE_Effect()	
{
}
	
//////////////////////////////////////////////////////////////////////////////

void			
CTE_Effect::Dump(void) const
{
	TRACE
	(
		"\n  CTE_Effect: name=\"%s\", category=\"%s\" space=%d, index=%d.", 
		m_Name, m_Category, m_Space, m_Index
	);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-fill.h ===
//	te-fill.h:	template for the generic CTE_Fill class

//	To add a new texture effect:
//		(1) globally replace Fill with the effect name,
//		(2) add effect-specific data members and access methods (if required),
//		(3)	implement the copy constructor,
//		(4) implement Dump(),
//		(5) implement Apply(),
//		(6) add effect-specific operations (if required).

#ifndef TE_Fill_DEFINED
#define TE_Fill_DEFINED

#include <te-texture.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_Fill : public CTE_Texture
{
//	Interface:
public:
	CTE_Fill();
	CTE_Fill(CTE_Fill const& te);
	CTE_Fill(CString const& name);
	virtual ~CTE_Fill();

	//	Data access methods
	void	SetRGBA(BYTE const rgba[4]);
	void	SetRGBA(BYTE r, BYTE g, BYTE b, BYTE a);
	void	GetRGBA(BYTE rgba[4]) const;

	//	Operations
	virtual	void	CreateParameters(void);
	virtual	void	Dump(void) const;
	void	Generate
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					);

//	Private data members:
private:
	BYTE	m_RGBA[4];			

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-globals.h ===
// te-globals.h:	definition of globals

#ifndef TE_GLOBALS_DEFINED
#define TE_GLOBALS_DEFINED

//////////////////////////////////////////////////////////////////////////////
//	Global constants

static	const	double	PI					= 3.1415926535897932384626433832795;
static	const	char*	TE_EXTENSION		= "te";
static	const	CString	TE_DEFAULT_LOCATION	= "d:\\src\\te\\lib";
//static	const	char*	TE_DEFAULT_LOCATION	= "d:\\src\\te\\lib\\n";
static	const	int		TE_MAX_PATH_SIZE	= 128;
static	const	BYTE	TE_RGBA_LOWER[4]	= {	0,	0,	0,	0 };
static	const	BYTE	TE_RGBA_UPPER[4]	= { 255,255,255,255 };

//////////////////////////////////////////////////////////////////////////////
//	Types


//////////////////////////////////////////////////////////////////////////////
//	Effect spaces

static enum TE_SpaceTypes
{
	TE_SPACE_CHAR_BB,	//	Character context, relative to bounding box
	TE_SPACE_CHAR_EM,	//	Character context, relative to em square
	TE_SPACE_STR_INC,	//	String context, incrementally applied
	TE_SPACE_STR_HOL,	//	String context, holistically applied
	TE_SPACE_TYPES
};

static TE_SpaceTypes TE_DEFAULT_SPACE = TE_SPACE_CHAR_EM;

//	Flags corresponding to effect spaces
static	const	BYTE	TE_SPACE_CHAR_BB_FLAG = (1 << TE_SPACE_CHAR_BB);
static	const	BYTE	TE_SPACE_CHAR_EM_FLAG = (1 << TE_SPACE_CHAR_EM);
static	const	BYTE	TE_SPACE_STR_INC_FLAG = (1 << TE_SPACE_STR_INC);
static	const	BYTE	TE_SPACE_STR_HOL_FLAG = (1 << TE_SPACE_STR_HOL);

static char* TE_SpaceNames[TE_SPACE_TYPES] =
{
	"char bounding box",
	"char em square",
	"string incremental",
	"string holistic",
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-image.h ===
//	te-image.h:	definition of the CTE_Image class

#ifndef TE_IMAGE_DEFINED
#define TE_IMAGE_DEFINED

//////////////////////////////////////////////////////////////////////////////

class CTE_Image
{
//	Interface:
public:
	CTE_Image();
	CTE_Image(CTE_Image const& img);
	CTE_Image(CDC* pdc);
	virtual ~CTE_Image();

//	inline	void	SetDC(CDC* pdc);
	inline	CDC*	GetDC(void) const				{ return m_pDC;	}
//	inline	void	SetSize(int  x, int  y);
//	inline	void	SetSize(CSize const& sz);
	inline	CSize	GetSize(void) const				{ return m_Size; }
	inline	void	SetActive(CRect const& active)	{ m_Active = active; }
	inline	CRect	GetActive(void) const			{ return m_Active; }

	void			PrepareImage(CDC* pdc);

//	Private data members:
private:
	CDC*	m_pDC;			// device context containing bitmap
	CBitmap* m_pBitmap;		// the bitmap in question
	CSize	m_Size;			// size of bitmap
	CRect	m_Active;		// active region

	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-image.cpp ===
//	te-image.cpp:	implementation of the CTE_Image class

#include <stdafx.h>
#include <te-image.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Image::CTE_Image() :	
	m_pDC(NULL),
	m_pBitmap(NULL),
	m_Size(0, 0),
	m_Active(0, 0, 0, 0)
{
}

	CTE_Image::CTE_Image(CTE_Image const& img)	:
	m_pDC(NULL),
	m_pBitmap(NULL),
	m_Size(0, 0),
	m_Active(0, 0, 0, 0)
{
	PrepareImage(img.GetDC());
}

CTE_Image::CTE_Image(CDC* pdc)	:
	m_pDC(NULL),
	m_pBitmap(NULL),
	m_Size(0, 0),
	m_Active(0, 0, 0, 0)
{
	PrepareImage(pdc);
}

CTE_Image::~CTE_Image() 
{
	delete m_pBitmap;
	delete m_pDC;
}

//////////////////////////////////////////////////////////////////////////////
//	Data member access functions


//////////////////////////////////////////////////////////////////////////////
//	Operations

void
CTE_Image::PrepareImage(CDC* pdc)
{
	delete m_pDC;
	m_pDC = new CDC;
			
	delete m_pBitmap;
	m_pBitmap = new CBitmap;
	
	m_pDC->CreateCompatibleDC(pdc);
	ASSERT(pdc->GetCurrentBitmap() != NULL);
	
	//	Get details of existing bitmap
	/*
	BITMAP bm;
	pdc->GetCurrentBitmap()->GetBitmap(&bm);
	TRACE
	(
		"\nBITMAP structure:\n  bmType=%d\n  bmWidth=%d\n  bmHeight=%d\n  bmWidthBytes=%d  \n  bmPlanes=%d\n  bmBitsPixel=%d\n  bmBits=%p.", 
		bm.bmType,
		bm.bmWidthBytes,
		bm.bmPlanes,
		bm.bmBitsPixel,
		bm.bmBits
	);
	pBitmap->CreateCompatibleBitmap(pdc, bm.bmWidth, bm.bmHeight);
	*/
	
	CSize sz = pdc->GetCurrentBitmap()->GetBitmapDimension();
	m_pBitmap->CreateCompatibleBitmap(pdc, sz.cx, sz.cy);

	m_pDC->SelectObject(m_pBitmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-fill.cpp ===
//	te-fill.cpp:	template for the generic CTE_Fill class

#include <stdafx.h>
#include <te-fill.h>
#include <te-globals.h>
#include <te-image.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Fill::CTE_Fill()
{
	//	init...
	SetRGBA(255, 0, 0, 255);
	CreateParameters();
}

CTE_Fill::CTE_Fill(CTE_Fill const& te)
{
	//	te heap objects require new
	//	init...
	SetRGBA(te.m_RGBA);
	CreateParameters();
}

CTE_Fill::CTE_Fill(CString const& name)
{
	SetName(name);
	//	init...
	SetRGBA(255, 0, 0, 255);
	CreateParameters();
}
	
CTE_Fill::~CTE_Fill()
{
	//	delete heap objects
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods

void	
CTE_Fill::SetRGBA(BYTE const rgba[4])
{
	memcpy(m_RGBA, rgba, 4);
}

void	
CTE_Fill::SetRGBA(BYTE r, BYTE g, BYTE b, BYTE a)
{
	m_RGBA[0] = r;
	m_RGBA[1] = g;
	m_RGBA[2] = b;
	m_RGBA[3] = a;
}

void	
CTE_Fill::GetRGBA(BYTE rgba[4]) const
{
	memcpy(rgba, m_RGBA, 4);
}

//////////////////////////////////////////////////////////////////////////////
//	Generic CTE_Texture operations

void
CTE_Fill::CreateParameters(void)
{
	AddParam
	(
		new CTE_Param(m_RGBA, TE_RGBA_LOWER, TE_RGBA_UPPER, "fill color")
	);
}

void	
CTE_Fill::Dump(void) const
{
	CTE_Texture::Dump();

	//	Dump effect-specific data...
}

//////////////////////////////////////////////////////////////////////////////
//	Effect-specific operations

void	
CTE_Fill::Generate
(
	CTE_Outline const& outline,	// copy may be passed on
	CTE_Placement const& pl, 
	CTE_Image& result
)
{
	TRACE("\n* Generating texture...");
	CDC* pDC = result.GetDC();

	//	Set color/brush
	//pDC->

	//	Draw path
	//pDC->

	//	Fill path
	//pDC->

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-library.h ===
// te-library.h:	defition of the CTE_Library class

#ifndef TE_LIBRARY_DEFINED
#define TE_LIBRARY_DEFINED

#include <te-effect.h>
#include <vector>

//////////////////////////////////////////////////////////////////////////////

class CTE_Library
{
//	Interface:
public:
	CTE_Library();
	~CTE_Library();

	int			GetNumEffects(void) const	{ return m_pEffects.size(); }
	CTE_Effect*	GetEffect(int i) const;
	CTE_Effect*	GetEffect(CString const& name) const;
	void		SetEffect(int i, CTE_Effect* pEffect);
	void		ReplaceEffect(int i, CTE_Effect* pEffect);
	BOOL		AddEffect(CTE_Effect* pEffect);

	void		Init(void);
	void		Dump(void) const;
	
private:
	BOOL		CreateEffects(void);
	void		DeleteEffects(void);
	
//	Private data members:
private:
	std::vector<CTE_Effect *>	m_pEffects;	//	collection of effects
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-effect.h ===
// te-effect.h:	definition of the CTE_Effect class

#ifndef TE_EFFECT_DEFINED
#define TE_EFFECT_DEFINED

#include <te-globals.h>

class CTE_Outline;
class CTE_Placement;
class CTE_Image;

//////////////////////////////////////////////////////////////////////////////

class CTE_Effect
{
//	Interface:
public:
	CTE_Effect();
	CTE_Effect
	(
		CString const& name, 
		CString const& cat = "general", 
		TE_SpaceTypes space = TE_SPACE_CHAR_EM, 
		int index = -1
	);
	virtual ~CTE_Effect();

	void			SetName(CString const& name)	{ m_Name = name; }
	void			GetName(CString& name) const	{ name = m_Name; }
	CString const&	GetName(void) const				{ return m_Name; }
	void			SetCategory(CString const& cat)	{ m_Category = cat; }
	void			GetCategory(CString& cat) const	{ cat = m_Category; }
	CString const&	GetCategory(void) const			{ return m_Category; }
	
	void			SetIndex(int index)				{ m_Index = index; }
	int				GetIndex(void) const			{ return m_Index; }
	
	void			SetSpace(TE_SpaceTypes space)	{ m_Space = (1 << space); }
	void			AddSpace(TE_SpaceTypes space)	{ m_Space |= (1 << space); }
	void			RemoveSpace(TE_SpaceTypes space)	
					{ 
						if ( (m_Space & !(1 << space)) == 0 )
							TRACE("\nCTE_Effect::RemoveSpace(%d):  will make m_Space = 0.", space);
						else
							m_Space &= !(1 << space); 
					}
	BYTE			GetSpace(void) const			{ return m_Space; }

	virtual void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					) = 0;

//	Private data members:
private:
	CString			m_Name;		// unique effect name
	CString			m_Category;	// broad category to which this effect belongs
	int				m_Index;	// index unique to current effect	
	BYTE			m_Space;	// space in which this effect is applied
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-library.cpp ===
// te-library.cpp:	implementation of the CTE_Library class

#include <stdafx.h>
#include <te-library.h>
#include <te-globals.h>
#include <te-textout.h>
#include <direct.h>		//	for chdir()

//	Effect definitions
#include <te-fill.h>
#include <te-stroke.h>
#include <te-over.h>
#include <te-shift.h>
#include <te-blur.h>

#define new DEBUG_NEW

extern int			TE_Antialias;// = 1;	//	1 is "off"static 
extern CString		TE_Location;// = "d:\\src\\te\\lib";	//	locn of user-defined te files

//////////////////////////////////////////////////////////////////////////////

CTE_Library::CTE_Library()	
{
	Init();
}

CTE_Library::~CTE_Library()	
{ 
	DeleteEffects(); 
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods

CTE_Effect*	
CTE_Library::GetEffect(int i) const			
{ 
	ASSERT(i >= 0 && i < m_pEffects.size()); 
	return m_pEffects[i]; 
}

CTE_Effect*	
CTE_Library::GetEffect(CString const& name) const			
{ 
	for (int i = 0; i < m_pEffects.size(); i++)
	{
		if (m_pEffects[i]->GetName() == name)
			return m_pEffects[i];
	}

	//	Effect name not found in library
	TRACE("\nCTE_Library::GetEffect(): Effect named %s not present.", name);
	return NULL;
}

void		
CTE_Library::SetEffect(int i, CTE_Effect* pEffect) 
{
	ASSERT(i >= 0 && i < m_pEffects.size()); 
	m_pEffects[i] = pEffect; 
}

void		
CTE_Library::ReplaceEffect(int i, CTE_Effect* pEffect) 
{
	ASSERT(i >= 0 && i < m_pEffects.size()); 
	delete m_pEffects[i];	// ??
	m_pEffects[i] = pEffect; 
}
	
//	Returns:
//		Whether pEffect was added sucessfully to the library
BOOL		
CTE_Library::AddEffect(CTE_Effect* pEffect)	
{ 
	for (int i = 0; i < m_pEffects.size(); i++)
		if (m_pEffects[i]->GetName() == pEffect->GetName())
		{
			//	Effect name is already used in library
			TRACE("\nEffect %s is already present in the library.", pEffect->GetName());
			return FALSE;
		}

	m_pEffects.push_back(pEffect); 
	return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//	Operations

void
CTE_Library::Init(void)
{
	CString TE_Location = TE_DEFAULT_LOCATION;
	
	char buff[128];
	for (int c = 0; c < TE_Location.GetLength(); c++)
		buff[c] = TE_Location[c];
	buff[c] = '\0';
	TRACE("\nchar[] version of TE_Location is %s", buff);

	TRACE
	(
		"\nUser-defined files (*.%s) are located at %s.", 
		TE_EXTENSION,
		TE_Location
	);

	TRACE("\nCurrent working directory is %s.", getcwd(buff, 128));
	TE_MoveToLocation();
	TRACE("\nCurrent working directory is %s.", getcwd(buff, 128));

	DeleteEffects();
	CreateEffects();
	Dump();
}

BOOL		
CTE_Library::CreateEffects(void)	
{
	// Note:  Heap allocated effects are deleted in CTE_Library::DeleteEffects()

	// (1)	Create primitive effects

	//	Stroke effect
	BYTE rgba[4] = { 255, 0, 0, 255 };
	CTE_Effect* pFill = new CTE_Fill("fill");
	((CTE_Fill *)pFill)->SetRGBA(rgba);
	AddEffect(pFill);

	//	Fill effect
	BYTE rgba1[4] = { 0, 0, 255, 255 };
	CTE_Effect* pStroke = new CTE_Stroke("stroke");
	((CTE_Stroke *)pStroke)->SetRGBA(rgba1);
	AddEffect(pStroke);

	//	Stroke over fill
	CTE_Effect* pOver1 = new CTE_Over("over1");
	((CTE_Branch *)pOver1)->AddChild(new CTE_Stroke(*((CTE_Stroke *)pStroke)));
	((CTE_Branch *)pOver1)->AddChild(new CTE_Fill(*((CTE_Fill *)pFill)));
	AddEffect(pOver1);

	//	Drop shadow
	CTE_Effect* pOver2 = new CTE_Over("over2");
	CTE_Effect* pOver2a = new CTE_Over("over2a");
	((CTE_Branch *)pOver2a)->AddChild(new CTE_Stroke(*((CTE_Stroke *)pStroke)));
	((CTE_Branch *)pOver2a)->AddChild(new CTE_Fill(*((CTE_Fill *)pFill)));
	((CTE_Branch *)pOver2)->AddChild(pOver2a);
	CTE_Effect* pShift2 = new CTE_Shift("shift2");
	((CTE_Shift *)pShift2)->SetShift(5.0, -8.0);
	CTE_Blur* pBlur2 = new CTE_Blur("blur2");
	pBlur2->SetAmount(3);
	((CTE_Branch *)pShift2)->AddChild(pBlur2);
	BYTE rgba2[4] = { 63, 31, 31, 127 };
	((CTE_Branch *)pBlur2)->AddChild(new CTE_Fill(rgba2));
	((CTE_Branch *)pOver2)->AddChild(pShift2);
	AddEffect(pOver2);

	// (2)	Create common effect expression trees (beware of dependencies!)

	// (3)	Load user-defined effects from file

	return TRUE;
}

void		
CTE_Library::DeleteEffects(void)
{
	//	Delete heap objects
	for (int i = 0; i < m_pEffects.size(); i++)
		delete m_pEffects[i];

	//	Delete collection of pointers
	m_pEffects.empty();
}

void		
CTE_Library::Dump(void) const
{
	TRACE("\n========\nLibrary:");
	if (m_pEffects.size() == 0)
		TRACE(" empty.");
	else
		for (int i = 0; i < m_pEffects.size(); i++)
			m_pEffects[i]->Dump();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-outline.h ===
//	te-outline.h:	definition of the CTE_Outline class

#ifndef TE_OUTLINE_DEFINED
#define TE_OUTLINE_DEFINED

//////////////////////////////////////////////////////////////////////////////

class CTE_Outline
{
//	Interface:
public:
	CTE_Outline();
	CTE_Outline(CTE_Outline const& outline);
	virtual ~CTE_Outline();

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-operator.h ===
//	te-operator.h:	definition of the CTE_Operator class

//	Individual operator effects are derived from here

#ifndef TE_OPERATOR_DEFINED
#define TE_OPERATOR_DEFINED

#include <te-branch.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_Operator : public CTE_Branch
{
//	Interface:
public:
	CTE_Operator();
	CTE_Operator(int num, CTE_Effect** ppChild);			
	virtual ~CTE_Operator();

	virtual	void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					);
	virtual	void	Combine
					(
						CTE_Outline const& outline,
						CTE_Placement const& pl, 
						CTE_Image args[],
						CTE_Image& result
					) = 0;

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-outline.cpp ===
//	te-outline.cpp:	implementation of the CTE_Outline class

#include <stdafx.h>
#include <te-outline.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Outline::CTE_Outline()
{
}

CTE_Outline::CTE_Outline(CTE_Outline const& outline)
{
}
	
CTE_Outline::~CTE_Outline()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-param.cpp ===
// te-param.cpp:	implementation of the CTE_Param parameter class

#include <stdafx.h>
#include <te-param.h>
#include <te-globals.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Param::CTE_Param()		
{ 
	m_Name = "unknown"; 
	m_Type = TE_PARAM_TYPES;
	m_Wrap = FALSE;
}

CTE_Param::CTE_Param(int value, int lower, int upper, CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_INTEGER;
	m_Value.i = value;
	m_Lower.i = lower;
	m_Upper.i = upper;
	m_Name = name;
	m_Wrap = wrap;
}

CTE_Param::CTE_Param(double value, double lower, double upper, CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_FLOAT;
	m_Value.f = value;
	m_Lower.f = lower;
	m_Upper.f = upper;
	m_Name = name;
	m_Wrap = wrap;
}

CTE_Param::CTE_Param(double value, CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_ANGLE;
	m_Value.f = value;
	m_Lower.f = 0.0;
	m_Upper.f = 2.0 * PI;
	m_Name = name;
	m_Wrap = wrap;		//	default is TRUE
}

CTE_Param::CTE_Param(char* value, CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_STRING;
	m_Value.str = value;
	//m_Lower.str = "";
	//m_Upper.str = "";
	m_Name = name;
	m_Wrap = wrap;
}

CTE_Param::CTE_Param(int num, char** value, CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_STRING_LIST;
	m_Value.list.number = num;
	m_Value.list.items = value;
	//m_Lower.str = "";
	//m_Upper.str = "";
	m_Name = name;
	m_Wrap = wrap;
}
	
CTE_Param::CTE_Param(BOOL value, CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_BOOLEAN;
	m_Value.b = value;
	//m_Lower.b = FALSE;
	//m_Upper.b = TRUE;
	m_Name = name;
	m_Wrap = wrap;
}

CTE_Param::CTE_Param(BYTE const value[4], BYTE const lower[4], BYTE const upper[4], CString const& name, BOOL wrap)
{
	m_Type = TE_PARAM_RGBA;
	memcpy(m_Value.rgba, value, 4);
	memcpy(m_Lower.rgba, lower, 4);
	memcpy(m_Upper.rgba, upper, 4);
	m_Name = name;
	m_Wrap = wrap;
}

CTE_Param::~CTE_Param()	
{
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods

/*
void			
CTE_Param::SetName(CString const& name)	
{ 
	m_Name = name; 
}

void			
CTE_Param::GetName(CString& name) const	
{ 
	name = m_Name; 
}

CString const&	
CTE_Param::GetName(void) const				
{ 
	return m_Name; 
}

void			
CTE_Param::SetType(TE_ParamTypes type)	
{ 
	m_Type = type; 
}

TE_ParamTypes	
CTE_Param::GetType(void) const	
{ 
	return m_Type; 
}

void			
CTE_Param::SetWrap(BOOL wrap)				
{ 
	m_Wrap = wrap; 
}

BOOL			
CTE_Param::GetWrap(void) const				
{ 
	return m_Wrap; 
}

void			
CTE_Param::SetValue(TE_Value value)		
{ 
	m_Value = value; 
}	

TE_Value		
CTE_Param::GetValue(void) const 			
{ 
	return m_Value; 
}

void			
CTE_Param::SetLower(TE_Value lower)		
{ 
	m_Lower = lower; 
}	

TE_Value		
CTE_Param::GetLower(void) const 			
{ 
	return m_Lower; 
}

void			
CTE_Param::SetUpper(TE_Value upper)		
{ 
	m_Upper = upper; 
}	

TE_Value		
CTE_Param::GetUpper(void) const 			
{ 
	return m_Upper; 
}
*/

void	
CTE_Param::SetValue(int i)
{
	switch(m_Type)
	{
	case TE_PARAM_INTEGER:	m_Value.i = i;	break;
	case TE_PARAM_FLOAT:	m_Value.f = i;	break;
	case TE_PARAM_BOOLEAN:	m_Value.b = i;	break;
	case TE_PARAM_ANGLE:	m_Value.a = i;	break;
	default:	
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_INTEGER;
		m_Value.i = i;
		break;	
	}
}

void	
CTE_Param::GetValue(int& i) const
{
	switch(m_Type)
	{
	case TE_PARAM_INTEGER:	i = m_Value.i;	break;
	case TE_PARAM_BOOLEAN:	i = m_Value.b;	break;
	default: TRACE("\nWrong param type..."); break;
	}
}

void	
CTE_Param::SetValue(double d, TE_ParamTypes type)
{
	//	Explicit change of type
	if (type != TE_PARAM_TYPES)
		m_Type = type;
		
	switch(m_Type)
	{
	case TE_PARAM_FLOAT:	m_Value.f = d;	break;
	case TE_PARAM_ANGLE:	m_Value.a = d;	break;
	default:	
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_FLOAT;
		m_Value.f = d;
		break;	
	}
}

void	
CTE_Param::GetValue(double& d) const
{
	switch(m_Type)
	{
	case TE_PARAM_FLOAT:	d = m_Value.f;	break;
	case TE_PARAM_ANGLE:	d = m_Value.a;	break;
	default: TRACE("\nWrong param type..."); break;	
	}
}

void	
CTE_Param::SetValue(char* str)
{
	if (m_Type != TE_PARAM_STRING)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_STRING;
	}
	m_Value.str = str;
}

void	
CTE_Param::GetValue(char* str) const
{
	if (m_Type == TE_PARAM_STRING)
		str = m_Value.str;
	else
		TRACE("\nWrong param type..."); 
}

int		
CTE_Param::GetNumListItems(void) const
{
	if (m_Type == TE_PARAM_STRING_LIST)
		return  m_Value.list.number;

	TRACE("\nWrong param type..."); 
	return 0;
}
	
void	
CTE_Param::SetValue(int index, char* str)
{
	if (m_Type == TE_PARAM_STRING_LIST)
	{
		ASSERT(index >= 0 && index < m_Value.list.number);
		m_Value.list.items[index] = str;
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}
	
void	
CTE_Param::GetValue(int index, char* str) const
{
	if (m_Type == TE_PARAM_STRING_LIST)
	{
		ASSERT(index >= 0 && index < m_Value.list.number);
		str = m_Value.list.items[index];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}	

void	
CTE_Param::SetValue(BYTE rgba[4])
{
	if (m_Type != TE_PARAM_RGBA)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_RGBA;
	}
	m_Value.rgba[0] = rgba[0];
	m_Value.rgba[1] = rgba[1];
	m_Value.rgba[2] = rgba[2];
	m_Value.rgba[3] = rgba[3];
}

void	
CTE_Param::GetValue(BYTE rgba[4]) const
{
	if (m_Type == TE_PARAM_RGBA)
	{
		rgba[0] = m_Value.rgba[0];
		rgba[1] = m_Value.rgba[1];
		rgba[2] = m_Value.rgba[2];
		rgba[3] = m_Value.rgba[3];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetValue(BYTE r, BYTE g, BYTE b, BYTE a)
{
	if (m_Type != TE_PARAM_RGBA)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_RGBA;
	}
	m_Value.rgba[0] = r;
	m_Value.rgba[1] = g;
	m_Value.rgba[2] = b;
	m_Value.rgba[3] = a;
}

void	
CTE_Param::GetValue(BYTE& r, BYTE& g, BYTE& b, BYTE& a) const
{
	if (m_Type == TE_PARAM_RGBA)
	{
		r = m_Value.rgba[0];
		g = m_Value.rgba[1];
		b = m_Value.rgba[2];
		a = m_Value.rgba[3];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetValue(double x, double y)
{
	if (m_Type != TE_PARAM_POINT_2D)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_POINT_2D;
	}
	m_Value.pt2[0] = x;
	m_Value.pt2[1] = y;
}

void	
CTE_Param::GetValue(double& x, double& y) const
{
	if (m_Type == TE_PARAM_POINT_2D)
	{
		x = m_Value.pt2[0];
		y = m_Value.pt2[1];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetValue(double x, double y, double z)
{
	if (m_Type != TE_PARAM_POINT_3D)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_POINT_3D;
	}
	m_Value.pt3[0] = x;
	m_Value.pt3[1] = y;
	m_Value.pt3[2] = z;
}

void	
CTE_Param::GetValue(double& x, double& y, double& z) const
{
	if (m_Type == TE_PARAM_POINT_3D)
	{
		x = m_Value.pt3[0];
		y = m_Value.pt3[1];
		z = m_Value.pt3[2];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetLower(int i)
{
	switch(m_Type)
	{
	case TE_PARAM_INTEGER:	m_Lower.i = i;	break;
	case TE_PARAM_FLOAT:	m_Lower.f = i;	break;
	case TE_PARAM_BOOLEAN:	m_Lower.b = i;	break;
	case TE_PARAM_ANGLE:	m_Lower.a = i;	break;
	default:	
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_INTEGER;
		m_Lower.i = i;
		break;	
	}
}

void	
CTE_Param::GetLower(int& i) const
{
	switch(m_Type)
	{
	case TE_PARAM_INTEGER:	i = m_Lower.i;	break;
	case TE_PARAM_BOOLEAN:	i = m_Lower.b;	break;
	default: TRACE("\nWrong param type..."); break;
	}
}

void	
CTE_Param::SetLower(double d, TE_ParamTypes type)
{
	//	Explicit change of type
	if (type != TE_PARAM_TYPES)
		m_Type = type;
		
	switch(m_Type)
	{
	case TE_PARAM_FLOAT:	m_Lower.f = d;	break;
	case TE_PARAM_ANGLE:	m_Lower.a = d;	break;
	default:	
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_FLOAT;
		m_Lower.f = d;
		break;	
	}
}

void	
CTE_Param::GetLower(double& d) const
{
	switch(m_Type)
	{
	case TE_PARAM_FLOAT:	d = m_Lower.f;	break;
	case TE_PARAM_ANGLE:	d = m_Lower.a;	break;
	default: TRACE("\nWrong param type..."); break;	
	}
}

void	
CTE_Param::SetLower(char* str)
{
	if (m_Type != TE_PARAM_STRING)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_STRING;
	}
	m_Lower.str = str;
}

void	
CTE_Param::GetLower(char* str) const
{
	if (m_Type == TE_PARAM_STRING)
		str = m_Lower.str;
	else
		TRACE("\nWrong param type..."); 
}

void	
CTE_Param::SetLower(BYTE rgba[4])
{
	if (m_Type != TE_PARAM_RGBA)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_RGBA;
	}
	m_Lower.rgba[0] = rgba[0];
	m_Lower.rgba[1] = rgba[1];
	m_Lower.rgba[2] = rgba[2];
	m_Lower.rgba[3] = rgba[3];
}

void	
CTE_Param::GetLower(BYTE rgba[4]) const
{
	if (m_Type == TE_PARAM_RGBA)
	{
		rgba[0] = m_Lower.rgba[0];
		rgba[1] = m_Lower.rgba[1];
		rgba[2] = m_Lower.rgba[2];
		rgba[3] = m_Lower.rgba[3];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetLower(BYTE r, BYTE g, BYTE b, BYTE a)
{
	if (m_Type != TE_PARAM_RGBA)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_RGBA;
	}
	m_Lower.rgba[0] = r;
	m_Lower.rgba[1] = g;
	m_Lower.rgba[2] = b;
	m_Lower.rgba[3] = a;
}

void	
CTE_Param::GetLower(BYTE& r, BYTE& g, BYTE& b, BYTE& a) const
{
	if (m_Type == TE_PARAM_RGBA)
	{
		r = m_Lower.rgba[0];
		g = m_Lower.rgba[1];
		b = m_Lower.rgba[2];
		a = m_Lower.rgba[3];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetLower(double x, double y)
{
	if (m_Type != TE_PARAM_POINT_2D)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_POINT_2D;
	}
	m_Lower.pt2[0] = x;
	m_Lower.pt2[1] = y;
}

void	
CTE_Param::GetLower(double& x, double& y) const
{
	if (m_Type == TE_PARAM_POINT_2D)
	{
		x = m_Lower.pt2[0];
		y = m_Lower.pt2[1];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetLower(double x, double y, double z)
{
	if (m_Type != TE_PARAM_POINT_3D)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_POINT_3D;
	}
	m_Lower.pt3[0] = x;
	m_Lower.pt3[1] = y;
	m_Lower.pt3[2] = z;
}

void	
CTE_Param::GetLower(double& x, double& y, double& z) const
{
	if (m_Type == TE_PARAM_POINT_3D)
	{
		x = m_Lower.pt3[0];
		y = m_Lower.pt3[1];
		z = m_Lower.pt3[2];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetUpper(int i)
{
	switch(m_Type)
	{
	case TE_PARAM_INTEGER:	m_Upper.i = i;	break;
	case TE_PARAM_FLOAT:	m_Upper.f = i;	break;
	case TE_PARAM_BOOLEAN:	m_Upper.b = i;	break;
	case TE_PARAM_ANGLE:	m_Upper.a = i;	break;
	default:	
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_INTEGER;
		m_Upper.i = i;
		break;	
	}
}

void	
CTE_Param::GetUpper(int& i) const
{
	switch(m_Type)
	{
	case TE_PARAM_INTEGER:	i = m_Upper.i;	break;
	case TE_PARAM_BOOLEAN:	i = m_Upper.b;	break;
	default: TRACE("\nWrong param type..."); break;
	}
}

void	
CTE_Param::SetUpper(double d, TE_ParamTypes type)
{
	//	Explicit change of type
	if (type != TE_PARAM_TYPES)
		m_Type = type;
		
	switch(m_Type)
	{
	case TE_PARAM_FLOAT:	m_Upper.f = d;	break;
	case TE_PARAM_ANGLE:	m_Upper.a = d;	break;
	default:	
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_FLOAT;
		m_Upper.f = d;
		break;	
	}
}

void	
CTE_Param::GetUpper(double& d) const
{
	switch(m_Type)
	{
	case TE_PARAM_FLOAT:	d = m_Upper.f;	break;
	case TE_PARAM_ANGLE:	d = m_Upper.a;	break;
	default: TRACE("\nWrong param type..."); break;	
	}
}

void	
CTE_Param::SetUpper(char* str)
{
	if (m_Type != TE_PARAM_STRING)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_STRING;
	}
	m_Upper.str = str;
}

void	
CTE_Param::GetUpper(char* str) const
{
	if (m_Type == TE_PARAM_STRING)
		str = m_Upper.str;
	else
		TRACE("\nWrong param type..."); 
}

void	
CTE_Param::SetUpper(BYTE rgba[4])
{
	if (m_Type != TE_PARAM_RGBA)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_RGBA;
	}
	m_Upper.rgba[0] = rgba[0];
	m_Upper.rgba[1] = rgba[1];
	m_Upper.rgba[2] = rgba[2];
	m_Upper.rgba[3] = rgba[3];
}

void	
CTE_Param::GetUpper(BYTE rgba[4]) const
{
	if (m_Type == TE_PARAM_RGBA)
	{
		rgba[0] = m_Upper.rgba[0];
		rgba[1] = m_Upper.rgba[1];
		rgba[2] = m_Upper.rgba[2];
		rgba[3] = m_Upper.rgba[3];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetUpper(BYTE r, BYTE g, BYTE b, BYTE a)
{
	if (m_Type != TE_PARAM_RGBA)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_RGBA;
	}
	m_Upper.rgba[0] = r;
	m_Upper.rgba[1] = g;
	m_Upper.rgba[2] = b;
	m_Upper.rgba[3] = a;
}

void	
CTE_Param::GetUpper(BYTE& r, BYTE& g, BYTE& b, BYTE& a) const
{
	if (m_Type == TE_PARAM_RGBA)
	{
		r = m_Upper.rgba[0];
		g = m_Upper.rgba[1];
		b = m_Upper.rgba[2];
		a = m_Upper.rgba[3];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetUpper(double x, double y)
{
	if (m_Type != TE_PARAM_POINT_2D)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_POINT_2D;
	}
	m_Upper.pt2[0] = x;
	m_Upper.pt2[1] = y;
}

void	
CTE_Param::GetUpper(double& x, double& y) const
{
	if (m_Type == TE_PARAM_POINT_2D)
	{
		x = m_Upper.pt2[0];
		y = m_Upper.pt2[1];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

void	
CTE_Param::SetUpper(double x, double y, double z)
{
	if (m_Type != TE_PARAM_POINT_3D)
	{
		TRACE("\nChanging param type..."); 
		m_Type = TE_PARAM_POINT_3D;
	}
	m_Upper.pt3[0] = x;
	m_Upper.pt3[1] = y;
	m_Upper.pt3[2] = z;
}

void	
CTE_Param::GetUpper(double& x, double& y, double& z) const
{
	if (m_Type == TE_PARAM_POINT_3D)
	{
		x = m_Upper.pt3[0];
		y = m_Upper.pt3[1];
		z = m_Upper.pt3[2];
	}
	else
	{
		TRACE("\nWrong param type..."); 
	}
}

//////////////////////////////////////////////////////////////////////////////

void		
CTE_Param::Dump(void) const
{
	TRACE("\n      CTE_Param: name = %s, type = %s.", m_Name, TE_ParamNames[m_Type]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-placement.h ===
// te-placement.h:	definition of the CTE_Placement class

#ifndef TE_PLACEMENT_DEFINED
#define TE_PLACEMENT_DEFINED

#include <box.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_Placement
{
//	Interface:
public:
	CTE_Placement();
	CTE_Placement(CTE_Placement const& pl);
	~CTE_Placement();

	void	SetInCell(CBox const& box)		{ m_InCell = box; }
	void	SetInCell(double l, double t, double r, double b)
			{	
				m_InCell.SetBox(l, t, r, b);	
			}
	CBox	GetInCell(CBox& box) const		{ return m_InCell; }
	void	SetBB(CBox const& box)			{ m_BB = box; }
	void	SetBB(double l, double t, double r, double b)
			{	
				m_BB.SetBox(l, t, r, b);	
			}
	CBox	GetBB(CBox& box) const			{ return m_BB; }
	void	SetInString(CBox const& box)	{ m_InString = box; }
	void	SetInString(double l, double t, double r, double b)
			{	
				m_InString.SetBox(l, t, r, b);	
			}
	CBox	GetInString(CBox& box) const	{ return m_InString; }
	void	SetPosition(int posn)			{ m_Position = posn; }
	int		GetPosition(void) const			{ return m_Position; }

	void		Dump(void) const;

//	Private data members:
private:
	CBox		m_InCell;		//	Placement in character cell
	CBox		m_BB;			//	Character's bounding box
	CBox		m_InString;		//	Placement in string's bounding box
	int			m_Position;		//	Character's ordinal position in string

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-shape.cpp ===
//	te-shape.cpp:	implementation of the CTE_Shape class

#include <stdafx.h>
#include <te-shape.h>
#include <te-outline.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Shape::CTE_Shape()
{ 
}

CTE_Shape::CTE_Shape(int num, CTE_Effect** ppChild)
	: CTE_Branch(num, ppChild)
{ 
}

CTE_Shape::~CTE_Shape()						
{
}

//////////////////////////////////////////////////////////////////////////////
//	Operations

void	
CTE_Shape::Dump(void) const
{
	CTE_Branch::Dump();

	TRACE("\nCTE_Shape.");
}

void	
CTE_Shape::Apply
(
	CTE_Outline const& outline,	// copy may be passed on
	CTE_Placement const& pl, 
	CTE_Image& result
)
{
	//	(1) Copy outline to outline2...
	CTE_Outline outline2(outline);

	//	(2) Modify outline2...

	//	(3) Pass outline2 to child
	ASSERT(GetNumChildren() == 1);
	ASSERT(GetChild() != NULL);
	GetChild()->Apply(outline2, pl, result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-param.h ===
// te-param.h:	defition of the CTE_Param parameter classes

#ifndef TE_PARAM_DEFINED
#define TE_PARAM_DEFINED

//////////////////////////////////////////////////////////////////////////////

static enum TE_ParamTypes
{
	TE_PARAM_INTEGER,
	TE_PARAM_FLOAT,
	TE_PARAM_BOOLEAN,
	TE_PARAM_STRING,
	TE_PARAM_STRING_LIST,
	TE_PARAM_ANGLE,
	TE_PARAM_RGBA,
	TE_PARAM_POINT_2D,
	TE_PARAM_POINT_3D,
	TE_PARAM_TYPES
};

static char* TE_ParamNames[TE_PARAM_TYPES] =
{
	"integer", 
	"float", 
	"boolean", 
	"string-list", 
	"list",
	"angle",
	"rgba",
	"point-2d",
	"point-3d",
};

//////////////////////////////////////////////////////////////////////////////

typedef struct StringListStruct
{
	int		number;
	char**	items;
} TE_StringList;


union TE_Value
{
	int		i;
	double	f;
	char*	str;
	TE_StringList list;
	BOOL	b;
	double	a;
	BYTE	rgba[4];
	double	pt2[2];
	double	pt3[3];
};

//////////////////////////////////////////////////////////////////////////////

class CTE_Param
{
//	Interface:
public:
	CTE_Param();
	CTE_Param
	(
		int value, int lower, int upper, 
		CString const& name = "?", BOOL wrap = FALSE
	);
	CTE_Param
	(
		double value, double lower, double upper, 
		CString const& name = "?", BOOL wrap = FALSE
	);
	CTE_Param(double value, CString const& name = "?", BOOL wrap = TRUE);
	CTE_Param(char* value, CString const& name = "?", BOOL wrap = FALSE);
	CTE_Param(int num, char** value, CString const& name = "?", BOOL wrap = FALSE);
	CTE_Param(BOOL value, CString const& name = "?", BOOL wrap = FALSE);
	CTE_Param
	(
		BYTE const value[4], BYTE const lower[4], BYTE const upper[4], 
		CString const& name = "?", BOOL wrap = FALSE
	);
	~CTE_Param();

	inline	void	SetName(CString const& name)	{ m_Name = name; }
	inline	void	GetName(CString& name) const	{ name = m_Name; }
	inline	CString const& GetName(void) const		{ return m_Name; }
	inline	void	SetType(TE_ParamTypes type)		{ m_Type = type; }
	inline	TE_ParamTypes GetType(void) const		{ return m_Type; }
	inline	void	SetWrap(BOOL wrap)				{ m_Wrap = wrap; }
	inline	BOOL	GetWrap(void) const				{ return m_Wrap; }

	inline	void	SetValue(TE_Value value)		{ m_Value = value; }
	inline	TE_Value GetValue(void) const			{ return m_Value; }
	inline	void	GetLower(TE_Value lower)		{ m_Lower = lower; }
	inline	TE_Value GetLower(void) const			{ return m_Lower; }
	inline	void	SetUpper(TE_Value upper)		{ m_Upper = upper; }
	inline	TE_Value GetUpper(void) const			{ return m_Upper; }

	void	SetValue(int i); 
	void	GetValue(int& i) const;  
	void	SetValue(double d, TE_ParamTypes type = TE_PARAM_TYPES); 
	void	GetValue(double& d) const;  
	void	SetValue(char* str); 
	void	GetValue(char* str) const; 
	int		GetNumListItems(void) const;
	void	SetValue(int index, char* str); 
	void	GetValue(int index, char* str) const;  
	void	SetValue(BYTE rgba[4]); 
	void	GetValue(BYTE rgba[4]) const;  
	void	SetValue(BYTE r, BYTE g, BYTE b, BYTE a); 
	void	GetValue(BYTE& r, BYTE& g, BYTE& b, BYTE& a) const;  
	void	SetValue(double x, double y); 
	void	GetValue(double& x, double& y) const;  
	void	SetValue(double x, double y, double z); 
	void	GetValue(double& x, double& y, double& z) const;  
	
	void	SetLower(int i); 
	void	GetLower(int& i) const;  
	void	SetLower(double d, TE_ParamTypes type = TE_PARAM_TYPES); 
	void	GetLower(double& d) const;  
	void	SetLower(char* str); 
	void	GetLower(char* str) const;  
	void	SetLower(BYTE rgba[4]); 
	void	GetLower(BYTE rgba[4]) const;  
	void	SetLower(BYTE r, BYTE g, BYTE b, BYTE a); 
	void	GetLower(BYTE& r, BYTE& g, BYTE& b, BYTE& a) const;  
	void	SetLower(double x, double y); 
	void	GetLower(double& x, double& y) const;  
	void	SetLower(double x, double y, double z); 
	void	GetLower(double& x, double& y, double& z) const;  
	
	void	SetUpper(int i); 
	void	GetUpper(int& i) const;  
	void	SetUpper(double d, TE_ParamTypes type = TE_PARAM_TYPES); 
	void	GetUpper(double& d) const;  
	void	SetUpper(char* str); 
	void	GetUpper(char* str) const;  
	void	SetUpper(BYTE rgba[4]); 
	void	GetUpper(BYTE rgba[4]) const;  
	void	SetUpper(BYTE r, BYTE g, BYTE b, BYTE a); 
	void	GetUpper(BYTE& r, BYTE& g, BYTE& b, BYTE& a) const;  
	void	SetUpper(double x, double y); 
	void	GetUpper(double& x, double& y) const;  
	void	SetUpper(double x, double y, double z); 
	void	GetUpper(double& x, double& y, double& z) const;  
	
	void				Dump(void) const;
	

//	private data members:
private:
	TE_ParamTypes	m_Type;		//	type of parameter
	CString			m_Name;		//	parameter's name unique to effect
	BOOL			m_Wrap;		//	Wrap or clamp to limits

	TE_Value		m_Value;	//	current value
	TE_Value		m_Lower;	//	current value
	TE_Value		m_Upper;	//	lower limit
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-primitive.h ===
//	te-primitive.h:	definition of the CTE_Primitive class

//	Individual effects are derived form here

#ifndef TE_PRIMITIVE_DEFINED
#define TE_PRIMITIVE_DEFINED

#include <te-effect.h>
#include <te-param.h>
#include <vector>

//////////////////////////////////////////////////////////////////////////////

class CTE_Primitive : public CTE_Effect
{
//	Interface:
public:
	CTE_Primitive();
	virtual ~CTE_Primitive();

	int			GetNumParams(void) const		{ return m_pParams.size(); }
	CTE_Param*	GetParam(int i) const;
	CTE_Param*	GetParam(CString const& name) const;
	BOOL		AddParam(CTE_Param* param)		
				{ 
					m_pParams.push_back(param); 
					return TRUE; 
				}

	virtual	void	CreateParameters(void) = 0;
	virtual void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					) = 0;

private:
	void		DeleteParams(void);

//	Private data members:
private:
	std::vector<CTE_Param *> m_pParams;	//  collection of effect parameters
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-shape.h ===
//	te-shape.h:	definition of the CTE_Shape class

//	Individual shape effects are derived from here

#ifndef TE_SHAPE_DEFINED
#define TE_SHAPE_DEFINED

#include <te-branch.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_Shape : public CTE_Branch
{
//	Interface:
public:
	CTE_Shape();
	CTE_Shape(int num, CTE_Effect** ppChild);
	virtual ~CTE_Shape();

	virtual	void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					);
	virtual	void	Modify
					(
						CTE_Outline const& outline, 
						CTE_Placement const& pl
					) = 0;

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-texture.cpp ===
//	te-texture.cpp:	implementation of the CTE_Texture class

#include <stdafx.h>
#include <te-texture.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Texture::CTE_Texture()	
{
}

CTE_Texture::~CTE_Texture()	
{
}

//////////////////////////////////////////////////////////////////////////////

void	
CTE_Texture::Dump(void) const
{
	CTE_Primitive::Dump();

	TRACE("\nCTE_Texture.");
}

void	
CTE_Texture::Apply
(
	CTE_Outline const& outline,	// copy may be passed on
	CTE_Placement const& pl, 
	CTE_Image& result
)
{
	//	(1) Generate texture...
	Generate(outline, pl, result);

	//	(2) Render to bmp...

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-textout.h ===
// te-textout.h:  definition of TE_TextOut() function and related global data

//	Stuff to eventually go in the DLL

#ifndef TE_TEXT_OUT_DEFINED
#define TE_TEXT_OUT_DEFINED

#include <te-library.h>

//////////////////////////////////////////////////////////////////////////////
//	Global variables

static	int			TE_Antialias = 1;	//	1 is "off"

static	int			TE_Height = 11;		//	height (point size?) of the 
										//	currently loaded font

static	CString		TE_Location = "d:\\src\\te\\lib";	//	whereabouts of the 
										//	library of user-defined te files

static	CTE_Library	TE_Library;			//	the one and only effect library

static	CRect		TE_Margin(0,0, 0,0);//	margin around active region of bitmap

//////////////////////////////////////////////////////////////////////////////
//	Global functions

FIXED	DoubleToFIXED(double num);
double	FIXEDToDouble(FIXED num);
void	TE_MoveToLocation(void);

BOOL	ConvertSpline
		(
			DWORD buffer_size, LPTTPOLYGONHEADER poly, CTE_Outline& ol
		);

BOOL	TE_TextOut
		(  
			HDC hdc,			// handle to device context
			int nXStart,		// x-coordinate of starting position
			int nYStart,		// y-coordinate of starting position
			LPCTSTR lpString,	// pointer to string
			int cbString,		// number of characters in string
			LPCTSTR lpEffect	// name of text effect
		);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-tree.cpp ===
// te-tree.cpp:	implementation of the CTE_Tree class

#include <stdafx.h>
#include <te-tree.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

CTE_Tree::CTE_Tree()									
{ 
	m_pRoot = NULL; 
}

CTE_Tree::CTE_Tree(CTE_Effect* pRoot)					
{ 
	m_pRoot = pRoot; 
}

CTE_Tree::~CTE_Tree()		
{
	//?	Is this correct?
	delete m_pRoot;
}

//////////////////////////////////////////////////////////////////////////////
//	Data access methods
	

//////////////////////////////////////////////////////////////////////////////
//	Operations

void	
CTE_Tree::Dump(void) const
{
	CTE_Effect::Dump();

	TRACE("\nCTE_Tree: m_pRoot = %p.", m_pRoot);
}

void	
CTE_Tree::Apply
(
	CTE_Outline const& outline,	// copy may be passed on
	CTE_Placement const& pl, 
	CTE_Image& result
) 
{
	if (m_pRoot != NULL)
		m_pRoot->Apply(outline, pl, result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-tree.h ===
// te-tree.h:	definition of the CTE_Tree class

#ifndef TE_TREE_DEFINED
#define TE_TREE_DEFINED

#include <te-effect.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_Tree : public CTE_Effect
{
//	Interface:
public:
	CTE_Tree();
	CTE_Tree(CTE_Effect* pRoot);
	virtual ~CTE_Tree();

	inline	void			SetRoot(CTE_Effect* pRoot)	{ m_pRoot = pRoot; }
	inline	CTE_Effect*		GetRoot(void) const			{ return m_pRoot; }
	
	virtual	void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					);

//	Private data members:
private:
	CTE_Effect*		m_pRoot;	//	pRoot of this effect tree
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-textout.cpp ===
// te-textout.cpp:	implementation of TE_TextOut() and related functions

//	Stuff to eventually go in the DLL

#include <stdafx.h>
#include <te-globals.h>
#include <te-textout.h>
#include <te-effect.h>
#include <te-library.h>
#include <direct.h>		// for chdir()
#include <te-outline.h>
#include <te-placement.h>
#include <te-image.h>

#define new DEBUG_NEW

//////////////////////////////////////////////////////////////////////////////

void
TE_MoveToLocation(void)
{
	if (chdir(TE_Location))
		TRACE("\nUnable to find directory %s.", TE_Location);
}

FIXED
DoubleToFIXED(double num)
{
	long l = (long)(num * 65536L);
	return *(FIXED *)&l;
}

//	fixed_to_double - converts a fixed point number to a double
double
FIXEDToDouble(FIXED num)
{
	long l = *(long *)&num;
	return (double)(l / 65536.0);
}

//////////////////////////////////////////////////////////////////////////////

BOOL
ConvertSpline(DWORD buffer_size, LPTTPOLYGONHEADER poly, CTE_Outline& ol)
{
	TRACE
	(
		"\nLPTTPOLYGONHEADER: size=%d, type=%d.", 
		poly->cb, poly->dwType
	);	
			










	dxLPI   = (double)xLPI;
    dyLPI   = (double)yLPI;
    dxScale = (double)Scale;
    dyScale = (double)Scale * dxLPI / dyLPI;

    cbTotal = dwrc;
    while( cbTotal > 0 )
    {
        HPEN    hPenOld;

        dprintf( "Polygon Header:" );
        dprintf(      "  cb       = %lu", lpph->cb       );
        dprintf(      "  dwType   = %d",  lpph->dwType   );
        PrintPointFX( "  pfxStart = ",    lpph->pfxStart );

        DrawXMark( hdc, lpph->pfxStart );

        nItem = 0;
        lpb   = (LPBYTE)lpph + sizeof(TTPOLYGONHEADER);

        //----  Calculate size of data  ----

        cbOutline = (long)lpph->cb - sizeof(TTPOLYGONHEADER);
        pptStart = (POINT *)&lpph->pfxStart;        // Starting Point

        pptStart->x = MapFX(lpph->pfxStart.x );
        pptStart->y = MapFY(lpph->pfxStart.y );


        while( cbOutline > 0 )
        {
            int           n;
            UINT          u;
            LPTTPOLYCURVE lpc;

            dprintf( "  cbOutline = %ld", cbOutline );
            nItem++;
            lpc = (LPTTPOLYCURVE)lpb;
            switch( lpc->wType )
            {
            case TT_PRIM_LINE:

                dprintf( "  Item %d: Line",         nItem );
                break;

            case TT_PRIM_CSPLINE:

                dprintf( "  Item %d: CSpline",      nItem );
                break;

            default:

                dprintf( "  Item %d: unknown type %u", nItem, lpc->wType );
                break;
            }
            dprintf( "    # of points: %d", lpc->cpfx );
            for( u = 0; u < lpc->cpfx; u++ )
            {
                PrintPointFX( "      Point = ", lpc->apfx[u] );
                DrawXMark( hdc, lpc->apfx[u] );

                ((POINT *)lpc->apfx)[u].x = MapFX( lpc->apfx[u].x );
                ((POINT *)lpc->apfx)[u].y = MapFY( lpc->apfx[u].y );
            }
            hPenOld = SelectObject( hdc, hPen );

            MoveToEx( hdc, pptStart->x, pptStart->y , 0);

            switch( lpc->wType )
            {
            case TT_PRIM_LINE:

                PolylineTo(hdc, (POINT *)lpc->apfx, (DWORD)lpc->cpfx);
                break;

            case TT_PRIM_CSPLINE:

                PolyBezierTo(hdc, (POINT *)lpc->apfx, (DWORD)lpc->cpfx);
                break;
            }
            SelectObject( hdc, hPenOld );
            pptStart = (POINT *)&lpc->apfx[lpc->cpfx - 1];        // Starting Point
            n          = sizeof(TTPOLYCURVE) + sizeof(POINTFX) * (lpc->cpfx - 1);
            lpb       += n;
            cbOutline -= n;
        }

        hPenOld = SelectObject( hdc, hPen );
        pptStart = (POINT *)&lpph->pfxStart;        // Starting Point
        LineTo( hdc, pptStart->x, pptStart->y);
        SelectObject( hdc, hPenOld );

        dprintf( "ended at cbOutline = %ld", cbOutline );
        cbTotal -= lpph->cb;
        lpph     = (LPTTPOLYGONHEADER)lpb;
    }

    dprintf( "ended at cbTotal = %ld", cbTotal );
















	return TRUE;
}

BOOL	
TE_TextOut
(  
	HDC hdc,			// handle to device context
	int nXStart,		// x-coordinate of starting position
	int nYStart,		// y-coordinate of starting position
	LPCTSTR lpString,	// pointer to string
	int cbString,		// number of characters in string
	LPCTSTR lpEffect	// name of text effect
)
{
	TRACE("\nTE_TextOut():  Applying effect %s to string %s.", lpEffect, lpString);
	TextOut(hdc, nXStart, nYStart, lpString, cbString);

	//	Examine the currently loaded font 
	//TE_Height = ...

	//	Get a pointer to the nominated effect
	CTE_Effect* pEffect = TE_Library.GetEffect(lpEffect);
	if (pEffect == NULL)
	{
		TRACE("\nTE_TextOut():  Effect named %s not found in library or NULL effect.", lpString);
		return FALSE;
	}

	if (pEffect->GetSpace() & (TE_SPACE_CHAR_BB_FLAG | TE_SPACE_CHAR_EM_FLAG))
	{
		//	Character context: handle characters separately
		TRACE("\nApplying effect in character context...");
		for (int i = 0; i < cbString; i++)
		{
			char ch = lpString[i];

			//	(1)	Determine placement 
			CTE_Placement pl;

			//	Bounding box
			pl.SetBB(0.0, 0.0, 1.0, 1.0);

			//	Character cell
			pl.SetInCell(0.0, 0.0, 1.0, 1.0);

			//	String context
			pl.SetInString(0.0, 0.0, 1.0, 1.0);
			pl.SetPosition(i);

			//	(2)	Get outline 
			//UINT format = GGO_NATIVE;
			UINT format = GGO_BEZIER;
			GLYPHMETRICS gm;
			MAT2 m2;

			// Unit transform matrix
			m2.eM11 = DoubleToFIXED(1.0);
			m2.eM12 = DoubleToFIXED(0.0);
			m2.eM21 = DoubleToFIXED(0.0);
			m2.eM22 = DoubleToFIXED(1.0);

			//	Get the buffer size
			DWORD buffer_size = 
				::GetGlyphOutlineW(hdc, UINT(ch), format, &gm, 0, NULL, &m2);

			if (buffer_size == GDI_ERROR)
			{
				TRACE
				(
					"\nTE_TextOut() bad buffer size.  Last error is %d.\n", 
					::GetLastError()
				);
				return FALSE;
			}
			TRACE
			(
				"\nGLYPHMETRICS for '%c': box=<%d,%d>, origin=<%d,%d>, cell inc=<%d,%d>.", 
				ch, gm.gmBlackBoxX, gm.gmBlackBoxY, 
				gm.gmptGlyphOrigin.x, gm.gmptGlyphOrigin.y, 
				gm.gmCellIncX, gm.gmCellIncY
			);
		
			//	Get the outline curves
			LPTTPOLYGONHEADER poly = (LPTTPOLYGONHEADER)malloc(buffer_size);
			DWORD dwrc = ::GetGlyphOutlineW(hdc, UINT(ch), format, &gm, buffer_size, poly, &m2);

			if (dwrc == -1L || dwrc == 0L)
			{
				TRACE
				(
					"\nTE_TextOut() error filling buffer.  Last error is %d.\n", 
					::GetLastError()
				);
				return FALSE;
			}
			
			CTE_Outline ol;
			// convert poly to ol...
			ConvertSpline(buffer_size, poly, ol);

			//	(3) Prepare result image
			CDC* pDC = new CDC;
			CBitmap* pBitmap = new CBitmap;
			pDC->CreateCompatibleDC(CDC::FromHandle(hdc));
	
			int x = 1;	//	max width + margins?
			int y = 1;	//	max height + margins?

			pBitmap->CreateCompatibleBitmap(pDC, x, y);
			pDC->SelectObject(pBitmap);

			CTE_Image result(pDC);

			//	(4) Apply the effect, starting at the root
			pEffect->Apply(ol, pl, result);
	
			//	(5) Draw result image to screen
			/*
			BitBlt
			(
				hdc, ?, ?, ?, ?, 
				result->GetDC()->GetSafeHdc(), ?, ?, SRCCOPY
			);
			*/

			//	(6) Clean up
			//delete [] poly;
			free(poly);
			delete pBitmap;
			delete pDC;
		}		
	}
	else
	{
		//	String context:	concatenate glyph outlines to single string outline

		//	if (pEffect->GetSpace() & TE_SPACE_STR_HOL_FLAG)
		//		handle differently?

		for (int i = 0; i < cbString; i++)
		{
			char ch = lpString[i];

			//	(1)	Determine placement 

			//	(2)	Get outline 

		}

		//	Determine bounding box for entire string

		//	(3) Prepare pdcResult

		//	(4) Apply effect

		//	(5) Draw resulting bmp

		//	(6) Clean up

	}
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te-texture.h ===
//	te-texture.h:	definition of the CTE_Texture class

//	Individual texture effects are derived from here

#ifndef TE_TEXTURE_DEFINED
#define TE_TEXTURE_DEFINED

#include <te-primitive.h>

//////////////////////////////////////////////////////////////////////////////

class CTE_Texture : public CTE_Primitive
{
//	Interface:
public:
	CTE_Texture();
	virtual ~CTE_Texture();

	virtual	void	Dump(void) const;
	virtual void	Apply
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					);
	virtual	void	Generate
					(
						CTE_Outline const& outline,	// copy may be passed on
						CTE_Placement const& pl, 
						CTE_Image& result
					) = 0;

//	Private data members:
private:
	
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te.h ===
// te.h : main header file for the TE application
//

#if !defined(AFX_TE_H__C3126678_63A7_11D2_9138_00A0C970228E__INCLUDED_)
#define AFX_TE_H__C3126678_63A7_11D2_9138_00A0C970228E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTeApp:
// See te.cpp for the implementation of this class
//

class CTeApp : public CWinApp
{
public:
	CTeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CTeApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TE_H__C3126678_63A7_11D2_9138_00A0C970228E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\te.cpp ===
// te.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "te.h"

#include "MainFrm.h"
#include "teDoc.h"
#include "teView.h"

#include <te-textout.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTeApp

BEGIN_MESSAGE_MAP(CTeApp, CWinApp)
	//{{AFX_MSG_MAP(CTeApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTeApp construction

CTeApp::CTeApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CTeApp object

CTeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CTeApp initialization

BOOL CTeApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register document templates

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CTeDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CTeView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CTeApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CTeApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\tedoc.cpp ===
// teDoc.cpp : implementation of the CTeDoc class
//

#include "stdafx.h"
#include "te.h"

#include "teDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTeDoc

IMPLEMENT_DYNCREATE(CTeDoc, CDocument)

BEGIN_MESSAGE_MAP(CTeDoc, CDocument)
	//{{AFX_MSG_MAP(CTeDoc)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTeDoc construction/destruction

CTeDoc::CTeDoc()
{
}

CTeDoc::~CTeDoc()
{
}

BOOL CTeDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CTeDoc serialization

void CTeDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
	}
	else
	{
	}
}

/////////////////////////////////////////////////////////////////////////////
// CTeDoc diagnostics

#ifdef _DEBUG
void CTeDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CTeDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTeDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\teview.cpp ===
// teView.cpp : implementation of the CTeView class
//

#include "stdafx.h"
#include "te.h"

#include "teDoc.h"
#include "teView.h"

#include <te-textout.h>
#include <te-param.h>
//#include <te-library.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTeView

IMPLEMENT_DYNCREATE(CTeView, CView)

BEGIN_MESSAGE_MAP(CTeView, CView)
	//{{AFX_MSG_MAP(CTeView)
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTeView construction/destruction

//#define TE_TEST_PARAM	1	

CTeView::CTeView()
{
	//	Initialise the effect library
	//TE_Library = new CTE_Library;
	//TE_Library->Init();
	//m_Library.Init();

#ifdef TE_TEST_PARAM
	CTE_Param pi(1, 2, 3, "int");
	CTE_Param pf(4.5, 6.7, 8.9, "float");

	int pi_v = 0, pi_l = 0, pi_u = 0;
	pi.GetValue(pi_v);
	pi.GetLower(pi_l);
	pi.GetUpper(pi_u);

	double pf_v = 0, pf_l = 0, pf_u = 0;
	pf.GetValue(pf_v);
	pf.GetLower(pf_l);
	pf.GetUpper(pf_u);

	TRACE("\npi: name = \"%s\", %d, %d..%d.", pi.GetName(), pi_v, pi_l, pi_u);
	TRACE("\npf: name = \"%s\", %f, %f..%f.", pf.GetName(), pf_v, pf_l, pf_u);
#endif

}

CTeView::~CTeView()
{
	//delete TE_Library;
}

BOOL CTeView::PreCreateWindow(CREATESTRUCT& cs)
{
	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CTeView drawing

void CTeView::OnDraw(CDC* pDC)
{
	CTeDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	//	Select a vector font
	HFONT font = CreateFont
	(
		18, 0, 0, 0, FW_DONTCARE, 0, 0, 0, ANSI_CHARSET, 
		OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, 
		DEFAULT_QUALITY, DEFAULT_PITCH,
		"times new roman"
	);
	pDC->SelectObject(font);

	TextOut(pDC->m_hDC, 10, 10, "TextOut(pDC->m_hDC)", 19);
	TE_TextOut(pDC->m_hDC, 10, 50, "TE_TextOut(pDC->m_hDC)", 22, "fill");

}

/////////////////////////////////////////////////////////////////////////////
// CTeView printing

BOOL CTeView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CTeView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}

void CTeView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
}

/////////////////////////////////////////////////////////////////////////////
// CTeView diagnostics

#ifdef _DEBUG
void CTeView::AssertValid() const
{
	CView::AssertValid();
}

void CTeView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CTeDoc* CTeView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CTeDoc)));
	return (CTeDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTeView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\tedoc.h ===
// teDoc.h : interface of the CTeDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_TEDOC_H__C312667E_63A7_11D2_9138_00A0C970228E__INCLUDED_)
#define AFX_TEDOC_H__C312667E_63A7_11D2_9138_00A0C970228E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CTeDoc : public CDocument
{
protected: // create from serialization only
	CTeDoc();
	DECLARE_DYNCREATE(CTeDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTeDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTeDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CTeDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEDOC_H__C312667E_63A7_11D2_9138_00A0C970228E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\teview.h ===
// teView.h : interface of the CTeView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_TEVIEW_H__C3126680_63A7_11D2_9138_00A0C970228E__INCLUDED_)
#define AFX_TEVIEW_H__C3126680_63A7_11D2_9138_00A0C970228E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CTeView : public CView
{
protected: // create from serialization only
	CTeView();
	DECLARE_DYNCREATE(CTeView)

// Attributes
public:
	CTeDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTeView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CTeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CTeView)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in teView.cpp
inline CTeDoc* CTeView::GetDocument()
   { return (CTeDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TEVIEW_H__C3126680_63A7_11D2_9138_00A0C970228E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\wvttest\wvttest.c ===
//
// wvttest.c
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// test WinVerifyTrust for fonts in the same
// spirit as fonttest.exe.
//
//

#include <windows.h>
// #include <cderr.h>
// #include <commdlg.h>

// #include <direct.h>
#include <malloc.h>
// #include <memory.h>
#include <stdio.h>
#include <stdlib.h>
// #include <string.h>
// #include <stdarg.h>

#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>

#include <limits.h>

#include "wvttest.h"


typedef LONG (*LPWINVERIFYTRUST) (HWND, GUID *, LPVOID);

int     gTime;


int ParseArguments (int argc,
                    char *argv[],
                    BOOL *pfFileHandle,
                    BOOL *pfFilePath,
                    BOOL *pfFileCheck,
                    GUID *pguid,
                    ULONG *pulPerfTest,
                    ULONG *pulIterations,
                    CHAR **pszFile)
{
    int rv = FALSE;

    int i;
    BOOL fHflag = FALSE;
    BOOL fPflag = FALSE;
    BOOL fOflag = FALSE;
    BOOL fCflag = FALSE;
    BOOL fIflag = FALSE;
    BOOL fFflag = FALSE;

    GUID gOTF = CRYPT_SUBJTYPE_OTF_IMAGE;
//    GUID gTTC = CRYPT_SUBJTYPE_TTC_IMAGE;

    *pulPerfTest = PERF_WVT_ONLY; // default value
    *pulIterations = 1;  // default value

	//// Parse the command line.  See the default case
	//// for a list of command line options.
	for (i = 1; i < argc; ) {
		if (argv[i][0] == '-') {
			switch (argv[i][1]) {

                case '0': // measure CryptHashData only on the file
                    *pulPerfTest = PERF_CRYPTHASHDATA_ONLY;
                    i++;
                    break;

                case '1': // measure WinVerifyTrust only
                    *pulPerfTest = PERF_WVT_ONLY;
                    i++;
                    break;

                case '2': // measure WinVerifyTrust and file openings/closings (if any)
                    *pulPerfTest = PERF_EVERYTHING;
                    i++;
                    break;

                case 'h': // pass a file handle to WVT
                    fHflag = TRUE;
                    i++;
                    break;

                case 'p': // pass a file pathname to WVT
					fPflag = TRUE;
					i++;
					break;

                case 'o': // pass the OTF GUID to WVT
					fOflag = TRUE;
					i++;
					break;

                case 'i': // the number of iterations
                    fIflag = TRUE;

                    i++;
					if (i >= argc) {
                        printf ("Not enough command line arguments.\n");
						goto done;
					}
					if ((*pulIterations = strtoul (argv[i], NULL, 10)) == ULONG_MAX) {
                        printf ("Bad number of iterations.  Using default (= 1).\n");
                        *pulIterations = 1;
					    goto done;
					}
                    i++;
                    break;

				case 'f': // the file we are verifying or generating a signature from

					fFflag = TRUE;

					// Get a handle to the True Type font file.
					i++;  // i is now pointing to the file name
					if (i >= argc) {
                        printf ("No input file name given!\n");
                        goto done;
					} else {
						if ((*pszFile = (CHAR *) malloc (strlen(argv[i]) + 1)) == NULL) {
                            printf ("Error in malloc.\n");
							goto done;
						}
						strcpy (*pszFile, argv[i]);
					}
					i++;
					break;

				default: // error
                    printf ("Bad command line option (arg %d).\n", i);
                    printf ("  -f <filename>: file to pass to WinVerifyTrust\n");
                    printf ("  -h : use a file handle when calling WVT\n");
                    printf ("  -p : use a file pathname when calling WVT\n");
                    printf ("  -o : assume the file is a font (OTF or TTC) file (no IsFileType checks)\n");
                    printf ("  -i : number of iterations to perform (default = 1)\n");
                    printf ("  -0 : measure only CryptHashData on the file\n");
                    printf ("         (works only if the number of iterations is 1 or if -p is set)\n");
                    printf ("  -1 : measure only WinVerifyTrust on the file (default)\n");
                    printf ("         (works only if the number of iterations is 1 or if -p is set)\n");
                    printf ("  -2 : measure WinVerifyTrust and file opening/closing\n");
                    printf ("defaults: memory pointer is used when calling WVT\n");
                    printf ("          IsFileType checks are made\n");
					goto done;
					break;
			}
		}
	}

    if (!fHflag && !fPflag && !fOflag && (*pulPerfTest != PERF_CRYPTHASHDATA_ONLY)) {
        printf ("Must have at least one of (-p or -h) or -o or -0 options.\n");
        goto done;
    }
    if (fHflag && fPflag) {
        printf ("Cannot specify -h and -p simultaneously.\n");
        goto done;
    }

    if (!fFflag) {
        printf ("Must specify a file name with the -f option.\n");
        goto done;
    }

    // set the return values
    *pfFileHandle = fHflag ? TRUE : FALSE;
    *pfFilePath = fPflag ? TRUE : FALSE;
    *pfFileCheck = (fOflag) ? FALSE : TRUE;
    if (fOflag) {
        *pguid = gOTF;
    }
    // note: *guid will be garbage if neither flag is set

    // pulIterations already set in -i option
    // pszFile already set in the -f option

    rv = TRUE;

done:
    return rv;
}


ULONG AuthenticFontSignature_MemPtr(BYTE *pbFile, ULONG cbFile, GUID *pguid, BOOL fFileCheck)
{
    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_BLOB_INFO      sWTBI;
    HANDLE                  hDll;
    LPWINVERIFYTRUST        lpWinVerifyTrust = NULL;
    ULONG                   fl;
    
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTBI, 0x00, sizeof(WINTRUST_BLOB_INFO));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_BLOB;
    sWTD.pBlob          = &sWTBI;
    sWTBI.cbStruct      = sizeof(WINTRUST_BLOB_INFO);
    sWTBI.gSubject      = *pguid;
    sWTBI.cbMemObject   = cbFile;
    sWTBI.pbMemObject   = pbFile;

//    hDll = LoadLibrary("wintrust");
    fl = 0;
    
//    if(hDll)
//    {
//        lpWinVerifyTrust = (LPWINVERIFYTRUST) GetProcAddress(hDll, "WinVerifyTrustEx");
//        if(lpWinVerifyTrust)
//        {
            if ((WinVerifyTrust ((HWND) 10, &gV2, &sWTD)) == ERROR_SUCCESS)
            {
#if DBG
                 printf(("WinVerifyTrust succeeded.\n"));
#endif
                 fl = TRUE;
            }
            else
            {
#if DBG
                 printf(("WinVerifyTrust failed.\n"));
#endif
            }
//        }                        
//        FreeLibrary(hDll);
//     }

     return fl;
}


ULONG AuthenticFontSignature_FileHandle(HANDLE hFile, GUID *pguid, BOOL fFileCheck)
{
    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    HANDLE                  hDll;
    LPWINVERIFYTRUST        lpWinVerifyTrust = NULL;
    ULONG                   fl;
    
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
    sWTD.pFile          = &sWTFI;
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = hFile;
    sWTFI.pcwszFilePath = NULL;
    sWTFI.pgKnownSubject = pguid;

//    hDll = LoadLibrary("wintrust");
    fl = 0;
    
//    if(hDll)
//    {
//        lpWinVerifyTrust = (LPWINVERIFYTRUST) GetProcAddress(hDll, "WinVerifyTrustEx");
//        if(lpWinVerifyTrust)
//        {
            if ((WinVerifyTrust ((HWND) 10, &gV2, &sWTD)) == ERROR_SUCCESS)
            {
                 printf(("WinVerifyTrust succeeded.\n"));
                 fl = TRUE;
            }
            else
            {
                 printf(("WinVerifyTrust failed.\n"));
            }
//        }                        
//        FreeLibrary(hDll);
//     }

     return fl;
}


ULONG AuthenticFontSignature_FilePath(LPWSTR pwszPathFileName, GUID *pguid, BOOL fFileCheck)
{
    GUID                    gV2 = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    WINTRUST_DATA           sWTD;
    WINTRUST_FILE_INFO      sWTFI;
    HANDLE                  hDll;
    LPWINVERIFYTRUST        lpWinVerifyTrust = NULL;
    ULONG                   fl;
    
    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    memset(&sWTFI, 0x00, sizeof(WINTRUST_FILE_INFO));

    sWTD.cbStruct       = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice     = WTD_UI_NONE;
    sWTD.dwUnionChoice  = WTD_CHOICE_FILE;
    sWTD.pFile          = &sWTFI;
    sWTFI.cbStruct      = sizeof(WINTRUST_FILE_INFO);
    sWTFI.hFile         = INVALID_HANDLE_VALUE;
    sWTFI.pcwszFilePath = pwszPathFileName;
    sWTFI.pgKnownSubject = pguid;

//    hDll = LoadLibrary("wintrust");
    fl = 0;
    
//    if(hDll)
//    {
//        lpWinVerifyTrust = (LPWINVERIFYTRUST) GetProcAddress(hDll, "WinVerifyTrustEx");
//        if(lpWinVerifyTrust)
//        {
            if ((WinVerifyTrust ((HWND) 10, &gV2, &sWTD)) == ERROR_SUCCESS)
            {
                 printf(("WinVerifyTrust succeeded.\n"));
                 fl = TRUE;
            }
            else
            {
                 printf(("WinVerifyTrust failed.\n"));
            }
//        }                        
//        FreeLibrary(hDll);
//     }

     return fl;
}


ULONG HashFile_MemPtr (HCRYPTPROV hProv, BYTE *pbFile, ULONG cbFile)
{

    HCRYPTHASH hHash;
    BYTE *pbHash = NULL;
    ULONG cbHash = 16;
    ALG_ID alg_id = CALG_MD5;

    // Set hHashTopLevel to be the hash object.
    if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHash)) {
        printf ("Error during CryptCreateHash.\n");
        goto done;
    }

    // Allocate memory for the hash value.
    if ((pbHash = (BYTE *) malloc (cbHash)) == NULL) {
        printf ("Error in malloc.\n");
        goto done;
    }

    //// Pump the bytes of the new file into the hash function
    if (!CryptHashData (hHash, pbFile, cbFile, 0)) {
        printf ("Error during CryptHashData.\n");
        goto done;
    }
		
    //// Compute the top-level hash value, and place the resulting
    //// hash value into pbHashTopLevel.
    if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
        printf ("Error during CryptGetHashParam (hash value)\n");
        goto done;
    }

done:
    if (pbHash) {
        free (pbHash);
    }

    return TRUE;
}




void __cdecl main (int argc, char *argv[])
{
    int rc = 0;
    ULONG  i;
    LPSTR  lpszFile = NULL;
    WCHAR  wPathFileName[260];
    BOOL   fFileHandle;
    BOOL   fFilePath;
    HANDLE hFile = NULL;
    HANDLE hMapFile = NULL;
    BYTE   *pbFile = NULL;
    ULONG  cbFile = 0;

    BOOL   fFileCheck;
    GUID   gOTF = CRYPT_SUBJTYPE_OTF_IMAGE;
    GUID   guid;
    GUID *ptheguid = NULL;
    ULONG  ulPerfTest;
    ULONG  ulIterations;
    HCRYPTPROV hProv = NULL;
    HMODULE hdll = NULL;

    _int64 liStart;
    _int64 liNow;
    _int64 liFreq;
    ULONG  liDelta;

    static char szFile[260];


    memset (&guid, 0x00, sizeof (GUID));
    if (ParseArguments (argc,
                        argv,
                        &fFileHandle,
                        &fFilePath,
                        &fFileCheck,
                        &guid,
                        &ulPerfTest,
                        &ulIterations,
                        &lpszFile) == FALSE) {
        printf ("Error parsing aruments.\n");
        goto done;
    }
 
    if ((hdll = LoadLibraryA ("mssipotf")) == NULL) {
      printf ("LoadLibraryA(mssipotf) failed.\n");
    }

    printf( "Evaluate TT in WVT's performance\n" );

//    lpszFile = (lstrlen(szFile) ? szFile : NULL);

printf ("lpszFile: '%s'\n", lpszFile);

    MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, lpszFile, -1,
                      wPathFileName, 260);

    // need to be set by now:
    // fFileHandle
    // fFilePath
    // fFileCheck
    // guid
    // ulIterations

printf ("fFileHandle: %d\n", fFileHandle);
printf ("fFilePath : %d\n", fFilePath);
printf ("fFileCheck: %d\n", fFileCheck);
printf ("wPathFileName: '%S'\n", wPathFileName);
printf ("ulIterations: %d\n", ulIterations);

    if (!fFilePath && !fFileHandle && (ulPerfTest != PERF_CRYPTHASHDATA_ONLY)) {

        // ASSERT: fFileCheck must FALSE
        if (fFileCheck) {
            printf ("ERROR: file check should not happen!\n");
            goto done;
        }

        printf ("Mapping file and verifying ...\n");
        if (ulPerfTest == PERF_EVERYTHING) {
            QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
        }

        for(i = 0; i < ulIterations; i++) {

            // convert file path name into a file handle
            if ((hFile = CreateFile (lpszFile,
                                     GENERIC_READ,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL)) == NULL) {
                printf ("Error in CreateFile.\n");
                goto done;
            }
                            
            // map the file into memory before calling WVT
            if ((hMapFile = CreateFileMapping (hFile,
                                     NULL,
                                     PAGE_READONLY,
                                     0,
                                     0,
                                     NULL)) == NULL) {
                printf ("Error in CreateFileMapping.\n");
                goto done;
            }
            if ((pbFile = (BYTE *) MapViewOfFile (hMapFile,
                                                  FILE_MAP_READ,
                                                  0,
                                                  0,
                                                  0)) == NULL) {
                printf ("Error in MapViewOfFile.\n");
                goto done;
            }
            if ((cbFile = GetFileSize (hFile, NULL)) == 0xFFFFFFFF) {
                printf ("Error in GetFileSize.\n");
                goto done;
            }

#if DBG
printf ("pbFile = %d\n", pbFile);
printf ("cbFile = %d\n", cbFile);
#endif
            if (ulPerfTest == PERF_WVT_ONLY) {
                QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
            }
            
            rc = AuthenticFontSignature_MemPtr (pbFile, cbFile, &guid, fFileCheck);

            if (ulPerfTest == PERF_WVT_ONLY) {
                QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
            }

            // unmap the file
            if (hMapFile) {
#if DBG
printf ("Unmapping file (1) ...\n");
#endif
                CloseHandle (hMapFile);
            }
            if (pbFile) {
#if DBG
printf ("Unmapping file (2) ...\n");
#endif
                UnmapViewOfFile (pbFile);
            }
            if (hFile) {
#if DBG
printf ("Unmapping file (3) ...\n");
#endif
                CloseHandle (hFile);
            }

        }

        if (ulPerfTest == PERF_EVERYTHING) {
            QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
            QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
        }

    } else if (fFileHandle) {
        printf ("Creating and using file handle to verify ...\n");
        if (fFileCheck) {
            ptheguid = NULL;
        } else {
            ptheguid = &guid;
        }

        if (ulPerfTest == PERF_EVERYTHING) {
            QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
        }

        for(i = 0; i < ulIterations; i++) {

            // create file handle and verify
            if ((hFile = CreateFile (lpszFile,
                                     GENERIC_READ,
                                     0,
                                     NULL,
                                     OPEN_EXISTING,
                                     0,
                                     NULL)) == NULL) {
                printf ("Error in CreateFile.\n");
                goto done;
            }

            if (ulPerfTest == PERF_WVT_ONLY) {
                QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
            }

            rc = AuthenticFontSignature_FileHandle (hFile, ptheguid, fFileCheck);

            if (ulPerfTest == PERF_WVT_ONLY) {
                QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
            }

            if (hFile) {
#if DBG
printf ("Unmapping file ...\n");
#endif
                CloseHandle (hFile);
            }
        }
        if (ulPerfTest == PERF_EVERYTHING) {
            QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
            QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
        }

    } else if (fFilePath) {

printf ("Using file pathname to verify ...\n");

        if (fFileCheck) {
            ptheguid = NULL;
        } else {
            ptheguid = &guid;
        }

        for (i = 0; i < ulIterations; i++) {

            if ((ulPerfTest == PERF_EVERYTHING) ||
                (ulPerfTest == PERF_WVT_ONLY)) {
                QueryPerformanceCounter((LARGE_INTEGER *) &liStart);
            }

            rc = AuthenticFontSignature_FilePath (wPathFileName, ptheguid, fFileCheck);

            if ((ulPerfTest == PERF_EVERYTHING) ||
                (ulPerfTest == PERF_WVT_ONLY)) {
                QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
                QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
            }
        }
    } else {

        // ASSERT: ulPerfTest == 0

printf ("Performing CryptHashData only on the file ...\n");

        // convert file path name into a file handle
        if ((hFile = CreateFile (lpszFile,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL)) == NULL) {
            printf ("Error in CreateFile.\n");
            goto done;
        }
                            
        // map the file into memory before calling WVT
        if ((hMapFile = CreateFileMapping (hFile,
                                 NULL,
                                 PAGE_READONLY,
                                 0,
                                 0,
                                 NULL)) == NULL) {
           printf ("Error in CreateFileMapping.\n");
           goto done;
        }
        if ((pbFile = (BYTE *) MapViewOfFile (hMapFile,
                                              FILE_MAP_READ,
                                              0,
                                              0,
                                              0)) == NULL) {
            printf ("Error in MapViewOfFile.\n");
            goto done;
        }
        if ((cbFile = GetFileSize (hFile, NULL)) == 0xFFFFFFFF) {
            printf ("Error in GetFileSize.\n");
            goto done;
        }
#if DBG
printf ("pbFile = %d\n", pbFile);
printf ("cbFile = %d\n", cbFile);
#endif

        // Set hProv to point to a cryptographic context of the default CSP.
        if (!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
            printf ("Error during CryptAcquireContext.  ");
            printf ("last error = %x.\n", GetLastError ());
            goto done;
        }

        for(i = 0; i < ulIterations; i++) {

            QueryPerformanceCounter((LARGE_INTEGER *) &liStart);

            rc = HashFile_MemPtr (hProv, pbFile, cbFile);

            QueryPerformanceCounter((LARGE_INTEGER *) &liNow);
            QueryPerformanceFrequency((LARGE_INTEGER *) &liFreq);
        }

        if (hProv) {
            CryptReleaseContext(hProv, 0);
        }

        // unmap the file
        if (hMapFile) {
#if DBG
printf ("Unmapping file (1) ...\n");
#endif
            CloseHandle (hMapFile);
        }
        if (pbFile) {
#if DBG
printf ("Unmapping file (2) ...\n");
#endif
            UnmapViewOfFile (pbFile);
        }
        if (hFile) {
#if DBG
printf ("Unmapping file (3) ...\n");
#endif
            CloseHandle (hFile);
        }
    }

done:                       

    printf( "  WVTtest rc = %d\n", rc );
    if ( rc ) {
        liNow = liNow - liStart;
        liDelta = (ULONG) ((liNow * 1000) / liFreq);
        printf( "  Time is %d milliseconds\n", liDelta );
    } else {
        printf((" Failed to get WVT performance\n"));
    }

    if (lpszFile) {
        free (lpszFile);
    }

    if (hdll) {
        FreeLibrary (hdll);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\teff\veclib.h ===
// veclib.h:	2D/3D vector and matrix library

//	Cameron Browne
//	10/20/1998	

#ifndef VECTOR_LIBRARY_DEFINED
#define VECTOR_LIBRARY_DEFINED

#include <math.h>


//////////////////////////////////////////////////////////////////////////////
//	Constants

static	const	double	PI			=	3.1415926535897932384626433832795;
static	const	double	PI_BY_2		=	6.283185307179586476925286766559;
static	const	double	PI_ON_2		=	1.5707963267948966192313216916398;
static	const	double	E			=	2.7182818284590452353602874713527;
static	const	double	EPSILON		=	0.000001;

static	const	double	SQRT_2		=	1.4142135623730950488016887242097;
static	const	double	SQRT_3		=	1.7320508075688772935274463415059;
static	const	double	CBRT_2		=	1.2599210498948731647672106072782;

static	const	double	DEG_T0_RAD	=	0.017453292519943295769236907684886
static	const	double	RAD_T0_DEG	=	57.295779513082320876798154814105;


//////////////////////////////////////////////////////////////////////////////
//	Macros

//	Take sign of a, either -1, 0, or 1
#define ZSGN(a)			( ((a) < 0) ? -1 : (a) > 0 ? 1 : 0 )

//	Ttake binary sign of a, either -1, or 1 if >= 0
#define SGN(a)			( ((a) < 0) ? -1 : 1 )

//	Square a
#define SQR(a)			( (a) * (a) )

//	Linear interpolation from l (when a=0) to h (when a=1)
//	Equal to (a * h) + ((1 - a) * l)
#define LERP(a,l,h)		( (l) + (((h) - (l)) * (a)) )

//	Clamp the input to the specified range
#define CLAMP(v,l,h)	( (v) < (l) ? (l) : (v) > (h) ? (h) : v )


//////////////////////////////////////////////////////////////////////////////
//	Utility functions


//////////////////////////////////////////////////////////////////////////////
//	Type declarations

//	Pointer to a function which returns a double and takes a double as argument
typedef	double	(*V_FN_PTR)(double);


//////////////////////////////////////////////////////////////////////////////
//	CPoint2

class CPoint2
{
//	Interface
public:
	CPoint2()						{ m_X = 0.0;	m_Y = 0.0; }
	CPoint2(CPoint2 const& vec)		{ m_X = vec.m_X;m_Y = vec.m_Y; }
	CPoint2(double x, double y)		{ m_X = x;		m_Y = y; }
	~CPoint2();

	//	Data member access
	void		Set(double  x, double  y)		{ m_X = x;	m_Y = y; }
	void		Get(double& x, double& y) const	{ x = m_X;	y = m_Y; }

	void		SetX(double x)		{ m_X = x; }
	double		GetX(void) const	{ return m_X; }
	void		SetY(double y)		{ m_Y = y; }
	double		GetY(void) const	{ return m_Y; }

	//	Operations
	CPoint2&	Apply(V_FN_PTR fn)		
				{ 
					m_X = (*fn)(m_X);
					m_Y = (*fn)(m_Y);
					return *this; 
				}

//	Private data members
private:
	double	m_X;
	double	m_Y;
};

//////////////////////////////////////////////////////////////////////////////
//	CVector2

class CVector2
{
//	Interface
public:
	CVector2()						{ m_X = 0.0;	m_Y = 0.0; }
	CVector2(CVector2 const& vec)	{ m_X = vec.m_X;m_Y = vec.m_Y; }
	CVector2(double x, double y)	{ m_X = x;		m_Y = y; }
	~CVector2();

	//	Data member access
	void		Set(double  x, double  y)		{ m_X = x;	m_Y = y; }
	void		Get(double& x, double& y) const	{ x = m_X;	y = m_Y; }

	void		SetX(double x)		{ m_X = x; }
	double		GetX(void) const	{ return m_X; }
	void		SetY(double y)		{ m_Y = y; }
	double		GetY(void) const	{ return m_Y; }

	//	Operations
	double		Length(void) const	{ return sqrt(length2()); }
	double		Length2(void) const	{ return (m_X * m_X + m_Y * m_Y); }
	CVector2&	Normalise(void)		
				{ 
					double ln = Length(); 
					if (ln != 0.0) 
						*this /= ln; 
					return *this; 
				}
	CVector2&	Apply(V_FN_PTR fn)		
				{ 
					m_X = (*fn)(m_X);
					m_Y = (*fn)(m_Y);
					return *this; 
				}


//	Private data members
private:
	double	m_X;
	double	m_Y;
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\test\wvttest\wvttest.h ===
//
// wvttest.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

// When DBG == 1, diagnostic messages are displayed
// This #define should be in sync with the version of
// mssipotf that you are using.  That is, if DBG == 0,
// then you want DBG == 0 in the version of mssipotf
// that you compiled.  Generally speaking, you want
// a DBG == 0 ("quiet") version when you are measuring
// performance.
#define DBG 0


// Performance measures
#define PERF_CRYPTHASHDATA_ONLY   0
#define PERF_WVT_ONLY             1
#define PERF_EVERYTHING           2


// New GUID for OTF files -- dchinn
// SIP v2.0 OTF Image == {6D875CC1-EF35-11d0-9438-00C04FD42C3B}
#define CRYPT_SUBJTYPE_OTF_IMAGE                                    \
            { 0x6d875cc1,                                           \
              0xef35,                                               \
              0x11d0,                                               \
              { 0x94, 0x38, 0x0, 0xc0, 0x4f, 0xd4, 0x2c, 0x3b }     \
            }

/*
// New GUID for TTC files -- dchinn
// SIP v2.0 TTC Image = {69986620-5BB5-11d1-A3E3-00C04FD42C3B}
#define CRYPT_SUBJTYPE_TTC_IMAGE                                    \
            { 0x69986620,                                           \
              0x5bb5,                                               \
              0x11d1,                                               \
              { 0xa3, 0xe3, 0x0, 0xc0, 0x4f, 0xd4, 0x2c, 0x3b }     \
            }
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\uexts\debug.c ===
/******************************Module*Header*******************************\
* Module Name: debug.c
*
* This file is for debugging tools and extensions.
*
* Created: 22-Dec-1991
* Author: John Colleran
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#if defined(_X86_)
#define FASTCALL    __fastcall
#else
#define FASTCALL
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <limits.h>
#include <string.h>
#include <nlsconv.h>
#include <wingdip.h>

#include "winddi.h"
#include "firewall.h"
#include "ntgdistr.h"
#include "ntgdi.h"
#include "xfflags.h"
#include "hmgshare.h"
#include "local.h"
#include "metarec.h"
#include "mfrec16.h"
#include "metadef.h"
#include "font.h"

#include <excpt.h>
#include <ntstatus.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#define NOEXTAPI
#include <dbgext.h>
#include <ntcsrmsg.h>



/**************************************************************************\
 *
\**************************************************************************/

typedef struct _FLAGDEF {
    char *psz;          // description
    FLONG fl;           // flag
} FLAGDEF;


FLAGDEF afdLDC_FL[] = {
    { "LDC_SAP_CALLBACK              ",  LDC_SAP_CALLBACK             },
    { "LDC_DOC_STARTED               ",  LDC_DOC_STARTED              },
    { "LDC_PAGE_STARTED              ",  LDC_PAGE_STARTED             },
    { "LDC_CALL_STARTPAGE            ",  LDC_CALL_STARTPAGE           },
    { "LDC_NEXTBAND                  ",  LDC_NEXTBAND                 },
    { "LDC_EMPTYBAND                 ",  LDC_EMPTYBAND                },
    { "LDC_META_ARCDIR_CLOCKWISE     ",  LDC_META_ARCDIR_CLOCKWISE    },
    { "LDC_FONT_CHANGE               ",  LDC_FONT_CHANGE              },
    { "LDC_DOC_CANCELLED             ",  LDC_DOC_CANCELLED            },
    { "LDC_META_PRINT                ",  LDC_META_PRINT               },
    { "LDC_PRINT_DIRECT              ",  LDC_PRINT_DIRECT             },
    { "LDC_BANDING                   ",  LDC_BANDING                  },
    { "LDC_DOWNLOAD_FONTS            ",  LDC_DOWNLOAD_FONTS           },
    { "LDC_RESETDC_CALLED            ",  LDC_RESETDC_CALLED           },
    { "LDC_FORCE_MAPPING             ",  LDC_FORCE_MAPPING            },
    { "LDC_INFO                      ",  LDC_INFO                     },
    { "NULL                          ",  0                            },
};

FLAGDEF afdDirty[] = {
    { "DIRTY_FILL              ", DIRTY_FILL              },
    { "DIRTY_LINE              ", DIRTY_LINE              },
    { "DIRTY_TEXT              ", DIRTY_TEXT              },
    { "DIRTY_BACKGROUND        ", DIRTY_BACKGROUND        },
    { "DIRTY_CHARSET           ", DIRTY_CHARSET           },
    { "SLOW_WIDTHS             ", SLOW_WIDTHS             },
    { "DC_CACHED_TM_VALID      ", DC_CACHED_TM_VALID      },
    { "DISPLAY_DC              ", DISPLAY_DC              },
    { "DIRTY_PTLCURRENT        ", DIRTY_PTLCURRENT        },
    { "DIRTY_PTFXCURRENT       ", DIRTY_PTFXCURRENT       },
    { "DIRTY_STYLESTATE        ", DIRTY_STYLESTATE        },
    { "DC_PLAYMETAFILE         ", DC_PLAYMETAFILE         },
    { "DC_BRUSH_DIRTY          ", DC_BRUSH_DIRTY          },
    { "DC_DIBSECTION           ", DC_DIBSECTION           },
    { "DC_LAST_CLIPRGN_VALID   ", DC_LAST_CLIPRGN_VALID   },
    {                          0, 0                       }
};

FLAGDEF afdIcmMode[] = {
    { "ICM_ON                  ", ICM_ON                  },
    { "ICM_OFF                 ", ICM_OFF                 },
    {                          0, 0                       }
};

FLAGDEF afdBrushAttr[] = {
    { "ATTR_CACHED             ", ATTR_CACHED             },
    { "ATTR_TO_BE_DELETED      ", ATTR_TO_BE_DELETED      },
    { "ATTR_NEW_COLOR          ", ATTR_NEW_COLOR          },
    { "ATTR_CANT_SELECT        ", ATTR_CANT_SELECT        },
    {                          0, 0                       }
};


#define PRINT_FLAGS(ulIn,sSpace,afd)                \
{                                                   \
    ULONG ul = ulIn;                                \
    FLAGDEF *pfd;                                   \
                                                    \
    for (pfd=afd; pfd->psz; pfd++)                  \
        if (ul & pfd->fl)                           \
            Print("    %s%s\n",sSpace, pfd->psz);   \
}

char *pszMapMode(long l)
{
    char *psz;
    switch (l) {
    case MM_TEXT       : psz = "MM_TEXT"       ; break;
    case MM_LOMETRIC   : psz = "MM_LOMETRIC"   ; break;
    case MM_HIMETRIC   : psz = "MM_HIMETRIC"   ; break;
    case MM_LOENGLISH  : psz = "MM_LOENGLISH"  ; break;
    case MM_HIENGLISH  : psz = "MM_HIENGLISH"  ; break;
    case MM_TWIPS      : psz = "MM_TWIPS"      ; break;
    case MM_ISOTROPIC  : psz = "MM_ISOTROPIC"  ; break;
    case MM_ANISOTROPIC: psz = "MM_ANISOTROPIC"; break;
    default            : psz = "MM_?"          ; break;
    }
    return( psz );
}

char *pszBkMode(long l)
{
    char *psz;
    switch (l)
    {
    case TRANSPARENT:   psz = "TRANSPARENT"; break;
    case OPAQUE     :   psz = "OPAQUE"     ; break;
    default         :   psz = "BKMODE_?"   ; break;
    }
    return( psz );
}

char *pszObjType(HOBJ h)
{
    char *psz;

    switch (LO_TYPE(h))
    {
    case LO_BRUSH_TYPE     :   psz = "BRUSH     "; break;
    case LO_DC_TYPE        :   psz = "DC        "; break;
    case LO_BITMAP_TYPE    :   psz = "BITMAP    "; break;
    case LO_PALETTE_TYPE   :   psz = "PALETTE   "; break;
    case LO_FONT_TYPE      :   psz = "FONT      "; break;
    case LO_REGION_TYPE    :   psz = "REGION    "; break;
    case LO_CLIENTOBJ_TYPE :   psz = "CLIENTOBJ "; break;
    case LO_ALTDC_TYPE     :   psz = "ALTDC     "; break;
    case LO_PEN_TYPE       :   psz = "PEN       "; break;
    case LO_EXTPEN_TYPE    :   psz = "EXTPEN    "; break;
    case LO_DIBSECTION_TYPE:   psz = "DIBSECTION"; break;
    case LO_METAFILE16_TYPE:   psz = "METAFILE16"; break;
    case LO_METAFILE_TYPE  :   psz = "METAFILE  "; break;
    case LO_METADC16_TYPE  :   psz = "METADC16  "; break;
    default:
        switch (GRE_TYPE(h))
        {
        case DEF_TYPE          :   psz = "DEF          "; break;
        case DC_TYPE           :   psz = "DC           "; break;
        case DD_DIRECTDRAW_TYPE:   psz = "DD_DIRECTDRAW"; break;
        case DD_SURFACE_TYPE   :   psz = "DD_SURFACE   "; break;
        case RGN_TYPE          :   psz = "RGN          "; break;
        case SURF_TYPE         :   psz = "SURF         "; break;
        case CLIENTOBJ_TYPE    :   psz = "CLIENTOBJ    "; break;
        case PATH_TYPE         :   psz = "PATH         "; break;
        case PAL_TYPE          :   psz = "PAL          "; break;
        case ICMLCS_TYPE       :   psz = "ICMLCS       "; break;
        case LFONT_TYPE        :   psz = "LFONT        "; break;
        case RFONT_TYPE        :   psz = "RFONT        "; break;
        case PFE_TYPE          :   psz = "PFE          "; break;
        case PFT_TYPE          :   psz = "PFT          "; break;
        case ICMCXF_TYPE       :   psz = "ICMCXF       "; break;
        case ICMDLL_TYPE       :   psz = "ICMDLL       "; break;
        case BRUSH_TYPE        :   psz = "BRUSH        "; break;
        case PFF_TYPE          :   psz = "PFF          "; break;
        case CACHE_TYPE        :   psz = "CACHE        "; break;
        case SPACE_TYPE        :   psz = "SPACE        "; break;
        case META_TYPE         :   psz = "META         "; break;
        case EFSTATE_TYPE      :   psz = "EFSTATE      "; break;
        case BMFD_TYPE         :   psz = "BMFD         "; break;
        case VTFD_TYPE         :   psz = "VTFD         "; break;
        case TTFD_TYPE         :   psz = "TTFD         "; break;
        case RC_TYPE           :   psz = "RC           "; break;
        case TEMP_TYPE         :   psz = "TEMP         "; break;
        case DRVOBJ_TYPE       :   psz = "DRVOBJ       "; break;
        case DCIOBJ_TYPE       :   psz = "DCIOBJ       "; break;
        case SPOOL_TYPE        :   psz = "SPOOL        "; break;
        default                :   psz = "unknown      "; break;
        }
    }
    return( psz );
}




/******************************Public*Routine******************************\
*
* History:
*  03-Nov-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

char *gaszHelpCli[] = {
 "=======================================================================\n"
,"GDIEXTS client debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"dh  [object handle]   -- dump HMGR entry of handle\n"
,"ddc [DC handle]       -- dump DC obj (ddc -? for more info)\n"
,"hbr [brush handle]    -- dump DC brush object\n"
,"dcfont                -- dumps all logfont/cfontsinfo\n"
,"dcache                -- dump client side object cache info\n"
,"\n"
,"use gdikdx.dll extensions for kernel debuging\n"
,"=======================================================================\n"
,NULL
};

VOID
help(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    )
{
    PNTSD_OUTPUT_ROUTINE Print;
    char **ppsz = gaszHelpCli;

// Avoid warnings.

    hCurrentProcess  = hCurrentProcess;
    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    Print = lpExtensionApis->lpOutputRoutine;

// The help info is formatted as a doubly NULL-terminated array of strings.
// So, until we hit the NULL, print each string.

    while (*ppsz)
        Print(*ppsz++);
}

/******************************Public*Routine******************************\
* dumphandle
*
* Dumps the contents of a GDI client handle
*
* History:
*  23-Dec-1991 -by- John Colleran
* Wrote it.
\**************************************************************************/

void dh(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PENTRY pent;
    DWORD  ho;
    ENTRY  ent;                            // copy of handle entry
    ULONG  ulTemp;

// eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

// do some real work

    ho = (ULONG)EvalExpression(lpArgumentString);

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");

    pent += HANDLE_TO_INDEX(ho);
    move(ent,pent);

// just incase they just gave us the index

    ho = MAKE_HMGR_HANDLE(HANDLE_TO_INDEX(ho),ent.FullUnique);

// Print the entry.

    Print("--------------------------------------------------\n");
    Print("Entry from ghmgr for handle 0x%08lx, pent = %lx\n", ho,pent);

    Print("    objt        = 0x%x, %s\n" , ent.Objt,pszObjType(ho));
    Print("    puser       = 0x%x\n"     , ent.pUser);
    Print("    ObjectOwner = 0x%08lx\n"  , ent.ObjectOwner.ulObj);
    Print("    pidOwner    = 0x%x\n"     , ent.ObjectOwner.Share.Pid);
    Print("    usUnique    = 0x%hx\n"    , ent.FullUnique);

    Print("    pobj krnl   = 0x%08lx\n"  , ent.einfo.pobj);
    Print("    ShareCount  = 0x%x\n"     , ent.ObjectOwner.Share.Count);
    Print("    lock        = %s\n"       , ent.ObjectOwner.Share.Lock ? "LOCKED" : "UNLOCKED");
    Print("    fsHmgr      = 0x%hx\n"    , ent.Flags);

    Print("--------------------------------------------------\n");
}

/******************************Public*Routine******************************\
* dcfonts
*
* Dumps the contents of a GDI client handle
*
* History:
*  23-Dec-1991 -by- John Colleran
* Wrote it.
\**************************************************************************/

void dcfont(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    int i;
    PENTRY pent;
    ENTRY ent;
    ULONG pid;
    ULONG h;
    ULONG ho;

// eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

// do some real work

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");
    GetValue(pid,"&gdi32!gW32PID");

    ho = (ULONG)EvalExpression(lpArgumentString);

    i = 0;

    if (ho)
        i =  HANDLE_TO_INDEX(ho);

    Print("pent = %lx, pid = %lx, lf type = %lx\n",pent,pid,LFONT_TYPE);

    for (;i < 1000/*MAX_HANDLE_COUNT*/; ++i)
    {
        move(ent,pent+i);

        if ((ent.Objt == LFONT_TYPE) &&
            ((ent.ObjectOwner.Share.Pid == pid) || ho))
        {
            LOCALFONT lf;
            h = MAKE_HMGR_HANDLE(i,ent.FullUnique);

            Print("\n");
            Print("%3lx: h = %lx, puser = %lx, owner = %lx\n",i,h,ent.pUser,ent.ObjectOwner.Share.Pid);

            if (ent.pUser)
            {
                CFONT cf;
                PCFONT pcf;

                move(lf,ent.pUser);

                for (pcf = lf.pcf; pcf; pcf = cf.pcfNext)
                {
                    move(cf,pcf);

                    Print("    pcf = 0x%lx, fl = 0x%lx, lHeight = %d\n",
                        pcf,cf.fl,cf.lHeight);

                    Print("          efm11 = 0x%08lx, efm22 = 0x%08lx, hdc = 0x%08lx\n",
                        lEfToF(cf.efM11),lEfToF(cf.efM22),cf.hdc);
                }
            }
        }

        if (ho)
            break;
    }
}

/******************************Public*Routine******************************\
*
* History:
*  10-Apr-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

void ddc(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PENTRY pent;
    DWORD  ho;
    ENTRY  ent;                            // copy of handle entry
    ULONG  ulTemp;
    BOOL   bVerbose = FALSE;
    BOOL   bLDC     = FALSE;

    // eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    // set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    if (*lpArgumentString == '-')
    {
        char chOpt;
        do {
            chOpt = *(++lpArgumentString);

            switch (chOpt) {
            case 'v':
            case 'V':
                bVerbose = TRUE;
                break;

            case 'L':
            case 'l':
                bLDC = TRUE;
                break;
            }

        } while ((chOpt != ' ') && (chOpt != '\0'));
    }

    // do some real work

    ho = (ULONG)EvalExpression(lpArgumentString);

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");

    pent += HANDLE_TO_INDEX(ho);
    move(ent,pent);

    // now get the dcAttr

    Print("DC dump for handle %lx, pUser = %lx\n",ho,ent.pUser);

    if (ent.pUser != NULL)
    {
        DC_ATTR dca;

        move(dca,ent.pUser);

        Print("        objt         = 0x%x\n"        , ent.Objt);

        Print("        pldc         = 0x%x\n"        , dca.pvLDC);

        Print("        ulDirty_     = 0x%08x\n"       , dca.ulDirty_);
        PRINT_FLAGS(dca.ulDirty_,"        ",afdDirty);

        Print("        hbrush       = 0x%08x\n"       , dca.hbrush);
        Print("        hpen         = 0x%08x\n"       , dca.hpen);
        Print("        hfont        = 0x%08x\n"       , dca.hlfntNew);

        Print("        bkColor      = 0x%x, (0x%x)\n", dca.crBackgroundClr,dca.ulBackgroundClr);
        Print("        foreColor    = 0x%x, (0x%x)\n", dca.crForegroundClr,dca.ulForegroundClr);

        Print("        lIcmMode     = 0x%08lx\n"      ,dca.lIcmMode);
        PRINT_FLAGS(dca.lIcmMode,"        ",afdIcmMode);

        Print("        hcmXform     = 0x%08lx\n"      ,dca.hcmXform);
        Print("        hColorSpace  = 0x%08lx\n"      ,dca.hColorSpace);
        Print("        pProfile     = 0x%08lx\n"      ,dca.pProfile);
        Print("        hProfile     = 0x%08lx\n"      ,dca.hProfile);
        Print("        IcmBrush     = 0x%08lx\n"      ,dca.IcmBrushColor);
        Print("        IcmPen       = 0x%08lx\n"      ,dca.IcmPenColor);

        if (bVerbose)
        {
            ULONG ul;
            PSZ psz;

            // REGION

            Print("    REGION\n");

            if (dca.VisRectRegion.AttrFlags & ATTR_RGN_VALID)
            {
                switch  (dca.VisRectRegion.Flags)
                {
                case NULLREGION:
                    Print("        NULLREGION\n");
                    break;

                SIMPLEREGION;
                    Print("        SIMPLEREGION, 1rect\n");
                    Print("        AttrFlags    = 0x%x,%s\n",
                            dca.VisRectRegion.AttrFlags,
                            (dca.VisRectRegion.AttrFlags & ATTR_RGN_DIRTY) ? "DIRTY" : "CLEAN");

                    Print("        RECT         = 0x%x, 0x%x, 0x%x, 0x%x\n",
                            dca.VisRectRegion.Rect.left,
                            dca.VisRectRegion.Rect.top,
                            dca.VisRectRegion.Rect.right,
                            dca.VisRectRegion.Rect.bottom);
                    break;

                case COMPLEXREGION:
                    Print("        COMPLEXREGION\n");
                    break;

                default:
                    Print("        ERROR in region\n");
                    break;
                }
            }
            else
            {
                Print("        invalid cached region\n");
            }

            Print("    Other attributes\n");

            Print("        BkMode       = 0x%x, (0x%x)\n", dca.lBkMode,dca.jBkMode);
            Print("        FillMode     = 0x%x, (0x%x)\n", dca.lFillMode,dca.jFillMode);
            Print("        StretchMode  = 0x%x, (0x%x)\n", dca.lStretchBltMode,dca.jStretchBltMode);
            Print("        PtlCurrent(L)= 0x%x,0x%x\n"   , dca.ptlCurrent.x,dca.ptlCurrent.y);
            Print("        PtlCurrent(D)= 0x%x,0x%x\n"   , dca.ptfxCurrent.x,dca.ptfxCurrent.y);
            Print("        ROP2         = 0x%x\n"        , dca.jROP2);
            Print("        GraphicsMode = 0x%x\n"        , dca.iGraphicsMode);

            Print("    Text attributes\n");

            Print("        code page    = 0x%x\n"        , dca.iCS_CP);
            Print("        flTextAlign  = 0x%x\n"        , dca.flTextAlign);
            Print("        lTextAlign   = 0x%x\n"        , dca.lTextAlign );
            Print("        lTextExtra   = 0x%x\n"        , dca.lTextExtra );
            Print("        lRelAbs      = 0x%x\n"        , dca.lRelAbs    );
            Print("        lBreakExtra  = 0x%x\n"        , dca.lBreakExtra);
            Print("        cBreak       = 0x%x\n"        , dca.cBreak     );

            Print("    XFORMS\n");

            Print("        flXform      = 0x%08lx\n", dca.flXform);

            Print("        Map Mode     = %ld, %s\n", dca.iMapMode, pszMapMode(dca.iMapMode));

            Print("        Window Org   = (%8ld, %8ld)\n", dca.ptlWindowOrg.x,
                                                 dca.ptlWindowOrg.y);
            Print("        Window Ext   = (%8ld, %8ld)\n", dca.szlWindowExt.cx,
                                                 dca.szlWindowExt.cy);
            Print("        Viewport Org = (%8ld, %8ld)\n", dca.ptlViewportOrg.x,
                                                   dca.ptlViewportOrg.y);
            Print("        Viewport Ext = (%8ld, %8ld)\n", dca.szlViewportExt.cx,
                                                   dca.szlViewportExt.cy);
            Print("        Virtual Pix  = (%8ld, %8ld)\n", dca.szlVirtualDevicePixel.cx,
                                                   dca.szlVirtualDevicePixel.cy);
            Print("        Virtual mm   = (%8ld, %8ld)\n", dca.szlVirtualDeviceMm.cx,
                                                     dca.szlVirtualDeviceMm.cy);

            Print("\tMatrix\n");
            Print("\t\tM11        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM11));
            Print("\t\tM12        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM12));
            Print("\t\tM21        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM21));
            Print("\t\tM22        =  0x%08lx\n", lEfToF(dca.mxWtoD.efM22));
            Print("\t\tDx         =  0x%08lx\n", lEfToF(dca.mxWtoD.efDx));
            Print("\t\tDy         =  0x%08lx\n", lEfToF(dca.mxWtoD.efDy));
            Print("\t\tFDx        =  0x%08lx\n", dca.mxWtoD.fxDx);
            Print("\t\tFDy        =  0x%08lx\n", dca.mxWtoD.fxDy);
        }

        if (bLDC && dca.pvLDC)
        {
            LDC ldc;
            move(ldc,dca.pvLDC);

            Print("    LDC\n");
            Print("        hdc          = 0x%08x\n"      , ldc.hdc);
            Print("        fl           = 0x%x\n"        , ldc.fl);
            PRINT_FLAGS(ldc.fl,"        ",afdLDC_FL);

            Print("        iType        = 0x%x, %s\n"    , ldc.iType, ldc.iType == LO_DC ? "LO_DC" : "LO_METADC");
            Print("        PMDC         = 0x%x\n"        , ldc.pvPMDC);
            Print("        pwszPort     = %ws\n"         , ldc.pwszPort ? ldc.pwszPort : L"NULL");
            Print("        pfnAbort     = 0x%08x\n"      , ldc.pfnAbort);
            Print("        hSpooler     = 0x%x\n"        , ldc.hSpooler);
            Print("        pdm          = 0x%x\n"        , ldc.pDevMode);
            Print("        pdm.devname  = %ws\n"         , ldc.pDevMode ? ldc.pDevMode->dmDeviceName : L"NULL");
        }
    }
}

/******************************Public*Routine******************************\
*
* History:
*  10-Apr-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

void hbrush(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PENTRY pent;
    DWORD  ho;
    ENTRY  ent;                            // copy of handle entry
    ULONG  ulTemp;
    BOOL   bVerbose = FALSE;
    BOOL   bLDC     = FALSE;

    // eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    // set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    if (*lpArgumentString == '-')
    {
        char chOpt;
        do {
            chOpt = *(++lpArgumentString);

            switch (chOpt) {
            case 'v':
            case 'V':
                bVerbose = TRUE;
                break;

            case 'L':
            case 'l':
                bLDC = TRUE;
                break;
            }

        } while ((chOpt != ' ') && (chOpt != '\0'));
    }

    // do some real work

    ho = (ULONG)EvalExpression(lpArgumentString);

    GetValue(pent,"&gdi32!pGdiSharedHandleTable");

    pent += HANDLE_TO_INDEX(ho);
    move(ent,pent);

    // now get the dcAttr

    Print("BRUSH dump for handle %lx, pUser = %lx\n",ho,ent.pUser);

    if (ent.pUser != NULL)
    {
        BRUSHATTR bra;

        move(bra,ent.pUser);

        Print("        objt         = 0x%x\n"        , ent.Objt);

        Print("        AttrFlags    = 0x%x, (0x%x)\n", bra.AttrFlags);
        PRINT_FLAGS(bra.AttrFlags,"        ",afdBrushAttr);

        Print("        lbColor      = 0x%x, (0x%x)\n", bra.lbColor);


    }
}

void dcache(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{
    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    PCFONT pcf;
    CFONT  cf;
    int    i;
    PGDI_SHARED_MEMORY pshare;

    // eliminate warnings

    hCurrentThread   = hCurrentThread;
    dwCurrentPc      = dwCurrentPc;
    lpArgumentString = lpArgumentString;

    // set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    // do some real work

    GetValue(pshare,"&gdi32!pGdiSharedMemory");
    pcf = pshare->acfPublic;

    Print("Public CFONT Table, %lx\n",pcf);

    for (i = 0; i < MAX_PUBLIC_CFONT; ++i)
    {
        move(cf,pcf);

        if (cf.hf)
        {
            Print("%2d: hf = 0x%lx, pcf = 0x%lx, fl = 0x%lx, lHeight = %d\n",
                i,cf.hf,pcf,cf.fl,cf.lHeight);
        }

        cf.hf = 0;

        pcf++;
    }
}


#if 0

/******************************Public*Routine******************************\
*
* History:
*  10-Apr-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

void clidumphmgr(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{

    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    LHE  lhe;
    LHE *pLocalTable;

    ULONG aulCount[LO_LAST];
    int i;
    int c;
    for (i = 0; i < LO_LAST; ++i)
        aulCount[i] = 0;

// eliminate warnings

    hCurrentThread = hCurrentThread;
    dwCurrentPc = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

    GetValue(c,"&gdi32!cLheCommitted");

    Print("cLheCommitted = %ld\n",c);

    GetValue(pLocalTable,"&gdi32!pLocalTable");

    for (i = 0; i < (int)c; ++i)
    {
        int iType;

        move(lhe,(pLocalTable+i));

        iType = lhe.iType & 0x0f;

        if (iType < LO_LAST)
            aulCount[iType]++;
        else
            Print("Invalid handle %lx, type = %ld\n",i,lhe.iType);
    }

    for (i = 0; i < LO_LAST; ++i)
        Print("\t%s - %ld\n",aszType[i],aulCount[i]);

    return;
}

void clidumpcache(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString)
{

    PNTSD_OUTPUT_ROUTINE Print;
    PNTSD_GET_EXPRESSION EvalExpression;
    PNTSD_GET_SYMBOL GetSymbol;

    LDC   ldc;
    HCACHE hc;

    PVOID apv[CACHESIZE];
    int i;
    BOOL b;
    PVOID pv;
    PLDC *gapldc;
    PHCACHE gaphcBrushes;
    PHCACHE gaphcFonts;

// eliminate warnings

    hCurrentThread = hCurrentThread;
    dwCurrentPc = dwCurrentPc;
    lpArgumentString = lpArgumentString;

// set up function pointers

    Print = lpExtensionApis->lpOutputRoutine;
    EvalExpression = lpExtensionApis->lpGetExpressionRoutine;
    GetSymbol = lpExtensionApis->lpGetSymbolRoutine;

// do the dc's

    Print("Cached objects - bucket: client handle, client handle, ...\n");
    Print("Cached DC's\n");

    GetAddress(gapldc,"gdi32!gapldc");

    move(apv,gapldc);

    for (i = 0; i < CACHESIZE; ++i)
    {
        b = FALSE;

        if (apv[i])
        {
            if (!b)
            {
                Print("\t%d: ",i);
                b = TRUE;
            }

            for (pv = apv[i]; pv; pv = ldc.pldcNext)
            {
                move(ldc,pv);
                Print("%x, ",ldc.lhdc);
            }
        }

        if (b)
            Print("\n");
    }

// do the brushes

    Print("Cached Brushes\n");

    GetAddress(gaphcBrushes,"gdi32!gaphcBrushes");
    move(apv,gaphcBrushes);

    for (i = 0; i < CACHESIZE; ++i)
    {
        b = FALSE;

        if (apv[i])
        {
            if (!b)
            {
                Print("\t%d: ",i);
                b = TRUE;
            }

            for (pv = apv[i]; pv; pv = hc.phcNext)
            {
                move(hc,pv);
                Print("%x, ",hc.hLocal);
            }
        }

        if (b)
            Print("\n");
    }

// do the fonts

    Print("Cached Fonts\n");

    GetAddress(gaphcFonts,"gdi32!gaphcFonts");
    move(apv,gaphcFonts);

    for (i = 0; i < CACHESIZE; ++i)
    {
        b = FALSE;

        if (apv[i])
        {
            if (!b)
            {
                Print("\t%d: ",i);
                b = TRUE;
            }

            for (pv = apv[i]; pv; pv = hc.phcNext)
            {
                move(hc,pv);
                Print("%x, ",hc.hLocal);
            }
        }

        if (b)
            Print("\n");
    }

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\client\acons.c ===
/****************************** Module Header ******************************\
* Module Name: acons.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code for dealing with animated icons/cursors.
*
* History:
* 10-02-91 DarrinM      Created.
* 07-30-92 DarrinM      Unicodized.
* 11-28-94 JimA         Moved to client from server.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Resource Directory format for IconEditor generated icon and cursor
 * (.ICO & .CUR) files.  All fields are shared except xHotspot and yHotspot
 * which are only valid for cursors.
 */
typedef struct _ICONFILERESDIR {    // ird
    BYTE bWidth;
    BYTE bHeight;
    BYTE bColorCount;
    BYTE bReserved;
    WORD xHotspot;
    WORD yHotspot;
    DWORD dwDIBSize;
    DWORD dwDIBOffset;
} ICONFILERESDIR;

typedef struct _HOTSPOTREC {    // hs
    WORD xHotspot;
    WORD yHotspot;
} HOTSPOTREC;

PCURSORRESOURCE ReadIconGuts(
    IN  PFILEINFO   pfi,
    IN  LPNEWHEADER pnhBase,
    IN  int         offResBase,
    OUT LPWSTR     *prt,
    IN  int         cxDesired,
    IN  int         cyDesired,
    IN  DWORD       LR_flags);

BOOL ReadTag(
    IN  PFILEINFO pfi,
    OUT PRTAG     ptag);

BOOL ReadChunk(
    IN  PFILEINFO pfi,
    IN      PRTAG ptag,
    OUT     PVOID pv);

BOOL SkipChunk(
    IN PFILEINFO pfi,
    IN PRTAG     ptag);

HICON CreateAniIcon(
    LPCWSTR pszName,
    LPWSTR rt,
    int cicur,
    DWORD *aicur,
    int cpcur,
    HCURSOR *ahcur,
    JIF jifRate,
    PJIF ajifRate,
    BOOL fPublic);

HCURSOR ReadIconFromFileMap(
    IN PFILEINFO   pfi,
    IN int         cbSize,
    IN DWORD       cxDesired,
    IN DWORD       cyDesired,
    IN DWORD       LR_flags);

HICON LoadAniIcon(
    IN PFILEINFO pfi,
    IN LPWSTR    rt,
    IN DWORD     cxDesired,
    IN DWORD     cyDesired,
    IN DWORD     LR_flags);



/***************************************************************************\
* LoadCursorFromFile (API)
*
* Called by SetSystemCursor.
*
* History:
* 08-03-92 DarrinM      Created.
\***************************************************************************/


FUNCLOG1(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorFromFileW, LPCWSTR, pszFilename)
HCURSOR WINAPI LoadCursorFromFileW(
    LPCWSTR pszFilename)
{
    return(LoadImage(NULL,
                     pszFilename,
                     IMAGE_CURSOR,
                     0,
                     0,
                     LR_DEFAULTSIZE | LR_LOADFROMFILE));
}



/***********************************************************************\
* LoadCursorFromFileA
*
* Returns: hCursor
*
* 10/9/1995 Created SanfordS
\***********************************************************************/


FUNCLOG1(LOG_GENERAL, HCURSOR, WINAPI, LoadCursorFromFileA, LPCSTR, pszFilename)
HCURSOR WINAPI LoadCursorFromFileA(
    LPCSTR pszFilename)
{
    LPWSTR lpUniName;
    HCURSOR hcur;

    if (pszFilename == NULL ||
            !MBToWCS(pszFilename, -1, &lpUniName, -1, TRUE))
        return (HANDLE)NULL;

    hcur = LoadCursorFromFileW(lpUniName);

    UserLocalFree(lpUniName);

    return hcur;
}



/***********************************************************************\
* ReadFilePtr
*
* Works like ReadFile but with pointers to a mapped file buffer.
*
* Returns:
*
* 11/16/1995 Created SanfordS
\***********************************************************************/
BOOL ReadFilePtr(
    IN  PFILEINFO pfi,
    OUT LPVOID   *ppBuf,
    IN  DWORD     cb)
{
    *ppBuf = pfi->pFilePtr;
    pfi->pFilePtr += cb;
    return (pfi->pFilePtr <= pfi->pFileEnd);
}



/***********************************************************************\
* ReadFilePtrUnaligned
*
* Works like ReadFile but with pointers to a mapped file buffer.
*
* Returns:
*
* 11/16/1995 Created SanfordS
\***********************************************************************/
BOOL ReadFilePtrUnaligned(
    IN  PFILEINFO pfi,
    OUT VOID UNALIGNED **ppBuf,
    IN  DWORD     cb)
{
    *ppBuf = pfi->pFilePtr;
    pfi->pFilePtr += cb;
    return (pfi->pFilePtr <= pfi->pFileEnd);
}



/***********************************************************************\
* ReadFilePtrCopy
*
* Works even more like ReadFile in that is copies data to the given buffer.
*
* Returns:
*
* 11/16/1995 Created SanfordS
\***********************************************************************/
BOOL ReadFilePtrCopy(
    IN     PFILEINFO pfi,
    IN OUT LPVOID pBuf,
    IN     DWORD cb)
{
    if (pfi->pFilePtr + cb > pfi->pFileEnd) {
        return(FALSE);
    }
    RtlCopyMemory(pBuf, pfi->pFilePtr, cb);
    pfi->pFilePtr += cb;
    return TRUE;
}



/***************************************************************************\
* ReadTag, ReadChunk, SkipChunk
*
* Some handy functions for reading RIFF files.
*
* History:
* 10-02-91 DarrinM      Created.
* 03-25-93 Jonpa        Changed to use RIFF format instead of ASDF
\***************************************************************************/
BOOL ReadTag(
    IN  PFILEINFO pfi,
    OUT PRTAG     ptag)
{
    ptag->ckID = ptag->ckSize = 0L;  // in case we fail the read.

    return(ReadFilePtrCopy(pfi, ptag, sizeof(RTAG)));
}



BOOL ReadChunk(
    IN  PFILEINFO pfi,
    IN  PRTAG     ptag,
    OUT PVOID     pv)
{
    if (!ReadFilePtrCopy(pfi, pv, ptag->ckSize))
        return FALSE;

    /* WORD align file pointer */
    if( ptag->ckSize & 1 )
        pfi->pFilePtr++;


    if (pfi->pFilePtr <= pfi->pFileEnd) {
        return TRUE;
    } else {
        RIPMSG0(RIP_WARNING, "ReadChunk: Advanced pointer past end of file map");
        return FALSE;
    }
}



BOOL SkipChunk(
    IN PFILEINFO pfi,
    IN PRTAG     ptag)
{
    /*
     * Round ptag->ckSize up to nearest word boundary
     * to maintain alignment
     */
    pfi->pFilePtr += (ptag->ckSize + 1) & (~1);
    if (pfi->pFilePtr <= pfi->pFileEnd) {
        return TRUE;
    } else {
        RIPMSG0(RIP_WARNING, "SkipChunk: Advanced pointer past end of file map");
        return FALSE;
    }
}



/***************************************************************************\
* LoadCursorIconFromFileMap
*
* If pszName is one of the IDC_* values then we use WIN.INI to find a
* custom cursor/icon.  Otherwise, pszName points to a filename of a .ICO/.CUR
* file to be loaded.  If the file is an .ANI file containing a multiframe
* animation then LoadAniIcon is called to create an ACON.  Otherwise if
* the file is an .ANI file containing just a single frame then it is loaded
* and a normal CURSOR/ICON resource is created from it.
*
* 12-26-91 DarrinM      Wrote it.
* 03-17-93 JonPa        Changed to use RIFF format for ani-cursors
* 11/16/1995 SanfordS   Added LR_flags support
\***************************************************************************/

HANDLE LoadCursorIconFromFileMap(
    IN PFILEINFO   pfi,
    IN OUT LPWSTR *prt,
    IN DWORD       cxDesired,
    IN DWORD       cyDesired,
    IN DWORD       LR_flags,
    OUT LPBOOL     pfAni)
{
    LPNEWHEADER pnh;
    int offResBase;

    *pfAni = FALSE;
    of