--------------------------------------------
//
//  Function:   HrOnCommandStatus
//
//  Purpose:    Command handler for the CMIDM_STATUS command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrOnCommandStatus(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT            hr          = S_OK;
    CONFOLDENTRY       ccfe;

    if (apidl[0].empty())
    {
        hr = E_INVALIDARG;
    }
    else
    {
        AssertSz(apidl.size() == 1, "We don't allow status on multi-selected items");

        // Copy the pidl, as the PostMessage isn't sync, and the context menu's
        // copy of the pidl could be destroyed before the tray processed the
        // message. The tray is responsible for free'ing in the pidl.
        //
        hr = apidl[0].ConvertToConFoldEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            if (fIsConnectedStatus(ccfe.GetNetConStatus()) ||
                ccfe.IsConnected() )
            {
                hr = HrOnCommandStatusInternal(ccfe, TRUE);
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandStatus");
    return hr;
}

VOID SetICWComplete();

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandNewConnection
//
//  Purpose:    Command handler for the CMIDM_NEW_CONNECTION command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   12 Nov 1997
//
//  Notes:
//
HRESULT HrOnCommandNewConnection(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT             hr              = S_OK;
    INetConnection *    pNetCon         = NULL;

    NETCFG_TRY

        PCONFOLDPIDL        pidlConnection;

        // Don't use hwndOwner for anything. We shouldn't become modal!
        //
        hr = NetSetupAddRasConnection(NULL, &pNetCon);
        if (S_OK == hr)
        {
            CConnectionFolder * pcf         = static_cast<CConnectionFolder *>(psf);
            PCONFOLDPIDLFOLDER  pidlFolder;
            if (pcf)
            {
                pidlFolder = pcf->PidlGetFolderRoot();
            }

            Assert(pNetCon);

            hr = g_ccl.HrInsertFromNetCon(pNetCon, pidlConnection);
            if (SUCCEEDED(hr) && (!pidlConnection.empty()) )
            {
                PCONFOLDPIDL    pcfp    = pidlConnection;

                GenerateEvent(SHCNE_CREATE, pidlFolder, pidlConnection, NULL);

                // Don't try to connect an object that's incoming only, and don't connect
                // it unless we're listed as disconnected
                //
                if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY) && (pcfp->ncs == NCS_DISCONNECTED))
                {
                    // If we have Ras connect permissions, then try to dial. Otherwise, don't
                    // force the user into a failure here.
                    //
                    if (FHasPermission(NCPERM_RasConnect))
                    {
                        hr = HrOnCommandConnectInternal(pNetCon, hwndOwner, pidlConnection, psf);
                    }
                }
            }

            pNetCon->Release();
        }
        else if (SUCCEEDED(hr))
        {
            // Convert S_FALSE to S_OK
            // S_FALSE means no pages were displayed but nothing failed.
            // S_FALSE is returned when the wizard is already being displayed
            //
            hr = S_OK;
        }

    SetICWComplete();
    
    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandNewConnection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandAdvancedConfig
//
//  Purpose:    Command handler for the CMIDM_ADVANCED_CONFIG command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   3 Dec 1997
//
//  Notes:
//
HRESULT HrOnCommandAdvancedConfig(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    hr = HrDoAdvCfgDlg(hwndOwner);

    TraceError("HrOnCommandAdvancedConfig", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDelete
//
//  Purpose:    Command handler for the CMIDM_DELETE command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//      psf       [in]  Our folder
//
//  Returns:
//
//  Author:     jeffspr   3 Dec 1997
//
//  Notes:
//
HRESULT HrOnCommandDelete(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT                 hr          = S_OK;
    INetConnection *        pNetCon     = NULL;
    INT                     iMBResult   = 0;
    BOOL                    fActivating = FALSE;

    NETCFG_TRY

        PCONFOLDPIDLVEC::const_iterator iterLoop;

        HANDLE hMutex              = NULL;

        for (iterLoop = apidl.begin(); iterLoop != apidl.end(); iterLoop++)
        {
            CConFoldEntry cfe;
            hr = iterLoop->ConvertToConFoldEntry(cfe);
            WCHAR  szConnectionGuid [c_cchGuidWithTerm];
            INT    cch = StringFromGUID2 (cfe.GetGuidID(), szConnectionGuid, c_cchGuidWithTerm);
            Assert (c_cchGuidWithTerm == cch);
            BOOL   fDuplicateMutex     = FALSE;
            hMutex = CreateMutex(NULL, TRUE, szConnectionGuid);
            if (hMutex)
            {
                fDuplicateMutex = (ERROR_ALREADY_EXISTS == GetLastError());
                ReleaseMutex(hMutex);
                CloseHandle(hMutex);
            }
            else
            {
                hr = E_ACCESSDENIED;
                break;
            }

            if (fDuplicateMutex)
            {
                // if the mutex already exists try to find the connection window
                //
                NcMsgBox(
                    _Module.GetResourceInstance(),
                    NULL,
                    IDS_CONFOLD_ERROR_DELETE_CAPTION,
                    IDS_CONFOLD_ERROR_DELETE_PROPERTYPAGEOPEN,
                    MB_ICONEXCLAMATION);

                hr = cfe.HrGetNetCon(IID_INetConnection, reinterpret_cast<VOID**>(&pNetCon));
                if (FAILED(hr))
                {
                    Assert(FALSE);
                    break;
                }
                else
                {
                    ActivatePropertyDialog(pNetCon);
                    hr = E_ACCESSDENIED;
                    break;
                }
            }

        }

        if (FAILED(hr))
        {
            goto Exit;
        }

        // Bring up the prompt for the delete
        //
        if (apidl.size() > 1)
        {
            WCHAR   wszItemCount[8];

            // Convert the item count to a string
            //
            _itow( apidl.size(), wszItemCount, 10 );

            // Bring up the message box
            //
            iMBResult = NcMsgBox(
                _Module.GetResourceInstance(),
                NULL,
                IDS_CONFOLD_DELETE_CONFIRM_MULTI_CAPTION,
                IDS_CONFOLD_DELETE_CONFIRM_MULTI,
                MB_YESNO | MB_ICONQUESTION,
                wszItemCount);

            if (IDYES == iMBResult)
            {
                for (iterLoop = apidl.begin(); iterLoop != apidl.end(); iterLoop++)
                {
                    CConFoldEntry cfe;
                    hr = iterLoop->ConvertToConFoldEntry(cfe);
                    if (SUCCEEDED(hr))
                    {
                            if ( (NCCF_INCOMING_ONLY & cfe.GetCharacteristics()) &&
                                 (NCM_NONE == cfe.GetNetConMediaType()) )
                            {
                            DWORD dwActiveIncoming;
                            if (SUCCEEDED(g_ccl.HasActiveIncomingConnections(&dwActiveIncoming))
                                && dwActiveIncoming)
                            {
                                if (1 == dwActiveIncoming )
                                {
                                    iMBResult = NcMsgBox(
                                        _Module.GetResourceInstance(),
                                        NULL,
                                        IDS_CONFOLD_DELETE_CONFIRM_MULTI_CAPTION,
                                        IDS_CONFOLD_DELETE_CONFIRM_RASSERVER,
                                        MB_YESNO | MB_ICONQUESTION);
                                }
                                else
                                {
                                    iMBResult = NcMsgBox(
                                        _Module.GetResourceInstance(),
                                        NULL,
                                        IDS_CONFOLD_DELETE_CONFIRM_MULTI_CAPTION,
                                        IDS_CONFOLD_DELETE_CONFIRM_RASSERVER_MULTI,
                                        MB_YESNO | MB_ICONQUESTION,
                                        dwActiveIncoming);
                                }
                            }
                            break;
                        }
                    }
                }
            }
        }
        else if (apidl.size() == 1)
        {
            CONFOLDENTRY  ccfe;

            // Convert the pidl to a confoldentry, and use the name
            // to bring up the confirm message box
            //
            hr = apidl[0].ConvertToConFoldEntry(ccfe);
            if (SUCCEEDED(hr))
            {
                // Don't let them try to delete a wizard
                //
                if (ccfe.GetWizard())
                {
                    goto Exit;
                }
                else
                {
                    // Check to see if this connection is in the process of activating.
                    // If so, then we won't allow the delete.
                    //
                    PCONFOLDPIDL pidlEmpty;
                    hr = HrCheckForActivation(pidlEmpty, ccfe, &fActivating);
                    if (S_OK == hr)
                    {
                        if (!fActivating)
                        {
                            if (FALSE == (ccfe.GetNetConMediaType() == NCM_BRIDGE) &&  // we do allow the bridge to be deleted
                               ((ccfe.GetNetConStatus() == NCS_CONNECTING) ||
                                fIsConnectedStatus(ccfe.GetNetConStatus()) ||
                                (ccfe.GetNetConStatus() == NCS_DISCONNECTING)) )
                            {
                                // You can't delete an active connection
                                //
                                NcMsgBox(
                                     _Module.GetResourceInstance(),
                                     NULL,
                                     IDS_CONFOLD_ERROR_DELETE_CAPTION,
                                     IDS_CONFOLD_ERROR_DELETE_ACTIVE,
                                     MB_ICONEXCLAMATION);

                                goto Exit;
                            }
                            else
                            {
                                if ( (NCCF_INCOMING_ONLY & ccfe.GetCharacteristics()) &&
                                     (NCM_NONE == ccfe.GetNetConMediaType()) )
                                {
                                    DWORD dwActiveIncoming;
                                    if (SUCCEEDED(g_ccl.HasActiveIncomingConnections(&dwActiveIncoming))
                                        && dwActiveIncoming)
                                    {
                                        if (1 == dwActiveIncoming )
                                        {
                                            iMBResult = NcMsgBox(
                                                _Module.GetResourceInstance(),
                                                NULL,
                                                IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                                IDS_CONFOLD_DELETE_CONFIRM_RASSERVER,
                                                MB_YESNO | MB_ICONQUESTION);
                                        }
                                        else
                                        {
                                            iMBResult = NcMsgBox(
                                                _Module.GetResourceInstance(),
                                                NULL,
                                                IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                                IDS_CONFOLD_DELETE_CONFIRM_RASSERVER_MULTI,
                                                MB_YESNO | MB_ICONQUESTION,
                                                dwActiveIncoming);
                                        }
                                    }
                                    else
                                    {
                                        iMBResult = NcMsgBox(
                                            _Module.GetResourceInstance(),
                                            NULL,
                                            IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                            IDS_CONFOLD_DELETE_CONFIRM_SINGLE,
                                            MB_YESNO | MB_ICONQUESTION,
                                            ccfe.GetName());
                                    }
                                }
                                else
                                {
                                    // is it shared?
                                    // if it is warn the user

                                    RASSHARECONN rsc;

                                    hr = ccfe.HrGetNetCon(IID_INetConnection, reinterpret_cast<VOID**>(&pNetCon));

                                    if (SUCCEEDED(hr))
                                    {
                                        hr = HrNetConToSharedConnection(pNetCon, &rsc);

                                        if (SUCCEEDED(hr))
                                        {
                                            BOOL pfShared;

                                            hr = HrRasIsSharedConnection(&rsc, &pfShared);

                                            if ((SUCCEEDED(hr)) && (pfShared == TRUE))
                                            {
                                                // tell the user they are deleting a
                                                // shared connection and get confirmation

                                                iMBResult = NcMsgBox(
                                                    _Module.GetResourceInstance(),
                                                    NULL,
                                                    IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                                    IDS_CONFOLD_DELETE_CONFIRM_SHARED,
                                                    MB_YESNO | MB_ICONQUESTION,
                                                    ccfe.GetName());
                                            }
                                            else
                                            {
                                                // Ask for delete confirmation

                                                iMBResult = NcMsgBox(
                                                    _Module.GetResourceInstance(),
                                                    NULL,
                                                    IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                                    IDS_CONFOLD_DELETE_CONFIRM_SINGLE,
                                                    MB_YESNO | MB_ICONQUESTION,
                                                    ccfe.GetName());
                                            }
                                        }
                                        else
                                        {
                                            // Ask for delete confirmation

                                            iMBResult = NcMsgBox(
                                                _Module.GetResourceInstance(),
                                                NULL,
                                                IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION,
                                                IDS_CONFOLD_DELETE_CONFIRM_SINGLE,
                                                MB_YESNO | MB_ICONQUESTION,
                                                ccfe.GetName());
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // Bring up the MB about "Hey, you can't delete while
                            // the connection is activating."
                            //
                            iMBResult = NcMsgBox(
                                _Module.GetResourceInstance(),
                                NULL,
                                IDS_CONFOLD_ERROR_DELETE_CAPTION,
                                IDS_CONFOLD_ERROR_DELETE_ACTIVE,
                                MB_ICONEXCLAMATION);

                            goto Exit;
                        }
                    }
                    else
                    {
                        // If the connection wasn't found, then we should just drop out of here
                        // because we sure can't delete it.
                        //
                        if (S_FALSE == hr)
                        {
                            goto Exit;
                        }
                    }

                }
            }
            else
            {
                AssertSz(FALSE, "Couldn't get ConFoldEntry from pidl in HrOnCommandDelete");
                goto Exit;
            }
        }
        else
        {
            // No connections were specified. Take a hike.
            //
            goto Exit;
        }

        // If the user said "Yes" to the prompt
        //
        if (iMBResult == IDYES)
        {
            CConnectionFolder * pcf         = static_cast<CConnectionFolder *>(psf);
            PCONFOLDPIDLFOLDER  pidlFolder;
            if (pcf)
            {
                pidlFolder = pcf->PidlGetFolderRoot();
            }

            BOOL                fShowActivationWarning = FALSE;
            BOOL                fShowNotDeletableWarning = FALSE;

            for (iterLoop = apidl.begin(); iterLoop != apidl.end(); iterLoop++)
            {
                CONFOLDENTRY  ccfe;

                hr = iterLoop->ConvertToConFoldEntry(ccfe);
                if (SUCCEEDED(hr))
                {
                    // If this is a LAN connection the user doesn't have rights
                    //
                    if ((NCM_LAN == ccfe.GetNetConMediaType()) || (ccfe.GetWizard()))
                    {
                        fShowNotDeletableWarning = TRUE;
                        continue;
                    }

                    // If this is a RAS connection and the user doesn't have rights
                    // then skip
                    //
                    if (IsMediaRASType(ccfe.GetNetConMediaType()))
                    {
                        if ((!FHasPermission(NCPERM_DeleteConnection)) ||
                            ((ccfe.GetCharacteristics() & NCCF_ALL_USERS) &&
                             !FHasPermission(NCPERM_DeleteAllUserConnection)))
                        {
                            fShowNotDeletableWarning = TRUE;
                            continue;
                        }
                    }

                    PCONFOLDPIDL pidlEmpty;
                    hr = HrCheckForActivation(pidlEmpty, ccfe, &fActivating);
                    if (S_OK == hr)
                    {
                        // Only allow deletion if this connection is inactive and
                        // it allows removal.
                        //
                        if (fActivating || ((FALSE == (ccfe.GetNetConMediaType() == NCM_BRIDGE))) &&
                            ((ccfe.GetNetConStatus() == NCS_CONNECTING) ||
                            fIsConnectedStatus(ccfe.GetNetConStatus()) ||
                            (ccfe.GetNetConStatus() == NCS_DISCONNECTING)) )
                        {
                            fShowActivationWarning = TRUE;
                        }
                        else if (ccfe.GetCharacteristics() & NCCF_ALLOW_REMOVAL)
                        {
                            hr = HrNetConFromPidl(*iterLoop, &pNetCon);
                            if (SUCCEEDED(hr))
                            {
                                if ( NCM_BRIDGE == ccfe.GetNetConMediaType() )
                                {
                                    //
                                    // Special delete case Removing the Network bridge take so long that we display a status dialog
                                    // and prevent the user from changing anything will we process
                                    //
                                    hr = HrOnCommandBridgeRemoveConnections(
                                        apidl,
                                        hwndOwner,
                                        psf,
                                        0    // Remove the Network bridge
                                        );
                                }
                                else
                                {
                                    hr = pNetCon->Delete();
                                }

                                if (SUCCEEDED(hr) && pcf)
                                {
                                    hr = HrDeleteFromCclAndNotifyShell(pidlFolder, *iterLoop, ccfe);
                                }
                                else if(E_ACCESSDENIED == hr && NCM_BRIDGE == ccfe.GetNetConMediaType())
                                {
                                    // can't delete the bridge while the netcfg lock is held
                                    NcMsgBox(
                                        _Module.GetResourceInstance(),
                                        NULL, IDS_CONFOLD_ERROR_DELETE_CAPTION, IDS_CONFOLD_ERROR_DELETE_BRIDGE_ACCESS, MB_ICONEXCLAMATION);
                                }


                                ReleaseObj(pNetCon);


                            }
                        }
                        else
                        {
                            // The selected item is not deletable
                            //
                            fShowNotDeletableWarning = TRUE;
                        }
                    }
                }
            }

            if (fShowNotDeletableWarning)
            {
                // You can't delete an item that doesn't support it
                //
                NcMsgBox(
                     _Module.GetResourceInstance(),
                     NULL,
                     IDS_CONFOLD_ERROR_DELETE_CAPTION,
                     (1 == apidl.size()) ?
                         IDS_CONFOLD_ERROR_DELETE_NOSUPPORT :
                         IDS_CONFOLD_ERROR_DELETE_NOSUPPORT_MULTI,
                     MB_ICONEXCLAMATION);
            }
            else if (fShowActivationWarning)
            {
                // You can't delete an active connection. Note, if more
                // than one are being deleted, then we put up the warning
                // that says 'one or more are being ignored'.
                //
                NcMsgBox(
                     _Module.GetResourceInstance(),
                     NULL,
                     IDS_CONFOLD_ERROR_DELETE_CAPTION,
                     (1 == apidl.size()) ?
                         IDS_CONFOLD_ERROR_DELETE_ACTIVE :
                         IDS_CONFOLD_ERROR_DELETE_ACTIVE_MULTI,
                     MB_ICONEXCLAMATION);
            }
        }
Exit:
    NETCFG_CATCH(hr)

    TraceError("HrOnCommandDelete", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandOptionalComponents
//
//  Purpose:    Command handler for the CMIDM_CONMENU_OPTIONALCOMPONENTS command.
//              Bring up the network optional components UI.
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//      psf       [in]  Our folder
//
//  Returns:
//
//  Author:     scottbri   29 Oct 1998
//
//  Notes:
//
HRESULT HrOnCommandOptionalComponents(IN const PCONFOLDPIDLVEC&   apidl,
                HWND                    hwndOwner,
                LPSHELLFOLDER           psf)
{
    return HrLaunchNetworkOptionalComponents();
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandNetworkId
//
//  Purpose:    Command handler for the CMIDM_CONMENU_NETORK_ID command.
//              Bring up the network ID UI
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
HRESULT HrOnCommandNetworkId(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    TraceFileFunc(ttidShellFolder);

    HRESULT   hr          = S_OK;
    WCHAR     szPath[MAX_PATH];

    hr = SHGetFolderPath(
                hwndOwner,
                CSIDL_SYSTEM,
                NULL,
                SHGFP_TYPE_CURRENT,
                szPath);

    if (SUCCEEDED(hr))
    {
        HINSTANCE hInst = ::ShellExecute(hwndOwner, NULL, c_szRunDll32, c_szNetworkIdCmdLine, szPath, SW_SHOW );
        if (hInst <= reinterpret_cast<HINSTANCE>(32))
        {
            hr = HRESULT_FROM_WIN32(static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(hInst)));
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandNetworkId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDialupPrefs
//
//  Purpose:    Command handler for the CMIDM_CONMENU_DIALUP_PREFS command.
//              Bring up the dialup prefs dialog
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
HRESULT HrOnCommandDialupPrefs(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr      = S_OK;
    DWORD   dwErr   = 0;

    dwErr = RasUserPrefsDlg(hwndOwner);
    hr = HRESULT_FROM_WIN32 (dwErr);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDialupPrefs");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandOperatorAssist
//
//  Purpose:    Command handler for the CMIDM_CONMENU_OPERATOR_ASSIST command.
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   26 Feb 1998
//
//  Notes:
//
HRESULT HrOnCommandOperatorAssist(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr      = S_OK;
    DWORD   dwErr   = 0;

    // Swap the flag
    //
    g_fOperatorAssistEnabled = !g_fOperatorAssistEnabled;

    // Set the state within RasDlg itself
    //
    dwErr = RasUserEnableManualDial(hwndOwner, FALSE, g_fOperatorAssistEnabled);
    hr = HRESULT_FROM_WIN32 (dwErr);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDialupPrefs");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandCreateShortcut
//
//  Purpose:    Command handler for the CMIDM_CREATE_SHORTCUT command.
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jeffspr   13 Mar 1998
//
//  Notes:
//
HRESULT HrOnCommandCreateShortcut(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT         hr              = S_OK;

    hr = HrCreateShortcutWithPath(  apidl,
                                    hwndOwner,
                                    psf,
                                    NULL);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandCreateShortcut");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandSetDefault
//
//  Purpose:    Command handler for the CMIDM_SET_DEFAULT command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     deonb   27 Nov 2000
//
//  Notes:  We only act on a single entry in this function
//
HRESULT HrOnCommandSetDefault(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT            hr          = S_OK;
    CONFOLDENTRY       ccfe;

    if (!apidl.empty())
    {
        hr = apidl[0].ConvertToConFoldEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            INetDefaultConnection *pNetDefaultConnection = NULL;

            // Get the INetDefaultConnection object from the persist data
            //
            hr = ccfe.HrGetNetCon(IID_INetDefaultConnection, reinterpret_cast<VOID**>(&pNetDefaultConnection));
            if (SUCCEEDED(hr))
            {
                hr = pNetDefaultConnection->SetDefault(TRUE);
                ReleaseObj(pNetDefaultConnection);
                hr = S_OK;
            }
            else
            {
                if (E_NOINTERFACE == hr)
                {
                    AssertSz(FALSE, "BUG: This connection type does not support INetDefaultConnection. Remove it from the menu");
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandSetDefault");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandUnsetDefault
//
//  Purpose:    Command handler for the CMIDM_UNSET_DEFAULT command
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      cidl      [in]  Size of the array
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     deonb   27 Nov 2000
//
//  Notes:  We only act on a single entry in this function
//
HRESULT HrOnCommandUnsetDefault(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT            hr          = S_OK;
    CONFOLDENTRY       ccfe;

    if (!apidl.empty())
    {
        hr = apidl[0].ConvertToConFoldEntry(ccfe);
        if (SUCCEEDED(hr))
        {
            INetDefaultConnection *pNetDefaultConnection = NULL;

            // Get the INetDefaultConnection object from the persist data
            //
            hr = ccfe.HrGetNetCon(IID_INetDefaultConnection, reinterpret_cast<VOID**>(&pNetDefaultConnection));
            if (SUCCEEDED(hr))
            {
                hr = pNetDefaultConnection->SetDefault(FALSE);
                ReleaseObj(pNetDefaultConnection);
                hr = S_OK;
            }
            else
            {
                if (E_NOINTERFACE == hr)
                {
                    AssertSz(FALSE, "BUG: This connection type does not support INetDefaultConnection. Remove it from the menu");
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandUnsetDefault");
    return hr;
}

HRESULT HrCreateShortcutWithPath(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf,
    PCWSTR                  pszDir)
{
    HRESULT         hr              = S_OK;
    LPDATAOBJECT    pdtobj          = NULL;
    LPCITEMIDLIST*  apidlInternal   = NULL;
    ULONG           cidlInternal    = 0;
    PCONFOLDPIDLVEC::const_iterator iterLoop;

    if (!apidl.empty())
    {
        apidlInternal = new LPCITEMIDLIST[apidl.size()];
        if (apidlInternal)
        {
            for (iterLoop = apidl.begin(); iterLoop != apidl.end(); iterLoop++)
            {
                const PCONFOLDPIDL& pcfp = *iterLoop;

                if (!(pcfp->dwCharacteristics & NCCF_INCOMING_ONLY))
                {
                    apidlInternal[cidlInternal++] = iterLoop->GetItemIdList();
                }
            }

            hr = psf->GetUIObjectOf(
                hwndOwner,
                cidlInternal,
                apidlInternal,
                IID_IDataObject,
                NULL,
                (LPVOID *) &pdtobj);
            if (SUCCEEDED(hr))
            {
                SHCreateLinks(hwndOwner, pszDir, pdtobj,
                              SHCL_USEDESKTOP | SHCL_USETEMPLATE | SHCL_CONFIRM,
                              NULL);
                ReleaseObj(pdtobj);
            }

            delete apidlInternal;
        }
    }

    TraceError("HrCreateShortcutWithPath", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RefreshFolderItem
//
//  Purpose:    Refresh an item within a connections folder. Mostly, this will
//              be called after a connect or disconnect operation.
//
//  Arguments:
//      pidlFolder [in]     PIDL for the connections folder
//      pidlItemOld[in]     PIDL for the item that's changed.
//      pidlItemNew[in]     PIDL for the item that it's changing to.
//      fRestart   [in]     If this is called during system startup
//
//  Returns:
//
//  Author:     jeffspr   13 Jun 1998
//
//  Notes:
//
VOID RefreshFolderItem(const PCONFOLDPIDLFOLDER& pidlFolder, const PCONFOLDPIDL& pidlItemOld, const PCONFOLDPIDL& pidlItemNew, BOOL fRestart)
{
    TraceTag(ttidShellFolder, "RefreshFolderItem");

    NETCFG_TRY

        HRESULT         hr              = S_OK;
        INT             iCachedImage    = 0;
        PCONFOLDPIDLFOLDER pidlFolderCopy;

        // If a folder pidl wasn't passed in, try to get one
        //
        if (pidlFolder.empty())
        {
            hr = HrGetConnectionsFolderPidl(pidlFolderCopy);
        }
        else
        {
            pidlFolderCopy = pidlFolder;
        }

        // If we now have a pidl, send the GenerateEvent to update the item
        //
        if (SUCCEEDED(hr))
        {
            GenerateEvent(SHCNE_UPDATEITEM, pidlFolderCopy, pidlItemNew, NULL);
        }

        // If we have a old item pidl, try to update its icon (useful for
        // shortcuts as well as folder items)
        //
        if (!pidlItemOld.empty())
        {
            const PCONFOLDPIDL& pcfp = pidlItemOld;
            if (!pcfp.empty())
            {
                CConFoldEntry cfe;
                hr = pcfp.ConvertToConFoldEntry(cfe);
                if (SUCCEEDED(hr))
                {
                    g_pNetConfigIcons->HrUpdateSystemImageListForPIDL(cfe);
                }

                if (fRestart)
                {
                    TraceTag(ttidIcons, "Refreshing Icon Shortcuts for startup");

                    // RAS connection state will be changed between reboots,
                    // we need to make sure icons for previously connected
                    // or disconnected ras connections are also updated

                    // If it's a ras connection,
                    BOOL fInbound = !!(pidlItemOld->dwCharacteristics & NCCF_INCOMING_ONLY);

                    if ((IsMediaRASType(pidlItemOld->ncm)) && !fInbound)
                    {
                        PCONFOLDPIDL pcfpTemp = pidlItemOld;

                        if ((pcfpTemp->ncs == NCS_DISCONNECTED) ||
                            (pcfpTemp->ncs == NCS_CONNECTING))
                        {
                            // get the connected icon
                            pcfpTemp->ncs = NCS_CONNECTED;
                        }
                        else
                        {
                            // get the disconnected icon
                            pcfpTemp->ncs = NCS_DISCONNECTED;
                        }

                        cfe.clear();
                        hr = pcfpTemp.ConvertToConFoldEntry(cfe);
                        if (SUCCEEDED(hr))
                        {
                            g_pNetConfigIcons->HrUpdateSystemImageListForPIDL(cfe);
                        }
                    }
                }
            }
        }

    NETCFG_CATCH_NOHR
}





//
//
//
HRESULT
HrOnCommandCreateBridge(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf
    )
{
    HRESULT hResult;
    IHNetCfgMgr* pHomeNetConfigManager;

    CWaitCursor wc;     // display wait cursor

    hResult = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomeNetConfigManager); // REVIEW combine this with QI?
    if(SUCCEEDED(hResult))
    {
        IHNetBridgeSettings* pNetBridgeSettings;
        hResult = pHomeNetConfigManager->QueryInterface(IID_IHNetBridgeSettings, reinterpret_cast<void**>(&pNetBridgeSettings));
        if(SUCCEEDED(hResult))
        {
            IHNetBridge* pNetBridge;

            IEnumHNetBridges* pNetBridgeEnum;
            hResult = pNetBridgeSettings->EnumBridges(&pNetBridgeEnum);
            if(SUCCEEDED(hResult))
            {
                hResult = pNetBridgeEnum->Next(1, &pNetBridge, NULL);

                if(S_FALSE == hResult) // no existing bridges, make a new one
                {
                    hResult = pNetBridgeSettings->CreateBridge(&pNetBridge);
                }

                if(S_OK == hResult) // can't use SUCCEEDED because someone returns S_FALSE
                {
                    Assert(pNetBridge); // we better have gotten one from somewhere

                    // Add any selected connections
                    for ( PCONFOLDPIDLVEC::const_iterator i = apidl.begin(); (i != apidl.end()) && SUCCEEDED(hResult); i++ )
                    {
                        const PCONFOLDPIDL& pcfp = *i;

                        if ( pcfp.empty() )
                            continue;

                        if ( NCM_LAN != pcfp->ncm  )
                            continue;

                        if ( (NCCF_BRIDGED|NCCF_FIREWALLED|NCCF_SHARED) & pcfp->dwCharacteristics )
                            continue;

                        //
                        // Ok we now have a LAN adapter the is valid to bind to the bridge
                        //
                        INetConnection* pNetConnection;
                        hResult = HrNetConFromPidl(*i, &pNetConnection);
                        if(SUCCEEDED(hResult))
                        {
                            IHNetConnection* pHomeNetConnection;
                            hResult = pHomeNetConfigManager->GetIHNetConnectionForINetConnection(pNetConnection, &pHomeNetConnection);
                            if(SUCCEEDED(hResult))
                            {
                                IHNetBridgedConnection* pBridgedConnection;
                                hResult = pNetBridge->AddMember(pHomeNetConnection, &pBridgedConnection);
                                if(SUCCEEDED(hResult))
                                {
                                    ReleaseObj(pBridgedConnection);
                                }

                                ReleaseObj(pHomeNetConnection);
                            }
                            ReleaseObj(pNetConnection);
                        }
                        // no cleanup needed
                    }

                    ReleaseObj(pNetBridge);
                }
                ReleaseObj(pNetBridgeEnum);
            }
            ReleaseObj(pNetBridgeSettings);
        }
        ReleaseObj(pHomeNetConfigManager);
    }

    SendMessage(hwndOwner, WM_COMMAND, IDCANCEL, 0); // destroy the status dialog

    // Show an error dialog on failure
    if( FAILED(hResult) )
    {
        UINT        ids;

        if( NETCFG_E_NO_WRITE_LOCK == hResult )
        {
            ids = IDS_CONFOLD_BRIDGE_NOLOCK;
        }
        else
        {
            ids = IDS_CONFOLD_BRIDGE_UNEXPECTED;
        }

        NcMsgBox( _Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION, ids, MB_ICONEXCLAMATION | MB_OK);
    }

    return hResult;
}


//
//
//
INT_PTR CALLBACK
CreateBridgeStatusDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR nResult = FALSE;
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {

            LPCWSTR pResourceStr = SzLoadIds(IDS_CONFOLD_OBJECT_TYPE_BRIDGE);
            SetWindowText(hwndDlg, pResourceStr);

            pResourceStr = SzLoadIds(IDS_STATUS_BRIDGE_CREATION);
            SetDlgItemText(hwndDlg, IDC_TXT_STATUS, pResourceStr);


            CCommandHandlerParams* pCreateBridgeParams = reinterpret_cast<CCommandHandlerParams*>(lParam);
            HrCommandHandlerThread(HrOnCommandCreateBridge, *(pCreateBridgeParams->apidl), hwndDlg, pCreateBridgeParams->psf);
            // HrOnCommandCreateBridge will send a message to kill this dialog

            nResult = TRUE;
        }
        break;

    case WM_COMMAND:
        if(IDCANCEL == LOWORD(wParam))
        {
            EndDialog(hwndDlg, 0);
            nResult = TRUE;
        }
        break;

    }
    return nResult;
}



//
//
//
HRESULT
HrOnCommandDeleteBridge(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf
    )
{
    HRESULT hr = S_FALSE;

    PCONFOLDPIDLVEC::const_iterator iterator;

    for ( iterator = apidl.begin(); iterator != apidl.end(); iterator++ )
    {
        CONFOLDENTRY  ccfe;

        hr = iterator->ConvertToConFoldEntry(ccfe);

        if ( SUCCEEDED(hr) )
        {
            if ( NCM_BRIDGE == ccfe.GetNetConMediaType() )
            {
                //
                // Stop at the first select BRIDGE item
                // The delete of the bridge is part of a bigger FOR LOOP see HrOnCommandDelete()
                //
                INetConnection* pNetConnection;
                hr = HrNetConFromPidl(*iterator, &pNetConnection);

                if ( SUCCEEDED(hr) )
                {
                    hr = pNetConnection->Delete();
                    ReleaseObj(pNetConnection);
                }

                break;
            }
        }
    }

    SendMessage(hwndOwner, WM_COMMAND, IDCANCEL, hr); // destroy the status dialog

    // Show an error dialog on failure
    if( FAILED(hr) )
    {
        UINT        ids;

        if( NETCFG_E_NO_WRITE_LOCK == hr )
        {
            ids = IDS_CONFOLD_BRIDGE_NOLOCK;
        }
        else
        {
            ids = IDS_CONFOLD_BRIDGE_UNEXPECTED;
        }

        NcMsgBox( _Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION, ids, MB_ICONEXCLAMATION | MB_OK);
    }

    return S_OK;
}



//
//
//
HRESULT
HrOnCommandDeleteBridgeConnections(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf
    )
{

    CWaitCursor wc;     // display wait cursor

    IHNetCfgMgr* pHomeNetConfigManager;
    HRESULT hResult = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomeNetConfigManager); // REVIEW combine this with QI?


    if ( SUCCEEDED(hResult) )
    {

        //
        // Remove any selected connections
        //
        for ( PCONFOLDPIDLVEC::const_iterator i = apidl.begin(); i != apidl.end() && SUCCEEDED(hResult); i++ )
        {
            INetConnection* pNetConnection;
            hResult = HrNetConFromPidl(*i, &pNetConnection);
            if(SUCCEEDED(hResult))
            {
                IHNetConnection* pHomeNetConnection;
                hResult = pHomeNetConfigManager->GetIHNetConnectionForINetConnection(pNetConnection, &pHomeNetConnection);
                if(SUCCEEDED(hResult))
                {
                    IHNetBridgedConnection* pBridgedConnection;
                    hResult = pHomeNetConnection->GetControlInterface(IID_IHNetBridgedConnection, reinterpret_cast<void**>(&pBridgedConnection));
                    if ( SUCCEEDED(hResult) )
                    {
                        hResult = pBridgedConnection->RemoveFromBridge();
                        ReleaseObj(pBridgedConnection);
                    }

                    ReleaseObj(pHomeNetConnection);
                }
                ReleaseObj(pNetConnection);
            }
            // no cleanup needed
        }

        ReleaseObj(pHomeNetConfigManager);
    }

    SendMessage(hwndOwner, WM_COMMAND, IDCANCEL, hResult); // destroy the status dialog

    // Show an error dialog on failure
    if( FAILED(hResult) )
    {
        UINT        ids;

        if( NETCFG_E_NO_WRITE_LOCK == hResult )
        {
            ids = IDS_CONFOLD_BRIDGE_NOLOCK;
        }
        else
        {
            ids = IDS_CONFOLD_BRIDGE_UNEXPECTED;
        }

        NcMsgBox( _Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION, ids, MB_ICONEXCLAMATION | MB_OK);
    }

    return S_OK;
}

//
//
//
INT_PTR CALLBACK
DeleteBridgeStatusDialogProc(
    HWND    hwndDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
    )
{
    INT_PTR nResult = FALSE;
    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            LPCWSTR pResourceStr = SzLoadIds(IDS_CONFOLD_OBJECT_TYPE_BRIDGE);
            SetWindowText(hwndDlg, pResourceStr);


            CCommandHandlerParams* pDeleteBridgeParams = reinterpret_cast<CCommandHandlerParams*>(lParam);

            if ( pDeleteBridgeParams->nAdditionalParam == CMIDM_REMOVE_FROM_BRIDGE )
            {
                //
                // Only remove the currently selected connections from the Network bridge
                //
                pResourceStr = SzLoadIds(IDS_STATUS_BRIDGE_REMOVE_MEMBER);
                SetDlgItemText(hwndDlg, IDC_TXT_STATUS, pResourceStr);

                HrCommandHandlerThread(HrOnCommandDeleteBridgeConnections, *(pDeleteBridgeParams->apidl), hwndDlg, pDeleteBridgeParams->psf);
            }
            else
            {
                //
                // Full delete of the network bridge
                //
                pResourceStr = SzLoadIds(IDS_STATUS_BRIDGE_DELETING);
                SetDlgItemText(hwndDlg, IDC_TXT_STATUS, pResourceStr);

                HrCommandHandlerThread(HrOnCommandDeleteBridge, *(pDeleteBridgeParams->apidl), hwndDlg, pDeleteBridgeParams->psf);
            }

            // After the delete a HrOnCommandDeleteBridge will send a SendMessage(hwndOwner, WM_COMMAND, IDCANCEL, 0); // destroy the status dialog

            nResult = TRUE;
        }
        break;

    case WM_COMMAND:
        if(IDCANCEL == LOWORD(wParam))
        {
            EndDialog(hwndDlg, lParam);
            nResult = TRUE;
        }
        break;

    }
    return nResult;
}



//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandBridgeAddConnections
//
//  Purpose:    Command handler for the CMIDM_CREATE_BRIDGE, CMDIDM_CONMENU_CREATE_BRIDGE, CMIDM_ADD_TO_BRIDGE.
//
//  Arguments:
//      apidl     [in]  PIDL array (item 0 is our item to work on)
//      psf       [in]  SHELLFOLDER
//      hwndOwner [in]  Owner hwnd
//
//  Returns:
//
//  Author:     jpdup   6 March 2000
//
//  Notes:
//
HRESULT
HrOnCommandBridgeAddConnections(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf
    )
{
    CCommandHandlerParams CreateBridgeParams;

    CreateBridgeParams.apidl        = &apidl;
    CreateBridgeParams.hwndOwner    = hwndOwner;
    CreateBridgeParams.psf          = psf;

    HRESULT hr = DialogBoxParam(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDD_STATUS),
        hwndOwner,
        CreateBridgeStatusDialogProc,
        reinterpret_cast<LPARAM>(&CreateBridgeParams)
        );

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandBridgeAddConnections");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandBridgeRemoveConnections
//
//  Purpose:    Command handler for the CMIDM_REMOVE_FROM_BRIDGE and the DELETE command when done on the NetworkBridge object
//
//  Arguments:
//      apidl                   [in]  PIDL array (item 0 is our item to work on)
//      hwndOwner               [in]  Owner hwnd
//      psf                     [in]  SHELLFOLDER
//      bDeleteTheNetworkBridge [in]  true is the NetworkBridge needs to be totaly remove, false if only the currently select item found in apild needs to be remove
//
//  Returns:
//
//  Author:     jpdup   6 March 2000
//
//  Notes:
//
HRESULT
HrOnCommandBridgeRemoveConnections(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf,
    UINT_PTR                    nDeleteTheNetworkBridgeMode
    )
{
    CCommandHandlerParams DeleteBridgeParams;

    DeleteBridgeParams.apidl            = &apidl;
    DeleteBridgeParams.hwndOwner        = hwndOwner;
    DeleteBridgeParams.psf              = psf;
    DeleteBridgeParams.nAdditionalParam = nDeleteTheNetworkBridgeMode;

    HRESULT hr = DialogBoxParam(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDD_STATUS),
        hwndOwner,
        DeleteBridgeStatusDialogProc,
        reinterpret_cast<LPARAM>(&DeleteBridgeParams)
        );

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandBridgeRemoveConnections");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"
#include "netconp.h"

class ATL_NO_VTABLE CConnectionNotifySink :
    public CComObjectRootEx <CComObjectThreadModel>,
    public INetConnectionNotifySink
{
private:
    PCONFOLDPIDLFOLDER    m_pidlFolder;
    HRESULT HrUpdateIncomingConnection();

public:
    BEGIN_COM_MAP(CConnectionNotifySink)
        COM_INTERFACE_ENTRY(INetConnectionNotifySink)
    END_COM_MAP()

    CConnectionNotifySink() {};
    ~CConnectionNotifySink();

    // INetConnectionNotifySink
    STDMETHOD(ConnectionAdded) (
        const NETCON_PROPERTIES_EX*    pPropsEx);

    STDMETHOD(ConnectionBandWidthChange) (
        const GUID* pguidId);

    STDMETHOD(ConnectionDeleted) (
        const GUID* pguidId);

    STDMETHOD(ConnectionModified) (
        const NETCON_PROPERTIES_EX* pPropsEx);

    STDMETHOD(ConnectionRenamed) (
        const GUID* pguidId,
        PCWSTR     pszwNewName);

    STDMETHOD(ConnectionStatusChange) (
        const GUID*     pguidId,
        NETCON_STATUS   Status);

    STDMETHOD(RefreshAll) ();
    
    STDMETHOD(ConnectionAddressChange) (
        const GUID* pguidId );

    STDMETHOD(ShowBalloon) (
        IN const GUID* pguidId, 
        IN const BSTR  szCookie, 
        IN const BSTR  szBalloonText); 

    STDMETHOD(DisableEvents) (
        IN const BOOL  fDisable,
        IN const ULONG ulDisableTimeout);

public:
    static HRESULT CreateInstance (
        REFIID  riid,
        VOID**  ppv);
};

// Helper functions for external modules
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\notify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "foldinc.h"
#include "nccom.h"
#include "notify.h"
#include "shutil.h"
#include "smcent.h"
#include "ctrayui.h"
#include "traymsgs.h"
#include "wzcdlg.h"

extern HWND g_hwndTray;

enum EVENT_LEVELS
{
    EVT_LVL_DISABLE_ALL    = 0,
    EVT_LVL_ENABLE_PRIVATE = 1,
    EVT_LVL_ENABLE_ALL     = 2
};

DWORD g_dwCurrentEventLevel = EVT_LVL_ENABLE_ALL;

//static
HRESULT
CConnectionNotifySink::CreateInstance (
    REFIID  riid,
    VOID**  ppv)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT hr = E_OUTOFMEMORY;

    // Initialize the output parameter.
    //
    *ppv = NULL;

    CConnectionNotifySink* pObj;
    pObj = new CComObject <CConnectionNotifySink>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            // Call the PidlInitialize function to allow the enumeration
            // object to copy the list.
            //
            hr = HrGetConnectionsFolderPidl(pObj->m_pidlFolder);

            if (SUCCEEDED(hr))
            {
                hr = pObj->QueryInterface (riid, ppv);
            }
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr), "CConnectionNotifySink::CreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConnectionNotifySink::~CConnectionNotifySink
//
//  Purpose:    Clean up the sink object, deleting the folder pidl and any
//              alloc'd junk we might add in the future.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     jeffspr   26 Aug 1998
//
//  Notes:
//
CConnectionNotifySink::~CConnectionNotifySink()
{
    TraceFileFunc(ttidNotifySink);

    if (FIsDebugFlagSet (dfidBreakOnNotifySinkRelease))
    {
        AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
            "\"BreakOnNotifySinkRelease\" has been set. Set your breakpoints now.");
    }    
    
    TraceTag(ttidNotifySink, "Connection notify sink destroyed");
} 

HRESULT CConnectionNotifySink::HrUpdateIncomingConnection()
{
    HRESULT hr = S_OK;

    ConnListEntry cle;
    hr = g_ccl.HrFindRasServerConnection(cle);
    if (S_OK == hr)
    {
        hr = HrOnNotifyUpdateConnection(
            m_pidlFolder,
            &(cle.ccfe.GetGuidID()),
            cle.ccfe.GetNetConMediaType(),
            cle.ccfe.GetNetConSubMediaType(),
            cle.ccfe.GetNetConStatus(),
            cle.ccfe.GetCharacteristics(),
            cle.ccfe.GetName(),
            cle.ccfe.GetDeviceName(),
            cle.ccfe.GetPhoneOrHostAddress()
            );
    }

    return hr;
}

HRESULT
CConnectionNotifySink::ConnectionAdded (
    const NETCON_PROPERTIES_EX*    pPropsEx)
{
    TraceFileFunc(ttidNotifySink);

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pPropsEx->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionAdded - %S %S [%s:%s:%s:%s]", 
        szGuidString, pPropsEx->bstrName, DbgNcm(pPropsEx->ncMediaType), DbgNcsm(pPropsEx->ncSubMediaType), DbgNcs(pPropsEx->ncStatus), DbgNccf(pPropsEx->dwCharacter) );
#endif
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    HRESULT         hr      = S_OK;     // Only used for code paths. We don't return this.
    HRESULT         hrFind  = S_OK;     // Only for finding the connection.
    PCONFOLDPIDL    pidlNew;

    ConnListEntry cleDontCare;
    hrFind = g_ccl.HrFindConnectionByGuid(&(pPropsEx->guidId), cleDontCare);
    if (S_OK == hrFind)
    {
        // We already know about this connection. Don't bother added it.
        TraceTag(ttidShellFolder, "Ignoring known connection on ConnectionAdded notify");
    }
    else
    {
        // Create the entry in the connection list and get the returned pidl
        //
        hr = HrCreateConFoldPidl(
            *pPropsEx,
            pidlNew);
        if (SUCCEEDED(hr) && (!pidlNew.empty()))
        {
            CONFOLDENTRY  cfe;

            Assert(!m_pidlFolder.empty());

            // Convert to the confoldentry
            //
            hr = pidlNew.ConvertToConFoldEntry(cfe);
            if (SUCCEEDED(hr))
            {
                // Insert the connection in the connection list
                //
                hr = g_ccl.HrInsert(cfe);
                if (SUCCEEDED(hr))
                {
                    // Notify the shell that we have a new object
                    //
                    PCONFOLDPIDL pidlShellNotify;
                    hr = cfe.ConvertToPidl(pidlShellNotify);
                    if (SUCCEEDED(hr))
                    {
                        GenerateEvent(SHCNE_CREATE, m_pidlFolder, pidlShellNotify, NULL);
                    }
                }

                // Don't delete the cfe here because the connection list now owns it.
            }
        }
    }

    if (SUCCEEDED(hr) &&
        (NCM_NONE != pPropsEx->ncMediaType) &&
        (pPropsEx->dwCharacter & NCCF_INCOMING_ONLY) )
    {
        hr = HrUpdateIncomingConnection();
    }

    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionBandWidthChange (
    const GUID* pguidId)
{
    TraceFileFunc(ttidNotifySink);
#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(*pguidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionBandWidthChange - %S", szGuidString);
#endif
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    HRESULT                 hr      = S_OK;
    CNetStatisticsCentral * pnsc    = NULL;

    hr = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
    if (SUCCEEDED(hr))
    {
        pnsc->UpdateRasLinkList(pguidId);
        ReleaseObj(pnsc);
    }

    return S_OK;
}


HRESULT
CConnectionNotifySink::ConnectionDeleted (
    const GUID* pguidId)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT         hr          = S_OK;
    HRESULT         hrFind      = S_OK;
    ConnListEntry   cle;
    PCONFOLDPIDL    pidlFind;
    BOOL            fFlushPosts = FALSE;

    Assert(pguidId);
    Assert(!m_pidlFolder.empty());

    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "CConnectionNotifySink::ConnectionDeleted event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Find the connection using the GUID.
    //
    hrFind = g_ccl.HrFindConnectionByGuid(pguidId, cle);
    if (S_OK == hrFind)
    {
#ifdef DBG
        OLECHAR szGuidString[MAX_GUID_STRING_LEN];
        StringFromGUID2(cle.ccfe.GetGuidID(), szGuidString, MAX_GUID_STRING_LEN);
        TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionDeleted - %S %S [%s:%s:%s:%s]", szGuidString, cle.ccfe.GetName(), 
            DbgNcm(cle.ccfe.GetNetConMediaType()), DbgNcsm(cle.ccfe.GetNetConSubMediaType()), DbgNcs(cle.ccfe.GetNetConStatus()), DbgNccf(cle.ccfe.GetCharacteristics()));
#endif
        // Very important to release the lock before doing any thing which
        // calls back into the shell.  (e.g. GenerateEvent)
        
        const CONFOLDENTRY &ccfe = cle.ccfe;

        // Get the pidl for the connection so we can use it to notify
        // the shell further below.
        //
        ccfe.ConvertToPidl(pidlFind);

        // Remove this connection from the global list while we
        // have the lock held.
        //
        hr = g_ccl.HrRemove(cle.ccfe, &fFlushPosts);
    }
    else
    {
        TraceTag(ttidShellFolder, "Notify: Delete <item not found in cache>. hr = 0x%08x", hr);
    }


    // If we need to flush the posts after making tray icon changes, do so
    //
    if (g_hwndTray && fFlushPosts)
    {
        FlushTrayPosts(g_hwndTray);
    }

    if (SUCCEEDED(hr) && (!pidlFind.empty()))
    {
        GenerateEvent(SHCNE_DELETE, m_pidlFolder, pidlFind, NULL);
    }

    if (SUCCEEDED(hr))
    {
        hr = HrUpdateIncomingConnection();
    }

    // Only return S_OK from here.
    //
    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionModified (
    const NETCON_PROPERTIES_EX* pPropsEx)
{
    TraceFileFunc(ttidNotifySink);

    Assert(pPropsEx);
    Assert(!m_pidlFolder.empty());

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pPropsEx->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionModified - %S %S [%s:%s:%s:%s]", szGuidString, pPropsEx->bstrName, 
        DbgNcm(pPropsEx->ncMediaType), DbgNcsm(pPropsEx->ncSubMediaType), DbgNcs(pPropsEx->ncStatus), DbgNccf(pPropsEx->dwCharacter));
#endif

    if (g_dwCurrentEventLevel <= EVT_LVL_ENABLE_PRIVATE)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Get the result for debugging only. We never want to fail this function
    //
    HRESULT hrTmp = HrOnNotifyUpdateConnection(
            m_pidlFolder,
            (GUID *)&(pPropsEx->guidId),
            pPropsEx->ncMediaType,
            pPropsEx->ncSubMediaType,
            pPropsEx->ncStatus,
            pPropsEx->dwCharacter,
            pPropsEx->bstrName,
            pPropsEx->bstrDeviceName,
            pPropsEx->bstrPhoneOrHostAddress);

    return S_OK;
}


HRESULT
CConnectionNotifySink::ConnectionRenamed (
    const GUID* pguidId,
    PCWSTR     pszwNewName)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT         hr      = S_OK;
    PCONFOLDPIDL    pidlNew;

    Assert(pguidId);
    Assert(pszwNewName);

    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "CConnectionNotifySink::ConnectionRenamed event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Update the name in the cache
    //

    //  Note: There exists a race condition with shutil.cpp:
    //  HrRenameConnectionInternal\HrUpdateNameByGuid can also update the cache.
    ConnListEntry cle;
    hr = g_ccl.HrFindConnectionByGuid(pguidId, cle);
    if (FAILED(hr))
    {
        return E_INVALIDARG;
    }
#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(cle.ccfe.GetGuidID(), szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionRenamed - %S %S (to %S) [%s:%s:%s:%s]", szGuidString, cle.ccfe.GetName(), pszwNewName, 
        DbgNcm(cle.ccfe.GetNetConMediaType()), DbgNcsm(cle.ccfe.GetNetConSubMediaType()), DbgNcs(cle.ccfe.GetNetConStatus()), DbgNccf(cle.ccfe.GetCharacteristics()));
#endif

    hr = g_ccl.HrUpdateNameByGuid(
        (GUID *) pguidId,
        (PWSTR) pszwNewName,
        pidlNew,
        TRUE);  // Force the update -- this is a notification, not a request

    if (S_OK == hr)
    {
        PCONFOLDPIDL pidl;
        cle.ccfe.ConvertToPidl(pidl);

        GenerateEvent(
            SHCNE_RENAMEITEM,
            m_pidlFolder,
            pidl, 
            pidlNew.GetItemIdList());

        // Update status monitor title (RAS case)
        CNetStatisticsCentral * pnsc = NULL;

        hr = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
        if (SUCCEEDED(hr))
        {
            pnsc->UpdateTitle(pguidId, pszwNewName);
            ReleaseObj(pnsc);
        }
    }
    else
    {
        // If the connection wasn't found in the cache, then it's likely that
        // the notification engine is giving us a notification for a connection
        // that hasn't yet been given to us.
        //
        if (S_FALSE == hr)
        {
            TraceHr(ttidShellFolder, FAL, hr, FALSE, "Rename notification received on a connection we don't know about");
        }
    }

    return S_OK;
}

HRESULT
CConnectionNotifySink::ConnectionStatusChange (
    const GUID*     pguidId,
    NETCON_STATUS   Status)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT         hr          = S_OK;
    HRESULT         hrFind      = S_OK;
    PCONFOLDPIDL    pidlFind;

    if (g_dwCurrentEventLevel <= EVT_LVL_ENABLE_PRIVATE)
    {
        TraceTag(ttidNotifySink, "CConnectionNotifySink::ConnectionStatusChange event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }
    
    // Find the connection using the GUID. Cast the const away from the GUID
    //
    hrFind = g_ccl.HrFindPidlByGuid((GUID *) pguidId, pidlFind);

    if( S_OK != hrFind )
    {   
        GUID guidOwner;

        // We did not find the guid in connection folder. Try finding the connection in the 
        // hidden connectiod list on netmans side.
        //
        hr = g_ccl.HrMapCMHiddenConnectionToOwner(*pguidId, &guidOwner);
        if (S_OK == hr)
        {
            // The conection has a parent!!!! Use the childs status instead of the parents status.
            //
            if (Status == NCS_CONNECTED)
            {
                // This means that the child has connected and the parent still has to connect
                // the overall status should stay as connected. This was done to overrule the Multi-link
                // hack in HrOnNotifyUpdateStatus. If we did not do this it would say :
                // Child( Connecting, Connected) and then Parent(Connecting, Connected)
                //
                Status = NCS_CONNECTING;
            }

            // Get the pidl of the parent.
            //
            hrFind = g_ccl.HrFindPidlByGuid(&guidOwner, pidlFind);
        }
    }

    if (S_OK == hrFind)
    {
#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pidlFind->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionStatusChange - %S %S [%s:%s:%s:%s]", szGuidString, pidlFind->PszGetNamePointer(), 
        DbgNcm(pidlFind->ncm), DbgNcsm(pidlFind->ncsm), DbgNcs(Status), DbgNccf(pidlFind->dwCharacteristics));
#endif
        hr = HrOnNotifyUpdateStatus(m_pidlFolder, pidlFind, Status);
    }

    return S_OK;
}

HRESULT
CConnectionNotifySink::RefreshAll ()
{
    TraceFileFunc(ttidNotifySink);

#ifdef DBG
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::RefreshAll");
#endif
    
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    // Refresh the connections folder, without having to hook the shell view.
    // In this case, we do a non-flush refresh where we compare the new set
    // of items to the cached set and do the merge (with the correct set
    // of individual notifications).
    //
    (VOID) HrForceRefreshNoFlush(m_pidlFolder);

    return S_OK;
}

HRESULT CConnectionNotifySink::ConnectionAddressChange (
    const GUID* pguidId )
{
    // Find the connection using the GUID.
    //
    PCONFOLDPIDL pidlFind;
    HRESULT hr = g_ccl.HrFindPidlByGuid(pguidId, pidlFind);
    if (S_OK != hr)
    {
        return E_INVALIDARG;
    }

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(pidlFind->guidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ConnectionAddressChange - %S %S [%s:%s:%s:%s]", szGuidString, pidlFind->PszGetNamePointer(),
        DbgNcm(pidlFind->ncm), DbgNcsm(pidlFind->ncsm), DbgNcs(pidlFind->ncs), DbgNccf(pidlFind->dwCharacteristics));

#endif
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    PCONFOLDPIDLFOLDER pidlFolder;
    hr = HrGetConnectionsFolderPidl(pidlFolder);
    if (SUCCEEDED(hr))
    {
        GenerateEvent(SHCNE_UPDATEITEM, pidlFolder, pidlFind, NULL);
    }
    
    return hr;
}

DWORD WINAPI OnTaskBarIconBalloonClickThread(LPVOID lpParam);

STDMETHODIMP CConnectionNotifySink::ShowBalloon(
                IN const GUID* pguidId, 
                IN const BSTR  szCookie, 
                IN const BSTR  szBalloonText)
{
    HRESULT hr;

#ifdef DBG
    OLECHAR szGuidString[MAX_GUID_STRING_LEN];
    StringFromGUID2(*pguidId, szGuidString, MAX_GUID_STRING_LEN);
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::ShowBalloon - %S (%S)", szGuidString, szBalloonText);
#endif
    
    if (g_dwCurrentEventLevel <= EVT_LVL_DISABLE_ALL)
    {
        TraceTag(ttidNotifySink, "Last event ignored due to g_dwCurrentEventLevel == %d", g_dwCurrentEventLevel);
        return S_FALSE;
    }

    CComBSTR szBalloonTextTmp = szBalloonText;
    BSTR szCookieTmp = NULL;

    if (szCookie)
    {
        szCookieTmp = SysAllocStringByteLen(reinterpret_cast<LPCSTR>(szCookie), SysStringByteLen(szCookie));
    }

    ConnListEntry cleFind;
    hr = g_ccl.HrFindConnectionByGuid(pguidId, cleFind);
    if (S_OK == hr)
    {
        hr = WZCCanShowBalloon(pguidId, cleFind.ccfe.GetName(), &szBalloonTextTmp, &szCookieTmp);
        if ( (S_OK == hr) || (S_OBJECT_NO_LONGER_VALID == hr) )
        {
            CTrayBalloon *pTrayBalloon = new CTrayBalloon();
            if (!pTrayBalloon)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                pTrayBalloon->m_gdGuid    = *pguidId;
                pTrayBalloon->m_dwTimeOut = 30 * 1000;
                pTrayBalloon->m_szMessage = szBalloonTextTmp;
                pTrayBalloon->m_pfnFuncCallback = WZCOnBalloonClick;
                pTrayBalloon->m_szCookie  = szCookieTmp;
                pTrayBalloon->m_szAdapterName = cleFind.ccfe.GetName();

                if (S_OK == hr)
                {
                    PostMessage(g_hwndTray, MYWM_SHOWBALLOON, 
                        NULL, 
                        (LPARAM) pTrayBalloon);
                }
                else // S_OBJECT_NO_LONGER_VALID == hr
                {
                    CreateThread(NULL, STACK_SIZE_SMALL, OnTaskBarIconBalloonClickThread, pTrayBalloon, 0, NULL);
                }
            }
        }
    }

    if (S_OK != hr)
    {
        SysFreeString(szCookieTmp);
    }

    TraceHr(ttidError, FAL, hr, FALSE,
        "CConnectionNotifySink::ShowBalloon");

    return hr;
}

UINT_PTR uipTimer = NULL;

VOID CALLBACK EventTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
    HRESULT hr = S_OK;
    TraceTag(ttidNotifySink, "Refreshing the folder due to DisableEvents timeout reached");

    g_dwCurrentEventLevel = EVT_LVL_ENABLE_ALL;
    if (uipTimer)
    {
        KillTimer(NULL, uipTimer);
        uipTimer = NULL;
    }
    
    PCONFOLDPIDLFOLDER pcfpFolder;
    hr = HrGetConnectionsFolderPidl(pcfpFolder);
    if (SUCCEEDED(hr))
    {
        HrForceRefreshNoFlush(pcfpFolder);
    }
}

STDMETHODIMP CConnectionNotifySink::DisableEvents (
        IN const BOOL  fDisable,
        IN const ULONG ulDisableTimeout)
{
#ifdef DBG
    TraceTag(ttidNotifySink, "INetConnectionNotifySink::DisableEvents - %s 0x%08x", fDisable ? "DISABLE" : "ENABLE", ulDisableTimeout);
#endif
    HRESULT hr = S_OK;

    if (fDisable)
    {
        if (HIWORD(ulDisableTimeout) & 0x8000)
        {
            // Called from private interface - disable all the events
            g_dwCurrentEventLevel = EVT_LVL_DISABLE_ALL;
        }
        else
        {
            // Called from public interface - only disable connection modified & status change events
            g_dwCurrentEventLevel = EVT_LVL_ENABLE_PRIVATE;
        }

        UINT uiEventTimeOut = LOWORD(ulDisableTimeout);
        if (uipTimer)
        {
            KillTimer(NULL, uipTimer);
            uipTimer = NULL;
        }

        uipTimer = SetTimer(NULL, NULL, uiEventTimeOut, EventTimerProc);
    }
    else
    {
        g_dwCurrentEventLevel = EVT_LVL_ENABLE_ALL;

        if (uipTimer)
        {
            KillTimer(NULL, uipTimer);
            uipTimer = NULL;
        }
        else
        {
            hr = S_FALSE; // Timer no more.
        }

        HrForceRefreshNoFlush(m_pidlFolder);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetNotifyConPoint
//
//  Purpose:    Common code for getting the connection point for use in
//              NotifyAdd and NotifyRemove
//
//  Arguments:
//      ppConPoint [out]    Return ptr for IConnectionPoint
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrGetNotifyConPoint(
    IConnectionPoint **             ppConPoint)
{
    TraceFileFunc(ttidNotifySink);

    HRESULT                     hr          = S_OK;
    IConnectionPointContainer * pContainer  = NULL;

    Assert(ppConPoint);

    // Get the debug interface from the connection manager
    //
    hr = HrCreateInstance(
        CLSID_ConnectionManager,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pContainer);

    TraceHr(ttidError, FAL, hr, FALSE,
        "HrCreateInstance(CLSID_ConnectionManager) for IConnectionPointContainer");

    if (SUCCEEDED(hr))
    {
        IConnectionPoint * pConPoint    = NULL;
        
        // Get the connection point itself and fill in the return param
        // on success
        //
        hr = pContainer->FindConnectionPoint(
                IID_INetConnectionNotifySink,
                &pConPoint);

        TraceHr(ttidError, FAL, hr, FALSE, "pContainer->FindConnectionPoint");

        if (SUCCEEDED(hr))
        {
            NcSetProxyBlanket (pConPoint);
            *ppConPoint = pConPoint;
        }

        ReleaseObj(pContainer);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetNotifyConPoint");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\oncommand.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D . H
//
//  Contents:   Command handler prototypes for the InvokeCommand code.
//
//  Notes:
//
//  Author:     jeffspr   4 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _ONCOMMAND_H_
#define _ONCOMMAND_H_

//---[ Typedefs ]-------------------------------------------------------------

// Typedefs for the functions that we'll GetProcAddress from the
// NetWare config DLL
typedef HRESULT (WINAPI *FOLDERONCOMMANDPROC)(
    const PCONFOLDPIDLVEC& apidl,
    HWND,
    LPSHELLFOLDER);

struct ConFoldOnCommandParams
{
    FOLDERONCOMMANDPROC     pfnfocp;
    PCONFOLDPIDLVEC         apidl;
    HWND                    hwndOwner;
    LPSHELLFOLDER           psf;
    HINSTANCE               hInstNetShell;
};

typedef struct ConFoldOnCommandParams   CONFOLDONCOMMANDPARAMS;
typedef struct ConFoldOnCommandParams * PCONFOLDONCOMMANDPARAMS;

HRESULT HrCommandHandlerThread(
    FOLDERONCOMMANDPROC     pfnCommandHandler,
    const PCONFOLDPIDLVEC&  apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf);

DWORD WINAPI FolderCommandHandlerThreadProc(LPVOID lpParam);


//---[ Internal versions of the command handlers ]----------------------------
//
//  These are called by the standard handler functions once they've retrieved
//  the actual data from the pidls. They are also called from those pieces
//  of the code that keep the native data, such as the tray
//
//
HRESULT HrOnCommandDisconnectInternal(
    const CONFOLDENTRY& pccfe,
    HWND            hwndOwner,
    LPSHELLFOLDER   psf);

HRESULT HrOnCommandFixInternal(
    const CONFOLDENTRY& pccfe,
    HWND            hwndOwner,
    LPSHELLFOLDER   psf);

HRESULT HrOnCommandStatusInternal(
    const CONFOLDENTRY&  pccfe,
    BOOL	    fCreateEngine);

HRESULT HrCreateShortcutWithPath(
    const PCONFOLDPIDLVEC&  apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf,
    PCWSTR                  pszDir = NULL);

//---[ Standard command handler functions ]----------------------------------
//
//  These are the pidl based functions that are called from the shell folder
//
HRESULT HrFolderCommandHandler(
    UINT                    uiCommand,
    const PCONFOLDPIDLVEC&  apidl,
    HWND                    hwndOwner,
    LPCMINVOKECOMMANDINFO   lpici,
    LPSHELLFOLDER           psf);

// All of these below handle individual command
//
HRESULT HrOnCommandProperties(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandWZCProperties(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandWZCDlgShow(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandCreateCopy(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandStatus(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandConnect(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandDisconnect(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandFix(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandNewConnection(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandAdvancedConfig(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandDelete(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandNetworkId(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandOptionalComponents(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);


HRESULT HrOnCommandDialupPrefs(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandOperatorAssist(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandCreateShortcut(
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrRaiseConnectionPropertiesInternal(
    HWND                    hwnd,
    UINT                    nStartPage, 
    INetConnection *        pconn);

HRESULT HrOnCommandCreateBridge(    
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandSetDefault(    
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);
                     
HRESULT HrOnCommandUnsetDefault(    
    IN const PCONFOLDPIDLVEC&   apidl,
    IN HWND                    hwndOwner,
    IN LPSHELLFOLDER           psf);

HRESULT HrOnCommandBridgeAddConnections(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf
    );

HRESULT HrOnCommandBridgeRemoveConnections(
    IN const PCONFOLDPIDLVEC&   apidl,
    HWND                        hwndOwner,
    LPSHELLFOLDER               psf,
    UINT_PTR                    nDeleteTheNetworkBridgeMode
    );

LONG 
TotalValidSelectedConnectionsForBridge(
    IN const PCONFOLDPIDLVEC&   apidlSelected
    );

#endif // _ONCOMMAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\traymsgs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A Y M S G S . H 
//
//  Contents:   Tray WM_ messages, for use in the icon window proc
//
//  Notes:      
//
//  Author:     jeffspr   13 Nov 1997
//
//----------------------------------------------------------------------------

#ifndef _TRAYMSGS_H_
#define _TRAYMSGS_H_

#define MYWM_NOTIFYICON         (WM_USER+1)
#define MYWM_OPENSTATUS         (WM_USER+2)
#define MYWM_ADDTRAYICON        (WM_USER+3)
#define MYWM_REMOVETRAYICON     (WM_USER+4)
#define MYWM_UPDATETRAYICON     (WM_USER+5)
#define MYWM_FLUSHNOOP          (WM_USER+6) // For flushing the tray messages via SendMessage()
#define MYWM_SHOWBALLOON        (WM_USER+7) // For update tray-icon text
                                           
#endif // _TRAYMSGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\oncommand_dbg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O N C O M M A N D _ D B G . C P P
//
//  Contents:   Debug command handlers
//
//  Notes:
//
//  Author:     jeffspr   23 Jul 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "advcfg.h"
#include "conprops.h"
#include "foldres.h"
#include "ncnetcon.h"
#include "oncommand.h"
#include "notify.h"
#include "ctrayui.h"
#include <nctraceui.h>

#if DBG                     // Debug menu commands
#include "oncommand_dbg.h"  //
#endif

#include "shutil.h"
#include "traymsgs.h"
#include <nsres.h>


//---[ Externs ]--------------------------------------------------------------

extern HWND g_hwndTray;

//---[ Globals ]--------------------------------------------------------------

// We allow X number (hardcoded) advises. This is all debug code, so no real
// need to build an expensive STL list
//
const DWORD c_dwMaxNotifyAdvises    = 16;
DWORD       g_dwCookieCount         = 0;
DWORD       g_dwAdviseCookies[c_dwMaxNotifyAdvises];

// Used as the caption for all debugging message boxes
//
const WCHAR c_szDebugCaption[]      = L"Net Config Debugging";

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugTray
//
//  Purpose:    Toggle the presence of the tray object
//
//  Arguments:
//      apidl     [in]  Ignored
//      cidl      [in]  Ignored
//      hwndOwner [in]  Ignored
//      psf       [in]  Ignored
//
//  Returns:
//
//  Author:     jeffspr   23 Jul 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugTray(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT             hr              = S_OK;
    IOleCommandTarget * pOleCmdTarget   = NULL;

    // Create an instance of the tray
    hr = CoCreateInstance(CLSID_ConnectionTray,
                          NULL,
                          CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                          IID_IOleCommandTarget,
                          (LPVOID *)&pOleCmdTarget);

    TraceHr(ttidError, FAL, hr, FALSE,
        "CoCreateInstance(CLSID_ConnectionTray) for IOleCommandTarget");

    if (SUCCEEDED(hr))
    {
        // If the tray object exists, try to remove it.
        //
        if (g_pCTrayUI)
        {
            TraceTag(ttidShellFolder, "Removing tray object");

            pOleCmdTarget->Exec(&CGID_ShellServiceObject, SSOCMDID_CLOSE, 0, NULL, NULL);

            hr = HrRemoveTrayExtension();
        }
        else
        {
            // Try to create the tray object
            //
            TraceTag(ttidShellFolder, "Creating tray object");

            pOleCmdTarget->Exec(&CGID_ShellServiceObject, SSOCMDID_OPEN, 0, NULL, NULL);

            hr = HrAddTrayExtension();
        }

        ReleaseObj(pOleCmdTarget);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugTray");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugTracing
//
//  Purpose:    Command handler for CMIDM_DEBUG_TRACING. It will eventually
//              bring up the tracing change dialog.
//
//  Arguments:
//      apidl     [] Ignored
//      cidl      [] Ignored
//      hwndOwner [] Ignored
//      psf       [] Ignored
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugTracing(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    hr = HrOpenTracingUI(hwndOwner);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugTracing");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugNotifyAdd
//
//  Purpose:    Command handler for CMIDM_DEBUG_NOTIFYADD. Adds an additional
//              advise for connection notifications
//
//  Arguments:
//      apidl     [in]  Ignored
//      cidl      [in]  Ignored
//      hwndOwner [in]  Ignored
//      psf       [in]  Ignored
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugNotifyAdd(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT                     hr              = S_OK;
    IConnectionPoint *          pConPoint       = NULL;
    INetConnectionNotifySink *  pSink           = NULL;
    DWORD                       dwCookie        = 0;

    if (g_dwCookieCount >= c_dwMaxNotifyAdvises)
    {
        MessageBox(hwndOwner,
            L"You're over the max advise count. If you REALLY need to test more advises than "
            L"we've hardcoded, then set c_dwMaxNotifyAdvises to something larger in oncommand_dbg.cpp",
            c_szDebugCaption,
            MB_OK | MB_ICONERROR);
    }
    else
    {
        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr))
        {
            // Create the notify sink
            //
            hr = CConnectionNotifySink::CreateInstance(
                    IID_INetConnectionNotifySink,
                    (LPVOID*)&pSink);
            if (SUCCEEDED(hr))
            {
                Assert(pSink);

                hr = pConPoint->Advise(pSink, &dwCookie);
                if (SUCCEEDED(hr))
                {
                    WCHAR   szMB[256];

                    g_dwAdviseCookies[g_dwCookieCount++] = dwCookie;

                    wsprintfW(szMB, L"Advise succeeded. You now have %d active advises", g_dwCookieCount);

                    MessageBox(hwndOwner,
                               szMB,
                               c_szDebugCaption,
                               MB_OK | MB_ICONEXCLAMATION);
                }

                ReleaseObj(pSink);
            }

            ReleaseObj(pConPoint);
        }
        else
        {
            AssertSz(FALSE, "Couldn't get connection point or sink in HrOnCommandDebugNotifyAdd");
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugNotifyAdd");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugNotifyRemove
//
//  Purpose:    Command handler for CMIDM_DEBUG_NOTIFYREMOVE
//
//  Arguments:
//      apidl     [] Ignored
//      cidl      [] Ignored
//      hwndOwner [] Ignored
//      psf       [] Ignored
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugNotifyRemove(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT                     hr              = S_OK;
    IConnectionPoint *          pConPoint       = NULL;
    DWORD                       dwCookie        = 0;

    if (g_dwCookieCount == 0)
    {
        MessageBox(hwndOwner,
                   L"Hey, you don't have any active advises",
                   c_szDebugCaption,
                   MB_OK | MB_ICONERROR);
    }
    else
    {
        hr = HrGetNotifyConPoint(&pConPoint);
        if (SUCCEEDED(hr))
        {
            hr = pConPoint->Unadvise(g_dwAdviseCookies[g_dwCookieCount-1]);
            if (SUCCEEDED(hr))
            {
                WCHAR   szMB[256];

                g_dwAdviseCookies[--g_dwCookieCount] = 0;

                wsprintfW(szMB, L"Unadvise succeeded. You have %d remaining advises", g_dwCookieCount);

                MessageBox(hwndOwner,
                           szMB,
                           c_szDebugCaption,
                           MB_OK | MB_ICONEXCLAMATION);
            }

            ReleaseObj(pConPoint);
        }
        else
        {
            AssertSz(FALSE, "Couldn't get connection point or sink in HrOnCommandDebugNotifyRemove");
        }
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugNotifyRemove");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugNotifyTest
//
//  Purpose:    Command handler for CMIDM_DEBUG_NOTIFYTEST. Runs the
//              NotifyTestStart on the ConManDebug interface.
//
//  Arguments:
//      apidl     [] Ignored
//      cidl      [] Ignored
//      hwndOwner [] Ignored
//      psf       [] Ignored
//
//  Returns:
//
//  Author:     jeffspr   24 Aug 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugNotifyTest(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT                         hr              = S_OK;
    INetConnectionManagerDebug *    pConManDebug    = NULL;

    hr = HrCreateInstance(
        CLSID_ConnectionManager,
        CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pConManDebug);

    TraceHr(ttidError, FAL, hr, FALSE,
        "HrCreateInstance(CLSID_ConnectionManager) for INetConnectionManagerDebug");

    if (SUCCEEDED(hr))
    {
        (VOID) pConManDebug->NotifyTestStart();
    }

    ReleaseObj(pConManDebug);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugNotifyAdd");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugRefresh
//
//  Purpose:    Test the flushing of the connection cache (does the folder
//              still work properly)? This will simulate the current response
//              to an external refresh request
//
//  Arguments:
//      apidl     [in]  Ignored
//      cidl      [in]  Ignored
//      hwndOwner [in]  Ignored
//      psf       [in]  Ignored
//
//  Returns:
//
//  Author:     jeffspr   17 Nov 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugRefresh(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT hr  = S_OK;

    TraceFileFunc(ttidShellFolder);
    // Force a refresh without having the window to work with.
    //
    ForceRefresh(NULL);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugFlushCache");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugRefreshNoFlush
//
//  Purpose:    Test the building of an external CConnectionList. When this
//              is working, it will be used to update the global list.
//
//  Arguments:
//      apidl     [in]  Ignored
//      cidl      [in]  Ignored
//      hwndOwner [in]  Ignored
//      psf       [in]  Ignored
//
//  Returns:
//
//  Author:     jeffspr   17 Nov 1998
//
//  Notes:
//
HRESULT HrOnCommandDebugRefreshNoFlush(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    // Refresh the folder. Pass in NULL to let the shell code do it's own
    // folder pidl lookup
    //
    PCONFOLDPIDLFOLDER pidlEmpty;
    HRESULT hr = HrForceRefreshNoFlush(pidlEmpty);

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugRefreshNoFlush");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnCommandDebugRefreshSelected
//
//  Purpose:    Refresh the selected connection objects (in place)
//
//  Arguments:
//      apidl     [in] Selected object pidls
//      cidl      [in] Count of selected objects
//      hwndOwner [in] Parent hwnd
//      psf       [in] Ignored
//
//  Returns:
//
//  Author:     jeffspr   29 Apr 1999
//
//  Notes:
//
HRESULT HrOnCommandDebugRefreshSelected(
    const PCONFOLDPIDLVEC&  apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDLFOLDER      pidlFolder;

    if (!apidl.empty())
    {
        hr = HrGetConnectionsFolderPidl(pidlFolder);
        if (SUCCEEDED(hr))
        {
            PCONFOLDPIDLVEC::const_iterator ulLoop;
            for (ulLoop = apidl.begin(); ulLoop != apidl.end(); ulLoop++)
            {
                const PCONFOLDPIDL& pcfp = *ulLoop;

                // If it's not a wizard pidl, then update the
                // icon data.
                //
                if (WIZARD_NOT_WIZARD == pcfp->wizWizard)
                {
                    // Refresh this item -- this will make the desktop shortcuts
                    // update to the correct state.
                    //
                    RefreshFolderItem(pidlFolder, *ulLoop, *ulLoop);
                }
            }
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnCommandDebugRefreshSelected");
    return hr;
}

HRESULT HrOnCommandDebugRemoveTrayIcons(
    const PCONFOLDPIDLVEC&          apidl,
    HWND                    hwndOwner,
    LPSHELLFOLDER           psf)
{
    HRESULT         hr  = S_OK;
    NOTIFYICONDATA  nid;

    TraceTag(ttidShellFolder, "In OnMyWMRemoveTrayIcon message handler");

    if (g_hwndTray)
    {
        UINT uiTrayIconId = 0;
        // We're going to remove icons until we can't remove icons any more
        // If HrShell_NotifyIcon screws up though and is returning S_OK
        // on invalid icon ids, make sure that we are able to bail this loop.
        // Hence the 10000
        //
        while (hr == S_OK && uiTrayIconId < 10000)
        {
            TraceTag(ttidShellFolder, "Attempting to remove icon: %d", uiTrayIconId);

            ZeroMemory (&nid, sizeof(nid));
            nid.cbSize  = sizeof(NOTIFYICONDATA);
            nid.hWnd    = g_hwndTray;
            nid.uID     = uiTrayIconId++;

            hr = HrShell_NotifyIcon(NIM_DELETE, &nid);
        }

        g_pCTrayUI->ResetIconCount();
    }


    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnCommandDebugRemoveTrayIcons");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\trayres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A Y R E S . H 
//
//  Contents:   Connections Tray resources
//
//  Notes:      
//
//  Author:     jeffspr   29 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _TRAYRES_H_
#define _TRAYRES_H_

// Trayres owns from 15000 - 15999

//---[ Menus, etc ]------------------------------------------------------------

#define POPUP_CONTRAY_GENERIC_MENU_RAS              15100
#define POPUP_CONTRAY_GENERIC_MENU_LAN              15101
#define POPUP_CONTRAY_MEDIA_DISCONNECTED_MENU       15102
#define POPUP_CONTRAY_GENERIC_MENU_WIRELESS_LAN     15103
#define POPUP_CONTRAY_WIRELESS_DISCONNECTED_LAN     15105

//---[ Commands (context/menus) ]----------------------------------------------

#define CMIDM_FIRST                     0x0000
#define CMIDM_OPEN_CONNECTIONS_FOLDER   (CMIDM_FIRST + 0x0001)
#define CMIDM_TRAY_DISCONNECT           (CMIDM_FIRST + 0x0002)
#define CMIDM_TRAY_STATUS               (CMIDM_FIRST + 0x0003)
#define CMIDM_TRAY_PROPERTIES           (CMIDM_FIRST + 0x0004)
#define CMIDM_TRAY_REPAIR               (CMIDM_FIRST + 0x0005)
#define CMIDM_TRAY_WZCDLG_SHOW          (CMIDM_FIRST + 0x0006)
#define CMIDM_TRAY_MAX                  (CMIDM_TRAY_WZCDLG_SHOW)

#endif  // _TRAYRES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\shutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S H U T I L . H
//
//  Contents:   Various shell utilities to be used by the connections folder
//
//  Notes:
//
//  Author:     jeffspr   21 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _SHUTIL_H_
#define _SHUTIL_H_

#include <ndispnp.h>
#include <ntddndis.h>
#include <ncshell.h>

HRESULT HrDupeShellStringLength(
    PCWSTR     pszInput,
    ULONG       cchInput,
    PWSTR *    ppszOutput);

inline
HRESULT HrDupeShellString(
    PCWSTR     pszInput,
    PWSTR *    ppszOutput)
{
    return HrDupeShellStringLength(pszInput, wcslen(pszInput), ppszOutput);
}

HRESULT HrGetConnectionPidlWithRefresh(const GUID& guidId,
                                       PCONFOLDPIDL& ppidlCon);


//---[ Various refresh functions ]--------------------------------------------

// Notify the shell that an object is going away, and remove it from our list
//
HRESULT HrDeleteFromCclAndNotifyShell(
    const PCONFOLDPIDLFOLDER&  pidlFolder,
    const PCONFOLDPIDL&  pidlConnection,
    const CONFOLDENTRY&  ccfe);

VOID ForceRefresh(HWND hwnd);

// Update the folder, but don't flush the items. Update them as needed.
// pidlFolder is optional -- if not passed in, we'll generate it.
//
HRESULT HrForceRefreshNoFlush(const PCONFOLDPIDLFOLDER& pidlFolder);

// Update the connection data based on the pidl. Notify the shell as
// appropriate
//
HRESULT HrOnNotifyUpdateConnection(
    const PCONFOLDPIDLFOLDER&        pidlFolder,
    const GUID *              pguid,
    NETCON_MEDIATYPE    ncm,
    NETCON_SUBMEDIATYPE ncsm,
    NETCON_STATUS       ncs,
    DWORD               dwCharacteristics,
    PCWSTR              pszwName,
    PCWSTR              pszwDeviceName,
    PCWSTR              pszwPhoneNumberOrHostAddress);

// Update the connection status, including sending the correct shell
// notifications for icon updates and such.
//
HRESULT HrOnNotifyUpdateStatus(
    const PCONFOLDPIDLFOLDER&    pidlFolder,
    const PCONFOLDPIDL&    pidlCached,
    NETCON_STATUS   ncsNew);

// update the shell/connection list with the new connection status
//
HRESULT HrUpdateConnectionStatus(
    const PCONFOLDPIDL&    pcfp,
    NETCON_STATUS   ncs,
    const PCONFOLDPIDLFOLDER&    pidlFolder,
    BOOL            fUseCharacter,
    DWORD           dwCharacter);


//---[ Menu merging functions ]-----------------------------------------------

VOID MergeMenu(
    HINSTANCE   hinst,
    UINT        idMainMerge,
    UINT        idPopupMerge,
    LPQCMINFO   pqcm);

INT IMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int   idCmdFirst,
    int   idCmdLast);

HRESULT HrGetMenuFromID(
    HMENU   hmenuMain,
    UINT    uID,
    HMENU * phmenu);

HRESULT HrLoadPopupMenu(
    HINSTANCE   hinst,
    UINT        id,
    HMENU *     phmenu);

HRESULT HrShellView_GetSelectedObjects(
    HWND                hwnd,
    PCONFOLDPIDLVEC&    apidlSelection);

HRESULT HrRenameConnectionInternal(
    const PCONFOLDPIDL&  pidlCon,
    const PCONFOLDPIDLFOLDER&  pidlFolder,
    LPCWSTR         pszNewName,
    BOOL            fRaiseError,
    HWND            hwndOwner,
    PCONFOLDPIDL&   ppidlOut);

#endif // _SHUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\shortcut.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S h o r t C u t . C P P
//
//  Contents:   Creates shortcuts.
//
//  Notes:
//
//  Author:     scottbri    19 June 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes

extern const WCHAR c_szBackslash[];
const WCHAR c_szLinkExt[]           = L".lnk";
const WCHAR c_szVersionFormat[]     = L" %d";

//
// Function:    HrGenerateLinkName
//
// Purpose:     Combine the link path, name, and extension and verify the file
//              doesn't already exist.
//
// Parameters:  pstrNew     [OUT] - The name and path of the .lnk shortcut
//              pszPath      [IN] - The directory path for the link
//              pszConnName  [IN] - The connection name itself
//
// Returns:     HRESULT, S_OK on success, an error if the file will not be created
//
HRESULT HrGenerateLinkName(tstring * pstrNew, PCWSTR pszPath, PCWSTR pszConnName)
{
    HRESULT hr = S_OK;
    tstring str;
    DWORD dwCnt = 0;

    do
    {
        // prepend the string with \\?\ so CreateFile will use a name buffer
        // larger than MAX_PATH
        str = L"\\\\?\\";

        str += pszPath;
        str += c_szBackslash;
        str += pszConnName;

        if (++dwCnt>1)
        {
            WCHAR szBuf[10];
            wsprintfW(szBuf, c_szVersionFormat, dwCnt);
            str += szBuf;
        }

        str += c_szLinkExt;

        HANDLE hFile = CreateFile(str.c_str(), GENERIC_READ, FILE_SHARE_READ,
                                  NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;      // Filename is unique
            }
        }
        else
        {
            CloseHandle(hFile);
            hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME);
        }
    } while (HRESULT_FROM_WIN32(ERROR_DUP_NAME) == hr);

    if (SUCCEEDED(hr))
    {
        *pstrNew = str.c_str();
    }

    return hr;
}

LPITEMIDLIST ILCombinePriv(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

//
// Function:    HrCreateStartMenuShortCut
//
// Purpose:     Create a shortcut to a connection in the start menu
//
// Parameters:  hwndParent [IN] - Handle to a parent window
//              fAllUser   [IN] - Create the connection for all users
//              pwszName   [IN] - The connection name
//              pConn      [IN] - Connection for which the shortcut is created
//
// Returns:     BOOL, TRUE
//
HRESULT HrCreateStartMenuShortCut(HWND hwndParent,
                                  BOOL fAllUsers,
                                  PCWSTR pszName,
                                  INetConnection * pConn)
{
    HRESULT                 hr              = S_OK;
    PCONFOLDPIDL            pidl;
    PCONFOLDPIDLFOLDER      pidlFolder;
    LPSHELLFOLDER           psfConnections  = NULL;

    if ((NULL == pConn) || (NULL == pszName))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Create a pidl for the connection
    //
    hr = HrCreateConFoldPidl(WIZARD_NOT_WIZARD, pConn, pidl);
    if (SUCCEEDED(hr))
    {
        // Get the pidl for the Connections Folder
        //
        hr = HrGetConnectionsFolderPidl(pidlFolder);
        if (SUCCEEDED(hr))
        {
            // Get the Connections Folder object
            //
            hr = HrGetConnectionsIShellFolder(pidlFolder, &psfConnections);
            if (SUCCEEDED(hr))
            {
                tstring str;
                WCHAR szPath[MAX_PATH + 1] = {0};

                // Find the location to stash the shortcut
                //
                if (!SHGetSpecialFolderPath(hwndParent, szPath,
                                (fAllUsers ? CSIDL_COMMON_DESKTOPDIRECTORY :
                                             CSIDL_DESKTOPDIRECTORY), FALSE))
                {
                    hr = HrFromLastWin32Error();
                }
                else if (SUCCEEDED(hr) && wcslen(szPath))
                {
                    LPITEMIDLIST pidlFull;

                    // Combine the folder and connections pidl into a
                    // fully qualified pidl.
                    //
                    pidlFull = ILCombinePriv(pidlFolder.GetItemIdList(), pidl.GetItemIdList());
                    if (pidlFull)
                    {
                        IShellLink *psl = NULL;

                        hr = CoCreateInstance(
                                CLSID_ShellLink,
                                NULL,
                                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                                IID_IShellLink,
                                (LPVOID*)&psl);

                        if (SUCCEEDED(hr))
                        {
                            IPersistFile *ppf = NULL;

                            // Set the combined IDL
                            //
                            hr = psl->SetIDList(pidlFull);
                            if (SUCCEEDED(hr))
                            {
                                hr = psl->QueryInterface(IID_IPersistFile,
                                                         (LPVOID *)&ppf);
                                if (SUCCEEDED(hr))
                                {
                                    tstring strPath;

                                    // Generate the lnk filename
                                    //
                                    hr = HrGenerateLinkName(&strPath,
                                                            szPath,
                                                            pszName);
                                    if (SUCCEEDED(hr))
                                    {
                                        // Create the link file.
                                        //
                                        hr = ppf->Save(strPath.c_str(), TRUE);
                                    }

                                    ReleaseObj(ppf);
                                }
                            }

                            ReleaseObj(psl);
                        }

                        if (pidlFull)
                            FreeIDL(pidlFull);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    TraceError("HrCreateStartMenuShortCut - Unable to find Start Menu save location", hr);
                }

                ReleaseObj(psfConnections);
            }
        }
    }

Error:
    TraceError("HrCreateStartMenuShortCut", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\pidlutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L U T I L . C P P
//
//  Contents:   PIDL utility routines. This stuff is mainly copied from the
//              existing Namespace extension samples and real code, since
//              everyone and their gramma uses this stuff.
//
//  Notes:
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"    // Standard shell\folder includes
#include "connlist.h"   // Connection list code

//+---------------------------------------------------------------------------
//
//  Function:   HrCloneRgIDL
//
//  Purpose:    Clone a pidl array
//
//  Arguments:
//      rgpidl              [in]    PIDL array to clone
//      cidl                [in]    Count of the pidl array
//      fUseCache           [in]    If TRUE, generate the returned IDL from the cache
//      fAllowNonCacheItems [in]    Use old version of pidl if cached version non available
//      pppidl              [out]   Return pointer for pidl array
//
//  Returns:
//
//  Author:     jeffspr   22 Oct 1997
//
//  Notes:
//
HRESULT HrCloneRgIDL(
    const PCONFOLDPIDLVEC& rgpidl,
    BOOL            fUseCache,
    BOOL            fAllowNonCacheItems,
    PCONFOLDPIDLVEC& pppidl)
{
    HRESULT          hr              = NOERROR;

    NETCFG_TRY

        PCONFOLDPIDLVEC  rgpidlReturn;
        PCONFOLDPIDLVEC::const_iterator irg;

        if (rgpidl.empty())
        {
            hr = E_INVALIDARG;
            goto Exit;
        }
        else
        {
            // Clone all elements within the passed in PIDL array
            //
            for (irg = rgpidl.begin(); irg != rgpidl.end(); irg++)
            {
                if (fUseCache)
                {
                    ConnListEntry  cle;
                    PCONFOLDPIDL   pcfp    = *irg;

                    hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
                    if (hr == S_OK)
                    {
                        Assert(!cle.empty());
                        Assert(!cle.ccfe.empty());

                        // Copy to the return pidl array.
                        PCONFOLDPIDL newPidl;
                        hr = cle.ccfe.ConvertToPidl(newPidl);
                        if (SUCCEEDED(hr))
                        {
                            rgpidlReturn.push_back(newPidl);
                        }
                        else
                        {
                            goto Exit;
                        }                            
                    }
                    else
                    {
                        TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection find returned: 0x%08x", hr);

                        if (hr == S_FALSE)
                        {
                            if (fAllowNonCacheItems)
                            {
                                TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache, "
                                         "using non-cache item");


                                PCONFOLDPIDL newPidl;
                                newPidl = *irg;
                                rgpidlReturn.push_back(newPidl);
                            }
                            else
                            {
                                TraceTag(ttidShellFolder, "HrCloneRgIDL: Connection not found in cache. "
                                         "Dropping item from array");
                            }
                        }
                        else
                        {
                            AssertSz(FALSE, "HrCloneRgIDL: Connection find HR_FAILED");
                        }
                    }
                }
                else
                {
                    
                    PCONFOLDPIDL newPidl;
                    newPidl = *irg;
                    rgpidlReturn.push_back(newPidl);
                }
            }
        }

Exit:
        if (FAILED(hr))
        {
            rgpidlReturn.clear();
        }
        else
        {
            // Fill in the return var.
            //
            pppidl = rgpidlReturn;
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "HrCloneRgIDL");
    return hr;

}       //  HrCloneRgIDL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\shutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S H U T I L . C P P
//
//  Contents:   Various shell utilities to be used by the connections shell
//
//  Notes:
//
//  Author:     jeffspr   21 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <wtypes.h>
#include <ntddndis.h>
#include <ndisprv.h>
#include <devioctl.h>
#include <ndispnp.h>
#include "foldinc.h"    // Standard shell\folder includes
#include "ncnetcon.h"   // FreeNetconProperties
#include "smcent.h"     // Statmon central
#include "ctrayui.h"    // For flushing tray messages

extern HWND g_hwndTray;

//+---------------------------------------------------------------------------
//
//  Function:   HrDupeShellStringLength
//
//  Purpose:    Duplicate a string using SHAlloc, so we can return it to the
//              shell. This is required because the shell typically releases
//              the strings that we pass it (so we need to use their
//              allocator).
//
//  Arguments:
//      pszInput   [in]  String to duplicate
//      cchInput   [in]  Count of characters to copy (not including null term)
//      ppszOutput [out] Return pointer for the newly allocated string.
//
//  Returns:
//
//  Author:     jeffspr   21 Oct 1997
//
//  Notes:
//
HRESULT HrDupeShellStringLength(
    PCWSTR     pszInput,
    ULONG       cchInput,
    PWSTR *    ppszOutput)
{
    HRESULT hr = S_OK;

    Assert(pszInput);
    Assert(ppszOutput);

    ULONG cbString = (cchInput + 1) * sizeof(WCHAR);

    // Allocate a new POLESTR block, which the shell can then free.
    //
    PWSTR pszOutput = (PWSTR) SHAlloc(cbString);

    // If the alloc failed, return E_OUTOFMEMORY
    //
    if (NULL != pszOutput)
    {
        // Copy the memory into the alloc'd block
        //
        CopyMemory(pszOutput, pszInput, cbString);
        pszOutput[cchInput] = 0;
        *ppszOutput = pszOutput;
    }
    else
    {
        *ppszOutput = NULL;
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrDupeShellStringLength");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLoadPopupMenu
//
//  Purpose:    Load a popup menu as the first child of a loadable parent
//              menu
//
//  Arguments:
//      hinst  [in]     Our instance handle
//      id     [in]     ID of the parent menu
//      phmenu [out]    Return pointer for the popup menu
//
//  Returns:
//
//  Author:     jeffspr   27 Oct 1997
//
//  Notes:
//
HRESULT HrLoadPopupMenu(
    HINSTANCE   hinst,
    UINT        id,
    HMENU *     phmenu)
{
    HRESULT hr          = S_OK;
    HMENU   hmParent    = NULL;
    HMENU   hmPopup     = NULL;

    Assert(id);
    Assert(hinst);
    Assert(phmenu);

    // Load the parent menu
    //
    hmParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (NULL == hmParent)
    {
        AssertSz(FALSE, "Can't load parent menu in HrLoadPopupMenu");
        hr = HrFromLastWin32Error();
    }
    else
    {
        // Load the popup from the parent (first submenu), then
        // remove the parent menu
        //
        hmPopup = GetSubMenu(hmParent, 0);
        RemoveMenu(hmParent, 0, MF_BYPOSITION);
        DestroyMenu(hmParent);
    }

    if (phmenu)
    {
        *phmenu = hmPopup;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrLoadPopupMenu");
    return hr;
}


HRESULT HrGetMenuFromID(
    HMENU   hmenuMain,
    UINT    uID,
    HMENU * phmenu)
{
    HRESULT         hr          = S_OK;
    HMENU           hmenuReturn = NULL;
    MENUITEMINFO    mii;

    Assert(hmenuMain);
    Assert(uID);
    Assert(phmenu);

    ZeroMemory(&mii, sizeof(MENUITEMINFO));

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.cch    = 0;     // just in case

    if (!GetMenuItemInfo(hmenuMain, uID, FALSE, &mii))
    {
        hr = E_FAIL;
    }
    else
    {
        hmenuReturn = mii.hSubMenu;
    }

    if (phmenu)
    {
        *phmenu = mii.hSubMenu;
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetMenuFromID");
    return hr;
}


INT IMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int   idCmdFirst,
    int   idCmdLast)
{
    HRESULT hr      = S_OK;
    int     iCount  = 0;
    int     idTemp  = 0;
    int     idMax   = idCmdFirst;
    HMENU   hmFromId = NULL;

    for (iCount = GetMenuItemCount(hmMerge) - 1; iCount >= 0; --iCount)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_ID | MIIM_SUBMENU;
        mii.cch    = 0;     // just in case

        if (!GetMenuItemInfo(hmMerge, iCount, TRUE, &mii))
        {
            TraceHr(ttidError, FAL, E_FAIL, FALSE, "GetMenuItemInfo failed in iMergePopupMenus");
            continue;
        }

        hr = HrGetMenuFromID(hmMain, mii.wID, &hmFromId);
        if (SUCCEEDED(hr))
        {
            idTemp = Shell_MergeMenus(
                        hmFromId,
                        mii.hSubMenu,
                        0,
                        idCmdFirst,
                        idCmdLast,
                        MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

            if (idMax < idTemp)
            {
                idMax = idTemp;
            }
        }
        else
        {
            TraceHr(ttidError, FAL, E_FAIL, FALSE, "HrGetMenuFromId failed in iMergePopupMenus");
            continue;
        }
    }

    return idMax;
}


VOID MergeMenu(
    HINSTANCE   hinst,
    UINT        idMainMerge,
    UINT        idPopupMerge,
    LPQCMINFO   pqcm)
{
    HMENU hmMerge   = NULL;
    UINT  idMax     = 0;
    UINT  idTemp    = 0;

    Assert(pqcm);
    Assert(idMainMerge);
    Assert(hinst);

    idMax = pqcm->idCmdFirst;

    if (idMainMerge
        && (SUCCEEDED(HrLoadPopupMenu(hinst, idMainMerge, &hmMerge))))
    {
        Assert(hmMerge);

        if (hmMerge)
        {
            idMax = Shell_MergeMenus(
                            pqcm->hmenu,
                            hmMerge,
                            pqcm->indexMenu,
                            pqcm->idCmdFirst,
                            pqcm->idCmdLast,
                            MM_SUBMENUSHAVEIDS);

            DestroyMenu(hmMerge);
        }
    }

    if (idPopupMerge
        && (hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge))) != NULL)
    {
        idTemp = IMergePopupMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast);

        if (idMax < idTemp)
        {
            idMax = idTemp;
        }

        DestroyMenu(hmMerge);
    }

    pqcm->idCmdFirst = idMax;
}

LPITEMIDLIST ILCombinePriv(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidls);

//+---------------------------------------------------------------------------
//
//  Function:   GenerateEvent
//
//  Purpose:    Generate a Shell Notification event.
//
//  Arguments:
//      lEventId   [in]     The event ID to post
//      pidlFolder [in]     Folder pidl
//      pidlIn     [in]     First pidl that we reference
//      pidlNewIn  [in]     If needed, the second pidl.
//
//  Returns:
//
//  Author:     jeffspr   16 Dec 1997
//
//  Notes:
//
VOID GenerateEvent(
    LONG            lEventId,
    const PCONFOLDPIDLFOLDER& pidlFolder,
    const PCONFOLDPIDL& pidlIn,
    LPCITEMIDLIST pidlNewIn)
{
    // Build an absolute pidl from the folder pidl + the object pidl
    //
    LPITEMIDLIST pidl = ILCombinePriv(pidlFolder.GetItemIdList(), pidlIn.GetItemIdList());
    if (pidl)
    {
        // If we have two pidls, call the notify with both
        //
        if (pidlNewIn)
        {
            // Build the second absolute pidl
            //
            
            LPITEMIDLIST pidlNew = ILCombinePriv(pidlFolder.GetItemIdList(), pidlNewIn);
            if (pidlNew)
            {
                // Make the notification, and free the new pidl
                //
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                FreeIDL(pidlNew);
            }
        }
        else
        {
            // Make the single-pidl notification
            //
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }

        // Always refresh, then free the newly allocated pidl
        //
        SHChangeNotifyHandleEvents();
        FreeIDL(pidl);
    }
}

VOID ForceRefresh(HWND hwnd)
{
    TraceFileFunc(ttidShellFolder);

    LPSHELLBROWSER  psb = FileCabinet_GetIShellBrowser(hwnd);
    LPSHELLVIEW     psv = NULL;

    // Did we get the shellview?
#if 0   // We can't require this, since we may need to refresh without a folder
        // actually being open
    AssertSz(psb, "FileCabinet_GetIShellBrowser failed in ForceRefresh()");
#endif

    if (psb && SUCCEEDED(psb->QueryActiveShellView(&psv)))
    {
        // Flush our connection list, which will force us to re-enumerate
        // on refresh
        //
        g_ccl.FlushConnectionList();

        Assert(psv);
        if (psv)
        {
            psv->Refresh();
            psv->Release();
        }
    }
    else
    {
        // In the case where we don't have a window to go off of, we'll just flush
        // and refresh the list.
        g_ccl.HrRefreshConManEntries();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDeleteFromCclAndNotifyShell
//
//  Purpose:    Remove an object from the connection list and notify the
//              shell that it's going away. We call this when a user has
//              deleted a connection, and when a disconnect has caused a
//              connection to go away (as in an incoming connection)
//
//  Arguments:
//      pidlFolder     [in]     Our folder pidl
//      pidlConnection [in]     The pidl for this connection
//      ccfe           [in]     Our ConFoldEntry
//
//  Returns:
//
//  Author:     jeffspr   22 Jul 1998
//
//  Notes:
//
HRESULT HrDeleteFromCclAndNotifyShell(
    const PCONFOLDPIDLFOLDER&  pidlFolder,
    const PCONFOLDPIDL&  pidlConnection,
    const CONFOLDENTRY&  ccfe)
{
    HRESULT hr          = S_OK;
    BOOL    fFlushPosts = FALSE;

    Assert(!pidlConnection.empty());
    Assert(!ccfe.empty());

    // Notify the shell that the object has gone away
    //
    if (!pidlFolder.empty())
    {
        GenerateEvent(SHCNE_DELETE, pidlFolder, pidlConnection, NULL);
    }

    if (!ccfe.empty())
    {
        // Remove this connection from the global list
        //
        hr = g_ccl.HrRemove(ccfe, &fFlushPosts);
    }

    // If we need to clear the tray PostMessages due to tray icon changes,
    // do so.
    //
    if (fFlushPosts && g_hwndTray)
    {
        FlushTrayPosts(g_hwndTray);
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrDeleteFromCclAndNotifyShell");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrUpdateConnectionStatus
//
//  Purpose:    Update the connection status in the connection list, and perform the
//              appropriate tray actions to add/remove the item. Update the shell
//
//  Arguments:
//      pcfp          [in]  pidl for this connection
//      ncs           [in]  new connection status
//      pidlFolder    [in]  our folder pidl
//      fUseCharacter [in]  dwCharacter is valid
//      dwCharacter   [in]  if fUseCharacter was specified as TRUE, update the
//                          characteristics using this value.
//
//  Returns:
//
//  Author:     jeffspr   28 Aug 1998
//
//  Notes:
//
HRESULT HrUpdateConnectionStatus(
    const PCONFOLDPIDL& pcfp,
    NETCON_STATUS   ncs,
    const PCONFOLDPIDLFOLDER&  pidlFolder,
    BOOL            fUseCharacter,
    DWORD           dwCharacter)
{
    HRESULT         hr      = S_OK;
    HRESULT         hrFind  = S_OK;
    ConnListEntry   cle;

    // Raid #310390: If this is a RAS connection, we need to double check the status..
    CONFOLDENTRY ccfeDup;

    hrFind = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
    if (S_OK == hrFind)
    {
        Assert(!cle.ccfe.empty());
        if (!cle.ccfe.empty())
        {
            if ((NCS_DISCONNECTED == ncs) &&
                (cle.ccfe.GetCharacteristics() & NCCF_OUTGOING_ONLY))
            {
                hr = ccfeDup.HrDupFolderEntry(cle.ccfe);
                if (FAILED(hr))
                {
                    ccfeDup.clear();
                }
            }
        }
    }

    if (!ccfeDup.empty())
    {
        // Raid #310390: If this is a Ras connection, then double check
        // the status
            
        HRESULT hrRas = S_OK;
        INetConnection * pNetCon = NULL;

        hrRas = ccfeDup.HrGetNetCon(IID_INetConnection,
                                      reinterpret_cast<VOID**>(&pNetCon));
        if (SUCCEEDED(hrRas))
        {
            NETCON_PROPERTIES * pProps;
            hrRas = pNetCon->GetProperties(&pProps);
            if (SUCCEEDED(hrRas))
            {
                if (ncs != pProps->Status)
                {
                    TraceTag(ttidShellFolder, "Resetting status, notified "
                             "status: %d, actual status: %d", 
                             ncs, pProps->Status);

                    ncs = pProps->Status;
                }

                FreeNetconProperties(pProps);
            }

            ReleaseObj(pNetCon);
        }
    }

    // MAKE SURE TO -- Release this lock in either find case below
    //
    g_ccl.AcquireWriteLock();
    hrFind = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cle);
    if (hrFind == S_OK)
    {
        Assert(!cle.ccfe.empty());
        if (!cle.ccfe.empty())
        {
            cle.ccfe.SetNetConStatus(ncs);
            if (fUseCharacter)
            {
                cle.ccfe.SetCharacteristics(dwCharacter);
            }
            const GUID ConnectionGuid = pcfp->guidId; // Fix IA64 alignment.
            g_ccl.HrUpdateConnectionByGuid(&ConnectionGuid, cle);
        }

        // Update the tray icon
        //
        GUID guidId;

        guidId = pcfp->guidId;
        hr = g_ccl.HrUpdateTrayIconByGuid(&guidId, TRUE);
        g_ccl.ReleaseWriteLock();

        // Close statistics window if disconnecting
        if (NCS_DISCONNECTED == ncs || NCS_MEDIA_DISCONNECTED == ncs)
        {
            CNetStatisticsCentral * pnsc = NULL;
            HRESULT hrStatmon = S_OK;

            hrStatmon = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
            if (S_OK == hrStatmon)
            {
                GUID guidId;

                guidId = pcfp->guidId;
                pnsc->CloseStatusMonitor(&guidId);
                ReleaseObj(pnsc);
            }
        }

        PCONFOLDPIDL pidlUpdated; 
        cle.ccfe.ConvertToPidl(pidlUpdated);
        RefreshFolderItem(pidlFolder, pcfp, pidlUpdated); // Update the folder icon
    }
    else
    {
        g_ccl.ReleaseWriteLock();

        LPCWSTR pszName = pcfp->PszGetNamePointer();

        TraceTag(ttidShellFolder, "HrUpdateConnectionStatus: Connection not found "
            "in cache: %S. Connection deleted prior to notification?",
            pszName ? pszName : L"<name missing>");
    }

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrUpdateConnectionStatus");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrOnNotifyUpdateStatus
//
//  Purpose:    Process Connection sink notifications -- Try to make good
//              decisions about where we can ignore notifications to prevent
//              unnecessary requeries or icon updates.
//
//  Arguments:
//      pidlFolder [in] The pidl information for our folder.
//      pidlCached [in] Pidl generated from our connection cache
//      ncsNew     [in] The new connection state
//
//  Returns:
//
//  Author:     jeffspr   29 Apr 1999
//
//  Notes:
//
HRESULT HrOnNotifyUpdateStatus(
    const PCONFOLDPIDLFOLDER&  pidlFolder,
    const PCONFOLDPIDL&    pidlCached,
    NETCON_STATUS   ncsNew)
{
    HRESULT         hr      = S_OK;

    NETCFG_TRY
        PCONFOLDPIDL    pcfp    = pidlCached;

        Assert(!pidlCached.empty());

        // Filter out the multilink resume case, meaning that we get a
        // connecting/connected notification on a link that's already active.
        //
        if ( (NCS_CONNECTED == pcfp->ncs) &&
            ((ncsNew == NCS_CONNECTING) || NCS_CONNECTED == ncsNew))
        {
            TraceTag(ttidShellFolder, "HrOnNotifyUpdateStatus: Multi-link resume "
                     "('connecting' while 'connected')");
        }
        else
        {
            // If we're in the process of dialing, and the user cancels the
            // dialer, we'll get "disconnecting" state. This is normally the
            // same as "connected" icon-wise, but if we've never gotten connected,
            // we don't want the icon to flash "connected" before going to the
            // disconnected state
            //
            if ((pcfp->ncs == NCS_CONNECTING) && (ncsNew == NCS_DISCONNECTING))
            {
                TraceTag(ttidShellFolder, "HrOnNotifyUpdateStatus: Ignoring "
                    "disconnecting notification during cancel of incomplete dial");
            }
            else
            {
                // Ignore the update if the connection status hasn't really changed.
                //
                if (pcfp->ncs != ncsNew)
                {
                    // This is a true state change that we want to show
                    //
                    hr = HrUpdateConnectionStatus(pcfp, ncsNew, pidlFolder, FALSE, 0);
                }
            }
        }

    NETCFG_CATCH(hr)

    return hr;
}

HRESULT HrOnNotifyUpdateConnection(
    const PCONFOLDPIDLFOLDER& pidlFolder,
    const GUID *              pguid,
    NETCON_MEDIATYPE    ncm,
    NETCON_SUBMEDIATYPE ncsm,
    NETCON_STATUS       ncs,
    DWORD               dwCharacteristics,
    PCWSTR              pszwName,
    PCWSTR              pszwDeviceName,
    PCWSTR              pszwPhoneNumberOrHostAddress)
{
    HRESULT         hr              = S_OK;
    HRESULT         hrFind          = S_FALSE;
    BOOL            fIconChanged    = FALSE;

    NETCFG_TRY
        ConnListEntry   cle;
        PCONFOLDPIDL    pidlFind;
        PCONFOLDPIDL    pidlOld;
        PCONFOLDPIDLFOLDER pidlFolderAlloc;

        // If the folder pidl wasn't passed in, then we'll go through the hassle of
        // getting it ourselves.
        //
        if (pidlFolder.empty())
        {
            hr = HrGetConnectionsFolderPidl(pidlFolderAlloc);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        else
        {
            pidlFolderAlloc = pidlFolder;
        }

        g_ccl.AcquireWriteLock();

        // Find the connection using the GUID. Cast the const away from the GUID
        //
        hrFind = g_ccl.HrFindConnectionByGuid(pguid, cle);
        if (S_OK == hrFind)
        {
            TraceTag(ttidShellFolder, "Notify: Pre-Update %S, Ncm: %d, Ncs: %d, Char: 0x%08x",
                     cle.ccfe.GetName(), cle.ccfe.GetNetConMediaType(), cle.ccfe.GetNetConStatus(),
                     cle.ccfe.GetCharacteristics());

            // Did the icon state change?
            //
            if ((cle.ccfe.GetCharacteristics() & NCCF_SHOW_ICON) !=
                (dwCharacteristics & NCCF_SHOW_ICON))
            {
                fIconChanged = TRUE;
            }

            // Is this a new "set default" command? If so we need to search for any other defaults and 
            // unset them first
            if ( (dwCharacteristics & NCCF_DEFAULT) &&
                 !(cle.ccfe.GetCharacteristics() & NCCF_DEFAULT) )
            {
                PCONFOLDPIDL pidlDefault;

                // Not the end of the world if this doesn't work, so use a HrT.
                HRESULT hrT = g_ccl.HrUnsetCurrentDefault(pidlDefault);
                if (S_OK == hrT)
                {
                    // Let the shell know about the new state of affairs
                    GenerateEvent(SHCNE_UPDATEITEM, pidlFolderAlloc, pidlDefault, NULL);
                }
            }
				 
            // Save the old version of the pidl for the connection so we can use
            // it to determine which notifications we need.
            //
            CONFOLDENTRY &ccfe = cle.ccfe;
            // Very important to release the lock before doing any thing which
            // calls back into the shell.  (e.g. GenerateEvent)
            //
            cle.ccfe.ConvertToPidl(pidlOld);

            // Save old status so we know whether or not to send the status change
            // notifications
            //
            ccfe.UpdateData(CCFE_CHANGE_MEDIATYPE |
                            CCFE_CHANGE_STATUS |
                            CCFE_CHANGE_CHARACTERISTICS |
                            CCFE_CHANGE_NAME |
                            CCFE_CHANGE_DEVICENAME |
                            CCFE_CHANGE_PHONEORHOSTADDRESS,
                            ncm, 
                            ncsm,
                            ncs, 
                            dwCharacteristics, 
                            pszwName,
                            pszwDeviceName,
                            pszwPhoneNumberOrHostAddress); // NULL means go figure it out yourself...

            g_ccl.HrUpdateConnectionByGuid(pguid, cle);
            
            TraceTag(ttidShellFolder, "Notify: Post-Update %S, Ncm: %d, Ncs: %d, Char: 0x%08x, Icon change: %d",
                     ccfe.GetName(), ccfe.GetNetConMediaType(), ccfe.GetNetConStatus(),
                     ccfe.GetCharacteristics(),
                     fIconChanged);

            // Get the pidl for the connection so we can use it to notify
            // the shell further below.
            //
            ccfe.ConvertToPidl(pidlFind);

            g_ccl.ReleaseWriteLock();
        }
        else
        {
            // If the connection wasn't found in the cache, then it's likely that
            // the notification engine is giving us a notification for a connection
            // that hasn't yet been given to us.
            //
            g_ccl.ReleaseWriteLock();

            if (S_FALSE == hrFind)
            {
                TraceTag(ttidShellFolder, "Notify: Modify notification received on a connection we don't know about");
            }
            else
            {
                TraceTag(ttidShellFolder, "Notify: Modify: Error occurred during find of connection. hr = 0x%08x", hr);
            }
        }

        if (S_OK == hrFind)
        {
            if ( !(pidlFind.empty() || pidlOld.empty()) )
            {
                // Don't do the update if the status isn't changing.
                //
                // Don't want to croak on a bad return code here.
                //
                (VOID) HrOnNotifyUpdateStatus(pidlFolderAlloc, pidlOld, ncs);

                if (fIconChanged)
                {
                    hr = g_ccl.HrUpdateTrayIconByGuid(pguid, TRUE);
                    TraceTag(ttidShellFolder, "Returned from HrUpdateTrayIconByGuid", hr);
                }

                GenerateEvent(SHCNE_UPDATEITEM, pidlFolderAlloc, pidlFind, NULL);
            }

            // Update status monitor title (LAN case)
            CNetStatisticsCentral * pnsc = NULL;
            HRESULT hrStatmon = S_OK;

            hrStatmon = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, FALSE);
            if (S_OK == hrStatmon)
            {
                pnsc->UpdateTitle(pguid, pszwName);
                ReleaseObj(pnsc);
            }
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrOnNotifyUpdateConnection");
    return hr;
}


BOOL    g_fInRefreshAlready = FALSE;
BOOL    g_fRefreshAgain     = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   HrForceRefreshNoFlush
//
//  Purpose:    Force a refresh, but without wiping out all existing data.
//              This lets us keep as much state as possible intact, while
//              also letting us remove old items and adding new items (doing
//              the correct things with tray icons and such along the way).
//
//  Arguments:  
//      pidlFolder [in]     Our folder pidl
//
//  Returns:    
//
//  Author:     jeffspr   28 Aug 1999
//
//  Notes:      
//
HRESULT HrForceRefreshNoFlush(const PCONFOLDPIDLFOLDER& pidlFolder)
{
    HRESULT             hr              = S_OK;
    CConnectionList *   pccl            = NULL;

    NETCFG_TRY

        PCONFOLDPIDLFOLDER  pidlFolderAlloc;

        TraceTag(ttidShellFolder, "HrForceRefreshNoFlush");

        g_fRefreshAgain = TRUE;

        // If we're refreshing, then tell the thread already in here that it
        // should refresh again.
        //
        if (!g_fInRefreshAlready)
        {
            // This starts out being set, then we'll turn it off. If someone
            // turns it back on while we're in this long function, then we'll
            // do it again
            //
            while (g_fRefreshAgain)
            {
                g_fInRefreshAlready = TRUE; // We're now in refresh 
                g_fRefreshAgain     = FALSE;

                if (pidlFolder.empty())
                {
                    hr = HrGetConnectionsFolderPidl(pidlFolderAlloc);
                }
                else
                {
                    pidlFolderAlloc = pidlFolder;
                }

                if (SUCCEEDED(hr))
                {
                    // First, create the secondary connection list in order to compare the known
                    // state with the recently requested refresh state
                    //
                    pccl = new CConnectionList();
                    if (!pccl)
                    {
                        hr = E_OUTOFMEMORY;
                        AssertSz(FALSE, "Couldn't create CConnectionList in HrForceRefreshNoFlush");
                    }
                    else
                    {
                        PCONFOLDPIDLVEC         apidl;
                        PCONFOLDPIDLVEC         apidlCached;
                        PCONFOLDPIDLVEC::const_iterator iterLoop      = 0;

                        // Initialize the list. FALSE means we don't want to tie this
                        // list to the tray
                        //
                        pccl->Initialize(FALSE, FALSE);

                        // Retrieve the entries from the connection manager.
                        //
                        hr = pccl->HrRetrieveConManEntries(apidl);
                        if (SUCCEEDED(hr))
                        {
                            TraceTag(ttidShellFolder, "HrForceRefreshNoFlush -- %d entries retrieved", apidl.size);

                            // Loop through the connections. If there are new connections
                            // here that aren't in the cache, then add them and do the appropriate
                            // icon updates
                            //
                            for (iterLoop = apidl.begin(); iterLoop != apidl.end(); iterLoop++)
                            {
                                PCONFOLDPIDL   pcfp    = *iterLoop;
                                CONFOLDENTRY   ccfe;

                                // We don't need to update the wizard.
                                //
                                if (WIZARD_NOT_WIZARD == pcfp->wizWizard)
                                {
                                    // Convert to the confoldentry
                                    //
                                    hr = iterLoop->ConvertToConFoldEntry(ccfe);
                                    if (SUCCEEDED(hr))
                                    {
                                        // ConnListEntry cle;
                                        ConnListEntry cleDontCare;
                                        hr = g_ccl.HrFindConnectionByGuid(&(pcfp->guidId), cleDontCare);

                                        if (S_FALSE == hr)
                                        {
                                            if ((ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY) &&
                                                (ccfe.GetNetConStatus() == NCS_DISCONNECTED) && (ccfe.GetNetConMediaType() != NCM_NONE))
                                            {
                                                TraceTag(ttidShellFolder, "Ignoring transient incoming connection (new, but status is disconnected)");
                                            }
                                            else
                                            {
                                                TraceTag(ttidShellFolder, "HrForceRefreshNoFlush -- New connection: %S", ccfe.GetName());

                                                // Insert the connection in the connection list
                                                //
                                                hr = g_ccl.HrInsert(ccfe);
                                                if (SUCCEEDED(hr))
                                                {
                                                    // the connection list has taken control of this structure
                                                    //
                                                    TraceTag(ttidShellFolder,
                                                             "HrForceRefreshNoFlush -- successfully added connection to list. Notifying shell");

                                                    // don't delete ccfe on success. g_ccl owns it after an
                                                    // insert.
                                                    //
                                                    GenerateEvent(SHCNE_CREATE, pidlFolderAlloc, *iterLoop, NULL);
                                                }
                                                else
                                                {
                                                    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrForceRefreshNoFlush -- Failed to insert connection into shell");
                                                }
                                            }
                                        }
                                        else
                                        {
                                            // Update the connection properties for this connection
                                            //
                                            hr = HrOnNotifyUpdateConnection(
                                                pidlFolderAlloc,
                                                &(ccfe.GetGuidID()),
                                                ccfe.GetNetConMediaType(),
                                                ccfe.GetNetConSubMediaType(),
                                                ccfe.GetNetConStatus(),
                                                ccfe.GetCharacteristics(),
                                                ccfe.GetName(),
                                                ccfe.GetDeviceName(),
                                                ccfe.GetPhoneOrHostAddress());
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            TraceHr(ttidShellFolder, FAL, hr, FALSE,
                                    "HrForceRefreshNoFlush -- Failed to retrieve Conman entries");
                        }

                        // Retrieve a pidl list from the connection cache. This should not force a
                        // reload (which would defeat the purpose of the whole operation).
                        //
                        hr = g_ccl.HrRetrieveConManEntries(apidlCached);
                        if (SUCCEEDED(hr))
                        {
                            for (iterLoop = apidlCached.begin(); iterLoop != apidlCached.end(); iterLoop++)
                            {
                                CONFOLDENTRY ccfe;

                                Assert(!iterLoop->empty());

                                if (!iterLoop->empty())
                                {
                                    const PCONFOLDPIDL& pcfp = *iterLoop;

                                    // If it's not a wizard pidl, then update the
                                    // icon data.
                                    //
                                    if (WIZARD_NOT_WIZARD == pcfp->wizWizard)
                                    {
                                        ConnListEntry   cle;
                                        BOOL            fDeadIncoming   = FALSE;

                                        hr = pccl->HrFindConnectionByGuid(&(pcfp->guidId), cle);
                                        if (hr == S_OK)
                                        {
                                            DWORD               dwChars = cle.ccfe.GetCharacteristics();
                                            NETCON_STATUS       ncs     = cle.ccfe.GetNetConStatus();
                                            NETCON_MEDIATYPE    ncm     = cle.ccfe.GetNetConMediaType();

                                            // Figure out whether this is a transient incoming connection
                                            // (enumerated, but disconnected)
                                            //
                                            if ((ncs == NCS_DISCONNECTED) &&
                                                (ncm != NCM_NONE) &&
                                                (dwChars & NCCF_INCOMING_ONLY))
                                            {
                                                fDeadIncoming = TRUE;
                                            }
                                        }

                                        // If it was either not found or is a dead incoming connection
                                        // (disconnected), blow it away from the list.
                                        //
                                        if ((S_FALSE == hr) || (fDeadIncoming))
                                        {
                                            hr = iterLoop->ConvertToConFoldEntry(ccfe);
                                            if (SUCCEEDED(hr))
                                            {
                                                hr = HrDeleteFromCclAndNotifyShell(pidlFolderAlloc,
                                                        *iterLoop, ccfe);

                                                // Assuming that succeeded (or hr will be S_OK if
                                                // the HrGet... wasn't called)
                                                //
                                                if (SUCCEEDED(hr))
                                                {
                                                    GenerateEvent(SHCNE_DELETE, pidlFolderAlloc,
                                                            *iterLoop, NULL);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        pccl->Uninitialize();

                        delete pccl;
                        pccl = NULL;
                    }
                }

                if (g_fRefreshAgain)
                {
                    TraceTag(ttidShellFolder, "Looping back for another refresh since g_fRefreshAgain got set");
                }

            } // end while (g_fRefreshAgain)

            // Mark us as not being in the function
            //
            g_fInRefreshAlready = FALSE;
        }
        else
        {
            TraceTag(ttidShellFolder, "Marking for additional refresh and exiting");
        }

    NETCFG_CATCH(hr)

    TraceHr(ttidShellFolder, FAL, hr, FALSE, "HrForceRefreshNoFlush");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrShellView_GetSelectedObjects
//
//  Purpose:    Get the selected data objects. We only care about the first
//              one (we'll ignore the rest)
//
//  Arguments:
//      hwnd            [in]    Our window handle
//      papidlSelection [out]   Return array for selected pidls
//      lpcidl          [out]   Count of returned pidls
//
//  Returns:    S_OK if 1 or more items are selected.
//              S_FALSE if 0 items are selected
//              OLE HRESULT otherwise
//
//  Author:     jeffspr   13 Jan 1998
//
//  Notes:
//
HRESULT HrShellView_GetSelectedObjects(
    HWND                hwnd,
    PCONFOLDPIDLVEC&    apidlSelection)
{
    HRESULT         hr      = S_OK;
    LPCITEMIDLIST * apidl   = NULL;
    UINT            cpidl   = 0;

    // Get the selected object list from the shell
    //
    cpidl = ShellFolderView_GetSelectedObjects(hwnd, &apidl);

    // If the GetSelectedObjects failed, NULL out the return
    // params.
    //
    if (-1 == cpidl)
    {
        cpidl = 0;
        apidl = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // If no items were selected, return S_FALSE
        //
        if (0 == cpidl)
        {
            Assert(!apidl);
            hr = S_FALSE;
        }
    }

    // Fill in the out params
    //
    if (SUCCEEDED(hr))
    {
        hr = PConfoldPidlVecFromItemIdListArray(apidl, cpidl, apidlSelection);
        SHFree(apidl);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "HrShellView_GetSelectedObjects");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetConnectionPidlWithRefresh
//
//  Purpose:    Utility function used by HrCreateDesktopIcon and HrLaunchConnection
//
//  Arguments:
//              guidId:     GUID of the connection
//              ppidlCon:   PIDL of the connection, if found
//
//  Returns:    S_OK if succeeded
//              S_FALSE if the GUID does not match any existing connection
//              standard error code otherwise
//
//  Author:     tongl   19 Feb 1999
//
//  Notes:
//

HRESULT HrGetConnectionPidlWithRefresh(const GUID& guidId,
                                       PCONFOLDPIDL& ppidlCon)
{
    HRESULT hr = S_OK;

    NETCFG_TRY

        PCONFOLDPIDL            pidlCon;
        CConnectionFolderEnum * pCFEnum         = NULL;
        DWORD                   dwFetched       = 0;

        // refresh the folder before we enumerate
        PCONFOLDPIDLFOLDER pidlEmpty;
        hr = HrForceRefreshNoFlush(pidlEmpty);
        if (SUCCEEDED(hr))
        {
            // Create the IEnumIDList object (CConnectionFolderEnum)
            //
            hr = CConnectionFolderEnum::CreateInstance (
                    IID_IEnumIDList,
                    (VOID **)&pCFEnum);

            if (SUCCEEDED(hr))
            {
                Assert(pCFEnum);

                // Call the PidlInitialize function to allow the enumeration
                // object to copy the list.
                //
                pCFEnum->PidlInitialize(TRUE, pidlEmpty, CFCOPT_ENUMALL);

                while (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    // Clear out the previous results, if any.
                    //
                    dwFetched   = 0;

                    // Get the next connection
                    //
                    LPITEMIDLIST pitemIdList;
                    hr = pCFEnum->Next(1, &pitemIdList, &dwFetched);
                    pidlCon.InitializeFromItemIDList(pitemIdList);
                    
                    if (S_OK == hr)
                    {
                        if (pidlCon->guidId == guidId)
                        {
                            hr = S_OK;
                            ppidlCon = pidlCon;
                            break;
                        }
                    }
                }
            }

            ReleaseObj(pCFEnum);
        }

    NETCFG_CATCH(hr)

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRenameConnectionInternal
//
//  Purpose:    The shared portion for renaming a connection through the
//              connections folder UI and the export function
//
//  Arguments:
//      pszInput   [in]  String to duplicate
//      cchInput   [in]  Count of characters to copy (not including null term)
//      ppszOutput [out] Return pointer for the newly allocated string.
//
//  Returns:
//
//  Author:     tongl   26 May 1999
//
//  Notes:
//

HRESULT HrRenameConnectionInternal(
    const PCONFOLDPIDL& pidlCon,
    const PCONFOLDPIDLFOLDER& pidlFolderRoot,
    LPCWSTR         pszNewName,
    BOOL            fRaiseError,
    HWND            hwndOwner,
    PCONFOLDPIDL&   ppidlOut)
{
    HRESULT             hr          = S_OK;

    NETCFG_TRY

        INetConnection *    pNetCon     = NULL;
        PCONFOLDPIDL        pidlNew;
        BOOL                fRefresh    = FALSE;
        BOOL                fActivating = FALSE;
        CONFOLDENTRY        ccfe;
        PCWSTR              pszReservedName;

        if (fRaiseError)
        {
            Assert(hwndOwner);
        }

        Assert(FImplies(fRaiseError,IsWindow(hwndOwner)));
        Assert(pszNewName);

        if ( (pidlCon.empty()) || !pszNewName )
        {
            hr = E_INVALIDARG;
        }
        else
        {
            hr = pidlCon.ConvertToConFoldEntry(ccfe);
            if (SUCCEEDED(hr))
            {
                // Do a case sensitive compare to see if the new name is exactly
                // the same as the old one. If yes then, we ignore renaming.
                //

                if (lstrcmpW(ccfe.GetName(), pszNewName) == 0)
                {
                    hr = S_FALSE;
                    // Create a dupe pidl, if needed
                    if (!ppidlOut.empty())                
                    {
                        pidlNew.ILClone(pidlCon);
                    }
                }
                else
                {
                    // New name is either completely different from the old one or
                    // differs just in the case.
                    //

                    CONFOLDENTRY cfEmpty;
                    hr = HrCheckForActivation(pidlCon, cfEmpty, &fActivating);
                    if (S_OK == hr)
                    {
                        if (fActivating)
                        {
                            // You can't rename an activating connection
                            //
                            TraceTag(ttidShellFolder, "Can not rename an activating connection");
                            hr = E_FAIL;

                            if (fRaiseError)
                            {
                                NcMsgBox(_Module.GetResourceInstance(),
                                         hwndOwner,
                                         IDS_CONFOLD_ERROR_RENAME_ACTIVATING_CAPTION,
                                         IDS_CONFOLD_ERROR_RENAME_ACTIVATING,
                                         MB_ICONEXCLAMATION);

                            }
                        }
                        else
                        {
                            // If the old and new names differ in their case only then, we don't
                            // need to check if the new name already exists.

                            if (lstrcmpiW(ccfe.GetName(), pszNewName) == 0)
                            {
                                // New name differs from the old name in case only.
                                hr = S_FALSE;
                            }
                            else
                            {
                                 pszReservedName = SzLoadIds( IDS_CONFOLD_INCOMING_CONN );

                                 if ( lstrcmpiW(pszNewName, pszReservedName) == 0 ) {
                                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
                                 }
                                 else {
                                    // New name is completely different, need to check if 
                                    // we already have the new name in our list
                                    //
                                    ConnListEntry cleDontCare;
 
                                    hr = g_ccl.HrFindConnectionByName((PWSTR)pszNewName, cleDontCare);
                                 }
                            }

//                            if (SUCCEEDED(hr))
                            {
                                // If there's no duplicate in the list, attempt to set the
                                // new name in the connection
                                //
                                if (hr == S_FALSE)
                                {
                                    // Convert our persist data back to a INetConnection pointer.
                                    //
                                    hr = HrNetConFromPidl(pidlCon, &pNetCon);
                                    if (SUCCEEDED(hr))
                                    {
                                        Assert(pNetCon);

                                        // Call the connection's Rename with the new name
                                        //
                                        hr = pNetCon->Rename(pszNewName);
                                        if (SUCCEEDED(hr))
                                        {
                                            GUID guidId;    
                                            
                                            fRefresh = TRUE;

                                            // Update the name in the cache
                                            //
                                            guidId = pidlCon->guidId;
                                            
                                            // Note: There is a race condition with notify.cpp:
                                            //  CConnectionNotifySink::ConnectionRenamed\HrUpdateNameByGuid can also update this
                                            hr = g_ccl.HrUpdateNameByGuid(
                                                &guidId,
                                                (PWSTR) pszNewName,
                                                pidlNew,
                                                TRUE);  // Force the issue. it's an update, not a request

                                            GenerateEvent(
                                                SHCNE_RENAMEITEM,
                                                pidlFolderRoot,
                                                pidlCon, 
                                                pidlNew.GetItemIdList());
                                        }

                                        if (fRaiseError && FAILED(hr))
                                        {
                                            // Leave hr at this value, as it will cause the UI to leave
                                            // the object in the "rename in progress" state, so the user
                                            // can change it again and hit enter.
                                            //
                                            if (HRESULT_FROM_WIN32(ERROR_DUP_NAME) == hr)
                                            {
                                                // Bring up the message box for the known DUPLICATE_NAME
                                                // error
                                                (void) NcMsgBox(
                                                    _Module.GetResourceInstance(),
                                                    hwndOwner,
                                                    IDS_CONFOLD_RENAME_FAIL_CAPTION,
                                                    IDS_CONFOLD_RENAME_DUPLICATE,
                                                    MB_OK | MB_ICONEXCLAMATION);
                                            }
                                            else
                                            {
                                                // Bring up the generic failure error, with the win32 text
                                                //
                                                (void) NcMsgBoxWithWin32ErrorText(
                                                    DwWin32ErrorFromHr (hr),
                                                    _Module.GetResourceInstance(),
                                                    hwndOwner,
                                                    IDS_CONFOLD_RENAME_FAIL_CAPTION,
                                                    IDS_TEXT_WITH_WIN32_ERROR,
                                                    IDS_CONFOLD_RENAME_OTHER_FAIL,
                                                    MB_OK | MB_ICONEXCLAMATION);
                                            }
                                        }

                                        ReleaseObj(pNetCon);    // RAID 180252
                                    }
                                }
                                else
                                {
                                    if ( hr == HRESULT_FROM_WIN32(ERROR_INVALID_NAME) ) {

                                        if(fRaiseError)
                                        {
                                            // Bring up the invalid name message box.
                                            // error
                                            (void) NcMsgBox(
                                                _Module.GetResourceInstance(),
                                                hwndOwner,
                                                IDS_CONFOLD_RENAME_FAIL_CAPTION,
                                                IDS_CONFOLD_RENAME_INCOMING_CONN,
                                                MB_OK | MB_ICONEXCLAMATION);
                                        }
                                    }
                                    else {
                                        // A duplicate name was found. Return an error.
                                        //
                                        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);

                                        if(fRaiseError)
                                        {
                                            // Bring up the message box for the known DUPLICATE_NAME
                                            // error
                                            (void) NcMsgBox(
                                                _Module.GetResourceInstance(),
                                                hwndOwner,
                                                IDS_CONFOLD_RENAME_FAIL_CAPTION,
                                                IDS_CONFOLD_RENAME_DUPLICATE,
                                                MB_OK | MB_ICONEXCLAMATION);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (S_OK == hr)
        {
            Assert(!pidlNew.empty());
            ppidlOut = pidlNew;
        }
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }
        // Fill in the return parameter
        //

    NETCFG_CATCH(hr)

    TraceHr(ttidError, FAL, hr, FALSE, "HrRenameConnectionInternal");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\trytofix.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       T R Y T O F I X . C P P
//
//  Contents:   Code for the "repair" command
//
//  Notes:
//
//  Author:     nsun Jan 2001
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "wzcsapi.h"
#include "nsbase.h"
#include "ncstring.h"
#include "nsres.h"
#include "ncperms.h"
#include "ncnetcon.h"
#include "repair.h"

extern "C"
{
    #include <dhcpcapi.h>
    extern DWORD DhcpStaticRefreshParams(IN LPWSTR Adapter);
    extern DWORD DhcpAcquireParametersByBroadcast(IN LPWSTR AdapterName);
}

#include <dnsapi.h>
#include "nbtioctl.h"

HRESULT HrGetAdapterSettings(LPCWSTR pszGuid, BOOL * pfDhcp, DWORD * pdwIndex);
HRESULT PurgeNbt(HANDLE NbtHandle);
HRESULT ReleaseRefreshNetBt(HANDLE NbtHandle);

//+---------------------------------------------------------------------------
//
//  Function:   HrTryToFix
//
//  Purpose:    Do the fix
//
//  Arguments:
//      guidConnection      [in]  guid of the connection to fix
//      strMessage  [out] the message containing the results
//
//  Returns: 
//           S_OK  succeeded
//           S_FALSE some fix operation failed
//           
HRESULT HrTryToFix(GUID & guidConnection, tstring & strMessage)
{
    HRESULT hr = S_OK;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fRet = TRUE;
    WCHAR   wszGuid[c_cchGuidWithTerm] = {0};
    tstring strFailures = L"";
    
    strMessage = L"";

    ::StringFromGUID2(guidConnection, 
                    wszGuid,
                    c_cchGuidWithTerm);

    BOOL fDhcp = FALSE;
    DWORD dwIfIndex = 0;

    //re-autheticate for 802.1X. This is a asynchronous call and there is
    //no meaningful return value. So ignore the return value
    WZCEapolReAuthenticate(NULL, wszGuid);
    
    //only do the fix when TCP/IP is enabled for this connection
    //also get the interface index that is needed when flushing Arp table
    hr = HrGetAdapterSettings(wszGuid, &fDhcp, &dwIfIndex);
    if (FAILED(hr))
    {
        strMessage = SzLoadIds((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? 
                                IDS_FIX_NO_TCP : IDS_FIX_TCP_FAIL);
        return S_FALSE;
    }

    //renew the lease if DHCP is enabled
    if (fDhcp)
    {
        dwRet = DhcpAcquireParametersByBroadcast(wszGuid);
        if (ERROR_SUCCESS != dwRet)
        {
            TraceError("DhcpAcquireParametersByBroadcast", HRESULT_FROM_WIN32(dwRet));
            strFailures += SzLoadIds(IDS_FIX_ERR_RENEW_DHCP);
            hr = S_FALSE;
        }
    }
    

    //purge the ARP table if the user is admin or Netcfg Ops
    //Other user are not allowed to do this
    if (FIsUserAdmin() || FIsUserNetworkConfigOps())
    {
        dwRet = FlushIpNetTable(dwIfIndex);
        if (NO_ERROR != dwRet)
        {
            TraceError("FlushIpNetTable", HRESULT_FROM_WIN32(dwRet));
            strFailures += SzLoadIds(IDS_FIX_ERR_FLUSH_ARP);
            hr = S_FALSE;
        }
    }
    

    //puge the NetBT table and Renew name registration
    HANDLE      NbtHandle = INVALID_HANDLE_VALUE;
    if (SUCCEEDED(OpenNbt(wszGuid, &NbtHandle)))
    {
        if (FAILED(PurgeNbt(NbtHandle)))
        {
            strFailures += SzLoadIds(IDS_FIX_ERR_PURGE_NBT);
            hr = S_FALSE;
        }

        if (FAILED(ReleaseRefreshNetBt(NbtHandle)))
        {
            strFailures += SzLoadIds(IDS_FIX_ERR_RR_NBT);
            hr = S_FALSE;
        }

        NtClose(NbtHandle);
        NbtHandle = INVALID_HANDLE_VALUE;
    }
    else
    {
        strFailures += SzLoadIds(IDS_FIX_ERR_PURGE_NBT);
        strFailures += SzLoadIds(IDS_FIX_ERR_RR_NBT);
        hr = S_FALSE;
    }

    //flush DNS cache
    fRet = DnsFlushResolverCache();
    if (!fRet)
    {
        strFailures += SzLoadIds(IDS_FIX_ERR_FLUSH_DNS);
        hr = S_FALSE;
    }

    //re-register DNS name 
    dwRet = DhcpStaticRefreshParams(NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        strFailures += SzLoadIds(IDS_FIX_ERR_REG_DNS);
        hr = S_FALSE;
    }

    if (S_OK == hr)
    {
        strMessage = SzLoadIds(IDS_FIX_SUCCEED);
    }
    else
    {
        PCWSTR pszFormat  = SzLoadIds(IDS_FIX_ERROR_FORMAT);
        PWSTR  pszText = NULL;
        LPCWSTR  pcszFailures = strFailures.c_str();
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, (va_list *)&pcszFailures);
        if (pszText)
        {
            strMessage = pszText;
            LocalFree(pszText);
        }
        else
        {
            strMessage = SzLoadIds(IDS_FIX_ERROR);
        }
        
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   OpenNbt
//
//  Purpose:    Open the NetBT driver
//
//  Arguments:
//              pwszGuid        [in]    guid of the adapter
//              pHandle         [out]   contains the handle of the Netbt driver 
//
//  Returns:    
//           
HRESULT OpenNbt(
            LPWSTR pwszGuid, 
            HANDLE * pHandle)
{
    const WCHAR         c_szNbtDevicePrefix[] = L"\\Device\\NetBT_Tcpip_";
    HRESULT             hr = S_OK;
    tstring             strDevice;
    HANDLE              StreamHandle = NULL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;

    Assert(pHandle);
    Assert(pwszGuid);

    strDevice = c_szNbtDevicePrefix;
    strDevice += pwszGuid;

    RtlInitUnicodeString(&uc_name_string, strDevice.c_str());

    InitializeObjectAttributes (&ObjectAttributes,
                                &uc_name_string,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | GENERIC_EXECUTE,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    if (NT_SUCCESS(status))
    {
        *pHandle = StreamHandle;
    }
    else
    {
        *pHandle = INVALID_HANDLE_VALUE;
        hr = E_FAIL;
    }

    TraceError("OpenNbt", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   PurgeNbt
//
//  Purpose:    Purge the NetBt cache
//
//  Arguments:  NbtHandle   [in]    handle of the Netbt driver
//
//  Returns: 
//           
HRESULT PurgeNbt(HANDLE NbtHandle)
{
    HRESULT hr = S_OK;
    CHAR    Buffer = 0;
    DWORD   dwBytesOut = 0;
    
    if (!DeviceIoControl(NbtHandle,
                IOCTL_NETBT_PURGE_CACHE,
                NULL,
                0,
                &Buffer,
                1,
                &dwBytesOut,
                NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    TraceError("PurgeNbt", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseRefreshNetBt
//
//  Purpose:    release and then refresh the name on the WINS server
//
//  Arguments:  NbtHandle   [in]    handle of the Netbt driver
//
//  Returns: 
//           
HRESULT ReleaseRefreshNetBt(HANDLE NbtHandle)
{
    HRESULT hr = S_OK;
    CHAR    Buffer = 0;
    DWORD   dwBytesOut = 0;
    if (!DeviceIoControl(NbtHandle,
                IOCTL_NETBT_NAME_RELEASE_REFRESH,
                NULL,
                0,
                &Buffer,
                1,
                &dwBytesOut,
                NULL))
    {
        DWORD dwErr = GetLastError();

        //RELEASE_REFRESH can at most do every two minutes
        //So if the user perform 2 RELEASE_REFRESH within 2 minutes, the 2nd
        //one will fail with ERROR_SEM_TIMEOUT. We ignore this particular error
        if (ERROR_SEM_TIMEOUT != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    
    TraceError("ReleaseRefreshNetBt", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetAdapterSettings
//
//  Purpose:    Query the stack to know whether dhcp is enabled
//
//  Arguments:  pszGuid    [in]    guid of the adapter
//              pfDhcp     [out]   contains whether dhcp is enabled
//              pdwIndex   [out]   contains the index of this adapter
//
//  Returns: 
//           
HRESULT HrGetAdapterSettings(LPCWSTR pszGuid, BOOL * pfDhcp, DWORD * pdwIndex)
{
    HRESULT hr = S_OK;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    DWORD dwOutBufLen = 0;
    DWORD dwRet = ERROR_SUCCESS;

    Assert(pfDhcp);
    Assert(pszGuid);

    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (dwRet == ERROR_BUFFER_OVERFLOW)
    {
        pAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc(dwOutBufLen);
        if (NULL == pAdapterInfo)
            return E_OUTOFMEMORY;
    }
    else if (ERROR_SUCCESS == dwRet)
    {
        return E_FAIL;
    }
    else
    {
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (ERROR_SUCCESS != dwRet)
    {
        CoTaskMemFree(pAdapterInfo);
        return HRESULT_FROM_WIN32(dwRet);
    }

    BOOL fFound = FALSE;
    PIP_ADAPTER_INFO pAdapterInfoEnum = pAdapterInfo;
    while (pAdapterInfoEnum)
    {
        USES_CONVERSION;
        
        if (lstrcmp(pszGuid, A2W(pAdapterInfoEnum->AdapterName)) == 0)
        {
            if (pdwIndex)
            {
                *pdwIndex = pAdapterInfoEnum->Index;
            }
            
            *pfDhcp = pAdapterInfoEnum->DhcpEnabled;
            fFound = TRUE;
            break;
        }
        
        pAdapterInfoEnum = pAdapterInfoEnum->Next;
    }

    CoTaskMemFree(pAdapterInfo);

    if (!fFound)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

HRESULT RepairConnectionInternal(
                    GUID & guidConnection,
                    LPWSTR * ppszMessage)
{

    if (NULL != ppszMessage && 
        IsBadWritePtr(ppszMessage, sizeof(LPWSTR)))
    {
        return E_INVALIDARG;
    }

    if (ppszMessage)
    {
        *ppszMessage = NULL;
    }

    if (!FHasPermission(NCPERM_Repair))
    {
        return E_ACCESSDENIED;
    }

    // Get the net connection manager
    CComPtr<INetConnectionManager> spConnMan;
    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                          CLSCTX_ALL,
                          IID_INetConnectionManager,
                          (LPVOID *)&spConnMan);

    if (FAILED(hr))
    {
        return hr;
    }

    Assert(spConnMan.p);

    NcSetProxyBlanket(spConnMan);

    CComPtr<IEnumNetConnection> spEnum;
    
    hr = spConnMan->EnumConnections(NCME_DEFAULT, &spEnum);
    spConnMan = NULL;

    if (FAILED(hr))
    {
        return hr;
    }

    Assert(spEnum.p);

    BOOL fFound = FALSE;
    ULONG ulCount = 0;
    INetConnection * pConn = NULL;
    spEnum->Reset();

    do
    {
        NETCON_PROPERTIES* pProps = NULL;
            
        hr = spEnum->Next(1, &pConn, &ulCount);
        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            NcSetProxyBlanket(pConn);

            hr = pConn->GetProperties(&pProps);
            if (S_OK == hr)
            {
                if (IsEqualGUID(pProps->guidId, guidConnection))
                {
                    fFound = TRUE;

                    //we only support LAN and Bridge adapters
                    if (NCM_LAN != pProps->MediaType && NCM_BRIDGE != pProps->MediaType)
                    {
                        hr = CO_E_NOT_SUPPORTED;
                    }

                    break;
                }
                    
                FreeNetconProperties(pProps);
            }

            pConn->Release();
            pConn = NULL;
        }
    }while (SUCCEEDED(hr) && 1 == ulCount);

    if (!fFound)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    if (FAILED(hr))
    {
        return hr;
    }

    LPWSTR psz = NULL;
    tstring strMessage;
    hr = HrTryToFix(guidConnection, strMessage);

    if (ppszMessage && S_OK != hr && strMessage.length())
    {
        psz = (LPWSTR) LocalAlloc(LPTR, (strMessage.length() + 1) * sizeof(WCHAR));
        lstrcpy(psz, strMessage.c_str());
        *ppszMessage = psz;
    }


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\advcfg.h ===
#ifndef _ADVCFG_H
#define _ADVCFG_H

#pragma once

HRESULT HrDoAdvCfgDlg(HWND hwndParent);

#endif //!_ADVCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\webview.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once

class CConnectionFolder;

class CEnumArray : 
    public CComObjectRootEx <CComObjectThreadModel>,
    public IEnumIDList
{
public:
    BEGIN_COM_MAP(CEnumArray)
        COM_INTERFACE_ENTRY(IEnumIDList)
    END_COM_MAP()

    static HRESULT CreateInstance(IEnumIDList** ppv, LPCITEMIDLIST *ppidl, UINT cItems);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    CEnumArray();
    virtual ~CEnumArray();

    LPCITEMIDLIST *_ppidl;        // this holds aliases to the pidls, don't free them

private:
    LONG  _cRef;
    ULONG _ulIndex;
    UINT _cItems;
};

#define TOPLEVEL TRUE
#define TASKLEVEL FALSE

#define DECLARE_WEBVIEW_INVOKE_HANDLER(cmd) \
    static HRESULT cmd (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

#define DECLARE_CANSHOW_HANDLER(cmd) \
    static HRESULT cmd (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    
#define DECLARE_WEBVIEW_HANDLERS(cmd) \
    DECLARE_WEBVIEW_INVOKE_HANDLER(On##cmd); \
    DECLARE_CANSHOW_HANDLER(CanShow##cmd);

#define INVOKE_HANDLER_OF(cmd) CNCWebView::On##cmd
#define CANSHOW_HANDLER_OF(cmd) CNCWebView::CanShow##cmd

#define IMPLEMENT_WEBVIEW_INVOKE_HANDLER(clsname, cmd, verb)  \
HRESULT clsname##::##cmd (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc) \
{                                            \
    return WebviewVerbInvoke(verb, pv, psiItemArray); \
}               

#define IMPLEMENT_CANSHOW_HANDLER(level, clsname, cmd, verb)  \
HRESULT clsname##::##cmd (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState) \
{                                            \
    return WebviewVerbCanInvoke(verb, pv, psiItemArray, fOkToBeSlow, puisState, level); \
}               

#define IMPLEMENT_WEBVIEW_HANDLERS(level, clsname, verb)  \
    IMPLEMENT_WEBVIEW_INVOKE_HANDLER(clsname, On##verb, verb) \
    IMPLEMENT_CANSHOW_HANDLER(level, clsname, CanShow##verb, verb)

#define MAXOTHERPLACES 5

class CNCWebView
{
private:
    // PIDLs to the folders in the webview other places section
    LPITEMIDLIST m_apidlOtherPlaces[MAXOTHERPLACES];

    CConnectionFolder* m_pConnectionFolder;

public:
    CNCWebView(CConnectionFolder* pConnectionFolder);
    ~CNCWebView();

    STDMETHOD(CreateOtherPlaces)(LPDWORD pdwCount);
    STDMETHOD(DestroyOtherPlaces)();

    STDMETHOD(RealMessage)(UINT uMsg, WPARAM wParam, LPARAM lParam);

    STDMETHOD(OnGetWebViewLayout)(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    STDMETHOD(OnGetWebViewContent)(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    STDMETHOD(OnGetWebViewTasks)(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);

public:
    static HRESULT WebviewVerbInvoke(DWORD dwVerbID, IUnknown* pv, IShellItemArray *psiItemArray);
    static HRESULT WebviewVerbCanInvoke(DWORD dwVerbID, IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState, BOOL bLevel);

    DECLARE_WEBVIEW_INVOKE_HANDLER(OnNull);

    DECLARE_WEBVIEW_HANDLERS(CMIDM_NEW_CONNECTION);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_FIX);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_CONNECT);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_DISCONNECT);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_ENABLE);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_DISABLE);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_RENAME);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_DELETE);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_STATUS);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_PROPERTIES);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_HOMENET_WIZARD);
    DECLARE_WEBVIEW_HANDLERS(CMIDM_NET_TROUBLESHOOT);
};

HRESULT HrIsWebViewEnabled();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\conprops.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N P R O P S . H
//
//  Contents:   Connection Properties code
//
//  Notes:
//
//  Author:     scottbri    4 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _CONPROPS_H_
#define _CONPROPS_H_

VOID    ActivatePropertyDialog(INetConnection * pconn);
HRESULT HrRaiseConnectionProperties(HWND hwnd, INetConnection * pconn);

enum CDFLAG
{
    CD_CONNECT,
    CD_DISCONNECT,
};

HRESULT HrConnectOrDisconnectNetConObject(HWND hwnd, INetConnection * pconn,
                                          CDFLAG Flag);

#endif  // _CONPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\connutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O N N U T I L . H 
//
//  Contents:   
//
//  Notes:      
//
//  Author:     tongl   29 April 1999
//
//----------------------------------------------------------------------------

#pragma once

EXTERN_C
HRESULT APIENTRY HrLaunchConnection(const GUID& guidId);

HIMAGELIST WINAPI ImageList_LoadImageAndMirror(
				HINSTANCE hi, 
				LPCTSTR lpbmp, 
				int cx, 
				int cGrow, 
				COLORREF crMask, 
				UINT uType, 
				UINT uFlags);

#define ImageList_LoadBitmapAndMirror(hi, lpbmp, cx, cGrow, crMask) \
	ImageList_LoadImageAndMirror(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\folder\webview.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Implementation of INetConnectionNotifySink
//
//  Notes:
//
//  Author:     shaunco   21 Aug 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "foldinc.h"
#include "webview.h"
#include "foldres.h"    // Folder resource IDs
#include "nsres.h"      // Netshell strings
#include "cfutils.h"    // Connection folder utility functions

#include "wininet.h"
#include "cmdtable.h"
#include "droptarget.h"

// WVTI_ENTRY             - Use for tasks that want to be displayed when something is selected, where the UI is 
//                          independent of the selection
// WVTI_ENTRY_NOSELECTION - Use for tasks that want to be displayed when nothing is selected
// WVTI_ENTRY_FILE        - Use for tasks that want to be displayed when a file is selected
// WVTI_ENTRY_TITLE       - Use for tasks that want to be displayed when something is selected, 
//                          and you want different UI depending on the selection or if you want to control the title, 
//                          but the tooltip is constant
// WVTI_ENTRY_ALL         - Use this one if you want the same text everywhere
// WVTI_ENTRY_ALL_TITLE   - Use this one if you want to control everything
// WVTI_HEADER            - Use this one for a header
// WVTI_HEADER_ENTRY      - Use this one for a header that changes with the selection

const WVTASKITEM c_ConnFolderGlobalTaskHeader = 
    WVTI_HEADER(L"netshell.dll",                  // module where the resources are
                IDS_WV_TITLE_NETCONFOLDERTASKS,   // static header for all cases
                IDS_WV_TITLE_NETCONFOLDERTASKS_TT // tooltip
                );

const WVTASKITEM c_ConnFolderItemTaskHeader = 
    WVTI_HEADER(L"netshell.dll",                   // module where the resources are
                IDS_WV_TITLE_NETCONITEMTASKS,      // static header for all cases
                IDS_WV_TITLE_NETCONITEMTASKS_TT    // tooltip
                );

const WVTASKITEM c_ConnFolderIntro = 
    WVTI_HEADER(L"netshell.dll",                   // module where the resources are
                IDS_WV_NETCON_INTRO,               // static header for all cases
                IDS_WV_NETCON_INTRO                // tooltip
                );


// Use for tasks that want to be displayed when a file is selected
//#define WVTI_ENTRY_FILE(g, d, t, p, i, s, k) {&(g), (d), (0), (t), (0), (0), (p), (i), (s), (k)}

#define NCWVIEW_ENTRY_FILE(t, mt, i, cmd) \
    {&GUID_NULL, L"netshell.dll", (0), (t), (0), (mt), (IDS_##cmd), (i), (CNCWebView::CanShow##cmd), (CNCWebView::On##cmd) }


const WVTASKITEM c_ConnFolderGlobalTaskList[] =
{
    WVTI_ENTRY_ALL( 
        GUID_NULL,                       // command GUID 
                                         // Future thinking - something like this is the way Context Menus are done.
                                         // Be a way to get access to DefView implementation of functions - IUICmdTarget.
        L"netshell.dll",                 // module
        IDS_WV_MNCWIZARD,                // text
        IDS_CMIDM_NEW_CONNECTION,        // tooltip
        IDI_WV_MNCWIZARD,                // icon
        CANSHOW_HANDLER_OF(CMIDM_NEW_CONNECTION),
        INVOKE_HANDLER_OF(CMIDM_NEW_CONNECTION)),
    
    WVTI_ENTRY_ALL( 
        GUID_NULL,                       // command GUID 
        L"netshell.dll",                 // module
        IDS_WV_HOMENET,                  // text
        IDS_CMIDM_HOMENET_WIZARD,        // tooltip
        IDI_WV_HOMENET,                  // icon
        CANSHOW_HANDLER_OF(CMIDM_HOMENET_WIZARD),
        INVOKE_HANDLER_OF(CMIDM_HOMENET_WIZARD)),
        
    //                 Single-select Name  ,Multi-select name     ,Icon                , Verb
    NCWVIEW_ENTRY_FILE(IDS_WV_CONNECT      ,IDS_WM_CONNECT        ,IDI_WV_CONNECT      , CMIDM_CONNECT),
    NCWVIEW_ENTRY_FILE(IDS_WV_DISCONNECT   ,IDS_WM_DISCONNECT     ,IDI_WV_DISCONNECT   , CMIDM_DISCONNECT),
    NCWVIEW_ENTRY_FILE(IDS_WV_ENABLE       ,IDS_WM_ENABLE         ,IDI_WV_ENABLE       , CMIDM_ENABLE),
    NCWVIEW_ENTRY_FILE(IDS_WV_DISABLE      ,IDS_WM_DISABLE        ,IDI_WV_DISABLE      , CMIDM_DISABLE),
    NCWVIEW_ENTRY_FILE(IDS_WV_REPAIR       ,IDS_WM_REPAIR         ,IDI_WV_REPAIR       , CMIDM_FIX),
    NCWVIEW_ENTRY_FILE(IDS_WV_RENAME       ,IDS_WM_RENAME         ,IDI_WV_RENAME       , CMIDM_RENAME),
    NCWVIEW_ENTRY_FILE(IDS_WV_STATUS       ,IDS_WM_STATUS         ,IDI_WV_STATUS       , CMIDM_STATUS),
    NCWVIEW_ENTRY_FILE(IDS_WV_DELETE       ,IDS_WM_DELETE         ,IDI_WV_DELETE       , CMIDM_DELETE),
    NCWVIEW_ENTRY_FILE(IDS_WV_PROPERTIES   ,IDS_WM_PROPERTIES     ,IDI_WV_PROPERTIES   , CMIDM_PROPERTIES)
};

DWORD c_aOtherPlaces[] = 
{
    CSIDL_CONTROLS, 
    CSIDL_NETWORK, 
    CSIDL_PERSONAL,
    CSIDL_DRIVES
};

extern const DWORD c_dwCountOtherPlaces = celems(c_aOtherPlaces);

const WVTASKITEM c_ConnFolderItemTaskList[] =
{
    WVTI_ENTRY_ALL( 
        GUID_NULL,                       // command GUID 
        L"netshell.dll",                 // module
        IDS_WV_TROUBLESHOOT,             // text
        IDS_CMIDM_NET_TROUBLESHOOT,      // tooltip
        IDI_WV_TROUBLESHOOT,             // icon
        CANSHOW_HANDLER_OF(CMIDM_NET_TROUBLESHOOT),
        INVOKE_HANDLER_OF(CMIDM_NET_TROUBLESHOOT))
};

CNCWebView::CNCWebView(CConnectionFolder* pConnectionFolder)
{
    Assert(pConnectionFolder);
    Assert(c_dwCountOtherPlaces <= MAXOTHERPLACES);
    m_pConnectionFolder = pConnectionFolder;
    
    // zero the PIDLs array to other places section in the webview
    ZeroMemory(m_apidlOtherPlaces, sizeof(m_apidlOtherPlaces));

}

CNCWebView::~CNCWebView()
{
    // check to destroy the other places PIDLs
    DestroyOtherPlaces();
}

IMPLEMENT_WEBVIEW_HANDLERS(TOPLEVEL,  CNCWebView, CMIDM_NEW_CONNECTION);
IMPLEMENT_WEBVIEW_HANDLERS(TOPLEVEL,  CNCWebView, CMIDM_HOMENET_WIZARD);
IMPLEMENT_WEBVIEW_HANDLERS(TOPLEVEL,  CNCWebView, CMIDM_NET_TROUBLESHOOT);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_FIX);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_CONNECT);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_DISCONNECT);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_ENABLE);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_DISABLE);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_RENAME);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_DELETE);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_STATUS);
IMPLEMENT_WEBVIEW_HANDLERS(TASKLEVEL, CNCWebView, CMIDM_PROPERTIES);

HRESULT CNCWebView::OnNull(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return S_OK;
}               

STDMETHODIMP CNCWebView::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT,  OnGetWebViewLayout);
        HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
        HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS,   OnGetWebViewTasks);
    
    default:
        return E_FAIL;
    }
}

STDMETHODIMP CNCWebView::CreateOtherPlaces(LPDWORD pdwCount)
{
    TraceFileFunc(ttidMenus);
    // first verify if created already
    HRESULT hr = S_OK;
    Assert(pdwCount);
    if (!pdwCount)
    {
        return E_INVALIDARG;
    }

    if( NULL == m_apidlOtherPlaces[0] )
    {
        *pdwCount = 0;

        // create the PIDLs to other places section in the webview
        ZeroMemory(m_apidlOtherPlaces, sizeof(m_apidlOtherPlaces));

        for (int dwPlaces = 0; dwPlaces < c_dwCountOtherPlaces; dwPlaces++)
        {
            if (SUCCEEDED(hr = SHGetSpecialFolderLocation(NULL, c_aOtherPlaces[dwPlaces], &(m_apidlOtherPlaces[*pdwCount]))))
            {
                (*pdwCount)++;
            }
            else
            {
                m_apidlOtherPlaces[*pdwCount] = NULL;
                TraceHr(ttidError, FAL, hr, FALSE, "CNCWebView::CreateOtherPlaces : 0x%04x", c_aOtherPlaces[dwPlaces]);
            }
        }

        if (FAILED(hr) && (*pdwCount))
        {
            hr = S_FALSE; // not a big deal if at least one worked.
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CNCWebView::CreateOtherPlaces - all places failed");
    return hr;
}

STDMETHODIMP CNCWebView::DestroyOtherPlaces()
{
    for (ULONG i = 0; i < c_dwCountOtherPlaces; i++)
    {
        if (m_apidlOtherPlaces[i])
        {
            LPMALLOC pMalloc;
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free(m_apidlOtherPlaces[i]);
            }
        }
    }
    ZeroMemory(m_apidlOtherPlaces, sizeof(m_apidlOtherPlaces));
    return S_OK;
}

STDMETHODIMP CNCWebView::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_DETAILS;
    
    return S_OK;
}

STDMETHODIMP CNCWebView::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    TraceFileFunc(ttidShellViewMsgs);

    HRESULT hr = S_OK;

    ZeroMemory(pTasks, sizeof(*pTasks));

    CComPtr<IUnknown> pUnk;
    hr = reinterpret_cast<LPSHELLFOLDER>(m_pConnectionFolder)->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID *>(&pUnk));

    if (SUCCEEDED(hr))
    {
        if (FAILED(hr = Create_IEnumUICommand(pUnk, c_ConnFolderItemTaskList,   celems(c_ConnFolderItemTaskList),   &pTasks->penumFolderTasks)) ||
            FAILED(hr = Create_IEnumUICommand(pUnk, c_ConnFolderGlobalTaskList, celems(c_ConnFolderGlobalTaskList), &pTasks->penumSpecialTasks)) )
        {
            // something has failed - cleanup

            IUnknown_SafeReleaseAndNullPtr(pTasks->penumFolderTasks);
            IUnknown_SafeReleaseAndNullPtr(pTasks->penumSpecialTasks);
        }
    }
    
    Assert(S_OK == hr);

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnGetWebViewTasks");

    return hr;
}

STDMETHODIMP CNCWebView::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    TraceFileFunc(ttidShellViewMsgs);

    HRESULT hr = S_OK;

    ZeroMemory(pData, sizeof(*pData));

    DWORD dwCountOtherPlaces;
    hr = CreateOtherPlaces(&dwCountOtherPlaces);

    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        LPCITEMIDLIST *papidl = reinterpret_cast<LPCITEMIDLIST*>(LocalAlloc(LPTR, sizeof(m_apidlOtherPlaces)));
        if (papidl)
        {
            // CEnumArray::CreateInstance is taking the ownership of the array of PIDLs passed
            // this function requires 2 things:
            //
            // 1. the caller should allocate the passed array with LocalAlloc
            // 2. the lifetime of the PIDLs passed should span the folder's lifetime
            //
            CopyMemory(papidl, &m_apidlOtherPlaces, sizeof(m_apidlOtherPlaces));

            hr = CEnumArray::CreateInstance(&pData->penumOtherPlaces, papidl, dwCountOtherPlaces);
            if (FAILED(hr))
            {
                LocalFree(papidl);
            }
        }

        if (FAILED(hr) ||
                FAILED(hr = Create_IUIElement(&c_ConnFolderGlobalTaskHeader, &pData->pSpecialTaskHeader)) ||
                FAILED(hr = Create_IUIElement(&c_ConnFolderItemTaskHeader, &pData->pFolderTaskHeader)) ||
                FAILED(hr = Create_IUIElement(&c_ConnFolderIntro, &pData->pIntroText)) )
        {
            // something has failed - cleanup
            DestroyOtherPlaces();
            IUnknown_SafeReleaseAndNullPtr(pData->pIntroText);
            IUnknown_SafeReleaseAndNullPtr(pData->pSpecialTaskHeader);
            IUnknown_SafeReleaseAndNullPtr(pData->pFolderTaskHeader);
            IUnknown_SafeReleaseAndNullPtr(pData->penumOtherPlaces);
        }
    }

    Assert(S_OK == hr);

    TraceHr(ttidError, FAL, hr, FALSE, "HrOnGetWebViewContent");
    
    return hr;
}

HRESULT CNCWebView::WebviewVerbInvoke(DWORD dwVerbID, IUnknown* pv, IShellItemArray *psiItemArray)
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IShellFolderViewCB> pShellFolderViewCB;
    hr = pv->QueryInterface(IID_IShellFolderViewCB, reinterpret_cast<LPVOID *>(&pShellFolderViewCB));
    if (SUCCEEDED(hr))
    {
        hr = pShellFolderViewCB->MessageSFVCB(DVM_INVOKECOMMAND, dwVerbID, NULL);
    }

    Assert(S_OK == hr);
    
    return hr;
}

HRESULT CNCWebView::WebviewVerbCanInvoke(DWORD dwVerbID, IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState, BOOL bLevel)
{
    HRESULT hr = E_NOINTERFACE;

    CComPtr<IShellFolderViewCB> pShellFolderViewCB;
    hr = pv->QueryInterface(IID_IShellFolderViewCB, reinterpret_cast<LPVOID *>(&pShellFolderViewCB));
    if (SUCCEEDED(hr))
    {
        NCCS_STATE nccsState;
        hr = pShellFolderViewCB->MessageSFVCB(bLevel ? MYWM_QUERYINVOKECOMMAND_TOPLEVEL : MYWM_QUERYINVOKECOMMAND_ITEMLEVEL, dwVerbID, reinterpret_cast<LPARAM>(&nccsState) );
        if (S_OK != hr)
        {
            *puisState = UIS_HIDDEN;
        }
        else
        {
            switch (nccsState)
            {
                case NCCS_DISABLED:
                    *puisState = UIS_DISABLED;
                    break;

                case NCCS_ENABLED:
                    *puisState = UIS_ENABLED;
                    break;

                case NCCS_NOTSHOWN:
                    *puisState = UIS_HIDDEN;
                    break;

                default:
                    AssertSz(FALSE, "Invalid value for NCCS_STATE");
            }
        }
    }

    Assert(S_OK == hr);
    
    return hr;
}

HRESULT CEnumArray::CreateInstance(
    IEnumIDList** ppv,
    LPCITEMIDLIST *ppidl, 
    UINT cItems)
{
    TraceFileFunc(ttidShellViewMsgs);

    HRESULT      hr      = E_OUTOFMEMORY;
    CEnumArray * pObj    = NULL;

    pObj = new CComObject<CEnumArray>;
    if (pObj)
    {
        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (SUCCEEDED(hr))
        {
            pObj->_cRef = 1;
            pObj->_ppidl = ppidl; // takes ownership of ppidl!
            pObj->_cItems = cItems;
            pObj->Reset();

            hr = pObj->QueryInterface (IID_IEnumIDList, reinterpret_cast<LPVOID *>(ppv));
        }

        if (FAILED(hr))
        {
            delete pObj;
        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CEnumArray::CreateInstance");
    return hr;
}

CEnumArray::CEnumArray()
{
    _ppidl = NULL;
}

CEnumArray::~CEnumArray()
{
    if (_ppidl)
    {
        LocalFree(_ppidl);
    }
}

STDMETHODIMP CEnumArray::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;

    if (_ppidl && (_ulIndex < _cItems))
    {
        *ppidl = ILClone(_ppidl[_ulIndex++]);
        if (ppidl)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    if (pceltFetched)
    {
        *pceltFetched = (hr == S_OK) ? 1 : 0;
    }

    return hr;
}

STDMETHODIMP CEnumArray::Skip(ULONG celt) 
{
    _ulIndex = min(_cItems, _ulIndex+celt);
    return S_OK;
}

STDMETHODIMP CEnumArray::Reset() 
{
    _ulIndex = 0;
    return S_OK;
}

STDMETHODIMP CEnumArray::Clone(IEnumIDList **ppenum) 
{
    // We can not clone this array, since we don't own references to the pidls
    *ppenum = NULL;
    return E_NOTIMPL;
}

HRESULT HrIsWebViewEnabled()
{
    SHELLSTATE ss={0};

    // SSF_HIDDENFILEEXTS and SSF_SORTCOLUMNS don't work with
    // the SHELLFLAGSTATE struct, make sure they are off
    // (because the corresponding SHELLSTATE fields don't
    // exist in SHELLFLAGSTATE.)
    //
    DWORD dwMask = SSF_WEBVIEW;

    SHGetSetSettings(&ss, dwMask, FALSE);

    if (ss.fWebView)
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}


/*
HRESULT GetCurrentCommandState(int iCommandId, UISTATE* puisState)
{
    for (DWORD dwLoop = 0; dwLoop < g_nFolderCommandCount; dwLoop++)
    {
        if (iCommandId = g_cteFolderCommands[dwLoop].iCommandId)
        {
            if (g_cteFolderCommands[dwLoop].fCurrentlyValid)
            {
                *puisState = UIS_ENABLED;
            }
            else
            {
                *puisState = UIS_DISABLED;
            }
            return S_OK;
        }
    }

    Assert(FALSE);
    return E_FILE_NOT_FOUND;
}

HRESULT CNCWebView::CanShowConnect(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = GetCurrentCommandState(CMIDM_CONNECT, puisState);
    return hr;
}

HRESULT CNCWebView::CanShowDisconnect(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;
    
    *puisState = UIS_DISABLED;
    
    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if (((cfe.GetNetConMediaType() == NCM_PHONE) ||
             (cfe.GetNetConMediaType() == NCM_TUNNEL) ||
             (cfe.GetNetConMediaType() == NCM_PPPOE) ||
             (cfe.GetNetConMediaType() == NCM_ISDN) ||
             (cfe.GetNetConMediaType() == NCM_DIRECT) ||
             (cfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_RAS) ||
             (cfe.GetNetConMediaType() == NCM_NONE ) ) &&
             (!cfe.GetWizard()))
        {
            if ( (cfe.GetNetConStatus() == NCS_CONNECTED) )
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    Assert(SUCCEEDED(hr));
    return hr;
}

HRESULT CNCWebView::CanShowEnable(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;

    *puisState = UIS_DISABLED;

    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if ((cfe.GetNetConMediaType() == NCM_LAN) ||
            (cfe.GetNetConMediaType() == NCM_BRIDGE) ||
            (cfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_LAN))
        {
            if ( (cfe.GetNetConStatus() == NCS_DISCONNECTED) )
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    Assert(SUCCEEDED(hr));
    return hr;
}

HRESULT CNCWebView::CanShowDisable(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;

    *puisState = UIS_DISABLED;

    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if ((cfe.GetNetConMediaType() == NCM_LAN) ||
            (cfe.GetNetConMediaType() == NCM_BRIDGE) ||
            (cfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_LAN))
        {
            if ( (cfe.GetNetConStatus() == NCS_CONNECTED || NCS_INVALID_ADDRESS || NCS_MEDIA_DISCONNECTED) )
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    Assert(SUCCEEDED(hr));
    return hr;
}

HRESULT CNCWebView::CanShowRepair(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;

    *puisState = UIS_DISABLED;

    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if ((cfe.GetNetConMediaType() == NCM_LAN) ||
            (cfe.GetNetConMediaType() == NCM_BRIDGE) ||
            (cfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_LAN))
        {
            if ( (cfe.GetNetConStatus() == NCS_CONNECTED || NCS_INVALID_ADDRESS || NCS_MEDIA_DISCONNECTED) )
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    Assert(SUCCEEDED(hr));
    
    return S_OK;
}

HRESULT CNCWebView::CanShowRename(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;

    *puisState = UIS_DISABLED;

    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if ((!cfe.GetWizard()) &&
            !(cfe.GetCharacteristics() && NCCF_INCOMING_ONLY))
        {
            *puisState = UIS_ENABLED;
        }
    }

    Assert(SUCCEEDED(hr))
    return S_OK;
}

HRESULT CNCWebView::CanShowStatus(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;

    *puisState = UIS_DISABLED;

    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if ((!cfe.GetWizard()) && 
            (cfe.GetNetConStatus() == NCS_CONNECTED || NCS_INVALID_ADDRESS || NCS_MEDIA_DISCONNECTED) )
        {
            *puisState = UIS_ENABLED;
        }
    }

    Assert(SUCCEEDED(hr));
    
    return S_OK;
}

HRESULT CNCWebView::CanShowDelete(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CONFOLDENTRY cfe;
    
    *puisState = UIS_DISABLED;
    
    HRESULT hr = WVGetConFoldPidlFromIDataObject(pv, pdo, cfe);
    if (SUCCEEDED(hr))
    {
        if (((cfe.GetNetConMediaType() == NCM_PHONE) ||
             (cfe.GetNetConMediaType() == NCM_TUNNEL) ||
             (cfe.GetNetConMediaType() == NCM_PPPOE) ||
             (cfe.GetNetConMediaType() == NCM_ISDN) ||
             (cfe.GetNetConMediaType() == NCM_DIRECT) ||
             (cfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_RAS) ||
             (cfe.GetNetConMediaType() == NCM_NONE ) ) &&
             (!cfe.GetWizard()))

        {
            *puisState = UIS_ENABLED;
        }
    }

    Assert(SUCCEEDED(hr));

    return S_OK;
}

HRESULT CNCWebView::CanShowHomenet(IUnknown* pv, IDataObject* pdo, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_ENABLED;
    return S_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\dialupui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I A L U P U I . H
//
//  Contents:   Dial-up connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "rasui.h"


class ATL_NO_VTABLE CDialupConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CDialupConnectionUi,
                        &CLSID_DialupConnectionUi>,
    public CRasUiBase,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionWizardUi
{
public:
    CDialupConnectionUi () : CRasUiBase () {m_dwRasWizType = RASWIZ_TYPE_DIALUP;};

    DECLARE_REGISTRY_RESOURCEID(IDR_DIALUP_UI)

    BEGIN_COM_MAP(CDialupConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionConnectUi
    STDMETHOD (SetConnection) (
        INetConnection* pCon);

    STDMETHOD (Connect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    STDMETHOD (Disconnect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    // INetConnectionPropertyUi2
    STDMETHOD (AddPages) (
        HWND                    hwndParent,
        LPFNADDPROPSHEETPAGE    pfnAddPage,
        LPARAM                  lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (
        INetConnectionWizardUiContext*  pContext,
        DWORD*                          pcMaxPages);

    STDMETHOD (AddPages) (
        INetConnectionWizardUiContext*  pContext,
        LPFNADDPROPSHEETPAGE            pfnAddPage,
        LPARAM                          lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName) (
        PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (
        PCWSTR pszwConnectionName);

    STDMETHOD (GetNewConnection) (
        INetConnection**    ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\inbui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I N B U I . H
//
//  Contents:   Inbound connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"


class ATL_NO_VTABLE CInboundConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CInboundConnectionUi,
                        &CLSID_InboundConnectionUi>,
    public INetConnectionPropertyUi2,
    public INetConnectionWizardUi
{
private:
    // This is our connection given to us via the SetConnection method.
    //
    INetConnection* m_pCon;

    // This is the server connection handle obtained by QI'ing m_pCon
    // for INetInboundConnection and calling the GetServerConnection method.
    // We do this as a way of verifying the INetConnection we are handed,
    // and to avoid the multiple RPCs calls we'd incur if we didn't cache it.
    //
    HRASSRVCONN     m_hRasSrvConn;

    // This member is the context that we provide so that rasdlg.dll knows
    // which modifications to commit.
    //
    PVOID           m_pvContext;

    // This member identifies our type to rasdlg.dll
    //
    DWORD           m_dwRasWizType;

public:
    CInboundConnectionUi ();
    ~CInboundConnectionUi ();

    DECLARE_REGISTRY_RESOURCEID(IDR_INBOUND_UI)

    BEGIN_COM_MAP(CInboundConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionPropertyUi2
    STDMETHOD (SetConnection) (
        INetConnection* pCon);

    STDMETHOD (AddPages) (
        HWND                    hwndParent,
        LPFNADDPROPSHEETPAGE    pfnAddPage,
        LPARAM                  lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (
        INetConnectionWizardUiContext*  pContext,
        DWORD*                          pcMaxPages);

    STDMETHOD (AddPages) (
        INetConnectionWizardUiContext*  pContext,
        LPFNADDPROPSHEETPAGE            pfnAddPage,
        LPARAM                          lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName) (
        PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (
        PCWSTR pszwConnectionName);

    STDMETHOD (GetNewConnection) (
        INetConnection**    ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\cfpidl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C F P I D L . H
//
//  Contents:   ConFoldPidl structures, classes, and prototypes
//
//  Author:     jeffspr   11 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once

#undef DBG_VALIDATE_PIDLS

#ifdef DBG
//    #define DBG_VALIDATE_PIDLS 1
#endif

// #define VERYSTRICTCOMPILE
// VERYSTRICTCOMPILE doesn't actually compile - However, it makes us check for things like using references
// from places other than STL etc.


// This defines the version number of the ConFoldPidl structure. When this
// changes, we'll need to invalidate the entries.
//
enum CONFOLDPIDLTYPE
{
    PIDL_TYPE_UNKNOWN = 0,
    PIDL_TYPE_V1 = 1,
    PIDL_TYPE_V2 = 2,
    PIDL_TYPE_98 = 98,
    PIDL_TYPE_FOLDER = 0xf01de
};

enum WIZARD
{
    WIZARD_NOT_WIZARD = 0,
    WIZARD_MNC        = 1,
    WIZARD_HNW        = 2
};

// {44086B2D-BAA3-4fce-949F-53FF664C4AD8}
DEFINE_GUID(GUID_MNC_WIZARD, 0x44086b2d, 0xbaa3, 0x4fce, 0x94, 0x9f, 0x53, 0xff, 0x66, 0x4c, 0x4a, 0xd8);

// {44086B2E-BAA3-4fce-949F-53FF664C4AD8}
DEFINE_GUID(GUID_HNW_WIZARD, 0x44086b2e, 0xbaa3, 0x4fce, 0x94, 0x9f, 0x53, 0xff, 0x66, 0x4c, 0x4a, 0xd8);

class CConFoldEntry;

class ConFoldPidlBase
{
public:
    WORD                iCB;
    USHORT              uLeadId;
    const DWORD         dwVersion;
    USHORT              uTrailId;
    WIZARD              wizWizard; // 0 - not a wizard, 1 - MNC, 2 - HNW
    CLSID               clsid;
    GUID                guidId;
    DWORD               dwCharacteristics;
    NETCON_MEDIATYPE    ncm;
    NETCON_STATUS       ncs;
    
    // Order of the rest of the non-static-sized data
    ULONG               ulPersistBufPos;
    ULONG               ulPersistBufSize;
    ULONG               ulStrNamePos;
    ULONG               ulStrNameSize;
    ULONG               ulStrDeviceNamePos;
    ULONG               ulStrDeviceNameSize;

protected:
    ConFoldPidlBase(DWORD Version) : dwVersion(Version) {};

};

class ConFoldPidl_v1 : public ConFoldPidlBase // CONFOLDPIDLTYPE = PIDL_TYPE_V1
{
public:
    enum tagConstants
    {
        CONNECTIONS_FOLDER_IDL_VERSION = PIDL_TYPE_V1
    };
    
    BOOL IsPidlOfThisType() const;
    HRESULT ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const;

    inline LPBYTE PbGetPersistBufPointer()  { return reinterpret_cast<LPBYTE>(bData + ulPersistBufPos); }
    inline LPWSTR PszGetNamePointer()       { return reinterpret_cast<LPWSTR>(bData + ulStrNamePos); }
    inline LPWSTR PszGetDeviceNamePointer() { return reinterpret_cast<LPWSTR>(bData + ulStrDeviceNamePos); }

    inline const BYTE * PbGetPersistBufPointer()  const { return reinterpret_cast<const BYTE *>(bData + ulPersistBufPos); }
    inline LPCWSTR PszGetNamePointer()       const { return reinterpret_cast<LPCWSTR>(bData + ulStrNamePos); }
    inline LPCWSTR PszGetDeviceNamePointer() const { return reinterpret_cast<LPCWSTR>(bData + ulStrDeviceNamePos); }

    // The rest of the non-static-sized data
    BYTE                bData[1];

    ConFoldPidl_v1() : ConFoldPidlBase(CONNECTIONS_FOLDER_IDL_VERSION) {};
};

class ConFoldPidl_v2 : public ConFoldPidlBase // CONFOLDPIDLTYPE = PIDL_TYPE_V2
{
public:
    enum tagConstants
    {
        CONNECTIONS_FOLDER_IDL_VERSION = PIDL_TYPE_V2
    };

    ConFoldPidl_v2() : ConFoldPidlBase(CONNECTIONS_FOLDER_IDL_VERSION) {};

    BOOL IsPidlOfThisType() const;
    HRESULT ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const;

    inline LPBYTE PbGetPersistBufPointer()  { return reinterpret_cast<LPBYTE>(bData + ulPersistBufPos); }
    inline LPWSTR PszGetNamePointer()       { return reinterpret_cast<LPWSTR>(bData + ulStrNamePos); }
    inline LPWSTR PszGetDeviceNamePointer() { return reinterpret_cast<LPWSTR>(bData + ulStrDeviceNamePos); }
    inline LPWSTR PszGetPhoneOrHostAddressPointer() { return reinterpret_cast<LPWSTR>(bData + ulStrPhoneOrHostAddressPos); }

    inline const BYTE * PbGetPersistBufPointer()  const { return reinterpret_cast<const BYTE *>(bData + ulPersistBufPos); }
    inline LPCWSTR PszGetNamePointer()       const { return reinterpret_cast<LPCWSTR>(bData + ulStrNamePos); }
    inline LPCWSTR PszGetDeviceNamePointer() const { return reinterpret_cast<LPCWSTR>(bData + ulStrDeviceNamePos); }
    inline LPCWSTR PszGetPhoneOrHostAddressPointer() const { return reinterpret_cast<LPCWSTR>(bData + ulStrPhoneOrHostAddressPos); }

    // PIDL version 2 members
    NETCON_SUBMEDIATYPE ncsm;
    ULONG               ulStrPhoneOrHostAddressPos;
    ULONG               ulStrPhoneOrHostAddressSize;

    // The rest of the non-static-sized data
    BYTE                bData[1];
};

// This structure is used as the LPITEMIDLIST that
// the shell uses to identify objects in a folder.  The
// first two bytes are required to indicate the size,
// the rest of the data is opaque to the shell.
struct ConFoldPidl98   // CONFOLDPIDLTYPE = PIDL_TYPE_98
{
    enum tagConstants
    {
        CONNECTIONS_FOLDER_IDL_VERSION = PIDL_TYPE_98
    };

    BOOL IsPidlOfThisType(OUT BOOL * pfIsWizard = NULL) const;
    HRESULT ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const { AssertSz(FALSE, "I don't know how to do that"); return E_UNEXPECTED; };;

    USHORT  cbSize;                 // Size of this struct
    UINT    uFlags;                 // One of SOF_ values
    int     nIconIndex;             // Icon index (in resource)
    struct  ConFoldPidl98 * psoNext;
    char    szaName[1];              // Display name
};

class ConFoldPidlFolder // CONFOLDPIDLTYPE = PIDL_TYPE_FOLDER
{
public:
    enum tagConstants
    {
        CONNECTIONS_FOLDER_IDL_VERSION = PIDL_TYPE_FOLDER
    };

    inline LPBYTE PbGetPersistBufPointer()  { AssertSz(FALSE, "Folders dont have this info"); return NULL; }
    inline LPWSTR PszGetNamePointer()       { AssertSz(FALSE, "Folders dont have this info"); return NULL; }
    inline LPWSTR PszGetDeviceNamePointer() { AssertSz(FALSE, "Folders dont have this info"); return NULL; }
    
    ConFoldPidlFolder() {}

    BOOL IsPidlOfThisType() const;

    // This is an internal structure used for debugging. Do NOT rely on this.
    WORD dwLength; // Should be 0x14 for Whistler
    BYTE dwId;     // Should be 0x1f for Whistler
    BYTE bOrder;   // used internall by shell
    CLSID clsid;

    HRESULT ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const { AssertSz(FALSE, "I don't do that"); return E_UNEXPECTED; };
};

template <class T>
class CPConFoldPidl
{
public:
    enum tagConstants
    {
        PIDL_VERSION = T::CONNECTIONS_FOLDER_IDL_VERSION
    };

    CPConFoldPidl();
    CPConFoldPidl(const CPConFoldPidl<T>& PConFoldPidl); // Copy constructor
    ~CPConFoldPidl();
    CPConFoldPidl<T>& operator =(const CPConFoldPidl<T>& PConFoldPidl);
    
    T&  operator *();   
    inline UNALIGNED T*  operator->();
    inline const UNALIGNED T*  operator->() const;

    HRESULT ILCreate(const DWORD dwSize);
    HRESULT ILClone(const CPConFoldPidl<T>& PConFoldPidl);

    HRESULT SHAlloc(const SIZE_T cb);
    HRESULT Clear();
    HRESULT InitializeFromItemIDList(LPCITEMIDLIST pItemIdList);

    LPITEMIDLIST Detach();
    LPITEMIDLIST TearOffItemIdList() const;
    inline LPCITEMIDLIST GetItemIdList() const;
#ifdef DBG_VALIDATE_PIDLS
    inline BOOL IsValidConFoldPIDL() const;
#endif
    
    inline BOOL empty() const;
    inline HRESULT ConvertToConFoldEntry(OUT CConFoldEntry& cfe) const;

    inline HRESULT Swop(IN OUT CPConFoldPidl<T>& cfe);

private:
    HRESULT      FreePIDLIfRequired();
#ifdef VERYSTRICTCOMPILE
    CPConFoldPidl<T>* operator &();
#endif
    UNALIGNED T* m_pConFoldPidl;

    friend HRESULT ConvertToPidl( OUT T& pidl);
};

//typedef ConFoldPidl   CONFOLDPIDL;
typedef struct ConFoldPidl98    CONFOLDPIDL98;

typedef CPConFoldPidl<ConFoldPidl_v2>    PCONFOLDPIDL;
typedef CPConFoldPidl<ConFoldPidlFolder> PCONFOLDPIDLFOLDER;
typedef CPConFoldPidl<ConFoldPidl98>     PCONFOLDPIDL98;

typedef vector<PCONFOLDPIDL> PCONFOLDPIDLVEC;

#define PCONFOLDPIDLDEFINED
// One of our pidls must be at least this size, it will likely be bigger.
//
#define CBCONFOLDPIDLV1_MIN      sizeof(ConFoldPidl_v1)
#define CBCONFOLDPIDLV1_MAX      2048

#define CBCONFOLDPIDLV2_MIN      sizeof(ConFoldPidl_v2)
#define CBCONFOLDPIDLV2_MAX      2048

// More versioning info. This will help me identify PIDLs as being mine
//
#define CONFOLDPIDL_LEADID     0x4EFF
#define CONFOLDPIDL_TRAILID    0x5EFF

// Define the Types of data which can changed via CConFoldEntry::HrUpdateData
//
#define CCFE_CHANGE_MEDIATYPE          0x0001
#define CCFE_CHANGE_STATUS             0x0002
#define CCFE_CHANGE_CHARACTERISTICS    0x0004
#define CCFE_CHANGE_NAME               0x0008
#define CCFE_CHANGE_DEVICENAME         0x0010
#define CCFE_CHANGE_PHONEORHOSTADDRESS 0x0020
#define CCFE_CHANGE_SUBMEDIATYPE       0x0040

#define CBCONFOLDPIDL98_MIN      sizeof(CONFOLDPIDL98)
#define CBCONFOLDPIDL98_MAX      2048
#define TAKEOWNERSHIP
#define SHALLOCATED
// ConFoldPidl98 flags
//
#define SOF_REMOTE      0x0000      // Remote connectoid
#define SOF_NEWREMOTE   0x0001      // New connection
#define SOF_MEMBER      0x0002      // Subobject is part of object space

// ****************************************************************************
BOOL fIsConnectedStatus(NETCON_STATUS ncs);

class CConFoldEntry
{
public:
    CConFoldEntry();
    ~CConFoldEntry();

private:
    explicit CConFoldEntry(IN const CConFoldEntry& ConFoldEntry);

    WIZARD              m_wizWizard;
    NETCON_MEDIATYPE    m_ncm;
    NETCON_SUBMEDIATYPE m_ncsm;
    NETCON_STATUS       m_ncs;
    CLSID               m_clsid;
    GUID                m_guidId;
    DWORD               m_dwCharacteristics;
    PWSTR               m_pszName;
    PWSTR               m_pszDeviceName;
    BYTE *              m_pbPersistData;
    ULONG               m_ulPersistSize;
    PWSTR               m_pszPhoneOrHostAddress;

    const CConFoldEntry* operator &() const;
    
    mutable BOOL        m_bDirty;
    mutable CPConFoldPidl<ConFoldPidl_v1> m_CachedV1Pidl;
    mutable CPConFoldPidl<ConFoldPidl_v2> m_CachedV2Pidl;
    
public:
    inline const DWORD GetCharacteristics() const;
    HRESULT SetCharacteristics(IN const DWORD dwCharacteristics);
    
    inline const GUID GetGuidID() const;
    HRESULT SetGuidID(IN const GUID guidId);
    
    inline const CLSID GetCLSID() const;
    HRESULT SetCLSID(IN const CLSID clsid);
    
    inline PCWSTR GetName() const;
    HRESULT SetPName(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszName);
    HRESULT SetName(IN LPCWSTR pszName);

    inline PCWSTR GetDeviceName() const;
    HRESULT SetPDeviceName(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszDeviceName);
    HRESULT SetDeviceName(IN LPCWSTR pszDeviceName);

    inline PCWSTR GetPhoneOrHostAddress() const;
    HRESULT SetPPhoneOrHostAddress(IN TAKEOWNERSHIP SHALLOCATED PWSTR pszPhoneOrHostAddress);
    HRESULT SetPhoneOrHostAddress(IN LPCWSTR pszPhoneOrHostAddress);

    inline const NETCON_STATUS GetNetConStatus() const;
    HRESULT SetNetConStatus(IN const NETCON_STATUS);

    inline const BOOL IsConnected() const;

    inline const NETCON_MEDIATYPE GetNetConMediaType() const;
    HRESULT SetNetConMediaType(IN const NETCON_MEDIATYPE);

    inline const NETCON_SUBMEDIATYPE GetNetConSubMediaType() const;
    HRESULT SetNetConSubMediaType(IN const NETCON_SUBMEDIATYPE);

    inline const WIZARD GetWizard() const;
    HRESULT SetWizard(IN const WIZARD);

    inline const BYTE * GetPersistData() const;
    inline const ULONG  GetPersistSize() const;
    HRESULT SetPersistData(IN BYTE* TAKEOWNERSHIP SHALLOCATED pbPersistData, IN const ULONG ulPersistSize);

public:
    BOOL empty() const;
    void clear();
    CConFoldEntry& operator =(const CConFoldEntry& ConFoldEntry);

    HRESULT InitializeFromItemIdList(LPCITEMIDLIST lpItemIdList);
    LPITEMIDLIST TearOffItemIdList() const;

    HRESULT ConvertToPidl( OUT CPConFoldPidl<ConFoldPidl_v1>& pidl) const;
    HRESULT ConvertToPidl( OUT CPConFoldPidl<ConFoldPidl_v2>& pidl) const;

    HRESULT HrInitData(
        const WIZARD        wizWizard,
        const NETCON_MEDIATYPE    ncm,
        const NETCON_SUBMEDIATYPE ncsm,
        const NETCON_STATUS       ncs,
        const CLSID *       pclsid,
        LPCGUID             pguidId,
        const DWORD         dwCharacteristics,
        const BYTE *        pbPersistData,
        const ULONG         ulPersistSize,
        LPCWSTR             pszName,
        LPCWSTR             pszDeviceName,
        LPCWSTR             pszPhoneOrHostAddress);

    HRESULT UpdateData(const DWORD dwChangeFlags, const NETCON_MEDIATYPE, const NETCON_SUBMEDIATYPE, const NETCON_STATUS,
                         const DWORD dwChar, PCWSTR pszName, PCWSTR pszDeviceName, PCWSTR pszPhoneOrHostAddress);
    HRESULT HrGetNetCon(IN REFIID riid, OUT VOID** ppv) const;
    HRESULT HrDupFolderEntry(const CConFoldEntry& pccfe);
    BOOL    FShouldHaveTrayIconDisplayed() const;

#ifdef NCDBGEXT
    IMPORT_NCDBG_FRIENDS
#endif
};

#define PCONFOLDENTRY_DEFINED

HRESULT PConfoldPidlVecFromItemIdListArray(
        IN LPCITEMIDLIST * apidl, 
        IN DWORD dwPidlCount, 
        OUT PCONFOLDPIDLVEC& vecConfoldPidl);

HRESULT HrNetConFromPidl(
        IN const PCONFOLDPIDL & pidl,
        OUT INetConnection **   ppNetCon);

HRESULT HrCreateConFoldPidl(
    IN  const WIZARD            wizWizard,
    IN  INetConnection *        pNetCon,
    OUT PCONFOLDPIDL &          ppidl);

HRESULT HrCreateConFoldPidl(
    IN  const NETCON_PROPERTIES_EX& PropsEx,
    OUT PCONFOLDPIDL &              ppidl);

HRESULT HrCreateConFoldPidlInternal(
    IN  const NETCON_PROPERTIES * pProps,
    IN  const BYTE *        pbBuf,
    IN  ULONG               ulBufSize,
    IN  LPCWSTR             szPhoneOrHostAddress,
    OUT PCONFOLDPIDL &      ppidl);

#ifdef DBG_VALIDATE_PIDLS
BOOL IsValidPIDL(LPCITEMIDLIST pidl);
#endif

CONFOLDPIDLTYPE GetPidlType(LPCITEMIDLIST pidl);

typedef CConFoldEntry CONFOLDENTRY;

// ****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\intnetui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I N T N E T U I . H
//
//  Contents:   Internet connection UI object.
//
//  Notes:
//
//  Author:     shaunco   15 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "rasui.h"


class ATL_NO_VTABLE CInternetConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CInternetConnectionUi,
                        &CLSID_InternetConnectionUi>,
    public CRasUiBase,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionWizardUi
{
public:
    CInternetConnectionUi () : CRasUiBase () {m_dwRasWizType = RASWIZ_TYPE_DIALUP;};

    DECLARE_REGISTRY_RESOURCEID(IDR_INTERNET_UI)

    BEGIN_COM_MAP(CInternetConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionConnectUi
    STDMETHOD (SetConnection) (
        INetConnection* pCon);

    STDMETHOD (Connect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    STDMETHOD (Disconnect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    // INetConnectionPropertyUi2
    STDMETHOD (AddPages) (
        HWND                    hwndParent,
        LPFNADDPROPSHEETPAGE    pfnAddPage,
        LPARAM                  lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (
        INetConnectionWizardUiContext*  pContext,
        DWORD*                          pcMaxPages);

    STDMETHOD (AddPages) (
        INetConnectionWizardUiContext*  pContext,
        LPFNADDPROPSHEETPAGE            pfnAddPage,
        LPARAM                          lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName) (
        PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (
        PCWSTR pszwConnectionName);

    STDMETHOD (GetNewConnection) (
        INetConnection**    ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\foldinc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       F O L D I N C . H
//
//  Contents:   Standard include for the shell\folder code
//
//  Notes:
//
//  Author:     jeffspr   30 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _FOLDINC_H_
#define _FOLDINC_H_

#if DBG
LPITEMIDLIST 	ILNext(LPCITEMIDLIST pidl);
BOOL			ILIsEmpty(LPCITEMIDLIST pidl);
#else
#define ILNext(pidl) 	((LPITEMIDLIST) ((BYTE *)pidl + ((LPITEMIDLIST)pidl)->mkid.cb))
#define ILIsEmpty(pidl)	(!pidl || !((LPITEMIDLIST)pidl)->mkid.cb)
#endif

#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))

#include "nsbase.h"
#include "nsres.h"
#include <ncdebug.h>
#include <ncreg.h>
#include <netshell.h>
#include <netconp.h>
#include <ncui.h>
#include "..\folder\confold.h"
#include "..\folder\contray.h"
#include "..\folder\foldglob.h"
#include "..\folder\shutil.h"
#include <openfold.h>   // For launching connections folder

#define _ILSkip(pidl, cb)	((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)		_ILSkip(pidl, (pidl)->mkid.cb)

#endif  // _FOLDINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\directui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D I R E C T U I . H
//
//  Contents:   Direct connection UI object.
//
//  Notes:
//
//  Author:     shaunco   17 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "rasui.h"


class ATL_NO_VTABLE CDirectConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CDirectConnectionUi,
                        &CLSID_DirectConnectionUi>,
    public CRasUiBase,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionWizardUi
{
public:
    CDirectConnectionUi () : CRasUiBase () {m_dwRasWizType = RASWIZ_TYPE_DIRECT;};

    DECLARE_REGISTRY_RESOURCEID(IDR_DIRECT_UI)

    BEGIN_COM_MAP(CDirectConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionConnectUi
    STDMETHOD (SetConnection) (
        INetConnection* pCon);

    STDMETHOD (Connect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    STDMETHOD (Disconnect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    // INetConnectionPropertyUi2
    STDMETHOD (AddPages) (
        HWND                    hwndParent,
        LPFNADDPROPSHEETPAGE    pfnAddPage,
        LPARAM                  lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (
        INetConnectionWizardUiContext*  pContext,
        DWORD*                          pcMaxPages);

    STDMETHOD (AddPages) (
        INetConnectionWizardUiContext*  pContext,
        LPFNADDPROPSHEETPAGE            pfnAddPage,
        LPARAM                          lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName) (
        PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (
        PCWSTR pszwConnectionName);

    STDMETHOD (GetNewConnection) (
        INetConnection**    ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>     // must come before shlguid.h
#include <shlguid.h>
#include <stdio.h>
#include <wchar.h>
#include <hnetcfg.h>
#include <iphlpapi.h>

// Fusion support
#include "shfusion.h"

#include "stlalgor.h"
#include "stllist.h"
#include "stlmap.h"
#include "stlset.h"
#include "stlvec.h"
using namespace std;

#include "ncmem.h"
#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
#include "ncexcept.h"
#include "naming.h"

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES
#define DONT_WANT_SHELLDEBUG 1
#define NO_SHIDLIST 1
#define USE_SHLWAPI_IDLIST

#include <commctrl.h>
#include <shlobjp.h>

#include <rasuip.h>
#include <rasdlg.h>

#include <comctrlp.h>
#include <shpriv.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlobjp.h>
#include <shlapip.h>

#define LoadIconSize(hInstance, lpszName, dwSize) \
    reinterpret_cast<HICON>(LoadImage(hInstance, lpszName, IMAGE_ICON, dwSize, dwSize, LR_DEFAULTCOLOR))

#define LoadIconSmall(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 16)

#define LoadIconNormal(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 32)

#define LoadIconTile(hInstance, lpszName) \
    LoadIconSize(hInstance, lpszName, 48)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\nsbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N S B A S E . H
//
//  Contents:   Base include file for netshell.dll.  Defines globals.
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#include "ncatl.h"
#include "nsclsid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\nsclsid.h ===
#include <guiddef.h>

// Reserved GUIDS for our use
//
// 7007ACC1-3202-11D1-AAD2-00805FC1270E     CLSID_DialUpConnectionUi
// 7007ACC2-3202-11D1-AAD2-00805FC1270E     CLSID_DirectConnectionUi
// 7007ACC3-3202-11D1-AAD2-00805FC1270E     CLSID_InboundConnectionUi
// 7007ACC4-3202-11D1-AAD2-00805FC1270E     CLSID_InternetConnectionUi
// 7007ACC5-3202-11D1-AAD2-00805FC1270E     CLSID_LanConnectionUi
// 7007ACC6-3202-11D1-AAD2-00805FC1270E     CLSID_VpnConnectionUi
// 7007ACC7-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolder
// 7007ACC8-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderEnum
// 7007ACC9-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderExtractIcon
// 7007ACCA-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderQueryInfo
// 7007ACCB-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderDataObject
// 7007ACCC-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderEnumFORMATETC
// 7007ACCD-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderContextMenu
// 7007ACCE-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderContextMenuBack
// 7007ACCF-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionTray
// 7007ACD0-3202-11D1-AAD2-00805FC1270E
// 7007ACD1-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionCommonUi
// 7007ACD2-3202-11D1-AAD2-00805FC1270E     CLSID_ConnectionFolderDetails
// 7007ACD3-3202-11D1-AAD2-00805FC1270E     CLSID_NetConnectionUIUtilities
// 7007ACD4-3202-11D1-AAD2-00805FC1270E     CLSID_PPPoEUi
// 7007ACD5-3202-11D1-AAD2-00805FC1270E     CLSID_SharedAccessConnectionUi
// 7007ACD6-3202-11D1-AAD2-00805FC1270E
// 7007ACD7-3202-11D1-AAD2-00805FC1270E
// 7007ACD8-3202-11D1-AAD2-00805FC1270E
// 7007ACD9-3202-11D1-AAD2-00805FC1270E
// 7007ACDA-3202-11D1-AAD2-00805FC1270E     
// ...
// 7007AD15-3202-11D1-AAD2-00805FC1270E
// 7007AD16-3202-11D1-AAD2-00805FC1270E
// 7007AD17-3202-11D1-AAD2-00805FC1270E

// Raid #214057
// The GUID for win98 RAS connection folder
// 992CFFA0-F557-101A-88EC-00DD010CCC48     CLSID_ConnectionFolderWin98     

// The following CLSIDs are defined in uuid.lib because the public uses them.
//
EXTERN_C const CLSID CLSID_ConnectionCommonUi;
EXTERN_C const CLSID CLSID_NetConnectionUiUtilities;


DEFINE_GUID(CLSID_DialupConnectionUi,               0x7007ACC1,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_DirectConnectionUi,               0x7007ACC2,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InboundConnectionUi,              0x7007ACC3,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_InternetConnectionUi,             0x7007ACC4,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_PPPoEUi,                          0x7007ACD4,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_SharedAccessConnectionUi,         0x7007ACD5,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_LanConnectionUi,                  0x7007ACC5,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_VpnConnectionUi,                  0x7007ACC6,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolder,                 0x7007ACC7,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderEnum,             0x7007ACC8,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderExtractIcon,      0x7007ACC9,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderQueryInfo,        0x7007ACCA,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderDataObject,       0x7007ACCB,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderEnumFORMATETC,    0x7007ACCC,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderContextMenu,      0x7007ACCD,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderContextMenuBack,  0x7007ACCE,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionTray,                   0x7007ACCF,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderDetails,          0x7007ACD2,0x3202,0x11D1,0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E);
DEFINE_GUID(CLSID_ConnectionFolderWin98,            0x992CFFA0,0xF557,0x101A,0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);     
DEFINE_GUID(FMTID_DUIWebViewProp,                   0x4bf1583f,0x916b,0x4719,0xac,0x31,0x88,0x96,0xa4,0xbd,0x8d,0x8b);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\nsres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N S R E S . H
//
//  Contents:   Master resource header for netshell.dll
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once


//+---------------------------------------------------------------------------
// Menu items
#define IDS_MENU_CMIDM_START              1600
#define IDS_MENU_CMIDM_NEW_CONNECTION     IDS_MENU_CMIDM_START + CMIDM_NEW_CONNECTION
#define IDS_MENU_CMIDM_CONNECT            IDS_MENU_CMIDM_START + CMIDM_CONNECT
#define IDS_MENU_CMIDM_DISCONNECT         IDS_MENU_CMIDM_START + CMIDM_DISCONNECT
#define IDS_MENU_CMIDM_ENABLE             IDS_MENU_CMIDM_START + CMIDM_ENABLE
#define IDS_MENU_IDS_MENU_CMIDM_DISABLE   IDS_MENU_CMIDM_START + CMIDM_DISABLE
#define IDS_MENU_CMIDM_STATUS             IDS_MENU_CMIDM_START + CMIDM_STATUS
#define IDS_MENU_CMIDM_CREATE_BRIDGE      IDS_MENU_CMIDM_START + CMIDM_CREATE_BRIDGE
#define IDS_MENU_CMIDM_ADD_TO_BRIDGE      IDS_MENU_CMIDM_START + CMIDM_ADD_TO_BRIDGE
#define IDS_MENU_CMIDM_REMOVE_FROM_BRIDGE IDS_MENU_CMIDM_START + CMIDM_REMOVE_FROM_BRIDGE
#define IDS_MENU_CMIDM_CREATE_SHORTCUT    IDS_MENU_CMIDM_START + CMIDM_CREATE_SHORTCUT
#define IDS_MENU_SFVIDM_FILE_LINK         IDS_MENU_CMIDM_START + SFVIDM_FILE_LINK
#define IDS_MENU_CMIDM_DELETE             IDS_MENU_CMIDM_START + CMIDM_DELETE
#define IDS_MENU_SFVIDM_FILE_DELETE       IDS_MENU_CMIDM_START + SFVIDM_FILE_DELETE
#define IDS_MENU_CMIDM_RENAME             IDS_MENU_CMIDM_START + CMIDM_RENAME
#define IDS_MENU_CMIDM_PROPERTIES         IDS_MENU_CMIDM_START + CMIDM_PROPERTIES
#define IDS_MENU_SFVIDM_FILE_PROPERTIES   IDS_MENU_CMIDM_START + SFVIDM_FILE_PROPERTIES
#define IDS_MENU_CMIDM_CREATE_COPY        IDS_MENU_CMIDM_START + CMIDM_CREATE_COPY
#define IDS_MENU_SFVIDM_FILE_RENAME       IDS_MENU_CMIDM_START + SFVIDM_FILE_RENAME
#define IDS_MENU_CMIDM_SET_DEFAULT        IDS_MENU_CMIDM_START + CMIDM_SET_DEFAULT
#define IDS_MENU_CMIDM_UNSET_DEFAULT      IDS_MENU_CMIDM_START + CMIDM_UNSET_DEFAULT
#define IDS_MENU_CMIDM_FIX                IDS_MENU_CMIDM_START + CMIDM_FIX
#define IDS_MENU_HOMENET_WIZARD           IDS_MENU_CMIDM_START + CMIDM_HOMENET_WIZARD
#define IDS_MENU_CMIDM_WZCDLG_SHOW        IDS_MENU_CMIDM_START + CMIDM_WZCDLG_SHOW


#define IDS_ERR_NO_NETMAN                 1507
#define IDS_ERR_LIMITED_USER              1508
//+---------------------------------------------------------------------------
// Web View

#define MYWM_QUERYINVOKECOMMAND_ITEMLEVEL     WM_USER+20
#define MYWM_QUERYINVOKECOMMAND_TOPLEVEL      WM_USER+21

#define IDS_WV_START                          1500
#define IDS_WV_TITLE_NETCONFOLDERTASKS        IDS_WV_START+1
#define IDS_WV_TITLE_NETCONFOLDERTASKS_TT     IDS_WV_START+2
#define IDS_WV_TITLE_NETCONITEMTASKS          IDS_WV_START+3
#define IDS_WV_TITLE_NETCONITEMTASKS_TT       IDS_WV_START+4
#define IDS_WV_NETCON_INTRO                   IDS_WV_START+6

#define IDI_WV_IDS_NOSELTEXT_INFO             IDI_SI_S_16

#define IDS_WV_HOMENET                        IDS_WV_START+20
#define IDI_WV_HOMENET                        IDI_CONFOLD_HOMENET_WIZARD

#define IDS_WV_TROUBLESHOOT                   IDS_WV_START+25

#define IDS_WV_CONNECT                        IDS_WV_START+30
#define IDS_WM_CONNECT                        IDS_WV_START+31

#define IDS_WV_DISCONNECT                     IDS_WV_START+35
#define IDS_WM_DISCONNECT                     IDS_WV_START+36

#define IDS_WV_REPAIR                         IDS_WV_START+40
#define IDS_WM_REPAIR                         IDS_WV_START+45

#define IDS_WV_RENAME                         IDS_WV_START+50
#define IDS_WM_RENAME                         IDS_WV_START+51

#define IDS_WV_STATUS                         IDS_WV_START+55
#define IDS_WM_STATUS                         IDS_WV_START+56

#define IDS_WV_DELETE                         IDS_WV_START+60
#define IDS_WM_DELETE                         IDS_WV_START+61

#define IDS_WV_ENABLE                         IDS_WV_START+65
#define IDS_WM_ENABLE                         IDS_WV_START+66

#define IDS_WV_DISABLE                        IDS_WV_START+70
#define IDS_WM_DISABLE                        IDS_WV_START+71

#define IDS_WV_PROPERTIES                     IDS_WV_START+75
#define IDS_WM_PROPERTIES                     IDS_WV_START+76

#define IDS_WV_MNCWIZARD                      IDS_WV_START+85
#define IDI_WV_MNCWIZARD                      IDI_CONFOLD_WIZARD

#define IDI_WV_START                          1600
#define IDI_WV_TROUBLESHOOT                   1601
#define IDI_WV_COPY                           1602
#define IDI_WV_DELETE                         1603
#define IDI_WV_RENAME                         1604
#define IDI_WV_TASK                           1605
#define IDI_WV_STATUS                         1606
#define IDI_WV_ENABLE                         1607
#define IDI_WV_DISABLE                        1608
#define IDI_WV_REPAIR                         1609
#define IDI_WV_PROPERTIES                     1610
#define IDI_WV_LOGIN                          1611
#define IDI_WV_CONNECT                        IDI_WV_ENABLE
#define IDI_WV_DISCONNECT                     IDI_WV_DISABLE
// Can also use IDI_WV_TASK


//+---------------------------------------------------------------------------
// Icon resources
//

#define IDI_BASE                                    100

//$ NOTE: Hey, you! Before you go changing any of these numbers, make sure
// that you talk to Jeffspr. For optimization, we calculate icons numbers
// and make some assumptions about the order of this file.


// Server inbound
//
#define IDI_SI_S_16         100     // Server inbound (16x16)
#define IDI_SI_M_16         101     // Server inbound (32x32)

// Non-state icons for folder small-icon display
//
#define IDI_XB_GEN_S_16     102     // dead connection
#define IDI_PB_GEN_S_16     103     // phone
#define IDI_LB_GEN_S_16     104     // lan
#define IDI_DB_GEN_S_16     105     // direct-connect
#define IDI_TB_GEN_S_16     106     // tunnel
#define IDI_CM_GEN_S_16     107     // CM connections
#define IDI_BR_GEN_S_16     108     // PPPoE

// Phone outbound
//
#define IDI_PO_DIS_M_16     111     // phone outbound disconnected
#define IDI_PO_CON_M_16     112     // phone outbound connected
#define IDI_PO_HNP_M_16     113     // phone outbound hardware failure (np, malfunc, etc.)
#define IDI_PO_TRN_M_16     114     // phone outbound transmitting
#define IDI_PO_RCV_M_16     115     // phone outbound receiving
#define IDI_PO_NON_M_16     116     // phone outbound idle

// LAN bidirectional
//
#define IDI_LB_DIS_M_16     121     // LAN (bi-dir) disconnected
#define IDI_LB_CON_M_16     122     // LAN (bi-dir) connected
#define IDI_LB_HNP_M_16     123     // LAN (bi-dir) hardware failure (np, malfunc, etc.)
#define IDI_LB_TRN_M_16     124     // LAN (bi-dir) transmitting
#define IDI_LB_RCV_M_16     125     // LAN (bi-dir) receiving
#define IDI_LB_NON_M_16     126     // LAN (bi-dir) idle
#define IDI_LB_GEN_M_16     127     // LAN (bi-dir) generic (for dialog boxes, etc.)
#define IDI_LB_MDS_M_16     128     // LAN (bi-dir) media disconnected

// Direct outbound
//
#define IDI_DO_DIS_M_16     131     // Direct outbound disconnected
#define IDI_DO_CON_M_16     132     // Direct outbound connected
#define IDI_DO_HNP_M_16     133     // Direct outbound hardware failure (np, malfunc, etc.)
#define IDI_DO_TRN_M_16     134     // Direct outbound transmitting
#define IDI_DO_RCV_M_16     135     // Direct outbound receiving
#define IDI_DO_NON_M_16     136     // Direct outbound idle

// Tunnel outbound
//
#define IDI_TO_DIS_M_16     141     // Tunnel outbound disconnected
#define IDI_TO_CON_M_16     142     // Tunnel outbound connected
#define IDI_TO_HNP_M_16     143     // Tunnel outbound hardware failure (np, malfunc, etc.)
#define IDI_TO_TRN_M_16     144     // Tunnel outbound transmitting
#define IDI_TO_RCV_M_16     145     // Tunnel outbound receiving
#define IDI_TO_NON_M_16     146     // Tunnel outbound idle

// Phone inbound
//
#define IDI_PI_CON_M_16     151     // phone inbound connected
#define IDI_PI_TRN_M_16     152     // phone inbound transmitting
#define IDI_PI_RCV_M_16     153     // phone inbound receiving
#define IDI_PI_NON_M_16     154     // phone inbound idle

// Direct inbound
//
#define IDI_DI_CON_M_16     161     // direct-connect inbound connected
#define IDI_DI_TRN_M_16     162     // direct-connect inbound transmitting
#define IDI_DI_RCV_M_16     163     // direct-connect inbound receiving
#define IDI_DI_NON_M_16     164     // direct-connect inbound idle

// Tunnel inbound
//
#define IDI_TI_CON_M_16     171     // tunnel inbound connected
#define IDI_TI_TRN_M_16     172     // tunnel inbound transmitting
#define IDI_TI_RCV_M_16     173     // tunnel inbound receiving
#define IDI_TI_NON_M_16     174     // tunnel inbound idle

// CM outbound
//
#define IDI_CM_DIS_M_16     181     // CM disconnected
#define IDI_CM_CON_M_16     182     // CM connected
#define IDI_CM_HNP_M_16     183     // CM hardware failure (np, malfunc, etc.)
#define IDI_CM_TRN_M_16     184     // CM transmitting
#define IDI_CM_RCV_M_16     185     // CM receiving
#define IDI_CM_NON_M_16     186     // CM idle

// Various small tray icons
#define IDI_CFT_XMTRECV     190     // Generic connected (both lit)
#define IDI_CFT_XMT         191     // Generic transmitting
#define IDI_CFT_RECV        192     // Generic receiving
#define IDI_CFT_BLANK       193     // Generic idle (both black)

// Win98 link icon
#define IDI_WIN98_LINK      194

// Tray LAN Media-Disconnected icon
#define IDI_CFT_DISCONNECTED    195     // LAN Media-Disconnected for tray
#define IDI_CFT_INVALID_ADDRESS 196     // LAN Invalid Address

// PPPoE outbound
//
#define IDI_BR_DIS_M_16     201     // PPPoE outbound disconnected
#define IDI_BR_CON_M_16     202     // PPPoE outbound connected
#define IDI_BR_HNP_M_16     203     // PPPoE outbound hardware failure (np, malfunc, etc.)
#define IDI_BR_TRN_M_16     204     // PPPoE outbound transmitting
#define IDI_BR_RCV_M_16     205     // PPPoE outbound receiving
#define IDI_BR_NON_M_16     206     // PPPoE outbound idle

// Overlays
#define IDI_OVL_SHARED      300
#define IDI_OVL_FIREWALLED  301
#define IDI_OVL_DEFAULT     302
#define IDI_OVL_INCOMING    303

// Connection Folder Icons
#define IDI_CFI_RASSERVER            1901
#define IDI_CFI_PHONE                1902
#define IDI_CFI_LAN                  1903
#define IDI_CFI_DIRECT               1904
#define IDI_CFI_VPN                  1905
#define IDI_CFI_ISDN                 1906
#define IDI_CFI_PPPOE                1907
#define IDI_CFI_BRIDGE               1908
#define IDI_CFI_SAH_LAN              1909
#define IDI_CFI_SAH_RAS              1910
#define IDI_CFI_BRIDGE_CONNECTED     1911
#define IDI_CFI_BRIDGE_DISCONNECTED  1912
#define IDI_CFI_WIRELESS             1913
#define IDI_CFI_CM                   1914

#define IDI_CFI_CONN_ALLOFF          1915
#define IDI_CFI_CONN_LEFTON          1916
#define IDI_CFI_CONN_RIGHTON         1917
#define IDI_CFI_CONN_BOTHON          1918

#define IDI_CFI_STAT_QUESTION        1919
#define IDI_CFI_STAT_FAULT           1920

// Personal Firewall
#define IDI_PERSONALFIREWALL 1000
#define IDI_PO_FDS_M_16      1001     // phone outbound disconnected, firewalled
#define IDI_PO_FCN_M_16      1002     // phone outbound connected, firewalled
#define IDI_LB_FDS_M_16      1003     // LAN (bi-dir) disconnected, firewalled
#define IDI_LB_FCN_M_16      1004     // LAN (bi-dir) connected, firewalled
#define IDI_TO_FDS_M_16      1005     // Tunnel outbound disconnected, firewalled
#define IDI_TO_FCN_M_16      1006     // Tunnel outbound connected, firewalled

// Network Bridge
#define IDI_NB_CON_M_16      1150
#define IDI_NB_DIS_M_16      1151
#define IDI_LB_BDS_M_16      1152     // LAN (bi-dir) disconnected,bridged
#define IDI_LB_BCN_M_16      1153     // LAN (bi-dir) connected, bridged

// Beacon client

#define IDI_SL_DIS_M_16 1111        // Shared access host lan disconnected
#define IDI_SL_CON_M_16 1112        // Shared access host lan connected
#define IDI_SR_DIS_M_16 1113        // Shared access host ras disconnected
#define IDI_SR_CON_M_16 1114        // Shared access host ras connected
#define IDI_SASTATMON_INTERNET 1115   // sahost status page icon
#define IDI_SASTATMON_ICSHOST 1116    // sahost status page icon 
#define IDI_SASTATMON_MYCOMPUTER 1117 // sahost status page icon

// Default connections:
#define IDI_PO_FDS_M_16_CHK 2001    // phone outbound disconnected, firewalled+chk
#define IDI_PO_FCN_M_16_CHK 2002    // phone outbound connected, firewalled+chk
#define IDI_TO_FDS_M_16_CHK 2005    // Tunnel outbound disconnected, firewalled+chk
#define IDI_TO_FCN_M_16_CHK 2006    // Tunnel outbound connected, firewalled+chk
#define IDI_XB_GEN_S_16_CHK 2102    // dead connection+chk
#define IDI_PB_GEN_S_16_CHK 2103    // phone+chk
#define IDI_DB_GEN_S_16_CHK 2105    // direct-connect+chk
#define IDI_TB_GEN_S_16_CHK 2106    // tunnel+chk
#define IDI_CM_GEN_S_16_CHK 2107    // CM connections+chk
#define IDI_BR_GEN_S_16_CHK 2108    // PPPoE+chk
#define IDI_PO_DIS_M_16_CHK 2111    // phone outbound disconnected+chk
#define IDI_PO_CON_M_16_CHK 2112    // phone outbound connected+chk
#define IDI_PO_HNP_M_16_CHK 2113    // phone outbound hardware failure (np, malfunc, etc.)+chk
#define IDI_DO_DIS_M_16_CHK 2131    // Direct outbound disconnected+chk
#define IDI_DO_CON_M_16_CHK 2132    // Direct outbound connected+chk
#define IDI_DO_HNP_M_16_CHK 2133    // Direct outbound hardware failure (np, malfunc, etc.)+chk
#define IDI_TO_DIS_M_16_CHK 2141    // Tunnel outbound disconnected+chk
#define IDI_TO_CON_M_16_CHK 2142    // Tunnel outbound connected+chk
#define IDI_TO_HNP_M_16_CHK 2143    // Tunnel outbound hardware failure (np, malfunc, etc.)+chk
#define IDI_CM_DIS_M_16_CHK 2181    // CM disconnected+chk
#define IDI_CM_CON_M_16_CHK 2182    // CM connected+chk
#define IDI_CM_HNP_M_16_CHK 2183    // CM hardware failure (np, malfunc, etc.)+chk
#define IDI_BR_DIS_M_16_CHK 2201    // PPPoE outbound disconnected+chk
#define IDI_BR_CON_M_16_CHK 2202    // PPPoE outbound connected+chk
#define IDI_BR_HNP_M_16_CHK 2203    // PPPoE outbound hardware failure (np, malfunc, etc.)+chk

//+---------------------------------------------------------------------------
// Registry resources
//

// Connections Folder (100-129)
//
#define IDR_CONFOLD                                 100
#define IDR_CONFOLDENUM                             101
#define IDR_CONFOLDEXTRACTICON                      102
#define IDR_CONFOLDQUERYINFO                        103
#define IDR_CONFOLDDATAOBJECT                       104
#define IDR_CONFOLDENUMFORMATETC                    105
#define IDR_CONFOLDCONTEXTMENU                      106
#define IDR_CONFOLDCONTEXTMENUBACK                  107

// Connection UI Objects (130-149)
//
#define IDR_DIALUP_UI                               130
#define IDR_DIRECT_UI                               131
#define IDR_INBOUND_UI                              132
#define IDR_LAN_UI                                  134
#define IDR_VPN_UI                                  135
#define IDR_PPPOE_UI                                136
#define IDR_SHAREDACCESS_UI                         137
#define IDR_INTERNET_UI                             138

// Connection Tray (150-154)
//
#define IDR_CONTRAY                                 150

// Common Connection Interfaces (160-180)
//
#define IDR_COMMCONN                                160
#define IDR_COMMUIUTILITIES                         161

//+---------------------------------------------------------------------------
// String resources
//

//---[ Utility strings ]------------------------------------------------------

#define IDS_TEXT_WITH_WIN32_ERROR                   900
#define IDS_TEXT_WITH_RAS_ERROR                     901

//---[ Folder strings ]-------------------------------------------------------

// Column titles
//
#define IDS_CONFOLD_DETAILS_NAME                    1000
#define IDS_CONFOLD_DETAILS_TYPE                    1001
#define IDS_CONFOLD_DETAILS_STATUS                  1002
#define IDS_CONFOLD_DETAILS_DEVICE_NAME             1003
#define IDS_CONFOLD_DETAILS_PHONEORHOSTADDRESS      1004
#define IDS_CONFOLD_DETAILS_OWNER                   1005
#define IDS_CONFOLD_DETAILS_ADDRESS                 1006
#define IDS_CONFOLD_DETAILS_WIRELESS_MODE           1007
#define IDS_CONFOLD_DETAILS_ADHOC_MODE              1008
#define IDS_CONFOLD_DETAILS_SENT                    1009
#define IDS_CONFOLD_DETAILS_RECEIVED                1015
#define IDS_CONFOLD_DETAILS_PHONENUMBER             1016
#define IDS_CONFOLD_DETAILS_HOSTADDRESS             1017

// Display names
//
#define IDS_CONFOLD_WIZARD_DISPLAY_NAME             1010
#define IDS_CONFOLD_WIZARD_FRIENDLY_NAME            1011
#define IDS_CONFOLD_WIZARD_TYPE                     1012
#define IDS_CONFOLD_HOMENET_WIZARD_DISPLAY_NAME     1013

// Connections Folder object type names
//
#define IDS_CONFOLD_OBJECT_TYPE_DIRECT              1020
#define IDS_CONFOLD_OBJECT_TYPE_INBOUND             1021
#define IDS_CONFOLD_OBJECT_TYPE_LAN                 1022
#define IDS_CONFOLD_OBJECT_TYPE_PHONE               1023
#define IDS_CONFOLD_OBJECT_TYPE_TUNNEL              1024
#define IDS_CONFOLD_OBJECT_TYPE_CONMAN              1025
#define IDS_CONFOLD_OBJECT_TYPE_UNKNOWN             1026
#define IDS_CONFOLD_OBJECT_TYPE_WIZARD              1027
#define IDS_CONFOLD_OBJECT_TYPE_BRIDGE              1028
#define IDS_CONFOLD_OBJECT_TYPE_SHAREDACCESSHOST    1029
#define IDS_CONFOLD_INCOMING_CONN                   1030
#define IDS_CONFOLD_OBJECT_TYPE_PPPOE               1031

// Connections Folder object status strings
//
#define IDS_CONFOLD_STATUS_AUTHENTICATING           1035
#define IDS_CONFOLD_STATUS_AUTHENTICATION_FAILED    1036
#define IDS_CONFOLD_STATUS_AUTHENTICATION_SUCCEEDED 1037
#define IDS_CONFOLD_STATUS_CREDENTIALS_REQUIRED     1038
#define IDS_CONFOLD_STATUS_INVALID_ADDRESS          1039
#define IDS_CONFOLD_STATUS_DISCONNECTED             1040
#define IDS_CONFOLD_STATUS_CONNECTING               1041
#define IDS_CONFOLD_STATUS_CONNECTED                1042
#define IDS_CONFOLD_STATUS_DISCONNECTING            1043
#define IDS_CONFOLD_STATUS_HARDWARE_NOT_PRESENT     1044
#define IDS_CONFOLD_STATUS_HARDWARE_DISABLED        1045
#define IDS_CONFOLD_STATUS_HARDWARE_MALFUNCTION     1046
#define IDS_CONFOLD_STATUS_MEDIA_DISCONNECTED       1047
#define IDS_CONFOLD_STATUS_DISABLED                 1048
#define IDS_CONFOLD_STATUS_DISABLING                1049
#define IDS_CONFOLD_STATUS_ENABLED                  1050
#define IDS_CONFOLD_STATUS_ENABLING                 1051
#define IDS_CONFOLD_STATUS_SHARED                   1052
#define IDS_CONFOLD_STATUS_BRIDGED                  1053
#define IDS_CONFOLD_STATUS_FIREWALLED               1054
#define IDS_CONFOLD_STATUS_WIRELESS_DISCONNECTED    1056

// Connections Property Caption String
//
#define IDS_CONPROP_CAPTION                         1057
#define IDS_CONPROP_NO_WRITE_LOCK                   1058
#define IDS_CONPROP_GENERIC_COMP                    1059

// Connections Error messages and captions
//
#define IDS_CONFOLD_WARNING_CAPTION                 1060
#define IDS_CONFOLD_RENAME_FAIL_CAPTION             1061
#define IDS_CONFOLD_RENAME_DUPLICATE                1062
#define IDS_CONFOLD_RENAME_OTHER_FAIL               1063
#define IDS_CONFOLD_RENAME_INVALID                  1064
#define IDS_CONFOLD_RENAME_INCOMING_CONN            1065
#define IDS_CONFOLD_DISCONNECT_FAILURE_CAPTION      1070
#define IDS_CONFOLD_DISCONNECT_FAILURE              1071
#define IDS_CONFOLD_CONNECT_FAILURE_CAPTION         1072
#define IDS_CONFOLD_CONNECT_FAILURE                 1073
#define IDS_CONFOLD_DISABLE_FAILURE_CAPTION         1074
#define IDS_CONFOLD_DISABLE_FAILURE                 1075

#define IDS_CONFOLD_DELETE_CONFIRM_SHARED           1077
#define IDS_CONFOLD_ERROR_DELETE_NOSUPPORT          1078
#define IDS_CONFOLD_ERROR_DELETE_NOSUPPORT_MULTI    1079
#define IDS_CONFOLD_DELETE_CONFIRM_SINGLE_CAPTION   1080
#define IDS_CONFOLD_DELETE_CONFIRM_MULTI_CAPTION    1081
#define IDS_CONFOLD_DELETE_CONFIRM_SINGLE           1082
#define IDS_CONFOLD_DELETE_CONFIRM_MULTI            1083
#define IDS_CONFOLD_DELETE_CONFIRM_RASSERVER        1084
#define IDS_CONFOLD_DELETE_CONFIRM_RASSERVER_MULTI  1085
#define IDS_CONFOLD_SYNC_CONFIRM                    1087
#define IDS_CONFOLD_SYNC_CONFIRM_WINDOW_TITLE       1088

#define IDS_CONFOLD_ERROR_DELETE_CAPTION            1089
#define IDS_CONFOLD_ERROR_DELETE_ACTIVE             1090
#define IDS_CONFOLD_ERROR_DELETE_ACTIVE_MULTI       1091
#define IDS_CONFOLD_ERROR_DELETE_WIZARD             1092
#define IDS_CONFOLD_ERROR_RENAME_ACTIVATING_CAPTION 1093
#define IDS_CONFOLD_ERROR_RENAME_ACTIVATING         1094
#define IDS_RESERVED_DONT_REUSE_1095                1095
#define IDS_CONFOLD_PROPERTIES_NOACCESS             1096
#define IDS_CONFOLD_CONNECT_NOACCESS                1097
#define IDS_CONFOLD_DISCONNECT_NOACCESS             1098
#define IDS_CONFOLD_CONNECT_IN_PROGRESS             1099
#define IDS_CONFOLD_UNEXPECTED_ERROR                1100
#define IDS_CONFOLD_OUTOFMEMORY                     1101
#define IDS_CONFOLD_NO_CONNECTION                   1102
#define IDS_CONFOLD_NO_PERMISSIONS_FOR_OPEN         1103
#define IDS_CONFOLD_RAS_DIALER_TITLE_FMT            1104
#define IDS_CONFOLD_ERROR_DELETE_BRIDGE_ACCESS      1105
#define IDS_CONFOLD_PROPERTIES_ON_RASSERVERINSTEAD  1106
#define IDS_CONFOLD_ERROR_DELETE_PROPERTYPAGEOPEN   1107

#define IDS_CONFOLD_DUPLICATE_PREFIX1               1150
#define IDS_CONFOLD_DUPLICATE_PREFIX2               1151

#define IDS_ADVANCEDLG_WRITE_NET_PROVIDERS_ERROR    1152
#define IDS_ADVANCEDLG_WRITE_PRINT_PROVIDERS_ERROR  1153
#define IDS_ADVANCEDLG_WRITE_PROVIDERS_CAPTION      1154

#define IDS_CONFOLD_STATUS_INCOMING_NONE            1155
#define IDS_CONFOLD_STATUS_INCOMING_ONE             1156
#define IDS_CONFOLD_STATUS_INCOMING_MULTI           1157

// Folder registration strings
//
#define IDS_CONFOLD_NAME                            1200
#define IDS_CONFOLD_INFOTIP                         1201

// Dialup connection Friendly Type Name
//
#define IDS_DUN_FRIENDLY_NAME                       1300

// Try-to-fix strings
#define IDS_FIX_NO_TCP                              1400
#define IDS_FIX_TCP_FAIL                            1401
#define IDS_FIX_ERR_RENEW_DHCP                      1402
#define IDS_FIX_ERR_FLUSH_ARP                       1403
#define IDS_FIX_ERR_PURGE_NBT                       1404
#define IDS_FIX_ERR_RR_NBT                          1405
#define IDS_FIX_ERR_FLUSH_DNS                       1406
#define IDS_FIX_ERR_REG_DNS                         1407
#define IDS_FIX_SUCCEED                             1408
#define IDS_FIX_ERROR_FORMAT                        1409
#define IDS_FIX_ERROR                               1410
#define IDS_FIX_CAPTION                             1411
#define IDS_FIX_MESSAGE                             1412
#define IDS_FIX_REPAIRING                           1413

// Connections Folder Toolbar Strings
//
#if 0   // Removed (for now) - Jeffspr
#define IDS_TOOLBAR_MAKE_NEW_STRING                 2000
#endif
#define IDS_TOOLBAR_CONNECT_STRING                  2001

// Connections Folder Random Strings
//
#define IDS_CONFOLD_DETAILS_OWNER_SYSTEM            2100    // Name of "System" owner.

// Connections Tray messages
//
#define IDS_CONTRAY_INITIAL_BALLOON                 2200
#define IDS_CONTRAY_MEDIA_DISCONN_BALLOON           2201
#define IDS_TOOLTIP_LINE_SPEED                      2202
#define IDS_TOOLTIP_LINE_BYTES_SENT                 2203
#define IDS_TOOLTIP_LINE_PACKETS_SENT               2204
#define IDS_TOOLTIP_LINE_BYTES_RCVD                 2205
#define IDS_TOOLTIP_LINE_PACKETS_RCVD               2206
#define IDS_TOOLTIP_MEDIA_DISCONNECTED              2207
#define IDS_CONTRAY_WIRELESS_DISCONN_BALLOON        2208
#define IDS_TOOLTIP_WIRELESS_DISCONNECTED           2209
#define IDS_CONTRAY_AUTHENTICATION_SUCCEEDED_BALLOON 2214
#define IDS_CONTRAY_AUTHENTICATION_FAILED_BALLOON   2215
#define IDS_TOOLTIP_AUTHENTICATING                  2216
#define IDS_TOOLTIP_AUTHENTICATION_FAILED           2217
#define IDS_TOOLTIP_ADDRESS_INFO                    2218
#define IDS_TOOLTIP_ADHOC                           2219
#define IDS_TOOLTIP_INFRASTRUCTURE                  2220
#define IDS_TOOLTIP_LINE_SPEED_INFRASTRUCTURE       2221
#define IDS_CONTRAY_ADDRESS_INVALID_BALLOON         2222
#define IDS_BALLOON_CONNECTED                       2223
#define IDS_CONTRAY_STATIC_ADDR_INVALID_BALLON      2224
#define IDS_CONTRAY_STATIC_ADDR_INVALID_TOOLTIP     2225
#define IDS_CONTRAY_ADDRESS_INVALID_TOOLTIP         2226
#define IDS_DETAILS_IP_ADDRESS                      2227
#define IDS_DETAILS_ADDRESS_TYPE                    2228
#define IDS_DETAILS_802_11_MODE                     2229
#define IDS_DETAILS_802_11_SSID_TYPE                2230
#define IDS_DETAILS_802_11_ENCRYPTION_TYPE          2231
#define IDS_DETAILS_802_11_SIGNAL_STRENGTH          2232
#define IDS_TOOLTIP_WIRELESS_CONNECTED              2234
#define IDS_NAME_NETWORK                            2235
#define IDS_SIGNAL_STRENGTH                         2236
#define IDS_BALLOON_UNAVAILABLE                     2237

// Connections folder menuitem strings (for switchable menuitems)
//
#define IDS_CONNECT_MENUITEM                        2210
#define IDS_DISCONNECT_MENUITEM                     2211
#define IDS_ENABLE_MENUITEM                         2212
#define IDS_DISABLE_MENUITEM                        2213

// Common bitmap and icon resources
//
#define IDI_UP_ARROW                                2300
#define IDI_DOWN_ARROW                              2301
#define IDB_IMAGELIST                               2302
#define IDB_CHECKSTATE                              2303
#define IDB_WZCSTATE                                2304

// Generic Strings
//
#define IDS_REBOOT_REQUIRED                         2400
#define IDS_WHATS_THIS                              2401
#define IDS_COMMA                                   2402

// OC Manager Caption Text
//
#define IDS_CONFOLD_OC_TITLE                        2403


// Home Net Auto Config Tray Messages
#define IDS_AUTOCONFIGTRAY_RUN_HOME_NET_WIZARD_BALLOON_TITLE 2500
#define IDS_AUTOCONFIGTRAY_RUN_HOME_NET_WIZARD_BALLOON       2501

// SIP Strings
#define IDS_AUTONET             2570
#define IDS_DHCP                2571
#define IDS_ALTERNATE_ADDR      2572
#define IDS_STATIC_CFG          2573
#define IDS_DHCP_ISP            2574


// Wireless Signal Strength
#define IDS_802_11_LEVEL0       2600
#define IDS_802_11_LEVEL1       2601
#define IDS_802_11_LEVEL2       2602
#define IDS_802_11_LEVEL3       2603
#define IDS_802_11_LEVEL4       2604
#define IDS_802_11_LEVEL5       2605

#define IDI_802_11_LEVEL0       2610
#define IDI_802_11_LEVEL1       2611
#define IDI_802_11_LEVEL2       2612
#define IDI_802_11_LEVEL3       2613
#define IDI_802_11_LEVEL4       2614
#define IDI_802_11_LEVEL5       2615
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\pppoeui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P P P O E U I . H
//
//  Contents:   PPPoE connection UI object.
//
//  Notes:
//
//  Author:     mbend   10 May 2000
//
//----------------------------------------------------------------------------

#pragma once
#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "rasui.h"


class ATL_NO_VTABLE CPPPoEUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CPPPoEUi,
                        &CLSID_PPPoEUi>,
    public CRasUiBase,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionWizardUi
{
public:
    CPPPoEUi () : CRasUiBase () {m_dwRasWizType = RASWIZ_TYPE_BROADBAND;};

    DECLARE_REGISTRY_RESOURCEID(IDR_PPPOE_UI)

    BEGIN_COM_MAP(CPPPoEUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionConnectUi
    STDMETHOD (SetConnection) (
        INetConnection* pCon);

    STDMETHOD (Connect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    STDMETHOD (Disconnect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    // INetConnectionPropertyUi2
    STDMETHOD (AddPages) (
        HWND                    hwndParent,
        LPFNADDPROPSHEETPAGE    pfnAddPage,
        LPARAM                  lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (
        INetConnectionWizardUiContext*  pContext,
        DWORD*                          pcMaxPages);

    STDMETHOD (AddPages) (
        INetConnectionWizardUiContext*  pContext,
        LPFNADDPROPSHEETPAGE            pfnAddPage,
        LPARAM                          lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName) (
        PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (
        PCWSTR pszwConnectionName);

    STDMETHOD (GetNewConnection) (
        INetConnection**    ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\repair.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R E P A I R . H 
//
//  Contents:   routines related the repair feature
//
//  Notes:      
//
//  Author:     nsun Jan 2001
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _REPAIR_H_
#define _REPAIR_H_

HRESULT HrTryToFix(
    GUID & guidConnection, 
    tstring & strMessage);

HRESULT RepairConnectionInternal(
                    GUID & guidConnection,
                    LPWSTR * ppszMessage);

HRESULT OpenNbt(
            LPWSTR pwszGuid, 
            HANDLE * pHandle);
                                                         
#endif // _REPAIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\shortcut.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S H O R T C U T . H
//
//  Contents:
//
//  Notes:
//
//  Author:     scottbri   19 June 1998
//
//----------------------------------------------------------------------------

#ifndef _SHORTCUT_H_
#define _SHORTCUT_H_

HRESULT HrCreateStartMenuShortCut(HWND hwndParent,
                                  BOOL fAllUsers,
                                  PCWSTR pszName,
                                  INetConnection * pConn);

#endif  // _SHORTCUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\openfold.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O P E N F O L D . H 
//
//  Contents:   Utility function for opening the connections folder
//
//  Notes:      
//
//  Author:     jeffspr   12 Jan 1998
//
//----------------------------------------------------------------------------

#ifndef _OPENFOLD_H_
#define _OPENFOLD_H_

// Get our folder pidl
//
HRESULT HrGetConnectionsFolderPidl(OUT PCONFOLDPIDLFOLDER& ppidlFolder);

// Bring up the connections folder UI
//
HRESULT HrOpenConnectionsFolder();

// Get an IShellFolder * given the folder pidl
//
HRESULT HrGetConnectionsIShellFolder(
    IN  const PCONFOLDPIDLFOLDER& pidlFolder, 
    OUT LPSHELLFOLDER * ppsf);

// Note -- This code is actually in folder\oncommand.cpp, but can be
// referenced from any place that needs it.
//
VOID    RefreshFolderItem(IN const PCONFOLDPIDLFOLDER& pidlFolder, 
                          IN const PCONFOLDPIDL& pidlItemOld,
                          IN const PCONFOLDPIDL& pidlItemNew,
                          BOOL fRestart = FALSE);

#endif // _OPENFOLD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\rasui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R A S U I . H
//
//  Contents:   Declares the base class used to implement the Dialup, Direct,
//              Internet, and Vpn connection UI objects.
//
//  Notes:
//
//  Author:     shaunco   17 Dec 1997  (and that's the code complete date!)
//
//----------------------------------------------------------------------------

#pragma once


HRESULT
HrCreateInboundConfigConnection (
    INetConnection** ppCon);


class CRasUiBase
{
protected:
    // This is our connection given to us via the SetConnection method.
    //
    INetConnection*     m_pCon;

    // This is the name of the connection told to us via SetConnectionName.
    // It is used subsequently during GetNewConnection to name the entry.
    //
    tstring             m_strConnectionName;

    // These structures are used to allow the property UI to be displayed.
    // Since our call to RasEntryDlg returns before the shell displays the UI,
    // we have to keep the memory that will be referenced by the property
    // pages valid.
    //
    RASCON_INFO         m_RasConInfo;
    RASENTRYDLG         m_RasEntryDlg;
    RASEDSHELLOWNEDR2   m_ShellCtx;

    // This member defines the type of connection that is subclassed off of
    // this base.  It is used to inform rasdlg.dll as to whether this is a
    // dialup, direct, or incoming connection
    //
    DWORD               m_dwRasWizType;

protected:
    CRasUiBase ();
    ~CRasUiBase ();

    HRESULT
    HrSetConnection (
        IN INetConnection* pCon,
        IN CComObjectRootEx <CComObjectThreadModel>* pObj);

    HRESULT
    HrConnect (
        IN HWND hwndParent,
        IN DWORD dwFlags,
        IN CComObjectRootEx <CComObjectThreadModel>* pObj,
        IN IUnknown* punk);

    HRESULT
    HrDisconnect (
        IN HWND hwndParent,
        IN DWORD dwFlags);

    HRESULT
    HrAddPropertyPages (
        IN HWND hwndParent,
        IN LPFNADDPROPSHEETPAGE pfnAddPage,
        IN LPARAM lParam);

    HRESULT
    HrQueryMaxPageCount (
        IN INetConnectionWizardUiContext* pContext,
        OUT DWORD* pcMaxPages);

    HRESULT
    HrAddWizardPages (
        IN INetConnectionWizardUiContext* pContext,
        IN LPFNADDPROPSHEETPAGE pfnAddPage,
        IN LPARAM lParam,
        IN DWORD dwFlags);

    HRESULT
    HrGetSuggestedConnectionName (
        OUT PWSTR* ppszwSuggestedName);

    
    HRESULT
    HrGetNewConnectionInfo (
        OUT DWORD* pdwFlags);

    HRESULT
    HrSetConnectionName (
        IN PCWSTR pszwConnectionName);

    HRESULT
    HrGetNewConnection (
        OUT INetConnection** ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\smcent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M C E N T . H
//
//  Contents:   The central object that controls statistic engines.
//
//  Notes:
//
//  Author:     CWill   11 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _SMCENT_H
#define _SMCENT_H

#include "cfpidl.h"
#include "netshell.h"
#include "ras.h"

typedef struct tagSM_TOOL_FLAGS
{
    DWORD   dwValue;
    WCHAR*  pszFlag;
} SM_TOOL_FLAGS;


// The flag bits
//
typedef enum tagSM_CMD_LINE_FLAGS
{
    SCLF_CONNECTION     = 0x00000001,
    SCLF_ADAPTER        = 0x00000002,
} SM_CMD_LINE_FLAGS;


// *** The index and the flags have to be in sync *** //
//
typedef enum tagSM_TOOL_FLAG_INDEX
{
    STFI_CONNECTION     = 0,
    STFI_ADAPTER,
    STFI_MAX,
} SM_TOOL_FLAG_INDEX;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CStatMonToolEntry                                                       //
//                                                                          //
//  This class is used to keep tack of any tool entries that are found in   //
//  registry to be shown in the tools page.                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

class CStatMonToolEntry
{
public:
    CStatMonToolEntry(VOID);
    ~CStatMonToolEntry(VOID);

public:
    tstring         strDisplayName;
    tstring         strDescription;
    tstring         strCommandLine;
    tstring         strManufacturer;

    list<tstring*>  lstpstrComponentID;
    list<tstring*>  lstpstrConnectionType;
    list<tstring*>  lstpstrMediaType;

    DWORD           dwFlags;
};

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CNetStatisticsCentral                                                   //
//                                                                          //
//  This global class manages all the engines that have been created.  It   //
//  is also responsible for keeping the statistics flowing by telling the   //
//  engines to update their statistics and notify their advises.            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef DWORD (APIENTRY* PRASGETCONNECTIONSTATISTICS)(HRASCONN, RAS_STATS*);
typedef DWORD (APIENTRY* PRASGETCONNECTSTATUS)(HRASCONN, RASCONNSTATUS*);

typedef class CNetStatisticsEngine CNetStatisticsEngine;

class CStatCentralCriticalSection
{
  CRITICAL_SECTION  m_csStatCentral;
  BOOL              bInitialized;

  public:
    CStatCentralCriticalSection();
    ~CStatCentralCriticalSection();
    HRESULT Enter();
    VOID Leave();
};

class CNetStatisticsCentral :
    public IUnknown,
    public CComObjectRootEx <CComObjectThreadModel>
{
public:
    virtual ~CNetStatisticsCentral();

// Message handlers
public:
    static VOID CALLBACK TimerCallback( HWND hwnd, UINT uMsg,
                                        UINT_PTR idEvent, DWORD dwTime);
    VOID RefreshStatistics(DWORD dwTime);
    VOID UpdateTitle(const GUID * pguidId, PCWSTR pszwNewName);
    VOID UpdateRasLinkList(const GUID * pguidId);
    VOID CloseStatusMonitor(const GUID * pguidId);

public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    static
    HRESULT
    HrGetNetStatisticsCentral(
        CNetStatisticsCentral ** ppnsc,
        BOOL fCreate);

    HRESULT RemoveNetStatisticsEngine(const GUID* pguidId);

    HRESULT HrReadTools(VOID);

    list<CStatMonToolEntry*>* PlstsmteRegEntries(VOID);

private:
    CNetStatisticsCentral();

    HRESULT HrCreateNewEngineType(
        const CONFOLDENTRY& pccfe,
        CNetStatisticsEngine** ppObj);

    HRESULT HrCreateStatisticsEngineForEntry(
        const CONFOLDENTRY& pccfe,
        INetStatisticsEngine** ppNetStatEng);


    BOOL FEngineInList( const GUID* pguidId,
                        INetStatisticsEngine** ppnseRet);

    HRESULT HrReadOneTool(HKEY hkeyToolEntry,
                          CStatMonToolEntry* psmteNew);

    HRESULT HrReadToolFlags(HKEY hkeyToolEntry,
                            CStatMonToolEntry* psmteNew);

    VOID InsertNewTool(CStatMonToolEntry* psmteTemp);

private:
    ULONG                              m_cRef;     // Object Ref count
    BOOL                               m_fProcessingTimerEvent;
    UINT_PTR                           m_unTimerId;
    list<INetStatisticsEngine*>        m_pnselst;
    list<CStatMonToolEntry*>           m_lstpsmte;
    static CStatCentralCriticalSection g_csStatCentral;

    friend
    HRESULT
    HrGetStatisticsEngineForEntry (
        const CONFOLDENTRY& pccfe,
        INetStatisticsEngine** ppnse,
        BOOL fCreate);
};

HRESULT
HrGetStatisticsEngineForEntry (
    const CONFOLDENTRY& pccfe,
    INetStatisticsEngine** ppnse, 
    BOOL fCreate);

#endif // _SMCENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\windutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       W I N D U T I L . H 
//
//  Contents:   Window utilities for the connections shell
//
//  Notes:      
//
//  Author:     jeffspr   22 May 1998
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _WINDUTIL_H_
#define _WINDUTIL_H_

BOOL FCenterWindow (HWND hwndChild, HWND hwndParent);

#endif _WINDUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\smutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M U T I L . H
//
//  Contents:   Utility functions to help out the status monitor
//
//  Notes:
//
//  Author:     CWill   2 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "netcon.h"

BOOL
FIsStringInList(
    list<tstring*>* plstpstrList,
    const WCHAR*    szString);

HRESULT
HrGetPcpFromPnse(
    INetStatisticsEngine*   pnseSrc,
    IConnectionPoint**      ppcpStatEng);

INT
IGetCurrentConnectionTrayIconId(
    NETCON_MEDIATYPE    ncmType,
    NETCON_STATUS       ncsStatus,
    DWORD               dwChangeFlags);

HICON
GetCurrentConnectionStatusIconId(
    NETCON_MEDIATYPE    ncmType,
    NETCON_SUBMEDIATYPE ncsmType,
    DWORD               dwCharacteristics,
    DWORD               dwChangeFlags);

INT
FormatTransmittingReceivingSpeed(
    UINT    nTransmitSpeed,
    UINT    nRecieveSpeed,
    WCHAR*  pchBuf);

VOID
FormatTimeDuration(
    UINT        uiMilliseconds,
    tstring*    pstrOut);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\inc\vpnui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       V P N U I . H
//
//  Contents:   VPN connection UI object.
//
//  Notes:
//
//  Author:     shaunco   17 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <netshell.h>
#include "nsbase.h"
#include "nsres.h"
#include "rasui.h"


class ATL_NO_VTABLE CVpnConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CVpnConnectionUi,
                        &CLSID_VpnConnectionUi>,
    public CRasUiBase,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionWizardUi
{
public:
    CVpnConnectionUi () : CRasUiBase () {m_dwRasWizType = RASWIZ_TYPE_DIALUP;};

    DECLARE_REGISTRY_RESOURCEID(IDR_VPN_UI)

    BEGIN_COM_MAP(CVpnConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionConnectUi
    STDMETHOD (SetConnection) (
        INetConnection* pCon);

    STDMETHOD (Connect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    STDMETHOD (Disconnect) (
        HWND    hwndParent,
        DWORD   dwFlags);

    // INetConnectionPropertyUi2
    STDMETHOD (AddPages) (
        HWND                    hwndParent,
        LPFNADDPROPSHEETPAGE    pfnAddPage,
        LPARAM                  lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (
        INetConnectionWizardUiContext*  pContext,
        DWORD*                          pcMaxPages);

    STDMETHOD (AddPages) (
        INetConnectionWizardUiContext*  pContext,
        LPFNADDPROPSHEETPAGE            pfnAddPage,
        LPARAM                          lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName) (
        PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (
        PCWSTR pszwConnectionName);

    STDMETHOD (GetNewConnection) (
        INetConnection**    ppCon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\advpage.h ===
#pragma once

#include "nsbase.h"     // must be first to include atl
#include "ncatlps.h"

HRESULT HrCreateHomenetUnavailablePage(HRESULT hErrorResult, CPropSheetPage*& pspAdvanced);

class CLanHomenetUnavailable: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CLanHomenetUnavailable)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
    END_MSG_MAP()

    CLanHomenetUnavailable(HRESULT hErrorResult);
    ~CLanHomenetUnavailable();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);


private:
    HRESULT m_hErrorResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\advpage.cpp ===
#include "pch.h"
#pragma hdrstop
#include "advpage.h"
#include "resource.h"


//+---------------------------------------------------------------------------
//
//  Function:   HrCreateHomenetUnavailablePage
//
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     kenwic   19 Dec 2000
//
//  Notes:
//
HRESULT HrCreateHomenetUnavailablePage(HRESULT hErrorResult,
                            CPropSheetPage*& pspPage)
{
    pspPage = new CLanHomenetUnavailable(hErrorResult);
    
    return S_OK;
}

CLanHomenetUnavailable::CLanHomenetUnavailable(HRESULT hErrorResult)
{
    m_hErrorResult = hErrorResult;
    LinkWindow_RegisterClass(); // REVIEW failure here?
}

CLanHomenetUnavailable::~CLanHomenetUnavailable()
{
    LinkWindow_UnregisterClass(_Module.GetResourceInstance());

}

//+---------------------------------------------------------------------------
//
//  Member:     CLanHomenetUnavailable::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     aboladeg   14 May 1998
//
//  Notes:
//
LRESULT CLanHomenetUnavailable::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    SetDlgItemText(IDC_ST_ERRORTEXT, SzLoadIds(m_hErrorResult == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED) ? IDS_ADVANCEDPAGE_NOWMI_ERROR : IDS_ADVANCEDPAGE_STORE_ERROR));
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanHomenetUnavailable::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanHomenetUnavailable::OnContextMenu(UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam,
                           BOOL& fHandled)
{
//        ::WinHelp(m_hWnd,
//                  c_szNetCfgHelpFile,
//                  HELP_CONTEXTMENU,
//                  (ULONG_PTR)m_adwHelpIDs);

    return 0;

}

//+---------------------------------------------------------------------------
//
//  Member:     CLanHomenetUnavailable::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanHomenetUnavailable::OnHelp(UINT uMsg,
                      WPARAM wParam,
                      LPARAM lParam,
                      BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        //::WinHelp(static_cast<HWND>(lphi->hItemHandle), c_szNetCfgHelpFile, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanHomenetUnavailable::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     kenwic   11 Sep 2000
//
//  Notes:
//
LRESULT CLanHomenetUnavailable::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\devdatatip.h ===
VOID
CreateDeviceDataTip (
    IN HWND hwndParent,
    IN OUT HWND* phwndDataTip,
    IN UINT nIdTool,
    IN PCWSTR pszDevNodeId,
    IN PCWSTR pszBindName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\chklist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C H K L I S T . C P P
//
//  Contents:   Implements bindings checkbox related utility functions
//              and classes.
//
//  Notes:
//
//  Created:     tongl   20 Nov 1997
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "ncnetcfg.h"
#include "ncui.h"
#include "ncstl.h"
#include "lanuiobj.h"
#include "lanui.h"
#include "util.h"
#include "chklist.h"
#include "ncperms.h"

//+---------------------------------------------------------------------------
//
//  Member:     HrRebuildBindingPathObjCollection
//
//  Purpose:    Build or rebuild a list of BindingPathObjects,
//              establish the links between sub-paths and super-paths,
//              as well as between ComponentObjects in the list view
//              and elements of the BindingPathObject collection
//
//  Arguments:
//      [IN]    pnccAdapter
//      [IN]    hList
//      [INOUT] pListObj
//
//  Returns:    TRUE
//
//  Author:     tongl   20 Nov 1997
//
//  Notes:
//
HRESULT HrRebuildBindingPathObjCollection(INetCfgComponent * pnccAdapter,
                                          ListBPObj * pListBPObj)
{
    HRESULT hr = S_OK;

    // now, add new BindingPathObjects to our list
    CIterNetCfgUpperBindingPath     ncbpIter(pnccAdapter);
    INetCfgBindingPath *            pncbp;

    TraceTag(ttidLanUi, "*** List of binding paths: begin ***");

    // Go through all upper binding paths starting from the current LAN
    // adapter, and add to our list of BindingPathObjects:
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        PrintBindingPath(ttidLanUi, pncbp, NULL);

        // create a new BindingPathObj
        CBindingPathObj * pBPObj = new CBindingPathObj(pncbp);

        // insert to our list, sorted by the length of the path
        // and establish super/sub path lists with existing items in
        // the list
        hr = HrInsertBindingPathObj(pListBPObj, pBPObj);
        ReleaseObj(pncbp);
    }

    TraceTag(ttidLanUi, "*** List of binding paths: end ***");

#if DBG
    TraceTag(ttidLanUi, "%%% Begin dump the subpath list %%%");

    for (ListBPObj_ITER iter = pListBPObj->begin(); iter != pListBPObj->end(); iter++)
    {
        (*iter)->DumpSubPathList();
    }

    TraceTag(ttidLanUi, "%%% End dump the subpath list %%%");
#endif

    if (hr == S_FALSE) // We just got to the end of the loop
        hr = S_OK;

    TraceError("HrRebuildBindingPathObjCollection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrInsertBindingPathObj
//
//  Purpose:    Insert a BindingPathObj to a list of BindingPathObj's,
//              keep the list sorted by the length of paths.
//              Also establishs super/sub path lists with existing items
//              in the list.
//
//  Arguments:
//          [INOUT] pListBPObj
//          [IN]    pBPObj
//
//  Returns:    S_OK if succeeded,
//              otherwise return a failure code
//
//  Author:     tongl   20 Nov 1997
//
//  Notes:
//
HRESULT HrInsertBindingPathObj(ListBPObj * pListBPObj,
                               CBindingPathObj * pBPObj)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    ListBPObj_ITER iter;

    // insert the new element
    for (iter = pListBPObj->begin();iter != pListBPObj->end(); iter++)
    {
        if ((*iter)->GetDepth() > pBPObj->GetDepth())
            break;
    }

    // insert at the current position
    ListBPObj_ITER iterNewItem = pListBPObj->insert(iter, pBPObj);

    // set subpaths and superpaths
    // Because of the change in the new binding engine for paths for DONT_EXPOSE_LOWER
    // components, we have to compare with every item in the list because the length
    // no longer garantees which one is the subpath..

    for (iter = pListBPObj->begin(); iter != pListBPObj->end(); iter++)
    {
        // Is this a sub-path ?
        hrTmp = ((*iter)->m_pncbp)->IsSubPathOf((*iterNewItem)->m_pncbp);
        if (S_OK == hrTmp)
        {
            hrTmp = (*iter)->HrInsertSuperPath(*iterNewItem);
            if SUCCEEDED(hr)
                hr = hrTmp;

            hrTmp = (*iterNewItem)->HrInsertSubPath(*iter);
            if SUCCEEDED(hr)
                hr = hrTmp;
        }

        // Is this a super-path ?
        hrTmp = ((*iterNewItem)->m_pncbp)->IsSubPathOf((*iter)->m_pncbp);
        if (S_OK == hrTmp)
        {
            hrTmp = (*iter)->HrInsertSubPath(*iterNewItem);
            if SUCCEEDED(hr)
                hr = hrTmp;

            hrTmp = (*iterNewItem)->HrInsertSuperPath(*iter);
            if SUCCEEDED(hr)
                hr = hrTmp;
        }
    }

    TraceError("HrInsertBindingPathObj", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrRefreshBindingPathObjCollectionState
//
//  Purpose:    Refresh the binding state of all items in the collection
//              of BindingPathObjects
//
//  Arguments:
//              [INOUT] pListBPObj
//
//  Returns:    S_OK if succeeded,
//              otherwise return a failure code
//
//  Author:     tongl   20 Nov 1997
//
//  Notes:
//
HRESULT HrRefreshBindingPathObjCollectionState(ListBPObj * plistBPObj)
{
    HRESULT hr = S_OK;
    ListBPObj_ITER iter;

    // first, clearup any existing state
    for (iter = plistBPObj->begin();iter != plistBPObj->end(); iter++)
    {
        (*iter)->SetBindingState(BPOBJ_UNSET);
    }

    // now set the new states
    TraceTag(ttidLanUi, "*** List of binding paths: begin ***");

    for (iter = plistBPObj->begin();iter != plistBPObj->end(); iter++)
    {
        Assert((*iter)->GetBindingState() != BPOBJ_ENABLED);

#if DBG
        PrintBindingPath (ttidLanUi, (*iter)->m_pncbp, NULL);
#endif

        if (BPOBJ_UNSET != (*iter)->GetBindingState())
        {
            continue;
        }

        // if it's not disabled yet, i.e. all of its sub paths
        // are enabled.
        hr = ((*iter)->m_pncbp)->IsEnabled();
        if (S_OK == hr) // enabled
        {
            (*iter)->SetBindingState(BPOBJ_ENABLED);
            continue;
        }
        else if (S_FALSE == hr) // disabled
        {
            // normal disabled case
            (*iter)->SetBindingState(BPOBJ_DISABLED);

            // special cases:
            // if the check state of the corresponding component is intent_check or mixed or checked
            if ((*iter)->m_pCompObj != NULL)
            {
                // if user is not intentionally unchecking this component
                if ((*iter)->m_pCompObj->m_ExpCheckState != UNCHECKED)
                {
                    // if the component should be checked or if it's hidden
                    if ((((*iter)->m_pCompObj)->m_CheckState == INTENT_CHECKED) ||
                        (((*iter)->m_pCompObj)->m_CheckState == MIXED) ||
                        (((*iter)->m_pCompObj)->m_CheckState == CHECKED))
                    {
                        // (#297772) We should only do this if one of the subpaths has just
                        // been re-enabled by user
                        BOOL fSubPathEnabled = FALSE;

                        ListBPObj_ITER iterSub;
                        for (iterSub = (*iter)->m_listSubPaths.begin();
                             iterSub != (*iter)->m_listSubPaths.end();
                             iterSub++)
                        {
                            // is the top component just enabled ?
                            INetCfgComponent * pncc;
                            hr = (*iterSub)->m_pncbp->GetOwner(&pncc);
                            if (SUCCEEDED(hr))
                            {
                                if (((*iterSub)->m_pCompObj != NULL) &&
                                    (CHECKED == (*iterSub)->m_pCompObj->m_ExpCheckState))
                                {
                                    fSubPathEnabled = TRUE;
                                }
                                ReleaseObj(pncc);

                                if (fSubPathEnabled)
                                    break;
                            }
                        }

                        if (fSubPathEnabled)
                        {
                            // Special case: enable the following binding path because
                            // 1) it's check state is intent or mixed, and
                            // 2) one of it's sub-paths is newly enabled
                            #if DBG
                                TraceTag(ttidLanUi, "Special case, enable the following path:");
                                PrintBindingPath(ttidLanUi, (*iter)->m_pncbp, "\n");
                            #endif

                            hr = HrEnableBindingPath((*iter)->m_pncbp, TRUE);
                            if (S_OK == hr)
                            {
                                (*iter)->SetBindingState(BPOBJ_ENABLED);
                                continue;
                            }
                        }
                    }
                }
            }
        }
    }
    TraceTag(ttidLanUi, "*** List of binding paths: end ***");

    TraceError("HrRefreshBindingPathObjCollectionState", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrRefreshCheckListState
//
//  Purpose:    Refresh the check state of all components in the list view
//
//  Arguments:
//
//  Returns:    S_OK if succeeded,
//              otherwise return a failure code
//
//  Author:     tongl   20 Nov 1997
//
//  Notes:
//

HRESULT HrRefreshCheckListState(HWND hListView)
{
    HRESULT hr = S_OK;

    TraceTag(ttidLanUi, "<<<<<Entering HrRefreshCheckListState");

    // for each item in the list view
    int nlvCount = ListView_GetItemCount(hListView);

    LV_ITEM lvItem;

    for (int i=0; i< nlvCount; i++)
    {
        lvItem.iItem = i;
        lvItem.iSubItem = 0;

        lvItem.mask = LVIF_PARAM;
        if (ListView_GetItem(hListView, &lvItem))
        {
            NET_ITEM_DATA * pnid;

            pnid = reinterpret_cast<NET_ITEM_DATA *>(lvItem.lParam);

            if (pnid)
            {
                // get the component object associated with this item
                CComponentObj * pCompObj = pnid->pCompObj;

                // get counts for enabled & disabled paths
                int iEnabled = 0;
                int iDisabled =0;

                // for each ComponentObject on the list
                ListBPObj_ITER iter;
                for (iter = (pCompObj->m_listBPObj).begin();
                     iter != (pCompObj->m_listBPObj).end();
                     iter++)
                {
                    // the state should not be unset
                    Assert((*iter)->m_BindingState != BPOBJ_UNSET);

                    // if enabled
                    switch ((*iter)->m_BindingState)
                    {
                    case BPOBJ_ENABLED:

                        PrintBindingPath(ttidLanUi, (*iter)->m_pncbp, "is enabled");

                        iEnabled++;
                        break;

                    case BPOBJ_DISABLED:

                        PrintBindingPath(ttidLanUi, (*iter)->m_pncbp, "is disabled");

                        // $REVIEW(tongl 1/19/98): According to SteveFal,
                        // for paths with length>1, we only count "disabled" if
                        // the sub paths are all enabled but the main path is disabled.

                        // Bug #304606, can't use length any more with IPX special case
                        {
                            // Is all the subpaths enabled ?
                            BOOL fAllSubPathsEnabled = TRUE;
                            ListBPObj_ITER iterSubPath;
                            for (iterSubPath =  ((*iter)->m_listSubPaths).begin();
                                 iterSubPath != ((*iter)->m_listSubPaths).end();
                                 iterSubPath++)
                            {
                                if ((*iterSubPath)->m_BindingState == BPOBJ_DISABLED)
                                {
                                    fAllSubPathsEnabled = FALSE;
                                    break;
                                }
                            }

                            if (fAllSubPathsEnabled)
                            {
                                // Is the binding path itself enabled ?
                                hr = ((*iter)->m_pncbp)->IsEnabled();
                                if (S_FALSE == hr)
                                {
                                    iDisabled++;
                                    hr = S_OK;
                                }
                            }
                        }
                        break;

                    default:
                        PrintBindingPath(ttidLanUi, (*iter)->m_pncbp, "*** has an invalid binding state ***");
                        break;
                    }
                }

                UINT iChkIndex = 0;
                BOOL fHasPermission = FHasPermission(NCPERM_ChangeBindState);

                if (pnid->dwFlags & NCF_FIXED_BINDING)
                {
                    // Don't change the checked state, we just want to prevent
                    // the user from changing it.
                    iChkIndex = SELS_FIXEDBINDING_ENABLED;
                }
                else if ((iEnabled >0) && (iDisabled == 0))
                {
                    if (!fHasPermission)
                    {
                        iChkIndex = SELS_FIXEDBINDING_ENABLED;
                    }
                    else
                    {
                        // current state is "checked"
                        pCompObj->m_CheckState = CHECKED;
                        iChkIndex = SELS_CHECKED;
                    }
                }
                else if ((iEnabled >0) && (iDisabled > 0))
                {
                    if (!fHasPermission)
                    {
                        iChkIndex = SELS_FIXEDBINDING_ENABLED;
                    }
                    else
                    {
                        // current state is "mixed"
                        pCompObj->m_CheckState = MIXED;
                        iChkIndex = SELS_INTERMEDIATE;
                    }
                }
                else //iEnabled ==0
                {
                    if (!fHasPermission)
                    {
                        iChkIndex = SELS_FIXEDBINDING_DISABLED;
                    }
                    else
                    {
                        if (pCompObj->m_ExpCheckState == CHECKED)
                        {
                            // change current state to "intent checked"
                            pCompObj->m_CheckState = INTENT_CHECKED;
    
                            // $REVIEW(tongl 1/19/98): SteveFal wants to show the
                            // intent state as checked in the display
                            // iChkIndex = SELS_INTENTCHECKED;
                            iChkIndex = SELS_CHECKED;
                        }
                        else if (pCompObj->m_ExpCheckState == UNSET)
                        {
                            // we are not changing this component
                            if  ((pCompObj->m_CheckState == CHECKED) ||
                                 (pCompObj->m_CheckState == MIXED) ||
                                 (pCompObj->m_CheckState == INTENT_CHECKED))
                            {
                                // set current state to "intent checked"
                                pCompObj->m_CheckState = INTENT_CHECKED;
    
                                // $REVIEW(tongl 1/19/98): SteveFal wants to show the
                                // intent state as checked in the display
                                // iChkIndex = SELS_INTENTCHECKED;
                                iChkIndex = SELS_CHECKED;
                            }
                            else
                            {
                                // set current state to "unchecked"
                                pCompObj->m_CheckState = UNCHECKED;
                                iChkIndex = SELS_UNCHECKED;
                            }
                        }
                        else
                        {
                            // current state is "unchecked"
                            pCompObj->m_CheckState = UNCHECKED;
                            iChkIndex = SELS_UNCHECKED;
                        }
                    }
                }

                // clear up expected check state
                pCompObj->m_ExpCheckState = UNSET;

                // update the checkmark
                AssertSz(iChkIndex, "What's the new check state ??");

                lvItem.mask = LVIF_STATE;
                lvItem.stateMask = LVIS_STATEIMAGEMASK;
                lvItem.state = INDEXTOSTATEIMAGEMASK(iChkIndex);
                BOOL ret = ListView_SetItem(hListView, &lvItem);
            }
        }
    }

    TraceError("HrRefreshCheckListState", hr);

    TraceTag(ttidLanUi, ">>>>>Leaving HrRefreshCheckListState");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     HrEnableBindingPath
//
//  Purpose:    Wraps the INetCfgBindingPath->Enable method with the following
//              flags: if enabling, it applies to all hidden super paths, if
//              disabling, it applies to all super paths.
//
//
//  Arguments:
//          [IN] pncbp : the binding path to enable or disable
//          [IN] fEnable : Enable = TRUE; disable = FALSE
//
//  Returns:    S_OK if succeeded,
//              otherwise return a failure code
//
//  Author:     tongl   5 Dec 1997
//
//  Notes:
//
HRESULT HrEnableBindingPath(INetCfgBindingPath * pncbpThis, BOOL fEnable)
{
    HRESULT hr;

    hr = pncbpThis->Enable(fEnable);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBindingPathObj implementation
//
//  Author:     tongl   20 Nov 1997
//
//  Notes:
//

CBindingPathObj::CBindingPathObj(INetCfgBindingPath * pncbp)
{
    Assert(pncbp);
    m_pncbp = pncbp;
    m_pncbp->AddRef();

    // Initialize other members
    m_pCompObj = NULL;

    m_BindingState = BPOBJ_UNSET;

    HRESULT hr = pncbp->GetDepth(&m_ulPathLen);
    TraceError("CBindingPathObj::CBindingPathObj failed on GetDepth", hr);
}

CBindingPathObj::~CBindingPathObj()
{
    ReleaseObj(m_pncbp);

    m_listSubPaths.erase (m_listSubPaths.begin(), m_listSubPaths.end());
    m_listSuperPaths.erase (m_listSuperPaths.begin(), m_listSuperPaths.end());
}

HRESULT CBindingPathObj::HrInsertSuperPath(CBindingPathObj * pbpobjSuperPath)
{
    HRESULT hr = S_OK;

    ListBPObj_ITER iter;

    // insert the new super path into the list, in increasing order of length
    for (iter = m_listSuperPaths.begin();
         iter != m_listSuperPaths.end();
         iter++)
    {
        if ((*iter)->GetDepth() > pbpobjSuperPath->GetDepth())
            break;
    }

    // insert at the current position
    ListBPObj_ITER iterNewItem = m_listSuperPaths.insert(iter, pbpobjSuperPath);

    TraceError("CBindingPathObj::HrInsertSuperPath", hr);
    return hr;
}

HRESULT CBindingPathObj::HrInsertSubPath(CBindingPathObj * pbpobjSubPath)
{
    HRESULT hr = S_OK;

    ListBPObj_ITER iter;

    // insert the new sub path into the list, in decreasing order of length
    for (iter = m_listSubPaths.begin();
         iter != m_listSubPaths.end();
         iter++)
    {
        if ((*iter)->GetDepth() < pbpobjSubPath->GetDepth())
            break;
    }

    // insert at the current position
    ListBPObj_ITER iterNewItem = m_listSubPaths.insert(iter, pbpobjSubPath);

    TraceError("CBindingPathObj::HrInsertSubPath", hr);
    return hr;
}

HRESULT CBindingPathObj::HrEnable(ListBPObj * plistBPObj)
{
    HRESULT hr = S_OK;

#if DBG
    if (m_BindingState == BPOBJ_ENABLED)
    {
        TraceTag(ttidError, "Why trying to enable a path that is already enabled ?");
    }
#endif

    AssertSz(m_ulPathLen > 1, "binding path length must be > 1");

    if (m_ulPathLen == 2)
    {
        // enable the current path
        hr = HrEnableBindingPath(m_pncbp, TRUE);
    }
    else
    {
        if (m_listSubPaths.size() <= 0)
        {
            PrintBindingPath(ttidLanUi, m_pncbp, "m_ulPathLen > 1, but no subpaths");
            AssertSz(FALSE, "if pathLen>1, there must be subpaths");
        }
        else
        {
            // check if the sub-path object is enabled, if not then we can't
            // enable this path ..
            if (m_listSubPaths.back()->m_BindingState == BPOBJ_ENABLED)
            {
                hr = HrEnableBindingPath(m_pncbp, TRUE);
            }
        }
    }

    // now refresh the BindingPathObjectList
    ::HrRefreshBindingPathObjCollectionState(plistBPObj);

    TraceError("CBindingPathObj::HrEnable", hr);
    return hr;
}

HRESULT CBindingPathObj::HrDisable(ListBPObj  * plistBPObj)
{
    HRESULT hr = S_OK;

    // Disable the current path
    hr = ::HrEnableBindingPath(m_pncbp, FALSE);

    if (S_OK == hr)
    {
        hr = ::HrRefreshBindingPathObjCollectionState(plistBPObj);
    }

    TraceError("CBindingPathObj::HrDisable", hr);
    return hr;
}

#if DBG
VOID CBindingPathObj::DumpSubPathList()
{
    TraceTag(ttidLanUi, " +++ Path: +++");

    PrintBindingPath(ttidLanUi, m_pncbp, NULL);

    if (m_listSubPaths.size())
    {
        TraceTag(ttidLanUi, "=== Subpaths: ===");

        for (ListBPObj_ITER iter = m_listSubPaths.begin();
             iter != m_listSubPaths.end();
             iter++)
        {
            (*iter)->DumpPath();
        }
    }
}

VOID CBindingPathObj::DumpPath()
{
    PrintBindingPath(ttidLanUi, m_pncbp, NULL);
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CComponentObj implementation
//
//  Author:     tongl   20 Nov 1997
//
//  Notes:
//

CComponentObj::CComponentObj(INetCfgComponent * pncc)
{
    Assert(pncc);
    m_pncc = pncc;
    m_pncc->AddRef();

    // Initialize other members
    m_CheckState = UNSET;
    m_ExpCheckState = UNSET;
}

CComponentObj::~CComponentObj()
{
    ReleaseObj(m_pncc);
    m_listBPObj.erase (m_listBPObj.begin(), m_listBPObj.end());
}

HRESULT CComponentObj::HrInit(ListBPObj * plistBindingPaths)
{
    PWSTR pszwThisId;
    HRESULT hr = m_pncc->GetId(&pszwThisId);
    if (SUCCEEDED(hr))
    {
        // builds the connection between a component object and a list of
        // binding path objects

        ListBPObj_ITER iter;

        for (iter = plistBindingPaths->begin();
             iter != plistBindingPaths->end();
             iter ++)
        {
            INetCfgComponent * pncc;
            hr = (*iter)->m_pncbp->GetOwner(&pncc);

            if SUCCEEDED(hr)
            {
                // check if the top component of the binding path is the
                // same component by comparing INF id
                PWSTR pszwId;
                hr = pncc->GetId (&pszwId);
                if (SUCCEEDED(hr))
                {
                    if (FEqualComponentId (pszwId, pszwThisId))
                    {
                        // Add the BindingPathObj to the end of m_listBPObj
                        m_listBPObj.push_back((*iter));

                        // Make m_pCompObj of the BindingPathObj point to this ComponentObj
                        Assert(NULL == (*iter)->m_pCompObj);
                        (*iter)->m_pCompObj = this;
                    }

                    CoTaskMemFree(pszwId);
                }

                ReleaseObj(pncc);
            }
        }

        CoTaskMemFree(pszwThisId);
    }

    TraceError ("CComponentObj::HrInit", hr);
    return hr;
}

HRESULT CComponentObj::HrCheck(ListBPObj  * plistBPObj)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    Assert(m_CheckState == UNCHECKED);

    // remember that user wanted to check (enable) this component
    m_ExpCheckState = CHECKED;

    ListBPObj_ITER iter;
    for (iter = m_listBPObj.begin();iter != m_listBPObj.end(); iter++)
    {
        // enable each binding path with enabled subpath
        hrTmp = (*iter)->HrEnable(plistBPObj);

        if SUCCEEDED(hr)
            hr = hrTmp;
    }

    TraceError("CComponentObj::HrCheck", hr);
    return hr;
}

HRESULT CComponentObj::HrUncheck(ListBPObj * plistBPObj)
{
    HRESULT hr = S_OK;
    HRESULT hrTmp = S_OK;

    Assert(m_CheckState != UNCHECKED);

    // remember that user wanted to uncheck (disable) this component
    m_ExpCheckState = UNCHECKED;

    if (INTENT_CHECKED == m_CheckState)
    {
        m_CheckState = UNCHECKED;
    }
    else
    {
        ListBPObj_ITER iter;
        for (iter = m_listBPObj.begin();iter != m_listBPObj.end(); iter++)
        {
            // disable each binding path with enabled subpath
            hrTmp = (*iter)->HrDisable(plistBPObj);

            if SUCCEEDED(hr)
                hr = hrTmp;
        }
    }

    TraceError("CComponentObj::HrUnCheck", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\eapolui.h ===
extern "C" {
#include "ntddndis.h"
#include "wzcsapi.h"
}

#pragma once

#define EAPOL_CTL_LOCKED    0x00000001
//
// CEapolConfig
//
class CEapolConfig
{
public:
    DWORD               m_dwCtlFlags;

    CEapolConfig();
    ~CEapolConfig();
    DWORD CopyEapolConfig(CEapolConfig *pEapolConfig);
    DWORD LoadEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid);
    DWORD SaveEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid);
    EAPOL_INTF_PARAMS   m_EapolIntfParams;
    DTLLIST             *m_pListEapcfgs;
    BOOL Is8021XEnabled();
    VOID Set8021XState(BOOLEAN fSet);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\eapolpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N U I . H
//
//  Contents:   Lan connection UI object.
//
//  Notes:
//
//  Author:     danielwe   16 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once

class CEapolConfig;
class CWZCConfigPage;
//
// CWLANAuthenticationPage Property Page
//

class CWLANAuthenticationPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CWLANAuthenticationPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(CID_CA_PB_Properties, OnProperties)
        COMMAND_ID_HANDLER(CID_CA_LB_EapPackages, OnEapPackages)
        COMMAND_ID_HANDLER(CID_CA_RB_Eap, OnEapSelection)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnSetActive)
    END_MSG_MAP()

    CWLANAuthenticationPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        const DWORD * adwHelpIDs = NULL);

    ~CWLANAuthenticationPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnEapPackages(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnEapSelection(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
    LRESULT UploadEapolConfig(CEapolConfig *pEapolConfig, CWZCConfigPage *pWzcPage);

private:
    INetConnection *        m_pconn;
    INetCfg *               m_pnc;
    IUnknown *              m_punk;
    const DWORD *           m_adwHelpIDs;

    CEapolConfig            *m_pEapolConfig;
    CWZCConfigPage          *m_pWzcPage;

    BOOLEAN     m_fNetcfgInUse;

    LRESULT RefreshControls();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\devdatatip.cpp ===
#include <pch.h>
#pragma hdrstop

#include "nsbase.h"

#include "ncreg.h"
#include "ncsetup.h"
#include "ndispnp.h"
#include "resource.h"


//+---------------------------------------------------------------------------
//
//  Function:   GetLocationInfo
//
//  Purpose:    Gets the slot and port number of a device and formats
//              a display string into a buffer.
//
//  Arguments:
//      pszDevNodeId [in] The device isntance id of the adapter.
//      pszBuffer    [in] Buffer to add location string.
//                          (must be preallocated)
//
//  Returns:
//
//  Author:  billbe   2 Aug 1999
//
//  Notes:  Slot and/or port number may not exist so the buffer
//          may not be modified.
//
VOID
GetLocationInfo (
    IN PCWSTR pszDevNodeId,
    OUT PWSTR pszLocation)
{
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    HRESULT hr;

    // Create the device info set needed to access SetupDi fcns.
    //
    hr = HrSetupDiCreateDeviceInfoList (&GUID_DEVCLASS_NET, NULL, &hdi);

    if (S_OK == hr)
    {
        TraceTag (ttidLanUi, "Opening %S", pszDevNodeId);
        // Open the device info for the adapter.
        //
        hr = HrSetupDiOpenDeviceInfo (hdi, pszDevNodeId, NULL, 0, &deid);

        if (S_OK == hr)
        {
            BOOL fHaveSlotNumber;
            DWORD dwSlotNumber;
            DWORD dwPortNumber;
            BOOL fHavePortNumber;

            // Slot number is stored as the UINumber registry property.
            //
            hr = HrSetupDiGetDeviceRegistryProperty (hdi, &deid,
                    SPDRP_UI_NUMBER, NULL, (BYTE*)&dwSlotNumber,
                    sizeof (dwSlotNumber), NULL);

            TraceTag (ttidLanUi, "Getting ui number result %lX  %d",
                      hr, dwSlotNumber);

            fHaveSlotNumber = (S_OK == hr);

            // Port information is stored by the class installer in the
            // device key.
            //
            HKEY hkey;
            fHavePortNumber = FALSE;
            hr = HrSetupDiOpenDevRegKey (hdi, &deid, DICS_FLAG_GLOBAL, 0,
                    DIREG_DEV, KEY_READ, &hkey);

            if (S_OK == hr)
            {
                hr = HrRegQueryDword(hkey, L"Port", &dwPortNumber);

                fHavePortNumber = (S_OK == hr);

                RegCloseKey (hkey);
            }

            // Format the string according to what information
            // we were able to retrieve.
            //
            HINSTANCE hinst = _Module.GetResourceInstance();
            if (fHaveSlotNumber && fHavePortNumber)
            {
                swprintf (pszLocation,
                        SzLoadString (hinst, IDS_SLOT_PORT_LOCATION),
                        dwSlotNumber, dwPortNumber);
                TraceTag (ttidLanUi, "Found slot and port. %S", pszLocation);
            }
            else if (fHaveSlotNumber)
            {
                swprintf (pszLocation,
                        SzLoadString (hinst, IDS_SLOT_LOCATION),
                        dwSlotNumber);
                TraceTag (ttidLanUi, "Found slot. %S", pszLocation);
            }
            else if (fHavePortNumber)
            {
                swprintf (pszLocation,
                        SzLoadString (hinst, IDS_PORT_LOCATION),
                        dwPortNumber);;
                        TraceTag (ttidLanUi, "Found port. %S", pszLocation);
            }
        }
        SetupDiDestroyDeviceInfoList (hdi);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendMacAddress
//
//  Purpose:    Appends the MAC address of a LAN adapter to a buffer for
//              display in UI.
//
//  Arguments:
//      pszBindName [in] Bind name of adapter.
//      pszBuffer   [in] Buffer to add MAC address string.
//                          (must be preallocated)
//
//  Returns:
//
//  Author:     tongl   17 Sept 1998
//              billbe   3 Aug 1999 Modified for datatip
//
//  Notes:
//
VOID
AppendMacAddress (
    IN PCWSTR pszBindName,
    IN OUT PWSTR pszBuffer)
{
    Assert (pszBindName);
    Assert (pszBuffer);

    WCHAR szExport[_MAX_PATH];

    if (pszBindName)
    {
        wcscpy (szExport, L"\\Device\\");
        wcscat (szExport, pszBindName);

        UNICODE_STRING ustrDevice;
        RtlInitUnicodeString(&ustrDevice, szExport);

        // Get the Mac Address
        UINT uiRet;
        UCHAR MacAddr[6];
        UCHAR PMacAddr[6];
        UCHAR VendorId[3];
        uiRet = NdisQueryHwAddress(&ustrDevice, MacAddr, PMacAddr, VendorId);

        if (uiRet)
        {
            // Succeeded
            WCHAR pszNumber[32];
            *pszNumber = 0;

            WCHAR szBuff[4];

            for (INT i=0; i<=5; i++)
            {
                wsprintfW(szBuff, L"%02X", MacAddr[i]);
                wcscat(pszNumber, szBuff);

                if (i != 5)
                {
                    wcscat(pszNumber, L"-");
                }
            }

            if (*pszBuffer)
            {
                wcscat (pszBuffer, L"\n");
            }
            DwFormatString(SzLoadString (_Module.GetResourceInstance(), IDS_MAC_ADDRESS),
                    pszBuffer + wcslen (pszBuffer),
                    _MAX_PATH,
                    pszNumber);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateDeviceDataTip
//
//  Purpose:    Creates a data tip that will display device specific
//              information when the user hovers over nIdTool.
//
//  Arguments:
//      hwndParent   [in] hwnd to parent window.
//      phwndDataTip [in] pointer to the hwnd of data tip. Must be
//                        preallocated and the hwnd assigned to NULL if
//                        data tip has not been created.
//      nIdTool      [in] resource is of tool to add datatip to.
//      pszDevNodeId [in] The device isntance id of the adapter.
//      pszBindName  [in] Bind name of adapter.
//
//  Returns:  nothing
//
//  Author:   billbe   2 Aug 1999
//
//  Notes:
//
VOID
CreateDeviceDataTip (
    IN HWND hwndParent,
    IN OUT HWND* phwndDataTip,
    IN UINT nIdTool,
    IN PCWSTR pszDevNodeId,
    IN PCWSTR pszBindName)
{
    if (!*phwndDataTip)
    {
        TraceTag (ttidLanUi, "Creating device datatip!!!");

        *phwndDataTip = CreateWindowExW (0, TOOLTIPS_CLASS, NULL,
                WS_POPUP | TTS_ALWAYSTIP,
                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, hwndParent, NULL, NULL, NULL);

        if (*phwndDataTip)
        {
            SetWindowPos (*phwndDataTip, HWND_TOPMOST, CW_USEDEFAULT,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
        }
    }

    if (*phwndDataTip)
    {
        TTTOOLINFOW toolinfo = {0};
        toolinfo.cbSize = sizeof (toolinfo);
        toolinfo.uId = (UINT_PTR)GetDlgItem (hwndParent, nIdTool);
        toolinfo.uFlags = TTF_SUBCLASS | TTF_IDISHWND;

        WCHAR szDataTip[_MAX_PATH] = {0};

        // Get location info.
        if (pszDevNodeId)
        {
            GetLocationInfo (pszDevNodeId, szDataTip);
        }

        // Append Mac address.
        if (pszBindName)
        {
            AppendMacAddress (pszBindName, szDataTip);
        }

        // If there is anything to display, set the data tip.
        //
        if (*szDataTip)
        {
            toolinfo.lpszText = szDataTip;
            SendMessage (*phwndDataTip, TTM_ADDTOOL, 0, (LPARAM)&toolinfo);

            // In order to use '\n' to move to the next line of the data tip,
            // we need to set the width.  We will set it to have of the
            // promary monitor's screen size.
            //
            DWORD dwToolTipWidth = GetSystemMetrics (SM_CXSCREEN) / 2;
            if (dwToolTipWidth)
            {
                SendMessage (*phwndDataTip, TTM_SETMAXTIPWIDTH, 0, dwToolTipWidth);
            }

            // Keep the tip up for 30 seconds.
            SendMessage (*phwndDataTip, TTM_SETDELAYTIME, TTDT_AUTOPOP,
                    MAKELONG (30000, 0));
            TraceTag (ttidLanUi, "Creating device datatip complete!!!");
        }
    }
    else
    {
        TraceTag (ttidError, "Creating datatip failed");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\eapolpage.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncui.h"
#include "lanui.h"
#include "lanhelp.h"
#include <raseapif.h>
#include "eapolui.h"
#include "eapolpage.h"
#include "wzcpage.h"
#include "wzcui.h"


extern const WCHAR c_szNetCfgHelpFile[];

//
// CWLANAuthenticationPage
//

CWLANAuthenticationPage::CWLANAuthenticationPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    const DWORD * adwHelpIDs)
{
    TraceFileFunc(ttidLanUi);

    m_pconn = pconn;
    m_pnc = pnc;
    m_fNetcfgInUse = FALSE;
    m_adwHelpIDs = adwHelpIDs;

    m_pEapolConfig = NULL;
    m_pWzcPage = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::~CWLANAuthenticationPage
//
//  Purpose:    Destroys the CWLANAuthenticationPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     sachins
//
//  Notes:
//
CWLANAuthenticationPage::~CWLANAuthenticationPage()
{
    TraceFileFunc(ttidLanUi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::UploadEapolConfig
//
//  Purpose:    Initializes latest data stored with Wireless Configuration
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::UploadEapolConfig(CEapolConfig *pEapolConfig, 
        CWZCConfigPage *pWzcPage)
{
    m_pEapolConfig = pEapolConfig;
    m_pWzcPage = pWzcPage;
    return LresFromHr(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    error code
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    DTLNODE*    pOriginalEapcfgNode = NULL;
    DTLLIST *   pListEapcfgs = NULL;
    HRESULT     hr = S_OK;

    SetClassLongPtr(m_hWnd, GCLP_HCURSOR, NULL);
    SetClassLongPtr(GetParent(), GCLP_HCURSOR, NULL);


    ::SetWindowText(GetDlgItem(IDC_TXT_EAP_LABEL),
                    SzLoadString(WZCGetSPResModule(), IDS_EAPOL_PAGE_LABEL));

    ::SendMessage(GetDlgItem(IDC_EAP_ICO_WARN),
                  STM_SETICON, (WPARAM)LoadIcon(NULL, IDI_WARNING), (LPARAM)0);

    // Initialize EAP package list
    // Read the EAPCFG information from the registry and find the node
    // selected in the entry, or the default, if none.

    do
    {
        DTLNODE* pNode = NULL;

        if (m_pEapolConfig != NULL)
        {
            // the state of CID_CA_RB_Eap is being set in RefreshControls()
                            
            Button_SetCheck(GetDlgItem(CID_CA_RB_MachineAuth),
                            IS_MACHINE_AUTH_ENABLED(m_pEapolConfig->m_EapolIntfParams.dwEapFlags));
            Button_SetCheck(GetDlgItem(CID_CA_RB_GuestAuth),
                            IS_GUEST_AUTH_ENABLED(m_pEapolConfig->m_EapolIntfParams.dwEapFlags));

            // Read the EAPCFG information from the registry and find the node
            // selected in the entry, or the default, if none.

            pListEapcfgs = m_pEapolConfig->m_pListEapcfgs;
        }

        if (pListEapcfgs)
        {

            DTLNODE*            pNodeEap;
            DWORD               dwkey = 0;

            // Choose the EAP name that will appear in the combo box
            pNode = EapcfgNodeFromKey(
                        pListEapcfgs,
                        m_pEapolConfig->m_EapolIntfParams.dwEapType );

            pOriginalEapcfgNode = pNode;


            // Fill the EAP packages listbox and select the previously identified
            // selection.  The Properties button is disabled by default, but may
            // be enabled when the EAP list selection is set.

            //::EnableWindow(GetDlgItem(CID_CA_PB_Properties), FALSE);

            for (pNode = DtlGetFirstNode( pListEapcfgs );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                EAPCFG* pEapcfg = NULL;
                INT i;
                TCHAR* pszBuf = NULL;

                pEapcfg = (EAPCFG* )DtlGetData( pNode );
                ASSERT( pEapcfg );
                ASSERT( pEapcfg->pszFriendlyName );

                pszBuf =  (LPTSTR)MALLOC (sizeof(TCHAR) * (lstrlen(pEapcfg->pszFriendlyName) + 1));
                if (!pszBuf)
                {
                    continue;
                }

                lstrcpy( pszBuf, pEapcfg->pszFriendlyName );

                i = ComboBox_AddItem( GetDlgItem(CID_CA_LB_EapPackages),
                   pszBuf, pNode );

                if (pNode == pOriginalEapcfgNode)
                {
                    // Select the EAP name that will appear in the
                    // combo box

                    ComboBox_SetCurSelNotify( GetDlgItem(CID_CA_LB_EapPackages), i );
                }

                FREE ( pszBuf );
            }
        }

        ComboBox_AutoSizeDroppedWidth( GetDlgItem(CID_CA_LB_EapPackages) );

        // refresh the state for all the controls
        RefreshControls();

    } while (FALSE);

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:
//
//  Author:     sachins
//
LRESULT
CWLANAuthenticationPage::OnContextMenu(UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam,
                           BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:
//
//  Author:     sachins
//
LRESULT
CWLANAuthenticationPage::OnHelp( UINT uMsg,
                        WPARAM wParam,
                        LPARAM lParam,
                        BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                    BOOL& bHandled)
{
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:    error code
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnProperties(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    DWORD       dwErr = 0;
    DTLNODE*    pNode = NULL;
    EAPCFG*     pEapcfg = NULL;
    RASEAPINVOKECONFIGUI pInvokeConfigUi;
    RASEAPFREE  pFreeConfigUIData;
    HINSTANCE   h;
    BYTE*       pConnectionData = NULL;
    DWORD       cbConnectionData = 0;
    HRESULT     hr = S_OK;


    // Look up the selected package configuration and load the associated
    // configuration DLL.

    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        GetDlgItem(CID_CA_LB_EapPackages),
        ComboBox_GetCurSel( GetDlgItem(CID_CA_LB_EapPackages) ) );
    ASSERT( pNode );
    if (!pNode)
    {
        return E_UNEXPECTED;
    }

    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    h = NULL;
    if (!(h = LoadLibrary( pEapcfg->pszConfigDll ))
        || !(pInvokeConfigUi =
                (RASEAPINVOKECONFIGUI )GetProcAddress(
                    h, "RasEapInvokeConfigUI" ))
        || !(pFreeConfigUIData =
                (RASEAPFREE) GetProcAddress(
                    h, "RasEapFreeMemory" )))
    {
        // Cannot load configuration DLL
        if (h)
        {
            FreeLibrary( h );
        }
        return E_FAIL;
    }


    // Call the configuration DLL to popup it's custom configuration UI.

    pConnectionData = NULL;
    cbConnectionData = 0;

    dwErr = pInvokeConfigUi(
                    pEapcfg->dwKey,
                    GetParent(),
                    RAS_EAP_FLAG_8021X_AUTH,
                    pEapcfg->pData,
                    pEapcfg->cbData,
                    &pConnectionData,
                    &cbConnectionData
                    );
    if (dwErr != 0)
    {
        FreeLibrary( h );
        return E_FAIL;
    }


    // Store the configuration information returned in the package descriptor.

    FREE ( pEapcfg->pData );
    pEapcfg->pData = NULL;
    pEapcfg->cbData = 0;

    if (pConnectionData)
    {
        if (cbConnectionData > 0)
        {
            // Copy it into the eap node
            pEapcfg->pData = (LPBYTE)MALLOC (sizeof(UCHAR) * cbConnectionData);
            if (pEapcfg->pData)
            {
                CopyMemory( pEapcfg->pData, pConnectionData, cbConnectionData );
                pEapcfg->cbData = cbConnectionData;
            }
        }
    }

    pFreeConfigUIData( pConnectionData );

    // Note any "force user to configure" requirement on the package has been
    // satisfied.

    pEapcfg->fConfigDllCalled = TRUE;

    FreeLibrary( h );

    TraceError("CWLANAuthenticationPage::OnProperties", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnEapSelection
//
//  Purpose:    Handles the clicking of the EAP checkbox
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnEapSelection(WORD wNotifyCode, WORD wID,
                                            HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    EAPCFG*     pEapcfg = NULL;
    INT         iSel = 0;

    // Toggle buttons based on selection

    if (BST_CHECKED == IsDlgButtonChecked(CID_CA_RB_Eap))
    {
        ::EnableWindow(GetDlgItem(CID_CA_LB_EapPackages), TRUE);
        ::EnableWindow(GetDlgItem(IDC_TXT_EAP_TYPE), TRUE);


        // Get the EAPCFG information for the currently selected EAP package.

        iSel = ComboBox_GetCurSel(GetDlgItem(CID_CA_LB_EapPackages));


        // iSel is the index in the displayed list as well as the
        // index of the dll that are loaded.
        // Get the cfgnode corresponding to this index

        if (iSel >= 0)
        {
            DTLNODE* pNode;

            pNode =
                (DTLNODE* )ComboBox_GetItemDataPtr(
                    GetDlgItem(CID_CA_LB_EapPackages), iSel );
            if (pNode)
            {
                pEapcfg = (EAPCFG* )DtlGetData( pNode );
            }
        }


        // Enable the Properties button if the selected package has a
        // configuration entrypoint

        // if (FIsUserAdmin())
        {
            ::EnableWindow ( GetDlgItem(CID_CA_PB_Properties),
                (pEapcfg && !!(pEapcfg->pszConfigDll)) );
        }

        ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), TRUE);
        ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), TRUE);

        m_pEapolConfig->m_EapolIntfParams.dwEapFlags |= EAPOL_ENABLED;
    }
    else
    {
        ::EnableWindow(GetDlgItem (IDC_TXT_EAP_TYPE), FALSE);
        ::EnableWindow(GetDlgItem (CID_CA_LB_EapPackages), FALSE);
        ::EnableWindow(GetDlgItem (CID_CA_PB_Properties), FALSE);
        ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), FALSE);
        ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), FALSE);

        m_pEapolConfig->m_EapolIntfParams.dwEapFlags &= ~EAPOL_ENABLED;
    }

    TraceError("CWLANAuthenticationPage::OnEapSelection", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnEapPackages
//
//  Purpose:    Handles the clicking of the EAP packages combo box
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnEapPackages(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    EAPCFG*     pEapcfg = NULL;
    INT         iSel = 0;


    // Get the EAPCFG information for the selected EAP package.

    iSel = ComboBox_GetCurSel(GetDlgItem(CID_CA_LB_EapPackages));


    // iSel is the index in the displayed list as well as the
    // index of the dll that are loaded.
    // Get the cfgnode corresponding to this index

    if (iSel >= 0)
    {
        DTLNODE* pNode = NULL;

        pNode =
            (DTLNODE* )ComboBox_GetItemDataPtr(
                GetDlgItem(CID_CA_LB_EapPackages), iSel );
        if (pNode)
        {
            pEapcfg = (EAPCFG* )DtlGetData( pNode );
        }
    }


    // Enable the Properties button if the selected package has a
    // configuration entrypoint

    if (BST_CHECKED == IsDlgButtonChecked(CID_CA_RB_Eap))
    {
        ::EnableWindow ( GetDlgItem(CID_CA_PB_Properties),
                        (pEapcfg && !!(pEapcfg->pszConfigDll)) );
    }


    TraceError("CWLANAuthenticationPage::OnEapPackages", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnKillActive
//
//  Purpose:    Called to check warning conditions before the security
//              page is going away
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnKillActive(int idCtrl, LPNMHDR pnmh,
                                        BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    BOOL    fError;

    fError = m_fNetcfgInUse;

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnKillActive
//
//  Purpose:    Called to check warning conditions when the security
//              page is showing up
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    RefreshControls();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CWLANAuthenticationPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    DWORD       dwEapFlags = 0;
    DWORD       dwDefaultEapType = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    NETCON_PROPERTIES* pProps = NULL;
    HRESULT     hrOverall = S_OK;
    DTLLIST *   pListEapcfgs;
    HRESULT     hr = S_OK;

    // Retain data for all EAP packages

    pListEapcfgs = m_pEapolConfig->m_pListEapcfgs;

    if (pListEapcfgs == NULL)
    {
        return LresFromHr(S_OK);
    }

    DTLNODE* pNode = NULL;
    EAPCFG* pEapcfg = NULL;

    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        GetDlgItem (CID_CA_LB_EapPackages),
        ComboBox_GetCurSel( GetDlgItem (CID_CA_LB_EapPackages) ) );
    if (pNode == NULL)
    {
        return LresFromHr (E_FAIL);
    }

    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    if (pEapcfg == NULL)
    {
        return LresFromHr (E_FAIL);
    }
        
    dwDefaultEapType = pEapcfg->dwKey;

    // If CID_CA_RB_Eap is checked, EAPOL is enabled on the interface
    // the memory image of CID_CA_RB_Eap is updated with each click on the control so
    // update this bit from the in-memory flag.
    dwEapFlags |= m_pEapolConfig->m_EapolIntfParams.dwEapFlags & EAPOL_ENABLED;

    if (Button_GetCheck( GetDlgItem(CID_CA_RB_MachineAuth )))
        dwEapFlags |= EAPOL_MACHINE_AUTH_ENABLED;

    if (Button_GetCheck( GetDlgItem(CID_CA_RB_GuestAuth )))
        dwEapFlags |= EAPOL_GUEST_AUTH_ENABLED;

    // Save the params for this interface in registry

    EapolIntfParams.dwEapType = dwDefaultEapType;
    EapolIntfParams.dwEapFlags = dwEapFlags;

    memcpy (&m_pEapolConfig->m_EapolIntfParams, &EapolIntfParams, 
            sizeof(EAPOL_INTF_PARAMS));

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//
LRESULT CWLANAuthenticationPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return LresFromHr(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWLANAuthenticationPage::OnCancel
//
//  Purpose:    Called to update the state of all the controls.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
LRESULT CWLANAuthenticationPage::RefreshControls()
{
    BOOL bLocked;
    BOOL bEnabled;

    bEnabled = IS_EAPOL_ENABLED(m_pEapolConfig->m_EapolIntfParams.dwEapFlags);
    bLocked = (m_pEapolConfig->m_dwCtlFlags & EAPOL_CTL_LOCKED);

    Button_SetCheck(GetDlgItem(CID_CA_RB_Eap), !bLocked && bEnabled);

    ::ShowWindow(GetDlgItem(IDC_EAP_ICO_WARN), bLocked? SW_SHOW : SW_HIDE);
    ::ShowWindow(GetDlgItem(IDC_EAP_LBL_WARN), bLocked? SW_SHOW : SW_HIDE);

    // now set all the controls state
    ::EnableWindow(GetDlgItem(IDC_TXT_EAP_LABEL), !bLocked);
    ::EnableWindow(GetDlgItem(CID_CA_RB_Eap), !bLocked);
    ::EnableWindow(GetDlgItem(IDC_TXT_EAP_TYPE), !bLocked && bEnabled);
    ::EnableWindow(GetDlgItem(CID_CA_LB_EapPackages), !bLocked && bEnabled);
    ::EnableWindow(GetDlgItem(CID_CA_PB_Properties), !bLocked && bEnabled);
    ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), !bLocked && bEnabled);
    ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), !bLocked && bEnabled);

    return LresFromHr(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\chklist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C H K L I S T . H
//
//  Contents:   Declares bindings checkbox related utility functions
//              and classes.
//
//  Notes:
//
//  Created:     tongl   20 Nov 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"
#include "netcon.h"

class CBindingPathObj;
class CComponentObj;

typedef list<CBindingPathObj *>     ListBPObj;
typedef ListBPObj::iterator         ListBPObj_ITER;

typedef list<INetCfgComponent *>    ListComp;
typedef ListComp::iterator          ListComp_ITER;

// States of a BindingPathObject
enum BPOBJ_STATE
{
    BPOBJ_ENABLED,
    BPOBJ_DISABLED,
    BPOBJ_UNSET
};

// States of a ComponentObject
enum CHECK_STATE
{
    CHECKED,
    MIXED,
    INTENT_CHECKED,
    UNCHECKED,
    UNSET
};

// Utility functions
//
HRESULT HrRebuildBindingPathObjCollection(INetCfgComponent * pnccAdapter,
                                          ListBPObj * pListObj);

HRESULT HrInsertBindingPathObj(ListBPObj * pListBPObj,
                               CBindingPathObj * pBPObj);

HRESULT HrRefreshBindingPathObjCollectionState(ListBPObj * pListBPObj);

HRESULT HrRefreshCheckListState(HWND hwndListView);

HRESULT HrEnableBindingPath(INetCfgBindingPath * pncbp, BOOL fEnable);

// Classes

class CBindingPathObj
{
public:

    // constructor and destructor
    CBindingPathObj(INetCfgBindingPath * pncbp);
    ~CBindingPathObj();

    // methods
    BPOBJ_STATE GetBindingState(){ return m_BindingState; };
    void SetBindingState(BPOBJ_STATE state) { m_BindingState = state; };

    ULONG GetDepth() { return m_ulPathLen; };

    HRESULT HrInsertSuperPath(CBindingPathObj * pbpobjSuperPath);
    HRESULT HrInsertSubPath(CBindingPathObj * pbpobjSubPath);

    HRESULT HrEnable(ListBPObj  * plistBPObj);
    HRESULT HrDisable(ListBPObj * plistBPObj);

#if DBG
    VOID DumpSubPathList();
    VOID DumpPath();
#endif


    // Declare friend class
    friend class CComponentObj;

    // Friend function declarations
    friend HRESULT HrRebuildBindingPathObjCollection(INetCfgComponent * pnccAdapter,
                                                     ListBPObj * pListObj);

    friend HRESULT HrInsertBindingPathObj(ListBPObj * pListBPObj,
                                          CBindingPathObj * pBPObj);

    friend HRESULT HrRefreshBindingPathObjCollectionState(ListBPObj * pListBPObj);

    friend HRESULT HrRefreshCheckListState(HWND hwndListView);

public:
    // data members

    // the corresponding binding path
    INetCfgBindingPath * m_pncbp;

    // length of the binding path
    ULONG m_ulPathLen;

    // list of BindingPathObjects that contains a subpath
    ListBPObj    m_listSubPaths;
    ListBPObj    m_listSuperPaths;

    // pointer to a ComponentObj if the top component
    // corresponds to a component in our listview
    CComponentObj * m_pCompObj;

    BPOBJ_STATE m_BindingState;
};

class CComponentObj
{
public:
    // constructor
    CComponentObj(INetCfgComponent * pncc);
    ~CComponentObj();

    // methods
    HRESULT HrInit(ListBPObj * plistBindingPaths);

    HRESULT HrCheck(ListBPObj * plistBPObj);
    HRESULT HrUncheck(ListBPObj * plistBPObj);

    CHECK_STATE GetChkState(){ return m_CheckState;} ;
    void SetChkState(CHECK_STATE state) { m_CheckState = state; };

    CHECK_STATE GetExpChkState(){ return m_ExpCheckState;} ;
    void SetExpChkState(CHECK_STATE state) { m_ExpCheckState = state; };

    // Declare friend class
    friend class CComponentObj;

    // Friend function declarations
    friend HRESULT HrRefreshBindingPathObjCollectionState(ListBPObj * pListBPObj);

    friend HRESULT HrRefreshCheckListState(HWND hwndListView);

    friend BOOL FValidatePageContents( HWND hwndDlg,
                                       HWND hwndList,
                                       INetCfg * pnc,
                                       INetCfgComponent * pnccAdapter,
                                       ListBPObj * plistBindingPaths);

private:

    // data members

    // corresponding netcfg component
    INetCfgComponent * m_pncc;

    // list of corresponding BindingPathObjects
    ListBPObj m_listBPObj;

    // current check state
    CHECK_STATE m_CheckState;

    // expected check state
    CHECK_STATE m_ExpCheckState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\eapolui.cpp ===
#include "pch.h"
#pragma hdrstop
#include "connutil.h"
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncui.h"
#include "xpsp1res.h"
#include "lanui.h"
#include "eapolui.h"
#include "util.h"
#include "lanhelp.h"
#include "wzcprops.h"
#include "wzcpage.h"
#include "wzcui.h"
#include "wzcsapi.h"


////////////////////////////////////////////////////////////////////////
// CEapolConfig related stuff
//
//+---------------------------------------------------------------------------
// constructor
CEapolConfig::CEapolConfig()
{
    m_dwCtlFlags = 0;
    ZeroMemory(&m_EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    m_pListEapcfgs = NULL;
}

//+---------------------------------------------------------------------------
// destructor
CEapolConfig::~CEapolConfig()
{
    ZeroMemory(&m_EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    if (m_pListEapcfgs)
    {
        DtlDestroyList (m_pListEapcfgs, DestroyEapcfgNode);
    }
    m_pListEapcfgs = NULL;
}

//+---------------------------------------------------------------------------
DWORD CEapolConfig::CopyEapolConfig(CEapolConfig *pEapolConfig)
{
    DTLLIST     *pListEapcfgs = NULL;
    DTLNODE     *pCopyNode = NULL, *pInNode = NULL;
    DWORD       dwRetCode = ERROR_SUCCESS;

    if (pEapolConfig)
    {
        pListEapcfgs = ::ReadEapcfgList (EAPOL_MUTUAL_AUTH_EAP_ONLY);
        if (pListEapcfgs)
        {
            for (pCopyNode = DtlGetFirstNode(pListEapcfgs);
                 pCopyNode;
                 pCopyNode = DtlGetNextNode(pCopyNode))
            {
                EAPCFG* pCopyEapcfg = (EAPCFG* )DtlGetData(pCopyNode);
                for (pInNode = DtlGetFirstNode(pEapolConfig->m_pListEapcfgs);
                        pInNode;
                        pInNode = DtlGetNextNode(pInNode))
                {
                    EAPCFG* pInEapcfg = (EAPCFG* )DtlGetData(pInNode);
                    if (pCopyEapcfg->dwKey == pInEapcfg->dwKey)
                    {
                        if ((pCopyEapcfg->pData = (PBYTE) MALLOC (pInEapcfg->cbData)) == NULL)
                        {
                            dwRetCode = ERROR_NOT_ENOUGH_MEMORY;
                            break;
                        }
                        memcpy (pCopyEapcfg->pData, pInEapcfg->pData, pInEapcfg->cbData);
                        pCopyEapcfg->cbData = pInEapcfg->cbData;
                        break;
                    }
                }
                if (dwRetCode != NO_ERROR)
                {
                    goto LExit;
                }
            }
        }
        m_pListEapcfgs = pListEapcfgs;
        memcpy (&m_EapolIntfParams, &pEapolConfig->m_EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    }
    else
    {
        dwRetCode = ERROR_INVALID_DATA;
    }

LExit:
    if (dwRetCode != ERROR_SUCCESS)
    {
        if (pListEapcfgs)
        {
            DtlDestroyList (pListEapcfgs, DestroyEapcfgNode);
        }
    }

    return dwRetCode;
}



//+---------------------------------------------------------------------------
DWORD CEapolConfig::LoadEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid)
{
    BYTE        *pbData = NULL;
    DWORD       cbData = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    DTLLIST     *pListEapcfgs = NULL;
    HRESULT     hr = S_OK;

    // Initialize EAP package list
    // Read the EAPCFG information from the registry and find the node
    // selected in the entry, or the default, if none.

    do
    {
        DTLNODE* pNode = NULL;

        // Read the EAPCFG information from the registry and find the node
        // selected in the entry, or the default, if none.

        pListEapcfgs = ::ReadEapcfgList (EAPOL_MUTUAL_AUTH_EAP_ONLY);

        if (pListEapcfgs)
        {

            DTLNODE*            pNodeEap;
            DWORD               dwkey = 0;

            // Read the EAP params for this interface

            ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
            EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
            EapolIntfParams.dwEapType = DEFAULT_EAP_TYPE;
            if (pndSsid)
            {
                EapolIntfParams.dwSizeOfSSID = pndSsid->SsidLength;
                memcpy (EapolIntfParams.bSSID, pndSsid->Ssid, pndSsid->SsidLength);
            }
            else
            {
                // If NULL SSID, this will get default EAPOL values
                EapolIntfParams.dwSizeOfSSID = 1;
            }
            hr = HrElGetInterfaceParams (
                    wszIntfGuid,
                    &EapolIntfParams
                    );
            if (FAILED (hr))
            {
                TraceTag (ttidLanUi, "HrElGetInterfaceParams failed with error %ld",
                        LresFromHr(hr));
                break;
            }


            TraceTag (ttidLanUi, "HrElGetInterfaceParams: Got EAPtype=(%ld), EAPState =(%ld)", EapolIntfParams.dwEapType, EapolIntfParams.dwEapFlags);

            memcpy (&m_EapolIntfParams, &EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));

            // Read the EAP configuration info for all EAP packages

            for (pNodeEap = DtlGetFirstNode(pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap))
            {
                EAPCFG* pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
                ASSERT( pEapcfg );

                hr = S_OK;
                pbData = NULL;

                TraceTag (ttidLanUi, "Calling HrElGetCustomAuthData for EAP %ld",
                        pEapcfg->dwKey);

                    cbData = 0;

                    // Get the size of the EAP blob

                    hr = HrElGetCustomAuthData (
                                    wszIntfGuid,
                                    pEapcfg->dwKey,
                                    EapolIntfParams.dwSizeOfSSID,
                                    EapolIntfParams.bSSID,
                                    NULL,
                                    &cbData
                                    );
                    if (!SUCCEEDED(hr))
                    {
                        if ((EapolIntfParams.dwSizeOfSSID != 0) &&
                            (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
                        {

                            TraceTag (ttidLanUi, "HrElGetCustomAuthData: SSID!= NULL, not found blob for SSID");

                            // The Last Used SSID did not have a connection
                            // blob created. Call again for size of blob with
                            // NULL SSID

                            EapolIntfParams.dwSizeOfSSID = 0;

                            // Get the size of the EAP blob

                            hr = HrElGetCustomAuthData (
                                            wszIntfGuid,
                                            pEapcfg->dwKey,
                                            0,
                                            NULL,
                                            NULL,
                                            &cbData
                                            );
                        }

                        if (hr == E_OUTOFMEMORY)
                        {
                            if (cbData <= 0)
                            {
                                // No EAP blob stored in the registry

                                TraceTag (ttidLanUi, "HrElGetCustomAuthData: No blob stored in reg at all");
                                pbData = NULL;

                                // Will continue processing for errors
                                // Not exit
                                hr = S_OK;

                            }
                            else
                            {
                                TraceTag (ttidLanUi, "HrElGetCustomAuthData: Found auth blob in registry");

                                // Allocate memory to hold the blob

                                pbData = (PBYTE) MALLOC (cbData);

                                if (pbData == NULL)
                                {
                                    hr = S_OK;
                                    TraceTag (ttidLanUi, "HrElGetCustomAuthData: Error in memory allocation for EAP blob");
                                    continue;
                                }
                                ZeroMemory (pbData, cbData);

                                hr = HrElGetCustomAuthData (
                                            wszIntfGuid,
                                            pEapcfg->dwKey,
                                            EapolIntfParams.dwSizeOfSSID,
                                            EapolIntfParams.bSSID,
                                            pbData,
                                            &cbData
                                            );

                                if (!SUCCEEDED(hr))
                                {
                                    TraceTag (ttidLanUi, "HrElGetCustomAuthData: HrElGetCustomAuthData failed with %ld",
                                            LresFromHr(hr));
                                    FREE ( pbData );
                                    hr = S_OK;
                                    continue;
                                }

                                TraceTag (ttidLanUi, "HrElGetCustomAuthData: HrElGetCustomAuthData successfully got blob of length %ld"
                                        , cbData);
                            }
                        }
                        else
                        {
                            TraceTag (ttidLanUi, "HrElGetCustomAuthData: Not got ERROR_NOT_ENOUGH_MEMORY error; Unknown error !!!");
                            hr = S_OK;
                            continue;
                        }
                    }
                    else
                    {
                        // HrElGetCustomAuthData will always return
                        // error with cbData = 0
                        hr = S_OK;
                    }

                    if (pEapcfg->pData != NULL)
                    {
                        FREE ( pEapcfg->pData );
                    }
                    pEapcfg->pData = (UCHAR *)pbData;
                    pEapcfg->cbData = cbData;
            }

            m_pListEapcfgs = pListEapcfgs;
        }
        else
        {
            hr = E_FAIL;
        }

    } while (FALSE);

    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
DWORD CEapolConfig::SaveEapolConfig(LPWSTR wszIntfGuid, PNDIS_802_11_SSID pndSsid)
{
    WCHAR       *pwszLastUsedSSID = NULL;
    DWORD       dwEapFlags = 0;
    HRESULT     hrOverall = S_OK;
    HRESULT     hr = S_OK;

    // Save the EAP configuration data into the registry

    DTLNODE* pNodeEap = NULL;

    hr = S_OK;

    // Save data for all EAP packages in the registry

    if (m_pListEapcfgs == NULL)
    {
        return LresFromHr(S_OK);
    }
            
    if (pndSsid)
    {
        m_EapolIntfParams.dwSizeOfSSID = pndSsid->SsidLength;
        memcpy (m_EapolIntfParams.bSSID, pndSsid->Ssid, pndSsid->SsidLength);
    }

    for (pNodeEap = DtlGetFirstNode(m_pListEapcfgs);
         pNodeEap;
         pNodeEap = DtlGetNextNode(pNodeEap))
    {
        EAPCFG* pcfg = (EAPCFG* )DtlGetData(pNodeEap);
        if (pcfg == NULL)
        {
            continue;
        }

        hr = S_OK;

        // ignore error and continue with next

        hr = HrElSetCustomAuthData (
                    wszIntfGuid,
                    pcfg->dwKey,
                    m_EapolIntfParams.dwSizeOfSSID,
                    m_EapolIntfParams.bSSID,
                    pcfg->pData,
                    pcfg->cbData);

        if (FAILED (hr))
        {
            TraceTag (ttidLanUi, "HrElSetCustomAuthData failed");
            hrOverall = hr;
            hr = S_OK;
        }
    }

    if (m_dwCtlFlags & EAPOL_CTL_LOCKED)
        m_EapolIntfParams.dwEapFlags &= ~EAPOL_ENABLED;

    hr = HrElSetInterfaceParams (
            wszIntfGuid,
            &m_EapolIntfParams
            );
    if (FAILED(hr))
    {
        TraceTag (ttidLanUi, "HrElSetInterfaceParams enabled failed with error %ld",
                LresFromHr(hr));
        hrOverall = hr;
    }

    if (hrOverall != S_OK)
    {
        hr = hrOverall;
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
BOOL CEapolConfig::Is8021XEnabled()
{
    return (IS_EAPOL_ENABLED(m_EapolIntfParams.dwEapFlags));
}
    
//+---------------------------------------------------------------------------
VOID CEapolConfig::Set8021XState(BOOLEAN fSet)
{
    if (fSet)
        m_EapolIntfParams.dwEapFlags |= EAPOL_ENABLED;
    else
        m_EapolIntfParams.dwEapFlags &= ~EAPOL_ENABLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanhelp.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Generated by Melissa Simmons 3-10-99
// Used by lanui.rc
//

#include <xpsp1res.h>

#define IDH_CB_PrivateLan       40000051
#define IDH_CHK_Shared          40000050
#define IDH_CHK_ShowIcon        40000031
#define IDH_EDT_Adapter_Border  40000025
#define IDH_LVW_Lan_Components  40000000
#define IDH_LVW_Net_Components  40000027
#define IDH_PSB_Add             40000028
#define IDH_PSB_Component_Add   40000001
#define IDH_PSB_Configure       40000026
#define IDH_PSB_Properties      40000030
#define IDH_PSB_Remove          40000029
#define IDH_CHK_Firewall        40000040
#define IDH_ST_ICFLINK          40000041
#define IDH_EDT_PrivateLan      40000042
#define IDH_CHK_BeaconControl   40000043
#define IDH_ST_ICSLINK          40000044
#define IDH_PSB_Settings        40000045
#define IDH_ST_HNWLINK          40000046
#define	IDH_CB_Eap              40000060
#define	IDH_LB_EapPackages      40000061
#define	IDH_PB_EapProperties    40000062
#define	IDH_CB_MachineAuth      40000063
#define	IDH_CB_GuestAuth        40000064
#define IDH_EAP_LBL_WARN        40000065
#define IDH_DISABLEHELP         ((DWORD)-1)

const DWORD g_aHelpIDs_IDD_LAN_COMPONENT_ADD[]=
{
    IDC_LVW_Lan_Components,IDH_LVW_Lan_Components,
    IDC_TXT_Component_Desc, IDH_DISABLEHELP,
    IDC_PSB_Component_Add,IDH_PSB_Component_Add,
    0,0
};


const DWORD g_aHelpIDs_IDD_LAN_NETWORKING[]=
{
    IDC_EDT_Adapter_Border,IDH_EDT_Adapter_Border,
    IDC_PSB_Configure,IDH_PSB_Configure,
        IDC_TXT_MAC_ADDR, IDH_DISABLEHELP,
    IDC_DEVICE_MAC_ADDR, IDH_DISABLEHELP,
    IDC_LVW_Net_Components,IDH_LVW_Net_Components,
    IDC_PSB_Add,IDH_PSB_Add,
    IDC_PSB_Remove,IDH_PSB_Remove,
    IDC_PSB_Properties,IDH_PSB_Properties,
    IDC_TXT_Desc, IDH_DISABLEHELP,
    IDC_CHK_ShowIcon,IDH_CHK_ShowIcon,
    0,0
};

const DWORD g_aHelpIDs_IDD_LAN_ADVANCED[]=
{
    IDC_CHK_Shared,IDH_CHK_Shared,
    IDC_CB_PrivateLan,IDH_CB_PrivateLan,
    IDC_PSB_Settings,IDH_PSB_Settings,
    IDC_CHK_Firewall,IDH_CHK_Firewall,
    IDC_ST_ICFLINK,IDH_ST_ICFLINK,
    IDC_EDT_PrivateLan,IDH_EDT_PrivateLan,
    IDC_CHK_BeaconControl,IDH_CHK_BeaconControl,
    IDC_ST_ICSLINK,IDH_ST_ICSLINK,
    IDC_ST_HNWLINK,IDH_ST_HNWLINK,
    IDC_GB_Shared,IDH_DISABLEHELP,
    IDC_GB_PrivateLan,IDH_DISABLEHELP,
    0,0
};

const DWORD g_aHelpIDs_IDD_SECURITY[]=
{
	CID_CA_RB_Eap,IDH_CB_Eap,
	IDC_TXT_EAP_TYPE,IDH_LB_EapPackages,
	CID_CA_LB_EapPackages,IDH_LB_EapPackages,
	CID_CA_PB_Properties,IDH_PB_EapProperties,
	CID_CA_RB_MachineAuth,IDH_CB_MachineAuth,
	CID_CA_RB_GuestAuth,IDH_CB_GuestAuth,
    IDC_EAP_ICO_WARN, IDH_DISABLEHELP,
    IDC_EAP_LBL_WARN, IDH_EAP_LBL_WARN,
	0,0
};

const DWORD g_aHelpIDs_IDD_SHAREDACCESS_GENERAL[]=
{
    IDC_EDT_Adapter_Border,IDH_DISABLEHELP,
    IDC_TXT_CONNECTTO,IDH_DISABLEHELP,
    IDC_CHK_ShowIcon,IDH_CHK_ShowIcon,
    IDC_PSB_Settings,IDH_PSB_Settings,
    IDC_TXT_SHAREDCONNECTION,IDH_DISABLEHELP,
    0,0
};

#define IDH_WZC_EDIT_SSID           40000141
#define IDH_WZC_CB_InfraMode        40000142
#define IDH_WZC_WEPENCRYPT          40000143
#define IDH_WZC_WepGroup            40000144
#define IDH_WZC_WEPAUTH             40000145
#define IDH_WZC_CHK_WepK            40000146
//#define IDH_WZC_CB_KLen             40000148
//#define IDH_WZC_CB_KFmt             40000150
#define IDH_WZC_EDIT_KMat           40000152
#define IDH_WZC_EDIT_KMat2           40000153
#define IDH_WZC_EDIT_KIdx           40000154
#define IDH_WZC_CHK_EnableWZC       40000155
#define IDH_WZC_GRP_BSSIDList       40000156
#define IDH_WZC_LVW_BSSIDList       40000160
#define IDH_WZC_GRP_StSSIDList      40000157
#define IDH_WZC_LVW_StSSIDList      40000161
#define IDH_WZC_BTN_UP              40000162
#define IDH_WZC_BTN_DOWN            40000163
#define IDH_WZC_BTN_COPY            40000164
#define IDH_WZC_BTN_RFSH            40000165
#define IDH_WZC_BTN_ADD             40000166
#define IDH_WZC_BTN_REM             40000167
#define IDH_WZC_CHK_Fallback        40000168
#define IDH_WZC_PROPERTIES          40000169
#define IDH_WZC_ADVANCED            40000170
#define IDH_WZC_GRP_NetType         40000171
#define IDH_WZC_RB_Auto             40000172
#define IDH_WZC_RB_INFRA            40000173
#define IDH_WZC_RB_ADHOC            40000174

// Help ID array for "WLAN Configuration" Tab
const DWORD g_aHelpIDs_IDD_LAN_WZEROCONF[]=
{
    IDC_WZC_CHK_EnableWZC,      IDH_WZC_CHK_EnableWZC,
    IDC_WZC_LBL_VisNet,         IDH_WZC_GRP_BSSIDList,
    IDC_AVAILLABEL,             IDH_DISABLEHELP,
    IDC_WZC_LVW_BSSIDList,      IDH_WZC_LVW_BSSIDList,
    IDC_WZC_BTN_COPY,           IDH_WZC_BTN_COPY,
    IDC_WZC_BTN_RFSH,           IDH_WZC_BTN_RFSH,
    IDC_WZC_LBL_PrefNet,        IDH_WZC_GRP_StSSIDList,
    IDC_PREFERLABEL,            IDH_DISABLEHELP,
    IDC_WZC_LVW_StSSIDList,     IDH_WZC_LVW_StSSIDList,
    IDC_WZC_BTN_UP,             IDH_WZC_BTN_UP,
    IDC_WZC_BTN_DOWN,           IDH_WZC_BTN_DOWN,
    IDC_WZC_BTN_ADD,            IDH_WZC_BTN_ADD,
    IDC_WZC_BTN_REM,            IDH_WZC_BTN_REM,
    IDC_PROPERTIES,             IDH_WZC_PROPERTIES,
    IDC_ADVANCED,               IDH_WZC_ADVANCED,
    0,0
};

// Help ID array for "WLAN Properties" dialog (RO version)
const DWORD g_aHelpIDs_IDC_WZC_DLG_VPROPS[]=
{
    IDC_WZC_EDIT_SSID,          IDH_WZC_EDIT_SSID,       
    IDC_ADHOC,                  IDH_WZC_CB_InfraMode,
    IDC_USEPW,                  IDH_WZC_WEPENCRYPT,
    0,0
};

// Help ID array for "WLAN Properties" dialog (RW version)
const DWORD g_aHelpIDs_IDC_WZC_DLG_PROPS[]=
{
    IDC_WZC_EDIT_SSID,          IDH_WZC_EDIT_SSID,
    IDC_WZC_GRP_Wep,            IDH_WZC_WepGroup,
    IDC_USEPW,                  IDH_WZC_WEPENCRYPT,
    IDC_SHAREDMODE,             IDH_WZC_WEPAUTH,
    IDC_WZC_EDIT_KMat,          IDH_WZC_EDIT_KMat,
    IDC_WZC_LBL_KMat,           IDH_WZC_EDIT_KMat,  // same as IDC_WZC_EDIT_KMat
    IDC_WZC_EDIT_KMat2,         IDH_WZC_EDIT_KMat2, 
    IDC_WZC_LBL_KMat2,          IDH_WZC_EDIT_KMat2,  // same as IDC_WZC_EDIT_KMat2
    IDC_WZC_LBL_KIdx,           IDH_WZC_EDIT_KIdx,  // same as IDC_WZC_EDIT_KIdx
    IDC_WZC_EDIT_KIdx,          IDH_WZC_EDIT_KIdx,
    IDC_USEHARDWAREPW,          IDH_WZC_CHK_WepK,
    IDC_ADHOC,                  IDH_WZC_CB_InfraMode,
    0,0
};

// add help array for the "Advanced" dialog
const DWORD g_aHelpIDs_IDC_WZC_ADVANCED[]=
{
    IDC_WZC_GRP_NetType,        IDH_WZC_GRP_NetType,
    IDC_ANYNET,                 IDH_WZC_RB_Auto,
    IDC_INFRA,                  IDH_WZC_RB_INFRA,
    IDC_ADHOC,                  IDH_WZC_RB_ADHOC,
    IDC_WZC_CHK_Fallback,       IDH_WZC_CHK_Fallback,
    0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N U I . H
//
//  Contents:   Lan connection UI object.
//
//  Notes:
//
//  Author:     danielwe   16 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "chklist.h"
#include "ncatlps.h"
#include "netcfgp.h"
#include "netcfgx.h"
#include "netcon.h"
#include "netconp.h"
#include "ncras.h"
#include "nsres.h"
#include "resource.h"
#include "netshell.h"
#include "util.h"

#include "HNetCfg.h"

struct ADVANCED_ITEM_DATA
{
    PWSTR              szwName;
    INetCfgComponent *  pncc;
};

//
// CLanConnectionUiDlg
//

class CLanConnectionUiDlg :
    public CDialogImpl<CLanConnectionUiDlg>
{
    BEGIN_MSG_MAP(CLanConnectionUiDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    enum { IDD = IDD_LAN_CONNECT};

    CLanConnectionUiDlg() { m_pconn = NULL; };

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);

    VOID SetConnection(INetConnection *pconn) {m_pconn = pconn;}

private:
    INetConnection *    m_pconn;
};

static const UINT WM_DEFERREDINIT   = WM_USER + 100;

//
// LAN Connection Networking Property Page
//
class CLanNetPage: public CPropSheetPage
{
public:
    CLanNetPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        BOOLEAN fReadOnly,
        BOOLEAN fNeedReboot,
        BOOLEAN fAccessDenied,
        const DWORD * adwHelpIDs = NULL);

    ~CLanNetPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnAddHelper(HWND hwndLV);
    LRESULT OnRemoveHelper(HWND hwndLV);
    LRESULT OnPropertiesHelper(HWND hwndLV);
    LRESULT OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnKillActiveHelper(HWND hwndLV);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDeferredInit(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& bHandled);

    HRESULT HrRequestReboot();

protected: 
    INetConnection *        m_pconn;
    INetCfg *               m_pnc;
    IUnknown *              m_punk;
    INetCfgComponent *      m_pnccAdapter;
    HIMAGELIST              m_hil;
    PSP_CLASSIMAGELIST_DATA m_pcild;
    HIMAGELIST              m_hilCheckIcons;
    HCURSOR                 m_hPrevCurs;

    // The collection of BindingPathObj
    // This is for handling the checklist state stuff
    ListBPObj m_listBindingPaths;

    // Handles (add\remove\property buttons and description text)
    HANDLES m_handles;

    BOOLEAN     m_fReadOnly;
    BOOLEAN     m_fDirty;

    HRESULT static RaiseDeviceConfiguration(HWND hWndParent, INetCfgComponent* pAdapterConfigComponent);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
        BOOL& bHandled);
    
private:
    const DWORD *           m_adwHelpIDs;



    INetLanConnection * m_plan;

    BOOLEAN     m_fRebootAlreadyRequested;
    BOOLEAN     m_fNeedReboot;
    BOOLEAN     m_fAccessDenied;
    BOOLEAN     m_fInitComplete;
    BOOLEAN     m_fNetcfgInUse;
    BOOLEAN     m_fNoCancel;
    BOOLEAN     m_fLockDown;

    virtual HRESULT InitializeExtendedUI(void) = 0;
    virtual HRESULT UninitializeExtendedUI(void) = 0;
};

class CLanNetNormalPage : public CLanNetPage
{
public:
    BEGIN_MSG_MAP(CLanNetPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_DEFERREDINIT, OnDeferredInit)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDC_PSB_Configure, OnConfigure)
        COMMAND_ID_HANDLER(IDC_CHK_ShowIcon, OnChange);
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        COMMAND_ID_HANDLER(IDC_PSB_Add, OnAdd)
        COMMAND_ID_HANDLER(IDC_PSB_Remove, OnRemove)
        COMMAND_ID_HANDLER(IDC_PSB_Properties, OnProperties)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        // Listview handlers
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)

    END_MSG_MAP()
    CLanNetNormalPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        BOOLEAN fReadOnly,
        BOOLEAN fNeedReboot,
        BOOLEAN fAccessDenied,
        const DWORD * adwHelpIDs = NULL);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                    LPARAM lParam, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
        BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                     BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    // listview handlers
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    HWND                    m_hwndLV;
    virtual HRESULT InitializeExtendedUI(void);
    virtual HRESULT UninitializeExtendedUI(void);


};


class CLanNetBridgedPage : public CLanNetPage
{
public:
    BEGIN_MSG_MAP(CLanNetPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_DEFERREDINIT, OnDeferredInit)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDC_CHK_ShowIcon, OnChange);
        COMMAND_ID_HANDLER(IDC_PSB_Configure, OnConfigure)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
    END_MSG_MAP()

    CLanNetBridgedPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        BOOLEAN fReadOnly,
        BOOLEAN fNeedReboot,
        BOOLEAN fAccessDenied,
        const DWORD * adwHelpIDs = NULL);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                    LPARAM lParam, BOOL& bHandled);
private:
    virtual HRESULT InitializeExtendedUI(void){return S_OK;};
    virtual HRESULT UninitializeExtendedUI(void){return S_OK;};

};

class CLanNetNetworkBridgePage : public CLanNetPage
{
public:
    BEGIN_MSG_MAP(CLanNetPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_PAINT, OnPaint)
        MESSAGE_HANDLER(WM_DEFERREDINIT, OnDeferredInit)
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDC_PSB_Configure, OnConfigure)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)


        COMMAND_ID_HANDLER(IDC_PSB_Add, OnAdd)
        COMMAND_ID_HANDLER(IDC_PSB_Remove, OnRemove)
        COMMAND_ID_HANDLER(IDC_PSB_Properties, OnProperties)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        // Listview handlers
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
    END_MSG_MAP()
    CLanNetNetworkBridgePage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        BOOLEAN fReadOnly,
        BOOLEAN fNeedReboot,
        BOOLEAN fAccessDenied,
        const DWORD * adwHelpIDs = NULL);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                    LPARAM lParam, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
        BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                         BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    // listview handlers
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl,
        BOOL& bHandled);



private:
    HWND m_hwndLV;
    HWND m_hAdaptersListView;           
    HIMAGELIST m_hAdaptersListImageList;
    virtual HRESULT InitializeExtendedUI(void);
    virtual HRESULT UninitializeExtendedUI(void);
    HRESULT FillListViewWithConnections(HWND ListView);
};


//
// LAN Connection 'Advanced' property page
//

class CLanAdvancedPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CLanAdvancedPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDC_CHK_Shared, OnShared)
        COMMAND_ID_HANDLER(IDC_CHK_Firewall, OnFirewall)
        COMMAND_ID_HANDLER(IDC_PSB_Settings, OnSettings)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_RETURN, OnClick)

    END_MSG_MAP()

    CLanAdvancedPage(IUnknown *punk, INetConnection *pconn,
                  BOOL fShared, BOOL fICSPrivate, BOOL fFirewalled, IHNetConnection *rgPrivateCons[],
                  ULONG cPrivate, LONG lxCurrentPrivate,
                  const DWORD * adwHelpIDs, IHNetConnection *pHNConn,
                  IHNetCfgMgr *pHNetCfgMgr, IHNetIcsSettings *pHNetIcsSettings);
    ~CLanAdvancedPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnShared(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnFirewall(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSettings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);


private:
    INetConnection *        m_pconn;
    IUnknown *              m_punk;
    BOOL                    m_fShared;
    BOOL                    m_fICSPrivate;
    BOOL                    m_fFirewalled;
    BOOL                    m_fOtherShared;
    IHNetIcsPublicConnection *  m_pOldSharedConnection;
    BOOL                    m_fResetPrivateAdapter;
    IHNetConnection **      m_rgPrivateCons;
    LONG                    m_lxCurrentPrivate;
    ULONG                   m_cPrivate;
    const DWORD *           m_adwHelpIDs;
    IHNetCfgMgr *           m_pHNetCfgMgr;
    IHNetIcsSettings *      m_pHNetIcsSettings;
    IHNetConnection *       m_pHNetConn;
    BOOL                    m_fShowDisableFirewallWarning;

    static INT_PTR CALLBACK DisableFirewallWarningDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL IsAdapterDHCPEnabled(IHNetConnection* pConnection);
};

//
// CLanAddComponentDlg
//

class CLanAddComponentDlg:
    public CDialogImpl<CLanAddComponentDlg>
{
    BEGIN_MSG_MAP(CLanAddComponentDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_PSB_Component_Add, OnAdd)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDblClick)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
    END_MSG_MAP()

    enum {IDD = IDD_LAN_COMPONENT_ADD};

    CLanAddComponentDlg(INetCfg *pnc, CI_FILTER_INFO* pcfi,
                        const DWORD * adwHelpIDs = NULL)
    {
        m_pnc = pnc;
        m_pcfi = pcfi;
        m_adwHelpIDs = adwHelpIDs;
    }

private:
    INetCfg *           m_pnc;
    CI_FILTER_INFO*     m_pcfi;
    HWND                m_hwndLV;
    const DWORD *       m_adwHelpIDs;

    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam,LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDblClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};


//
// LAN Connection Security Property Page
//

class CLanSecurityPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CLanSecurityPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_ID_HANDLER(CID_CA_PB_Properties, OnProperties)
        COMMAND_ID_HANDLER(CID_CA_LB_EapPackages, OnEapPackages)
        COMMAND_ID_HANDLER(CID_CA_RB_Eap, OnEapSelection)
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
    END_MSG_MAP()

    CLanSecurityPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        const DWORD * adwHelpIDs = NULL);

    ~CLanSecurityPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, 
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnEapPackages(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnEapSelection(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

private:
    INetConnection *        m_pconn;
    INetCfg *               m_pnc;
    IUnknown *              m_punk;
    const DWORD *           m_adwHelpIDs;


    // Config information of the EAP Dlls
    DTLLIST *  pListEapcfgs;

    BOOLEAN     m_fNetcfgInUse;
};

//
// Global functions
//

HRESULT HrGetDeviceIcon(HICON *phicon);
HRESULT HrQueryLanAdvancedPage(INetConnection* pconn, IUnknown* punk,
                            CPropSheetPage*& pspAdvanced, IHNetCfgMgr *pHNetCfgMgr,
                            IHNetIcsSettings *pHNetIcsSettings, IHNetConnection *pHNetConn);
HRESULT HrQueryLanFirewallPage(INetConnection* pconn, IUnknown* punk,
                               CPropSheetPage*& pspFirewall, IHNetCfgMgr *pHNetCfgMgr,
                               IHNetConnection *pHNetConn);
HRESULT HrQueryUserAndRemoveComponent (HWND hwndParent, INetCfg* pnc,
                                       INetCfgComponent* pncc);
HRESULT HrDisplayAddComponentDialog (HWND hwndParent, INetCfg* pnc,
                                     CI_FILTER_INFO* pcfi);

//
// Exported Interfaces
//
class ATL_NO_VTABLE CNetConnectionUiUtilities :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CNetConnectionUiUtilities, &CLSID_NetConnectionUiUtilities>,
    public INetConnectionUiUtilities
{
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_COMMUIUTILITIES)

    BEGIN_COM_MAP(CNetConnectionUiUtilities)
        COM_INTERFACE_ENTRY(INetConnectionUiUtilities)
    END_COM_MAP()

    CNetConnectionUiUtilities() {};
    ~CNetConnectionUiUtilities() {};

    STDMETHODIMP QueryUserAndRemoveComponent(
            HWND                hwndParent,
            INetCfg*            pnc,
            INetCfgComponent*   pncc);

    STDMETHODIMP QueryUserForReboot(
            HWND    hwndParent,
            PCWSTR pszCaption,
            DWORD   dwFlags);

    STDMETHODIMP DisplayAddComponentDialog (
            HWND            hwndParent,
            INetCfg*        pnc,
            CI_FILTER_INFO* pcfi);

    STDMETHODIMP_(BOOL) UserHasPermission(DWORD dwPerm);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanuiobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N U I O B J. C P P
//
//  Contents:   Implementation of the LAN ConnectionUI object
//
//  Notes:
//
//  Created:     tongl   8 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "lancmn.h"
#include "lanui.h"
#include "wzcui.h"
#include "lanuiobj.h"
#include "lanwiz.h"
#include "ncnetcon.h"
#include "ncras.h"
#include "lanhelp.h"
#include "ncperms.h"
#include "advpage.h"
#include "cfpidl.h"
#include "..\folder\confold.h"
#include "..\folder\connlist.h"
#include "ncsvc.h"

extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szInfId_MS_AtmElan[];
const WCHAR c_szTcpip[]     = L"Tcpip";

//+---------------------------------------------------------------------------
// INetConnectionUI
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::SetConnection
//
//  Purpose:    Sets the LAN connection that this UI object will operate upon
//
//  Arguments:
//      pCon [in]   LAN connection object to operate on. Can be NULL.
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   16 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::SetConnection(INetConnection* pCon)
{
    HRESULT hr = S_OK;

    ReleaseObj(m_pconn);
    m_pconn = pCon;
    AddRefObj(m_pconn);

    TraceError("CLanConnectionUi::SetConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::Connect
//
//  Purpose:    Tells the connection to connect, optionally displaying UI of
//              connection progress.
//
//  Arguments:
//      hwndParent [in]     Parent window for UI
//      dwFlags    [in]     Flags affecting how UI is shown
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   16 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::Connect(HWND hwndParent, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_pconn)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        CLanConnectionUiDlg dlg;
        HWND                hwndDlg;

        if (!(dwFlags & NCUC_NO_UI))
        {
            // Display UI prior to connect
            //

            dlg.SetConnection(m_pconn);
            hwndDlg = dlg.Create(hwndParent);

            if (!hwndDlg)
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pconn->Connect();

            // Sleep a bit so they can read the text
            Sleep(1000);

            if (!(dwFlags & NCUC_NO_UI))
            {
                SetDlgItemText(hwndDlg, IDC_TXT_Caption, c_szEmpty);
                Sleep(100);

                UINT ids = SUCCEEDED(hr) ?
                    IDS_LAN_CONNECTED :
                    IDS_LAN_CONNECT_FAILED;

                PCWSTR szwResult = SzLoadIds(ids);
                SetDlgItemText(hwndDlg, IDC_TXT_Caption, szwResult);

                // Sleep a bit so they can read the text
                Sleep(1000);

                DestroyWindow(hwndDlg);
            }

        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CLanConnectionUi::Connect");
    return hr;
}

STDMETHODIMP CLanConnectionUi::Disconnect(HWND hwndParent, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_pconn)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = m_pconn->Disconnect();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanConnectionUi::Disconnect");
    return hr;
}
//+---------------------------------------------------------------------------
// INetConnectionPropertyUi
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::AddPages
//
//  Purpose:    Called when our UI object shoud add its pages to a property
//              sheet for the connection UI owned by the shell.
//
//  Arguments:
//      pfnAddPage [in]     Callback function to add the page
//      lParam     [in]     User-defined paramter required by the callback
//                          function.
//
//  Returns:    S_OK if succeeded, otherwise OLE error.
//
//  Author:     danielwe   28 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::AddPages(HWND hwndParent,
                                        LPFNADDPROPSHEETPAGE pfnAddPage,
                                        LPARAM lParam)
{
    HRESULT hr = S_OK;

    if (!pfnAddPage)
    {
        hr = E_POINTER;
    }
    else if (!m_pconn)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        NETCON_PROPERTIES* pProperties;
        hr = m_pconn->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            BOOL bShift = (0x8000 & GetKeyState(VK_SHIFT)); // ISSUE-2000/08/28-kenwic For debugging bridge bindings, remove before ship
            if(!bShift && pProperties->MediaType == NCM_BRIDGE)
            {
                if (!m_pspNet)
                {
                    m_pspNet = new CLanNetNetworkBridgePage(static_cast<INetConnectionPropertyUi *>(this),
                        m_pnc, m_pconn, m_fReadOnly, m_fNeedReboot,
                        m_fAccessDenied, g_aHelpIDs_IDD_LAN_NETWORKING);
                }
                
                if (m_pspNet)
                {
                    (VOID) pfnAddPage(m_pspNet->CreatePage(IDD_LAN_NETWORKING_MACBRIDGE, 0),
                        lParam); 
                }
            }
            else if(!bShift && pProperties->dwCharacter & NCCF_BRIDGED)
            {
                if (!m_pspNet)
                {
                    m_pspNet = new CLanNetBridgedPage(static_cast<INetConnectionPropertyUi *>(this),
                        m_pnc, m_pconn, m_fReadOnly, m_fNeedReboot,
                        m_fAccessDenied, g_aHelpIDs_IDD_LAN_NETWORKING);
                }
                
                if (m_pspNet)
                {
                    (VOID) pfnAddPage(m_pspNet->CreatePage(IDD_LAN_NETWORKING_BRIDGED, 0),
                        lParam); 
                }
                
            }
            else
            {
                if (!m_pspNet)
                {
                    m_pspNet = new CLanNetNormalPage(static_cast<INetConnectionPropertyUi *>(this),
                        m_pnc, m_pconn, m_fReadOnly, m_fNeedReboot,
                        m_fAccessDenied, g_aHelpIDs_IDD_LAN_NETWORKING);
                }
                
                if (m_pspNet)
                {
                    (VOID) pfnAddPage(m_pspNet->CreatePage(IDD_LAN_NETWORKING, 0),
                        lParam);
                }

            }
        
            FreeNetconProperties(pProperties);
        }

        // display the "Wireless Zero Configuration" page
        //
        // for now (WinXP Client RTM) the decision was made to let everybody party, but based on 
        // the acl below. Later, the security schema won't change by default, but support will be
        // added allowing admins to tighten up the access to the service RPC APIs.
        if (m_pspWZeroConf==NULL /*&& FIsUserAdmin()*/)
        {
            m_pspWZeroConf = new CWZeroConfPage(static_cast<INetConnectionPropertyUi *>(this),
                                       m_pnc, m_pconn , g_aHelpIDs_IDD_LAN_WZEROCONF);
            // The page should show up only if the adapter is wireless and if
            // the wzcsvc service is responding to calls.
            if (!m_pspWZeroConf->IsWireless())
            {
                delete m_pspWZeroConf;
                m_pspWZeroConf = NULL;
            }
        }

        if (m_pspWZeroConf != NULL)
        {
            (VOID) pfnAddPage(
                       m_pspWZeroConf->CreatePage(
                           IDD_LAN_WZEROCONF, 
                           0),
                       lParam);
        }

        //
        // display the "Security" page 

        if (m_pspWZeroConf == NULL && !m_pspSecurity)
        {
            TraceTag (ttidLanUi, "OnInitDialog: Calling ElCanEapolRunOnInterface");

            if (ElCanEapolRunOnInterface (m_pconn))
            {
                TraceTag (ttidLanUi, "OnInitDialog: Can surely display Authentication tab on interface");
                m_pspSecurity = new CLanSecurityPage(static_cast<INetConnectionPropertyUi *>(this),
                                       m_pnc, m_pconn, 
                                       g_aHelpIDs_IDD_SECURITY);
            }
            else
            {
                TraceTag (ttidLanUi, "OnInitDialog: Cannot display Authentication tab on interface");
            }
        }

        if (m_pspSecurity)
        {
            (VOID) pfnAddPage(
                       m_pspSecurity->CreatePage(
                           IDD_LAN_SECURITY,
                           0,
                           NULL,
                           NULL,
                           NULL,
                           WZCGetSPResModule()),
                       lParam);
        } 
        
        // Check to see what homenet pages should be shown. These pages are
        // never shown if the user is not an admin, as such a user will not
        // have rights to modify the WMI store, which may be necessary just
        // to retrieve the IHNetConnection
        //

        // (a) The page is not displayed unless the user is an admin
        //     or power-user, and the user has rights to share connections.
        //
        if (IsHNetAllowed(NCPERM_ShowSharedAccessUi) || IsHNetAllowed(NCPERM_PersonalFirewallConfig))
        {
            // (b) The page is not displayed unless TCP/IP is installed.
            //
            DWORD dwState;
            if (SUCCEEDED(HrSvcQueryStatus(c_szTcpip, &dwState)) && dwState == SERVICE_RUNNING)
            {
                
                IHNetCfgMgr *pHNetCfgMgr;
                IHNetIcsSettings *pHNetIcsSettings;
                IHNetConnection *pHNConn;
                
                hr = CoCreateInstance(
                    CLSID_HNetCfgMgr,
                    NULL,
                    CLSCTX_ALL,
                    IID_IHNetCfgMgr,
                    reinterpret_cast<void**>(&pHNetCfgMgr)
                    );
                
                if (SUCCEEDED(hr))
                {
                    hr = pHNetCfgMgr->QueryInterface(
                        __uuidof(pHNetIcsSettings),
                        reinterpret_cast<void**>(&pHNetIcsSettings)
                        );
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = pHNetCfgMgr->GetIHNetConnectionForINetConnection(
                            m_pconn,
                            &pHNConn
                            );
                        
                        if (SUCCEEDED(hr))
                        {
                            
                            // display the 'Advanced' page if necessary
                            //
                            
                            if (!m_pspAdvanced)
                            {
                                hr = HrQueryLanAdvancedPage(
                                    m_pconn,
                                    static_cast<INetConnectionPropertyUi *>(this),
                                    m_pspAdvanced,
                                    pHNetCfgMgr,
                                    pHNetIcsSettings,
                                    pHNConn);
                            }
                            if (m_pspAdvanced)
                            {
                                (VOID) pfnAddPage(
                                    m_pspAdvanced->CreatePage(IDD_LAN_ADVANCED, 0),
                                    lParam);
                            }
                            
                            ReleaseObj(pHNConn);
                        }
                        
                        ReleaseObj(pHNetIcsSettings);
                    }
                    
                    ReleaseObj(pHNetCfgMgr);
                }
                
                if(FAILED(hr))
                {
                    if(!m_pspHomenetUnavailable)
                    {
                        hr = HrCreateHomenetUnavailablePage(hr, m_pspHomenetUnavailable);
                    }
                    
                    if (m_pspHomenetUnavailable)
                    {
                        (VOID) pfnAddPage(
                            m_pspHomenetUnavailable->CreatePage(IDD_LAN_HOMENETUNAVAILABLE, 0),
                            lParam);
                    }
                    
                    hr = S_OK; 
                }
            }
        }
    }

    TraceError("CLanConnectionUi::AddPages(INetConnectionPropertyUi)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//

STDMETHODIMP
CLanConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_LAN, NCSM_LAN, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);

    return hr;
}

//+---------------------------------------------------------------------------
// INetConnectionWizardUi Methods
//
//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::QueryMaxPageCount
//
//  Purpose:
//
//  Arguments:
//      pContext    [in]
//      pcMaxPages  [out]
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  9 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::QueryMaxPageCount(INetConnectionWizardUiContext* pContext,
                                                 DWORD*    pcMaxPages)
{
    // Keep the pContext if we have not got one before
    // for later use (to get the writable INetCfg *, for instance)
    Assert(pContext);
    Assert(pcMaxPages);

    if (!m_pContext)
    {
        m_pContext = pContext;
        AddRefObj(pContext);
    }

    *pcMaxPages = 1;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::AddPages
//
//  Purpose:
//
//  Arguments:
//      INetConnectionWizardUiContext* pContext [in]
//      LPFNADDPROPSHEETPAGE pfnAddPage [in]
//      LPARAM lParam [in]
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  9 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::AddPages(INetConnectionWizardUiContext* pContext,
                                        LPFNADDPROPSHEETPAGE lpfnAddPage,
                                        LPARAM lParam)
{
    // 1) Keep the pContext if we have not got one before
    //    for later use (to get the writable INetCfg *, for instance)
    Assert(pContext);
    if (!m_pContext)
    {
        m_pContext = pContext;
        AddRefObj(pContext);
    }

    HPROPSHEETPAGE * ahpsp = NULL;
    INT cPages = 0;

    // 2) Call "lpfnAddPage(hpsp, lParam)" for every
    // wizard page in the right order

    // Get all wizard pages

    // $REVIEW(tongl 10/30/97): With current design,
    // LAN wizard has one page only
    HRESULT hr = HrSetupWizPages(pContext, &ahpsp, &cPages);

    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hpspCurrentPage = NULL;

        while (cPages--)
        {
            hpspCurrentPage = *ahpsp;
            ahpsp++;

            // Add each wizard page
            if (lpfnAddPage(hpspCurrentPage, lParam))
            {
                // We successfully made the hand off to the requestor
                // Now we reset our handle so we don't try to free it
                hpspCurrentPage = NULL;
            }

            // clean up if needed
            if (hpspCurrentPage)
            {
                TraceError("CLanConnectionUi::AddPages, Failed to add one wizard page...", E_FAIL);
                DestroyPropertySheetPage(hpspCurrentPage);
            }
        }
    }

    TraceError("CLanConnectionUi::AddPages", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::GetSuggestedConnectionName
//
//  Purpose:
//
//  Arguments:
//      BSTR * bstrSuggestedName     [out]
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  9 Dec 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::GetSuggestedConnectionName(
    PWSTR* ppszwSuggestedName)
{
    HRESULT hr = S_OK;

    // Validate parameters.
    //
    if (!ppszwSuggestedName)
    {
        hr = E_POINTER;
    }
    else
    {
        GUID guid;
        hr = m_pnccAdapter->GetInstanceGuid(&guid);
        if (SUCCEEDED(hr))
        {
            LPWSTR szName;
            CIntelliName Intelliname(_Module.GetResourceInstance(), NULL);
            Intelliname.GenerateName(guid, NCM_LAN, 0, NULL, &szName);

            hr = HrCoTaskMemAllocAndDupSz ( szName, ppszwSuggestedName);
            LocalFree(szName);
        }
    }

    TraceError("CLanConnectionUi::GetSuggestedConnectionName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::GetNewConnectionInfo
//
//  Purpose:    Allow provider control over renaming the current connection
//              and the optional creation of connection shortcuts
//
//  Arguments:
//
//  Returns:    HRESULT, Error code.
//
//  Author:     scottbri    02 Feb 1998
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::GetNewConnectionInfo(
    DWORD*              pdwFlags,
    NETCON_MEDIATYPE*   pMediaType)
{
    *pdwFlags = 0;
    *pMediaType = NCM_LAN;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::SetConnectionName
//
//  Purpose:
//
//  Arguments:
//      PCWSTR pszwConnectionName         [in]
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  9 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::SetConnectionName(PCWSTR pszwConnectionName)
{
    HRESULT hr = S_OK;

    // 1) If the pointer is NULL or string is empty, return E_INVALIDAR
    if ((!pszwConnectionName) || !wcslen(pszwConnectionName))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // 2) Otherwise, save the name to m_strConnectionName

        // $REVIEW(tongl 12\23\97): Scott expects this function to return
        // HRESULT_FROM_WIN32(ERROR_DUP_NAME)
        // Here is what we are supposed to do:
        // 1) Call HrIsConnectionNameUnique to determine if the name is unique
        // 2) Call m_pLanConn->SetInfo if we have a valid connection already
        //    i.e. GetNewConnection has been called.

        AssertSz(m_pnccAdapter, "How come we dont have the device yet ?");

        if (m_pnccAdapter)
        {
            GUID guidConn;

            hr = m_pnccAdapter->GetInstanceGuid(&guidConn);

            if (SUCCEEDED(hr))
            {
                hr = HrIsConnectionNameUnique(guidConn,
                                              pszwConnectionName);

                if (S_FALSE == hr) // is duplicate
                {
                    hr = HRESULT_FROM_WIN32(ERROR_DUP_NAME);
                }
                else if (S_OK == hr)
                {
                    m_strConnectionName = pszwConnectionName;

                    if (m_pLanConn)
                    {
                        LANCON_INFO lci = {0};
                        lci.szwConnName = const_cast<PWSTR>(pszwConnectionName);
                        m_pLanConn->SetInfo(LCIF_NAME, &lci);
                    }
                }
            }
        }
    }

    TraceErrorOptional("CLanConnectionUi::SetConnectionName", hr,
                       HRESULT_FROM_WIN32(ERROR_DUP_NAME) == hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::GetNewConnection
//
//  Purpose:
//
//  Arguments:
//      INetConnection**  ppCon [out]
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  9 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::GetNewConnection(INetConnection**  ppCon)
{
    Assert (ppCon);

    *ppCon = NULL;

    // Enumerate existing connections and get the INetLanConnection *
    // as follows:
    //    1) If connection for the current m_pnccAdapter exists
    //         simply use the existing INetLanConnection *
    //    2) If connection for the current m_pnccAdapter does not exist
    //         CreateInstance to get a new INetLanConnection *

    INetLanConnection * pLanConn = NULL;
    HRESULT hr = HrGetLanConnection(&pLanConn);

    if (SUCCEEDED(hr))
    {
        // Call INetLanConnection::SetInfo if m_strConnName is not empty
        Assert(pLanConn);

        ReleaseObj(m_pLanConn);
        m_pLanConn = pLanConn;

        if (!m_strConnectionName.empty())
        {
            LANCON_INFO lci = {0};
            lci.szwConnName = const_cast<PWSTR>(m_strConnectionName.c_str());
            pLanConn->SetInfo(LCIF_NAME, &lci);
        }

        // Return the INetConnection pointer
        hr = HrQIAndSetProxyBlanket(pLanConn, &ppCon);
    }

    TraceError("CLanConnectionUi::GetNewConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
// INetLanConnectionWizardUi Methods

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::SetDeviceComponent
//
//  Purpose:
//
//  Arguments:
//      GUID pguid [in]
//
//  Returns:    HRESULT, Error code.
//              S_OK if the GUID matches a installed net device's GUID.
//              E_FAIL if no match found.
//
//  Author:     tongl  19 Oct 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::SetDeviceComponent(const GUID * pguid)
{
    HRESULT hr = S_OK;

    // AddPages must be called before SetDeviceComponent is called
    AssertSz(m_pContext, "We do not have a valid context yet ?!");

    if (!m_pnc)
    {
        hr = m_pContext->GetINetCfg(&m_pnc);
    }

    // Reset the adapter
    ReleaseObj(m_pnccAdapter);
    m_pnccAdapter = NULL;

    // Reset the connection
    ReleaseObj(m_pLanConn);
    m_pLanConn = NULL;

    // reset connection name
    m_strConnectionName = c_szEmpty;

    AssertSz(m_pnc, "Invalid INetCfg!");

    // Note: pguid == NULL when the wizard is requesting the LAN adapter
    //       to release it's m_pnccAdapter and m_pLanConn members
    //
    if (SUCCEEDED(hr) && m_pnc && pguid)
    {
        // 1) Enumerate net adapters and try to find a match with the input GUID
        // Save the adapter component in m_pnccAdapter
        BOOL fFound = FALSE;

        CIterNetCfgComponent nccIter(m_pnc, &GUID_DEVCLASS_NET);
        INetCfgComponent* pnccAdapter = NULL;

        while (!fFound && SUCCEEDED(hr) &&
               (S_OK == (hr = nccIter.HrNext(&pnccAdapter))))
        {
            GUID guidDev;
            hr = pnccAdapter->GetInstanceGuid(&guidDev);

            if (S_OK == hr)
            {
                if (*pguid == guidDev)
                {
                    hr = HrIsLanCapableAdapter(pnccAdapter);

                    AssertSz((S_OK == hr), "Why is Lan wizard called on a non-Lan capable adapter ?");

                    if (S_OK == hr)
                    {
                        fFound = TRUE;
                        m_pnccAdapter = pnccAdapter;
                        AddRefObj(m_pnccAdapter);
                    }
                }
            }
            ReleaseObj (pnccAdapter);
        }

        // 2) If we matched an adapter successfully, set it to the UI dialog
        if ((fFound) && (S_OK == hr))
        {
            Assert(m_pnccAdapter);

            if (m_pWizPage)
            {
                m_pWizPage->SetNetcfg(m_pnc);
                m_pWizPage->SetAdapter(m_pnccAdapter);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    }

    TraceError("CLanConnectionUi::SetDeviceComponent", hr);
    return hr;
}

//
// INetLanConnectionUiInfo
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::GetDeviceGuid
//
//  Purpose:    Returns the device GUID associated with this connection
//
//  Arguments:
//      pguid [out]     Returns GUID
//
//  Returns:    S_OK if success, OLE or Win32 error code otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::GetDeviceGuid(GUID *pguid)
{
    HRESULT     hr = S_OK;

    if (!pguid)
    {
        hr = E_POINTER;
    }
    else
    {
        // $REVIEW(tongl 11/29/97): when called from Lan wizard, the
        // m_pconn has not been set yet, but the device guid is kept
        // in m_pnccAdapter. So I added the if-else below.
        if (m_pconn) // called from property UI
        {
            INetLanConnection *     plan;

            hr = HrQIAndSetProxyBlanket(m_pconn, &plan);
            if (SUCCEEDED(hr))
            {
                hr = plan->GetDeviceGuid(pguid);
                ReleaseObj(plan);
            }
        }
        else // called from wizard UI
        {
            AssertSz(m_pnccAdapter, "If called from wizard, the device should have been set.");

            if (m_pnccAdapter)
            {
                m_pnccAdapter->GetInstanceGuid(pguid);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }

    TraceError("CLanConnectionUi::GetDeviceGuid", hr);
    return hr;
}

//
// INetConnectionUiLock
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::QueryLock
//
//  Purpose:    Causes the UI object to attempt to get the INetCfg write lock.
//
//  Arguments:
//      ppszwLockHolder [out] Description of component that holds the
//                            write lock in the event that it couldn't be
//                            obtained.
//
//  Returns:    S_OK if success, S_FALSE if write lock couldn't be obtained,
//              OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
STDMETHODIMP CLanConnectionUi::QueryLock(PWSTR* ppszwLockHolder)
{
    HRESULT     hr = S_OK;

    if (!ppszwLockHolder)
    {
        hr = E_POINTER;
    }
    else
    {
        INetCfgLock *   pnclock;

        AssertSz(!m_pnc, "We're assuming this is in the property sheet "
                  "context and we don't yet have an INetCfg!");

        *ppszwLockHolder = NULL;

        // Instantiate an INetCfg
        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetCfg,
                reinterpret_cast<LPVOID *>(&m_pnc));

        TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance");

        if (SUCCEEDED(hr))
        {
            // Get the locking interface
            hr = m_pnc->QueryInterface(IID_INetCfgLock,
                                       reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr))
            {
                // Attempt to lock the INetCfg for read/write
                hr = pnclock->AcquireWriteLock(0,
                        SzLoadIds(IDS_LANUI_LOCK_DESC), ppszwLockHolder);

                ReleaseObj(pnclock);

                if (NETCFG_E_NEED_REBOOT == hr)
                {
                    // Can't make any changes because we are pending a reboot.
                    m_fReadOnly = TRUE;
                    m_fNeedReboot = TRUE;
                    hr = S_OK;
                }
                else if(E_ACCESSDENIED == hr)
                {
                    // user not logged on as admin
                    //
                    m_fReadOnly = TRUE;
                    m_fAccessDenied = TRUE;
                    hr = S_OK;
                }
                else if (S_FALSE == hr)
                {
                    // We don't have sufficent rights
                    //
                    m_fReadOnly = TRUE;
                    hr = S_OK;
                }
            }
        }
    }

    TraceError("CLanConnectionUi::QueryLock", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N U I . C P P
//
//  Contents:   Lan connection object UI
//
//  Notes:
//
//  Author:     danielwe   16 Oct 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop
#include "devdatatip.h"
#include "lancmn.h"
#include "lanui.h"
#include "ncnetcfg.h"
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "ncsvc.h"
#include "ncui.h"
#include "util.h"
#include <raserror.h>
#include <raseapif.h>
#include "lanhelp.h"
#include "ncreg.h"
#include "iphlpapi.h"
#include "beacon.h"
#include "htmlhelp.h"
#include "lm.h"
#include <clusapi.h>
#include <wzcsapi.h>

extern const WCHAR c_szEmpty[];
extern const WCHAR c_szNetCfgHelpFile[];

extern const WCHAR c_szInfId_MS_AppleTalk[];
extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_NetMon[];
extern const WCHAR c_szInfId_MS_TCPIP[];
extern const WCHAR c_szInfId_MS_PSched[];

static BOOL g_fReentrancyCheck = FALSE;

static TCHAR g_pszFirewallRegKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\HomeNetworking\\PersonalFirewall");
static TCHAR g_pszDisableFirewallWarningValue[] = TEXT("ShowDisableFirewallWarning");

static const CLSID CLSID_NetGroupPolicies =
        {0xBA126AD8,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};


//+---------------------------------------------------------------------------
//
//  Function:   HrDisplayAddComponentDialog
//
//  Purpose:    Display the add component dialog box and add whatever the user
//              selects.
//
//  Arguments:
//
//  Returns:    S_OK if added, S_FALSE if the user cancelled, NETCFG_S_REBOOT
//              if a reboot is required
//
//  Author:     danielwe   15 Dec 1997
//
//  Notes:      This function is called from RASDLG.DLL for the Networking
//              tab of the RAS entry property sheet.
//
HRESULT
HrDisplayAddComponentDialog (
    HWND        hwndParent,
    INetCfg*    pnc,
    CI_FILTER_INFO* pcfi)
{
    HRESULT hr;

    if (hwndParent && !IsWindow (hwndParent))
    {
        hr = E_INVALIDARG;
    }
    else if (!pnc)
    {
        hr = E_POINTER;
    }
    else
    {
        CLanAddComponentDlg dlg(pnc, pcfi, g_aHelpIDs_IDD_LAN_COMPONENT_ADD);
        int nRet = dlg.DoModal(hwndParent);
        hr = static_cast<HRESULT>(nRet);
    }

    TraceError("HrDisplayAddComponentDialog", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryUserAndRemoveComponent
//
//  Purpose:    Ask the user if its okay to remove the specified component
//              and remove it if he/she inidcates yes.
//
//  Arguments:
//
//  Returns:    S_OK if removed, S_FALSE if the user cancelled, NETCFG_S_REBOOT
//              if a reboot is required
//
//  Author:     shaunco   30 Dec 1997
//
//  Notes:      This function is called from RASDLG.DLL for the Networking
//              tab of the RAS entry property sheet.
//
HRESULT
HrQueryUserAndRemoveComponent (
    HWND                hwndParent,
    INetCfg*            pnc,
    INetCfgComponent*   pncc)
{
    HRESULT hr;

    if (hwndParent && !IsWindow (hwndParent))
    {
        hr = E_INVALIDARG;
    }
    else if (!pnc || !pncc)
    {
        hr = E_POINTER;
    }
    else
    {
        PWSTR pszwName;
        hr = pncc->GetDisplayName(&pszwName);
        if (SUCCEEDED(hr))
        {
            Assert(pszwName);

            BOOL fProceed = TRUE;

            // Special case for RAS and TCP/IP removal.  If there
            // are active ras connections, the user has to disconnect
            // them all first before TCP/IP can be removed.
            //
            PWSTR pszwId;
            hr = pncc->GetId (&pszwId);
            if (SUCCEEDED(hr))
            {
                if ((FEqualComponentId (c_szInfId_MS_TCPIP,     pszwId) ||
                     FEqualComponentId (c_szInfId_MS_NWIPX,     pszwId) ||
                     FEqualComponentId (c_szInfId_MS_PSched,    pszwId) ||
                     FEqualComponentId (c_szInfId_MS_AppleTalk, pszwId) ||
                     FEqualComponentId (c_szInfId_MS_NetMon,    pszwId))
                     && FExistActiveRasConnections ())
                {
                    NcMsgBoxWithVarCaption(_Module.GetResourceInstance(),
                        hwndParent,
                        IDS_LAN_REMOVE_CAPTION, pszwName,
                        IDS_LANUI_REQUIRE_DISCONNECT_REMOVE,
                        MB_ICONERROR | MB_OK);

                    fProceed = FALSE;
                }

                CoTaskMemFree (pszwId);
            }

            if (fProceed)
            {
                HCURSOR hCur = NULL;

                // Query the user about removing the component
                //
                int nRet = NcMsgBoxWithVarCaption(_Module.GetResourceInstance(),
                                hwndParent, IDS_LAN_REMOVE_CAPTION,
                                pszwName, IDS_LAN_REMOVE_WARNING,
                                MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2,
                                pszwName);

                if (nRet == IDYES)
                {
                    OBO_TOKEN OboToken;
                    ZeroMemory (&OboToken, sizeof(OboToken));
                    OboToken.Type = OBO_USER;
                    PWSTR      mszwRefs = NULL;

                    hCur = BeginWaitCursor();

                    hr = HrRemoveComponent(pnc, pncc, &OboToken, &mszwRefs);
                    if (NETCFG_S_STILL_REFERENCED == hr)
                    {
                        static const WCHAR  c_szCRLF[] = L"\r\n";
                        tstring     strRefs = c_szCRLF;
                        PWSTR      szwRef = mszwRefs;

                        AssertSz(mszwRefs, "This can't be NULL!");

                        while (*szwRef)
                        {
                            strRefs += c_szCRLF;
                            strRefs += szwRef;
                            szwRef += lstrlenW(szwRef) + 1;
                        }

                        LvReportError(IDS_LANUI_STILL_REFERENCED, hwndParent,
                                      pszwName, strRefs.c_str());

                        CoTaskMemFree(mszwRefs);
                    }

                    // If the remove succeeded commit the changes
                    //
                    if (SUCCEEDED(hr))
                    {
                        g_fReentrancyCheck = TRUE;

                        // Commit the changes
                        HRESULT hrTmp = pnc->Apply();

                        g_fReentrancyCheck = FALSE;

                        if (S_OK != hrTmp)
                        {
                            // Propigate the error
                            //
                            hr = hrTmp;
                            if (FAILED(hr))
                                pnc->Cancel();
                        }
                    }

                    if (FAILED(hr))
                    {
                        if (NETCFG_E_ACTIVE_RAS_CONNECTIONS == hr)
                        {
                            LvReportError(IDS_LANUI_REQUIRE_DISCONNECT_REMOVE, hwndParent,
                                          pszwName, NULL);
                        }
                        else if (NETCFG_E_NEED_REBOOT == hr)
                        {
                            LvReportError(IDS_LANUI_REQUIRE_REBOOT_REMOVE, hwndParent,
                                          pszwName, NULL);
                        }
                        else
                        {
                            LvReportErrorHr(hr, IDS_LANUI_GENERIC_REMOVE_ERROR,
                                            hwndParent, pszwName);
                        }
                    }
                }
                else
                {
                    hr = S_FALSE;
                }

                EndWaitCursor(hCur);
            }

            CoTaskMemFree(pszwName);
        }
    }

    TraceError("HrQueryUserAndRemoveComponent",
        (S_FALSE == hr || NETCFG_S_STILL_REFERENCED == hr ||
         NETCFG_S_REBOOT) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryUserForReboot
//
//  Purpose:    Query the user to reboot.  If he/she chooses yes, a reboot
//              is initiated.
//
//  Arguments:
//      hwndParent [in] Parent window handle.
//      pszCaption [in] Caption text to use.
//      dwFlags    [in] Control flags (QUFR_PROMPT | QUFR_REBOOT)
//
//  Returns:    S_OK if a reboot is initiated, S_FALSE if the user
//              didn't want to, or an error code otherwise.
//
//  Author:     shaunco   2 Jan 1998
//
//  Notes:
//
HRESULT
HrQueryUserForReboot (
    HWND    hwndParent,
    PCWSTR pszCaption,
    DWORD   dwFlags)
{
    TraceFileFunc(ttidLanUi);

    PCWSTR pszText = SzLoadString(_Module.GetResourceInstance(),
                        IDS_REBOOT_REQUIRED);

    HRESULT hr = HrNcQueryUserForRebootEx (hwndParent,
                    pszCaption, pszText, dwFlags);

    TraceError("HrQueryUserForReboot", hr);
    return hr;
}

HRESULT CNetConnectionUiUtilities::QueryUserAndRemoveComponent(
            HWND                hwndParent,
            INetCfg*            pnc,
            INetCfgComponent*   pncc)
{
    TraceFileFunc(ttidLanUi);

    return HrQueryUserAndRemoveComponent (hwndParent, pnc, pncc);
}

HRESULT CNetConnectionUiUtilities::QueryUserForReboot(
            HWND    hwndParent,
            PCWSTR pszCaption,
            DWORD   dwFlags)
{
    TraceFileFunc(ttidLanUi);
    return HrQueryUserForReboot (hwndParent, pszCaption, dwFlags);
}

HRESULT CNetConnectionUiUtilities::DisplayAddComponentDialog (
            HWND            hwndParent,
            INetCfg*        pnc,
            CI_FILTER_INFO* pcfi)
{
    TraceFileFunc(ttidLanUi);
    return HrDisplayAddComponentDialog(hwndParent, pnc, pcfi);
}

BOOL CNetConnectionUiUtilities::UserHasPermission(DWORD dwPerm)
{
    TraceFileFunc(ttidLanUi);
    BOOL fPermission = FALSE;

    if (dwPerm == NCPERM_AllowNetBridge_NLA || dwPerm == NCPERM_PersonalFirewallConfig ||
        dwPerm == NCPERM_ICSClientApp || dwPerm == NCPERM_ShowSharedAccessUi)
    {
        HRESULT hr;
        INetMachinePolicies* pMachinePolicy;


        hr = CoCreateInstance(CLSID_NetGroupPolicies, NULL,
                              CLSCTX_SERVER, IID_INetMachinePolicies,
                              reinterpret_cast<void **>(&pMachinePolicy));

        if (SUCCEEDED(hr))
        {
            hr = pMachinePolicy->VerifyPermission(dwPerm, &fPermission);

            pMachinePolicy->Release();
        }

    }
    else
    {
        fPermission = FHasPermission(dwPerm);
    }

    return fPermission;
}

//
// Connect UI dialog
//

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUiDlg::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message.
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   16 Oct 1997
//
//  Notes:
//
LRESULT CLanConnectionUiDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                          LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT hr = S_OK;
    NETCON_PROPERTIES* pProps;

    AssertSz(m_pconn, "No connection object in dialog!");

    hr = m_pconn->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        SetDlgItemText(IDC_TXT_Caption, SzLoadIds(IDS_LAN_CONNECT_CAPTION));
        SetWindowText(pProps->pszwName);

        HICON hLanIconSmall;
        HICON hLanIconBig;

        hr = HrGetIconFromMediaType(GetSystemMetrics(SM_CXSMICON), NCM_LAN, NCSM_LAN, 7, 0, &hLanIconSmall);
        if (SUCCEEDED(hr))
        {
            hr = HrGetIconFromMediaType(GetSystemMetrics(SM_CXICON), NCM_LAN, NCSM_LAN, 7, 0, &hLanIconBig);
            if (SUCCEEDED(hr))
            {
                SetIcon(hLanIconSmall, FALSE);
                SetIcon(hLanIconBig, TRUE);

                SendDlgItemMessage(IDI_Device_Icon, STM_SETICON, reinterpret_cast<WPARAM>(hLanIconBig), 0);

            }
        }

        FreeNetconProperties(pProps);
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetDeviceIcon
//
//  Purpose:    Returns the icon associated with network devices
//
//  Arguments:
//      phicon [out]    Returns HICON
//
//  Returns:    S_OK if success, SetupAPI or Win32 error otherwise
//
//  Author:     danielwe   12 Nov 1997
//
//  Notes:
//
HRESULT HrGetDeviceIcon(HICON *phicon)
{
    TraceFileFunc(ttidLanUi);

    SP_CLASSIMAGELIST_DATA  cild;

    Assert(phicon);

    *phicon = NULL;

    HRESULT hr = HrSetupDiGetClassImageList(&cild);

    if (SUCCEEDED(hr))
    {
        INT     iImage;

        hr = HrSetupDiGetClassImageIndex(&cild,
                                         const_cast<GUID *>(&GUID_DEVCLASS_NET),
                                         &iImage);

        if (SUCCEEDED(hr))
        {
            *phicon = ImageList_GetIcon(cild.ImageList, iImage, 0);
        }

        (void) HrSetupDiDestroyClassImageList(&cild);
    }

    TraceError("HrGetDeviceIcon", hr);
    return hr;
}


//
// CLanNetPage
//

CLanNetPage::CLanNetPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    BOOLEAN fReadOnly,
    BOOLEAN fNeedReboot,
    BOOLEAN fAccessDenied,
    const DWORD * adwHelpIDs)
{
    TraceFileFunc(ttidLanUi);

    m_pconn = pconn;
    m_pnccAdapter = NULL;
    m_pnc = pnc;
    m_punk = punk;
    m_hilCheckIcons = NULL;
    m_hPrevCurs = NULL;
    m_plan = NULL;
    m_fRebootAlreadyRequested = FALSE;
    m_fReadOnly = fReadOnly;
    m_fNeedReboot = fNeedReboot;
    m_fAccessDenied = fAccessDenied;
    m_fInitComplete = FALSE;
    m_fNetcfgInUse = FALSE;
    m_fNoCancel = FALSE;
    m_fLockDown = FALSE;
    m_adwHelpIDs = adwHelpIDs;
    m_fDirty    = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::~CLanNetPage
//
//  Purpose:    Destroys the CLanNetPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
CLanNetPage::~CLanNetPage()
{
    TraceFileFunc(ttidLanUi);

    // Destroy our check icons
    if (m_hilCheckIcons)
    {
        ImageList_Destroy(m_hilCheckIcons);
    }

    if (m_pnc)
    {
        INetCfgLock *   pnclock;

        if (SUCCEEDED(m_pnc->QueryInterface(IID_INetCfgLock,
                                            (LPVOID *)&pnclock)))
        {
            (VOID)pnclock->ReleaseWriteLock();
            ReleaseObj(pnclock);
        }
    }

    FreeCollectionAndItem(m_listBindingPaths);
    ReleaseObj(m_pnccAdapter);
    ReleaseObj(m_plan);
}

LRESULT CLanNetPage::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    m_fDirty = TRUE;

    bHandled = FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnDeferredInit
//
//  Purpose:    Handles the WM_DEFERREDINIT message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     scottbri    20 Oct 1998
//
//  Notes:
//
LRESULT CLanNetPage::OnDeferredInit(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT hr;
    CWaitCursor wc;
    HWND hwndParent = GetParent();
    AssertSz(m_pnc, "INetConnectionUiLock::QueryLock was not called!");

    if(NULL != m_handles.m_hList)
    {
        ::EnableWindow(m_handles.m_hList, TRUE);
    }

    if(NULL != m_handles.m_hDescription)
    {
        ::EnableWindow(m_handles.m_hDescription, TRUE);
    }
    ::UpdateWindow(hwndParent);

    hr = m_pnc->Initialize(NULL);
    if (S_OK == hr)
    {
        AssertSz(m_pconn, "No connection object in dialog!");

        hr = HrQIAndSetProxyBlanket(m_pconn, &m_plan);
        if (SUCCEEDED(hr))
        {
            LANCON_INFO linfo;

            hr = m_plan->GetInfo(LCIF_ALL, &linfo);
            if (SUCCEEDED(hr))
            {
                // Release any old reference
                ReleaseObj(m_pnccAdapter);

                // This is already AddRef'd so no need to do it here
                hr = HrPnccFromGuid(m_pnc, linfo.guid, &m_pnccAdapter);
                if (S_OK != hr)
                {
                    #if DBG

                        WCHAR   achGuid[c_cchGuidWithTerm];
                        ::StringFromGUID2(linfo.guid, achGuid,c_cbGuidWithTerm);

                        TraceTag(ttidError, "LAN conection has no matching INetCfgComponent for the adapter !!!!!");
                        TraceTag(ttidError, "GUID = %S", achGuid);

                    #endif

                    if(S_FALSE == hr)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    }
                }
                else
                {
                    Assert(m_pnccAdapter);
                    HICON   hicon;

                    CheckDlgButton(IDC_CHK_ShowIcon, linfo.fShowIcon);
                    //::EnableWindow(GetDlgItem(IDC_CHK_ShowIcon), !m_fReadOnly);

                    hr = HrGetDeviceIcon(&hicon);
                    if (SUCCEEDED(hr))
                    {
                        SendDlgItemMessage(IDI_Device_Icon, STM_SETICON,
                                           reinterpret_cast<WPARAM>(hicon), 0);
                        ::ShowWindow(GetDlgItem(IDI_Device_Icon), SW_SHOW);

                        AssertSz(hr != S_FALSE, "Adapter not found!?!?");
                    }

                    // Ignore any failure getting the icon above.  The icon
                    // in the dialog is by default hidden.

                    ::UpdateWindow(hwndParent);
                    hr = InitializeExtendedUI();
                    // If the UI is readonly, let user know why the controls are
                    // disabled..
                    if (m_fNeedReboot)
                    {
                        Assert (m_fReadOnly);
                        NcMsgBox(_Module.GetResourceInstance(),
                                 m_hWnd,
                                 IDS_LAN_CAPTION,
                                 IDS_LANUI_NEEDS_REBOOT,
                                 MB_ICONINFORMATION | MB_OK);
                    }
                    else if (m_fAccessDenied)
                    {
                        Assert (m_fReadOnly);
                        NcMsgBox(_Module.GetResourceInstance(),
                                 m_hWnd,
                                 IDS_LAN_CAPTION,
                                 IDS_LANUI_ACCESS_DENIED,
                                 MB_ICONINFORMATION | MB_OK);
                    }
                    else if (m_fReadOnly)
                    {
                        NcMsgBox(_Module.GetResourceInstance(),
                                 m_hWnd,
                                 IDS_LAN_CAPTION,
                                 IDS_LANUI_READONLY,
                                 MB_ICONINFORMATION | MB_OK);
                    }

                }

                // Don't need the name anymore
                CoTaskMemFree(linfo.szwConnName);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        NETCON_PROPERTIES* pProps;

        hr = m_pconn->GetProperties(&pProps);
        if (SUCCEEDED(hr))
        {
            // We need to get the bind name and pnp id of this adapter
            // so we can collect the information needed by the data tip
            // we are about to create.
            //
            PWSTR pszDevNodeId = NULL;
            PWSTR pszBindName = NULL;
            (VOID) m_pnccAdapter->GetPnpDevNodeId (&pszDevNodeId);
            (VOID) m_pnccAdapter->GetBindName (&pszBindName);

            // Now we create a data tip for the adapter description.
            // This will display adapter specific information
            // like MAC address and physical location.
            //
            HWND hwndDataTip = NULL;
            CreateDeviceDataTip (m_hWnd, &hwndDataTip, IDC_EDT_Adapter,
                    pszDevNodeId, pszBindName);

            // Set the adapter description.
            SetDlgItemText(IDC_EDT_Adapter, pProps->pszwDeviceName);

            FreeNetconProperties(pProps);

            CoTaskMemFree (pszDevNodeId);
            CoTaskMemFree (pszBindName);
        }
    }

    ::UpdateWindow(hwndParent);

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnPaint
//
//  Purpose:    Handles the WM_PAINT message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanNetPage::OnPaint(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    if (!m_fInitComplete)
    {
        m_fInitComplete = TRUE;

        // Request the deferred init be processed.
        //
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        PostMessage(WM_DEFERREDINIT, 0, 0);
    }

    bHandled = FALSE;
    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanNetPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_handles.m_hAdd          = GetDlgItem(IDC_PSB_Add);
    m_handles.m_hRemove       = GetDlgItem(IDC_PSB_Remove);
    m_handles.m_hProperty     = GetDlgItem(IDC_PSB_Properties);
    m_handles.m_hDescription  = GetDlgItem(IDC_TXT_Desc);

    SetClassLongPtr(m_hWnd, GCLP_HCURSOR, NULL);
    SetClassLongPtr(GetParent(), GCLP_HCURSOR, NULL);

    // Initially disable all the controls
    //
    ::EnableWindow(m_handles.m_hAdd, FALSE);
    ::EnableWindow(m_handles.m_hRemove, FALSE);
    ::EnableWindow(m_handles.m_hProperty, FALSE);

    if(NULL != m_handles.m_hDescription)
    {
        ::EnableWindow(m_handles.m_hDescription, FALSE);
    }

    if (!FHasPermission(NCPERM_Statistics))
    {
        ::EnableWindow(GetDlgItem(IDC_CHK_ShowIcon), FALSE);
    }

    // If this is a readonly sheet, convert cancel to close.
    //
//  Bug 130602 - There should still be an OK button
//  if (m_fReadOnly)
//  {
//      ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
//      m_fNoCancel = TRUE;
//  }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanNetPage::OnContextMenu(UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam,
                           BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanNetPage::OnHelp( UINT uMsg,
                     WPARAM wParam,
                     LPARAM lParam,
                     BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
LRESULT CLanNetPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                               BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HICON hIcon;
    hIcon = reinterpret_cast<HICON>(SendDlgItemMessage(IDI_Device_Icon, STM_GETICON, 0, 0));
    if (hIcon)
    {
        DestroyIcon(hIcon);
    }

    UninitializeExtendedUI();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnSetCursor
//
//  Purpose:    Called in response to the WM_SETCURSOR message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Jan 1998
//
//  Notes:
//
LRESULT CLanNetPage::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    if (m_hPrevCurs)
    {
        if (LOWORD(lParam) == HTCLIENT)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        return TRUE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::RequestReboot
//
//  Purpose:    Request permission to reboot the machine from the user.  If
//              approved the reboot is performed
//
//  Arguments:
//
//  Returns:
//
//  Author:     scottbri   19 Aug 1998
//
//  Notes:
//
HRESULT CLanNetPage::HrRequestReboot()
{
    TraceFileFunc(ttidLanUi);

    HRESULT hr = S_FALSE;

    // A reboot is required. Ask the user if it is ok to reboot now
    //
    hr = HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                m_hWnd, IDS_LAN_CAPTION,
                                IDS_REBOOT_REQUIRED,
                                QUFR_PROMPT);

    if (S_OK == hr)
    {
        // User requested a reboot, note this for processing in OnApply
        // which is triggered by the message posted below
        //
        m_fRebootAlreadyRequested = TRUE;

        // Press the cancel button (changes have already been applied)
        // so the appropriate cleanup occurs.
        //
        ::PostMessage(GetParent(), PSM_PRESSBUTTON, (WPARAM)PSBTN_OK, 0);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnAddHelper
//
//  Purpose:    Handles the clicking of the Add button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanNetPage::OnAddHelper(HWND hwndLV)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    // $REVIEW(tongl 1/6/99): We can't let user do anything till this
    // is returned (Raid #258690)

    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_PSB_Add,
                                 IDC_PSB_Remove,
                                 IDC_PSB_Properties};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    // get window handle to propertysheet
    HWND hwndParent=GetParent();
    Assert(hwndParent);

    ::EnableWindow(::GetDlgItem(hwndParent, IDOK), FALSE);
    ::EnableWindow(::GetDlgItem(hwndParent, IDCANCEL), FALSE);

    // make sure user can't close the UI till we are done
    m_fNetcfgInUse = TRUE;

    EnableWindow(FALSE);

    hr = HrLvAdd(hwndLV, m_hWnd, m_pnc, m_pnccAdapter, &m_listBindingPaths);

    if( S_OK != hr )
    {
        // If HrLvAdd failed then the adapater was deleted by the CModifyContext::HrApplyIfOkOrCancel function
        // Now we have to recreate the adapter
        //
        HRESULT hrT;
        LANCON_INFO linfo;

        // Determine the GUID of the adapter
        //
        hrT = m_plan->GetInfo(LCIF_ALL, &linfo);
        if (SUCCEEDED(hrT))
        {

            // Release any old reference
            ReleaseObj(m_pnccAdapter);

            // Get the adpater matching the GUID
            //
            //
            hrT = HrPnccFromGuid(m_pnc, linfo.guid, &m_pnccAdapter);
            if(SUCCEEDED(hrT))
            {
                // Refresh the list view
                //
                hrT = HrRefreshAll(hwndLV, m_pnc, m_pnccAdapter, &m_listBindingPaths);
            }
        }

    }

    EnableWindow(TRUE);
    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
        m_fNoCancel = TRUE;
    }

    if (NETCFG_S_REBOOT == hr)
    {
        hr = HrRequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }
    else if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);

    ::EnableWindow(::GetDlgItem(hwndParent, IDOK), TRUE);

    if (!m_fNoCancel)
    {
        ::EnableWindow(::GetDlgItem(hwndParent, IDCANCEL), TRUE);
    }

    m_fNetcfgInUse = FALSE;

    TraceError("CLanNetPage::OnAdd", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnRemove
//
//  Purpose:    Handles the clicking of the Remove button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanNetPage::OnRemoveHelper(HWND hwndLV)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    // $REVIEW(tongl 1/6/99): We can't let user do anything till this
    // is returned (Raid #258690)

    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_PSB_Add,
                                 IDC_PSB_Remove,
                                 IDC_PSB_Properties};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    // get window handle to propertysheet
    HWND hwndParent=GetParent();
    Assert(hwndParent);

    ::EnableWindow(::GetDlgItem(hwndParent, IDOK), FALSE);
    ::EnableWindow(::GetDlgItem(hwndParent, IDCANCEL), FALSE);

    // make sure user can't close the UI till we are done
    m_fNetcfgInUse = TRUE;

    EnableWindow(FALSE);
    hr = HrLvRemove(hwndLV, m_hWnd, m_pnc, m_pnccAdapter,
                    &m_listBindingPaths);
    EnableWindow(TRUE);

    if (SUCCEEDED(hr) && (S_FALSE != hr))
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
        m_fNoCancel = TRUE;
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (NETCFG_S_REBOOT == hr)
    {
        HrRequestReboot();

        // The reboot request has been handled
        hr = S_OK;
    }

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);

    if (!m_fNoCancel)
    {
        ::EnableWindow(::GetDlgItem(hwndParent, IDCANCEL), TRUE);
    }

    ::EnableWindow(::GetDlgItem(hwndParent, IDOK), TRUE);

    m_fNetcfgInUse = FALSE;

    TraceError("CLanNetPage::OnRemove", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanNetPage::OnPropertiesHelper(HWND hwndLV)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;
    BOOL        bChanged;

    // $REVIEW(tongl 12/02/98): We can't let user do anything till this
    // is returned (Raid #258690)

    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_PSB_Add,
                                 IDC_PSB_Remove,
                                 IDC_PSB_Properties};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    // get window handle to propertysheet
    HWND hwndParent=GetParent();
    Assert(hwndParent);

    ::EnableWindow(::GetDlgItem(hwndParent, IDOK), FALSE);
    ::EnableWindow(::GetDlgItem(hwndParent, IDCANCEL), FALSE);

    // make sure user can't close the UI till we are done
    m_fNetcfgInUse = TRUE;

    hr = HrLvProperties(hwndLV, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths,
                        &bChanged);

    if ( bChanged )
    {
        // Change the Cancel Button to CLOSE (because we committed changes)
        //
        ::PostMessage(GetParent(), PSM_CANCELTOCLOSE, 0, 0L);
        m_fNoCancel = TRUE;

    }

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);

    ::EnableWindow(::GetDlgItem(hwndParent, IDOK), TRUE);

    if (!m_fNoCancel)
    {
        ::EnableWindow(::GetDlgItem(hwndParent, IDCANCEL), TRUE);
    }

    m_fNetcfgInUse = FALSE;

    TraceError("CLanNetPage::OnProperties", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnConfigure
//
//  Purpose:    Handles the clicking of the Configure button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Notes:
//
LRESULT CLanNetPage::OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                 BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr  = S_OK;

    BOOL bProceed = TRUE;
    if (m_fDirty)
    {
        bProceed = FALSE;
        LPWSTR szDisplayName;

        NETCON_PROPERTIES *pProps = NULL;
        HRESULT hrT = m_pconn->GetProperties(&pProps);
        if (SUCCEEDED(hrT))
        {
            szDisplayName = pProps->pszwName;
        }
        else
        {
            szDisplayName = const_cast<LPWSTR>(SzLoadIds(IDS_LAN_DEFAULT_CONN_NAME));
        }

        if (IDYES == ::MessageBox(m_hWnd, SzLoadIds(IDS_DIRTY_PROPERTIES), szDisplayName, MB_YESNO))
        {
            bProceed = TRUE;
        }

        if (SUCCEEDED(hrT))
        {
            FreeNetconProperties(pProps);
        }

    }

    if (bProceed)
    {
        hr = RaiseDeviceConfiguration(m_hWnd, m_pnccAdapter);
        PostQuitMessage(0);
    }

    TraceError("CLanNetPage::OnConfigure", hr);
    return LresFromHr(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnKillActiveHelper
//
//  Purpose:    Called to check warning conditions before the Networking
//              page is going away
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     tongl   3 Dec 1998
//
//  Notes:
//
LRESULT CLanNetPage::OnKillActiveHelper(HWND hwndLV)
{
    TraceFileFunc(ttidLanUi);

    BOOL    fError;

    fError = m_fNetcfgInUse;

    if (!fError && !m_fReadOnly && !m_fLockDown)
    {
        fError = FValidatePageContents( m_hWnd,
                                        hwndLV,
                                        m_pnc,
                                        m_pnccAdapter,
                                        &m_listBindingPaths);
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanNetPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    if (g_fReentrancyCheck)
    {
        TraceTag(ttidLanUi, "CLanNetPage::OnApply is being re-entered! "
                 "I'm outta here!");

        // Don't allow the automatic EndDialog() to work just yet
        SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
        return TRUE;
    }

    if (!m_fReadOnly)
    {
        m_hPrevCurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

        BOOL    fReboot = FALSE;

        // Issue: This function becomes reentrant because INetCfg::Apply()
        // has a message pump in it which causes the PSN_APPLY message to
        // be processed twice. This will happen ONLY if the user double-clicks
        // the OK button.
        g_fReentrancyCheck = TRUE;

        TraceTag(ttidLanUi, "Calling INetCfg::Apply()");
        hr = m_pnc->Apply();
        if (NETCFG_S_REBOOT == hr)
        {
            fReboot = TRUE;
        }

        if (SUCCEEDED(hr))
        {
            TraceTag(ttidLanUi, "INetCfg::Apply() succeeded");
            hr = m_pnc->Uninitialize();
        }

        if (SUCCEEDED(hr))
        {
            if (m_fRebootAlreadyRequested || fReboot)
            {
                DWORD dwFlags = QUFR_REBOOT;
                if (!m_fRebootAlreadyRequested)
                    dwFlags |= QUFR_PROMPT;

                (VOID) HrNcQueryUserForReboot(_Module.GetResourceInstance(),
                                              m_hWnd, IDS_LAN_CAPTION,
                                              IDS_REBOOT_REQUIRED,
                                              dwFlags);
            }
        }

        // Normalize result
        if (S_FALSE == hr)
        {
            hr = S_OK;
        }

        if (m_hPrevCurs)
        {
            SetCursor(m_hPrevCurs);
            m_hPrevCurs = NULL;
        }

        // Reset this just in case
        g_fReentrancyCheck = FALSE;

        // On failure tell the user we weren't able to commit all changes
        //
        if (FAILED(hr))
        {
            NcMsgBox(_Module.GetResourceInstance(), m_hWnd, IDS_LAN_CAPTION,
                        IDS_LANUI_APPLYFAILED, MB_ICONINFORMATION | MB_OK);
            TraceError("CLanNetPage::OnApply", hr);

            // Eat the error or the user will never be able to leave the dialog
            // (if the cancel button is disabled)
            //
            hr = S_OK;
        }
    }   // !fReadOnly


    // Apply "general" properties
    if (SUCCEEDED(hr))
    {
        LANCON_INFO linfo = {0};

        linfo.fShowIcon = IsDlgButtonChecked(IDC_CHK_ShowIcon);

        // Set new value of show icon property
        hr = m_plan->SetInfo(LCIF_ICON, &linfo);
    }

    m_fDirty = FALSE;

    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Jan 1998
//
//  Notes:      Added the check to see if we are in the middle of
//              installing components, in which case we can't
//              uninitialize INetCfg (Raid #258690).
//
LRESULT CLanNetPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    AssertSz(m_pnc, "I need a NetCfg object!");

    if (!m_fNetcfgInUse)
    {
        (VOID) m_pnc->Uninitialize();
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, m_fNetcfgInUse);
    return m_fNetcfgInUse;
}

DWORD WINAPI RaiseDeviceConfigurationThread(LPVOID lpParam)
{
    const char c_szDevicePropertiesW[]      = "DevicePropertiesW";
    const WCHAR c_szDevMgrDll[]             = L"devmgr.dll";

    PWSTR pszwPnpDevNodeId = reinterpret_cast<PWSTR>(lpParam);
    Assert(pszwPnpDevNodeId);

    typedef int (STDAPICALLTYPE* NDeviceProperties)(HWND, PCWSTR,
            PCWSTR, BOOL);

    HMODULE           hModule;
    NDeviceProperties pfn;

    // Load the Device Manager and get the procedure
    HRESULT hr = HrLoadLibAndGetProc(c_szDevMgrDll, c_szDevicePropertiesW,
                             &hModule, reinterpret_cast<FARPROC*>(&pfn));
    if (SUCCEEDED(hr))
    {
        // Bring up the device's properties...
        // This fcn doesn't return anything meaningful so
        // we can ignore it

        (void) (*pfn)(::GetDesktopWindow(), NULL, pszwPnpDevNodeId, FALSE);

        FreeLibrary(hModule); // REVIEW possible uninit var
    }

    CoTaskMemFree(pszwPnpDevNodeId);

    return hr;
}

#define COMCTL_IDS_PROPERTIESFOR 0x1042
HRESULT CLanNetPage::RaiseDeviceConfiguration(HWND hWndParent, INetCfgComponent* pAdapterConfigComponent)
{
    TraceFileFunc(ttidLanUi);

    HRESULT hr = E_INVALIDARG;

    // Get the PnpId of the adapter
    if (pAdapterConfigComponent)
    {
        PWSTR pszwPnpDevNodeId;
        hr = pAdapterConfigComponent->GetPnpDevNodeId(&pszwPnpDevNodeId);
        if (SUCCEEDED(hr))
        {
            WCHAR szWindowTitle[MAX_PATH];
            ZeroMemory(szWindowTitle, MAX_PATH);

            PWSTR pszwDisplayName;
            HRESULT hrT = pAdapterConfigComponent->GetDisplayName(&pszwDisplayName);

            if (SUCCEEDED(hrT))
            {
                HMODULE hComCtl32 = GetModuleHandle(L"comctl32.dll");
                if (hComCtl32)
                {
                    WCHAR szPropertiesFor[MAX_PATH];
                    if (LoadString(hComCtl32, COMCTL_IDS_PROPERTIESFOR, szPropertiesFor, MAX_PATH))
                    {
                        wsprintf(szWindowTitle, szPropertiesFor, pszwDisplayName);
                    }
                }
            }

            if (*szWindowTitle)
            {
                HWND hWndDevNode = FindWindow(NULL, szWindowTitle);
                if (hWndDevNode && IsWindow(hWndDevNode))
                {
                    SetForegroundWindow(hWndDevNode);
                }
                else
                {
                    CreateThread(NULL, STACK_SIZE_TINY, RaiseDeviceConfigurationThread, pszwPnpDevNodeId, 0, NULL);

                    DWORD dwTries = 120;
                    while (!FindWindow(NULL, szWindowTitle) && dwTries--)
                    {
                        Sleep(500);
                    }
                    CoTaskMemFree(pszwDisplayName);
                }
            }
            else
            {
                CreateThread(NULL, STACK_SIZE_TINY, RaiseDeviceConfigurationThread, pszwPnpDevNodeId, 0, NULL);
            }
        }
    }

    return hr;
}

//
// CLanNetNormalPage
//

CLanNetNormalPage::CLanNetNormalPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    BOOLEAN fReadOnly,
    BOOLEAN fNeedReboot,
    BOOLEAN fAccessDenied,
    const DWORD * adwHelpIDs) : CLanNetPage(punk, pnc, pconn, fReadOnly, fNeedReboot, fAccessDenied, adwHelpIDs)
{
    TraceFileFunc(ttidLanUi);
}

LRESULT CLanNetNormalPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_handles.m_hList = m_hwndLV = GetDlgItem(IDC_LVW_Net_Components);
   ::EnableWindow(m_hwndLV, FALSE);

    return CLanNetPage::OnInitDialog(uMsg, wParam, lParam, bHandled);
}

LRESULT CLanNetNormalPage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_fDirty = TRUE;

    return OnAddHelper(m_hwndLV);
}

LRESULT CLanNetNormalPage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_fDirty = TRUE;

    return OnRemoveHelper(m_hwndLV);
}

LRESULT CLanNetNormalPage::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_fDirty = TRUE;

    return OnPropertiesHelper(m_hwndLV);
}

LRESULT CLanNetNormalPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return OnKillActiveHelper(m_hwndLV);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnDeleteItem
//
//  Purpose:    Called when the LVN_DELETEITEM message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
LRESULT CLanNetNormalPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(IDC_LVW_Net_Components == idCtrl);
    LvDeleteItem(m_hwndLV, pnmlv->iItem);

    m_fDirty = TRUE;

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CLanNetNormalPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                m_pnccAdapter, &m_listBindingPaths, FALSE, m_fReadOnly);

    m_fDirty = TRUE;

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnDbClick
//
//  Purpose:    Called in response to the NM_DBLCLK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CLanNetNormalPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
                m_pnccAdapter, &m_listBindingPaths, TRUE, m_fReadOnly);

    m_fDirty = TRUE;

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnKeyDown
//
//  Purpose:    Called in response to the LVN_KEYDOWN message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     danielwe   1 Dec 1997
//
//  Notes:
//
LRESULT CLanNetNormalPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if (!m_fReadOnly)
    {
        LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
        OnListKeyDown(m_hwndLV, &m_listBindingPaths, plvkd->wVKey);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetPage::OnItemChanged
//
//  Purpose:    Called when the LVN_ITEMCHANGED message is received
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   10 Nov 1997
//
//  Notes:
//
LRESULT CLanNetNormalPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(pnmlv);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);

    return 0;
}


HRESULT CLanNetNormalPage::InitializeExtendedUI()
{
    TraceFileFunc(ttidLanUi);

    HRESULT hResult = HrInitListView(m_hwndLV, m_pnc, m_pnccAdapter,
        &m_listBindingPaths,
        &m_hilCheckIcons);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);

    return hResult;

}

HRESULT CLanNetNormalPage::UninitializeExtendedUI()
{
    TraceFileFunc(ttidLanUi);

    UninitListView(m_hwndLV);
    return S_OK;
}

//
// CLanNetBridgedPage
//

CLanNetBridgedPage::CLanNetBridgedPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    BOOLEAN fReadOnly,
    BOOLEAN fNeedReboot,
    BOOLEAN fAccessDenied,
    const DWORD * adwHelpIDs) : CLanNetPage(punk, pnc, pconn, fReadOnly, fNeedReboot, fAccessDenied, adwHelpIDs)
{
    TraceFileFunc(ttidLanUi);
}

LRESULT CLanNetBridgedPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_handles.m_hList = NULL;
    return CLanNetPage::OnInitDialog(uMsg, wParam, lParam, bHandled);
}

//
// CLanNetNetworkBridgePage
//

CLanNetNetworkBridgePage::CLanNetNetworkBridgePage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    BOOLEAN fReadOnly,
    BOOLEAN fNeedReboot,
    BOOLEAN fAccessDenied,
    const DWORD * adwHelpIDs) : CLanNetPage(punk, pnc, pconn, fReadOnly, fNeedReboot, fAccessDenied, adwHelpIDs)
{
    TraceFileFunc(ttidLanUi);

    m_hAdaptersListView = NULL;
    m_hAdaptersListImageList = NULL;

}


LRESULT CLanNetNetworkBridgePage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_handles.m_hList = m_hwndLV = GetDlgItem(IDC_LVW_Net_Components);
    m_hAdaptersListView = GetDlgItem(IDC_LVW_Bridged_Adapters);
   ::EnableWindow(m_hwndLV, FALSE);
    return CLanNetPage::OnInitDialog(uMsg, wParam, lParam, bHandled);
}

LRESULT CLanNetNetworkBridgePage::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return OnAddHelper(m_hwndLV);
}

LRESULT CLanNetNetworkBridgePage::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return OnRemoveHelper(m_hwndLV);
}

LRESULT CLanNetNetworkBridgePage::OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return OnPropertiesHelper(m_hwndLV);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanNetNetworkBridgePage::OnConfigure
//
//  Purpose:    Handles the clicking of the Configure button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Notes:
//
LRESULT CLanNetNetworkBridgePage::OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                 BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    m_fDirty = TRUE;

    HRESULT     hr = E_FAIL;

    AssertSz(1 == ListView_GetSelectedCount(m_hAdaptersListView), "No item selected, button should have been disabled"); // should be enforced through enable/disable

    int nSelection = ListView_GetSelectionMark(m_hAdaptersListView);
    if(-1 != nSelection)
    {
        LVITEM ListViewItem = {0};
        ListViewItem.stateMask = -1;
        ListViewItem.mask = LVIF_STATE | LVIF_PARAM | LVIF_IMAGE;
        ListViewItem.iItem = nSelection;
        if(TRUE == ListView_GetItem(m_hAdaptersListView, &ListViewItem))
        {
            // REVIEW this ref should be protected by the apt nature of the wndproc
            INetConnection* pNetConnection = reinterpret_cast<INetConnection*>(ListViewItem.lParam);
            Assert(NULL != pNetConnection);

            INetLanConnection* pNetLanConnection;
            hr = HrQIAndSetProxyBlanket(pNetConnection, &pNetLanConnection);
            if (SUCCEEDED(hr))
            {
                LANCON_INFO linfo;
                hr = pNetLanConnection->GetInfo(LCIF_COMP, &linfo);
                if (SUCCEEDED(hr))
                {
                    INetCfgComponent* pNetCfgComponent;
                    hr = HrPnccFromGuid(m_pnc, linfo.guid, &pNetCfgComponent); // REVIEW can we use our m_pnc here?
                    if(SUCCEEDED(hr))
                    {
                        BOOL bProceed = TRUE;
                        if (m_fDirty)
                        {
                            bProceed = FALSE;
                            LPWSTR szDisplayName;

                            NETCON_PROPERTIES *pProps = NULL;
                            HRESULT hrT = m_pconn->GetProperties(&pProps);
                            if (SUCCEEDED(hrT))
                            {
                                szDisplayName = pProps->pszwName;
                            }
                            else
                            {
                                szDisplayName = const_cast<LPWSTR>(SzLoadIds(IDS_LAN_DEFAULT_CONN_NAME));
                            }

                            if (IDYES == ::MessageBox(m_hWnd, SzLoadIds(IDS_DIRTY_PROPERTIES), szDisplayName, MB_YESNO))
                            {
                                bProceed = TRUE;
                            }

                            if (SUCCEEDED(hrT))
                            {
                                FreeNetconProperties(pProps);
                            }

                        }

                        if (bProceed)
                        {
                            hr = RaiseDeviceConfiguration(m_hWnd, pNetCfgComponent);
                            PostQuitMessage(0);
                        }

                        ReleaseObj(pNetCfgComponent);
                    }
                    // no cleanup required
                }
                ReleaseObj(pNetLanConnection);
            }

        }
    }


    TraceError("CLanNetPage::OnConfigure", hr);
    return LresFromHr(hr);
}
LRESULT CLanNetNetworkBridgePage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return OnKillActiveHelper(m_hwndLV);
}

LRESULT CLanNetNetworkBridgePage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    LRESULT     lResult = FALSE;
    WCHAR DummyBuffer[255]; // REMOVE

    LVITEM ListViewItem = {0};
    ListViewItem.pszText = DummyBuffer; // REMOVE
    ListViewItem.cchTextMax = 255; // REMOVE
    ListViewItem.stateMask = -1;
    ListViewItem.mask = LVIF_TEXT /* REMOVE */ | LVIF_STATE | LVIF_PARAM | LVIF_IMAGE;

    HRESULT hr;


    IHNetCfgMgr* pHomeNetConfigManager;
    hr = HrCreateInstance(CLSID_HNetCfgMgr, CLSCTX_INPROC, &pHomeNetConfigManager);
    if(SUCCEEDED(hr))
    {
        IHNetConnection* pBridgeHomeNetConnection;
        IHNetBridge* pNetBridge;
        hr = pHomeNetConfigManager->GetIHNetConnectionForINetConnection(m_pconn, &pBridgeHomeNetConnection); // REVIEW lazy eval?
        if(SUCCEEDED(hr))
        {
            hr = pBridgeHomeNetConnection->GetControlInterface(IID_IHNetBridge, reinterpret_cast<void**>(&pNetBridge));
            if(SUCCEEDED(hr))
            {
                int nAdapterCount = ListView_GetItemCount(m_hAdaptersListView); // REVIEW docs list no error code
                while(0 != nAdapterCount)
                {
                    nAdapterCount--;
                    ListViewItem.iItem = nAdapterCount;
                    if(TRUE == ListView_GetItem(m_hAdaptersListView, &ListViewItem))
                    {
                        NETCON_PROPERTIES* pProperties;
                        INetConnection* pNetConnection = reinterpret_cast<INetConnection*>(ListViewItem.lParam);
                        
                        int nState = LVIS_STATEIMAGEMASK & ListViewItem.state;
                        hr = pNetConnection->GetProperties(&pProperties);
                        if(SUCCEEDED(hr))
                        {
                            // WARNING this code assumes only one bridge allowed
                            // see if checkbox matches the current bridge state and update if necessary
                            
                            IHNetConnection* pHomeNetConnection;
                            
                            if(INDEXTOSTATEIMAGEMASK(SELS_CHECKED) == nState)
                            {
                                if(!(NCCF_BRIDGED & pProperties->dwCharacter))
                                {
                                    
                                    hr = pHomeNetConfigManager->GetIHNetConnectionForINetConnection(pNetConnection, &pHomeNetConnection);
                                    if(SUCCEEDED(hr))
                                    {
                                        IHNetBridgedConnection* pBridgedConnection;
                                        hr = pNetBridge->AddMember(pHomeNetConnection, &pBridgedConnection, m_pnc); // REVIEW if we fail to add any members, should we destroy the bridge?
                                        if(SUCCEEDED(hr))
                                        {
                                            ReleaseObj(pBridgedConnection);
                                        }
                                        ReleaseObj(pHomeNetConnection);
                                    }
                                    // no cleanup needed
                                }
                                // no cleanup needed
                            }
                            else if(INDEXTOSTATEIMAGEMASK(SELS_UNCHECKED) == nState)
                            {
                                if(NCCF_BRIDGED & pProperties->dwCharacter)
                                {
                                    hr = pHomeNetConfigManager->GetIHNetConnectionForINetConnection(pNetConnection, &pHomeNetConnection);
                                    if(SUCCEEDED(hr))
                                    {
                                        IHNetBridgedConnection* pBridgedConnection;
                                        hr = pHomeNetConnection->GetControlInterface(IID_IHNetBridgedConnection, reinterpret_cast<void**>(&pBridgedConnection));
                                        if(SUCCEEDED(hr))
                                        {
                                            pBridgedConnection->RemoveFromBridge(m_pnc);
                                        }
                                        ReleaseObj(pHomeNetConnection);
                                    }
                                    //no cleanup needed
                                }
                                // no cleanup needed
                            }
                            else
                            {
                                AssertSz(FALSE, "Bad state");
                            }
                            FreeNetconProperties(pProperties);
                        }
                        // no cleanup needed
                    }
                    else
                    {
                        hr = E_FAIL; // error code coversion
                    }
                    //no cleanup needed
                }
                
                
                ReleaseObj(pNetBridge);
            }
            ReleaseObj(pBridgeHomeNetConnection);
        }
        ReleaseObj(pHomeNetConfigManager);
    }
    else
    {
        hr = S_OK; // fail silently in this case
    }
    
    if(SUCCEEDED(hr))
    {
        if( PSNRET_NOERROR != CLanNetPage::OnApply(idCtrl, pnmh, bHandled) )
        {
            hr = E_FAIL;
        }
        else
        {
            //
            // Since we have done bridge binding operations inside an existing NetCfg context
            // (m_pnc), it is our responsibility to refresh netshell. Fire a refresh-all.
            //
            INetConnectionRefresh   *pNetConRefresh;
            
            hr = CoCreateInstance(
                CLSID_ConnectionManager,
                NULL,
                CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetConnectionRefresh, reinterpret_cast<void **>(&pNetConRefresh)
                );
            
            if( SUCCEEDED(hr) )
            {
                pNetConRefresh->RefreshAll();
                pNetConRefresh->Release();
            }
        }
    }

    m_fDirty = FALSE;

    lResult = LresFromHr(hr);

    return lResult;
}
LRESULT CLanNetNetworkBridgePage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    if(IDC_LVW_Net_Components == idCtrl)
    {
        LvDeleteItem(m_hwndLV, pnmlv->iItem);
    }
    else
    {
        Assert(IDC_LVW_Bridged_Adapters == idCtrl);
        Assert(NULL != pnmlv->lParam);
        ReleaseObj(reinterpret_cast<INetConnection*>(pnmlv->lParam));
    }

    m_fDirty = TRUE;


    return 0;
}

LRESULT CLanNetNetworkBridgePage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    m_fDirty = TRUE;

    if(IDC_LVW_Net_Components == idCtrl)
    {
        OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
            m_pnccAdapter, &m_listBindingPaths, FALSE, m_fReadOnly);
    }
    else
    {
        Assert(idCtrl == IDC_LVW_Bridged_Adapters);

        if(FALSE == m_fReadOnly)
        {
            DWORD dwpts = GetMessagePos();

            LV_HITTESTINFO lvhti;
            lvhti.pt.x = LOWORD( dwpts );
            lvhti.pt.y = HIWORD( dwpts );
            ::MapWindowPoints(NULL , m_hAdaptersListView , (LPPOINT) &(lvhti.pt) , 1);

            int iItem = ListView_HitTest( m_hAdaptersListView, &lvhti );

            if (-1 != iItem && LVHT_ONITEMSTATEICON & lvhti.flags)
            {
                LV_ITEM lvItem;
                lvItem.iItem = iItem;
                lvItem.iSubItem = 0;
                lvItem.mask = LVIF_STATE;
                lvItem.stateMask = LVIS_STATEIMAGEMASK;

                if(ListView_GetItem(m_hAdaptersListView, &lvItem))
                {
                    if(INDEXTOSTATEIMAGEMASK(SELS_CHECKED) == lvItem.state)
                    {
                        lvItem.state = INDEXTOSTATEIMAGEMASK(SELS_UNCHECKED);

                    }
                    else
                    {
                        lvItem.state = INDEXTOSTATEIMAGEMASK(SELS_CHECKED);

                    }
                    ListView_SetItem(m_hAdaptersListView, &lvItem);
                }
            }
        }

        HWND hConfigureButton = GetDlgItem(IDC_PSB_Configure);
        Assert(NULL != hConfigureButton);
        ::EnableWindow(hConfigureButton, ListView_GetSelectedCount(m_hAdaptersListView) ? TRUE : FALSE);

    }
    return 0;
}

LRESULT CLanNetNetworkBridgePage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if(IDC_LVW_Net_Components == idCtrl)
    {
        OnListClick(m_hwndLV, m_hWnd, m_pnc, m_punk,
            m_pnccAdapter, &m_listBindingPaths, TRUE, m_fReadOnly);
    }

    m_fDirty = TRUE;

    return 0;
}

LRESULT CLanNetNetworkBridgePage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if (!m_fReadOnly)
    {
        LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
        if(IDC_LVW_Net_Components == idCtrl)
        {
            OnListKeyDown(m_hwndLV, &m_listBindingPaths, plvkd->wVKey);
        }
        else
        {
            Assert(IDC_LVW_Bridged_Adapters == idCtrl);


            if ((VK_SPACE == plvkd->wVKey) && (GetAsyncKeyState(VK_MENU)>=0))
            {
                int iItem = ListView_GetSelectionMark(m_hAdaptersListView);
                if(-1 != iItem)
                {

                    LV_ITEM lvItem;
                    lvItem.iItem = iItem;
                    lvItem.iSubItem = 0;
                    lvItem.mask = LVIF_STATE;
                    lvItem.stateMask = LVIS_STATEIMAGEMASK;

                    if(ListView_GetItem(m_hAdaptersListView, &lvItem))
                    {
                        if(INDEXTOSTATEIMAGEMASK(SELS_CHECKED) == lvItem.state)
                        {
                            lvItem.state = INDEXTOSTATEIMAGEMASK(SELS_UNCHECKED);

                        }
                        else
                        {
                            lvItem.state = INDEXTOSTATEIMAGEMASK(SELS_CHECKED);

                        }
                        ListView_SetItem(m_hAdaptersListView, &lvItem);
                    }
                }
            }
        }
    }
    return 0;
}

LRESULT CLanNetNetworkBridgePage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);

    Assert(pnmlv);

    // Reset the buttons and the description text based on the changed selection
    if(IDC_LVW_Net_Components == idCtrl)
    {
        LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);
    }

    return 0;
}

HRESULT CLanNetNetworkBridgePage::InitializeExtendedUI()
{
    TraceFileFunc(ttidLanUi);

    HRESULT hResult = HrInitListView(m_hwndLV, m_pnc, m_pnccAdapter,
        &m_listBindingPaths,
        &m_hilCheckIcons);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_handles, m_fReadOnly, m_punk);

    Assert(NULL != m_hAdaptersListView);
    SP_CLASSIMAGELIST_DATA* pcild = reinterpret_cast<SP_CLASSIMAGELIST_DATA *>(::GetWindowLongPtr(::GetParent(m_hAdaptersListView), GWLP_USERDATA));
    Assert(NULL != pcild);

    HrInitCheckboxListView(m_hAdaptersListView, &m_hAdaptersListImageList, pcild);
    hResult = FillListViewWithConnections(m_hAdaptersListView);

    return hResult;
}

HRESULT CLanNetNetworkBridgePage::UninitializeExtendedUI()
{
    TraceFileFunc(ttidLanUi);

    UninitListView(m_hwndLV);
    ListView_DeleteAllItems(m_hAdaptersListView);
    ImageList_Destroy(m_hAdaptersListImageList);
    return S_OK;
}

HRESULT CLanNetNetworkBridgePage::FillListViewWithConnections(HWND hListView)
{
    TraceFileFunc(ttidLanUi);

    HRESULT hResult;
    INetConnectionManager* pLanConnectionManager;

    hResult = HrCreateInstance(CLSID_LanConnectionManager, CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, &pLanConnectionManager);
    if (SUCCEEDED(hResult))
    {
        CIterNetCon NetConnectionIterator(pLanConnectionManager, NCME_DEFAULT);

        INetConnection* pConnection;
        int i = 0;
        while (S_OK == NetConnectionIterator.HrNext(&pConnection))
        {
            NcSetProxyBlanket(pConnection);

            NETCON_PROPERTIES* pProperties;
            hResult = pConnection->GetProperties(&pProperties);
            if(SUCCEEDED(hResult))
            {
                if(NCM_LAN == pProperties->MediaType) // we only bridge lan connections
                {
                    if(0 == ((NCCF_FIREWALLED | NCCF_SHARED) & pProperties->dwCharacter))
                    {
                        SP_CLASSIMAGELIST_DATA *    pcild;
                        INT nIndex = 0;
                        pcild = reinterpret_cast<SP_CLASSIMAGELIST_DATA *>(::GetWindowLongPtr(::GetParent(m_hAdaptersListView), GWLP_USERDATA));
                        Assert(pcild);

                        (VOID) HrSetupDiGetClassImageIndex(pcild, &GUID_DEVCLASS_NETCLIENT, &nIndex);

                        LV_ITEM     lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM | LVIF_IMAGE;
                        lvi.state = LVIS_SELECTED | LVIS_FOCUSED;

                        // WARNING assuming only one bridge
                        lvi.state |=  INDEXTOSTATEIMAGEMASK(pProperties->dwCharacter & NCCF_BRIDGED ? SELS_CHECKED : SELS_UNCHECKED);
                        lvi.iImage = nIndex;
                        lvi.pszText = pProperties->pszwName;
                        lvi.cchTextMax = lstrlen(pProperties->pszwName);
                        lvi.lParam = reinterpret_cast<LPARAM>(pConnection);
                        lvi.iItem = i++;
                        ListView_InsertItem(hListView, &lvi);
                    }
                }
                FreeNetconProperties(pProperties);
            }
            //Released by WM_DELETEITEM
        }
        ReleaseObj(pLanConnectionManager);
    }
    return hResult;
}

//
// CLanAdvancedPage
//

//+---------------------------------------------------------------------------
//
//  Function:   HrQueryLanAdvancedPage
//
//  Purpose:    Determines whether the 'Shared Access' page should be shown,
//              and if so supplies an initialized object for the page.
//              The page is displayed if
//              (a)  the user is an admin or power-user, and
//              (b)  TCP/IP is installed, and
//                   (i)    this is already a shared connection, or
//                  (ii)    there is at least one other LAN connection.
//
//  Arguments:
//      pconn   [in]    the connection for which a page is requested
//      pspAdvanced[out]   the created page, if appropriate
//
//  Returns:    S_OK if success, Win32 error otherwise
//
//  Author:     aboladeg   22 Aug 1998
//
//  Notes:
//
HRESULT HrQueryLanAdvancedPage(INetConnection* pconn, IUnknown* punk,
                            CPropSheetPage*& pspAdvanced, IHNetCfgMgr *pHNetCfgMgr,
                            IHNetIcsSettings *pHNetIcsSettings,
                            IHNetConnection *pHNetConn)
{
    HRESULT hr = S_OK;

    TraceFileFunc(ttidLanUi);

    pspAdvanced = NULL;

    BOOL fShared = FALSE;
    BOOL fAnyShared = FALSE;
    HNET_CONN_PROPERTIES *pHNetProps;
    IHNetConnection **rgPrivateCons;
    ULONG cPrivate;
    LONG lxCurrentPrivate;

    //
    // (i) Determine if this connection is currently shared
    //

    hr = pHNetConn->GetProperties(&pHNetProps);
    if (FAILED(hr))
    {
        return hr;
    }

    if(FALSE == pHNetProps->fPartOfBridge && FALSE == pHNetProps->fBridge) // no sharing a bridged adapter or the bridge
    {


        fShared = pHNetProps->fIcsPublic;


        // (ii) Determine what connections could serve as a private connection
        //      if pconn were made the public connection
        //
        hr = pHNetIcsSettings->GetPossiblePrivateConnections(
            pHNetConn,
            &cPrivate,
            &rgPrivateCons,
            &lxCurrentPrivate
            );

        if (SUCCEEDED(hr))
        {
            pspAdvanced = new CLanAdvancedPage(punk, pconn, fShared, pHNetProps->fIcsPrivate, pHNetProps->fFirewalled, rgPrivateCons,
                cPrivate, lxCurrentPrivate,
                g_aHelpIDs_IDD_LAN_ADVANCED,
                pHNetConn, pHNetCfgMgr, pHNetIcsSettings);
        }

    }

    CoTaskMemFree(pHNetProps);
    return S_OK;
}

CLanAdvancedPage::CLanAdvancedPage(IUnknown *punk, INetConnection *pconn,
                  BOOL fShared, BOOL fICSPrivate, BOOL fFirewalled, IHNetConnection **rgPrivateCons,
                  ULONG cPrivate, LONG lxCurrentPrivate,
                  const DWORD * adwHelpIDs, IHNetConnection *pHNConn,
                  IHNetCfgMgr *pHNetCfgMgr, IHNetIcsSettings *pHNetIcsSettings)
{
    TraceFileFunc(ttidLanUi);

    m_pconn = pconn;
    m_punk = punk;
    m_fShared = fShared;
    m_fICSPrivate = fICSPrivate;
    m_fFirewalled = fFirewalled;
    m_fOtherShared = FALSE;
    m_pOldSharedConnection = NULL;
    m_fResetPrivateAdapter = fShared && -1 == lxCurrentPrivate;
    m_rgPrivateCons = rgPrivateCons;
    m_cPrivate = cPrivate;
    m_lxCurrentPrivate = lxCurrentPrivate;
    m_adwHelpIDs = adwHelpIDs;
    m_pHNetCfgMgr = pHNetCfgMgr;
    AddRefObj(m_pHNetCfgMgr);
    m_pHNetIcsSettings = pHNetIcsSettings;
    AddRefObj(m_pHNetIcsSettings);
    m_pHNetConn = pHNConn;
    AddRefObj(m_pHNetConn);
    LinkWindow_RegisterClass(); // REVIEW failure here?

}

CLanAdvancedPage::~CLanAdvancedPage()
{
    TraceFileFunc(ttidLanUi);

    if (m_rgPrivateCons)
    {
        for (ULONG i = 0; i < m_cPrivate; i++)
        {
            ReleaseObj(m_rgPrivateCons[i]);
        }

        CoTaskMemFree(m_rgPrivateCons);
    }
    ReleaseObj(m_pHNetCfgMgr);
    ReleaseObj(m_pHNetIcsSettings);
    ReleaseObj(m_pHNetConn);
    ReleaseObj(m_pOldSharedConnection);
    LinkWindow_UnregisterClass(_Module.GetResourceInstance());

}

// util function used below
static BOOL IsConnectionIncomingOnly (INetConnection * pNC)
{
    // Kludge Alert!!!!
    // this #@$% camera doesn't have the right characteristics,
    // so I'm checking by device name
    BOOL b = FALSE;

    DWORD dwCharacteristics = 0;
    NETCON_PROPERTIES * pProps = NULL;
    HRESULT hr = pNC->GetProperties (&pProps);
    if (pProps) {
        dwCharacteristics = pProps->dwCharacter;
        if (!wcscmp (pProps->pszwDeviceName, L"Microsoft TV/Video Connection"))
            b = TRUE;
        NcFreeNetconProperties (pProps);
    }
    if (b)
        return TRUE;
    return (dwCharacteristics & NCCF_INCOMING_ONLY) ? TRUE : FALSE;
}
//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     aboladeg   14 May 1998
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    LPWSTR pszw;
    HRESULT hr;


    // init firewall section


    if ( IsHNetAllowed(NCPERM_PersonalFirewallConfig) && FALSE == m_fICSPrivate )
    {
        CheckDlgButton(IDC_CHK_Firewall, m_fFirewalled);

        m_fShowDisableFirewallWarning = TRUE; // TODO check registry

        HKEY hFirewallKey;
        if(SUCCEEDED(HrRegOpenKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, KEY_QUERY_VALUE, &hFirewallKey)))
        {
            DWORD dwValue;
            DWORD dwType;
            DWORD dwSize = sizeof(dwValue);
            if(ERROR_SUCCESS == RegQueryValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, NULL, &dwType, reinterpret_cast<BYTE*>(&dwValue), &dwSize))
            {
                if(REG_DWORD == dwType && TRUE == dwValue)
                {
                    m_fShowDisableFirewallWarning = FALSE;
                }
            }
            RegCloseKey(hFirewallKey);
        }

    }
    else
    {
        ::EnableWindow(GetDlgItem(IDC_CHK_Firewall), FALSE);
    }

    // The appearance of the dialog depends on how many LAN connections
    // we have other than the current one. If we have only one,
    // then we just show a checkbox. Otherwise, we display
    // (a)  a drop-list of LAN connections if 'm_pconn' is not shared, or
    // (b)  a disabled edit-box showing the private LAN connection
    //      if 'm_pconn' is shared.
    //

    BOOL fPolicyAllowsSharing = IsHNetAllowed(NCPERM_ShowSharedAccessUi);

    if (m_cPrivate == 0)
    {
        // if the have no private adapters, hide all ICS stuff
        ::ShowWindow(GetDlgItem(IDC_GB_Shared), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_CHK_Shared), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_CHK_BeaconControl), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_ST_ICSLINK), SW_HIDE);
    }
    else if (IsConnectionIncomingOnly (m_pconn)) {
        // bug 281820:  disable group box if NCCF_INCOMING_ONLY bit is set
        m_fShared = FALSE;
        ::EnableWindow(GetDlgItem(IDC_GB_Shared), FALSE);
        ::ShowWindow  (GetDlgItem(IDC_GB_Shared), SW_HIDE);
        ::EnableWindow(GetDlgItem(IDC_CHK_Shared), FALSE);
        ::ShowWindow  (GetDlgItem(IDC_CHK_Shared), SW_HIDE);
        ::EnableWindow(GetDlgItem(IDC_CHK_BeaconControl), FALSE);
        ::ShowWindow  (GetDlgItem(IDC_CHK_BeaconControl), SW_HIDE);
        ::EnableWindow(GetDlgItem(IDC_ST_ICSLINK), FALSE);
        ::ShowWindow  (GetDlgItem(IDC_ST_ICSLINK), SW_HIDE);
    }
    else if(FALSE == fPolicyAllowsSharing)
    {
        // if policy disables ICS just gray the checkbox
        ::EnableWindow(GetDlgItem(IDC_CHK_Shared), FALSE);
        ::EnableWindow(GetDlgItem(IDC_CHK_BeaconControl), FALSE);
    }
    else if(m_cPrivate > 1)
    {
        // Show a drop-list of LAN connections or a disabled edit-box
        // depending on whether 'm_pconn' is shared, in both cases
        // hiding the smaller groupbox and showing the larger one
        // along with the 'private LAN' label.
        //
        ::ShowWindow(GetDlgItem(IDC_GB_Shared), SW_HIDE);
        ::ShowWindow(GetDlgItem(IDC_GB_PrivateLan), SW_SHOW);

        // show the text label
        ::ShowWindow(GetDlgItem(IDC_ST_HomeNetworkLabel), SW_SHOW);
        ::EnableWindow(GetDlgItem(IDC_ST_HomeNetworkLabel), TRUE);

        // move the beaconcontrol checkbox down
        RECT SourceRect;
        RECT TargetRect;
        ::GetWindowRect(GetDlgItem(IDC_CHK_BeaconControl), &SourceRect);
        ::GetWindowRect(GetDlgItem(IDC_ST_PositionBar), &TargetRect);

        LONG lDelta = TargetRect.top - SourceRect.top; // how far we need to move the controls down

        ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&SourceRect, 2); // convert screen to client
        ::SetWindowPos( GetDlgItem(IDC_CHK_BeaconControl), NULL, SourceRect.left, SourceRect.top + lDelta, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

        ::GetWindowRect(GetDlgItem(IDC_ST_ICSLINK), &SourceRect);
        ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&SourceRect, 2); // convert screen to client
        ::SetWindowPos(GetDlgItem(IDC_ST_ICSLINK), NULL, SourceRect.left, SourceRect.top + lDelta, 0, 0, SWP_NOSIZE|SWP_NOZORDER);

        if (m_fShared && !m_fResetPrivateAdapter)
        {
            ::ShowWindow(GetDlgItem(IDC_EDT_PrivateLan), SW_SHOW);

            // Display the private LAN in the editbox
            //

            hr = m_rgPrivateCons[m_lxCurrentPrivate]->GetName(&pszw);
            if (SUCCEEDED(hr))
            {
                SetDlgItemText(IDC_EDT_PrivateLan, pszw);
                CoTaskMemFree(pszw);
            }
        }
        else
        {
            // show and configure the dropdown
            HWND hwndCb = GetDlgItem(IDC_CB_PrivateLan);
            INT i, item;

            ::ShowWindow(hwndCb, SW_SHOW);
            // Add the bogus entry to the combobox

            pszw = const_cast<LPWSTR>(SzLoadIds(IDS_SHAREDACCESS_SELECTADAPTER));
            Assert(pszw);

            item = ComboBox_AddString(hwndCb, pszw);
            if (item != CB_ERR && item != CB_ERRSPACE)
            {
                ComboBox_SetItemData(hwndCb, item, NULL); // ensure item data is null for validation purposes
            }

            // Fill the combobox with LAN names
            //
            for (i = 0; i < (INT)m_cPrivate; i++)
            {
                hr = m_rgPrivateCons[i]->GetName(&pszw);
                if (SUCCEEDED(hr))
                {
                    item = ComboBox_AddString(hwndCb, pszw);
                    if (item != CB_ERR && item != CB_ERRSPACE)
                    {
                        ComboBox_SetItemData(
                            hwndCb, item, m_rgPrivateCons[i] );
                    }

                    CoTaskMemFree(pszw);
                }
            }
            ComboBox_SetCurSel( hwndCb, 0 );

        }
    }
    ::EnableWindow(GetDlgItem(IDC_PSB_Settings), m_fShared || m_fFirewalled);

    BOOL fBeaconControl = TRUE;

    HKEY hKey;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, KEY_QUERY_VALUE, &hKey);
    if(ERROR_SUCCESS == dwError) // if this fails we assume it is on, set the box, and commit on apply
    {
        DWORD dwType;
        DWORD dwData = 0;
        DWORD dwSize = sizeof(dwData);
        dwError = RegQueryValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, &dwType, reinterpret_cast<LPBYTE>(&dwData), &dwSize);
        if(ERROR_SUCCESS == dwError && REG_DWORD == dwType && 0 == dwData)
        {
            fBeaconControl = FALSE;
        }
        RegCloseKey(hKey);
    }

    CheckDlgButton(IDC_CHK_Shared, m_fShared);
    CheckDlgButton(IDC_CHK_BeaconControl, fBeaconControl);
    ::EnableWindow(GetDlgItem(IDC_CHK_BeaconControl), m_fShared && fPolicyAllowsSharing);


    //if the machine is personal or workstation, show the HNW link
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

    if(0 != VerifyVersionInfo(&verInfo, VER_PRODUCT_TYPE, ConditionMask))
    {
        // but only if not on a domain
        LPWSTR pszNameBuffer;
        NETSETUP_JOIN_STATUS BufferType;

        if(NERR_Success == NetGetJoinInformation(NULL, &pszNameBuffer, &BufferType))
        {
            NetApiBufferFree(pszNameBuffer);
            if(NetSetupDomainName != BufferType)
            {
                ::ShowWindow(GetDlgItem(IDC_ST_HNWLINK), SW_SHOW);
            }
        }
    }


    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanAdvancedPage::OnContextMenu(UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam,
                           BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanAdvancedPage::OnHelp(UINT uMsg,
                      WPARAM wParam,
                      LPARAM lParam,
                      BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnApply
//
//  Purpose:    Called when the 'Shared Access' page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     aboladeg   14 May 1998
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;
    IHNetIcsPrivateConnection *pIcsPrivate;
    IHNetConnection *pPrivateConn;
    IHNetIcsPublicConnection *pIcsPublic;
    ULONG ulcPub, ulcPvt;
    BOOLEAN fPrivateConfigured = FALSE;
    BOOLEAN fConflictDialogDisplayed = FALSE;
    HNET_CONN_PROPERTIES *pProps;

    if (!!m_fFirewalled != !!IsDlgButtonChecked(IDC_CHK_Firewall))
    {
        IHNetFirewalledConnection *pFWConn;

        if (m_fFirewalled)
        {
            //
            // Obtain our firewalled connection interface
            //

            hr = m_pHNetConn->GetControlInterface(
                __uuidof(IHNetFirewalledConnection),
                reinterpret_cast<void**>(&pFWConn)
                );

            if (SUCCEEDED(hr))
            {
                hr = pFWConn->Unfirewall();
                ReleaseObj(pFWConn);

                if (SUCCEEDED(hr))
                {
                    m_fFirewalled = FALSE;
                }
            }

        }
        else
        {
            hr = m_pHNetConn->Firewall(&pFWConn);

            if (SUCCEEDED(hr))
            {
                ReleaseObj(pFWConn);
                m_fFirewalled = TRUE;
            }
        }

        if (!SUCCEEDED(hr))
        {
            if (HRESULT_CODE(hr) == ERROR_SHARING_RRAS_CONFLICT)
            {
                fConflictDialogDisplayed = TRUE;
                NcMsgBox(_Module.GetResourceInstance(),
                         m_hWnd,
                         IDS_LAN_CAPTION,
                         IDS_LANUI_SHARING_CONFLICT,
                         MB_ICONINFORMATION | MB_OK);
            }
            else
            {
                NcRasMsgBoxWithErrorText (HRESULT_CODE(hr),
                    _Module.GetResourceInstance(), m_hWnd,
                    IDS_LANUI_ERROR_CAPTION, IDS_TEXT_WITH_RAS_ERROR,
                    m_fFirewalled ? IDS_LAN_UNSHARE_FAILED : IDS_LAN_SHARE_FAILED,
                    MB_OK | MB_ICONEXCLAMATION );
            }
        }
    }

    if (!!m_fShared != !!IsDlgButtonChecked(IDC_CHK_Shared))
    {
        if (m_fShared)
        {
            //
            // Instead of dealing w/ the public and private connection
            // individually, we simply just diasable all sharing
            //

            hr = m_pHNetIcsSettings->DisableIcs(&ulcPub, &ulcPvt);

            if (SUCCEEDED(hr))
            {
                m_fShared = FALSE;
            }
        }
        else
        {
            if (m_cPrivate > 1)
            {
                HWND hWndCb = GetDlgItem(IDC_CB_PrivateLan);
                INT item = ComboBox_GetCurSel(hWndCb);
                if (item != CB_ERR)
                {
                    pPrivateConn =
                        (IHNetConnection*)ComboBox_GetItemData(hWndCb, item);
                }
            }
            else
            {
                ASSERT(NULL != m_rgPrivateCons);

                pPrivateConn = m_rgPrivateCons[0];
            }

            //
            // Check to see if the selected private connection is already
            // configured as such.
            //

            if (SUCCEEDED(pPrivateConn->GetProperties(&pProps)))
            {
                fPrivateConfigured = pProps->fIcsPrivate;
                CoTaskMemFree(pProps);
            }

            if (m_fOtherShared)
            {
                if (fPrivateConfigured)
                {
                    //
                    // Unshare old public connection only. Leaving the
                    // private connection as-is prevents a lot of
                    // useless work.
                    //

                    ASSERT(NULL != m_pOldSharedConnection);

                    hr = m_pOldSharedConnection->Unshare();
                }
                else
                {
                    //
                    // We need to configure a new private connection, so
                    // just wipe out the old configuration.
                    //

                    hr = m_pHNetIcsSettings->DisableIcs(&ulcPub, &ulcPvt);
                }
            }

            if (SUCCEEDED(hr))
            {
                hr = m_pHNetConn->SharePublic(&pIcsPublic);

                if (SUCCEEDED(hr))
                {
                    if (!fPrivateConfigured)
                    {
                        hr = pPrivateConn->SharePrivate(&pIcsPrivate);

                        if (SUCCEEDED(hr))
                        {
                            ReleaseObj(pIcsPrivate);
                            m_fShared = TRUE;
                        }
                        else
                        {
                            pIcsPublic->Unshare();
                        }
                    }
                    else
                    {
                        m_fShared = TRUE;
                    }

                    ReleaseObj(pIcsPublic);
                }
            }
        }

        if (!SUCCEEDED(hr))
        {
            if (HRESULT_CODE(hr) == ERROR_SHARING_RRAS_CONFLICT)
            {
                if (!fConflictDialogDisplayed)
                {
                    NcMsgBox(_Module.GetResourceInstance(),
                             m_hWnd,
                             IDS_LAN_CAPTION,
                             IDS_LANUI_SHARING_CONFLICT,
                             MB_ICONINFORMATION | MB_OK);
                }
            }
            else
            {
                NcRasMsgBoxWithErrorText (HRESULT_CODE(hr),
                    _Module.GetResourceInstance(), m_hWnd,
                    IDS_LANUI_ERROR_CAPTION, IDS_TEXT_WITH_RAS_ERROR,
                    m_fShared ? IDS_LAN_UNSHARE_FAILED : IDS_LAN_SHARE_FAILED,
                    MB_OK | MB_ICONEXCLAMATION );
            }
        }
    }
    else if (m_fResetPrivateAdapter && m_cPrivate)
    {
        if (m_cPrivate > 1)
        {
            HWND hWndCb = GetDlgItem(IDC_CB_PrivateLan);
            INT item = ComboBox_GetCurSel(hWndCb);
            if (item != CB_ERR)
            {
                pPrivateConn =
                    (IHNetConnection*)ComboBox_GetItemData(hWndCb, item);
            }
        }
        else
        {
            ASSERT(NULL != m_rgPrivateCons);

            pPrivateConn = m_rgPrivateCons[0];
        }

        hr = pPrivateConn->SharePrivate(&pIcsPrivate);
        if (SUCCEEDED(hr))
        {
            ReleaseObj(pIcsPrivate);
        }
        else
        {
            HRESULT hr2 = m_pHNetIcsSettings->DisableIcs(&ulcPub, &ulcPvt);
            if (SUCCEEDED(hr2))
            {
                m_fShared = FALSE;
            }

            NcRasMsgBoxWithErrorText (HRESULT_CODE(hr),
                _Module.GetResourceInstance(), m_hWnd,
                IDS_LANUI_ERROR_CAPTION, IDS_TEXT_WITH_RAS_ERROR,
                m_fShared ? IDS_LAN_UNSHARE_FAILED : IDS_LAN_SHARE_FAILED,
                MB_OK | MB_ICONEXCLAMATION );
        }
    }

    HKEY hKey;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGKEY_SHAREDACCESSCLIENTKEYPATH, 0, NULL, 0, KEY_SET_VALUE, NULL, &hKey, NULL))
    {
        DWORD dwData = BST_CHECKED == IsDlgButtonChecked(IDC_CHK_BeaconControl);
        RegSetValueEx(hKey, REGVAL_SHAREDACCESSCLIENTENABLECONTROL, 0, REG_DWORD, reinterpret_cast<LPBYTE>(&dwData), sizeof(dwData));
        RegCloseKey(hKey);
    }

    TraceError("CLanAdvancedPage::OnApply", hr);

    //
    // We always need to return a success code here. If we return a failure
    // code the dialog won't go away, allowing the user to click "OK" a
    // second time. This second call will result in problems w/ other
    // property sheets (e.g., CLanNetPage), as they aren't expecting this
    // second (non-reentrant) call to OnApply.
    //

    if (FAILED(hr))
    {
        hr = S_FALSE;
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnCancel
//
//  Purpose:    Called when the 'Shared Access' page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     aboladeg    14 May 1998
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return LresFromHr(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnKillActive
//
//  Purpose:    Called when the 'Shared Access' page is deactivated,
//              or applied.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     aboladeg    6 July 1998
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);
    //
    // m_fOtherShared will be set to true in OnShared if we're switching the
    // shared connection. Since we've already displayed a warning for
    // switching, we don't need to display another here.
    //

    if (IsDlgButtonChecked(IDC_CHK_Shared) && (!m_fShared || (m_fResetPrivateAdapter && 0 != m_cPrivate)))
    {
        IHNetConnection* pPrivateConn = NULL;
        if(1 < m_cPrivate) // if the combobox is showing make sure they selected a valid adapter
        {
            HWND hwndCb = GetDlgItem(IDC_CB_PrivateLan);
            INT item = ComboBox_GetCurSel(hwndCb);
            if (item != CB_ERR)
            {
                pPrivateConn = reinterpret_cast<IHNetConnection*>(ComboBox_GetItemData(hwndCb, item));
            }
        }
        else
        {
            pPrivateConn = m_rgPrivateCons[0];

        }

        if(NULL == pPrivateConn)
        {
            Assert(1 < m_cPrivate);

            NcMsgBox(_Module.GetResourceInstance(), m_hWnd, IDS_LAN_CAPTION,
                IDS_SHAREDACCESS_SELECTADAPTERERROR, MB_OK | MB_ICONWARNING);

            SetWindowLong(DWLP_MSGRESULT, PSNRET_INVALID);
            return TRUE;
        }

        if(!m_fOtherShared && FALSE == IsAdapterDHCPEnabled(pPrivateConn))
        {
            int nRet = NcMsgBox(
                _Module.GetResourceInstance(), m_hWnd, IDS_LAN_CAPTION,
                IDS_LAN_ENABLE_SHARED_ACCESS, MB_ICONINFORMATION|MB_YESNO);
            if (nRet == IDNO)
            {
                SetWindowLong(DWLP_MSGRESULT, TRUE);
                return TRUE;
            }
        }

    }

    if (TRUE == m_fFirewalled && TRUE == m_fShowDisableFirewallWarning && BST_UNCHECKED == IsDlgButtonChecked(IDC_CHK_Firewall))
    {
        INT_PTR nDialogResult;
        m_fShowDisableFirewallWarning = FALSE;

        nDialogResult = DialogBox(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_DISABLEFIREWALLWARNING), m_hWnd, DisableFirewallWarningDlgProc);
        if(-1 != nDialogResult && IDYES != nDialogResult)
        {
            CheckDlgButton(IDC_CHK_Firewall, BST_CHECKED);
            ::EnableWindow(
                GetDlgItem(IDC_PSB_Settings),
                BST_CHECKED == IsDlgButtonChecked(IDC_CHK_Firewall) || BST_CHECKED == IsDlgButtonChecked(IDC_CHK_Shared)
                );
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnShared
//
//  Purpose:    Handles the clicking of the Shared button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     aboladeg    23 May 1998
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnShared(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                           BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    BOOL fShared = IsDlgButtonChecked(IDC_CHK_Shared);
    if (!m_fShared && fShared)
    {
        //
        // Check to see if the user is changing the shared connection
        //

        HRESULT             hr = S_OK;
        IHNetIcsPublicConnection* pOldIcsConn;
        IHNetConnection*    pOldConn;
        PWSTR               pszwOld;
        NETCON_PROPERTIES*  pProps;
        IEnumHNetIcsPublicConnections *pEnum;

        hr = m_pHNetIcsSettings->EnumIcsPublicConnections(&pEnum);

        if (SUCCEEDED(hr))
        {
            ULONG ulCount;

            hr = pEnum->Next(1, &pOldIcsConn, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                hr = pOldIcsConn->QueryInterface(
                        __uuidof(pOldConn),
                        reinterpret_cast<void**>(&pOldConn)
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pOldConn->GetName(&pszwOld);
                    ReleaseObj(pOldConn);

                    //
                    // Transfer reference for old shared connection
                    //

                    m_pOldSharedConnection = pOldIcsConn;

                    //
                    // Even if we weren't able to obtain the name of the
                    // old shared connection, we need to note that such
                    // a connection exists. (This situation will arise if
                    // the old shared connection has been removed from the
                    // system.)
                    //

                    m_fOtherShared = TRUE;
                }
                else
                {
                    ReleaseObj(pOldIcsConn);
                }
            }
            else
            {
                m_fOtherShared = FALSE;
            }

            ReleaseObj(pEnum);
        }

        if (SUCCEEDED(hr) && m_fOtherShared)
        {
            hr = m_pconn->GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                NcMsgBox(
                    _Module.GetResourceInstance(), m_hWnd, IDS_LANUI_ERROR_CAPTION,
                    IDS_LAN_CHANGE_SHARED_CONNECTION, MB_ICONINFORMATION|MB_OK,
                    pszwOld, pProps->pszwName );
                FreeNetconProperties(pProps);
            }
            CoTaskMemFree(pszwOld);
        }
    }
    ::EnableWindow(GetDlgItem(IDC_PSB_Settings), fShared || BST_CHECKED == IsDlgButtonChecked(IDC_CHK_Firewall));
    ::EnableWindow(GetDlgItem(IDC_CHK_BeaconControl), fShared);
    return LresFromHr(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnFirewall
//
//  Purpose:    Handles the clicking of the Firewall checkbox
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     jonburs    6 Oct 1999
//
//  Notes:
//

LRESULT CLanAdvancedPage::OnFirewall(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                     BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    ::EnableWindow(
        GetDlgItem(IDC_PSB_Settings),
        BST_CHECKED == IsDlgButtonChecked(IDC_CHK_Firewall) || BST_CHECKED == IsDlgButtonChecked(IDC_CHK_Shared)
        );

    return LresFromHr(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnSettings
//
//  Purpose:    Handles the clicking of the Settings button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     aboladeg    25 Oct 1998
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnSettings(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                           BOOL& bHandled)
{
    DWORD dwLastError = NOERROR;

    TraceFileFunc(ttidLanUi);

    HINSTANCE hinstance = LoadLibrary(TEXT("hnetcfg.dll"));
    if (!hinstance)
        dwLastError = GetLastError();
    else {
        BOOL (APIENTRY *pfnHNetSharingAndFirewallSettingsDlg)(HWND, IHNetCfgMgr*, BOOL, IHNetConnection*);

        pfnHNetSharingAndFirewallSettingsDlg = (BOOL (APIENTRY *)(HWND, IHNetCfgMgr*, BOOL, IHNetConnection*))
                            ::GetProcAddress(hinstance, "HNetSharingAndFirewallSettingsDlg");
        if (!pfnHNetSharingAndFirewallSettingsDlg)
            dwLastError = GetLastError();
        else
            pfnHNetSharingAndFirewallSettingsDlg(m_hWnd, m_pHNetCfgMgr, IsDlgButtonChecked(IDC_CHK_Firewall), m_pHNetConn);
        FreeLibrary (hinstance);
    }
    if (dwLastError != NOERROR) {
        LPVOID lpMsgBuf = NULL;
        if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            dwLastError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL)) {
            // Display the string.
            MessageBox( (LPCTSTR)lpMsgBuf );
            // Free the buffer.
            LocalFree( lpMsgBuf );
        }
    }
    return LresFromHr(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::OnClick
//
//  Purpose:    Called in response to the NM_CLICK message
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      fHandled []
//
//  Returns:
//
//  Author:     kenwic   11 Sep 2000
//
//  Notes:
//
LRESULT CLanAdvancedPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if(IDC_ST_HNWLINK == idCtrl)
    {
        HWND hPropertySheetWindow = GetParent();
        if(NULL != hPropertySheetWindow)
        {
            ShellExecute(NULL,TEXT("open"),TEXT("rundll32"), TEXT("hnetwiz.dll,HomeNetWizardRunDll"),NULL,SW_SHOW);
            ::PostMessage(hPropertySheetWindow, WM_COMMAND, MAKEWPARAM(IDCANCEL, 0), (LPARAM) ::GetDlgItem(hPropertySheetWindow, IDCANCEL));
        }
    }
    else if(IDC_ST_ICFLINK == idCtrl || IDC_ST_ICSLINK == idCtrl)
    {
        LPTSTR pszHelpTopic = IDC_ST_ICFLINK == idCtrl ? TEXT("netcfg.chm::/hnw_understanding_firewall.htm") : TEXT("netcfg.chm::/Share_conn_overvw.htm");
        HtmlHelp(NULL, pszHelpTopic, HH_DISPLAY_TOPIC, 0);
    }

    return 0;
}

INT_PTR CALLBACK CLanAdvancedPage::DisableFirewallWarningDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidLanUi);

    switch(uMsg)
    {
        case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
            case IDYES:
            case IDNO:
                if(BST_CHECKED == ::IsDlgButtonChecked(hWnd, IDC_CHK_DISABLEFIREWALLWARNING))
                {
                    HKEY hFirewallKey;
                    if(SUCCEEDED(HrRegCreateKeyEx(HKEY_CURRENT_USER, g_pszFirewallRegKey, 0, KEY_SET_VALUE, NULL, &hFirewallKey, NULL)))
                    {
                        DWORD dwValue = TRUE;
                        HrRegSetValueEx(hFirewallKey, g_pszDisableFirewallWarningValue, REG_DWORD, reinterpret_cast<CONST BYTE*>(&dwValue), sizeof(dwValue));
                        RegCloseKey(hFirewallKey);
                    }
                }

                // fallthru
            case IDCANCEL:
                EndDialog(hWnd, LOWORD(wParam));
                break;

            }
            break;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAdvancedPage::IsAdapterDHCPEnabled
//
//  Purpose:    Check if DHCP is set on this adapter
//
//  Arguments:
//              pConnection: the adapter
//
//  Returns:
//
//  Author:     kenwic   11 Oct 2000
//
//  Notes:
//

BOOL CLanAdvancedPage::IsAdapterDHCPEnabled(IHNetConnection* pConnection)
{
    TraceFileFunc(ttidLanUi);

    HRESULT hr;
    BOOL fDHCP = FALSE;
    GUID* pAdapterGuid;
    hr = pConnection->GetGuid(&pAdapterGuid);
    if(SUCCEEDED(hr))
    {
        LPOLESTR pAdapterName;
        hr = StringFromCLSID(*pAdapterGuid, &pAdapterName);
        if(SUCCEEDED(hr))
        {
            SIZE_T Length = wcslen(pAdapterName);
            LPSTR pszAnsiAdapterName = new char[Length + 1];
            if(NULL != pszAnsiAdapterName)
            {
                if(0 != WideCharToMultiByte(CP_ACP, 0, pAdapterName, Length + 1, pszAnsiAdapterName, Length + 1, NULL, NULL))
                {
                    HMODULE hIpHelper;
                    hIpHelper = LoadLibrary(L"iphlpapi");
                    if(NULL != hIpHelper)
                    {
                        DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO, PULONG);

                        pGetAdaptersInfo = (DWORD (WINAPI*)(PIP_ADAPTER_INFO, PULONG)) GetProcAddress(hIpHelper, "GetAdaptersInfo");
                        if(NULL != pGetAdaptersInfo)
                        {
                            ULONG ulSize = 0;
                            if(ERROR_BUFFER_OVERFLOW == pGetAdaptersInfo(NULL, &ulSize))
                            {
                                BYTE* pInfoArray = new BYTE[ulSize];
                                PIP_ADAPTER_INFO pInfo = reinterpret_cast<PIP_ADAPTER_INFO>(pInfoArray);
                                if(NULL != pInfo)
                                {
                                    if(ERROR_SUCCESS == pGetAdaptersInfo(pInfo, &ulSize))
                                    {
                                        PIP_ADAPTER_INFO pAdapterInfo = pInfo;
                                        do
                                        {
                                            if(0 == lstrcmpA(pszAnsiAdapterName, pAdapterInfo->AdapterName))
                                            {
                                                fDHCP = !!pAdapterInfo->DhcpEnabled;
                                                break;
                                            }

                                        } while(NULL != (pAdapterInfo = pAdapterInfo->Next));
                                    }
                                    delete [] pInfoArray;
                                }
                            }
                        }
                        FreeLibrary(hIpHelper);
                    }
                }
                delete [] pszAnsiAdapterName;
            }
            CoTaskMemFree(pAdapterName);
        }
        CoTaskMemFree(pAdapterGuid);
    }

    return fDHCP;
}


//
// CLanAddComponentDlg
//

struct ADD_COMPONENT_INFO
{
    UINT            uiIdsName;
    UINT            uiIdsDesc;
    const GUID *    pguidClass;
};

static const ADD_COMPONENT_INFO c_rgaci[] =
{
    {IDS_LAN_CLIENT,     IDS_LAN_CLIENT_DESC,    &GUID_DEVCLASS_NETCLIENT},
    {IDS_LAN_SERVICE,    IDS_LAN_SERVICE_DESC,   &GUID_DEVCLASS_NETSERVICE},
    {IDS_LAN_PROTOCOL,   IDS_LAN_PROTOCOL_DESC,  &GUID_DEVCLASS_NETTRANS},
};

static const INT c_naci = celems(c_rgaci);

//+---------------------------------------------------------------------------
//
//  Member:     CLanAddComponentDlg::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanAddComponentDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                          LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT                 hr = S_OK;
    INT                     iaci;
    RECT                    rc;
    LV_COLUMN               lvc = {0};
    SP_CLASSIMAGELIST_DATA  cid = {0};
    BOOL                    fValidImages = FALSE;

    m_hwndLV = GetDlgItem(IDC_LVW_Lan_Components);

    // Get the class image list structure
    hr = HrSetupDiGetClassImageList(&cid);
    if (SUCCEEDED(hr))
    {
        ListView_SetImageList(m_hwndLV, ImageList_Duplicate(cid.ImageList),
                              LVSIL_SMALL);
        fValidImages = TRUE;
    }
    else
    {
        // Handling failure with fValidImages flag
        hr = S_OK;
    }

    ::GetClientRect(m_hwndLV, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(m_hwndLV, 0, &lvc);

    // For each class, add it to the list
    for (iaci = 0; iaci < c_naci; iaci++)
    {
        LV_ITEM     lvi = {0};

        lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;

        if (fValidImages)
        {
            // Get the component's class image list index
            hr = HrSetupDiGetClassImageIndex(&cid,
                               const_cast<LPGUID>(c_rgaci[iaci].pguidClass),
                               &lvi.iImage);
            if (SUCCEEDED(hr))
            {
                lvi.mask |= LVIF_IMAGE;
            }
        }

        // Select the first item
        if (iaci == 0)
        {
            lvi.state = lvi.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        }

        lvi.pszText = const_cast<PWSTR>(SzLoadIds(c_rgaci[iaci].uiIdsName));
        lvi.lParam = reinterpret_cast<LPARAM>(c_rgaci[iaci].pguidClass);
        lvi.iItem = iaci;
        ListView_InsertItem(m_hwndLV, &lvi);
    }

    if (fValidImages)
    {
        (void) HrSetupDiDestroyClassImageList(&cid);
    }

    if (FAILED(hr))
    {
        EndDialog(0);
    }

    TraceError("CLanAddComponentDlg::OnInitDialog", hr);
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanAddComponentDlg::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanAddComponentDlg::OnContextMenu(UINT uMsg,
                                   WPARAM wParam,
                                   LPARAM lParam,
                                   BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);
    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAddComponentDlg::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CLanAddComponentDlg::OnHelp( UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAddComponentDlg::OnItemChanged
//
//  Purpose:    Handles the selection changed message for the list view
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanAddComponentDlg::OnItemChanged(int idCtrl, LPNMHDR pnmh,
                                           BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    HWND            hwndButton = GetDlgItem(IDC_PSB_Component_Add);

    Assert(pnmlv);

    // Check if selection changed
    if ((pnmlv->uNewState & LVIS_SELECTED) &&
        (!(pnmlv->uOldState & LVIS_SELECTED)))
    {
        // Update the description if/when selection changes
        SetDlgItemText(IDC_TXT_Component_Desc,
                       SzLoadIds(c_rgaci[pnmlv->iItem].uiIdsDesc));
        ::EnableWindow(hwndButton, TRUE);
    }
    else if (!(pnmlv->uNewState & LVIS_SELECTED) &&
            (pnmlv->uOldState & LVIS_SELECTED))
    {
        // Update the description if/when selection changes
        SetDlgItemText(IDC_TXT_Component_Desc, c_szEmpty);
        ::EnableWindow(hwndButton, FALSE);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAddComponentDlg::OnAdd
//
//  Purpose:    Handles the clicking of the Add button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CLanAddComponentDlg::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                   BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT             hr = S_OK;
    INT                 iIndex;
    INetCfgComponent *  pncc = NULL;
    BOOL                fCancel = FALSE;
    HWND                hwndFocus;
    CWaitCursor         wc;                 // Displays a wait cursor

    // Get the selected item
    iIndex = ListView_GetNextItem(m_hwndLV, -1, LVNI_SELECTED);
    if (iIndex != -1)
    {
        int rgidc[] = {IDC_LVW_Lan_Components, IDC_PSB_Component_Add, IDCANCEL};

        CWaitCursor wc;

        LV_ITEM lvi = {0};
        lvi.mask  = LVIF_PARAM;
        lvi.iItem = iIndex;
        ListView_GetItem(m_hwndLV, &lvi);

        // Disable the UI
        //

        hwndFocus = ::GetFocus();
        EnableOrDisableDialogControls (m_hWnd, celems(rgidc), rgidc, FALSE);

        // This is its class GUID.
        //
        Assert (lvi.lParam);

        // Get the setup interface for the class and use it to install
        // a component of the user's selection.
        //
        GUID* pClassGuid = (GUID*)lvi.lParam;
        INetCfgInternalSetup* pInternalSetup;

        hr = m_pnc->QueryInterface (IID_INetCfgInternalSetup,
                (void**)&pInternalSetup);

        if (SUCCEEDED(hr))
        {
            OBO_TOKEN OboToken;
            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_USER;

            hr = pInternalSetup->SelectWithFilterAndInstall(m_hWnd,
                    pClassGuid, &OboToken, m_pcfi, &pncc);

            if (HRESULT_FROM_WIN32 (ERROR_CANCELLED) == hr)
            {
                fCancel = TRUE;
                hr = S_FALSE;
            }
            else if (S_OK == hr)
            {
                // Commit the changes
                hr = m_pnc->Apply();
            }

            ReleaseObj(pncc);
            ReleaseObj(pInternalSetup);
        }

        EnableOrDisableDialogControls (m_hWnd, celems(rgidc), rgidc, TRUE);
        ::SetFocus( hwndFocus );
    }
    else
    {
        fCancel = TRUE;
    }

    if (SUCCEEDED(hr) && (NETCFG_S_REBOOT != hr))
    {
        // Make sure S_FALSE doesn't get thru
        hr = S_OK;
    }

    if (!fCancel)
    {
        // Return the installed error code as the result. S_OK means user
        // clicked OK and actually added a component. S_FALSE means they
        // cancelled, otherwise this will return an error code
        EndDialog(static_cast<int>(hr));
    }

    TraceError("CLanAddComponentDlg::OnAdd", hr);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanAddComponentDlg::OnCancel
//
//  Purpose:    Called when the cancel button is pressed.
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     danielwe   10 Nov 1997
//
//  Notes:
//
LRESULT CLanAddComponentDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                                      BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_FALSE;

    // Return S_FALSE on cancel
    EndDialog(static_cast<int>(hr));

    return 0;
}

LRESULT CLanAddComponentDlg::OnDblClick(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    return OnAdd(0, 0, NULL, bHandled);
}

//
// CLanSecurityPage
//

CLanSecurityPage::CLanSecurityPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    const DWORD * adwHelpIDs)
{
    TraceFileFunc(ttidLanUi);

    m_pconn = pconn;
    m_pnc = pnc;
    m_fNetcfgInUse = FALSE;
    m_adwHelpIDs = adwHelpIDs;
    pListEapcfgs = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::~CLanSecurityPage
//
//  Purpose:    Destroys the CLanSecurityPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     sachins
//
//  Notes:
//
CLanSecurityPage::~CLanSecurityPage()
{
    TraceFileFunc(ttidLanUi);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    error code
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                        LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    DTLNODE*    pOriginalEapcfgNode = NULL;
    WCHAR       wszGuid[c_cchGuidWithTerm];
    BYTE        *pbData = NULL;
    DWORD       cbData = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    EAPOL_INTF_STATE    EapolIntfState = {0};
    BOOLEAN     fFlag = FALSE;
    DWORD       dwFlags = 0;
    HRESULT     hr = S_OK;


    SetClassLongPtr(m_hWnd, GCLP_HCURSOR, NULL);
    SetClassLongPtr(GetParent(), GCLP_HCURSOR, NULL);


    // Initially disable all the controls

    ::EnableWindow(GetDlgItem(CID_CA_RB_Eap), FALSE);
    ::EnableWindow(GetDlgItem(IDC_TXT_EAP_TYPE), FALSE);
    ::EnableWindow(GetDlgItem(CID_CA_LB_EapPackages), FALSE);
    ::EnableWindow(GetDlgItem(CID_CA_PB_Properties), FALSE);
    ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), FALSE);
    ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), FALSE);


    // Initialize EAP package list
    // Read the EAPCFG information from the registry and find the node
    // selected in the entry, or the default, if none.

    do
    {
        DTLNODE* pNode = NULL;
        TCHAR* pszEncEnabled = NULL;


            DTLNODE*            pNodeEap;
            DWORD               dwkey = 0;
            NETCON_PROPERTIES*  pProps;

            hr = m_pconn->GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                if ((::StringFromGUID2(pProps->guidId,
                                        wszGuid,
                                        c_cchGuidWithTerm)) == 0)
                {
                    TraceTag (ttidLanUi, "Security::OnInitDialog: StringFromGUID2 failed");
                    FreeNetconProperties(pProps);
                    break;
                }

                FreeNetconProperties(pProps);

            }
            else
            {
                TraceTag (ttidLanUi, "Security::OnInitDialog: GetProperties failed");
                break;
            }

        // Read the state for this interface

        ZeroMemory ((BYTE *)&EapolIntfState, sizeof(EAPOL_INTF_STATE));
        DWORD   dwRetCode = NO_ERROR;
        dwRetCode = WZCEapolQueryState (
                NULL,
                wszGuid,
                &EapolIntfState
                );
        if (dwRetCode != NO_ERROR)
        {
            TraceTag (ttidLanUi, "WZCEapolQueryState failed with error %ld",
                    dwRetCode);
            // Consider the interface as non-wireless
        }


            // Read the EAP params for this interface

            ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
            EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
            EapolIntfParams.dwEapType = DEFAULT_EAP_TYPE;
            hr = HrElGetInterfaceParams (
                    wszGuid,
                    &EapolIntfParams
                    );
            if (FAILED (hr))
            {
                TraceTag (ttidLanUi, "HrElGetInterfaceParams failed with error %ld",
                        LresFromHr(hr));
                break;
            }


        // Read the EAPCFG information from the registry and find the node
        // selected in the entry, or the default, if none.

        pListEapcfgs = NULL;

        if (EapolIntfState.dwPhysicalMediumType == NdisPhysicalMediumWirelessLan)
        {
            dwFlags |= EAPOL_MUTUAL_AUTH_EAP_ONLY;
        }

        pListEapcfgs = ::ReadEapcfgList (dwFlags);

        if (pListEapcfgs)
        {

            TraceTag (ttidLanUi, "HrElGetInterfaceParams: Got EAPtype=(%ld), EAPState =(%ld)", EapolIntfParams.dwEapType, EapolIntfParams.dwEapFlags);

            // Enable all windows only for admins
            // if (FIsUserAdmin())
            {
                fFlag = TRUE;
            }

            ::EnableWindow(GetDlgItem(CID_CA_RB_Eap), fFlag);

            if (IS_EAPOL_ENABLED(EapolIntfParams.dwEapFlags))
            {
                Button_SetCheck(GetDlgItem(CID_CA_RB_Eap), TRUE);
                CheckDlgButton(CID_CA_RB_Eap, TRUE);
                ::EnableWindow(GetDlgItem(IDC_TXT_EAP_TYPE), fFlag);
                ::EnableWindow(GetDlgItem(CID_CA_LB_EapPackages), fFlag);

                ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), fFlag);
                if (IS_MACHINE_AUTH_ENABLED(EapolIntfParams.dwEapFlags))
                    Button_SetCheck(GetDlgItem(CID_CA_RB_MachineAuth), TRUE);

                ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), fFlag);
                if (IS_GUEST_AUTH_ENABLED(EapolIntfParams.dwEapFlags))
                    Button_SetCheck(GetDlgItem(CID_CA_RB_GuestAuth), TRUE);
            }
            else
            {
                ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), FALSE);
                if (IS_MACHINE_AUTH_ENABLED(EapolIntfParams.dwEapFlags))
                    Button_SetCheck(GetDlgItem(CID_CA_RB_MachineAuth), TRUE);

                ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), FALSE);
                if (IS_GUEST_AUTH_ENABLED(EapolIntfParams.dwEapFlags))
                    Button_SetCheck(GetDlgItem(CID_CA_RB_GuestAuth), TRUE);
            }

            // Read the EAP configuration info for all EAP packages

            for (pNodeEap = DtlGetFirstNode(pListEapcfgs);
                 pNodeEap;
                 pNodeEap = DtlGetNextNode(pNodeEap))
            {
                EAPCFG* pEapcfg = (EAPCFG* )DtlGetData(pNodeEap);
                ASSERT( pEapcfg );

                hr = S_OK;

                TraceTag (ttidLanUi, "Calling HrElGetCustomAuthData for EAP %ld",
                        pEapcfg->dwKey);

                    cbData = 0;

                    // Get the size of the EAP blob

                    hr = HrElGetCustomAuthData (
                                    wszGuid,
                                    pEapcfg->dwKey,
                                    EapolIntfParams.dwSizeOfSSID,
                                    EapolIntfParams.bSSID,
                                    NULL,
                                    &cbData
                                    );
                    if (!SUCCEEDED(hr))
                    {
                        if ((EapolIntfParams.dwSizeOfSSID != 0) &&
                            (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)))
                        {

                            TraceTag (ttidLanUi, "HrElGetCustomAuthData: SSID!= NULL, not found blob for SSID");

                            // The Last Used SSID did not have a connection
                            // blob created. Call again for size of blob with
                            // NULL SSID

                            EapolIntfParams.dwSizeOfSSID = 0;

                            // Get the size of the EAP blob

                            hr = HrElGetCustomAuthData (
                                            wszGuid,
                                            pEapcfg->dwKey,
                                            0,
                                            NULL,
                                            NULL,
                                            &cbData
                                            );
                        }

                        if (hr == E_OUTOFMEMORY)
                        {
                            if (cbData <= 0)
                            {
                                // No EAP blob stored in the registry

                                TraceTag (ttidLanUi, "HrElGetCustomAuthData: No blob stored in reg at all");
                                pbData = NULL;

                                // Will continue processing for errors
                                // Not exit

                            }
                            else
                            {
                                TraceTag (ttidLanUi, "HrElGetCustomAuthData: Found auth blob in registry");

                                // Allocate memory to hold the blob

                                pbData = (PBYTE) MALLOC (cbData);

                                if (pbData == NULL)
                                {
                                    hr = E_OUTOFMEMORY;
                                    TraceTag (ttidLanUi, "HrElGetCustomAuthData: Error in memory allocation for EAP blob");
                                    continue;
                                }
                                ZeroMemory (pbData, cbData);

                                hr = HrElGetCustomAuthData (
                                            wszGuid,
                                            pEapcfg->dwKey,
                                            EapolIntfParams.dwSizeOfSSID,
                                            EapolIntfParams.bSSID,
                                            pbData,
                                            &cbData
                                            );

                                if (!SUCCEEDED(hr))
                                {
                                    TraceTag (ttidLanUi, "HrElGetCustomAuthData: HrElGetCustomAuthData failed with %ld",
                                            LresFromHr(hr));
                                    FREE ( pbData );
                                    hr = S_OK;
                                    continue;
                                }

                                TraceTag (ttidLanUi, "HrElGetCustomAuthData: HrElGetCustomAuthData successfully got blob of length %ld"
                                        , cbData);
                            }
                        }
                        else
                        {
                            TraceTag (ttidLanUi, "HrElGetCustomAuthData: Not got ERROR_NOT_ENOUGH_MEMORY error; Unknown error !!!");
                            continue;
                        }
                    }
                    else
                    {
                        // HrElGetCustomAuthData will always return
                        // error with cbData = 0
                    }

                    if (pEapcfg->pData != NULL)
                    {
                        FREE ( pEapcfg->pData );
                    }
                    pEapcfg->pData = (UCHAR *)pbData;
                    pEapcfg->cbData = cbData;
            }


            // Choose the EAP name that will appear in the combo box

            pNode = EapcfgNodeFromKey(
                        pListEapcfgs, EapolIntfParams.dwEapType );


            pOriginalEapcfgNode = pNode;


            // Fill the EAP packages listbox and select the previously identified
            // selection.  The Properties button is disabled by default, but may
            // be enabled when the EAP list selection is set.

            ::EnableWindow(GetDlgItem(CID_CA_PB_Properties), FALSE);

            for (pNode = DtlGetFirstNode( pListEapcfgs );
                 pNode;
                 pNode = DtlGetNextNode( pNode ))
            {
                EAPCFG* pEapcfg = NULL;
                INT i;
                TCHAR* pszBuf = NULL;

                pEapcfg = (EAPCFG* )DtlGetData( pNode );
                ASSERT( pEapcfg );
                ASSERT( pEapcfg->pszFriendlyName );

                pszBuf =  (TCHAR *) MALLOC (( lstrlen(pEapcfg->pszFriendlyName) + 1 ) * sizeof(TCHAR));
                if (!pszBuf)
                {
                    continue;
                }

                lstrcpy( pszBuf, pEapcfg->pszFriendlyName );

                i = ComboBox_AddItem( GetDlgItem(CID_CA_LB_EapPackages),
                   pszBuf, pNode );

                if (pNode == pOriginalEapcfgNode)
                {
                    // Select the EAP name that will appear in the
                    // combo box

                    ComboBox_SetCurSelNotify( GetDlgItem(CID_CA_LB_EapPackages), i );
                }

                FREE ( pszBuf );
            }
        }

        ComboBox_AutoSizeDroppedWidth( GetDlgItem(CID_CA_LB_EapPackages) );


        // Disable the Properties button, if EAPOL is not enabled
        // or if the user is not AdminUser

        // if ((!FIsUserAdmin()) || (!IS_EAPOL_ENABLED(EapolIntfParams.dwEapFlags)))
        if ((!IS_EAPOL_ENABLED(EapolIntfParams.dwEapFlags)))
        {
            ::EnableWindow (GetDlgItem(CID_CA_PB_Properties), FALSE);
        }

    } while (FALSE);

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:
//
//  Author:     sachins
//
LRESULT
CLanSecurityPage::OnContextMenu(UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam,
                           BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:
//
//  Author:     sachins
//
LRESULT
CLanSecurityPage::OnHelp( UINT uMsg,
                        WPARAM wParam,
                        LPARAM lParam,
                        BOOL& fHandled)
{
    TraceFileFunc(ttidLanUi);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                    BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    if (pListEapcfgs)
    {
        DtlDestroyList (pListEapcfgs, DestroyEapcfgNode);
    }
    pListEapcfgs = NULL;


    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnProperties
//
//  Purpose:    Handles the clicking of the Properties button
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:    error code
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnProperties(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    DWORD       dwErr = 0;
    DTLNODE*    pNode = NULL;
    EAPCFG*     pEapcfg = NULL;
    RASEAPINVOKECONFIGUI pInvokeConfigUi;
    RASEAPFREE  pFreeConfigUIData;
    HINSTANCE   h;
    BYTE*       pConnectionData = NULL;
    DWORD       cbConnectionData = 0;
    HRESULT     hr = S_OK;


    // Look up the selected package configuration and load the associated
    // configuration DLL.

    pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
        GetDlgItem(CID_CA_LB_EapPackages),
        ComboBox_GetCurSel( GetDlgItem(CID_CA_LB_EapPackages) ) );
    ASSERT( pNode );
    if (!pNode)
    {
        return E_UNEXPECTED;
    }

    pEapcfg = (EAPCFG* )DtlGetData( pNode );
    ASSERT( pEapcfg );

    h = NULL;
    if (!(h = LoadLibrary( pEapcfg->pszConfigDll ))
        || !(pInvokeConfigUi =
                (RASEAPINVOKECONFIGUI )GetProcAddress(
                    h, "RasEapInvokeConfigUI" ))
        || !(pFreeConfigUIData =
                (RASEAPFREE) GetProcAddress(
                    h, "RasEapFreeMemory" )))
    {
        // Cannot load configuration DLL
        if (h)
        {
            FreeLibrary( h );
        }
        return E_FAIL;
    }


    // Call the configuration DLL to popup it's custom configuration UI.

    pConnectionData = NULL;
    cbConnectionData = 0;

    dwErr = pInvokeConfigUi(
                    pEapcfg->dwKey,
                    GetParent(),
                    RAS_EAP_FLAG_8021X_AUTH,
                    pEapcfg->pData,
                    pEapcfg->cbData,
                    &pConnectionData,
                    &cbConnectionData
                    );
    if (dwErr != 0)
    {
        FreeLibrary( h );
        return E_FAIL;
    }


    // Store the configuration information returned in the package descriptor.

    FREE ( pEapcfg->pData );
    pEapcfg->pData = NULL;
    pEapcfg->cbData = 0;

    if (pConnectionData)
    {
        if (cbConnectionData > 0)
        {
            // Copy it into the eap node
            pEapcfg->pData = (PUCHAR) MALLOC (cbConnectionData);
            if (pEapcfg->pData)
            {
                CopyMemory( pEapcfg->pData, pConnectionData, cbConnectionData );
                pEapcfg->cbData = cbConnectionData;
            }
        }
    }

    pFreeConfigUIData( pConnectionData );

    // Note any "force user to configure" requirement on the package has been
    // satisfied.

    pEapcfg->fConfigDllCalled = TRUE;

    FreeLibrary( h );

    TraceError("CLanSecurityPage::OnProperties", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnEapSelection
//
//  Purpose:    Handles the clicking of the EAP checkbox
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnEapSelection(WORD wNotifyCode, WORD wID,
                                            HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    EAPCFG*     pEapcfg = NULL;
    INT         iSel = 0;

    // Toggle buttons based on selection

    if (BST_CHECKED == IsDlgButtonChecked(CID_CA_RB_Eap))
    {
        ::EnableWindow(GetDlgItem(CID_CA_LB_EapPackages), TRUE);
        ::EnableWindow(GetDlgItem(IDC_TXT_EAP_TYPE), TRUE);


        // Get the EAPCFG information for the currently selected EAP package.

        iSel = ComboBox_GetCurSel(GetDlgItem(CID_CA_LB_EapPackages));


        // iSel is the index in the displayed list as well as the
        // index of the dll that are loaded.
        // Get the cfgnode corresponding to this index

        if (iSel >= 0)
        {
            DTLNODE* pNode;

            pNode =
                (DTLNODE* )ComboBox_GetItemDataPtr(
                    GetDlgItem(CID_CA_LB_EapPackages), iSel );
            if (pNode)
            {
                pEapcfg = (EAPCFG* )DtlGetData( pNode );
            }
        }


        // Enable the Properties button if the selected package has a
        // configuration entrypoint

        // if (FIsUserAdmin())
        {
            ::EnableWindow ( GetDlgItem(CID_CA_PB_Properties),
                (pEapcfg && !!(pEapcfg->pszConfigDll)) );
        }

        ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), TRUE);
        ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), TRUE);
    }
    else
    {
        ::EnableWindow(GetDlgItem (IDC_TXT_EAP_TYPE), FALSE);
        ::EnableWindow(GetDlgItem (CID_CA_LB_EapPackages), FALSE);
        ::EnableWindow(GetDlgItem (CID_CA_PB_Properties), FALSE);
        ::EnableWindow(GetDlgItem(CID_CA_RB_MachineAuth), FALSE);
        ::EnableWindow(GetDlgItem(CID_CA_RB_GuestAuth), FALSE);
    }

    TraceError("CLanSecurityPage::OnEapSelection", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnEapPackages
//
//  Purpose:    Handles the clicking of the EAP packages combo box
//
//  Arguments:
//      wNotifyCode []
//      wID         []
//      hWndCtl     []
//      bHandled    []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnEapPackages(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    HRESULT     hr = S_OK;

    EAPCFG*     pEapcfg = NULL;
    INT         iSel = 0;


    // Get the EAPCFG information for the selected EAP package.

    iSel = ComboBox_GetCurSel(GetDlgItem(CID_CA_LB_EapPackages));


    // iSel is the index in the displayed list as well as the
    // index of the dll that are loaded.
    // Get the cfgnode corresponding to this index

    if (iSel >= 0)
    {
        DTLNODE* pNode = NULL;

        pNode =
            (DTLNODE* )ComboBox_GetItemDataPtr(
                GetDlgItem(CID_CA_LB_EapPackages), iSel );
        if (pNode)
        {
            pEapcfg = (EAPCFG* )DtlGetData( pNode );
        }
    }


    // Enable the Properties button if the selected package has a
    // configuration entrypoint

    if (BST_CHECKED == IsDlgButtonChecked(CID_CA_RB_Eap))
    {
        ::EnableWindow ( GetDlgItem(CID_CA_PB_Properties),
                        (pEapcfg && !!(pEapcfg?pEapcfg->pszConfigDll:NULL)) );
    }


    TraceError("CLanSecurityPage::OnEapPackages", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnKillActive
//
//  Purpose:    Called to check warning conditions before the security
//              page is going away
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnKillActive(int idCtrl, LPNMHDR pnmh,
                                        BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    BOOL    fError;

    fError = m_fNetcfgInUse;

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//  Notes:
//
LRESULT CLanSecurityPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    WCHAR       wszGuid[c_cchGuidWithTerm];
    WCHAR       *pwszLastUsedSSID = NULL;
    DWORD       dwSizeofSSID = 0;
    DWORD       dwEapFlags = 0;
    DWORD       dwDefaultEapType = 0;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    NETCON_PROPERTIES* pProps = NULL;
    HRESULT     hrOverall = S_OK;
    HRESULT     hr = S_OK;

    // Save the EAP configuration data into the registry

    DTLNODE* pNodeEap = NULL;

#if 0
    if (!FIsUserAdmin())
    {
        TraceTag (ttidLanUi, "CLanSecurityPage::OnApply: Non-admin user, not saving data");
        return LresFromHr(hr);
    }
#endif

    hr = m_pconn->GetProperties(&pProps);
    if (!SUCCEEDED(hr))
    {
        TraceTag (ttidLanUi, "CLanSecurityPage::OnApply: Error in m_pconn->GetProperties");
        return LresFromHr(hr);
    }

    hr = S_OK;

    if (::StringFromGUID2(pProps->guidId, wszGuid, c_cchGuidWithTerm) == 0)
    {
        TraceTag (ttidLanUi, "CLanSecurityPage::OnApply: StringFromGUID2 failed");
        FreeNetconProperties(pProps);
        hr = E_FAIL;
        return LresFromHr(hr);
    }

    FreeNetconProperties(pProps);

    // Get the Last Used SSID on the interface and set the
    // EAP blob for that interface

    ZeroMemory ((BYTE *)&EapolIntfParams, sizeof(EAPOL_INTF_PARAMS));
    EapolIntfParams.dwEapFlags = DEFAULT_EAP_STATE;
    hr = HrElGetInterfaceParams (
            wszGuid,
            &EapolIntfParams
            );
    if (FAILED(hr))
    {
        TraceTag (ttidLanUi, "OnApply: HrElGetInterfaceParams failed with error %ld",
                LresFromHr(hr));
        return LresFromHr(hr);
    }

    // Save data for all EAP packages in the registry

    if (pListEapcfgs == NULL)
    {
        return LresFromHr(S_OK);
    }

    {
        DTLNODE* pNode = NULL;
        EAPCFG* pEapcfg = NULL;

        pNode = (DTLNODE* )ComboBox_GetItemDataPtr(
            GetDlgItem (CID_CA_LB_EapPackages),
            ComboBox_GetCurSel( GetDlgItem (CID_CA_LB_EapPackages) ) );
        if (pNode == NULL)
        {
            return LresFromHr (E_FAIL);
        }

        pEapcfg = (EAPCFG* )DtlGetData( pNode );
        if (pEapcfg == NULL)
        {
            return LresFromHr (E_FAIL);
        }
        dwDefaultEapType = pEapcfg->dwKey;
    }

    for (pNodeEap = DtlGetFirstNode(pListEapcfgs);
         pNodeEap;
         pNodeEap = DtlGetNextNode(pNodeEap))
    {
        EAPCFG* pcfg = (EAPCFG* )DtlGetData(pNodeEap);
        if (pcfg == NULL)
        {
            continue;
        }

        hr = S_OK;

        TraceTag (ttidLanUi, "Saving data for EAP Id = %ld", pcfg->dwKey);

        TraceTag (ttidLanUi, "OnApply: Setting customauthdata for %S",
                wszGuid);

        // ignore error and continue with next

        hr = HrElSetCustomAuthData (
                    wszGuid,
                    pcfg->dwKey,
                    EapolIntfParams.dwSizeOfSSID,
                    EapolIntfParams.bSSID,
                    pcfg->pData,
                    pcfg->cbData);

        if (FAILED (hr))
        {
            TraceTag (ttidLanUi, "HrElSetCustomAuthData failed");
            hrOverall = hr;
            hr = S_OK;
        }
        else
        {
            TraceTag (ttidLanUi, "HrElSetCustomAuthData succeeded");
        }

        FREE (pcfg->pData);
        pcfg->pData = NULL;
        pcfg->cbData = 0;
    }

    // If CID_CA_RB_Eap is checked, EAPOL is enabled on the interface

    if ( Button_GetCheck( GetDlgItem(CID_CA_RB_Eap) ) )
    {
        dwEapFlags |= EAPOL_ENABLED;

        if (Button_GetCheck( GetDlgItem(CID_CA_RB_MachineAuth )))
            dwEapFlags |= EAPOL_MACHINE_AUTH_ENABLED;

        if (Button_GetCheck( GetDlgItem(CID_CA_RB_GuestAuth )))
            dwEapFlags |= EAPOL_GUEST_AUTH_ENABLED;

        // Save the params for this interface in registry

        EapolIntfParams.dwEapType = dwDefaultEapType;
        EapolIntfParams.dwEapFlags = dwEapFlags;

        hr = HrElSetInterfaceParams (
                wszGuid,
                &EapolIntfParams
                );
        if (FAILED(hr))
        {
            TraceTag (ttidLanUi, "HrElSetInterfaceParams enabled failed with error %ld",
                    LresFromHr(hr));
            hrOverall = hr;
            hr = S_OK;
        }
    }
    else
    {
        dwEapFlags |= EAPOL_DISABLED;


        if (Button_GetCheck( GetDlgItem(CID_CA_RB_MachineAuth )))
            dwEapFlags |= EAPOL_MACHINE_AUTH_ENABLED;

        if (Button_GetCheck( GetDlgItem(CID_CA_RB_GuestAuth )))
            dwEapFlags |= EAPOL_GUEST_AUTH_ENABLED;

        // Save the params for this interface in registry

        EapolIntfParams.dwEapType = dwDefaultEapType;
        EapolIntfParams.dwEapFlags = dwEapFlags;

        hr = HrElSetInterfaceParams (
                wszGuid,
                &EapolIntfParams
                );
        if (FAILED(hr))
        {
            TraceTag (ttidLanUi, "HrElSetInterfaceParams EAPOL disabled failed with error %ld",
                    LresFromHr(hr));
            hrOverall = hr;
            hr = S_OK;
        }
        }

    if (FAILED(hrOverall))
    {
        NcMsgBox(
                WZCGetSPResModule(),
                m_hWnd,
                IDS_LANUI_ERROR_CAPTION,
                IDS_EAPOL_PARTIAL_APPLY,
                MB_ICONSTOP|MB_OK);
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanSecurityPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     sachins
//
//
LRESULT CLanSecurityPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    TraceFileFunc(ttidLanUi);

    if (pListEapcfgs)
    {
        DtlDestroyList (pListEapcfgs, DestroyEapcfgNode);
    }
    pListEapcfgs = NULL;

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, m_fNetcfgInUse);
    return m_fNetcfgInUse;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanwiz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N W I Z . H
//
//  Contents:   Declaration of the LAN wizard page
//
//  Notes:
//
//  Author:    tongl   16 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "ncatlps.h"
#include "resource.h"
#include "util.h"

class CLanWizPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CLanWizPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroyDialog)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)

        // NOTIFY_CODE_HANDLER(PSN_WIZBACK, OnWizBack)
        // NOTIFY_CODE_HANDLER(PSN_WIZNEXT, OnWizNext)
        // NOTIFY_CODE_HANDLER(PSN_WIZFINISH, OnWizFinish)

        // Push button handlers
        COMMAND_ID_HANDLER(IDC_PSH_ADD, OnAdd)
        COMMAND_ID_HANDLER(IDC_PSH_REMOVE, OnRemove)
        COMMAND_ID_HANDLER(IDC_PSH_PROPERTIES, OnProperties)

        // Listview handlers
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDbClick)
        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnKeyDown)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        NOTIFY_CODE_HANDLER(LVN_DELETEITEM, OnDeleteItem)

    END_MSG_MAP()

public:
    CLanWizPage(IUnknown *punk);

public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroyDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // LRESULT OnWizBack(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    // LRESULT OnWizNext(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    // LRESULT OnWizFinish(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // push button handlers
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    // listview handlers
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

public:
    HRESULT SetNetcfg(INetCfg * pnc);
    HRESULT SetAdapter(INetCfgComponent * pnccAdapter);
    VOID    SetReadOnlyMode(BOOL fReadOnly) {m_fReadOnly = fReadOnly;}

private:

    // The INetCfg that has write access
    INetCfg * m_pnc;

    // The Adapter used in this connection
    INetCfgComponent * m_pnccAdapter;

    // IUnknown to pass to property UIs to get to the context
    IUnknown * m_punk;

    // The list view handle
    HWND m_hwndList;

    // Handles
    HANDLES m_Handles;

    // Setup can be in readonly mode
    BOOL    m_fReadOnly;

    // The collection of BindingPathObj
    // This is for handling the checklist state stuff
    ListBPObj m_listBindingPaths;

    HIMAGELIST m_hilCheckIcons;

    HWND m_hwndDataTip;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanuiobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N U I O B J. H
//
//  Contents:   Declaration of the LAN ConnectionUI object
//
//  Notes:
//
//  Created:    tongl   8 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "lanwiz.h"
#include "ncatlps.h"
#include "netshell.h"
#include "netcfgn.h"
#include "nsres.h"
#include "wzcui.h"

class ATL_NO_VTABLE CLanConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CLanConnectionUi, &CLSID_LanConnectionUi>,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionUiLock,
    public INetConnectionWizardUi,
    public INetLanConnectionUiInfo,
    public INetLanConnectionWizardUi
{
public:
    CLanConnectionUi()
    {
        m_pconn = NULL;
        m_pspNet = NULL;
        m_pspAdvanced = NULL;
        m_pspSecurity = NULL;
        m_pspWZeroConf = NULL;
        m_pspHomenetUnavailable = NULL;
        m_fReadOnly = FALSE;
        m_fNeedReboot = FALSE;
        m_fAccessDenied = FALSE;

        m_pContext = NULL;
        m_pnc = NULL;
        m_pnccAdapter = NULL;
        m_pWizPage = NULL;
        m_pLanConn = NULL;
        m_strConnectionName = c_szEmpty;
    }

    ~CLanConnectionUi()
    {
        ReleaseObj(m_pconn);
        delete m_pspNet;
        delete m_pspAdvanced;
        delete m_pspSecurity;
        delete m_pspWZeroConf;
        delete m_pspHomenetUnavailable;

        ReleaseObj(m_pnc);
        ReleaseObj(m_pnccAdapter);
        ReleaseObj(m_pContext);
        delete m_pWizPage;
        ReleaseObj(m_pLanConn);
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_LAN_UI)

    BEGIN_COM_MAP(CLanConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionUiLock)
        COM_INTERFACE_ENTRY(INetConnectionWizardUi)
        COM_INTERFACE_ENTRY(INetLanConnectionUiInfo)
        COM_INTERFACE_ENTRY(INetLanConnectionWizardUi)
    END_COM_MAP()

    // INetConnectionConnectUi
    //
    STDMETHOD (SetConnection)(INetConnection* pCon);
    STDMETHOD (Connect)(HWND hwndParent, DWORD dwFlags);
    STDMETHOD (Disconnect)(HWND hwndParent, DWORD dwFlags);

    // INetConnectionPropertyUi2
    //
    STDMETHOD (AddPages)(HWND hwndParent,
                         LPFNADDPROPSHEETPAGE pfnAddPage,
                         LPARAM lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );

    // INetConnectionWizardUi
    STDMETHOD (QueryMaxPageCount) (INetConnectionWizardUiContext* pContext,
                                   DWORD*    pcMaxPages);
    STDMETHOD (AddPages) (  INetConnectionWizardUiContext* pContext,
                            LPFNADDPROPSHEETPAGE pfnAddPage,
                            LPARAM lParam);

    STDMETHOD (GetNewConnectionInfo) (
        DWORD*              pdwFlags,
        NETCON_MEDIATYPE*   pMediaType);

    STDMETHOD (GetSuggestedConnectionName)(PWSTR* ppszwSuggestedName);

    STDMETHOD (SetConnectionName) (PCWSTR pszwConnectionName);
    STDMETHOD (GetNewConnection) (INetConnection**  ppCon);

    //  INetLanConnectionWizardUi
    STDMETHOD (SetDeviceComponent) (const GUID * pguid);

    // INetLanConnectionUiInfo
    STDMETHOD (GetDeviceGuid) (GUID * pguid);

    // INetConnectionUiLock
    STDMETHOD (QueryLock) (PWSTR* ppszwLockHolder);

public:

private:

    //==============
    // Data members
    //==============

    INetConnection *    m_pconn;        // Pointer to LAN connection object
    CPropSheetPage *    m_pspNet;       // Networking property page
    CPropSheetPage *    m_pspAdvanced;     // 'Advanced' property page
    CPropSheetPage *    m_pspHomenetUnavailable;  // Homenet is unavailable page
    CPropSheetPage *    m_pspSecurity;  // EAPOL security page
    CWZeroConfPage *    m_pspWZeroConf; // Wireless Zero Configuration page

    // =====================
    // Wizard data members
    // =====================
    INetConnectionWizardUiContext* m_pContext; // The WizardUI context
    INetCfg * m_pnc;                    // This is the writable INetCfg passed to the Lan Wizard
    INetCfgComponent * m_pnccAdapter;   // The adapter that represents this connection
    tstring m_strConnectionName;        // Unique name of this LAN connection
    class CLanWizPage * m_pWizPage;     // Lan wizard page
    INetLanConnection   * m_pLanConn;   // Lan conection created through the wizard

    BOOLEAN m_fReadOnly;    // If TRUE, then access to inetcfg is RO
    BOOLEAN m_fNeedReboot;  // If TRUE, then we are readonly becuase INetCfg needs a reboot
    BOOLEAN m_fAccessDenied;// If TRUE, the user is not logged on as admin

    // =====================
    // Wizard help functions
    // =====================
    HRESULT HrSetupWizPages(INetConnectionWizardUiContext* pContext,
                            HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    HRESULT HrGetLanConnection(INetLanConnection ** ppcon);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanwiz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N W I Z . C P P
//
//  Contents:   Implementation of the LAN wizard page
//
//  Notes:
//
//  Author:    tongl   16 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "devdatatip.h"
#include "lanwiz.h"
#include "ncsetup.h"
#include "util.h"
#include "ncui.h"

// Constructor and Destructor
CLanWizPage::CLanWizPage(IUnknown * punk)
{
    Assert(punk);
    m_punk = punk;

    m_pnc = NULL;
    m_pnccAdapter = NULL;
    m_hwndList = NULL;
    m_hilCheckIcons = NULL;
    m_fReadOnly = FALSE;
    m_hwndDataTip = NULL;
}

// Methods that set the Netcfg interfaces the dialog needs.
// Should be only by INetLanConnectionWizardUi->SetDeviceComponent
// and right before initializing the wizard dialog each time
HRESULT CLanWizPage::SetNetcfg(INetCfg * pnc)
{
    Assert(pnc);

    if (m_pnc)
    {
        // Release it
        ReleaseObj(m_pnc);
    }

    m_pnc = pnc;
    AddRefObj(pnc);

    return S_OK;
}

HRESULT CLanWizPage::SetAdapter(INetCfgComponent * pnccAdapter)
{
    Assert(pnccAdapter);

    if (m_pnccAdapter)
    {
        // Release it
        ReleaseObj(m_pnccAdapter);
    }

    m_pnccAdapter = pnccAdapter;
    AddRefObj(pnccAdapter);

    return S_OK;
}

// Initialize dialog
LRESULT CLanWizPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    m_hwndList = GetDlgItem(IDC_LVW_COMPLIST);

    m_Handles.m_hList =         m_hwndList;
    m_Handles.m_hAdd =          GetDlgItem(IDC_PSH_ADD);
    m_Handles.m_hRemove =       GetDlgItem(IDC_PSH_REMOVE);
    m_Handles.m_hProperty =     GetDlgItem(IDC_PSH_PROPERTIES);
    m_Handles.m_hDescription =  GetDlgItem(IDC_TXT_COMPDESC);

    // set the font of the device description: IDC_DEVICE_DESC to bold
    HFONT hCurFont = (HFONT)::SendMessage(GetDlgItem(IDC_DEVICE_DESC), WM_GETFONT, 0,0);

    if (hCurFont) // if not using system font
    {
        int cbBuffer;
        cbBuffer = GetObject(hCurFont, 0, NULL);

        if (cbBuffer)
        {
            void * lpvObject = new BYTE[cbBuffer];

            if (lpvObject)
            {
                int nRet = GetObject(hCurFont, cbBuffer, lpvObject);

                if (nRet)
                {
                    LOGFONT * pLogFont =
                        reinterpret_cast<LOGFONT *>(lpvObject);

                    pLogFont->lfWeight = FW_BOLD;

                    HFONT hNewFont = CreateFontIndirect(pLogFont);

                    if (hNewFont)
                    {
                        ::SendMessage(GetDlgItem(IDC_DEVICE_DESC), WM_SETFONT, (WPARAM)hNewFont, TRUE);
                    }
                }

                delete[] lpvObject;
            }
        }
    }

    return 0;
}

// Destroy dialog
LRESULT CLanWizPage::OnDestroyDialog(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    // Release netcfg interfaces, they should be reinitialized
    // the next time the dialog is brought up
    ReleaseObj(m_pnc);
    ReleaseObj(m_pnccAdapter);

    UninitListView(m_hwndList);

    // Destroy our check icons
    if (m_hilCheckIcons)
    {
        ImageList_Destroy(m_hilCheckIcons);
    }

    // release binding path objects and component objects we kept
    ReleaseAll(m_hwndList, &m_listBindingPaths);

    return 0;
}

// Wizard page notification handlers
LRESULT CLanWizPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // Fill in the adapter description
    AssertSz(m_pnccAdapter, "We don't have a valid adapter!");

    if (m_pnccAdapter)
    {
        PWSTR pszwDeviceName;

        hr = m_pnccAdapter->GetDisplayName(&pszwDeviceName);
        if (SUCCEEDED(hr))
        {
            SetDlgItemText(IDC_DEVICE_DESC, pszwDeviceName);

            CoTaskMemFree(pszwDeviceName);
        }

        // Create a data tip for the device to display location
        // info and MAc address.
        //
        PWSTR pszDevNodeId = NULL;
        PWSTR pszBindName = NULL;

        // Get the pnp instance id of the device.
        (VOID) m_pnccAdapter->GetPnpDevNodeId (&pszDevNodeId);

        // Get the device's bind name
        (VOID) m_pnccAdapter->GetBindName (&pszBindName);

        // Create the tip and associate it with the description control.
        // Note if the tip was already created, then only the text
        // will be modified.
        //
        CreateDeviceDataTip (m_hWnd, &m_hwndDataTip, IDC_DEVICE_DESC,
                pszDevNodeId, pszBindName);

        CoTaskMemFree (pszDevNodeId);
        CoTaskMemFree (pszBindName);
    }

    // refresh the listview for the new adapter
    // Now setup the BindingPathObj collection and List view
    hr = HrInitListView(m_hwndList, m_pnc, m_pnccAdapter,
                        &m_listBindingPaths, &m_hilCheckIcons);

    // now set the buttons
    LvSetButtons(m_hWnd, m_Handles, m_fReadOnly, m_punk);

    ::PostMessage(::GetParent(m_hWnd),
                  PSM_SETWIZBUTTONS,
                  (WPARAM)0,
                  (LPARAM)(PSWIZB_BACK | PSWIZB_NEXT));

    return 0;
}

LRESULT CLanWizPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL    fError;

    fError = FValidatePageContents( m_hWnd,
                                    m_Handles.m_hList,
                                    m_pnc,
                                    m_pnccAdapter,
                                    &m_listBindingPaths
                                  );

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);
    return fError;
}

// Push button handlers
LRESULT CLanWizPage::OnAdd(WORD wNotifyCode, WORD wID,
                           HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // $REVIEW(tongl 1/7/99): We can't let user do anything till this
    // is returned (Raid #258690)

    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_PSB_Add,
                                 IDC_PSB_Remove,
                                 IDC_PSB_Properties};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    // disable wizard buttons till we are done
    ::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, 0);

    hr = HrLvAdd(m_hwndList, m_hWnd, m_pnc, m_pnccAdapter, &m_listBindingPaths);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_Handles, m_fReadOnly, m_punk);

    ::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, (LPARAM)(PSWIZB_NEXT | PSWIZB_BACK));

    TraceError("CLanWizPage::OnAdd", hr);
    return 0;
}

LRESULT CLanWizPage::OnRemove(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // $REVIEW(tongl 1/7/99): We can't let user do anything till this
    // is returned (Raid #258690)

    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_PSB_Add,
                                 IDC_PSB_Remove,
                                 IDC_PSB_Properties};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    hr = HrLvRemove(m_hwndList, m_hWnd, m_pnc, m_pnccAdapter,
                    &m_listBindingPaths);

    if (NETCFG_S_REBOOT == hr)
    {
        // tell the user the component they removed cannot be re-added until
        // setup completes
        //$REVIEW - scottbri - Notifing the user maybe optional,
        //$REVIEW              as little can be done on their part
    }

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_Handles, m_fReadOnly, m_punk);

    TraceError("CLanWizPage::OnRemove", hr);
    return 0;
}

LRESULT CLanWizPage::OnProperties(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // $REVIEW(tongl 1/7/99): We can't let user do anything till this
    // is returned (Raid #258690)

    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_PSB_Add,
                                 IDC_PSB_Remove,
                                 IDC_PSB_Properties};

    EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);

    // disable wizard buttons till we are done
    ::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, 0);

    hr = HrLvProperties(m_hwndList, m_hWnd, m_pnc, m_punk,
                        m_pnccAdapter, &m_listBindingPaths, NULL);

    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_Handles, m_fReadOnly, m_punk);

    ::SendMessage(GetParent(), PSM_SETWIZBUTTONS, 0, (LPARAM)(PSWIZB_NEXT | PSWIZB_BACK));

    TraceError("CLanWizPage::OnProperties", hr);
    return 0;
}

// List view handlers
LRESULT CLanWizPage::OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    if (idCtrl == IDC_LVW_COMPLIST)
    {
        OnListClick(m_hwndList, m_hWnd, m_pnc, m_punk,
                    m_pnccAdapter, &m_listBindingPaths, FALSE);
    }

    return 0;
}

LRESULT CLanWizPage::OnDbClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    if (idCtrl == IDC_LVW_COMPLIST)
    {
        // If we're in read-only mode, treat a double click as a single click
        //
        OnListClick(m_hwndList, m_hWnd, m_pnc, m_punk,
                    m_pnccAdapter, &m_listBindingPaths, !m_fReadOnly);
    }

    return 0;
}

LRESULT CLanWizPage::OnKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    if (idCtrl == IDC_LVW_COMPLIST)
    {
        LV_KEYDOWN* plvkd = (LV_KEYDOWN*)pnmh;
        OnListKeyDown(m_hwndList, &m_listBindingPaths, plvkd->wVKey);
    }

    return 0;
}

LRESULT CLanWizPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // Reset the buttons and the description text based on the changed selection
    LvSetButtons(m_hWnd, m_Handles, m_fReadOnly, m_punk);

    return 0;
}

LRESULT CLanWizPage::OnDeleteItem(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    LvDeleteItem(m_hwndList, pnmlv->iItem);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LanUI.rc
//
#define IDC_CB_PrivateLan               1516
#define IDC_ST_HomeNetworkLabel         1517
#define IDC_GB_PrivateLan               1518
#define IDC_ST_PositionBar              1519
#define IDC_CHK_BeaconControl           1520
#define IDC_ST_ICSLINK                  1521
#define IDC_ST_ICFLINK                  1522
#define IDC_CHK_Default_Client          15000
#define IDC_CHK_ShowIcon                15001
#define IDC_DEVICE_DESC                 15002
#define IDC_EDT_Adapter                 15003
#define IDC_LVW_COMPLIST                15004
#define IDC_LVW_Lan_Advanced            15005
#define IDC_LVW_Lan_Components          15006
#define IDC_LVW_Net_Components          15007
#define IDC_PSB_Add                     15008
#define IDC_PSB_Component_Add           15009
#define IDC_PSB_Down                    15010
#define IDC_PSB_Properties              15011
#define IDC_PSB_Remove                  15012
#define IDC_PSB_Up                      15013
#define IDC_PSH_ADD                     15014
#define IDC_PSH_PROPERTIES              15015
#define IDC_PSH_REMOVE                  15016
#define IDC_TXT_COMPDESC                15017
#define IDC_TXT_Caption                 15018
#define IDC_TXT_Component_Desc          15019
#define IDC_TXT_Desc                    15020
#define IDC_EDT_Adapter_Border          15021
#define IDC_CHK_Shared                  15022
#define IDC_CHK_DemandDial              15023
#define IDC_GRP_DemandDial              15024
#define IDC_TXT_DemandDial              15025
#define IDC_GB_Shared                   15026
#define IDC_EDT_PrivateLan              15027
#define IDC_DEVICE_MAC_ADDR             15028
#define IDC_TXT_MAC_ADDR                15029
#define IDC_PSB_Settings                15030
#define IDC_PSB_Configure               15031
#define IDC_CHK_Firewall                15032
#define IDC_TXT_EAP_TYPE                15033
#define CID_CA_RB_MachineAuth           15034
#define CID_CA_RB_GuestAuth             15035
#define CID_CA_RB_Eap                   15036
#define CID_CA_LB_EapPackages           15037
#define CID_CA_PB_Properties            15038
#define IDC_WZC_DLG_PROPS               15039
#define IDC_WZC_DLG_VPROPS              15040
#define IDC_WZC_EDIT_SSID               15041
#define IDC_WZC_LBL_KLen                15047
#define IDC_WZC_CB_KLen                 15048
#define IDC_WZC_LBL_KFmt                15049
#define IDC_WZC_CB_KFmt                 15050
#define IDC_WZC_LBL_KMat                15051
#define IDC_WZC_EDIT_KMat               15052
#define IDC_WZC_LBL_KIdx                15053
#define IDC_WZC_EDIT_KIdx               15054
#define IDC_WZC_CHK_EnableWZC           15055
#define IDC_WZC_GRP_NetType             15056
#define IDC_WZC_GRP_Wep                 15057
#define IDC_WZC_LBL_VisNet              15058
#define IDC_WZC_LBL_PrefNet             15059
#define IDC_WZC_LVW_BSSIDList           15060
#define IDC_WZC_LVW_StSSIDList          15061
#define IDC_WZC_BTN_UP                  15062
#define IDC_WZC_BTN_DOWN                15063
#define IDC_WZC_BTN_COPY                15064
#define IDC_WZC_BTN_RFSH                15065
#define IDC_WZC_BTN_ADD                 15066
#define IDC_WZC_BTN_REM                 15067
#define IDC_WZC_CHK_Fallback            15068
#define IDC_TXT_SHAREDCONNECTION        15069
#define IDC_TXT_CONNECTTO               15070
#define IDD_LANWIZ_DLG                  15999
#define IDD_LAN_ADVANCED                16000
#define IDD_LAN_COMPONENT_ADD           16001
#define IDD_LAN_CONNECT                 16002
#define IDD_LAN_GENERAL                 16003
#define IDD_LAN_NETWORKING              16004
#define IDI_Device_Icon                 16006
#define IDD_LAN_SECURITY                16007
#define IDS_LANUI_ERROR_CAPTION         16008
#define IDS_LANUI_GENERIC_ADD_ERROR     16009
#define IDS_LANUI_GENERIC_REMOVE_ERROR  16011
#define IDS_LANUI_LOCK_DESC             16012
#define IDS_LANUI_STILL_REFERENCED      16013
#define IDS_LANWIZ_SUBTITLE             16014
#define IDS_LANWIZ_TITLE                16015
#define IDS_LAN_CAPTION                 16016
#define IDS_LAN_CLIENT                  16017
#define IDS_LAN_CLIENT_DESC             16018
#define IDS_LAN_CONNECTED               16019
#define IDS_LAN_CONNECT_CAPTION         16020
#define IDS_LAN_CONNECT_FAILED          16021
#define IDS_LAN_DEFAULT_CONN_NAME       16022
#define IDS_LAN_PROTOCOL                16023
#define IDS_LAN_PROTOCOL_DESC           16024
#define IDS_LAN_REMOVE_CAPTION          16025
#define IDS_LAN_REMOVE_WARNING          16026
#define IDS_LAN_SERVICE                 16027
#define IDS_LAN_SERVICE_DESC            16028
#define IDS_UNKNOWN_NETWORK_CARD        16029
#define IDS_LAN_SHARE_FAILED            16030
#define IDS_LAN_UNSHARE_FAILED          16031
#define IDS_LAN_CHANGE_SHARED_CONNECTION 16032
#define IDS_LAN_ENABLE_SHARED_ACCESS    16033
#define IDS_ATM_DEFAULT_CONN_NAME       16034
#define IDS_ELAN_DEFAULT_CONN_NAME      16035
#define IDS_LANUI_APPLYFAILED           16036
#define IDS_LANUI_NOPROTOCOL_CAPTION    16037
#define IDS_LANUI_NOPROTOCOL            16038
#define IDS_LANUI_INTENTCHECK           16039
#define IDS_LANUI_READONLY              16040
#define IDS_LANUI_NEEDS_REBOOT          16041
#define IDS_LANUI_ACCESS_DENIED         16042
#define IDS_NEWLINE                     16043
#define IDS_LANUI_REQUIRE_DISCONNECT_REMOVE 16044
#define IDS_LANUI_REQUIRE_DISCONNECT_ADD 16045
#define IDS_LANUI_REQUIRE_REBOOT_ADD    16046
#define IDS_LANUI_REQUIRE_REBOOT_REMOVE 16047
#define IDS_LANWIZ_CUSTOM_CHANGE        16048
#define IDS_LANUI_SHARING_CONFLICT      16049
#define IDS_SLOT_PORT_LOCATION          16050
#define IDS_SLOT_LOCATION               16051
#define IDS_PORT_LOCATION               16052
#define IDS_MAC_ADDRESS                 16053
#define IDC_TXT_LISTBOXLABEL            16055
#define IDC_GRP_DESCRIPTIONFRAME        16056
#define IDC_TXT_BRIDGEDCONNECTION       16057
#define IDD_LAN_NETWORKING_BRIDGED      16058
#define IDD_LAN_NETWORKING_MACBRIDGE    16059
#define IDC_LVW_Bridged_Adapters        16060
#define IDS_LANUI_BRIDGE_CAPTION        16062
#define IDS_SHAREDACCESSUI_LOCK_DESC    16063
#define IDD_SHAREDACCESS_GENERAL        16064
#define IDC_ST_HNWLINK                  16065
#define IDD_DISABLEFIREWALLWARNING      16066
#define IDC_ST_SAICON                   16067
#define IDC_ST_ICSTEXT                  16068
#define IDC_CHK_DISABLEFIREWALLWARNING  16069
#define IDS_SHAREDACCESSUI_CONNECTING   16070
#define IDS_SHAREDACCESSUI_CONNECTED    16071
#define IDS_SHAREDACCESS_SELECTADAPTER  16072
#define IDS_SHAREDACCESS_SELECTADAPTERERROR 16073
#define IDS_ADVANCEDPAGE_NOWMI_ERROR    16074
#define IDS_ADVANCEDPAGE_STORE_ERROR    16075
#define IDD_LAN_HOMENETUNAVAILABLE      16076
#define IDC_ST_ERRORTEXT                16077
#define IDD_LAN_WZEROCONF               16077
#define IDS_WZC_AUTH_OPEN               16100
#define IDS_WZC_AUTH_SHARED             16101
#define IDS_WZC_AUTH_AUTO               16102
#define IDS_WZC_ERR_DUPSSID             16106
#define IDS_WZC_PRIV_ABS                16108
#define IDS_WZC_PRIV_REQ                16109
#define IDS_WZC_WEP_DISABLED            16110
#define IDS_WZC_WEP_ENABLED             16111
#define IDS_WZC_KLEN_40X                16112
#define IDS_WZC_KLEN_104X               16113
#define IDS_WZC_KLEN_40A                16114
#define IDS_WZC_KLEN_104A               16115
#define IDS_WZC_KFMT_X                  16116
#define IDS_WZC_KFMT_A                  16117
#define IDS_WZC_KERR_SHORT              16118
#define IDS_WZC_KERR_LARGE              16119
#define IDS_WZC_KERR_NONX               16120
#define IDS_WZC_KERR_IDX                16121
#define IDS_SHAREDACCESSUI_ACCESSDENIED 16122
#define IDS_SHAREDACCESSSETTINGS        16123
#define IDS_WZC_INFRA_IBSS2             16124
#define IDS_WZC_INFRA_INFRA2            16125
#define IDS_WZC_INFRA_IBSS              16126
#define IDS_WZC_INFRA_INFRA             16127
#define IDS_DIRTY_PROPERTIES            16128
#define IDS_WZC_LEARNCMD                16129

// New resources for DSheldon's visual refresh
// Controls
#define IDC_AVAILLABEL                  1000
#define IDC_PREFERLABEL                 1001
#define IDC_ADVANCEDLABEL               1002
#define IDC_ADVANCED                    1003
#define IDC_ANYNET                      1004
#define IDC_ADHOC                       1005
#define IDC_INFRA                       1006
#define IDC_PROPERTIES                  1007
#define IDC_USEPW                       1008
#define IDC_USEHARDWAREPW               1009
#define IDC_SHAREDMODE                  1010
#define IDC_LEARNABOUT                  1011

// Dialogs
#define IDD_LAN_WZC_ADVANCED            1000

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        16055
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         15070
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\saui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A U I . C P P
//
//  Contents:   Shared Access connection object UI
//
//  Notes:
//
//  Author:     danielwe   16 Oct 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "saui.h"
#include "ncreg.h"
#include "nsres.h"

extern const WCHAR c_szNetCfgHelpFile[];
static const WCHAR c_szShowIcon[]                 = L"Show Icon";
static const WCHAR c_szSharedAccessClientKeyPath[] = L"System\\CurrentControlSet\\Control\\Network\\SharedAccessConnection";

CSharedAccessPage::CSharedAccessPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    BOOLEAN fReadOnly,
    BOOLEAN fNeedReboot,
    BOOLEAN fAccessDenied,
    const DWORD * adwHelpIDs)
{
    m_pconn = pconn;      // REVIEW addref?
    m_pnc = pnc;
    m_punk = punk;
    m_fReadOnly = fReadOnly;
    m_adwHelpIDs = adwHelpIDs;
    m_fNetcfgInUse = FALSE;
    m_pNetSharedAccessConnection = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::~CSharedAccessPage
//
//  Purpose:    Destroys the CSharedAccessPage object
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing
//
//  Author:     danielwe   25 Feb 1998
//
//  Notes:
//
CSharedAccessPage::~CSharedAccessPage()
{
    if (m_pnc)
    {
        INetCfgLock *   pnclock;

        if (SUCCEEDED(m_pnc->QueryInterface(IID_INetCfgLock,
                                            (LPVOID *)&pnclock)))
        {
            (VOID)pnclock->ReleaseWriteLock();
            ReleaseObj(pnclock);
        }
    }

    if(NULL != m_pNetSharedAccessConnection)
    {
        ReleaseObj(m_pNetSharedAccessConnection);
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CSharedAccessPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr;
    
    // set the text field
    NETCON_PROPERTIES* pProperties;
    hr = m_pconn->GetProperties(&pProperties);
    if(SUCCEEDED(hr))
    {
        SetDlgItemText(IDC_EDT_Adapter, pProperties->pszwDeviceName);

        FreeNetconProperties(pProperties);
    }

    // set the icon    
    int cx = GetSystemMetrics(SM_CXSMICON);
    int cy = GetSystemMetrics(SM_CYSMICON);
    
    HICON hIcon = (HICON) LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_CFI_SAH_LAN), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR);
    if(NULL != hIcon)
    {
        SendDlgItemMessage(IDI_Device_Icon, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0);
        ::ShowWindow(GetDlgItem(IDI_Device_Icon), SW_SHOW);
    }

    ASSERT(NULL == m_pNetSharedAccessConnection);  // make sure we don't leak a ref
    hr = HrQIAndSetProxyBlanket(m_pconn, &m_pNetSharedAccessConnection);
    if (SUCCEEDED(hr))
    {
        SHAREDACCESSCON_INFO ConnectionInfo;
        hr = m_pNetSharedAccessConnection->GetInfo(SACIF_ICON, &ConnectionInfo);
        if (SUCCEEDED(hr))
        {
            CheckDlgButton(IDC_CHK_ShowIcon, ConnectionInfo.fShowIcon);
        }
        // released in destructor
    }
    

    
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CSharedAccessPage::OnContextMenu(UINT uMsg,
                           WPARAM wParam,
                           LPARAM lParam,
                           BOOL& fHandled)
{
    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CSharedAccessPage::OnHelp( UINT uMsg,
                     WPARAM wParam,
                     LPARAM lParam,
                     BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::OnDestroy
//
//  Purpose:    Called when the dialog page is destroyed
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
LRESULT CSharedAccessPage::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam,
                               BOOL& bHandled)
{
    HICON hIcon;
    hIcon = reinterpret_cast<HICON>(SendDlgItemMessage(IDI_Device_Icon, STM_GETICON, 0, 0));
    if (hIcon)
    {
        DestroyIcon(hIcon);
    }
    return 0;
}
//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::OnApply
//
//  Purpose:    Called when the Networking page is applied
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   29 Oct 1997
//
//  Notes:
//
LRESULT CSharedAccessPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    
    if(NULL != m_pNetSharedAccessConnection)
    {
        SHAREDACCESSCON_INFO ConnectionInfo = {0};
        ConnectionInfo.fShowIcon = IsDlgButtonChecked(IDC_CHK_ShowIcon);
        hr = m_pNetSharedAccessConnection->SetInfo(SACIF_ICON, &ConnectionInfo);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessPage::OnCancel
//
//  Purpose:    Called when the Networking page is cancelled.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []
//      bHandled []
//
//  Returns:
//
//  Author:     danielwe   3 Jan 1998
//
//  Notes:      Added the check to see if we are in the middle of 
//              installing components, in which case we can't 
//              uninitialize INetCfg (Raid #258690).
//
LRESULT CSharedAccessPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    AssertSz(m_pnc, "I need a NetCfg object!");

    if (!m_fNetcfgInUse)
    {
        (VOID) m_pnc->Uninitialize();
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, m_fNetcfgInUse);
    return m_fNetcfgInUse;
}
 
LRESULT CSharedAccessPage::OnClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (wID != IDC_PSB_Settings)
        return bHandled = FALSE;

    /*  new improved way:
        get upnp service from INetSharedAccessConnection
        call hnetcfg's HNetGetSharingServicesPage
        create the property page
    */
    
    NETCON_MEDIATYPE MediaType;
    NETCON_PROPERTIES* pProperties;
    HRESULT hr = m_pconn->GetProperties(&pProperties);
    if (SUCCEEDED(hr))
    {
        MediaType = pProperties->MediaType;
        FreeNetconProperties(pProperties);
    }
    else
    {
        return bHandled = FALSE;
    }

    if ((MediaType != NCM_SHAREDACCESSHOST_LAN) &&
        (MediaType != NCM_SHAREDACCESSHOST_RAS) )
        return bHandled = FALSE;

    BOOL b = FALSE;

    CComPtr<IUPnPService> spUPS = NULL;
    hr = m_pNetSharedAccessConnection->GetService (
                    MediaType == NCM_SHAREDACCESSHOST_LAN ?
                           SAHOST_SERVICE_WANIPCONNECTION :
                           SAHOST_SERVICE_WANPPPCONNECTION,
                    &spUPS);
    if (spUPS) {
        // must run-time load "HNetGetSharingServicesPage",
        // else netshell.dll and hnetcfg.dll are cross-linked.
        HINSTANCE hinstDll = LoadLibrary (TEXT("hnetcfg.dll"));
        if (!hinstDll)
            hr = HRESULT_FROM_WIN32 (GetLastError());
        else {
            HRESULT (APIENTRY *pfnHNetGetSharingServicesPage)(IUPnPService *, PROPSHEETPAGE *);
            pfnHNetGetSharingServicesPage = (HRESULT (APIENTRY *)(IUPnPService *, PROPSHEETPAGE *))
                GetProcAddress (hinstDll, "HNetGetSharingServicesPage");
            if (!pfnHNetGetSharingServicesPage)
                hr = HRESULT_FROM_WIN32 (GetLastError());
            else {
                PROPSHEETPAGE psp;
                ZeroMemory (&psp, sizeof(psp));
                psp.dwSize = sizeof(psp);
                psp.lParam = (LPARAM)m_hWnd;    // double-secret place to hang owner window (will get wiped)
                hr = pfnHNetGetSharingServicesPage (spUPS, &psp);
                if (SUCCEEDED(hr)) {
                    b = TRUE;
                    
                    PROPSHEETHEADER psh;
                    ZeroMemory (&psh, sizeof(psh));
                    psh.dwSize     = PROPSHEETHEADER_V1_SIZE;
                    psh.dwFlags    = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW | PSH_NOCONTEXTHELP;
                    psh.hwndParent = m_hWnd;
                    psh.pszCaption = (LPCTSTR)MAKEINTRESOURCE (IDS_SHAREDACCESSSETTINGS);
                    psh.hInstance  = _Module.GetResourceInstance();
                    psh.nPages     = 1;
                    psh.ppsp       = &psp;
                
                    PropertySheet (&psh);
                }
            }
            FreeLibrary (hinstDll);
        }
    }
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\lanwizfn.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N W I Z F N. C P P
//
//  Contents:   Help member functions of the LAN ConnectionUI object
//              used to implement the Lan Connection Wizard
//
//  Notes:
//
//  Created:     tongl   24 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nsbase.h"
#include "lanuiobj.h"
#include "lancmn.h"
#include "lanwiz.h"
#include "ncnetcon.h"


//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::HrSetupWizPages
//
//  Purpose:    Setup the needed wizard pages based on the context
//
//  Arguments:
//      pContext    [in]
//      pahpsp      [out]
//      pcPages     [out]
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  9 Oct 1997
//
//  Notes:
//
HRESULT CLanConnectionUi::HrSetupWizPages(INetConnectionWizardUiContext* pContext,
                                          HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;

    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    // We now have only 1 page no matter what
    cPages = 1;

    // Lan wizard page
    if (!m_pWizPage)
        m_pWizPage = new CLanWizPage(static_cast<INetConnectionPropertyUi *>(this));

    // Allocate a buffer large enough to hold the handles to all of our
    // wizard pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);

    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // Check for read-only mode
    if (UM_READONLY == pContext->GetUnattendedModeFlags())
    {
        // If read-only, remember this
        m_pWizPage->SetReadOnlyMode(TRUE);
    }

    cPages =0;

    DWORD dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    PCWSTR pszTitle = SzLoadIds(IDS_LANWIZ_TITLE);
    PCWSTR pszSubTitle = SzLoadIds(IDS_LANWIZ_SUBTITLE);

    ahpsp[cPages++] = m_pWizPage->CreatePage(IDD_LANWIZ_DLG, dwFlags,
                                             pszTitle,
                                             pszSubTitle);

    *pahpsp = ahpsp;
    *pcPages = cPages;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanConnectionUi::HrGetLanConnection
//
//  Purpose:    Return an existing connection or create a new one if none
//              exists
//
//  Arguments:
//
//  Returns:    HRESULT, Error code.
//
//  Author:     tongl  30 Oct 1997
//
//  Notes:
//
HRESULT CLanConnectionUi::HrGetLanConnection(INetLanConnection ** ppLanCon)
{
    Assert(ppLanCon);

    // Initialize output parameter.
    //
    *ppLanCon = NULL;

    INetLanConnection*  pLanCon          = NULL;
    BOOL                fFoundConnection = FALSE;

    INetConnectionManager* pConMan;
    HRESULT hr = HrCreateInstance(
        CLSID_LanConnectionManager, 
        CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pConMan);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        GUID guidAdapter;
        hr = m_pnccAdapter->GetInstanceGuid(&guidAdapter);

        CIterNetCon     ncIter(pConMan, NCME_DEFAULT);
        INetConnection* pCon;
        while (SUCCEEDED(hr) && !fFoundConnection &&
               (S_OK == ncIter.HrNext(&pCon)))
        {
            if (FPconnEqualGuid (pCon, guidAdapter))
            {
                hr = HrQIAndSetProxyBlanket(pCon, &pLanCon);
                if (SUCCEEDED(hr))
                {
                    fFoundConnection = TRUE;
                }
            }

            ReleaseObj(pCon);
        }

#if DBG
        if (SUCCEEDED(hr) && !fFoundConnection)
        {
            // If it's not caused by a non-functioning device, we need to assert

            ULONG ulProblem;
            HRESULT hrTmp = m_pnccAdapter->GetDeviceStatus(&ulProblem);

            if (SUCCEEDED(hrTmp))
            {
                if (FIsDeviceFunctioning(ulProblem))
                {
                    TraceTag(ttidLanUi, "m_pnccAdapter->GetDeviceStatus: ulProblem "
                             "= 0x%08X.", ulProblem);

                    AssertSz(FALSE, "How come the LAN connection does not exist after enumeration?");
                }
            }
        }
#endif

        ReleaseObj (pConMan);
    }

    if ((S_OK == hr) && fFoundConnection)
    {
        Assert(pLanCon);
        *ppLanCon = pLanCon;
    }
    else
    {
        TraceTag(ttidError, "Error! CLanConnectionUi::HrGetLanConnection is called on non-existing adapter.");
        hr = E_FAIL;
    }

    TraceError("CLanConnectionUi::HrGetLanConnection", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\saui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A U I . H
//
//  Contents:   Shared Acces connection UI object.
//
//  Notes:
//
//  Author:     danielwe   16 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "ncatlps.h"
#include "resource.h"
#include "netshell.h"
#include "util.h"


class CSharedAccessPage : public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CSharedAccessPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        NOTIFY_CODE_HANDLER(PSN_QUERYCANCEL, OnCancel)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        COMMAND_CODE_HANDLER (BN_CLICKED, OnClicked)
    END_MSG_MAP()

    CSharedAccessPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        BOOLEAN fReadOnly,
        BOOLEAN fNeedReboot,
        BOOLEAN fAccessDenied,
        const DWORD * adwHelpIDs = NULL);
    ~CSharedAccessPage();

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                    LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnClicked (WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    INetConnection *        m_pconn;
    INetSharedAccessConnection* m_pNetSharedAccessConnection;
    INetCfg *               m_pnc;
    IUnknown *              m_punk;
    BOOLEAN     m_fReadOnly;
    const DWORD *           m_adwHelpIDs;
    BOOLEAN m_fNetcfgInUse;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\sauiobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A U I O B J. H
//
//  Contents:   Declaration of the Shared Access ConnectionUI object
//
//  Notes:
//
//  Created:    tongl   8 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "nsbase.h"     // must be first to include atl

#include "ncatlps.h"
#include "netshell.h"
#include "netcfgn.h"
#include "nsres.h"
#include "resource.h"


class ATL_NO_VTABLE CSharedAccessConnectionUi :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CComCoClass <CSharedAccessConnectionUi, &CLSID_SharedAccessConnectionUi>,
    public INetConnectionConnectUi,
    public INetConnectionPropertyUi2,
    public INetConnectionUiLock
{
public:
    CSharedAccessConnectionUi()
    {
        m_pconn = NULL;
        m_pspSharedAccessPage = NULL;
        m_pnc = NULL;
        m_fReadOnly = FALSE;
        m_fNeedReboot = FALSE;
        m_fAccessDenied = FALSE;

    }

    ~CSharedAccessConnectionUi()
    {
        ReleaseObj(m_pconn);
    }

    DECLARE_REGISTRY_RESOURCEID(IDR_SHAREDACCESS_UI)

    BEGIN_COM_MAP(CSharedAccessConnectionUi)
        COM_INTERFACE_ENTRY(INetConnectionConnectUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi)
        COM_INTERFACE_ENTRY(INetConnectionPropertyUi2)
        COM_INTERFACE_ENTRY(INetConnectionUiLock)
    END_COM_MAP()

    // INetConnectionConnectUi
    //
    STDMETHOD (SetConnection)(INetConnection* pCon);
    STDMETHOD (Connect)(HWND hwndParent, DWORD dwFlags);
    STDMETHOD (Disconnect)(HWND hwndParent, DWORD dwFlags);

    // INetConnectionPropertyUi2
    //
    STDMETHOD (AddPages)(HWND hwndParent,
                         LPFNADDPROPSHEETPAGE pfnAddPage,
                         LPARAM lParam);

    STDMETHOD (GetIcon) (
        DWORD dwSize,
        HICON *phIcon );
    
    // INetConnectionUiLock
    STDMETHOD (QueryLock) (PWSTR* ppszwLockHolder);

public:

private:

    //==============
    // Data members
    //==============

    INetConnection *    m_pconn;        // Pointer to LAN connection object
    CPropSheetPage *    m_pspSharedAccessPage;       // Networking property page
    INetCfg * m_pnc;                    // This is the writable INetCfg passed to the Lan Wizard
    BOOLEAN m_fReadOnly;    // If TRUE, then access to inetcfg is RO
    BOOLEAN m_fNeedReboot;  // If TRUE, then we are readonly becuase INetCfg needs a reboot
    BOOLEAN m_fAccessDenied;// If TRUE, the user is not logged on as admin

};

class CSharedAccessConnectionUiDlg :
    public CDialogImpl<CSharedAccessConnectionUiDlg>
{
    BEGIN_MSG_MAP(CSharedAccessConnectionUiDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    enum { IDD = IDD_LAN_CONNECT};  // borrowing the lan dialog template

    CSharedAccessConnectionUiDlg() { m_pconn = NULL; };

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);

    VOID SetConnection(INetConnection *pconn) {m_pconn = pconn;}

private:
    INetConnection *    m_pconn;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\util.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U T I L. H
//
//  Contents:   Utility functions shared within lanui
//
//
//----------------------------------------------------------------------------
#pragma once

#include "chklist.h"
#include "ncnetcfg.h"
#include "netcon.h"
#include "wzcsapi.h"

extern const WCHAR c_szEmpty[];

//
// image state entries
//
const UINT SELS_INTENTCHECKED = 0x1;
const UINT SELS_CHECKED       = 0x2;
const UINT SELS_UNCHECKED     = 0x3;
const UINT SELS_FIXEDBINDING_DISABLED = 0x4;
const UINT SELS_FIXEDBINDING_ENABLED  = 0x5;
const UINT SELS_INTERMEDIATE  = 0x6;

struct NET_ITEM_DATA
{
    INetCfgComponent *  pncc;
    CComponentObj     *  pCompObj;

    PWSTR              szwName;
    PWSTR              szwDesc;
    DWORD               dwFlags;
};

struct HANDLES
{
    HWND    m_hList;
    HWND    m_hAdd;
    HWND    m_hRemove;
    HWND    m_hProperty;
    HWND    m_hDescription;
};

// Function prototypes
HRESULT HrInitCheckboxListView(HWND hwndList,
                       HIMAGELIST* philStateIcons,
                       SP_CLASSIMAGELIST_DATA* pcild);

HRESULT HrInitListView(HWND hwndList,
                       INetCfg* pnc,
                       INetCfgComponent * pnccAdapter,
                       ListBPObj * plistBindingPaths,
                       HIMAGELIST* philStateIcons);

VOID UninitListView(HWND hwndList);

HRESULT HrRefreshListView(HWND hwndList,
                          INetCfg* pnc,
                          INetCfgComponent * pnccAdapter,
                          ListBPObj * plistBindingPaths);

HRESULT HrLvGetSelectedComponent(HWND hwndList,
                                 INetCfgComponent **pncc);

VOID LvDeleteItem(HWND hwndList, int iItem);

HRESULT HrLvRemove(HWND hwndLV, HWND hwndParent,
                   INetCfg *pnc, INetCfgComponent *pnccAdapter,
                   ListBPObj * plistBindingPaths);

HRESULT HrLvAdd(HWND hwndLV, HWND hwndParent, INetCfg *pnc,
                INetCfgComponent *pnccAdapter,
                ListBPObj * plistBindingPaths);

HRESULT HrLvProperties(HWND hwndLV, HWND hwndParent, INetCfg *pnc,
                       IUnknown *punk, INetCfgComponent *pnccAdapter,
                       ListBPObj * plistBindingPaths,
                       BOOL *bChanged);

INT OnListClick(HWND hwndList,
                HWND hwndParent,
                INetCfg *pnc,
                IUnknown *punk,
                INetCfgComponent *pnccAdapter,
                ListBPObj * plistBindingPaths,
                BOOL fDoubleClk,
                BOOL fReadOnly = FALSE);

HRESULT HrToggleLVItemState(HWND hwndList,
                            ListBPObj * plistBindingPaths,
                            INT iItem);

INT OnListKeyDown(HWND hwndList, ListBPObj * plistBindingPaths, WORD wVKey);

VOID LvSetButtons(HWND hwndParent, HANDLES& h, BOOL fReadOnly, IUnknown *punk);
VOID LvReportErrorHr(HRESULT hr, INT ids, HWND hwnd, PCWSTR szDesc);
VOID LvReportError(INT ids, HWND hwnd, PCWSTR szDesc, PCWSTR szText);

HRESULT HrRefreshAll(HWND hwndList,
                     INetCfg* pnc,
                     INetCfgComponent * pnccAdapter,
                     ListBPObj * plistBindingPaths);

VOID ReleaseAll(HWND hwndList,
                ListBPObj * plistBindingPaths);

BOOL FValidatePageContents( HWND hwndDlg,
                            HWND hwndList,
                            INetCfg * pnc,
                            INetCfgComponent * pnccAdapter,
                            ListBPObj * plistBindingPaths);

//
// EAPOL related funtions
//

HRESULT
HrElSetCustomAuthData (
        IN  WCHAR       *pwszGuid,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  BYTE        *pbConnInfo,
        IN  DWORD       dwInfoSize);

HRESULT
HrElGetCustomAuthData (
        IN  WCHAR       *pwszGuid,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  BYTE        *pbConnInfo,
        IN  DWORD       *pdwInfoSize);

HRESULT
HrElSetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  EAPOL_INTF_PARAMS  *pIntfParams);

HRESULT
HrElGetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_PARAMS  *pIntfParams);

VOID
ComboBox_SetCurSelNotify(
    IN HWND hwndLb,
    IN INT  nIndex );

VOID
ComboBox_AutoSizeDroppedWidth(
    IN HWND hwndLb );


INT
ComboBox_AddItem(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem );

VOID*
ComboBox_GetItemDataPtr(
    IN HWND hwndLb,
    IN INT  nIndex );

TCHAR*
ComboBox_GetPsz(
    IN HWND hwnd,
    IN INT  nIndex );

BOOL
ElCanEapolRunOnInterface (
        IN  INetConnection *    m_pconn);

#ifdef ENABLETRACE

VOID PrintBindingPath (
    TRACETAGID ttidToTrace,
    INetCfgBindingPath* pncbp,
    PCSTR pszaExtraText);

#else

#define PrintBindingPath(a, b, c)

#endif //ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\sauiobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S A U I O B J. C P P
//
//  Contents:   Implementation of the LAN ConnectionUI object
//
//  Notes:
//
//  Created:     tongl   8 Oct 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncras.h"
#include "sauiobj.h"
#include "saui.h"
#include "resource.h"
#include "lanhelp.h"
#include "lanui.h"
#include "ncui.h"

//+---------------------------------------------------------------------------
// INetConnectionUI
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionUi::SetConnection
//
//  Purpose:    Sets the LAN connection that this UI object will operate upon
//
//  Arguments:
//      pCon [in]   LAN connection object to operate on. Can be NULL.
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   16 Oct 1997
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionUi::SetConnection(INetConnection* pCon)
{
    HRESULT hr = S_OK;

    ReleaseObj(m_pconn);
    m_pconn = pCon;
    AddRefObj(m_pconn);

    TraceError("CSharedAccessConnectionUi::SetConnection", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionUi::Connect
//
//  Purpose:    Tells the connection to connect, optionally displaying UI of
//              connection progress.
//
//  Arguments:
//      hwndParent [in]     Parent window for UI
//      dwFlags    [in]     Flags affecting how UI is shown
//
//  Returns:    S_OK if success, OLE error otherwise
//
//  Author:     danielwe   16 Oct 1997
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionUi::Connect(HWND hwndParent, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_pconn)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        CSharedAccessConnectionUiDlg dlg; // we are borrowing the CLanConnectionUiDlg because it works so well for us.  
        HWND                hwndDlg;

        NETCON_MEDIATYPE MediaType = NCM_NONE; // assume no ui
        NETCON_PROPERTIES* pProperties;
        hr = m_pconn->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            MediaType = pProperties->MediaType;            
            FreeNetconProperties(pProperties);
        }
        else
        {
            hr = S_OK; // ok if prev fails
        }

        if (!(dwFlags & NCUC_NO_UI))
        {
            // Display UI prior to connect
            //

            dlg.SetConnection(m_pconn);
            hwndDlg = dlg.Create(hwndParent);

            if (!hwndDlg)
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pconn->Connect();

            // Sleep a bit so they can read the text
            Sleep(1000);

            if (!(dwFlags & NCUC_NO_UI))
            {
                SetDlgItemText(hwndDlg, IDC_TXT_Caption, c_szEmpty);
                Sleep(100);

                UINT ids = SUCCEEDED(hr) ?
                    IDS_SHAREDACCESSUI_CONNECTED :
                    IDS_LAN_CONNECT_FAILED;

                PCWSTR szwResult = SzLoadIds(ids);
                SetDlgItemText(hwndDlg, IDC_TXT_Caption, szwResult);

                // Sleep a bit so they can read the text
                Sleep(1000);

                DestroyWindow(hwndDlg);

                if(E_ACCESSDENIED == hr)
                {
                    NcMsgBox(_Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION, IDS_SHAREDACCESSUI_ACCESSDENIED, MB_OK | MB_ICONEXCLAMATION);
                    hr = S_OK;  // handled the error
                }
            }

        }
    }

    TraceHr(ttidError, FAL, hr, FALSE, "CSharedAccessConnectionUi::Connect");
    return hr;
}

STDMETHODIMP CSharedAccessConnectionUi::Disconnect(HWND hwndParent, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    if (!m_pconn)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        hr = m_pconn->Disconnect();
        if(E_ACCESSDENIED == hr)
        {
            NcMsgBox(_Module.GetResourceInstance(), NULL, IDS_CONFOLD_WARNING_CAPTION, IDS_SHAREDACCESSUI_ACCESSDENIED, MB_OK | MB_ICONEXCLAMATION);
            hr = S_OK;  // handled the error
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CSharedAccessConnectionUi::Disconnect");
    return hr;
}
//+---------------------------------------------------------------------------
// INetConnectionPropertyUi2
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionUi::AddPages
//
//  Purpose:    Called when our UI object shoud add its pages to a property
//              sheet for the connection UI owned by the shell.
//
//  Arguments:
//      pfnAddPage [in]     Callback function to add the page
//      lParam     [in]     User-defined paramter required by the callback
//                          function.
//
//  Returns:    S_OK if succeeded, otherwise OLE error.
//
//  Author:     danielwe   28 Oct 1997
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionUi::AddPages(HWND hwndParent,
                                        LPFNADDPROPSHEETPAGE pfnAddPage,
                                        LPARAM lParam)
{
    HRESULT hr = S_OK;

    if (!pfnAddPage)
    {
        hr = E_POINTER;
    }
    else if (!m_pconn)
    {
        hr = E_UNEXPECTED;
    }
    else
    {
        NETCON_PROPERTIES* pProperties;
        hr = m_pconn->GetProperties(&pProperties);
        if(SUCCEEDED(hr))
        {
            if (!m_pspSharedAccessPage)
            {
                m_pspSharedAccessPage = new CSharedAccessPage(static_cast<INetConnectionPropertyUi *>(this),
                    m_pnc, m_pconn, m_fReadOnly, m_fNeedReboot,
                    m_fAccessDenied, g_aHelpIDs_IDD_SHAREDACCESS_GENERAL);
            }
            
            if (m_pspSharedAccessPage)
            {
                (VOID) pfnAddPage(m_pspSharedAccessPage->CreatePage(IDD_SHAREDACCESS_GENERAL, 0),
                    lParam);
            }
            
        
            FreeNetconProperties(pProperties);
        }
    }

    TraceError("CSharedAccessConnectionUi::AddPages(INetConnectionPropertyUi)", hr);
    return hr;
}

STDMETHODIMP
CSharedAccessConnectionUi::GetIcon (
    DWORD dwSize,
    HICON *phIcon )
{
    HRESULT hr;
    Assert (phIcon);

    hr = HrGetIconFromMediaType(dwSize, NCM_SHAREDACCESSHOST_LAN, NCSM_NONE, 7, 0, phIcon);

    TraceError ("CLanConnectionUi::GetIcon (INetConnectionPropertyUi2)", hr);

    return hr;
}


//
// INetConnectionUiLock
//

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionUi::QueryLock
//
//  Purpose:    Causes the UI object to attempt to get the INetCfg write lock.
//
//  Arguments:
//      ppszwLockHolder [out] Description of component that holds the
//                            write lock in the event that it couldn't be
//                            obtained.
//
//  Returns:    S_OK if success, S_FALSE if write lock couldn't be obtained,
//              OLE or Win32 error otherwise
//
//  Author:     danielwe   13 Nov 1997
//
//  Notes:
//
STDMETHODIMP CSharedAccessConnectionUi::QueryLock(PWSTR* ppszwLockHolder)
{
    HRESULT     hr = S_OK;

    if (!ppszwLockHolder)
    {
        hr = E_POINTER;
    }
    else
    {
        INetCfgLock *   pnclock;

        AssertSz(!m_pnc, "We're assuming this is in the property sheet "
                  "context and we don't yet have an INetCfg!");

        *ppszwLockHolder = NULL;

        // Instantiate an INetCfg
        hr = CoCreateInstance(
                CLSID_CNetCfg,
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetCfg,
                reinterpret_cast<LPVOID *>(&m_pnc));

        TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance");

        if (SUCCEEDED(hr))
        {
            // Get the locking interface
            hr = m_pnc->QueryInterface(IID_INetCfgLock,
                                       reinterpret_cast<LPVOID *>(&pnclock));
            if (SUCCEEDED(hr))
            {
                // Attempt to lock the INetCfg for read/write
                hr = pnclock->AcquireWriteLock(0,
                        SzLoadIds(IDS_SHAREDACCESSUI_LOCK_DESC), ppszwLockHolder);

                ReleaseObj(pnclock);

                if (NETCFG_E_NEED_REBOOT == hr)
                {
                    // Can't make any changes because we are pending a reboot.
                    m_fReadOnly = TRUE;
                    m_fNeedReboot = TRUE;
                    hr = S_OK;
                }
                else if(E_ACCESSDENIED == hr)
                {
                    // user not logged on as admin
                    //
                    m_fReadOnly = TRUE;
                    m_fAccessDenied = TRUE;
                    hr = S_OK;
                }
                else if (S_FALSE == hr)
                {
                    // We don't have sufficent rights
                    //
                    m_fReadOnly = TRUE;
                    hr = S_OK;
                }
            }
        }
    }

    TraceError("CSharedAccessConnectionUi::QueryLock", (S_FALSE == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSharedAccessConnectionUiDlg::OnInitDialog
//
//  Purpose:    Handles the WM_INITDIALOG message.
//
//  Arguments:
//      uMsg     []
//      wParam   []
//      lParam   []
//      bHandled []
//
//  Returns:    TRUE
//
//  Author:     kenwic   19 Sep 2000
//
//  Notes:
//
LRESULT CSharedAccessConnectionUiDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                          LPARAM lParam, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    NETCON_PROPERTIES* pProps;

    AssertSz(m_pconn, "No connection object in dialog!");

    hr = m_pconn->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        SetDlgItemText(IDC_TXT_Caption, SzLoadIds(IDS_SHAREDACCESSUI_CONNECTING));
        SetWindowText(pProps->pszwName);

        HICON hLanIconSmall;
        HICON hLanIconBig;

        hr = HrGetIconFromMediaType(GetSystemMetrics(SM_CXSMICON), NCM_SHAREDACCESSHOST_LAN, NCSM_NONE, 7, 0, &hLanIconSmall);
        if (SUCCEEDED(hr))
        {
            hr = HrGetIconFromMediaType(GetSystemMetrics(SM_CXICON), NCM_SHAREDACCESSHOST_LAN, NCSM_NONE, 7, 0, &hLanIconBig);
            if (SUCCEEDED(hr))
            {
                SetIcon(hLanIconSmall, FALSE);
                SetIcon(hLanIconBig, TRUE);

                SendDlgItemMessage(IDI_Device_Icon, STM_SETICON, reinterpret_cast<WPARAM>(hLanIconBig), 0);

            }
        }
        
        FreeNetconProperties(pProps);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\wzcpage.h ===
extern "C" {
#include "ntddndis.h"
#include "wzcsapi.h"
}

#pragma once

////////////////////////////////////////////////////////////////////////
// CWZCConfigPage related stuff
//
// flags used for CWZCConfigProps::m_dwFlags
#define     WZCDLG_PROPS_RWALL      0x000000ff    // enable all settings for writing
#define     WZCDLG_PROPS_RWSSID     0x00000001    // enable SSID for writing
#define     WZCDLG_PROPS_RWINFR     0x00000002    // enable Infrastructure Mode for writing
#define     WZCDLG_PROPS_RWAUTH     0x00000004    // enable Authentication Mode for writing
#define     WZCDLG_PROPS_RWWEP      0x00000010    // enable the WEP entry for selecting
#define     WZCDLG_PROPS_ONEX_CHECK 0x00000100    // correlate the 802.1X state with the existence of the key

#define     WZCDLG_PROPS_DEFOK      0x00002000    // "OK" = defpushbutton (otherwise, "Cancel"=defpushbutton)

// utility macro to convert a hexa digit into its value
#define HEX(c)  ((c)<='9'?(c)-'0':(c)<='F'?(c)-'A'+0xA:(c)-'a'+0xA)

// defines used for the valid WEP Key indices
#define WZC_WEPKIDX_NDIGITS 16  // more than we ever need
#define WZC_WEPKIDX_MIN     1
#define WZC_WEPKIDX_MAX     4

// defines legal lengths for the WEP Key material
#define WZC_WEPKMAT_40_ASC  5
#define WZC_WEPKMAT_40_HEX  10
#define WZC_WEPKMAT_104_ASC 13
#define WZC_WEPKMAT_104_HEX 26
#define WZC_WEPKMAT_128_ASC 16
#define WZC_WEPKMAT_128_HEX 32

class CEapolConfig;
class CWZCConfig;

class CWZCConfigPage:
    public CPropSheetPage
{
protected:
    BEGIN_MSG_MAP(CWZCConfigPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOK)
        COMMAND_ID_HANDLER(IDC_SHAREDMODE, OnUsePW)
        COMMAND_ID_HANDLER(IDC_USEPW, OnUsePW)
        COMMAND_ID_HANDLER(IDC_USEHARDWAREPW, OnUseHWPassword)
        COMMAND_ID_HANDLER(IDC_WZC_EDIT_KMat, OnWepKMatCmd)
        COMMAND_ID_HANDLER(IDC_ADHOC, OnCheckEapolAllowed)
    END_MSG_MAP()

    BOOL m_bKMatTouched; // indicator whether the wep key material has been touched

    // handle to the dialog
    HWND        m_hwndDlg;
    // Handles to all the UI controls managed
    // by this class (all related to Wireless
    // Zero Configuration)
    HWND        m_hwndEdSSID;   // "Service Set Identifier:" edit
    HWND        m_hwndChkAdhoc; // "Adhoc" vs "Infra" checkbox
    HWND        m_hwndChkShared; // "Use shared auth mode" checkbox
    HWND        m_hwndUsePW;    // "Use Password" checkbox
    // wep key related controls
    HWND        m_hwndUseHardwarePW; // "Use password from network hardware" check box
    HWND        m_hwndLblKMat;  // "Key material" label
    HWND        m_hwndLblKMat2; // "Confirm Key material" label
    HWND        m_hwndEdKMat;   // "Key material" edit
    HWND        m_hwndEdKMat2;  // "Confirm Key material" edit
    HWND        m_hwndLblKIdx;  // "Key index" label
    HWND        m_hwndEdKIdx;   // "Key index" edit

    // Internal members
    DWORD       m_dwFlags;

    // Pointer to the EAPOL configuration for this network
    CEapolConfig    *m_pEapolConfig;

    // automatically enable/disable state for all the WepK related controls
    DWORD EnableWepKControls();

    // initializes WEP controls
    DWORD InitWepKControls();

    // checks the validity of the WEP Key material
    DWORD CheckWepKMaterial(LPSTR *ppszKMat, DWORD *pdwKeyFlags);

    // parses & copies the WEP Key material from the parameter into the m_wzcConfig object
    DWORD CopyWepKMaterial(LPSTR szKMat);

    // sets the EAPOL Locked bit
    DWORD SetEapolAllowedState();

public:
    // wzc configuration settings
    WZC_WLAN_CONFIG m_wzcConfig;
    // class constructor
    CWZCConfigPage(DWORD dwFlags = 0);
    // initialize the wzc config data
    DWORD UploadWzcConfig(CWZCConfig *pwzcConfig);
    // copy a reference to the EAPOL configuration object
    DWORD UploadEapolConfig(CEapolConfig *pEapolConfig);
    // Sets the dialog flags
    DWORD SetFlags(DWORD dwMask, DWORD dwNewFlags);
    // Dialog related members
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(UINT idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUsePW(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnUseHWPassword(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnWepKMatCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCheckEapolAllowed(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\wzcpage.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncui.h"
#include "lanui.h"
#include "xpsp1res.h"
#include "lanhelp.h"
#include "eapolui.h"
#include "wzcpage.h"
#include "wzcui.h"

#define ARRAYSIZE(x) (sizeof((x)) / sizeof((x)[0]))

////////////////////////////////////////////////////////////////////////
// CWZCConfigPage related stuff
//
// g_wszHiddWebK is a string of 26 bullets (0x25cf - the hidden password char) and a NULL
WCHAR g_wszHiddWepK[] = {0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf,
                         0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x25cf, 0x0000};

//+---------------------------------------------------------------------------
// automatically enable/disable state for all the WepK related controls
DWORD 
CWZCConfigPage::EnableWepKControls()
{
    BOOL bEnable;

    // allow changing the Wep Key settings only if they are needed (i.e. privacy and/or shared auth)
    // It is so for several reasons:
    // - we allow all the params to change, but the SSID & the infra mode (these are 
    //   the key info for a configuration and determines the position of the configuration
    //   in the preferred list - messing with these involves a whole work to readjust 
    //   the position of the configuration)
    // - for the long term future we could allow any params of a configuration to change
    //   including the key info. This will involve changing the position of this configuration
    //   in the preferred list, but we should do it some time.
    bEnable = (m_dwFlags & WZCDLG_PROPS_RWWEP); 
    bEnable = bEnable && ((BST_CHECKED == ::SendMessage(m_hwndUsePW, BM_GETCHECK, 0, 0)) ||
                          (BST_CHECKED == ::SendMessage(m_hwndChkShared, BM_GETCHECK, 0, 0)));

    ::EnableWindow(m_hwndUseHardwarePW, bEnable);

    bEnable = bEnable && (BST_UNCHECKED == IsDlgButtonChecked(IDC_USEHARDWAREPW));
    ::EnableWindow(m_hwndLblKMat, bEnable);
    ::EnableWindow(m_hwndEdKMat, bEnable);
    ::EnableWindow(m_hwndLblKMat2, bEnable && m_bKMatTouched);
    ::EnableWindow(m_hwndEdKMat2, bEnable && m_bKMatTouched);
    ::EnableWindow(m_hwndLblKIdx, bEnable);
    ::EnableWindow(m_hwndEdKIdx, bEnable);
 
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// initializes WEP controls
DWORD
CWZCConfigPage::InitWepKControls()
{
    UINT nWepKLen = 0;

    // check whether the key is provided automatically or not
    CheckDlgButton(IDC_USEHARDWAREPW, 
        (m_wzcConfig.dwCtlFlags & WZCCTL_WEPK_PRESENT) ? BST_UNCHECKED : BST_CHECKED);

    if (m_wzcConfig.KeyLength == 0)
    {
        nWepKLen = 0;
        m_bKMatTouched = TRUE;
    }
    //--- when a password is to be displayed as hidden chars, don't put in
    //--- its actual length, but just 8 bulled chars.
    else
    {
        nWepKLen = 8;
    }

    g_wszHiddWepK[nWepKLen] = L'\0';
    ::SetWindowText(m_hwndEdKMat, g_wszHiddWepK);
    ::SetWindowText(m_hwndEdKMat2, g_wszHiddWepK);
    g_wszHiddWepK[nWepKLen] = 0x25cf; // Hidden password char (bullet)

    // the index edit control shouldn't accept more than exactly one char
    ::SendMessage(m_hwndEdKIdx, EM_LIMITTEXT, 1, 0);

    // show the current key index, if valid. Otherwise, default to the min valid value.
    if (m_wzcConfig.KeyIndex + 1 >= WZC_WEPKIDX_MIN && 
        m_wzcConfig.KeyIndex + 1 <= WZC_WEPKIDX_MAX)
    {
        CHAR   szIdx[WZC_WEPKIDX_NDIGITS];
        ::SetWindowTextA(m_hwndEdKIdx, _itoa(m_wzcConfig.KeyIndex + 1, szIdx, 10));
    }
    else
        m_wzcConfig.KeyIndex = 0;

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// checks the validity of the WEP Key material and selects the
// material from the first invalid char (non hexa in hexa format or longer
// than the specified length
DWORD
CWZCConfigPage::CheckWepKMaterial(LPSTR *ppszKMat, DWORD *pdwKeyFlags)
{
    DWORD       dwErr = ERROR_SUCCESS;
    DWORD       dwKeyFlags = 0;
    UINT        nMatLen = ::GetWindowTextLength(m_hwndEdKMat);
    LPSTR       pszCrtMat = NULL;
    UINT        nSelIdx = 0;

    switch(nMatLen)
    {
    case WZC_WEPKMAT_40_ASC:    // 5 chars
    case WZC_WEPKMAT_104_ASC:   // 13 chars
    case WZC_WEPKMAT_128_ASC:   // 16 chars
        break;
    case WZC_WEPKMAT_40_HEX:    // 10 hexadecimal digits
    case WZC_WEPKMAT_104_HEX:   // 26 hexadecimal digits
    case WZC_WEPKMAT_128_HEX:   // 32 hexadecimal digits
        dwKeyFlags |= WZCCTL_WEPK_XFORMAT;
        break;
    default:
        dwErr = ERROR_BAD_FORMAT;
    }

    // allocate space for the current key material
    if (dwErr == ERROR_SUCCESS)
    {
        pszCrtMat = new CHAR[nMatLen + 1];
        if (pszCrtMat == NULL)
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    // get the current key material from the edit control
    if (dwErr == ERROR_SUCCESS)
    {
        if (nMatLen != ::GetWindowTextA(m_hwndEdKMat, pszCrtMat, nMatLen+1))
            dwErr = GetLastError();
    }

    // we have now all the data. We should select the text in the Key material 
    // edit control from the first one of the two:
    // - the nNewLen to the end (if the current content exceeds the specified length)
    // - the first non hexa digit to the end (if current format is hexa)
    if (dwErr == ERROR_SUCCESS && (dwKeyFlags & WZCCTL_WEPK_XFORMAT))
    {
        UINT nNonXIdx;

        for (nNonXIdx = 0; nNonXIdx < nMatLen; nNonXIdx++)
        {
            if (!isxdigit(pszCrtMat[nNonXIdx]))
            {
                dwErr = ERROR_BAD_FORMAT;
                break;
            }
        }
    }

    if (dwErr != ERROR_SUCCESS)
    {
        ::SetWindowText(m_hwndEdKMat2, L"");
        ::SendMessage(m_hwndEdKMat, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
        // and set the focus on the key material edit control
        ::SetFocus(m_hwndEdKMat);
        // clean up whatever memory we allocated since we're not passing it up
        if (pszCrtMat != NULL)
            delete [] pszCrtMat;
    }
    else
    {
        *ppszKMat = pszCrtMat;
        *pdwKeyFlags = dwKeyFlags;
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
// parses & copies the WEP Key material from the parameter into the m_wzcConfig object
// The length should be already the good one, the format is given by m_wzcConfig.dwCtlFlags
// Since we assume a valid key material it means its length is non-zero and it is fitting in
// the configurations key material buffer, and if the formatting is hexadecimal, it 
// contains an even number of hexa digits.
DWORD
CWZCConfigPage::CopyWepKMaterial(LPSTR szKMat)
{
    BYTE     chFakeKeyMaterial[] = {0x56, 0x09, 0x08, 0x98, 0x4D, 0x08, 0x11, 0x66, 0x42, 0x03, 0x01, 0x67, 0x66};

    if (m_wzcConfig.dwCtlFlags & WZCCTL_WEPK_XFORMAT)
    {
        UINT  nKMatIdx = 0;

        // we know here we have a valid hexadecimal formatting
        // this implies the string has an even number of digits
        while(*szKMat != '\0')
        {
            m_wzcConfig.KeyMaterial[nKMatIdx] = HEX(*szKMat) << 4;
            szKMat++;
            m_wzcConfig.KeyMaterial[nKMatIdx] |= HEX(*szKMat);
            szKMat++;
            nKMatIdx++;
        }
        m_wzcConfig.KeyLength = nKMatIdx;
    }
    else
    {
        // the key is not in Hex format, so just copy over the bytes
        // we know the length is good so no worries about overwritting the buffer
        m_wzcConfig.KeyLength = strlen(szKMat);
        memcpy(m_wzcConfig.KeyMaterial, szKMat, m_wzcConfig.KeyLength);
    }

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// sets the EAPOL Locked bit
DWORD 
CWZCConfigPage::SetEapolAllowedState()
{
    if (m_pEapolConfig != NULL)
    {
        // EAPOL shouldn't be even allowed on networks not requesting privacy or on 
        // ad hoc networks.
        if (BST_UNCHECKED == ::SendMessage(m_hwndUsePW, BM_GETCHECK, 0, 0) ||
            BST_CHECKED == ::SendMessage(m_hwndChkAdhoc, BM_GETCHECK, 0, 0))
        {
            // lock the Eapol configuration page
            m_pEapolConfig->m_dwCtlFlags |= EAPOL_CTL_LOCKED;
        }
        else // for Infrastructure networks requiring privacy..
        {
            // unlock the Eapol configuration page (users are allowed to enable / disable 802.1X)
            m_pEapolConfig->m_dwCtlFlags &= ~EAPOL_CTL_LOCKED;

            // if asked to correlate onex state with the presence of an explicit key, fix this here
            if (m_dwFlags & WZCDLG_PROPS_ONEX_CHECK)
            {
                if (BST_CHECKED == ::SendMessage(m_hwndUseHardwarePW, BM_GETCHECK, 0, 0))
                    m_pEapolConfig->m_EapolIntfParams.dwEapFlags |= EAPOL_ENABLED;
                else
                    m_pEapolConfig->m_EapolIntfParams.dwEapFlags &= ~EAPOL_ENABLED;
            }
        }
    }

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// class constructor
CWZCConfigPage::CWZCConfigPage(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
    m_bKMatTouched = FALSE;
    m_pEapolConfig = NULL;

    ZeroMemory(&m_wzcConfig, sizeof(WZC_WLAN_CONFIG));
    m_wzcConfig.Length = sizeof(WZC_WLAN_CONFIG);
    m_wzcConfig.InfrastructureMode = Ndis802_11Infrastructure;
    m_wzcConfig.Privacy = 1;
}

//+---------------------------------------------------------------------------
// Uploads the configuration into the dialog's internal data
DWORD
CWZCConfigPage::UploadWzcConfig(CWZCConfig *pwzcConfig)
{
    // if the configuration being uploaded is already a preferred one, reset the
    // ONEX check flag (don't control the ONEX setting since it has already been 
    // chosen by the user at the moment the configuration was first created)
    if (pwzcConfig->m_dwFlags & WZC_DESCR_PREFRD)
        m_dwFlags &= ~WZCDLG_PROPS_ONEX_CHECK;
    CopyMemory(&m_wzcConfig, &(pwzcConfig->m_wzcConfig), sizeof(WZC_WLAN_CONFIG));
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// copy a reference to the EAPOL configuration object
DWORD 
CWZCConfigPage::UploadEapolConfig(CEapolConfig *pEapolConfig)
{
    // this member is never to be freed in this class
    m_pEapolConfig = pEapolConfig;
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// Sets the dialog flags. Returns the entire current set of flags
DWORD
CWZCConfigPage::SetFlags(DWORD dwMask, DWORD dwNewFlags)
{
    m_dwFlags &= ~dwMask;
    m_dwFlags |= (dwNewFlags & dwMask);
    return m_dwFlags;
}

//+---------------------------------------------------------------------------
// INIT_DIALOG handler
LRESULT
CWZCConfigPage::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DWORD dwStyle;
    HRESULT hr = S_OK;

    // get all the controls handles
    m_hwndEdSSID = GetDlgItem(IDC_WZC_EDIT_SSID);
    m_hwndChkAdhoc = GetDlgItem(IDC_ADHOC);
    m_hwndChkShared = GetDlgItem(IDC_SHAREDMODE);
    m_hwndUsePW = GetDlgItem(IDC_USEPW);
    // wep key related controls
    m_hwndUseHardwarePW = GetDlgItem(IDC_USEHARDWAREPW);
    m_hwndLblKMat = GetDlgItem(IDC_WZC_LBL_KMat);
    m_hwndEdKMat = GetDlgItem(IDC_WZC_EDIT_KMat);
    m_hwndLblKMat2 = GetDlgItem(IDC_WZC_LBL_KMat2);
    m_hwndEdKMat2 = GetDlgItem(IDC_WZC_EDIT_KMat2);
    m_hwndLblKIdx = GetDlgItem(IDC_WZC_LBL_KIdx);
    m_hwndEdKIdx = GetDlgItem(IDC_WZC_EDIT_KIdx);

    // initialize the SSID field with the SSID, if one is given
    if (m_wzcConfig.Ssid.SsidLength != 0)
    {
        // ugly but this is life. In order to convert the SSID to LPWSTR we need a buffer.
        // We know an SSID can't exceed 32 chars (see NDIS_802_11_SSID from ntddndis.h) so
        // make room for the null terminator and that's it. We could do mem alloc but I'm
        // not sure it worth the effort (at runtime).
        WCHAR   wszSSID[33];
        UINT    nLenSSID = 0;

        // convert the LPSTR (original SSID format) to LPWSTR (needed in List Ctrl)
        nLenSSID = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        (LPCSTR)m_wzcConfig.Ssid.Ssid,
                        m_wzcConfig.Ssid.SsidLength,
                        wszSSID,
                        celems(wszSSID));
        if (nLenSSID != 0)
        {
            wszSSID[nLenSSID] = L'\0';
            ::SetWindowText(m_hwndEdSSID, wszSSID);
        }
    }

    // Check the "this network is adhoc" box if neccessary.
    ::SendMessage(m_hwndChkAdhoc, BM_SETCHECK, (m_wzcConfig.InfrastructureMode == Ndis802_11IBSS) ? BST_CHECKED : BST_UNCHECKED, 0);

    // Check the "Use the network key to access this network" checkbox if necessary
    // Checking this corresponds to "Shared" auth mode. Unchecked corresponds to "Open" (dsheldon)
    ::SendMessage(m_hwndChkShared, BM_SETCHECK, m_wzcConfig.AuthenticationMode ? BST_CHECKED : BST_UNCHECKED, 0);

    // the SSID can't be under any circumstances larger than 32 chars
    ::SendMessage(m_hwndEdSSID, EM_LIMITTEXT, 32, 0);

    // create the spin control
    CreateUpDownControl(
        WS_CHILD|WS_VISIBLE|WS_BORDER|UDS_SETBUDDYINT|UDS_ALIGNRIGHT|UDS_NOTHOUSANDS|UDS_ARROWKEYS,
        0, 0, 0, 0,
        m_hWnd,
        -1,
        _Module.GetResourceInstance(),
        m_hwndEdKIdx,
        WZC_WEPKIDX_MAX,
        WZC_WEPKIDX_MIN,
        WZC_WEPKIDX_MIN);

    ::SendMessage(m_hwndUsePW, BM_SETCHECK, (m_wzcConfig.Privacy == 1) ? BST_CHECKED : BST_UNCHECKED, 0);

    // at this point we can say the WEP key is untouched
    m_bKMatTouched = FALSE;

    // fill in the WepK controls
    InitWepKControls();

    // enable or disable the controls based on how the dialog is called
    ::EnableWindow(m_hwndEdSSID, m_dwFlags & WZCDLG_PROPS_RWSSID);
    ::EnableWindow(m_hwndChkAdhoc, m_dwFlags & WZCDLG_PROPS_RWINFR);
    ::EnableWindow(m_hwndChkShared, m_dwFlags & WZCDLG_PROPS_RWAUTH);
    ::EnableWindow(m_hwndUsePW, m_dwFlags & WZCDLG_PROPS_RWWEP);
    // enable or disable all the wep key related controls
    EnableWepKControls();
    SetEapolAllowedState();

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
// OK button handler
LRESULT
CWZCConfigPage::OnOK(UINT idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    UINT    nSSIDLen;
    CHAR    szSSID[33];
    DWORD   dwKeyFlags = 0;
    UINT    nKeyIdx;
    LPSTR   szWepKMat = NULL;
    // variables used for prompting the user with warning/error messages
    UINT    nWarnStringID = 0;
    WCHAR   wszBuff[48];

    m_wzcConfig.Length = sizeof(WZC_WLAN_CONFIG);
    // get the basic 802.11 parameters
    m_wzcConfig.InfrastructureMode = (BST_CHECKED == ::SendMessage(m_hwndChkAdhoc, BM_GETCHECK, 0, 0)) ? Ndis802_11IBSS : Ndis802_11Infrastructure;
    m_wzcConfig.AuthenticationMode = (BST_CHECKED == ::SendMessage(m_hwndChkShared, BM_GETCHECK, 0, 0)) ? Ndis802_11AuthModeShared : Ndis802_11AuthModeOpen;
    m_wzcConfig.Privacy = (BYTE) (BST_CHECKED == ::SendMessage(m_hwndUsePW, BM_GETCHECK, 0, 0)) ? 1 : 0;

    // get the SSID (max 32 chars)
    nSSIDLen = ::GetWindowTextA(
                    m_hwndEdSSID,
                    szSSID,
                    sizeof(szSSID));
    m_wzcConfig.Ssid.SsidLength = nSSIDLen;
    if (nSSIDLen > 0)
        CopyMemory(m_wzcConfig.Ssid.Ssid, szSSID, nSSIDLen);

    // mark whether a WEP key is provided (not defaulted) or not (defaulted to whatever the hdw might have)
    if (IsDlgButtonChecked(IDC_USEHARDWAREPW))
        m_wzcConfig.dwCtlFlags &= ~WZCCTL_WEPK_PRESENT;
    else
        m_wzcConfig.dwCtlFlags |= WZCCTL_WEPK_PRESENT;

    // get the key index in a local variable
    wszBuff[0] = L'\0';
    ::GetWindowText(m_hwndEdKIdx, wszBuff, sizeof(wszBuff)/sizeof(WCHAR));
    nKeyIdx = _wtoi(wszBuff) - 1;
    if (nKeyIdx + 1 < WZC_WEPKIDX_MIN || nKeyIdx + 1 > WZC_WEPKIDX_MAX)
    {
        nWarnStringID = IDS_WZC_KERR_IDX;
        nKeyIdx = m_wzcConfig.KeyIndex;
        ::SendMessage(m_hwndEdKIdx, EM_SETSEL, 0, -1);
        ::SetFocus(m_hwndEdKIdx);
    }

    // get the key material in a local variable.
    // If the key is incorrect, the local storage is not changed.
    if (m_bKMatTouched)
    {
        if (CheckWepKMaterial(&szWepKMat, &dwKeyFlags) != ERROR_SUCCESS)
        {
            nWarnStringID = IDS_WZC_KERR_MAT;
        }
        else
        {
            CHAR szBuff[WZC_WEPKMAT_128_HEX + 1]; // maximum key length
        // verify whether the key is confirmed correctly. We do this only if nWarnString is 
        // 0, which means the key is formatted correctly, hence less than 32 chars.
    
            szBuff[0] = '\0';
            ::GetWindowTextA( m_hwndEdKMat2, szBuff, sizeof(szBuff));
            if (strcmp(szBuff, szWepKMat) != 0)
            {
                nWarnStringID = IDS_WZCERR_MISMATCHED_WEPK;
                // no wep key to be saved, hence delete whatever was read so far
                delete szWepKMat; 
                szWepKMat = NULL;
                ::SetWindowText(m_hwndEdKMat2, L"");
                ::SetFocus(m_hwndEdKMat2);
            }
        }
    }

    // check whether we actually need the wep key settings entered by the user
    if ((m_wzcConfig.AuthenticationMode == Ndis802_11AuthModeOpen && !m_wzcConfig.Privacy) ||
        !(m_wzcConfig.dwCtlFlags & WZCCTL_WEPK_PRESENT))
    {
        // no, we don't actually need the key, so we won't prompt the user if he entered an incorrect
        // key material or index. In this case whatever the user entered is simply ignored.
        // However, if the user entered a correct index / material, they will be saved.
        nWarnStringID = 0;
    }

    // if there is no error to be prompted, just copy over the key settings (regardless they are needed
    // or not).
    if (nWarnStringID == 0)
    {
        m_wzcConfig.KeyIndex = nKeyIdx;
        if (szWepKMat != NULL)
        {
            m_wzcConfig.dwCtlFlags &= ~(WZCCTL_WEPK_XFORMAT);
            m_wzcConfig.dwCtlFlags |= dwKeyFlags;
            CopyWepKMaterial(szWepKMat);
        }
    }
    else
    {
        //NcMsgBox(
        //    WZCGetSPResModule(),
        //    m_hWnd,
        //    IDS_LANUI_ERROR_CAPTION,
        //    nWarnStringID,
        //    MB_ICONSTOP|MB_OK);

        WCHAR pszCaption[256];
        WCHAR pszText[1024];

        LoadString(WZCGetSPResModule(), IDS_LANUI_ERROR_CAPTION, pszCaption, celems(pszCaption));
        LoadString(nWarnStringID == IDS_WZC_KERR_MAT ? WZCGetDlgResModule() : WZCGetSPResModule(),
                   nWarnStringID == IDS_WZC_KERR_MAT ? 5002 : nWarnStringID,
                   pszText,
                   celems(pszText));

        ::MessageBox (m_hWnd, pszText, pszCaption, MB_ICONSTOP|MB_OK);
    }

    if (szWepKMat != NULL)
        delete szWepKMat;

    bHandled = TRUE;

    if (nWarnStringID == 0)
    { 
        return PSNRET_NOERROR;
    }
    else
    {
        return PSNRET_INVALID_NOCHANGEPAGE;
    }
}

//+---------------------------------------------------------------------------
// Context sensitive help handler
extern const WCHAR c_szNetCfgHelpFile[];
LRESULT
CWZCConfigPage::OnContextMenu(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& fHandled)
{
    ::WinHelp(m_hWnd,
              c_szNetCfgHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)g_aHelpIDs_IDC_WZC_DLG_PROPS);

    return 0;
}
LRESULT 
CWZCConfigPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_IDC_WZC_DLG_PROPS);
    }

    return 0;
}

//+---------------------------------------------------------------------------
// Handler for enabling/disabling WEP
LRESULT
CWZCConfigPage::OnUsePW(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EnableWepKControls();
    SetEapolAllowedState();
    return 0;
}

//+---------------------------------------------------------------------------
// Handler for enabling controls if the user wants to specify key material (password) explicitly
LRESULT
CWZCConfigPage::OnUseHWPassword(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EnableWepKControls();
    SetEapolAllowedState();
    return 0;
}

//+---------------------------------------------------------------------------
// Handler for detecting changes in the key material
LRESULT 
CWZCConfigPage::OnWepKMatCmd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (wNotifyCode == EN_SETFOCUS)
    {
        if (!m_bKMatTouched)
        {
            ::SetWindowText(m_hwndEdKMat, L"");
            ::SetWindowText(m_hwndEdKMat2, L"");
            ::EnableWindow(m_hwndLblKMat2, TRUE);
            ::EnableWindow(m_hwndEdKMat2, TRUE);
            m_bKMatTouched = TRUE;
        }
    }
    return 0;
}

//+---------------------------------------------------------------------------
LRESULT 
CWZCConfigPage::OnCheckEapolAllowed(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    return SetEapolAllowedState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\wzcprops.h ===
extern "C" {
#include "ntddndis.h"
#include "wzcsapi.h"
}

#pragma once

class CWZCConfig;

////////////////////////////////////////////////////////////////////////
// CWZCConfigProps related stuff
//
class CWZCConfigProps:
    public CDialogImpl<CWZCConfigProps>
{
protected:
    BEGIN_MSG_MAP(CWZCConfigProps)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDCLOSE, OnCancel)
    END_MSG_MAP()

    enum {IDD = IDC_WZC_DLG_VPROPS};

    // Handles to all the UI controls managed
    // by this class (all related to Wireless
    // Zero Configuration)
    HWND        m_hwndEdSSID;   // "Service Set Identifier:" edit
    HWND        m_hwndChkAdhoc; // "Adhoc" vs "Infra" checkbox
    HWND        m_hwndUsePW;    // "Use Password" checkbox

public:
    // wzc configuration settings
    WZC_WLAN_CONFIG m_wzcConfig;
    // class constructor
    CWZCConfigProps();
    // initialize the wzc config data
    DWORD UploadWzcConfig(CWZCConfig *pwzcConfig);
    // Dialog related members
    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\util.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       U T I L. C P P
//
//  Contents:   Utility functions shared within lanui
//
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "resource.h"
#include "ncreg.h"
#include "ncnetcon.h"
#include "ncnetcfg.h"
#include "ncsetup.h"
#include "lanui.h"
#include "util.h"
#include "chklist.h"
#include "lanuiobj.h"
#include "ncui.h"
#include "ndispnp.h"
#include "ncperms.h"
#include "ncmisc.h"
#include "wzcsapi.h"
#include <raseapif.h>
#include <raserror.h>
#include "connutil.h"

#define INITGUID
#include "ncxclsid.h"
#undef  INITGUID

extern const WCHAR c_szBiNdisAtm[];
extern const WCHAR c_szDevice[];
extern const WCHAR c_szInfId_MS_TCPIP[];
//+---------------------------------------------------------------------------
//                          
//  Function Name:  HrInitCheckboxListView
//
//  Purpose:    Initialize the list view for checkboxes.
//
//  Arguments:
//      hwndList[in]:    Handle of the list view
//      philStateIcons[out]:  Image list for the list view
//      pcild [in,optional] Image list data, created if necessary
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//

HRESULT HrInitCheckboxListView(HWND hwndList, HIMAGELIST* philStateIcons, SP_CLASSIMAGELIST_DATA* pcild)
{
    HRESULT   hr = S_OK;
    RECT      rc;
    LVCOLUMN  lvc = {0};
    HWND      hwndHeader;                 

    // Create small image lists
    //
    if(NULL == pcild)
    {
        pcild = new SP_CLASSIMAGELIST_DATA;
        if(pcild)
        {
            hr = HrSetupDiGetClassImageList(pcild);
            if (SUCCEEDED(hr))
            {
                AssertSz(pcild->ImageList, "No class image list data!");
                
                // Save off image list data for use later
                ::SetWindowLongPtr(GetParent(hwndList), GWLP_USERDATA,
                    reinterpret_cast<LONG_PTR>(pcild));
            }
            else
            {
                TraceError("HrSetupDiGetClassImageList returns failure", hr);
                hr = S_OK;
                
                // delete this if we couldn't get the structure
                delete pcild;
                ::SetWindowLongPtr(GetParent(hwndList), GWLP_USERDATA, 0);
            }
        }
        else 
        {
            hr = E_OUTOFMEMORY;
        }

    }
    
    if(SUCCEEDED(hr))
    {
        ListView_SetImageList(hwndList, pcild->ImageList, LVSIL_SMALL);
        
		// Set the shared image lists bit so the caller can destroy the class
		// image lists itself
		//
		DWORD dwStyle = GetWindowLong(hwndList, GWL_STYLE);
		SetWindowLong(hwndList, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));

        // Create state image lists
        *philStateIcons = ImageList_LoadBitmapAndMirror(
                                    _Module.GetResourceInstance(),
                                    MAKEINTRESOURCE(IDB_CHECKSTATE),
                                    16,
                                    0,
                                    PALETTEINDEX(6));
        ListView_SetImageList(hwndList, *philStateIcons, LVSIL_STATE);
       
        // First determine if we have already added a column before
        // adding one. 
        //

        hwndHeader = ListView_GetHeader( hwndList );

        Assert( hwndHeader );

        if ( (!hwndHeader) ||
             (Header_GetItemCount(hwndHeader) == 0) )
        {
            GetClientRect(hwndList, &rc);
            lvc.mask = LVCF_FMT | LVCF_WIDTH;
            lvc.fmt = LVCFMT_LEFT;
            lvc.cx = rc.right;

            // $REVIEW(tongl 12\22\97): Fix for bug#127472
            // lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
        
            ListView_InsertColumn(hwndList, 0, &lvc);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrInitListView
//
//  Purpose:    Initialize the list view.
//              Iterate through all installed clients, services and protocols,
//              insert into the list view with the correct binding state with
//              the adapter used in this connection.
//
//  Arguments:
//      hwndList[in]:    Handle of the list view
//      pnc[in]:         The writable INetcfg pointer
//      pnccAdapter[in]: The INetcfgComponent pointer to the adapter used in this connection
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//

HRESULT HrInitListView(HWND hwndList,
                       INetCfg* pnc,
                       INetCfgComponent * pnccAdapter,
                       ListBPObj * plistBindingPaths,
                       HIMAGELIST* philStateIcons)
{
    HRESULT                     hr = S_OK;
    SP_CLASSIMAGELIST_DATA     *pcild;

    Assert(hwndList);
    Assert(pnc);
    Assert(pnccAdapter);
    Assert(plistBindingPaths);
    Assert(philStateIcons);

    pcild = (SP_CLASSIMAGELIST_DATA *)::GetWindowLongPtr(::GetParent(hwndList),
                                                         GWLP_USERDATA);

    HrInitCheckboxListView(hwndList, philStateIcons, pcild);
    
    hr = HrRefreshAll(hwndList, pnc, pnccAdapter, plistBindingPaths);

    if (SUCCEEDED(hr))
    {
        // Selete the first item
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
    }

    TraceError("HrInitListView", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   UninitListView
//
//  Purpose:    Uninitializes the common component list view
//
//  Arguments:
//      hwndList [in]   HWND of listview
//
//  Returns:    Nothing
//
//  Author:     danielwe   2 Feb 1998
//
//  Notes:
//
VOID UninitListView(HWND hwndList)
{
    SP_CLASSIMAGELIST_DATA *    pcild;

    Assert(hwndList);

    // delete existing items in the list view
    ListView_DeleteAllItems( hwndList );

    pcild = reinterpret_cast<SP_CLASSIMAGELIST_DATA *>(
            ::GetWindowLongPtr(GetParent(hwndList), GWLP_USERDATA));

    if (pcild)
    {
        // Destroy the class image list data
        (VOID) HrSetupDiDestroyClassImageList(pcild);
        delete pcild;
    }
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrInsertComponent
//
//  Purpose:    Insert all installed, non-hidden and bindable components
//              of a class to the list view
//
//  Arguments:
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//
HRESULT HrInsertComponent(
    IN HWND hwndList,
    IN const GUID* pGuidDevClass,
    IN INetCfgComponent *pncc,
    IN INetCfgComponent *pnccAdapter,
    IN DWORD dwFlags,
    IN ListBPObj * plistBindingPaths,
    IN OUT INT* pnPos)
{
    HRESULT                     hr = S_OK;
    SP_CLASSIMAGELIST_DATA *    pcild;

    Assert(hwndList);
    Assert(pGuidDevClass);

    pcild = reinterpret_cast<SP_CLASSIMAGELIST_DATA *>
            (::GetWindowLongPtr(GetParent(hwndList), GWLP_USERDATA));

    // We should only list components that are bindable to the adapter
    // Note: bindable means binding path exists, either enabled or disabled

    INetCfgComponentBindings * pnccb;
    hr = pncc->QueryInterface(IID_INetCfgComponentBindings, (LPVOID *)&pnccb);

    if (S_OK == hr)
    {
        // Do this only for protocols !!

        // $REVIEW(TongL 3/28/99), I included the 2 reasons on why we only filter
        // non-bindable protocols below, in case someone ask again ..

        // 1) (Originally per BillBe) The add component dialog filters out non-bindable
        // protocols by matching binding interface names from INF, it can not easily do
        // so for services/clients which could be several layers above the adapter.

        // The property UI needs to be consistent because it's confusing to users if
        // we allow them to add a component from a connection but don't let that
        // component show up in the same connection's property UI.

        // 2) (Per ShaunCo) After talking with Bill, we show protocols yet not clients
        // services not to be consistent with the add component dialog, but because
        // you cannot predict based on bindings alone whether a client or service will
        // end up being involved with an adapter.  example: i can install a service
        // that doesn't bind and uses winsock to send data.  It may be able to be configured
        // differently for each adapter (and hence would need to show up for each adapter's
        // connection) but you can't tell by any means whether its going to be invovled with
        // that adapter or not. -- So you have to show all services and clients.
        // A protocol, on the other hand, binds with adapters by definition.  So, we know
        // for the protocol's which will use an adapter and which won't.

        // Special case: do now show filter components unless it is bindable,
        // Raid 358865
        DWORD   dwFlags;
        hr = pncc->GetCharacteristics(&dwFlags);

        if ((SUCCEEDED(hr) && (dwFlags & NCF_FILTER)) ||
            (GUID_DEVCLASS_NETTRANS == *pGuidDevClass))
        {
            // $REVIEW(ShaunCo 3/26/99)
            // To see if the protocol is involved with the adapter, check the
            // owner of each bindpath and see if its equal to the component
            // we are considering inserting into the list view.
            // Note the special case for ms_nwnb.  It won't be involved in a
            // direct binding to the adapter because it has NCF_DONTEXPOSELOWER,
            // so we can't use IsBindableTo.

            BOOL fProtocolIsInvolved = FALSE;
            ListBPObj_ITER iter;

            for (iter  = plistBindingPaths->begin();
                 (iter != plistBindingPaths->end() && !fProtocolIsInvolved);
                 iter++)
            {
                INetCfgComponent* pScan;
                hr = (*iter)->m_pncbp->GetOwner(&pScan);

                if (S_OK == hr)
                {
                    if (pScan == pncc)
                    {
                        fProtocolIsInvolved = TRUE;
                    }
                    ReleaseObj(pScan);
                }
            }

            if (!fProtocolIsInvolved)
            {
                // Don't insert this protocol because it is not involved
                // in the binding set for the adpater.
                //
                hr = S_FALSE;
            }
        }

        if (S_OK == hr) // bindable, add to list
        {
            PWSTR  pszwName;

            hr = pncc->GetDisplayName(&pszwName);
            if (SUCCEEDED(hr))
            {
                PWSTR pszwDesc;

                // Special Case:
                // If this is a Domain Controller,
                // disable tcpip removal, Raid 263754
                //
                if (GUID_DEVCLASS_NETTRANS == *pGuidDevClass)
                {
                    PWSTR pszwId;
                    hr = pncc->GetId (&pszwId);
                    if (SUCCEEDED(hr))
                    {
                        if (FEqualComponentId (c_szInfId_MS_TCPIP, pszwId))
                        {
                            NT_PRODUCT_TYPE   pt;

                            RtlGetNtProductType (&pt);
                            if (NtProductLanManNt == pt)
                            {
                                dwFlags |= NCF_NOT_USER_REMOVABLE;
                            }
                        }

                        CoTaskMemFree (pszwId);
                    }
                }

                hr = pncc->GetHelpText(&pszwDesc);
                if (SUCCEEDED(hr))
                {
                    LV_ITEM lvi = {0};

                    lvi.mask = LVIF_TEXT | LVIF_IMAGE |
                               LVIF_STATE | LVIF_PARAM;


                    // Get the component's class image list index
                    if (pcild)
                    {
                        INT nIndex = 0;

                        (VOID) HrSetupDiGetClassImageIndex(pcild,
                                pGuidDevClass, &nIndex);

                        lvi.iImage = nIndex;
                    }

                    lvi.iItem = *pnPos;

                    NET_ITEM_DATA * pnid = new NET_ITEM_DATA;

                    if (pnid)
                    {
                        pnid->szwName = SzDupSz(pszwName);
                        pnid->szwDesc = SzDupSz(pszwDesc);
                        pnid->dwFlags = dwFlags;
                        AddRefObj(pnid->pncc = pncc);

                        pnid->pCompObj = new CComponentObj(pncc);
                        if (pnid->pCompObj)
                        {
                            hr = pnid->pCompObj->HrInit(plistBindingPaths);
                            if FAILED(hr)
                            {
                                TraceError("HrInsertComponent: failed to initialize a component object", hr);
                                hr = S_OK;
                            }
                        }

                        lvi.lParam = reinterpret_cast<LPARAM>(pnid);
                        lvi.pszText = pnid->szwName;

                        // We will refresh the state of the whole list in the end
                        UINT iChkIndex = SELS_CHECKED;
                        lvi.state = INDEXTOSTATEIMAGEMASK( iChkIndex );

                        INT ret;
                        ret = ListView_InsertItem(hwndList, &lvi);

                        (*pnPos)++;

                        CoTaskMemFree(pszwDesc);
                    }
                }

                CoTaskMemFree(pszwName);
            }
        }

        ReleaseObj(pnccb);
    }

    TraceError("HrInsertComponent", S_FALSE == hr ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrInsertComponents
//
//  Purpose:    Insert installed and non-hidden components
//              of a class to the list view
//
//  Arguments:
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//
HRESULT HrInsertComponents(
    IN HWND hwndList,
    IN INetCfg* pnc,
    IN const GUID* pGuidDevClass,
    IN INetCfgComponent* pnccAdapter,
    IN ListBPObj* plistBindingPaths,
    IN OUT INT* pnPos)
{
    Assert(hwndList);

    HRESULT hr = S_OK;
    CIterNetCfgComponent iterComp (pnc, pGuidDevClass);
    INetCfgComponent* pncc;

    while (SUCCEEDED(hr) && S_OK == (hr = iterComp.HrNext(&pncc)))
    {
        DWORD   dwFlags;

        hr = pncc->GetCharacteristics(&dwFlags);

        // Make sure it's not hidden
        if (SUCCEEDED(hr) && !(dwFlags & NCF_HIDDEN))
        {
            // This will AddRef pncc so the release below can still be
            // there
            hr = HrInsertComponent(
                    hwndList, pGuidDevClass, pncc, pnccAdapter,
                    dwFlags, plistBindingPaths, pnPos);
        }
        ReleaseObj(pncc);
    }

    if (SUCCEEDED(hr))
    {
        // Get rid of FALSE returns
        hr = S_OK;
    }

    TraceError("HrInsertComponents", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrRefreshListView
//
//  Purpose:    Iterate through all installed clients, services and protocols,
//              insert into the list view with the correct binding state with
//              the adapter used in this connection.
//
//  Arguments:
//      hwndList[in]:    Handle of the list view
//      pnc[in]:         The writable INetcfg pointer
//      pnccAdapter[in]: The INetcfgComponent pointer to the adapter used in this connection
//
//  Returns:    HRESULT, Error code.
//
//  Notes:
//
HRESULT HrRefreshListView(HWND hwndList,
                          INetCfg* pnc,
                          INetCfgComponent * pnccAdapter,
                          ListBPObj * plistBindingPaths)
{
    HRESULT hr;
    INT nPos = 0;

    Assert(hwndList);

    // Clients
    hr = HrInsertComponents(hwndList, pnc,
                &GUID_DEVCLASS_NETCLIENT, pnccAdapter, plistBindingPaths,
                &nPos);

    if (SUCCEEDED(hr))
    {
        // Services
        hr = HrInsertComponents(hwndList, pnc,
                &GUID_DEVCLASS_NETSERVICE, pnccAdapter, plistBindingPaths,
                &nPos);
    }

    if (SUCCEEDED(hr))
    {
        // Protocols
        hr = HrInsertComponents(hwndList, pnc,
                &GUID_DEVCLASS_NETTRANS, pnccAdapter, plistBindingPaths,
                &nPos);
    }

    // Now refresh the state of all items
    if (SUCCEEDED(hr))
    {
        hr = HrRefreshCheckListState(hwndList);
    }

    TraceError("HrRefreshListView", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrLvGetSelectedComponent
//
//  Purpose:    Return pointer to the INetCfgComponent of the selected
//              client, service or protocol
//
//  Returns:    S_OK if successful,
//              S_FALSE if list view Macros returns failure
//              (specific error not available).
//
//  Notes:
//
HRESULT HrLvGetSelectedComponent(HWND hwndList,
                                 INetCfgComponent ** ppncc)
{
    HRESULT hr = S_FALSE;

    Assert(hwndList);

    *ppncc = NULL;

    INT iSelected = ListView_GetNextItem(hwndList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM     lvItem = {0};

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;

        if (ListView_GetItem(hwndList, &lvItem))
        {
            NET_ITEM_DATA * pnid;

            pnid = reinterpret_cast<NET_ITEM_DATA *>(lvItem.lParam);

            if (pnid)
            {
                hr = S_OK;
                pnid->pncc->AddRef();
                *ppncc = pnid->pncc;
            }
        }
    }

    TraceError("HrLvGetSelectedComponent", S_FALSE == hr ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LvDeleteItem
//
//  Purpose:    Handles deletion of the given item from the listview. Should
//              be called in response to the LVN_DELETEITEM notification.
//
//  Arguments:
//      hwndList [in]   Listview handle
//      iItem    [in]   item that was deleted
//
//  Returns:    Nothing
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
VOID LvDeleteItem(HWND hwndList, int iItem)
{
    LV_ITEM         lvi = {0};
    NET_ITEM_DATA * pnid;

    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;

    ListView_GetItem(hwndList, &lvi);

    pnid = reinterpret_cast<NET_ITEM_DATA*>(lvi.lParam);

    AssertSz(pnid, "No item data!?!?");

    ReleaseObj(pnid->pncc);
    delete(pnid->pCompObj);
    delete pnid->szwName;
    delete pnid->szwDesc;

    delete pnid;
}

//+---------------------------------------------------------------------------
//
//  Function Name:  OnListClick
//
//  Purpose:
//
//  Returns:
//
INT OnListClick(HWND hwndList,
                HWND hwndParent,
                INetCfg *pnc,
                IUnknown *punk,
                INetCfgComponent *pnccAdapter,
                ListBPObj * plistBindingPaths,
                BOOL fDoubleClk,
                BOOL fReadOnly)
{
    INT iItem;
    DWORD dwpts;
    LV_HITTESTINFO lvhti;

    // we have the location
    dwpts = GetMessagePos();

    lvhti.pt.x = LOWORD( dwpts );
    lvhti.pt.y = HIWORD( dwpts );
    MapWindowPoints(NULL , hwndList , (LPPOINT) &(lvhti.pt) , 1);

    // get currently selected item
    iItem = ListView_HitTest( hwndList, &lvhti );

    // if no selection, or click not on state return false
    if (-1 != iItem)
    {
        // set the current selection
        ListView_SetItemState(hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);

        if ( fDoubleClk )
        {
            if ((LVHT_ONITEMICON != (LVHT_ONITEMICON & lvhti.flags)) &&
                (LVHT_ONITEMLABEL != (LVHT_ONITEMLABEL & lvhti.flags)) &&
                (LVHT_ONITEMSTATEICON != (LVHT_ONITEMSTATEICON & lvhti.flags)) )
            {
                iItem = -1;
            }
        }
        else // single click
        {
            if (LVHT_ONITEMSTATEICON != (LVHT_ONITEMSTATEICON & lvhti.flags))
            {
                iItem = -1;
            }
        }

        if (-1 != iItem)
        {
            HRESULT hr = S_OK;

            if ((fDoubleClk) &&
                (LVHT_ONITEMSTATEICON != (LVHT_ONITEMSTATEICON & lvhti.flags)))
            {
                // only raise properties if the selected component has UI and
                // is not disabled, and the current user has the permission to
                // change properties.

                LV_ITEM lvItem;
                lvItem.mask = LVIF_PARAM;
                lvItem.iItem = iItem;
                lvItem.iSubItem = 0;

                if (ListView_GetItem(hwndList, &lvItem))
                {
                    NET_ITEM_DATA * pnid = NULL;
                    pnid = reinterpret_cast<NET_ITEM_DATA *>(lvItem.lParam);
                    if (pnid)
                    {
                        // is this component checked ?
                        if ((UNCHECKED != (pnid->pCompObj)->GetChkState()) &&
                            (pnid->dwFlags & NCF_HAS_UI) &&
                            FHasPermission(NCPERM_LanChangeProperties))
                        {
                            BOOL fShowProperties = TRUE;

                            if (FIsUserNetworkConfigOps())
                            {
                                LPWSTR pszwId;

                                hr = pnid->pncc->GetId(&pszwId);
                                
                                if (SUCCEEDED(hr))
                                {
                                    if (pszwId)
                                    {
                                        if (!FEqualComponentId (c_szInfId_MS_TCPIP, pszwId))
                                        {
                                            fShowProperties = FALSE;        
                                        }
                                        else if (FEqualComponentId (c_szInfId_MS_TCPIP, pszwId))
                                        {
                                            fShowProperties = TRUE;
                                        }
                                        CoTaskMemFree(pszwId);
                                    }
                                    else
                                    {
                                        fShowProperties = FALSE;
                                    }
                                }
                                else
                                {
                                    fShowProperties = FALSE;
                                }
                            }

                            if (fShowProperties)
                            {
                                hr = HrLvProperties(hwndList, hwndParent, pnc, punk,
                                        pnccAdapter, plistBindingPaths, NULL);
                            }
                        }
                    }
                }
            }
            else
            {
                if (!fReadOnly)
                {
                    hr = HrToggleLVItemState(hwndList, plistBindingPaths, iItem);
                }
            }

            if FAILED(hr)
                iItem = -1;
        }
    }

    return( iItem );
}

//+---------------------------------------------------------------------------
//
//  Function Name:  HrToggleLVItemState
//
//  Purpose:
//
//  Returns:
//
HRESULT HrToggleLVItemState(HWND hwndList,
                       ListBPObj * plistBindingPaths,
                       INT iItem)
{
    HRESULT hr = S_OK;

    LV_ITEM lvItem;
    NET_ITEM_DATA * pnid;

    // we are interested in is the PARAM
    lvItem.iItem = iItem;
    lvItem.mask = LVIF_PARAM;
    lvItem.iSubItem = 0;

    ListView_GetItem( hwndList, &lvItem );

    // get the item
    pnid = (NET_ITEM_DATA *)lvItem.lParam;

    // If the binding checkbox is available, then allow the toggle.
    //
    if (!(pnid->dwFlags & NCF_FIXED_BINDING) &&
        FHasPermission(NCPERM_ChangeBindState))
    {
        if (pnid->pCompObj->GetChkState() == UNCHECKED) // toggle on
        {
            hr = pnid->pCompObj->HrCheck(plistBindingPaths);
            if SUCCEEDED(hr)
            {
                hr = HrRefreshCheckListState(hwndList);
            }

            // "Ding" if the state of this item is still unchecked
            if (pnid->pCompObj->GetChkState() == UNCHECKED)
            {
                #ifdef DBG
                    TraceTag(ttidLanUi, "Why is this component still disabled ???");
                #endif
            }

        }
        else // toggle off
        {
            hr = pnid->pCompObj->HrUncheck(plistBindingPaths);
            if SUCCEEDED(hr)
            {
                hr = HrRefreshCheckListState(hwndList);
            }

            // "Ding" if the state of this item is not unchecked
            if (pnid->pCompObj->GetChkState() != UNCHECKED)
            {
                #ifdef DBG
                    TraceTag(ttidLanUi, "Why is this component not disabled ???");
                #endif
            }
        }
    }

    TraceError("HrToggleLVItemState", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function Name:  OnListKeyDown
//
//  Purpose:
//
//  Returns:
//

INT OnListKeyDown(HWND hwndList, ListBPObj * plistBindingPaths, WORD wVKey)
{
    INT iItem = -1;

    if ((VK_SPACE == wVKey) && (GetAsyncKeyState(VK_MENU)>=0))
    {
        iItem = ListView_GetNextItem(hwndList, -1, LVNI_FOCUSED | LVNI_SELECTED);
        // if no selection
        if (-1 != iItem)
        {
            HRESULT hr = S_OK;
            hr = HrToggleLVItemState(hwndList, plistBindingPaths, iItem);

            if FAILED(hr)
                iItem = -1;
        }
    }

    return( iItem );
}

//+---------------------------------------------------------------------------
//
//  Function Name:  LvSetButtons
//
//  Purpose: Set the correct status of Add, Remove, Property buttons,
//           and the description text
//
//  Returns:
//
VOID LvSetButtons(HWND hwndParent, HANDLES& h, BOOL fReadOnly, IUnknown * punk)
{
    Assert(IsWindow(h.m_hList));
    Assert(IsWindow(h.m_hAdd));
    Assert(IsWindow(h.m_hRemove));
    Assert(IsWindow(h.m_hProperty));

    // enable Property button if valid and update description text
    INT iSelected = ListView_GetNextItem(h.m_hList, -1, LVNI_SELECTED);
    if (iSelected == -1) // Nothing selected or list empty
    {
        ::EnableWindow(h.m_hAdd, !fReadOnly && FHasPermission(NCPERM_AddRemoveComponents));

        if (!fReadOnly)
        {
            // if list is empty, set focus to the list view
            if (0 == ListView_GetItemCount(h.m_hList))
            {
                // remove the default on the remove button
                SendMessage(h.m_hRemove, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

                // move focus to the Add button
                ::SetFocus(h.m_hAdd);
            }
        }

        ::EnableWindow(h.m_hRemove, FALSE);
        ::EnableWindow(h.m_hProperty, FALSE);

        if(h.m_hDescription)
        {
            ::SetWindowText(h.m_hDescription, c_szEmpty);
        }
    }
    else
    {
        // enable Add/Remove buttons
        ::EnableWindow(h.m_hAdd, !fReadOnly && FHasPermission(NCPERM_AddRemoveComponents));

        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(h.m_hList, &lvItem))
        {
            NET_ITEM_DATA * pnid = NULL;
            pnid = reinterpret_cast<NET_ITEM_DATA *>(lvItem.lParam);
            if (pnid)
            {
                if (fReadOnly)
                {
                    ::EnableWindow(h.m_hProperty, FALSE);
                    ::EnableWindow(h.m_hRemove, FALSE);
                }
                else
                {
                    // is this component checked ?
                    if (UNCHECKED != (pnid->pCompObj)->GetChkState())
                    {
                        BOOL    fHasPropertyUi = FALSE;

                        HRESULT hr = S_OK;
                        INetCfgComponent *  pncc;
                        LPWSTR pszwId;
                        
                        hr = HrLvGetSelectedComponent(h.m_hList, &pncc);
                        if (S_OK == hr)
                        {
                            AssertSz(pncc, "No component selected?!?!");
                            hr = pncc->RaisePropertyUi(hwndParent, NCRP_QUERY_PROPERTY_UI, punk);

                            if (S_OK == hr)
                            {
                                fHasPropertyUi = TRUE;
                            }
                            ReleaseObj(pncc);
                        }

                        if (FIsUserNetworkConfigOps() && FHasPermission(NCPERM_LanChangeProperties))
                        {
                            hr = pncc->GetId(&pszwId);
                            
                            if (SUCCEEDED(hr))
                            {
                                if (pszwId && !FEqualComponentId (c_szInfId_MS_TCPIP, pszwId))
                                {
                                    ::EnableWindow(h.m_hProperty, FALSE);
                                }
                                else if (pszwId && FEqualComponentId (c_szInfId_MS_TCPIP, pszwId) && fHasPropertyUi)
                                {
                                    ::EnableWindow(h.m_hProperty, TRUE);
                                }
                            }
                        }
                        else
                        {
                            ::EnableWindow(h.m_hProperty,
                                           fHasPropertyUi &&
                                           FHasPermission(NCPERM_LanChangeProperties));
                        }
                    }
                    else
                    {
                        ::EnableWindow(h.m_hProperty, FALSE);
                    }

                    // is this component user removable ?
                    ::EnableWindow(h.m_hRemove,
                                   !(pnid->dwFlags & NCF_NOT_USER_REMOVABLE) &&
                                     FHasPermission(NCPERM_AddRemoveComponents));
                }

                // set description text
                if(h.m_hDescription)
                {
                    ::SetWindowText(h.m_hDescription, (PCWSTR)pnid->szwDesc);
                }
            }

            // Set focus to  the list (336050)
            SetFocus(h.m_hList);
        }
    }
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLvRemove
//
//  Purpose:    Handles the pressing of the Remove button. Should be called
//              in responsed to the PSB_Remove message.
//
//  Arguments:
//      hwndLV      [in]    Handle of listview
//      hwndParent  [in]    Handle of parent window
//      pnc         [in]    INetCfg being used
//      pnccAdapter [in]    INetCfgComponent of adapter for the connection
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
HRESULT HrLvRemove(HWND hwndLV, HWND hwndParent,
                   INetCfg *pnc, INetCfgComponent *pnccAdapter,
                   ListBPObj * plistBindingPaths)
{
    HRESULT     hr = S_OK;

    INetCfgComponent *  pncc;

    hr = HrLvGetSelectedComponent(hwndLV, &pncc);
    if (S_OK == hr)
    {
        hr = HrQueryUserAndRemoveComponent(hwndParent, pnc, pncc);
        if (NETCFG_S_STILL_REFERENCED == hr)
        {
            hr = S_OK;
        }
        else 
        {
            if (SUCCEEDED(hr))
            {
                HRESULT hrTmp = HrRefreshAll(hwndLV, pnc, pnccAdapter, plistBindingPaths);
                if (S_OK != hrTmp)
                    hr = hrTmp;
            }
        }

        ReleaseObj(pncc);
    }
    else
    {
        TraceTag(ttidLanUi, "HrLvGetSelectedComponent did not get a valid selection.");
    }

    TraceError("HrLvRemove", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLvAdd
//
//  Purpose:    Handles the pressing of the Add button. Should be called in
//              response to the PSB_Add message.
//
//  Arguments:
//      hwndLV      [in]    Handle of listview
//      hwndParent  [in]    Handle of parent window
//      pnc         [in]    INetCfg being used
//      pnccAdapter [in]    INetCfgComponent of adapter for the connection
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
HRESULT HrLvAdd(HWND hwndLV, HWND hwndParent, INetCfg *pnc,
                INetCfgComponent *pnccAdapter,
                ListBPObj * plistBindingPaths)
{
    HRESULT hr;
    CI_FILTER_INFO cfi;

    ZeroMemory(&cfi, sizeof(cfi));

    if (!pnccAdapter)
    {
        return E_INVALIDARG;
    }

    // We want to filter out any irrelvant protocols (i.e. protocols that
    // won't bind to this adapter) so we need to send in a filter info
    // struct with our information.
    cfi.eFilter = FC_LAN; // Apply lan specific filtering
    cfi.pIComp = pnccAdapter; // Filter against this adapter

    INetCfgComponentBindings*  pnccb;
    hr = pnccAdapter->QueryInterface(IID_INetCfgComponentBindings,
                              reinterpret_cast<LPVOID *>(&pnccb));
    if (SUCCEEDED(hr))
    {
        hr = pnccb->SupportsBindingInterface(NCF_UPPER, c_szBiNdisAtm);
        if (S_OK == hr)
        {
            cfi.eFilter = FC_ATM; // Apply lan specific filtering
        }
        ReleaseObj(pnccb);
    }

    hr = HrDisplayAddComponentDialog(hwndParent, pnc, &cfi);
    if ((S_OK == hr) || (NETCFG_S_REBOOT == hr))
    {
        HRESULT hrSave = hr;

        // Refresh the list to reflect changes
        hr = HrRefreshAll(hwndLV, pnc, pnccAdapter, plistBindingPaths);
        if (SUCCEEDED(hr))
            hr = hrSave;
    }
    else if (NETCFG_E_ACTIVE_RAS_CONNECTIONS == hr)
    {
        LvReportError(IDS_LANUI_REQUIRE_DISCONNECT_ADD, hwndParent, NULL, NULL);
    }
    else if (NETCFG_E_NEED_REBOOT == hr)
    {
        LvReportError(IDS_LANUI_REQUIRE_REBOOT_ADD, hwndParent, NULL, NULL);
    }
    else if (S_FALSE != hr)
    {
        PWSTR psz = NULL;

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          hr,
                          LANG_NEUTRAL,
                          (PWSTR)&psz,
                          0,
                          NULL))
        {
            LvReportError(IDS_LANUI_GENERIC_ADD_ERROR, hwndParent, NULL, psz);
            GlobalFree(psz);
        }
        else
        {
            LvReportErrorHr(hr, IDS_LANUI_GENERIC_ADD_ERROR, hwndParent, NULL);
        }
    }

    TraceError("HrLvAdd", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   LvReportError
//
//  Purpose:    Reports a generic error based on the information passed in
//
//  Arguments:
//      ids    [in]     IDS of the string to be used as the text of the
//                      message box
//      hwnd   [in]     Parent HWND
//      szDesc [in]     Display name of component
//      szText [in]     [Optional] If supplied, provides additional string
//                      for replacement. Can be NULL.
//
//  Returns:    Nothing
//
//  Author:     danielwe   6 Jan 1998
//
//  Notes:
//
VOID LvReportError(INT ids, HWND hwnd, PCWSTR szDesc, PCWSTR szText)
{
    if (szDesc && szText)
    {
        NcMsgBox(_Module.GetResourceInstance(), hwnd,
                 IDS_LANUI_ERROR_CAPTION, ids,
                 MB_ICONSTOP | MB_OK, szDesc, szText);
    }
    else if (szDesc)
    {
        NcMsgBox(_Module.GetResourceInstance(), hwnd,
                 IDS_LANUI_ERROR_CAPTION, ids,
                 MB_ICONSTOP | MB_OK, szDesc);
    }
    else if (szText)
    {
        NcMsgBox(_Module.GetResourceInstance(), hwnd,
                 IDS_LANUI_ERROR_CAPTION, ids,
                 MB_ICONSTOP | MB_OK, szText);
    }
    else
    {
        NcMsgBox(_Module.GetResourceInstance(), hwnd,
                 IDS_LANUI_ERROR_CAPTION, ids,
                 MB_ICONSTOP | MB_OK);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LvReportErrorHr
//
//  Purpose:    Reports a generic error based on the information passed in
//
//  Arguments:
//      hr     [in]     HRESULT error value to use in reporting the error
//      ids    [in]     IDS of the string to be used as the text of the
//                      message box
//      hwnd   [in]     Parent HWND
//      szDesc [in]     Display name of component
//
//  Returns:    Nothing
//
//  Author:     danielwe   14 Nov 1997
//
//  Notes:
//
VOID LvReportErrorHr(HRESULT hr, INT ids, HWND hwnd, PCWSTR szDesc)
{
    WCHAR   szText[32];
    static const WCHAR c_szFmt[] = L"0x%08X";

    wsprintfW(szText, c_szFmt, hr);
    LvReportError(ids, hwnd, szDesc, szText);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrLvProperties
//
//  Purpose:    Handles the pressing of the Add button. Should be called in
//              response to the PSB_Properties message.
//
//  Arguments:
//      hwndLV      [in]    Handle of listview
//      hwndParent  [in]    Handle of parent window
//      pnc         [in]    INetCfg being used
//      punk        [in]    IUnknown for interface to query context information
//      bChanged    [out]   Boolean indicating if something changed.
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     danielwe   3 Nov 1997
//
//  Notes:
//
HRESULT HrLvProperties(HWND hwndLV, HWND hwndParent, INetCfg *pnc,
                       IUnknown *punk, INetCfgComponent *pnccAdapter,
                       ListBPObj * plistBindingPaths,
                       BOOL *bChanged)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pncc;

    if ( bChanged )
    {

        *bChanged = FALSE;
    }

    hr = HrLvGetSelectedComponent(hwndLV, &pncc);
    if (S_OK == hr)
    {
        AssertSz(pncc, "No component selected?!?!");

        hr = pncc->RaisePropertyUi(hwndParent, NCRP_SHOW_PROPERTY_UI, punk);

        // if components have been added or removed, we may need
        // to refresh the whole list

        if (S_OK == hr)
        {
            TraceTag(ttidLanUi, "Refreshing component list needed because other components are added or removed.");
            hr = HrRefreshAll(hwndLV, pnc, pnccAdapter, plistBindingPaths);

            if ( bChanged )
            {
                *bChanged = TRUE;
            }
        }

        ReleaseObj(pncc);
    }
    else
    {
        TraceTag(ttidLanUi, "HrLvGetSelectedComponent did not return a valid selection.");
    }

    if (SUCCEEDED(hr))
    {
        // Normalize error result
        hr = S_OK;
    }

    TraceError("HrLvProperties", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRefreshAll
//
//  Purpose:    Rebuilds the collection of BindingPathObj and the list view
//
//  Arguments:
//      hwndList            [in]        Handle of listview
//      pnc                 [in]        INetCfg being used
//      pnccAdapter         [in]        INetCfgComponent of the adapter in this connection
//      plistBindingPaths   [in/out]    The collection of BindingPathObj
//
//  Returns:    S_OK if success, Win32 or OLE error code otherwise
//
//  Author:     tongl   23 Nov 1997
//
//  Notes:
//

HRESULT HrRefreshAll(HWND hwndList,
                     INetCfg* pnc,
                     INetCfgComponent * pnccAdapter,
                     ListBPObj * plistBindingPaths)
{
    HRESULT hr = S_OK;

    ReleaseAll(hwndList, plistBindingPaths);

    hr = HrRebuildBindingPathObjCollection( pnccAdapter,
                                            plistBindingPaths);
    if SUCCEEDED(hr)
    {
        // Set the correct state on the BindingPathObject list
        hr = HrRefreshBindingPathObjCollectionState(plistBindingPaths);

        if SUCCEEDED(hr)
        {
            // Now refresh the list to reflect changes
            hr = HrRefreshListView(hwndList, pnc, pnccAdapter, plistBindingPaths);
        }
    }

    // $REVIEW(tongl 12\16\97): added so we always have a selection.
    // Caller of this function can reset selection if they need to.
    if (SUCCEEDED(hr))
    {
        // Selete the first item
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);
    }

    TraceError("HrRefreshAll", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseAll
//
//  Purpose:    Releases the INetCfgComponent and INetCfgBindingPath objects
//
//  Arguments:
//      hwndList            [in]        Handle of listview
//      plistBindingPaths   [in/out]    The collection of BindingPathObj
//
//  Author:     tongl   18 Mar, 1998
//
//  Notes:
//
VOID ReleaseAll(HWND hwndList,
                     ListBPObj * plistBindingPaths)
{
    // first, clean up any existing objects in the list
    FreeCollectionAndItem(*plistBindingPaths);

    // delete existing items in the list view
    ListView_DeleteAllItems( hwndList );
}

//+---------------------------------------------------------------------------
//
//  Function:   FValidatePageContents
//
//  Purpose:    Check error conditions before LAN property or wizard page
//              exits
//
//  Arguments:
//      hwndDlg             [in]    Handle of dialog
//      hwndList            [in]    Handle of the list view
//      pnc                 [in]    INetCfg
//      pnccAdapter         [in]    INetCfgComponent
//      plistBindignPaths   [in]    List of binding paths to this adater
//
//  Returns:    TRUE if there is a possible error and user wants to fix
//              it before leaving the page. FALSE if no error or user
//              chooses to move on.
//
//  Author:     tongl   17 Sept 1998
//
//  Notes:
//
BOOL FValidatePageContents( HWND hwndDlg,
                            HWND hwndList,
                            INetCfg * pnc,
                            INetCfgComponent * pnccAdapter,
                            ListBPObj * plistBindingPaths)
{
    HRESULT hr = S_OK;

    // 1) Check if any protocol is enabled on this adapter
    BOOL fEnabledProtocolExists = FALSE;

    CIterNetCfgComponent    iterProt(pnc, &GUID_DEVCLASS_NETTRANS);
    INetCfgComponent*       pnccTrans;

    while (SUCCEEDED(hr) && !fEnabledProtocolExists &&
           S_OK == (hr = iterProt.HrNext(&pnccTrans)))
    {
        HRESULT hrTmp;

        INetCfgComponentBindings * pnccb;
        hrTmp = pnccTrans->QueryInterface (
                    IID_INetCfgComponentBindings, (LPVOID*)&pnccb);

        if (S_OK == hrTmp)
        {
            hrTmp = pnccb->IsBindableTo(pnccAdapter);

            if (S_OK == hrTmp)
            {
                fEnabledProtocolExists = TRUE;
            }
            ReleaseObj(pnccb);
        }
        ReleaseObj(pnccTrans);
    }

    if (!fEnabledProtocolExists)
    {
        // warn the user
        int nRet = NcMsgBox(
                            _Module.GetResourceInstance(),
                            hwndDlg,
                            IDS_LANUI_NOPROTOCOL_CAPTION,
                            IDS_LANUI_NOPROTOCOL,
                            MB_APPLMODAL|MB_ICONINFORMATION|MB_YESNO
                            );

        if (nRet == IDYES)
        {
            return TRUE;
        }
    }

    // 2) Check if any component on the display list is in an intent check state
    //    If so, it means these components are actually disabled and will not be
    //    displayed as checked the next time the UI is refreshed.
    tstring strCompList = c_szEmpty;

    // for each item in the list view
    int nlvCount = ListView_GetItemCount(hwndList);

    LV_ITEM lvItem;
    for (int i=0; i< nlvCount; i++)
    {
        lvItem.iItem = i;
        lvItem.iSubItem = 0;

        lvItem.mask = LVIF_PARAM;
        if (ListView_GetItem(hwndList, &lvItem))
        {
            NET_ITEM_DATA * pnid;

            pnid = reinterpret_cast<NET_ITEM_DATA *>(lvItem.lParam);

            if (pnid)
            {
                // get the component object associated with this item
                CComponentObj * pCompObj = pnid->pCompObj;

                if (pCompObj)
                {
                    if (INTENT_CHECKED == pCompObj->m_CheckState)
                    {
                        PWSTR pszwName;
                        hr = pCompObj->m_pncc->GetDisplayName(&pszwName);

                        if (SUCCEEDED(hr))
                        {
                            if (!strCompList.empty())
                                strCompList += SzLoadIds(IDS_NEWLINE);
                            strCompList += pszwName;

                            delete pszwName;
                        }
                    }
                }
            }
        }
    }

    if (!strCompList.empty())
    {
        // warn the user
        int nRet = NcMsgBox(
                            _Module.GetResourceInstance(),
                            hwndDlg,
                            IDS_LANUI_ERROR_CAPTION,
                            IDS_LANUI_INTENTCHECK,
                            MB_APPLMODAL|MB_ICONINFORMATION|MB_YESNO,
                            strCompList.c_str());
        if (nRet == IDNO)
        {
            hr = HrRefreshAll(hwndList, pnc, pnccAdapter, plistBindingPaths);
            return TRUE;
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// EAPOL related util functions
//
//+---------------------------------------------------------------------------

// Location of EAPOL Parameters Service
static WCHAR cszEapKeyEapolServiceParams[] = L"Software\\Microsoft\\EAPOL\\Parameters\\General" ;

static WCHAR cszInterfaceList[] = L"InterfaceList";

//+---------------------------------------------------------------------------
//
// Function called to retrieve the connection data for an interface for a 
// specific EAP type and SSID (if any). Data is stored in the HKLM hive
//
// Input arguments:
//  pwszGUID - GUID string for the interface
//  dwEapTypeId - EAP type for which connection data is to be stored
//  dwSizeOfSSID - Size of Special identifier if any for the EAP blob
//  pwszSSID - Special identifier if any for the EAP blob
//
//  Return values:
//  pbConnInfo - pointer to binary EAP connection data blob
//  dwInfoSize - pointer to size of EAP connection blob
//
//

HRESULT
HrElGetCustomAuthData (
        IN  WCHAR           *pwszGUID,
        IN  DWORD           dwEapTypeId,
        IN  DWORD           dwSizeOfSSID,
        IN  BYTE            *pbSSID,
        IN  OUT BYTE        *pbConnInfo,
        IN  OUT DWORD       *pdwInfoSize
        )
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    HRESULT     hr = S_OK;

    do
    {
        dwRetCode = WZCEapolGetCustomAuthData (
                        NULL,
                        pwszGUID,
                        dwEapTypeId,
                        dwSizeOfSSID,
                        pbSSID,
                        pbConnInfo,
                        pdwInfoSize
                    );

        if (dwRetCode == ERROR_BUFFER_TOO_SMALL)
        {
            hr = E_OUTOFMEMORY;
            dwRetCode = ERROR_SUCCESS;
        }

    } while (FALSE);

    if (dwRetCode != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRetCode);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function called to set the connection data for an interface for a specific
// EAP type and SSID (if any). Data will be stored in the HKLM hive
//
// Input arguments:
//  pwszGUID - pinter to GUID string for the interface
//  dwEapTypeId - EAP type for which connection data is to be stored
//  dwSizeOfSSID - Size of Special identifier if any for the EAP blob
//  pwszSSID - Special identifier if any for the EAP blob
//  pbConnInfo - pointer to binary EAP connection data blob
//  dwInfoSize - Size of EAP connection blob
//
//  Return values:
//

HRESULT
HrElSetCustomAuthData (
        IN  WCHAR       *pwszGUID,
        IN  DWORD       dwEapTypeId,
        IN  DWORD       dwSizeOfSSID,
        IN  BYTE        *pbSSID,
        IN  PBYTE       pbConnInfo,
        IN  DWORD       dwInfoSize
        )
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    HRESULT     hr = S_OK;

    do
    {
        dwRetCode = WZCEapolSetCustomAuthData (
                        NULL,
                        pwszGUID,
                        dwEapTypeId,
                        dwSizeOfSSID,
                        pbSSID,
                        pbConnInfo,
                        dwInfoSize
                    );

    } while (FALSE);

    if (dwRetCode != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRetCode); 
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function called to retrieve the EAPOL parameters for an interface
//
// Input arguments:
//  pwszGUID - GUID string for the interface
//  
//  Return values:
//  pdwDefaultEAPType - default EAP type for interface
//  pIntfParams - Interface parameters
//

HRESULT
HrElGetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  OUT EAPOL_INTF_PARAMS       *pIntfParams
        )
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    HRESULT     hr = S_OK;

    do
    {
        dwRetCode = WZCEapolGetInterfaceParams (
                        NULL,
                        pwszGUID,
                        pIntfParams
                );

    } while (FALSE);

    if (dwRetCode != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRetCode);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function called to set the EAPOL parameters for an interface
//
// Input arguments:
//  pwszGUID - GUID string for the interface
//  pIntfParams - Interface parameters
//
//  Return values:
//

HRESULT
HrElSetInterfaceParams (
        IN  WCHAR           *pwszGUID,
        IN  EAPOL_INTF_PARAMS       *pIntfParams
        )
{
    DWORD       dwRetCode = ERROR_SUCCESS;
    HRESULT     hr = S_OK;

    do
    {
        dwRetCode = WZCEapolSetInterfaceParams (
                        NULL,
                        pwszGUID,
                        pIntfParams
                    );

    } while (FALSE);

    if (dwRetCode != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwRetCode);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Set selection in listbox 'hwndLb' to 'nIndex' and notify parent as if
// user had clicked the item which Windows doesn't do for some reason.
//

VOID
ComboBox_SetCurSelNotify (
    IN HWND hwndLb,
    IN INT  nIndex 
    )
{
    ComboBox_SetCurSel( hwndLb, nIndex );

    SendMessage(
        GetParent( hwndLb ),
        WM_COMMAND,
        (WPARAM )MAKELONG(
            (WORD )GetDlgCtrlID( hwndLb ), (WORD )CBN_SELCHANGE ),
        (LPARAM )hwndLb );
}


//+---------------------------------------------------------------------------
//
// Set the width of the drop-down list 'hwndLb' to the width of the
// longest item (or the width of the list box if that's wider).
//

VOID
ComboBox_AutoSizeDroppedWidth (
    IN HWND hwndLb 
    )
{
    HDC    hdc;
    HFONT  hfont;
    TCHAR* psz;
    SIZE   size;
    DWORD  cch;
    DWORD  dxNew;
    DWORD  i;

    hfont = (HFONT )SendMessage( hwndLb, WM_GETFONT, 0, 0 );
    if (!hfont)
        return;

    hdc = GetDC( hwndLb );
    if (!hdc)
        return;

    SelectObject( hdc, hfont );

    dxNew = 0;
    for (i = 0; psz = ComboBox_GetPsz( hwndLb, i ); ++i)
    {
        cch = lstrlen( psz );
        if (GetTextExtentPoint32( hdc, psz, cch, &size ))
        {
            if (dxNew < (DWORD )size.cx)
                dxNew = (DWORD )size.cx;
        }

        free ( psz );
    }

    ReleaseDC( hwndLb, hdc );

    // Allow for the spacing on left and right added by the control.
    
    dxNew += 6;

    // Figure out if the vertical scrollbar will be displayed and, if so,
    // allow for it's width.
    
    {
        RECT  rectD;
        RECT  rectU;
        DWORD dyItem;
        DWORD cItemsInDrop;
        DWORD cItemsInList;

        GetWindowRect( hwndLb, &rectU );
        SendMessage( hwndLb, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM )&rectD );
        dyItem = (DWORD)SendMessage( hwndLb, CB_GETITEMHEIGHT, 0, 0 );
        cItemsInDrop = (rectD.bottom - rectU.bottom) / dyItem;
        cItemsInList = ComboBox_GetCount( hwndLb );
        if (cItemsInDrop < cItemsInList)
            dxNew += GetSystemMetrics( SM_CXVSCROLL );
    }

    SendMessage( hwndLb, CB_SETDROPPEDWIDTH, dxNew, 0 );
}


//+---------------------------------------------------------------------------
//
// Adds data item 'pItem' with displayed text 'pszText' to listbox
// 'hwndLb'.  The item is added sorted if the listbox has LBS_SORT style,
// or to the end of the list otherwise.  If the listbox has LB_HASSTRINGS
// style, 'pItem' is a null terminated string, otherwise it is any user
// defined data.
//
// Returns the index of the item in the list or negative if error.
//

INT
ComboBox_AddItem(
    IN HWND    hwndLb,
    IN LPCTSTR pszText,
    IN VOID*   pItem 
    )
{
    INT nIndex;

    nIndex = ComboBox_AddString( hwndLb, pszText );
    if (nIndex >= 0)
        ComboBox_SetItemData( hwndLb, nIndex, pItem );
    return nIndex;
}


//+---------------------------------------------------------------------------
//
// Returns the address of the 'nIndex'th item context in 'hwndLb' or NULL
// if none.
//

VOID*
ComboBox_GetItemDataPtr (
    IN HWND hwndLb,
    IN INT  nIndex 
    )
{
    LRESULT lResult;

    if (nIndex < 0)
        return NULL;

    lResult = ComboBox_GetItemData( hwndLb, nIndex );
    if (lResult < 0)
        return NULL;

    return (VOID* )lResult;
}


//+---------------------------------------------------------------------------
//
// Returns heap block containing the text contents of the 'nIndex'th item
// of combo box 'hwnd' or NULL.  It is caller's responsibility to Free the
// returned string.
//

TCHAR*
ComboBox_GetPsz (
    IN HWND hwnd,
    IN INT  nIndex 
    )
{
    INT    cch;
    TCHAR* psz;

    cch = ComboBox_GetLBTextLen( hwnd, nIndex );
    if (cch < 0)
        return NULL;

    psz = new TCHAR[( cch + 1)];

    if (psz)
    {
        *psz = TEXT('\0');
        ComboBox_GetLBText( hwnd, nIndex, psz );
    }

    return psz;
}


static WCHAR WZCSVC_SERVICE_NAME[] = L"WZCSVC";


//+---------------------------------------------------------------------------
//
// ElCanEapolRunOnInterface:
//
// Function to verify if EAPOL can ever be started on an interface
//
// Returns TRUE if:
//  WZCSVC service is running and WZCSVC has bound to the interface
//
//

BOOL
ElCanEapolRunOnInterface (
        IN  INetConnection  *pconn
        )
{
    SC_HANDLE       hServiceCM = NULL;
    SC_HANDLE       hWZCSVCService = NULL;
    SERVICE_STATUS  WZCSVCServiceStatus;
    WCHAR           wszGuid[c_cchGuidWithTerm];
    NETCON_PROPERTIES* pProps = NULL;
    BOOL            fIsOK = TRUE;
    DWORD           dwType = 0;
    DWORD           dwSizeOfList = 0;
    WCHAR           *pwszRegInterfaceList = NULL;
    DWORD           dwDisposition = 0;
    HKEY            hkey = NULL;
    EAPOL_INTF_PARAMS   EapolIntfParams;
    LONG            lError = ERROR_SUCCESS;
    DWORD           dwRetCode = NO_ERROR;
    HRESULT         hr = S_OK;

    do 
    {

        //
        // Query status of WZCSVC service
        // Do not display tab if WZCSVC service is not running
        //
    
        if ((hServiceCM = OpenSCManager ( NULL, NULL, GENERIC_READ )) 
             == NULL)
        {
            dwRetCode = GetLastError ();
         
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: OpenSCManager failed with error %ld",
                    dwRetCode); 
            fIsOK = FALSE;
            break;
        }

        if ((hWZCSVCService = 
                    OpenService ( hServiceCM, WZCSVC_SERVICE_NAME, GENERIC_READ )) 
                == NULL)
        {
            dwRetCode = GetLastError ();
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: OpenService failed with error %ld",
                    dwRetCode);
            fIsOK = FALSE;
            break;
        }

        if (!QueryServiceStatus ( hWZCSVCService, &WZCSVCServiceStatus ))
        {
            dwRetCode = GetLastError ();
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: StartService failed with error %ld",
                    dwRetCode);
            fIsOK = FALSE;
            break;
        }

        if ( WZCSVCServiceStatus.dwCurrentState != SERVICE_RUNNING )
        {
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: WZCSVC service not running !!!");
    
            fIsOK = FALSE;
            break;
        }

        TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: WZCSVC service is indeed running !!!");

        if (!CloseServiceHandle ( hWZCSVCService ))
        {
            dwRetCode = GetLastError ();
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: CloseService failed with error %ld",
                    dwRetCode);
            fIsOK = FALSE;
            break;
        }
        hWZCSVCService = NULL;

        if (!CloseServiceHandle ( hServiceCM ))
        {
            dwRetCode = GetLastError ();
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: CloseService failed with error %ld",
                    dwRetCode);
            fIsOK = FALSE;
            break;
        }
        hServiceCM = NULL;

        //
        // Check if NDISUIO is bound to interface
        //

        hr = pconn->GetProperties (&pProps);
        if (SUCCEEDED(hr))
        {
            if (::StringFromGUID2 (pProps->guidId, wszGuid, c_cchGuidWithTerm) 
                    == 0)
            {
                TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: StringFromGUID2 failed"); 
                fIsOK = FALSE;
                FreeNetconProperties(pProps);
                break;
            }
            FreeNetconProperties(pProps);
        }
        else
        {
            break;
        }

        // Fetch InterfaceList from registry
        // Search for GUID string in registry

        // Get handle to 
        // HKLM\Software\Microsoft\EAPOL\Parameters\Interfaces\General

        hr = HrRegCreateKeyEx (
                        HKEY_LOCAL_MACHINE,
                        cszEapKeyEapolServiceParams,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ,
                        NULL,
                        &hkey,
                        &dwDisposition);
        if (!SUCCEEDED (hr))
        {
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: Error in HrRegCreateKeyEx for base key, %ld",
                    LresFromHr(hr));
            fIsOK = FALSE;
            break;
        }


        // Query the value of 
        // ...\EAPOL\Parameters\Interfaces\General\InterfaceList key

        dwSizeOfList = 0;

        hr = HrRegQueryValueEx (
                        hkey,
                        cszInterfaceList,
                        &dwType,
                        NULL,
                        &dwSizeOfList);
        if (SUCCEEDED (hr))
        {
            pwszRegInterfaceList = (WCHAR *) new BYTE [dwSizeOfList];
            if (pwszRegInterfaceList == NULL)
            {
                hr = E_OUTOFMEMORY;
                fIsOK = FALSE;
                break;
            }

            hr = HrRegQueryValueEx (
                            hkey,
                            cszInterfaceList,
                            &dwType,
                            (LPBYTE)pwszRegInterfaceList,
                            &dwSizeOfList); 
            if (!SUCCEEDED(hr))
            {
                    
                TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: Error in HrRegQueryValueEx acquiring value for InterfaceList, %ld",
                        LresFromHr(hr));
                break;
            }

            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: Query value succeeded = %ws, size=%ld, search GUID = %ws",
                pwszRegInterfaceList, dwSizeOfList, wszGuid);
        }
        else
        {
                TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: Error in HrRegQueryValueEx size estimation for InterfaceList, %ld",
                    LresFromHr(hr));
                fIsOK = FALSE;
                break;
        }

        if (wcsstr (pwszRegInterfaceList, wszGuid))
        {
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface interface found in interface list !!!");
        }
        else
        {
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface interface *not* found in interface list !!!");
            fIsOK = FALSE;
            break;
        }

    } while (FALSE);

    if (hkey != NULL)
    {
        RegSafeCloseKey (hkey);
    }

    if (pwszRegInterfaceList != NULL)
    {
        free (pwszRegInterfaceList);
    }

    if (hWZCSVCService != NULL)
    {
        if (!CloseServiceHandle ( hWZCSVCService ))
        {
            dwRetCode = GetLastError ();
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: CloseService failed with error %ld",
                    dwRetCode);
        }
    }

    if (hServiceCM != NULL)
    {
        if (!CloseServiceHandle ( hServiceCM ))
        {
            dwRetCode = GetLastError ();
            TraceTag (ttidLanUi, "ElCanEapolRunOnInterface: CloseService failed with error %ld",
                    dwRetCode);
        }
    }
    
    return fIsOK;

}



#ifdef ENABLETRACE
//+---------------------------------------------------------------------------
//
//  Function:   PrintBindingPath
//
//  Purpose:    Prints the binding path ID and a list of component IDs on
//              the path from top down
//
//  Arguments:
//
//  Returns:
//
//  Author:     tongl   26 Nov 1997
//
//  Notes:
//
VOID PrintBindingPath (
    TRACETAGID ttidToTrace,
    INetCfgBindingPath* pncbp,
    PCSTR pszaExtraText)
{
    Assert (pncbp);

    if (!pszaExtraText)
    {
        pszaExtraText = "";
    }

    const WCHAR c_szSept[] = L"->";

    tstring strPath;
    INetCfgComponent * pnccNetComponent;
    PWSTR pszwCompId;
    HRESULT hr;

    // Get the top component
    hr = pncbp->GetOwner(&pnccNetComponent);
    if (SUCCEEDED(hr))
    {
        hr = pnccNetComponent->GetId(&pszwCompId);
        if SUCCEEDED(hr)
        {
            strPath += pszwCompId;
            CoTaskMemFree(pszwCompId);
        }
    }
    ReleaseObj(pnccNetComponent);

    // Get Comp ID for other component on the path
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface * pncbi;

    //Go through interfaces of the binding path
    while (SUCCEEDED(hr) && (hr = ncbiIter.HrNext(&pncbi)) == S_OK)
    {
        strPath += c_szSept;

        // Get the lower component
        hr = pncbi->GetLowerComponent(&pnccNetComponent);
        if(SUCCEEDED(hr))
        {
            hr = pnccNetComponent->GetId(&pszwCompId);
            if (SUCCEEDED(hr))
            {
                strPath += pszwCompId;
                CoTaskMemFree(pszwCompId);
            }
        }
        ReleaseObj(pnccNetComponent);
        ReleaseObj(pncbi);
    }

    if (hr == S_FALSE) // We just got to the end of the loop
        hr = S_OK;

    BOOL fEnabled = (S_OK == pncbp->IsEnabled());

    // Now print the path and ID
    char szaBuf[1024];
    wsprintfA (szaBuf, "[%s] %S: %s",
        (fEnabled) ? "x" : " ",
        strPath.c_str(),
        pszaExtraText);

    TraceTag (ttidToTrace, szaBuf);

    TraceError ("PrintBindingPath", hr);
}
#endif //ENABLETRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\wzcprops.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncui.h"
#include "lanui.h"
#include "lanhelp.h"
#include "wzcprops.h"
#include "wzcui.h"

////////////////////////////////////////////////////////////////////////
// CWZCConfigProps related stuff
//
//+---------------------------------------------------------------------------
// class constructor
CWZCConfigProps::CWZCConfigProps()
{
    ZeroMemory(&m_wzcConfig, sizeof(WZC_WLAN_CONFIG));
    m_wzcConfig.Length = sizeof(WZC_WLAN_CONFIG);
    m_wzcConfig.InfrastructureMode = Ndis802_11Infrastructure;
}

//+---------------------------------------------------------------------------
// Uploads the configuration into the dialog's internal data
DWORD
CWZCConfigProps::UploadWzcConfig(CWZCConfig *pwzcConfig)
{
    CopyMemory(&m_wzcConfig, &(pwzcConfig->m_wzcConfig), sizeof(WZC_WLAN_CONFIG));
    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
// INIT_DIALOG handler
LRESULT
CWZCConfigProps::OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    DWORD dwStyle;
    HRESULT hr = S_OK;

    // get all the controls handles
    m_hwndEdSSID = GetDlgItem(IDC_WZC_EDIT_SSID);
    m_hwndChkAdhoc = GetDlgItem(IDC_ADHOC);
    m_hwndUsePW = GetDlgItem(IDC_USEPW);

    // initialize the SSID field with the SSID, if one is given
    if (m_wzcConfig.Ssid.SsidLength != 0)
    {
        // ugly but this is life. In order to convert the SSID to LPWSTR we need a buffer.
        // We know an SSID can't exceed 32 chars (see NDIS_802_11_SSID from ntddndis.h) so
        // make room for the null terminator and that's it. We could do mem alloc but I'm
        // not sure it worth the effort (at runtime).
        WCHAR   wszSSID[33];
        UINT    nLenSSID = 0;

        // convert the LPSTR (original SSID format) to LPWSTR (needed in List Ctrl)
        nLenSSID = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        (LPCSTR)m_wzcConfig.Ssid.Ssid,
                        m_wzcConfig.Ssid.SsidLength,
                        wszSSID,
                        celems(wszSSID));
        if (nLenSSID != 0)
        {
            wszSSID[nLenSSID] = L'\0';
            ::SetWindowText(m_hwndEdSSID, wszSSID);
        }
    }

    // Check the "this network is adhoc" box if neccessary.
    ::SendMessage(m_hwndChkAdhoc, BM_SETCHECK, (m_wzcConfig.InfrastructureMode == Ndis802_11IBSS) ? BST_CHECKED : BST_UNCHECKED, 0);
    // the SSID can't be under any circumstances larger than 32 chars
    ::SendMessage(m_hwndEdSSID, EM_LIMITTEXT, 32, 0);
    ::SendMessage(m_hwndUsePW, BM_SETCHECK, (m_wzcConfig.Privacy == 1) ? BST_CHECKED : BST_UNCHECKED, 0);

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
// OK button handler
LRESULT
CWZCConfigProps::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bHandled = TRUE;
    EndDialog(IDOK);
    return 0;
}

//+---------------------------------------------------------------------------
// Cancel button handler
LRESULT
CWZCConfigProps::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // return S_FALSE on cancel
    bHandled = TRUE;
    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
// Context sensitive help handler
extern const WCHAR c_szNetCfgHelpFile[];
LRESULT
CWZCConfigProps::OnContextMenu(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& fHandled)
{
    ::WinHelp(m_hWnd,
              c_szNetCfgHelpFile,
              HELP_CONTEXTMENU,
              (ULONG_PTR)g_aHelpIDs_IDC_WZC_DLG_VPROPS);

    return 0;
}
LRESULT 
CWZCConfigProps::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_IDC_WZC_DLG_VPROPS);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\wzcui.h ===
extern "C" {
#include "ntddndis.h"
#include "wzcsapi.h"
}

#pragma once

////////////////////////////////////////////////////////////////////////
// CWZCConfig related stuff
//
// flags used in CWZCConfig::m_dwFlags
// the entry is preferred (user defined)
#define WZC_DESCR_PREFRD    0x00000001
// the entry is currently visible in the air
#define WZC_DESCR_VISIBLE   0x00000002
// the entry is currently active (the one plumbed to the adapter)
#define WZC_DESCR_ACTIVE    0x00000004

// object attached to each entry in the list
class CWZCConfig
{
public:
    class CWZCConfig    *m_pPrev, *m_pNext;
    INT                 m_nListIndex;           // index of the entry in the list
    DWORD               m_dwFlags;              // WZC_DESCR* flags
    WZC_WLAN_CONFIG     m_wzcConfig;            // all WZC configuration
    class CEapolConfig  *m_pEapolConfig;        // all 802.1x configuration

public:
    // constructor
    CWZCConfig(DWORD dwFlags, PWZC_WLAN_CONFIG pwzcConfig);
    // destructor
    ~CWZCConfig();
    // checks whether this SSID matches with the one from pwzcConfig
    BOOL Match(PWZC_WLAN_CONFIG pwzcConfig);
    // checks whether this configuration is weaker than the one given as parameter
    BOOL Weaker(PWZC_WLAN_CONFIG pwzcConfig);

    // add the Configuration to the list of entries in the list view
    DWORD AddConfigToListView(HWND hwndLV, INT nPos);
};

////////////////////////////////////////////////////////////////////////
// CWZeroConfPage related stuff
//
// flags used to select state & item images
#define WZCIMG_PREFR_NOSEL     0    // empty check box
#define WZCIMG_PREFR_SELECT    1    // checked check box
#define WZCIMG_INFRA_AIRING    2    // infra icon
#define WZCIMG_INFRA_ACTIVE    3    // infra icon + blue circle
#define WZCIMG_INFRA_SILENT    4    // infra icon + red cross
#define WZCIMG_ADHOC_AIRING    5    // adhoc icon
#define WZCIMG_ADHOC_ACTIVE    6    // adhoc icon + blue circle
#define WZCIMG_ADHOC_SILENT    7    // adhoc icon + red cross

// flags indicating various operational actions.
// flags are used in:
//   AddUniqueConfig()
//   RefreshListView()
#define WZCADD_HIGROUP     0x00000001   // add in front of its group
#define WZCADD_OVERWRITE   0x00000002   // overwrite data
#define WZCOP_VLIST        0x00000004   // operate on the visible list
#define WZCOP_PLIST        0x00000008   // operate on the preferred list

class CWZCConfigPage;
class CWLANAuthenticationPage;

class CWZeroConfPage: public CPropSheetPage
{
    INetConnection *        m_pconn;
    INetCfg *               m_pnc;
    IUnknown *              m_punk;
    const DWORD *           m_adwHelpIDs;

    // zero conf data on the interface
    BOOL        m_bHaveWZCData;
    INTF_ENTRY  m_IntfEntry;
    DWORD       m_dwOIDFlags;
    UINT        m_nTimer;
    HCURSOR     m_hCursor;

    // handles to the controls
    HWND    m_hckbEnable;   // checkbox for enabling / disabling the service
    HWND    m_hwndVLV;      // list ctrl holding the visible configurations
    HWND    m_hwndPLV;      // list ctrl holding the preferred configurations
    HWND    m_hbtnCopy;     // "Copy" button
    HWND    m_hbtnRfsh;     // "Refresh" button
    HWND    m_hbtnAdd;      // "Add" button
    HWND    m_hbtnRem;      // "Remove" button
    HWND    m_hbtnUp;       // "Up" button
    HWND    m_hbtnDown;     // "Down" button
    HWND    m_hbtnAdvanced; // "Advanced" button
    HWND    m_hbtnProps;    // "Properties" button
    HWND    m_hlblVisNet;   // "Visible Networks" label
    HWND    m_hlblPrefNet;  // "Prefered Networks" label
    HWND    m_hlblAvail;    // "Available networks" description
    HWND    m_hlblPrefDesc; // "Prefered Networks" description
    HWND    m_hlblAdvDesc;  // "Advacned" description
    // Handle to the images
    HIMAGELIST  m_hImgs;    // list items images
    HICON       m_hIcoUp;   // "Up" icon
    HICON       m_hIcoDown; // "Down" icon

    // current Infrastructure mode
    UINT        m_dwCtlFlags;

    // internal lists
    CWZCConfig   *m_pHdVList;   // list of visible configs
    CWZCConfig   *m_pHdPList;   // list of preferred configs

private:
    DWORD InitListViews();
    DWORD GetOIDs(DWORD dwInFlags, LPDWORD pdwOutFlags);
    DWORD HelpCenter(LPCTSTR wszTopic);

public:
    // misc public handlers
    BOOL IsWireless();
    BOOL IsConfigInList(CWZCConfig *pHdList, PWZC_WLAN_CONFIG pwzcConfig, CWZCConfig **ppMatchingConfig = NULL);
    // calls operating only on the internal lists (m_pHdVList or m_pHdPList)
    DWORD AddUniqueConfig(
            DWORD dwOpFlags,                    // operation specific flags (see WZCADD_* flags)
            DWORD dwEntryFlags,                 // flags for the config to be inserted
            PWZC_WLAN_CONFIG pwzcConfig,        // WZC Configuration
            CEapolConfig *pEapolConfig = NULL,  // [in] pointer to the Eapol configuration object (if available)
            CWZCConfig **ppNewNode = NULL);     // [out] gives the pointer of the newly created config object
    DWORD FillVisibleList(PWZC_802_11_CONFIG_LIST pwzcVList);
    DWORD FillPreferredList(PWZC_802_11_CONFIG_LIST pwzcPList);
    DWORD FillCurrentConfig(PINTF_ENTRY pIntf);
    DWORD RefreshListView(DWORD dwFlags);
    DWORD RefreshButtons();
    DWORD SwapConfigsInListView(INT nIdx1, INT nIdx2, CWZCConfig * & pConfig1, CWZCConfig * & pConfig2);
    DWORD SavePreferredConfigs(PINTF_ENTRY pIntf);

public:
    // UI handlers
    BEGIN_MSG_MAP(CWZeroConfPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(NM_DBLCLK, OnDblClick)
        NOTIFY_CODE_HANDLER(NM_CLICK, OnClick)
        NOTIFY_CODE_HANDLER(NM_RETURN, OnReturn)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)
        COMMAND_ID_HANDLER(IDC_WZC_CHK_EnableWZC, OnChkWZCEnable)
        COMMAND_ID_HANDLER(IDC_WZC_BTN_COPY, OnPushAddOrCopy)
        COMMAND_ID_HANDLER(IDC_WZC_BTN_RFSH, OnPushRefresh)
        COMMAND_ID_HANDLER(IDC_WZC_BTN_ADD, OnPushAddOrCopy)
        COMMAND_ID_HANDLER(IDC_WZC_BTN_REM, OnPushRemove)
        COMMAND_ID_HANDLER(IDC_WZC_BTN_UP, OnPushUpOrDown)
        COMMAND_ID_HANDLER(IDC_WZC_BTN_DOWN, OnPushUpOrDown)
        COMMAND_ID_HANDLER(IDC_ADVANCED, OnPushAdvanced)
        COMMAND_ID_HANDLER(IDC_PROPERTIES, OnPushProperties)
    END_MSG_MAP()

    CWZeroConfPage(
        IUnknown* punk,
        INetCfg* pnc,
        INetConnection* pconn,
        const DWORD * adwHelpIDs = NULL);

    ~CWZeroConfPage();

    // initialization / termination members
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    // Help related members
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    // Timer related members
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    // List actions
    LRESULT OnDblClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnClick(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnReturn(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    // Controls actions
    LRESULT OnChkWZCEnable(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPushAddOrCopy(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPushRefresh(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPushUpOrDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPushRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPushAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPushProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
    HRESULT _DoProperties(HWND hwndLV, int iItem);
    INT _DoModalPropSheet(CWZCConfigPage *pPpWzcPage, CWLANAuthenticationPage *pPpAuthPage, BOOL bCustomizeTitle = FALSE);
    // The advanced dialog
    static INT_PTR CALLBACK AdvancedDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\lanui\wzcui.cpp ===
#include "pch.h"
#pragma hdrstop
#include "connutil.h"
#include "ncnetcon.h"
#include "ncperms.h"
#include "ncui.h"
#include "lanui.h"
#include "xpsp1res.h"
#include "eapolui.h"
#include "util.h"
#include "lanhelp.h"
#include "wzcprops.h"
#include "eapolpage.h"
#include "wzcpage.h"
#include "wzcui.h"

////////////////////////////////////////////////////////////////////////
// CWZCConfig related stuff
//
//+---------------------------------------------------------------------------
// constructor
CWZCConfig::CWZCConfig(DWORD dwFlags, PWZC_WLAN_CONFIG pwzcConfig)
{
    m_dwFlags = dwFlags;
    CopyMemory(&m_wzcConfig, pwzcConfig, sizeof(WZC_WLAN_CONFIG));
    m_pPrev = m_pNext = this;
    m_nListIndex = -1;
    m_pEapolConfig = NULL;
}

//+---------------------------------------------------------------------------
// destructor
CWZCConfig::~CWZCConfig()
{
    // remove the object from the list
    m_pPrev->m_pNext = m_pNext;
    m_pNext->m_pPrev = m_pPrev;
    if (m_pEapolConfig != NULL)
    {
        delete m_pEapolConfig;
        m_pEapolConfig = NULL;
    }
}

//+---------------------------------------------------------------------------
// checks whether this configuration matches with the one from pwzcConfig
BOOL
CWZCConfig::Match(PWZC_WLAN_CONFIG pwzcConfig)
{
    BOOL bMatch;

    // check whether the InfrastructureMode matches
    bMatch = (m_wzcConfig.InfrastructureMode == pwzcConfig->InfrastructureMode);
    // check whether the SSIDs are of the same length
    bMatch = bMatch && (m_wzcConfig.Ssid.SsidLength == pwzcConfig->Ssid.SsidLength);
    if (bMatch && m_wzcConfig.Ssid.SsidLength != 0)
    {
        // in case of Non empty SSIDs, check if they're the same
        bMatch = (memcmp(m_wzcConfig.Ssid.Ssid,
                         pwzcConfig->Ssid.Ssid,
                         m_wzcConfig.Ssid.SsidLength)) == 0;
    }

    return bMatch;
}

//+---------------------------------------------------------------------------
// checks whether this configuration is weaker than the one given as parameter
BOOL 
CWZCConfig::Weaker(PWZC_WLAN_CONFIG pwzcConfig)
{
    BOOL bWeaker = FALSE;

    // a configuration is stronger if its privacy bit is set while the matching one is not set
    if (m_wzcConfig.Privacy != pwzcConfig->Privacy)
        bWeaker = pwzcConfig->Privacy;
    // if privacy bits are identical, a configuration is stronger if it has Open Auth mode
    else if (m_wzcConfig.AuthenticationMode != pwzcConfig->AuthenticationMode)
        bWeaker = (pwzcConfig->AuthenticationMode == Ndis802_11AuthModeOpen);

    return bWeaker;
}

DWORD
CWZCConfig::AddConfigToListView(HWND hwndLV, INT nPos)
{
    DWORD   dwErr = ERROR_SUCCESS;
    // ugly but this is life. In order to convert the SSID to LPWSTR we need a buffer.
    // We know an SSID can't exceed 32 chars (see NDIS_802_11_SSID from ntddndis.h) so
    // make room for the null terminator and that's it. We could do mem alloc but I'm
    // not sure it worth the effort (at runtime).
    WCHAR   wszSSID[33];
    UINT    nLenSSID = 0;

    // convert the LPSTR (original SSID format) to LPWSTR (needed in List Ctrl)
    if (m_wzcConfig.Ssid.SsidLength != 0)
    {
        nLenSSID = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        (LPCSTR)m_wzcConfig.Ssid.Ssid,
                        m_wzcConfig.Ssid.SsidLength,
                        wszSSID,
                        celems(wszSSID));

        if (nLenSSID == 0)
            dwErr = GetLastError();
    }

    if (dwErr == ERROR_SUCCESS)
    {
        LVITEM lvi={0};
        UINT   nImgIdx;

        // put the null terminator
        wszSSID[nLenSSID]=L'\0';

        // get the item's image index
        if (m_wzcConfig.InfrastructureMode == Ndis802_11Infrastructure)
        {
            nImgIdx = (m_dwFlags & WZC_DESCR_ACTIVE) ? WZCIMG_INFRA_ACTIVE :
                        ((m_dwFlags & WZC_DESCR_VISIBLE) ? WZCIMG_INFRA_AIRING : WZCIMG_INFRA_SILENT);
        }
        else
        {
            nImgIdx = (m_dwFlags & WZC_DESCR_ACTIVE) ? WZCIMG_ADHOC_ACTIVE :
                        ((m_dwFlags & WZC_DESCR_VISIBLE) ? WZCIMG_ADHOC_AIRING : WZCIMG_ADHOC_SILENT);
        }

        lvi.iItem = nPos;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        lvi.pszText = wszSSID;
        lvi.iImage = nImgIdx;
        lvi.lParam = (LPARAM)this;
        // store the list position in the object
        m_nListIndex = ListView_InsertItem(hwndLV, &lvi);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////
// CWZeroConfPage related stuff
//
#define RFSH_TIMEOUT    3500
UINT g_TimerID = 371;

//+=================== PRIVATE MEMBERS =================================
DWORD
CWZeroConfPage::InitListViews()
{
    RECT        rc;
    LV_COLUMN   lvc = {0};
    DWORD       dwStyle;

    // initialize the image list styles
    dwStyle = ::GetWindowLong(m_hwndVLV, GWL_STYLE);
    ::SetWindowLong(m_hwndVLV, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));
    dwStyle = ::GetWindowLong(m_hwndPLV, GWL_STYLE);
    ::SetWindowLong(m_hwndPLV, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));

    // Create state image lists
    m_hImgs = ImageList_LoadBitmapAndMirror(
        _Module.GetResourceInstance(),
        MAKEINTRESOURCE(IDB_WZCSTATE),
        16,
        0,
        PALETTEINDEX(6));

    ListView_SetImageList(m_hwndVLV, m_hImgs, LVSIL_SMALL);
    ListView_SetImageList(m_hwndPLV, m_hImgs, LVSIL_SMALL);
        
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;

    ::GetClientRect(m_hwndVLV, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    //lvc.cx = rc.right;
    ListView_InsertColumn(m_hwndVLV, 0, &lvc);

    ::GetClientRect(m_hwndPLV, &rc);
    lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);
    //lvc.cx = rc.right;
    ListView_InsertColumn(m_hwndPLV, 0, &lvc);

    ListView_SetExtendedListViewStyleEx(m_hwndPLV, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);
    ListView_SetExtendedListViewStyleEx(m_hwndVLV, LVS_EX_FULLROWSELECT, LVS_EX_FULLROWSELECT);

    return ERROR_SUCCESS;
}

//+=================== PUBLIC  MEMBERS =================================
//+---------------------------------------------------------------------
// CWZeroConfPage constructor
CWZeroConfPage::CWZeroConfPage(
    IUnknown* punk,
    INetCfg* pnc,
    INetConnection* pconn,
    const DWORD * adwHelpIDs)
{
    m_pconn = pconn;
    m_pnc = pnc;
    m_adwHelpIDs = adwHelpIDs;

    // initialize the WZC data
    m_bHaveWZCData = FALSE;
    ZeroMemory(&m_IntfEntry, sizeof(INTF_ENTRY));
    m_dwOIDFlags = 0;
    m_nTimer = 0;
    m_hCursor = NULL;

    // initialize all the control's handles
    m_hckbEnable    = NULL;
    m_hwndVLV       = NULL;
    m_hwndPLV       = NULL;
    m_hbtnCopy      = NULL;
    m_hbtnRfsh      = NULL;
    m_hbtnAdd       = NULL;
    m_hbtnRem       = NULL;
    m_hbtnUp        = NULL;
    m_hbtnDown      = NULL;
    m_hbtnAdvanced  = NULL;
    m_hbtnProps     = NULL;
    m_hlblVisNet    = NULL;
    m_hlblPrefNet   = NULL;
    m_hlblAvail     = NULL;
    m_hlblPrefDesc  = NULL;
    m_hlblAdvDesc   = NULL;
    m_hbtnProps     = NULL;

    m_hImgs     = NULL;
    m_hIcoUp    = NULL;
    m_hIcoDown  = NULL;

    // default the infrastructure mode to Auto
    m_dwCtlFlags = (INTFCTL_ENABLED | INTFCTL_FALLBACK | Ndis802_11AutoUnknown);

    // init the internal list heads
    m_pHdVList = NULL;
    m_pHdPList = NULL;
}

//+---------------------------------------------------------------------
CWZeroConfPage::~CWZeroConfPage()
{
    if (m_hImgs != NULL)
        ImageList_Destroy(m_hImgs);
    if (m_hIcoUp != NULL)
        DeleteObject(m_hIcoUp);
    if (m_hIcoDown != NULL)
        DeleteObject(m_hIcoDown);

    // delete the internal INTF_ENTRY object
    WZCDeleteIntfObj(&m_IntfEntry);

    // delete the internal list of visible configurations
    // (is like filling it with NULL)
    FillVisibleList(NULL);

    // delete the internal list of preferred configurations
    // (is like filling it with NULL)
    FillPreferredList(NULL);

    if (m_nTimer != 0)
        KillTimer(m_nTimer);
}

//+---------------------------------------------------------------------
// IsWireless - loads data from WZC if needed and checks whether the
// interface is wireless or not.
BOOL
CWZeroConfPage::IsWireless()
{
    if (!m_bHaveWZCData)
    {
        BOOL                bOk;
        WCHAR               wszGuid[c_cchGuidWithTerm];
        NETCON_PROPERTIES   *pProps = NULL;

        bOk = SUCCEEDED(m_pconn->GetProperties(&pProps));

        if (bOk)
        {
            UINT cch;
            cch = ::StringFromGUID2(
                        pProps->guidId, 
                        wszGuid, 
                        c_cchGuidWithTerm);
            FreeNetconProperties(pProps);
            bOk = (cch != 0);
        }

        if (bOk)
        {
            WZCDeleteIntfObj(&m_IntfEntry);
            ZeroMemory(&m_IntfEntry, sizeof(INTF_ENTRY));
            m_IntfEntry.wszGuid = (LPWSTR)RpcCAlloc(sizeof(WCHAR)*c_cchGuidWithTerm);
            bOk = (m_IntfEntry.wszGuid != NULL);
        }

        if (bOk)
        {
            DWORD dwErr;

            CopyMemory(m_IntfEntry.wszGuid, wszGuid, c_cchGuidWithTerm*sizeof(WCHAR));
            m_IntfEntry.wszDescr = NULL;
            m_dwOIDFlags = 0;

            dwErr = GetOIDs(INTF_ALL, &m_dwOIDFlags);

            // if getting the oids failed or we could get the OIDs but the driver/firmware
            // is not capable of doing the BSSID_LIST_SCAN it means we don't have enough
            // driver/firmware support for having Zero Configuration running. This will
            // result in not showing the Zero Configuration tab at all.
            bOk = (dwErr == ERROR_SUCCESS) && (m_IntfEntry.dwCtlFlags & INTFCTL_OIDSSUPP);

            if (m_IntfEntry.nAuthMode < 0)
                m_IntfEntry.nAuthMode = 0;
            if (m_IntfEntry.nInfraMode < 0)
                m_IntfEntry.nInfraMode = 0;

            if (!bOk)
            {
                WZCDeleteIntfObj(&m_IntfEntry);
                ZeroMemory(&m_IntfEntry, sizeof(INTF_ENTRY));
            }
        }

        m_bHaveWZCData = bOk;
    }

    return m_bHaveWZCData && (m_IntfEntry.ulPhysicalMediaType == NdisPhysicalMediumWirelessLan);
}


//+---------------------------------------------------------------------
// GetOIDs - gets the OIDs for the m_IntfEntry member. It assumes the
// GUID is set already
DWORD
CWZeroConfPage::GetOIDs(DWORD dwInFlags, LPDWORD pdwOutFlags)
{
    DWORD rpcStatus, dwOutFlags;

    if (dwInFlags & INTF_DESCR)
    {
        RpcFree(m_IntfEntry.wszDescr);
        m_IntfEntry.wszDescr = NULL;
    }
    if (dwInFlags & INTF_PREFLIST)
    {
        RpcFree(m_IntfEntry.rdStSSIDList.pData);
        m_IntfEntry.rdStSSIDList.dwDataLen = 0;
        m_IntfEntry.rdStSSIDList.pData = NULL;
    }
    if (dwInFlags & INTF_SSID)
    {
        RpcFree(m_IntfEntry.rdSSID.pData);
        m_IntfEntry.rdSSID.dwDataLen = 0;
        m_IntfEntry.rdSSID.pData = NULL;
    }
    if (dwInFlags & INTF_BSSID)
    {
        RpcFree(m_IntfEntry.rdBSSID.pData);
        m_IntfEntry.rdBSSID.dwDataLen = 0;
        m_IntfEntry.rdBSSID.pData = NULL;
    }
    if (dwInFlags & INTF_BSSIDLIST)
    {
        RpcFree(m_IntfEntry.rdBSSIDList.pData);
        m_IntfEntry.rdBSSIDList.dwDataLen = 0;
        m_IntfEntry.rdBSSIDList.pData = NULL;
    }
    rpcStatus = WZCQueryInterface(
                    NULL,
                    dwInFlags,
                    &m_IntfEntry,
                    pdwOutFlags);

    return rpcStatus;
}

//+---------------------------------------------------------------------
// HelpCenter - brings up the help topic given as parameter
DWORD
CWZeroConfPage::HelpCenter(LPCTSTR wszTopic)
{
    DWORD dwErr = ERROR_SUCCESS;
    SHELLEXECUTEINFO shexinfo = {0};

    shexinfo.cbSize = sizeof (shexinfo);
    shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
    shexinfo.nShow = SW_SHOWNORMAL;
    shexinfo.lpFile = wszTopic;
    shexinfo.lpVerb = _T("open");

    // since help center doesn't properly call AllowSetForegroundWindow when it defers 
    // to an existing process we just give it to the next taker.
    AllowSetForegroundWindow(-1);

    ShellExecuteEx(&shexinfo);

    return dwErr;
}

//+---------------------------------------------------------------------
// IsConfigInList - checks whether the pwzcConfig (WZC_WLAN_CONFIG object) is present
// in the list given as the first param
BOOL
CWZeroConfPage::IsConfigInList(CWZCConfig *pHdList, PWZC_WLAN_CONFIG pwzcConfig, CWZCConfig **ppMatchingConfig)
{
    BOOL bYes = FALSE;

    if (pHdList != NULL)
    {
        CWZCConfig    *pConfig;

        pConfig = pHdList;
        do
        {
            if (pConfig->Match(pwzcConfig))
            {
                if (ppMatchingConfig != NULL)
                    *ppMatchingConfig = pConfig;

                bYes = TRUE;
                break;
            }
            pConfig = pConfig->m_pNext;
        } while(pConfig != pHdList);
    }

    return bYes;
}

//+---------------------------------------------------------------------------
// Adds the given configuration to the internal lists. The entries in the lists
// are ordered on InfrastructureMode in descending order. This way the Infrastructure
// entries will be on the top of the list while the adhoc entries will be on the
// bottom. (we rely on the order as it is given in NDIS_802_11_NETWORK_INFRASTRUCTURE)
DWORD
CWZeroConfPage::AddUniqueConfig(
    DWORD            dwOpFlags,
    DWORD            dwEntryFlags,
    PWZC_WLAN_CONFIG pwzcConfig,
    CEapolConfig     *pEapolConfig,
    CWZCConfig       **ppNewNode)
{
    LRESULT       dwErr    = ERROR_SUCCESS;
    CWZCConfig  *pHdList;

    if (dwEntryFlags & WZC_DESCR_PREFRD)
    {
        pHdList = m_pHdPList;
    }
    else
    {
        UINT i;
        pHdList = m_pHdVList;

        // skip the null SSIDs from the visible list (coming from APs
        // not responding to broadcast SSID).
        for (i = pwzcConfig->Ssid.SsidLength; i > 0 && pwzcConfig->Ssid.Ssid[i-1] == 0; i--);
        if (i == 0)
            goto exit;
    }

    // if the list is currently empty, create the first entry as the head of the list
    if (pHdList == NULL)
    {
        pHdList = new CWZCConfig(dwEntryFlags, pwzcConfig);
        if (pHdList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if (pEapolConfig == NULL)
        {
            pHdList->m_pEapolConfig = new CEapolConfig;
            if (pHdList->m_pEapolConfig == NULL)
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            else
                dwErr = pHdList->m_pEapolConfig->LoadEapolConfig(m_IntfEntry.wszGuid, &(pHdList->m_wzcConfig.Ssid));

            if (dwErr != ERROR_SUCCESS)
            {
                delete pHdList;
                pHdList = NULL;
            }
        }
        else
        {
            pHdList->m_pEapolConfig = pEapolConfig;
        }

        // if the caller wants, return the pointer to the newly created object
        if (ppNewNode != NULL)
            *ppNewNode = pHdList;
    }
    else
    {
        // else the list already contains at least one element
        CWZCConfig *pCrt, *pHdGroup;

        // scan the list (keep in mind it is ordered descendingly on IM)
        pHdGroup = pCrt = pHdList;
        do
        {
            // check whether we entered a new group of configs (different InfrastructureMode)
            if (pHdGroup->m_wzcConfig.InfrastructureMode != pCrt->m_wzcConfig.InfrastructureMode)
                pHdGroup = pCrt;

            // if found an identical entry (same SSID and same InfraMode)
            // signal the DUPLICATE_TAG error
            if (pCrt->Match(pwzcConfig))
            {
                // merge the flags first
                pCrt->m_dwFlags |= dwEntryFlags;

                // If requested, copy over the new configuration.
                // If not explicitly requested, copy over only if the existent configuration
                // prooves to be weaker than the one being added.
                //
                // NOTE: the pCrt->m_pEapolConfig remains untouched since it depends exclusively
                // on the SSID & Infrastructure mode. These are not changing hence there is no
                // reason to reload the 802.1x settings.
                if (dwOpFlags & WZCADD_OVERWRITE || 
                    (pHdList == m_pHdVList && pCrt->Weaker(pwzcConfig)))
                {
                    memcpy(&(pCrt->m_wzcConfig), pwzcConfig, sizeof(WZC_WLAN_CONFIG));
                    // just in case a different pEapolConfig has been provided, destroy
                    // the original one (if any) and point to the new object
                    if (pEapolConfig != NULL)
                    {
                        if (pCrt->m_pEapolConfig != NULL)
                            delete pCrt->m_pEapolConfig;
                        pCrt->m_pEapolConfig = pEapolConfig;
                    }
                }

                // if the caller wants, return the pointer to the matching entry
                if (ppNewNode != NULL)
                    *ppNewNode = pCrt;

                // signal there is already a matching config
                dwErr = ERROR_DUPLICATE_TAG;
            }
            pCrt = pCrt->m_pNext;
        } while (dwErr == ERROR_SUCCESS &&
                 pCrt != pHdList && 
                 pwzcConfig->InfrastructureMode <= pCrt->m_wzcConfig.InfrastructureMode);

        // if dwErr is unchanged, this means a new node has to be added ahead of pCrt node
        if (dwErr == ERROR_SUCCESS)
        {
            // create the new config and insert it ahead of this node.
            CWZCConfig *pNewConfig;

            pNewConfig = new CWZCConfig(dwEntryFlags, pwzcConfig);
            if (pNewConfig == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else if (pEapolConfig == NULL)
            {
                pNewConfig->m_pEapolConfig = new CEapolConfig;
                if (pNewConfig->m_pEapolConfig == NULL)
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                else
                    dwErr = pNewConfig->m_pEapolConfig->LoadEapolConfig(m_IntfEntry.wszGuid, &(pNewConfig->m_wzcConfig.Ssid));

                if (dwErr != ERROR_SUCCESS)
                {
                    delete pNewConfig;
                    pNewConfig = NULL;
                }
            }
            else
            {
                pNewConfig->m_pEapolConfig = pEapolConfig;
            }

            if (dwErr == ERROR_SUCCESS)
            {
                INT nDiff;

                // if asked to insert in the head of the group, pCrt should point to this head
                if (dwOpFlags & WZCADD_HIGROUP)
                    pCrt = pHdGroup;

                pNewConfig->m_pPrev = pCrt->m_pPrev;
                pNewConfig->m_pNext = pCrt;
                pCrt->m_pPrev->m_pNext = pNewConfig;
                pCrt->m_pPrev = pNewConfig;

                // get the difference between the Infrastructure modes for the new node and
                // for the current head
                nDiff = pNewConfig->m_wzcConfig.InfrastructureMode - pHdList->m_wzcConfig.InfrastructureMode;

                // if the newly entered entry has the largest "key" in
                // the existent sequence, or it has to be inserted in the head of its group and it is
                // in the first group, then the global list head moves to the new entry
                if (nDiff > 0 || ((dwOpFlags & WZCADD_HIGROUP) && (nDiff == 0)))
                    pHdList = pNewConfig;
            }

            // if the caller wants, return the pointer to the newly created object
            if (ppNewNode != NULL)
                *ppNewNode = pNewConfig;
        }
    }

    if (dwEntryFlags & WZC_DESCR_PREFRD)
    {
        m_pHdPList = pHdList;
    }
    else
    {
        m_pHdVList = pHdList;
    }
exit:
    return dwErr;
}

//+---------------------------------------------------------------------
// FillVisibleList - fills in the configs from the WZC_802_11_CONFIG_LIST object
// into the list of visible configs
DWORD
CWZeroConfPage::FillVisibleList(PWZC_802_11_CONFIG_LIST pwzcVList)
{
    DWORD   dwErr = ERROR_SUCCESS;
    UINT    i;

    // cleanup whatever we might already have in the visible list
    if (m_pHdVList != NULL)
    {
        while (m_pHdVList->m_pNext != m_pHdVList)
        {
            delete m_pHdVList->m_pNext;
        }
        delete m_pHdVList;
        m_pHdVList = NULL;
    }

    if (pwzcVList != NULL)
    {
        for (i = 0; i < pwzcVList->NumberOfItems; i++)
        {
            dwErr = AddUniqueConfig(
                        0,                  // no op flags
                        WZC_DESCR_VISIBLE,  // this is a visible entry
                        &(pwzcVList->Config[i]));

            // reset the error if config was just duplicated
            if (dwErr == ERROR_DUPLICATE_TAG)
                dwErr = ERROR_SUCCESS;
        }
    }

    return dwErr;
}

//+---------------------------------------------------------------------
// FillPreferredList - fills in the configs from the WZC_802_11_CONFIG_LIST object
// into the list of preferred configs
DWORD
CWZeroConfPage::FillPreferredList(PWZC_802_11_CONFIG_LIST pwzcPList)
{
    DWORD   dwErr = ERROR_SUCCESS;
    UINT    i;

    // cleanup whatever we might already have in the preferred list
    if (m_pHdPList != NULL)
    {
        while (m_pHdPList ->m_pNext != m_pHdPList)
        {
            delete m_pHdPList ->m_pNext;
        }
        delete m_pHdPList;
        m_pHdPList = NULL;
    }

    if (pwzcPList != NULL)
    {
        for (i = 0; i < pwzcPList->NumberOfItems; i++)
        {
            PWZC_WLAN_CONFIG    pwzcPConfig = &(pwzcPList->Config[i]);
            DWORD               dwFlags = WZC_DESCR_PREFRD;

            // check whether this preferred is also visible and adjust dwFlags if so
            if (IsConfigInList(m_pHdVList, pwzcPConfig))
                dwFlags |= WZC_DESCR_VISIBLE;

            dwErr = AddUniqueConfig(
                        WZCADD_OVERWRITE,   // preferred entries cause info to be overwritten
                        dwFlags,
                        pwzcPConfig);

            // reset the error if config was just duplicated
            if (dwErr == ERROR_DUPLICATE_TAG)
                dwErr = ERROR_SUCCESS;
        }
    }

    return dwErr;
}

//+---------------------------------------------------------------------------
// Fill in the current configuration settings for this adapter
DWORD
CWZeroConfPage::FillCurrentConfig(PINTF_ENTRY pIntf)
{
    DWORD           dwErr = ERROR_SUCCESS;
    WZC_WLAN_CONFIG wzcCurrent = {0};
    CWZCConfig      *pConfig = NULL;

    wzcCurrent.InfrastructureMode = (NDIS_802_11_NETWORK_INFRASTRUCTURE)pIntf->nInfraMode;
    wzcCurrent.Ssid.SsidLength = pIntf->rdSSID.dwDataLen;
    CopyMemory(wzcCurrent.Ssid.Ssid, pIntf->rdSSID.pData, pIntf->rdSSID.dwDataLen);
    // another bit of a hack. Code in the authentication mode for this adapter in the highest
    // of the two reserved bits from WZC_WLAN_CONFIG
    //NWB_SET_AUTHMODE(&wzcCurrent, pIntf->nAuthMode);
    wzcCurrent.AuthenticationMode = (NDIS_802_11_AUTHENTICATION_MODE)pIntf->nAuthMode;
    // set the privacy field based on the adapter's WEP status.
    wzcCurrent.Privacy = (pIntf->nWepStatus == Ndis802_11WEPEnabled);

    if (IsConfigInList(m_pHdVList, &wzcCurrent, &pConfig))
        pConfig->m_dwFlags |= WZC_DESCR_ACTIVE;

    if (IsConfigInList(m_pHdPList, &wzcCurrent, &pConfig))
        pConfig->m_dwFlags |= WZC_DESCR_ACTIVE;

    return dwErr;
}

//+---------------------------------------------------------------------------
// Display the Visible & Preferred lists into their controls
DWORD
CWZeroConfPage::RefreshListView(DWORD dwFlags)
{
    DWORD       dwErr = ERROR_SUCCESS;
    CWZCConfig  *pActive = NULL;

    while (dwFlags != 0)
    {
        HWND       hwndLV;
        CWZCConfig *pHdList;

        // the logic below allows iteration through all the lists
        // requested by the caller
        if (dwFlags & WZCOP_VLIST)
        {
            dwFlags ^= WZCOP_VLIST;
            hwndLV = m_hwndVLV;
            pHdList = m_pHdVList;
        }
        else if (dwFlags & WZCOP_PLIST)
        {
            dwFlags ^= WZCOP_PLIST;
            hwndLV = m_hwndPLV;
            pHdList = m_pHdPList;
        }
        else
            break;

        // clear first the list
        ListView_DeleteAllItems(hwndLV);

        if (pHdList != NULL)
        {
            CWZCConfig  *pCrt;
            UINT        i;

            pCrt = pHdList;
            i = 0;
            do
            {
                // add in the list all the entries if AutoMode or we're filling the
                // visible list.
                // Otherwise (!AutoMode & Preferred list) put in just the entries for
                // the corresponding infrastructure mode
                if ((m_dwCtlFlags & INTFCTL_CM_MASK) == Ndis802_11AutoUnknown ||
                    hwndLV == m_hwndVLV ||
                    (m_dwCtlFlags & INTFCTL_CM_MASK) == pCrt->m_wzcConfig.InfrastructureMode)
                {
                    pCrt->m_nListIndex = i;
                    pCrt->AddConfigToListView(hwndLV, i++);
                    if (pCrt->m_dwFlags & WZC_DESCR_ACTIVE)
                        pActive = pCrt;
                }
                else
                {
                    pCrt->m_nListIndex = -1;
                }
                pCrt = pCrt->m_pNext;
            } while (pCrt != pHdList);

            if (pActive != NULL)
            {
                ListView_SetItemState(hwndLV, pActive->m_nListIndex, LVIS_SELECTED, LVIS_SELECTED);
                ListView_EnsureVisible(hwndLV, pActive->m_nListIndex, FALSE);
            }
            else if (i > 0)
            {
                ListView_SetItemState(hwndLV, 0, LVIS_SELECTED, LVIS_SELECTED);
                ListView_EnsureVisible(hwndLV, 0, FALSE);
            }
        }
    }

    return dwErr;
}

DWORD
CWZeroConfPage::RefreshButtons()
{
    CWZCConfig  *pVConfig = NULL;
    CWZCConfig  *pPConfig = NULL;
    LVITEM      lvi = {0};
    INT         iSelected;
    BOOL        bEnabled;

    // get the selected item from the visible list
    iSelected = ListView_GetNextItem(m_hwndVLV, -1, LVNI_SELECTED);
    if (iSelected >= 0)
    {
        lvi.mask  = LVIF_PARAM;
        lvi.iItem = iSelected;
        if (ListView_GetItem(m_hwndVLV, &lvi))
        {
            pVConfig = (CWZCConfig*)lvi.lParam;
        }
    }
    // get the selected item from the preferred list
    iSelected = ListView_GetNextItem(m_hwndPLV, -1, LVNI_SELECTED);
    if (iSelected >= 0)
    {
        lvi.mask  = LVIF_PARAM;
        lvi.iItem = iSelected;
        if (ListView_GetItem(m_hwndPLV, &lvi))
        {
            pPConfig = (CWZCConfig*)lvi.lParam;
        }
    }

    // enable buttons only if not during refresh - otherwise disable all
    bEnabled = (m_dwOIDFlags & INTF_BSSIDLIST);

    // "Refresh" button is enabled if we do have the visible list
    // "Refresh" button might be enabled even if the service is disabled. User can see what is visible
    ::EnableWindow(m_hbtnRfsh, bEnabled);

    bEnabled = bEnabled && (m_dwCtlFlags & INTFCTL_ENABLED);

    // "Copy" button is enabled if there is any selection in the Visible list
    ::EnableWindow(m_hbtnCopy, bEnabled && (pVConfig != NULL) &&
                               ((m_dwCtlFlags & INTFCTL_CM_MASK) == Ndis802_11AutoUnknown ||
                                (m_dwCtlFlags & INTFCTL_CM_MASK) == pVConfig->m_wzcConfig.InfrastructureMode));

    // "Add" Button is always enabled, regardless the selections
    ::EnableWindow(m_hbtnAdd, bEnabled);
        
    // "Remove" button is active only if there is any selection in the Preferred list
    ::EnableWindow(m_hbtnRem, bEnabled && (pPConfig != NULL));

    // Same test for "properties" button as for "remove"
    ::EnableWindow(m_hbtnProps, bEnabled && (pPConfig != NULL));

    // "Up" button is active only for preferred entries.
    // It also is active only if the entry is not the first in the
    // list and the entry preceding it has the same InfrastructureMode
    bEnabled = bEnabled && (pPConfig != NULL);
    bEnabled = bEnabled && (pPConfig != m_pHdPList);
    bEnabled = bEnabled &&
               (pPConfig->m_wzcConfig.InfrastructureMode == pPConfig->m_pPrev->m_wzcConfig.InfrastructureMode);
    ::EnableWindow(m_hbtnUp, bEnabled);

    // "Down" button is active only for preferred or preferred entries.
    // It also is active only if the entry is not the last in the list
    // and it precedes another entry of exactly the same InfrastructureMode
    bEnabled = (m_dwCtlFlags & INTFCTL_ENABLED) && (m_dwOIDFlags & INTF_BSSIDLIST);
    bEnabled = bEnabled && (pPConfig != NULL);
    bEnabled = bEnabled && (pPConfig->m_pNext != m_pHdPList);
    bEnabled = bEnabled &&
               (pPConfig->m_wzcConfig.InfrastructureMode == pPConfig->m_pNext->m_wzcConfig.InfrastructureMode);
    ::EnableWindow(m_hbtnDown, bEnabled);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------
DWORD
CWZeroConfPage::SwapConfigsInListView(INT nIdx1, INT nIdx2, CWZCConfig * & pConfig1, CWZCConfig * & pConfig2)
{
    DWORD   dwErr = ERROR_SUCCESS;
    LVITEM  lvi1 = {0};
    LVITEM  lvi2 = {0};
    WCHAR   wszSSID1[33];
    WCHAR   wszSSID2[33];

    // since we take all what is known about an item this includes
    // images indices and selection state
    // get the first item
    lvi1.iItem = nIdx1;
    lvi1.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_PARAM;
    lvi1.stateMask = (UINT)-1;
    lvi1.pszText = wszSSID1;
    lvi1.cchTextMax = sizeof(wszSSID1)/sizeof(WCHAR);
    if (!ListView_GetItem(m_hwndPLV, &lvi1))
    {
        dwErr = ERROR_GEN_FAILURE;
        goto exit;
    }
    pConfig1 = (CWZCConfig*)lvi1.lParam;

    // get the second item
    lvi2.iItem = nIdx2;
    lvi2.mask = LVIF_TEXT | LVIF_STATE | LVIF_IMAGE | LVIF_PARAM;
    lvi2.stateMask = (UINT)-1;
    lvi2.pszText = wszSSID2;
    lvi2.cchTextMax = sizeof(wszSSID2)/sizeof(WCHAR);
    if (!ListView_GetItem(m_hwndPLV, &lvi2))
    {
        dwErr = ERROR_GEN_FAILURE;
        goto exit;
    }
    pConfig2 = (CWZCConfig*)lvi2.lParam;

    // swap the indices and reset the items at their new positions
    lvi1.iItem = nIdx2;
    lvi2.iItem = nIdx1;
    if (!ListView_SetItem(m_hwndPLV, &lvi1) ||
        !ListView_SetItem(m_hwndPLV, &lvi2))
    {
        dwErr = ERROR_GEN_FAILURE;
        goto exit;
    }
    // if everything went fine, swap the indices in the objects
    pConfig1->m_nListIndex = nIdx2;
    pConfig2->m_nListIndex = nIdx1;
    // make visible the selected entry
    ListView_EnsureVisible(m_hwndPLV, nIdx1, FALSE);

exit:
    return dwErr;
}

//+---------------------------------------------------------------------
DWORD
CWZeroConfPage::SavePreferredConfigs(PINTF_ENTRY pIntf)
{
    DWORD       dwErr = ERROR_SUCCESS;
    CWZCConfig  *pCrt = NULL;
    UINT        nPrefrd = 0;

    if (m_pHdPList != NULL)
    {
        // count first the number of preferred entries in the list
        pCrt = m_pHdPList;
        do
        {
            nPrefrd++;
            pCrt = pCrt->m_pNext;
        } while(pCrt != m_pHdPList);
    }

    if (nPrefrd > 0)
    {
        PWZC_802_11_CONFIG_LIST pwzcPrefrdList;
        UINT                    nwzcPrefrdSize;

        nwzcPrefrdSize = sizeof(WZC_802_11_CONFIG_LIST)+ (nPrefrd-1)*sizeof(WZC_WLAN_CONFIG);

        // allocate as much memory as needed for storing all the preferred SSIDs
        pwzcPrefrdList = (PWZC_802_11_CONFIG_LIST)RpcCAlloc(nwzcPrefrdSize);
        if (pwzcPrefrdList == NULL)
        {
            dwErr = GetLastError();
        }
        else
        {
            DWORD dwLErr;

            pwzcPrefrdList->NumberOfItems = 0; 
            // we have now all we need - start copying the preferred 
            pCrt = m_pHdPList;
            do
            {
                PWZC_WLAN_CONFIG    pPrefrdConfig;

                pPrefrdConfig = &(pwzcPrefrdList->Config[pwzcPrefrdList->NumberOfItems++]);
                CopyMemory(pPrefrdConfig, &pCrt->m_wzcConfig, sizeof(WZC_WLAN_CONFIG));

                // fix 802.1X state for infrastructure networks only.
                // don't touch the 802.1X state for ad hoc networks since this might mess the setting for a 
                // corresponding Infrastructure network (802.1X engine doesn't make the difference between SSID infra
                // and SSID ad hoc) and besides, the 802.1X engine is smart enough to not act on ad hoc networks
                if (pCrt->m_pEapolConfig != NULL &&
                    pPrefrdConfig->InfrastructureMode == Ndis802_11Infrastructure)
                {
                    dwLErr = pCrt->m_pEapolConfig->SaveEapolConfig(m_IntfEntry.wszGuid, &(pCrt->m_wzcConfig.Ssid));

                    if (dwErr == ERROR_SUCCESS)
                        dwErr = dwLErr;
                }

                pCrt = pCrt->m_pNext;
            } while(pwzcPrefrdList->NumberOfItems < nPrefrd && pCrt != m_pHdPList);

            // since we don't want any "one time configuration" logic to apply here,
            // we need to put in the whole number of items in the "Index" field
            pwzcPrefrdList->Index = pwzcPrefrdList->NumberOfItems;

            pIntf->rdStSSIDList.dwDataLen = nwzcPrefrdSize;
            pIntf->rdStSSIDList.pData = (LPBYTE)pwzcPrefrdList;
        }
    }
    else
    {
        pIntf->rdStSSIDList.dwDataLen = 0;
        pIntf->rdStSSIDList.pData = NULL;
    }

    return dwErr;
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnInitDialog(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled)
{
    HRESULT hr = S_OK;
    BOOL    bEnableAll;
    BOOL    bEnableVisible;

    // get the controls as the first thing to do
    m_hckbEnable    = GetDlgItem(IDC_WZC_CHK_EnableWZC);
    m_hlblVisNet    = GetDlgItem(IDC_WZC_LBL_VisNet);
    m_hlblPrefNet   = GetDlgItem(IDC_WZC_LBL_PrefNet);
    m_hlblAvail     = GetDlgItem(IDC_AVAILLABEL);
    m_hlblPrefDesc  = GetDlgItem(IDC_PREFERLABEL);
    m_hlblAdvDesc   = GetDlgItem(IDC_ADVANCEDLABEL);
    m_hwndVLV       = GetDlgItem(IDC_WZC_LVW_BSSIDList);
    m_hwndPLV       = GetDlgItem(IDC_WZC_LVW_StSSIDList);
    m_hbtnUp        = GetDlgItem(IDC_WZC_BTN_UP);
    m_hbtnDown      = GetDlgItem(IDC_WZC_BTN_DOWN);
    m_hbtnCopy      = GetDlgItem(IDC_WZC_BTN_COPY);
    m_hbtnRfsh      = GetDlgItem(IDC_WZC_BTN_RFSH);
    m_hbtnAdd       = GetDlgItem(IDC_WZC_BTN_ADD);
    m_hbtnRem       = GetDlgItem(IDC_WZC_BTN_REM);
    m_hbtnAdvanced  = GetDlgItem(IDC_ADVANCED);
    m_hbtnProps     = GetDlgItem(IDC_PROPERTIES);

    // Initialize the list view controls
    InitListViews();

    // enable UI only for Admins and if the interface is wireless
    // As a side effect, IsWireless() loads the data from the WZC
    bEnableAll = /*FIsUserAdmin() &&*/ IsWireless();
    bEnableVisible = bEnableAll;

    if (bEnableAll)
    {
        // set the configuration mode to the one for this interface
        m_dwCtlFlags = m_IntfEntry.dwCtlFlags;

        // if service disabled, gray out everything
        bEnableAll = (m_dwCtlFlags & INTFCTL_ENABLED);

        // set the control check boxes
        CheckDlgButton(IDC_WZC_CHK_EnableWZC, 
                       (m_dwCtlFlags & INTFCTL_ENABLED) ? BST_CHECKED : BST_UNCHECKED);

        // the UI can be filled in only when we were able to retrieve the list of
        // visible configs (even if it is NULL/empty). Otherwise, the UI is locked.
        if (m_dwOIDFlags & INTF_BSSIDLIST)
        {
            // add the list of visible configs for this adapter
            FillVisibleList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdBSSIDList.pData);
            // add the list of preferred configs for this adapter
            FillPreferredList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdStSSIDList.pData);
            // add to the visible list the current settings
            FillCurrentConfig(&m_IntfEntry);
            // dump the resulting lists in their List Views
            RefreshListView(WZCOP_VLIST|WZCOP_PLIST);
            // if we got a visible list, have to enable it here
            bEnableVisible = TRUE;

        }
        else
        {
            // mark that we don't have WZC data yet
            m_bHaveWZCData = FALSE;
            // the list of preferred configs still needs to be filled up here
            FillPreferredList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdStSSIDList.pData);
            // switch the cursor to "App starting"
            m_hCursor = SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
            // we should fill in the UI after Tr (see the WZC state machine)
            // Tr is 3secs (defined in ..zeroconf\server\state.h)
            m_nTimer = SetTimer(g_TimerID, RFSH_TIMEOUT, 0);
            // don't enable any control if refreshing
            bEnableAll = FALSE;
            // actually disable even the "Enable" button
            ::EnableWindow(m_hckbEnable, FALSE);
            // and also disable the visible list
            bEnableVisible = FALSE;
        }
        // refresh the buttons
        RefreshButtons();
    }

    // the controls related to the visible list should be enabled if:
    // - WZC can operate on this adapter
    // - we got a BSSIDLIST from the very first shot.
    // otherwise these controls should remain disabled
    ::EnableWindow(m_hlblVisNet, bEnableVisible);
    ::EnableWindow(m_hwndVLV, bEnableVisible);
    ::EnableWindow(m_hlblAvail, bEnableVisible);

    // all the remaining controls should be enabled only if:
    // - WZC can operate on the adapter
    // - WZC is enabled as a service
    // - we got the BSSIDLIST from the very first shot
    // otherwise these controls should remain disabled
    ::EnableWindow(m_hlblPrefNet, bEnableAll);
    ::EnableWindow(m_hwndPLV, bEnableAll);
    ::EnableWindow(m_hlblPrefDesc, bEnableAll);

    ::EnableWindow(m_hlblAdvDesc, bEnableAll);
    ::EnableWindow(m_hbtnAdvanced, bEnableAll);

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnApply(
    int idCtrl,
    LPNMHDR pnmh,
    BOOL& bHandled)
{
    HRESULT             hr = S_OK;
    WCHAR               wszGuid[c_cchGuidWithTerm];
    NETCON_PROPERTIES   *pProps = NULL;
    DWORD               rpcStatus = ERROR_SUCCESS;
    BOOL                bOk;

    hr = m_pconn->GetProperties(&pProps);
    bOk = SUCCEEDED(hr);

    if (bOk)
    {   
        UINT cch;
        cch = ::StringFromGUID2(
                    pProps->guidId, 
                    wszGuid, 
                    c_cchGuidWithTerm);
        FreeNetconProperties(pProps);
        bOk = (cch != 0);
    }

    if (bOk)
    {
        UINT        nText;
        INTF_ENTRY  Intf;
        BOOL        bDirty;
        DWORD       dwOneXErr;

        ZeroMemory(&Intf, sizeof(INTF_ENTRY));
        Intf.wszGuid = wszGuid;

        // copy the configuration mode
        Intf.dwCtlFlags = m_dwCtlFlags;
        // save the preferred config list
        dwOneXErr = SavePreferredConfigs(&Intf);
        
        bDirty = (Intf.dwCtlFlags != m_IntfEntry.dwCtlFlags);
        bDirty = bDirty || (Intf.rdStSSIDList.dwDataLen != m_IntfEntry.rdStSSIDList.dwDataLen);
        bDirty = bDirty || ((Intf.rdStSSIDList.dwDataLen != 0) && 
                            memcmp(Intf.rdStSSIDList.pData, m_IntfEntry.rdStSSIDList.pData, Intf.rdStSSIDList.dwDataLen));

        if (bDirty)
        {
            rpcStatus = WZCSetInterface(
                    NULL,
                    INTF_ALL_FLAGS | INTF_PREFLIST,
                    &Intf,
                    NULL);
        }

        if (dwOneXErr != ERROR_SUCCESS || rpcStatus == ERROR_PARTIAL_COPY)
        {
            NcMsgBox(
                WZCGetSPResModule(),
                m_hWnd,
                IDS_LANUI_ERROR_CAPTION,
                IDS_WZC_PARTIAL_APPLY,
                MB_ICONEXCLAMATION|MB_OK);

            rpcStatus = RPC_S_OK;
        }

        bOk = (rpcStatus == RPC_S_OK);

        // wszGuid field is not pointing to heap memory hence it should not
        // be deleted -> set the pointer to NULL to avoid this to happen
        Intf.wszGuid = NULL;
        WZCDeleteIntfObj(&Intf);
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
extern const WCHAR c_szNetCfgHelpFile[];
LRESULT
CWZeroConfPage::OnContextMenu(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& fHandled)
{
    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}
LRESULT
CWZeroConfPage::OnHelp(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------
LRESULT
CWZeroConfPage::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_nTimer != 0)
    {
        BOOL bEnableAll;

        // switch the cursor back to whatever it was
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        KillTimer(m_nTimer);
        m_nTimer = 0;

        // attempt to requery the service for all the OIDs. Regardless we could or not
        // obtain the OIDs, fill the UI with what we have.
        if (GetOIDs(INTF_ALL_OIDS, &m_dwOIDFlags) == ERROR_SUCCESS)
        {
            CWZCConfig *pPConfig = NULL;

            // add the list of visible configs for this adapter
            FillVisibleList((PWZC_802_11_CONFIG_LIST)m_IntfEntry.rdBSSIDList.pData);
            // Update the visibility flag for each of the preferred configs
            pPConfig = m_pHdPList;
            if (pPConfig != NULL)
            {
                do
                {
                    // by default, none of the preferred entries is marked as "active".
                    // This will be taken care of later, when calling FillCurrentConfig().
                    pPConfig->m_dwFlags &= ~WZC_DESCR_ACTIVE;
                    if (IsConfigInList(m_pHdVList, &pPConfig->m_wzcConfig))
                        pPConfig->m_dwFlags |= WZC_DESCR_VISIBLE;
                    else
                        pPConfig->m_dwFlags &= ~WZC_DESCR_VISIBLE;
                    pPConfig = pPConfig->m_pNext;
                } while(pPConfig != m_pHdPList);
            }
            // add the current settings to the visible list
            FillCurrentConfig(&m_IntfEntry);
        }

        // even in case of failure, at this point we should live with whatever
        // visible list (if any) we have. Hence, flag BSSIDLIST as "visible"
        m_dwOIDFlags |= INTF_BSSIDLIST;

        // dump the resulting lists in their List Views
        RefreshListView(WZCOP_VLIST|WZCOP_PLIST);
        // refresh the buttons
        RefreshButtons();

        // if service disabled, gray out all the other controls
        bEnableAll = (m_dwCtlFlags & INTFCTL_ENABLED);

        // enable all the UI when done refreshing
        ::EnableWindow(m_hckbEnable, TRUE);

        // enable everything related to the visible list
        ::EnableWindow(m_hlblVisNet, TRUE);
        ::EnableWindow(m_hwndVLV, TRUE);
        ::EnableWindow(m_hlblAvail, TRUE);

        ::EnableWindow(m_hlblPrefNet, bEnableAll);
        ::EnableWindow(m_hwndPLV, bEnableAll);
        ::EnableWindow(m_hlblPrefDesc, bEnableAll);

        ::EnableWindow(m_hlblAdvDesc, bEnableAll);
        ::EnableWindow(m_hbtnAdvanced, bEnableAll);
    }

    return 0;
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnDblClick(
    int idCtrl, 
    LPNMHDR pnmh,
    BOOL& bHandled)
{
    HWND            hwndLV;
    HRESULT         hr = S_OK;
    LPNMLISTVIEW    pnmhLv = (LPNMLISTVIEW) pnmh;

    if (idCtrl == IDC_WZC_LVW_BSSIDList)
    {
        hwndLV = m_hwndVLV;
    }
    else
    {
        hwndLV =  m_hwndPLV;
    }

    bHandled = FALSE;
    if (pnmhLv->iItem != -1)
    {
        ListView_SetItemState(hwndLV, pnmhLv->iItem, LVIS_SELECTED, LVIS_SELECTED);
        hr = _DoProperties(hwndLV, pnmhLv->iItem);
        bHandled = TRUE;
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnClick(
    int idCtrl, 
    LPNMHDR pnmh,
    BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    LPNMLISTVIEW    pnmhLv = (LPNMLISTVIEW) pnmh;

    if (idCtrl == IDC_LEARNABOUT)
    {
        HelpCenter(SzLoadString(_Module.GetResourceInstance(), IDS_WZC_LEARNCMD));
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnReturn(
    int idCtrl, 
    LPNMHDR pnmh,
    BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    LPNMLISTVIEW    pnmhLv = (LPNMLISTVIEW) pnmh;

    if (idCtrl == IDC_LEARNABOUT)
    {
        HelpCenter(SzLoadString(_Module.GetResourceInstance(), IDS_WZC_LEARNCMD));
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnItemChanged(
    int idCtrl,
    LPNMHDR pnmh,
    BOOL& bHandled)
{

    HRESULT hr = S_OK;

    RefreshButtons();
    bHandled = TRUE;

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnChkWZCEnable(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled)
{
    HRESULT hr = S_OK;
    BOOL bEnable;

    bEnable = (IsDlgButtonChecked(IDC_WZC_CHK_EnableWZC) == BST_CHECKED);
    m_dwCtlFlags &= ~INTFCTL_ENABLED;
    if (bEnable)
        m_dwCtlFlags |= INTFCTL_ENABLED;

    // enable everything related to the visible list
    ::EnableWindow(m_hlblVisNet, TRUE);
    ::EnableWindow(m_hwndVLV, TRUE);
    ::EnableWindow(m_hlblAvail, TRUE);

    ::EnableWindow(m_hlblPrefNet, bEnable);
    ::EnableWindow(m_hwndPLV, bEnable);
    ::EnableWindow(m_hlblPrefDesc, bEnable);

    ::EnableWindow(m_hlblAdvDesc, bEnable);
    ::EnableWindow(m_hbtnAdvanced, bEnable);

    RefreshButtons();

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT
CWZeroConfPage::OnPushAddOrCopy(
    WORD wNotifyCode,
    WORD wID, 
    HWND hWndCtl,
    BOOL& bHandled)
{
    HRESULT         hr = S_OK;
    LVITEM          lvi = {0};
    BOOL            bOk;
    INT             iSelected;
    CWZCConfig      *pConfig = NULL;
    CWZCConfigPage  PpWzcProps(WZCDLG_PROPS_RWALL|WZCDLG_PROPS_DEFOK|WZCDLG_PROPS_ONEX_CHECK);
    CEapolConfig    *pEapolConfig = NULL;

    // in case of success, the object allocated here is linked to the 
    // newly created or updated CWZCConfig and will be deleted when
    // this latter one gets destroyed.
    pEapolConfig = new CEapolConfig;
    bOk = (pEapolConfig != NULL);

    if (bOk)
    {
        if (hWndCtl == m_hbtnCopy)
        {
            // get the selected item from the Visible list
            iSelected = ListView_GetNextItem(m_hwndVLV, -1, LVNI_SELECTED);
            bOk = (iSelected != -1);

            // there is a valid selection to copy (it couldn't be otherwise since
            // "Copy" shouldn't be enabled if there is no such selection)
            // Find the CWZCConfig for the selection
            if (bOk)
            {
                LVITEM lvi = {0};

                lvi.mask  = LVIF_PARAM;
                lvi.iItem = iSelected;
                if (ListView_GetItem(m_hwndVLV, &lvi))
                {
                    pConfig = (CWZCConfig*)lvi.lParam;
                    if (pConfig != NULL)
                    {
                        UINT nVisPrivacy = pConfig->m_wzcConfig.Privacy;
                        // check whether this config is in the preferred list. If IsConfigInList 
                        // succeeds, it returns in pConfig the pointer to the preferred config - this is
                        // what we need to show the properties for.
                        // If this network is not in the preferred list, pConfig will not be modified hence
                        // the properties coming from the AP will be loaded. Again what we want.
                        IsConfigInList(m_pHdPList, &pConfig->m_wzcConfig, &pConfig);
                        // copy in the newly created 802.1x object what we have for this configuration
                        pEapolConfig->CopyEapolConfig(pConfig->m_pEapolConfig);
                        // upload the 802.11 settings into the property page
                        PpWzcProps.UploadWzcConfig(pConfig);
                        // However, even if we're showing up preferred, settings, the Privacy bit from the AP
                        // (the visible configuration) takes precedence.
                        if (nVisPrivacy)
                        {
                            PpWzcProps.m_wzcConfig.Privacy = nVisPrivacy;
                        }
                    }
                }
                bOk = (pConfig != NULL);
            }
        }
        else
        {
            // this is a brand new network, we don't know even the SSID,
            // let 802.1x start with its defaults then.
            pEapolConfig->LoadEapolConfig(m_IntfEntry.wszGuid, NULL);
            bOk = TRUE;
        }
    }

    // we have the CWZCConfig object, prompt the user with it allowing 
    // him to change whatever params he want
    if (bOk)
    {
        CWLANAuthenticationPage PpAuthProps(NULL, m_pnc, m_pconn, g_aHelpIDs_IDD_SECURITY);

        // if the mode is not "auto", freeze it in the dialog
        if ((m_dwCtlFlags & INTFCTL_CM_MASK) != Ndis802_11AutoUnknown)
        {
            PpWzcProps.m_wzcConfig.InfrastructureMode = (NDIS_802_11_NETWORK_INFRASTRUCTURE)(m_dwCtlFlags & INTFCTL_CM_MASK);
            PpWzcProps.SetFlags(WZCDLG_PROPS_RWINFR, 0);
        }

        PpAuthProps.UploadEapolConfig(pEapolConfig, &PpWzcProps);
        PpWzcProps.UploadEapolConfig(pEapolConfig);
        bOk = (_DoModalPropSheet(&PpWzcProps, &PpAuthProps) > 0);
    }

    // the dialog was ack-ed, the dialog contains the WZC_WLAN_CONFIG to be added
    // go ahead and create the list entry for it.
    if (bOk)
    {
        DWORD dwFlags = WZC_DESCR_PREFRD;
        DWORD dwErr;

        // it could happen that the newly added config is visible
        if (IsConfigInList(m_pHdVList, &PpWzcProps.m_wzcConfig))
            dwFlags |= WZC_DESCR_VISIBLE;

        // we have now a WZC_WLAN_CONFIG structure in the dialog
        // we have to add it to the list view and to the internal list as
        // a preferred one. This call doesn't fix the list index
        // and doesn't insert the new config in the ListView.

        dwErr = AddUniqueConfig(
                    WZCADD_OVERWRITE | WZCADD_HIGROUP,
                    dwFlags,
                    &PpWzcProps.m_wzcConfig,
                    pEapolConfig,   // 802.1x settings need to be updated no matter what
                    &pConfig);

        // if the addition returns success, it means this is a brand new
        // entry! Then fix the indices and add the entry to the list view
        if (dwErr == ERROR_SUCCESS)
        {
            CWZCConfig *pCrt = pConfig;
            INT      nCrtIdx = 0;

            // if everything went up fine, we need to fix the indices and
            // create/add the list view item
            // find the first index above the newly entry item.
            // pConfig already has the m_nListIndex set to -1;
            if (pConfig == m_pHdPList)
            {
                nCrtIdx = 0;
            }
            else
            {
                do
                {
                    pCrt = pCrt->m_pPrev;
                    if (pCrt->m_nListIndex != -1)
                    {
                        nCrtIdx = pCrt->m_nListIndex+1;
                        break;
                    }
                } while(pCrt != m_pHdPList);
            }

            pConfig->m_nListIndex = nCrtIdx++;
            pCrt = pConfig->m_pNext;

            while(pCrt != m_pHdPList)
            {
                if (pCrt->m_nListIndex != -1)
                    pCrt->m_nListIndex = nCrtIdx++;
                pCrt = pCrt->m_pNext;
            }

            pConfig->AddConfigToListView(m_hwndPLV, pConfig->m_nListIndex);
        }

        bOk = (dwErr == ERROR_SUCCESS) || (dwErr == ERROR_DUPLICATE_TAG);
    }

    if (bOk)
    {
        ListView_SetItemState(m_hwndPLV, pConfig->m_nListIndex, LVIS_SELECTED, LVIS_SELECTED);
        ListView_EnsureVisible(m_hwndPLV, pConfig->m_nListIndex, FALSE);
        RefreshButtons();
    }

    if (!bOk && pEapolConfig != NULL)
        delete pEapolConfig;

    bHandled = bOk;
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT
CWZeroConfPage::OnPushRefresh(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hr = S_OK;
    DWORD rpcStatus;
    DWORD dwOutFlags;

    // since we are here, it means we have already got the info for this adapter, hence
    // we already have its GUID in the m_IntfEntry member.
    // All we have to do is to ask WZCSVC for a visible list rescan

    rpcStatus = WZCRefreshInterface(
                    NULL, 
                    INTF_LIST_SCAN,
                    &m_IntfEntry, 
                    &dwOutFlags);

    // if everything went fine, just disable the "Refresh" button and set
    // the timer for the future query
    if (rpcStatus == RPC_S_OK &&
        dwOutFlags & INTF_LIST_SCAN)
    {
        ::EnableWindow(m_hbtnRfsh, FALSE);
        // mark that we don't have WZC data yet
        m_bHaveWZCData = FALSE;
        // switch the cursor to the "app starting"
        m_hCursor = SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        m_nTimer = SetTimer(g_TimerID, RFSH_TIMEOUT, 0);
        // indicate we don't have the visible list in order
        // to disable all the buttons
        m_dwOIDFlags &= ~INTF_BSSIDLIST;
        RefreshButtons();
        // disable all the UI while refreshing
        ::EnableWindow(m_hckbEnable, FALSE);
        ::EnableWindow(m_hwndVLV, FALSE);
        ::EnableWindow(m_hwndPLV, FALSE);
        ::EnableWindow(m_hlblVisNet, FALSE);
        ::EnableWindow(m_hlblPrefNet, FALSE);
        ::EnableWindow(m_hlblAvail, FALSE);
        ::EnableWindow(m_hlblPrefDesc, FALSE);
        ::EnableWindow(m_hlblAdvDesc, FALSE);
        ::EnableWindow(m_hbtnAdvanced, FALSE);
    }

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT 
CWZeroConfPage::OnPushUpOrDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    INT         iSelected;
    INT         iOther;
    CWZCConfig  *pConfig, *pOther;

    // no matter what, get the selected item from the list
    iSelected = ListView_GetNextItem(m_hwndPLV, -1, LVNI_SELECTED);

    // since we are here it means there is another entry up/down side
    // with which the selected one needs to change place
    // first delete the entry from its current position in the list
    iOther = (hWndCtl == m_hbtnDown)? iSelected+1 : iSelected-1;
    // swap first the visual elements (entries in the List View)
    // This returns the CWZCConfig pointers with their indices already
    // adjusted
    if (SwapConfigsInListView(iSelected, iOther, pConfig, pOther) == ERROR_SUCCESS)
    {
        // if need to go down one hop..
        if (hWndCtl == m_hbtnDown)
        {
            // swap positions in the list 
            // remove the entry from its current position
            pOther->m_pPrev = pConfig->m_pPrev;
            pConfig->m_pPrev->m_pNext = pOther;
            // and put it back down to its successor
            pConfig->m_pPrev = pOther;
            pConfig->m_pNext = pOther->m_pNext;
            pOther->m_pNext->m_pPrev = pConfig;
            pOther->m_pNext = pConfig;
            // fix the m_pHdPList if needed;
            if (m_pHdPList == pConfig)
                m_pHdPList = pOther;
        }
        // if need to go up one hop..
        else
        {
            // swap positions in the list
            // remove the entry from its current position
            pOther->m_pNext = pConfig->m_pNext;
            pConfig->m_pNext->m_pPrev = pOther;
            // and put it back in front of its predecessor
            pConfig->m_pNext = pOther;
            pConfig->m_pPrev = pOther->m_pPrev;
            pOther->m_pPrev->m_pNext = pConfig;
            pOther->m_pPrev = pConfig;
            // fix the m_pHdPList if needed
            if (m_pHdPList == pOther)
                m_pHdPList = pConfig;
        }
    }

    // need to refresh the buttons such that the "Up"/"Down" buttons
    // get updated for the new position of the selection
    RefreshButtons();
    bHandled = TRUE;

    return LresFromHr(hr);
}

//+---------------------------------------------------------------------
LRESULT CWZeroConfPage::OnPushRemove(
    WORD wNotifyCode,
    WORD wID, 
    HWND hWndCtl,
    BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    LVITEM      lvi = {0};
    CWZCConfig  *pConfig, *pCrt;
    INT     iSelected;

    iSelected = ListView_GetNextItem(m_hwndPLV, -1, LVNI_SELECTED);

    lvi.mask  = LVIF_PARAM;
    lvi.iItem = iSelected;
    if (!ListView_GetItem(m_hwndPLV, &lvi))
        goto exit;
    // get the CWZCConfig from it
    pConfig = (CWZCConfig*)lvi.lParam;

    // adjust the list indices for all the entries that follow
    // the selected one
    for (pCrt = pConfig->m_pNext; pCrt != m_pHdPList; pCrt = pCrt->m_pNext)
    {
        if (pCrt->m_nListIndex != -1)
            pCrt->m_nListIndex--;
    }
    // determine first which entry gets the selection
    // the selection moves down if there is any other entry down, or up otherwise
    pCrt = (pConfig->m_pNext == m_pHdPList) ? pConfig->m_pPrev : pConfig->m_pNext;

    // if after that the selection still points to the same object, it means
    // it is the only one in the list so the head and selection are set to NULL
    if (pCrt == pConfig)
    {
        m_pHdPList = pCrt = NULL;
    }
    // otherwise, if it is the head of the list which gets removed, the head
    // moves down to the next entry
    else if (m_pHdPList == pConfig)
    {
        m_pHdPList = pConfig->m_pNext;
    }

    // delete now the selected entry from the list
    ListView_DeleteItem(m_hwndPLV, iSelected);
    // and destroy its object (desctructor takes care of list removal)
    delete pConfig;

    // set the new selection if any
    if (pCrt != NULL)
    {
        ListView_SetItemState(m_hwndPLV, pCrt->m_nListIndex, LVIS_SELECTED, LVIS_SELECTED);
        ListView_EnsureVisible(m_hwndPLV, pCrt->m_nListIndex, FALSE);
    }
    // refresh the buttons' state
    RefreshButtons();

    bHandled = TRUE;

exit:
    return LresFromHr(hr);
}

LRESULT CWZeroConfPage::OnPushAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bHandled = TRUE;
    DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_LAN_WZC_ADVANCED), m_hWnd, AdvancedDialogProc, (LPARAM) this);
    RefreshListView(WZCOP_VLIST|WZCOP_PLIST);
    RefreshButtons();
    return 0;
}

LRESULT CWZeroConfPage::OnPushProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    bHandled = TRUE;
    int iItem = ListView_GetNextItem(m_hwndPLV, -1, LVNI_SELECTED);
    if (-1 != iItem)
    {
        _DoProperties(m_hwndPLV, iItem);
    }

    return 0;
}

HRESULT CWZeroConfPage::_DoProperties(HWND hwndLV, int iItem)
{
    LV_ITEM lvi = {0};

    // we need to get to the corresponding config object
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;

    if (ListView_GetItem(hwndLV, &lvi) && lvi.lParam != NULL)
    {
        CWZCConfig  *pConfig = (CWZCConfig*)lvi.lParam;

        if (hwndLV == m_hwndVLV)
        {
            CWZCConfigProps dlgProps;

            dlgProps.UploadWzcConfig(pConfig);
            // bring up the info dialog (it only has "Close" so the user can't
            // change anything there, hence there is no reason to do anything
            // more here.
            dlgProps.DoModal(m_hWnd);
        }
        else
        {
            BOOL bOk = FALSE;
            CWZCConfigPage PpWzcProps(WZCDLG_PROPS_RWAUTH|WZCDLG_PROPS_RWWEP);
            CEapolConfig *pEapolConfig;

            PpWzcProps.UploadWzcConfig(pConfig);

            pEapolConfig = new CEapolConfig;
            bOk = (pEapolConfig != NULL);

            if (bOk)
            {
                CWLANAuthenticationPage PpAuthProps(NULL, m_pnc, m_pconn, g_aHelpIDs_IDD_SECURITY);

                pEapolConfig->CopyEapolConfig(pConfig->m_pEapolConfig);
                PpAuthProps.UploadEapolConfig(pEapolConfig, &PpWzcProps);
                PpWzcProps.UploadEapolConfig(pEapolConfig);
                bOk = (_DoModalPropSheet(&PpWzcProps, &PpAuthProps, TRUE) > 0);
            }

            // bring up the modal property sheet
            if (bOk)
            {
                // copy over the info from the dialog. SSID & Infra Mode should have been locked
                // so the position of this entry in the internal and UI list has not changed
                memcpy(&pConfig->m_wzcConfig, &PpWzcProps.m_wzcConfig, sizeof(WZC_WLAN_CONFIG));

                delete pConfig->m_pEapolConfig;
                pConfig->m_pEapolConfig = pEapolConfig;
            }

            if (!bOk && pEapolConfig != NULL)
                delete pEapolConfig;
        }
    }

    return S_OK;
}

INT CWZeroConfPage::_DoModalPropSheet(CWZCConfigPage *pPpWzcPage, CWLANAuthenticationPage *pPpAuthPage, BOOL bCustomizeTitle)
{
    INT retCode = 0;
    PROPSHEETHEADER     psh;
    HPROPSHEETPAGE      hpsp[2];
    INT                 npsp = 0;
    LPWSTR              pwszCaption = NULL;
    WCHAR               wszBuffer[64];

    hpsp[0] = pPpWzcPage->CreatePage(
                              IDC_WZC_DLG_PROPS, 
                              0,
                              NULL,
                              NULL,
                              NULL,
                              WZCGetSPResModule());
    npsp++;
    if (hpsp[0] == NULL)
        return -1;

    if(pPpAuthPage != NULL)
    {
        hpsp[1] = pPpAuthPage->CreatePage(
                                   IDD_LAN_SECURITY,
                                   0,
                                   NULL,
                                   NULL,
                                   NULL,
                                   WZCGetSPResModule());
        npsp++;
        if (hpsp[1] == NULL)
            return -1;
    }

    ZeroMemory (&psh, sizeof(psh));
    psh.dwSize      = sizeof( PROPSHEETHEADER );
    psh.dwFlags     = PSH_NOAPPLYNOW ;
    psh.hwndParent  = m_hWnd;
    psh.hInstance   = WZCGetSPResModule();
    psh.nPages      = npsp;
    psh.phpage      = hpsp;
    psh.nStartPage  = 0;

    // just double check the SsidLength is no larger than the allowed size!
    if (bCustomizeTitle && pPpWzcPage->m_wzcConfig.Ssid.SsidLength <= 32)
    {
        // SzLoadString returns either the right string or " " (space)
        //LPCWSTR  pwszSuffix = SzLoadString(WZCGetSPResModule(), IDS_WZC_DLG_CAP_SUFFIX);
        LPCWSTR  pwszSuffix = wszBuffer;
        UINT    nLen = 0;

        LoadString(WZCGetSPResModule(), IDS_WZC_DLG_CAP_SUFFIX, wszBuffer, sizeof(wszBuffer));
  
        // alocate space enough for the SSID (32 ACP chars can't result in more than 32 WCHARs)
        // the space between the SSID and the suffix, the suffix itself and the null-terminator
        pwszCaption = new WCHAR [wcslen(pwszSuffix) + pPpWzcPage->m_wzcConfig.Ssid.SsidLength + 2];
        // in case of failure put in just the suffix!
        if (pwszCaption == NULL)
        {
            psh.pszCaption = pwszSuffix;
        }
        else
        {
            if (pPpWzcPage->m_wzcConfig.Ssid.SsidLength)
            {
                nLen = MultiByteToWideChar(
                            CP_ACP,
                            0,
                            (LPCSTR)pPpWzcPage->m_wzcConfig.Ssid.Ssid,
                            pPpWzcPage->m_wzcConfig.Ssid.SsidLength,
                            pwszCaption,
                            32); // no more than 32 WCHARs reserved for the SSID
            }
            pwszCaption[nLen] = L' ';
            // this copies the null terminator as well
            wcscpy(&(pwszCaption[nLen + 1]), pwszSuffix);
            psh.pszCaption = pwszCaption;
        }
    }
    else
    {
        LoadString(WZCGetSPResModule(), IDS_WZC_DLG_CAPTION, wszBuffer, sizeof(wszBuffer));
        //psh.pszCaption = SzLoadString(WZCGetSPResModule(), IDS_WZC_DLG_CAPTION);
        psh.pszCaption = wszBuffer;
    }

    retCode = PropertySheet(&psh);

    if (pwszCaption != NULL)
        delete pwszCaption;

    return retCode;
}

// Advanced dialog
INT_PTR CALLBACK CWZeroConfPage::AdvancedDialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Get the pointer to our instance from where we stashed it.
    CWZeroConfPage* pThis = (CWZeroConfPage*) ::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if (!pThis)
    {
        if (WM_INITDIALOG == uMsg)
        {
            // Stash our instance pointer
            pThis = (CWZeroConfPage*) lParam;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pThis);
        }
    }

    if (pThis)
    {
        switch (uMsg)
        {
        case WM_INITDIALOG:
            {
                // select the correct item by default
                NDIS_802_11_NETWORK_INFRASTRUCTURE mode = (NDIS_802_11_NETWORK_INFRASTRUCTURE)(pThis->m_dwCtlFlags & INTFCTL_CM_MASK);
                UINT idSelect;
                switch (mode)
                {
                case Ndis802_11IBSS:
                    // Computer-to-computer
                    idSelect = IDC_ADHOC;
                    break;
                case Ndis802_11Infrastructure:
                    // infrastructure (access point) network
                    idSelect = IDC_INFRA;
                    break;
                case Ndis802_11AutoUnknown:
                default:
                    // Any network (access point preferred)
                    idSelect = IDC_ANYNET;
                };

                // Select the right radio button
                ::SendDlgItemMessage(hwnd, idSelect, BM_SETCHECK, BST_CHECKED, 0);

                // Check the "fallback to visible networks" checkbox if necessary
                ::SendDlgItemMessage(hwnd, IDC_WZC_CHK_Fallback, BM_SETCHECK, (pThis->m_dwCtlFlags & INTFCTL_FALLBACK) ? BST_CHECKED : BST_UNCHECKED, 0);
            }

            return TRUE;
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
            case IDOK:
                {
                    // ...Set the connectivity mode...
                    NDIS_802_11_NETWORK_INFRASTRUCTURE mode = Ndis802_11AutoUnknown;

                    // See what type of network connectivity the user selected
                    if (BST_CHECKED == ::SendDlgItemMessage(hwnd, IDC_ADHOC, BM_GETCHECK, 0, 0))
                    {
                        // Computer-to-computer
                        mode = Ndis802_11IBSS;
                    }
                    else if (BST_CHECKED == ::SendDlgItemMessage(hwnd, IDC_INFRA, BM_GETCHECK, 0, 0))
                    {
                        // infrastructure (access point) network
                        mode = Ndis802_11Infrastructure;
                    }
                    else if (BST_CHECKED == ::SendDlgItemMessage(hwnd, IDC_ANYNET, BM_GETCHECK, 0, 0))
                    {
                        // Any network (access point preferred)
                        mode = Ndis802_11AutoUnknown;
                    }

                    pThis->m_dwCtlFlags &= ~INTFCTL_CM_MASK;
                    pThis->m_dwCtlFlags |= (((DWORD) mode) & INTFCTL_CM_MASK);


                    // Set the "fallback to visible networks" flag
                    pThis->m_dwCtlFlags &= ~INTFCTL_FALLBACK;
                    if (BST_CHECKED == ::SendDlgItemMessage(hwnd, IDC_WZC_CHK_Fallback, BM_GETCHECK, 0, 0))
                    {
                        pThis->m_dwCtlFlags |= INTFCTL_FALLBACK;
                    }


                    ::EndDialog(hwnd, IDOK);
                }
                return TRUE;
            }
            break;
        case WM_CLOSE:
            ::EndDialog(hwnd, IDCANCEL);
            return TRUE;
        case WM_CONTEXTMENU:
            {
                ::WinHelp(hwnd,
                          c_szNetCfgHelpFile,
                          HELP_CONTEXTMENU,
                          (ULONG_PTR)g_aHelpIDs_IDC_WZC_ADVANCED);
                return TRUE;
            }
        case WM_HELP:
            {
                LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
                ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                      c_szNetCfgHelpFile,
                      HELP_WM_HELP,
                      (ULONG_PTR)g_aHelpIDs_IDC_WZC_ADVANCED);
                return TRUE;
            }
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\afilexp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A F I L E X P . H
//
//  Contents:   Functions exported from netsetup for answerfile related work.
//
//  Author:     kumarp    25-November-97
//
//----------------------------------------------------------------------------

#pragma once
#include "afileint.h"
#include <syssetup.h>

HRESULT
HrInitForUnattendedNetSetup (
    IN INetCfg* pnc,
    IN PINTERNAL_SETUP_DATA pisd);

HRESULT
HrInitForRepair (VOID);

VOID
HrCleanupNetSetup();

HRESULT
HrInitAnswerFileProcessing (
    IN PCWSTR szAnswerFileName,
    OUT CNetInstallInfo** ppnii);

EXTERN_C
HRESULT
WINAPI
HrGetInstanceGuidOfPreNT5NetCardInstance(
    IN PCWSTR szPreNT5NetCardInstance,
    OUT LPGUID pguid);

HRESULT
HrResolveAnswerFileAdapters (
    IN INetCfg* pnc);

HRESULT
HrGetAnswerFileParametersForComponent (
    IN PCWSTR pszInfId,
    OUT PWSTR* ppszAnswerFile,
    OUT PWSTR* ppszAnswerSection);

HRESULT
HrGetAnswerFileName(
    OUT tstring* pstrAnswerFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\afilexp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A F I L E X P . C P P
//
//  Contents:   Functions exported from netsetup for answerfile related work.
//
//  Author:     kumarp    25-November-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "afileint.h"
#include "afilexp.h"
#include "compid.h"
#include "kkenet.h"
#include "kkutils.h"
#include "ncerror.h"
#include "ncnetcfg.h"
#include "ncsetup.h"
#include "nsbase.h"
#include "oemupgrd.h"
#include "resource.h"
#include "upgrade.h"
#include <wdmguid.h>
#include "nslog.h"

//+---------------------------------------------------------------------------
// Global variables
//
CNetInstallInfo*    g_pnii;
CNetInstallInfo*    g_pniiTemp;
DWORD               g_dwOperationFlags = 0;

//+---------------------------------------------------------------------------
//
// Function:  HrDoUnattend
//
// Purpose:   call member function of CNetInstallInfo to perform
//            answerfile based install/upgrade work
//
// Arguments:
//    hwndParent     [in]  handle of parent window
//    punk           [in]  pointer to an interface
//    idPage         [in]  id indicating which section to run
//    ppdm           [out] pointer to page display mode
//    pfAllowChanges [out] pointer to flag controlling read/write behavior
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 26-November-97
//
EXTERN_C
HRESULT
WINAPI
HrDoUnattend (
    IN HWND hwndParent,
    IN IUnknown* punk,
    IN EUnattendWorkType uawType,
    OUT EPageDisplayMode* ppdm,
    OUT BOOL* pfAllowChanges)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(punk);
    Assert(ppdm);
    Assert(pfAllowChanges);
    Assert(g_pnii);

    HRESULT hr = S_OK;

#if DBG
    if (FIsDebugFlagSet (dfidBreakOnDoUnattend))
    {
        AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                 "\"BreakOnDoUnattend\" has been set. Set your breakpoints now.");
    }
#endif //_DEBUG

    hr = g_pnii->HrDoUnattended(hwndParent, punk, uawType, ppdm, pfAllowChanges);

    TraceHr(ttidError, FAL, hr, FALSE, "HrDoUnattend");
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInitForRepair
//
// Purpose:   Initialize in repair mode.
//
// Arguments:
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    asinha 17-October-2001
//
HRESULT
HrInitForRepair (VOID)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;

    g_pnii = NULL;

    hr = CNetInstallInfo::HrCreateInstance (
            NULL,
            &g_pnii);

    TraceHr(ttidError, FAL, hr, FALSE,
        "HrInitForRepair");

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInitForUnattendedNetSetup
//
// Purpose:   Initialize net setup for answerfile processing
//
// Arguments:
//    pnc  [in]  pointer to INetCfg object
//    pisd [in]  pointer to private data supplied by base setup
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 26-November-97
//
HRESULT
HrInitForUnattendedNetSetup (
    IN INetCfg* pnc,
    IN PINTERNAL_SETUP_DATA pisd)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(pnc);
    Assert(pisd);

    HRESULT hr = S_OK;

    g_dwOperationFlags = pisd->OperationFlags;
    if (pisd->OperationFlags & SETUPOPER_BATCH)
    {
        Assert(pisd->UnattendFile);
        AssertSz(!g_pnii, "who initialized g_pnii ??");

        hr = HrInitAnswerFileProcessing(pisd->UnattendFile, &g_pnii);
    }

    TraceHr(ttidError, FAL, hr,
       (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) ||
       (hr == NETSETUP_E_NO_ANSWERFILE),
        "HrInitNetSetup");
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrCleanupNetSetup
//
// Purpose:   Do cleanup work in NetSetup
//
// Arguments: None
//
// Returns:   Nothing
//
// Author:    kumarp 26-November-97
//
VOID
HrCleanupNetSetup()
{
    TraceFileFunc(ttidGuiModeSetup);

    DeleteIfNotNull(g_pnii);
    DeleteIfNotNull(g_pniiTemp);
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetAnswerFileName
//
// Purpose:   Generate full path to the answerfile
//
// Arguments:
//    pstrAnswerFileName [out] pointer to name of answerfile
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 26-November-97
//
// Notes:     !!!This function has a dependency on the base setup.!!!
//            If base setup changes name of the answerfile, this fn
//            function will break.
//
HRESULT
HrGetAnswerFileName(
    OUT tstring* pstrAnswerFileName)
{
    TraceFileFunc(ttidGuiModeSetup);

    static const WCHAR c_szAfSubDirAndName[] = L"\\system32\\$winnt$.inf";

    HRESULT hr=S_OK;

    WCHAR szWinDir[MAX_PATH+1];
    DWORD cNumCharsReturned = GetSystemWindowsDirectory(szWinDir, MAX_PATH);

    if (cNumCharsReturned)
    {
        *pstrAnswerFileName = szWinDir;
        *pstrAnswerFileName += c_szAfSubDirAndName;
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrGetAnswerFileName");
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInitAnswerFileProcessing
//
// Purpose:   Initialize answerfile processing
//
// Arguments:
//    szAnswerFileName [in]  name of answerfile
//    ppnii            [out] pointer to pointer to CNetInstallInfo object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 26-November-97
//
HRESULT
HrInitAnswerFileProcessing (
    IN PCWSTR szAnswerFileName,
    OUT CNetInstallInfo** ppnii)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(ppnii);

    HRESULT hr = S_OK;
    tstring strAnswerFileName;

    *ppnii = NULL;

    if (!szAnswerFileName)
    {
        hr = HrGetAnswerFileName(&strAnswerFileName);
    }
    else
    {
        strAnswerFileName = szAnswerFileName;
    }

    if (S_OK == hr)
    {
        hr = CNetInstallInfo::HrCreateInstance (
                strAnswerFileName.c_str(),
                ppnii);
    }

    TraceHr(ttidError, FAL, hr,
        (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) ||
        (hr == NETSETUP_E_NO_ANSWERFILE),
        "HrInitAnswerFileProcessing");
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrOemUpgrade
//
// Purpose:   Process special OEM upgrades by running an inf section
//
// Arguments:
//    hkeyDriver           [in] the driver key
//    pszAnswerFile       [in] pointer to answer filename string.
//    pszAnswerSection    [in] pointer to answer filname sections string
//
// Returns:   S_OK on success, otherwise an error code
//
// Date:    30 Mar 1998
//
EXTERN_C
HRESULT
WINAPI
HrOemUpgrade(
    IN HKEY hkeyDriver,
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(hkeyDriver);
    Assert(pszAnswerFile);
    Assert(pszAnswerSection);

    // Open the answer file.
    HINF hinf;
    HRESULT hr = HrSetupOpenInfFile(pszAnswerFile, NULL,
                INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL, &hinf);

    if (SUCCEEDED(hr))
    {
        tstring strInfToRun;
        tstring strSectionToRun;
        tstring strInfToRunType;

        // Get the file and section to run for upgrade
        hr = HrAfGetInfToRunValue(hinf, pszAnswerFile, pszAnswerSection,
                I2R_AfterInstall, &strInfToRun, &strSectionToRun, &strInfToRunType);

        if (S_OK == hr)
        {
            HINF hinfToRun;
            // Open the inf file containing the section to run
            hr = HrSetupOpenInfFile(strInfToRun.c_str(), NULL,
                        INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL,
                        &hinfToRun);

            if (SUCCEEDED(hr))
            {
                TraceTag(ttidNetSetup, "Running section %S in %S",
                         strSectionToRun.c_str(), strInfToRun.c_str());

                // Run the section against the key
                hr = HrSetupInstallFromInfSection (NULL,
                        hinfToRun, strSectionToRun.c_str(), SPINST_REGISTRY,
                        hkeyDriver, NULL, 0, NULL, NULL, NULL, NULL);

                NetSetupLogHrStatusV(hr, SzLoadIds (IDS_STATUS_OF_APPLYING),
                                     pszAnswerSection,
                                     strInfToRunType.c_str(),
                                     strSectionToRun.c_str(),
                                     strInfToRun.c_str());
                SetupCloseInfFile(hinfToRun);
            }
        }
        else if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // Nothing to run.
            hr = S_FALSE;
        }
        SetupCloseInfFile(hinf);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrOemUpgrade");
    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetAnswerFileParametersForComponent
//
// Purpose:   Search in answerfile for a component whose InfId matches
//            the one specified.
//
// Arguments:
//    pszInfId            [in]  inf id of component
//    ppszAnswerFile      [out] pointer to answer filename string.
//    ppszAnswerSection   [out] pointer to answer filename section string
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    billbe 12 July 1999
//
// Notes:     This fcn is not for adapters.  If you need the answerfile
//                  parameters for an adapter, use
//                  HrGetAnswerFileParametersForNetCard.
//
HRESULT
HrGetAnswerFileParametersForComponent (
    IN PCWSTR pszInfId,
    OUT PWSTR* ppszAnswerFile,
    OUT PWSTR* ppszAnswerSection)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(pszInfId);
    Assert(ppszAnswerFile);
    Assert(ppszAnswerSection);

    HRESULT hr = S_OK;

    TraceTag (ttidNetSetup, "In HrGetAnswerFileParametersForComponent");

    *ppszAnswerFile = NULL;
    *ppszAnswerSection = NULL;

    // If we don't already have a cached pointer...
    if (!g_pniiTemp)
    {
        // Initialize our net install info.
        hr = HrInitAnswerFileProcessing(NULL, &g_pniiTemp);
    }

    if (S_OK == hr)
    {
        Assert(g_pniiTemp);
        if (!g_pniiTemp->AnswerFileInitialized())
        {
            hr = NETSETUP_E_NO_ANSWERFILE;
            TraceTag (ttidNetSetup, "No answerfile");
        }

        if (S_OK == hr)
        {
            // Find the component in the list of component's with
            // answer file sections.
            CNetComponent* pnetcomp;
            pnetcomp = g_pniiTemp->FindFromInfID (pszInfId);

            if (!pnetcomp)
            {
                // The component doesn't have a section.  Return
                // no answer file.
                hr = NETSETUP_E_NO_ANSWERFILE;
                TraceTag (ttidNetSetup, "Component not found");
            }
            else
            {
                if (NCT_Adapter == pnetcomp->Type())
                {
                    // We don't support getting answerfile parameters
                    // for adapters. HrGetAnswerFileParametersForNetCard
                    // is the fcn for adapters.
                    hr = NETSETUP_E_NO_ANSWERFILE;
                }
                else
                {
                    // Allocate and save the answerfile name and the
                    // component's section.
                    hr = HrCoTaskMemAllocAndDupSz (g_pniiTemp->AnswerFileName(),
                            ppszAnswerFile);
                    if (S_OK == hr)
                    {
                        hr = HrCoTaskMemAllocAndDupSz (
                                pnetcomp->ParamsSections().c_str(),
                                ppszAnswerSection);
                    }
                }
            }
        }
    }
    else
    {
        TraceTag (ttidNetSetup, "Answerfile could not be initialized");
    }

    TraceHr (ttidError, FAL, hr,
            (NETSETUP_E_NO_ANSWERFILE == hr) ||
            (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr),
            "HrGetAnswerFileParametersForComponent");

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetAnswerFileParametersForNetCard
//
// Purpose:   Search in answerfile for a net card whose InfID matches
//            at least one in the supplied multi-sz list.
//
// Arguments:
//    mszInfIDs            [in]  list of InfIDs
//    pszDeviceName        [in]  exported device name of the card to search
//    pguidNetCardInstance [in]  pointer to instance guid of the card
//    pszAnswerFile       [out] pointer to answer filename string.
//    pszAnswerSection   [out] pointer to answer filname sections string
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 26-November-97
//
// Notes:     If more than one such card is found in the answerfile, then
//            resolve between the cards by finding out the net-card-address
//            of the pszServiceInstance and matching it against that
//            stored in the answerfile.
//
EXTERN_C
HRESULT
WINAPI
HrGetAnswerFileParametersForNetCard(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszDeviceName,
    IN const GUID*  pguidNetCardInstance,
    OUT PWSTR* ppszwAnswerFile,
    OUT PWSTR* ppszwAnswerSections)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(pguidNetCardInstance);
    Assert(ppszwAnswerFile);
    Assert(ppszwAnswerSections);

    HRESULT hr=E_FAIL;
    CNetAdapter* pna=NULL;
    WORD wNumAdapters=0;
    QWORD qwNetCardAddr=0;

    *ppszwAnswerFile         = NULL;
    *ppszwAnswerSections     = NULL;

    if (!g_pniiTemp)
    {
        hr = HrInitAnswerFileProcessing(NULL, &g_pniiTemp);
#if DBG
        if (S_OK == hr)
        {
            Assert(g_pniiTemp);
        }
#endif
        if (FAILED(hr) || !g_pniiTemp->AnswerFileInitialized())
        {
            TraceHr (ttidNetSetup, FAL, hr, (hr == NETSETUP_E_NO_ANSWERFILE) ||
                    hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
                    "HrGetAnswerFileParametersForNetCard");

            return hr;
        }
    }

    // the defs of HIDWORD and LODWORD are wrong in byteorder.hxx

#   define LODWORD(a) (DWORD)( (a) & ( (DWORD)~0 ))
#   define HIDWORD(a) (DWORD)( (a) >> (sizeof(DWORD)*8) )

    hr = HrGetNetCardAddr(pszDeviceName, &qwNetCardAddr);
    if ((S_OK == hr) && qwNetCardAddr)
    {
        // there is a bug in wvsprintfA (used in trace.cpp) which does not
        // handle %I64x therefore we need to show the QWORD addr as follows
        //
        TraceTag(ttidNetSetup, "net card address of %S is 0x%x%x",
                 pszDeviceName, HIDWORD(qwNetCardAddr),
                 LODWORD(qwNetCardAddr));

        hr = g_pniiTemp->FindAdapter(qwNetCardAddr, &pna);

        if (NETSETUP_E_NO_EXACT_MATCH == hr)
        {
            TraceTag(ttidError, "there is no card with this netcard address in the answer-file");
        }
    }
    else
    {
        TraceTag(ttidError, "error getting netcard address of %S",
                 pszDeviceName);

        // if we either (a) failed to get the NetCard address, or
        // (b) if the netcard address was 0 (ISDN adapters), we try other means
        //
        hr = NETSETUP_E_AMBIGUOUS_MATCH;
    }

    if (NETSETUP_E_AMBIGUOUS_MATCH == hr)
    {
        // could not match netcard using the mac addr. If this device is
        // PCI, try to match using location info.
        //

        TraceTag (ttidNetSetup, "Did not find a match for netcard address. "
                "But there was at least one section that did not specify an "
                "address.\nChecking bus type of installed adapter.");

        GUID BusTypeGuid;
        hr = HrSetupDiGetDeviceRegistryProperty (hdi, pdeid,
                SPDRP_BUSTYPEGUID, NULL, (BYTE*)&BusTypeGuid,
                sizeof (BusTypeGuid), NULL);

        if (S_OK == hr)
        {
            if (GUID_BUS_TYPE_PCI == BusTypeGuid)
            {
                TraceTag (ttidNetSetup, "Installed adapter is PCI. "
                          "Retrieving its location info.");

                DWORD BusNumber;
                hr = HrSetupDiGetDeviceRegistryProperty (hdi, pdeid,
                        SPDRP_BUSNUMBER, NULL, (BYTE*)&BusNumber,
                        sizeof (BusNumber), NULL);

                if (S_OK == hr)
                {
                    DWORD Address;
                    hr = HrSetupDiGetDeviceRegistryProperty (hdi, pdeid,
                            SPDRP_ADDRESS, NULL, (BYTE*)&Address,
                            sizeof (Address), NULL);

                    if (S_OK == hr)
                    {
                        TraceTag (ttidNetSetup, "Installed device location: "
                            "Bus: %X, Device %x, Function %x\n Will try to "
                            "use location info to find a match with the "
                            "remaining ambiguous sections.", BusNumber,
                            HIWORD(Address), LOWORD(Address));

                        hr = g_pniiTemp->FindAdapter (BusNumber,
                                Address, &pna);

#ifdef ENABLETRACE
                        if (NETSETUP_E_NO_EXACT_MATCH == hr)
                        {
                            TraceTag (ttidNetSetup, "No match was found "
                                "using PCI location info.");
                        }
                        else if (NETSETUP_E_AMBIGUOUS_MATCH == hr)
                        {
                            TraceTag (ttidNetSetup, "Location info did not "
                                    "match but some sections did not specify "
                                    "location info.");
                        }
#endif // ENABLETRACE
                    }
                }
            }
            else
            {
                hr = NETSETUP_E_AMBIGUOUS_MATCH;
            }
        }

        if (FAILED(hr) && (NETSETUP_E_AMBIGUOUS_MATCH != hr) &&
            (NETSETUP_E_NO_EXACT_MATCH != hr))
        {
            TraceHr(ttidNetSetup, FAL, hr, FALSE, "Trying to retrieve/use "
                    "PCI location info.");
            hr = NETSETUP_E_AMBIGUOUS_MATCH;
        }


        if (NETSETUP_E_AMBIGUOUS_MATCH == hr)
        {
            // could not match netcard using the mac addr. try to match
            // using the PnP ID

            TraceTag (ttidNetSetup, "Will try to use pnp id to find a match "
                    "with the remaining ambiguous sections.");

            PWSTR mszInfIds;
            hr = HrGetCompatibleIds (hdi, pdeid, &mszInfIds);

            if (S_OK == hr)
            {
#ifdef ENABLETRACE
    TStringList slInfIds;
    tstring strInfIds;
    MultiSzToColString(mszInfIds, &slInfIds);
    ConvertStringListToCommaList(slInfIds, strInfIds);
    TraceTag(ttidNetSetup, "(InfIDs (%d): %S\tDeviceName: %S)",
             slInfIds.size(), strInfIds.c_str(), pszDeviceName);
#endif
                // find out how many adapters have this InfID
                wNumAdapters = g_pniiTemp->AdaptersPage()->GetNumCompatibleAdapters(mszInfIds);

                TraceTag(ttidNetSetup, "%d adapters of type '%S' found in the answer-file",
                         wNumAdapters, mszInfIds);

                if (wNumAdapters == 1)
                {
                    // a definite match found
                    pna = (CNetAdapter*) g_pniiTemp->AdaptersPage()->FindCompatibleAdapter(mszInfIds);
                    Assert(pna);

                    // Since matching by inf id can cause one section to be
                    // matched to multiple adapters, we pass on sections that
                    // have already been give to an adapter.
                    //
                    GUID guid = GUID_NULL;
                    pna->GetInstanceGuid(&guid);

                    if (GUID_NULL == guid)
                    {
                        // The section is still available.
                        hr = S_OK;
                    }
                    else
                    {
                        // This section was given to another adapter.
                        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    }
                }
                else
                {
                    // either there are no adapters of this type in the answerfile
                    // or there are multiple adapters of the same type.
                    // we couldn't match the card using the mac addr earlier.
                    // must return error
                    //
                    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                }
                MemFree (mszInfIds);
            }
        }
    }

    if (S_OK == hr)
    {
        Assert(pna);
        pna->SetInstanceGuid(pguidNetCardInstance);

        hr = HrCoTaskMemAllocAndDupSz(g_pniiTemp->AnswerFileName(),
                                      (PWSTR*) ppszwAnswerFile);
        if (S_OK == hr)
        {
            hr = HrCoTaskMemAllocAndDupSz(pna->ParamsSections().c_str(),
                                          (PWSTR*) ppszwAnswerSections);
        }
    }

    if (S_OK != hr && (NETSETUP_E_NO_ANSWERFILE != hr))
    {
        // add log so that we know why adapter specific params
        // are lost after upgrade
        //
        if (g_dwOperationFlags & SETUPOPER_NTUPGRADE)
        { // bug 124805 - We only want to see this during upgradres
            WCHAR szGuid[c_cchGuidWithTerm];
            StringFromGUID2(*pguidNetCardInstance, szGuid, c_cchGuidWithTerm);
            NetSetupLogStatusV(LogSevWarning,
                    SzLoadIds (IDS_ANSWERFILE_SECTION_NOT_FOUND),
                    szGuid);
        }
    }

    if ((NETSETUP_E_AMBIGUOUS_MATCH == hr) ||
            (NETSETUP_E_NO_EXACT_MATCH == hr))
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    TraceHr(ttidError, FAL, hr,
        (hr == NETSETUP_E_NO_ANSWERFILE) ||
        (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)),
        "HrGetAnswerFileParametersForNetCard");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidOfPreNT5NetCardInstance
//
//  Purpose:    Finds the instance guid of a component specified in the answerfile
//              or an already installed component
//
//  Arguments:
//      szPreNT5NetCardInstance [in]  pre-NT5 net card instance name e.g. "ieepro2"
//      pguid                   [out] instance guid of the same card
//
//  Returns:    S_OK if found, S_FALSE if not, or an error code.
//
//  Author:     kumarp    12-AUG-97
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrGetInstanceGuidOfPreNT5NetCardInstance (
    IN PCWSTR szPreNT5NetCardInstance,
    OUT LPGUID pguid)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(szPreNT5NetCardInstance);
    Assert(pguid);

    HRESULT hr = E_FAIL;

    if (IsBadStringPtr(szPreNT5NetCardInstance, 64) ||
        IsBadWritePtr(pguid, sizeof(GUID)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    else if (g_pnii)
    {
        hr = g_pnii->HrGetInstanceGuidOfPreNT5NetCardInstance (
                        szPreNT5NetCardInstance, pguid);
    }

    TraceHr(ttidError, FAL, hr, FALSE,
        "HrGetInstanceGuidOfPreNT5NetCardInstance");
    return hr;
}

HRESULT
HrResolveAnswerFileAdapters (
    IN INetCfg* pnc)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(g_pnii);

    HRESULT hr = S_OK;

    if (g_pnii)
    {
        hr = g_pnii->AdaptersPage()->HrResolveNetAdapters(pnc);
    }

    TraceHr(ttidError, FAL, hr, FALSE, "HrResolveAnswerFileAdapters");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\afileint.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A F I L E I N T . C P P
//
//  Contents:   Functions that operate on the answer file.
//
//  Notes:
//
//  Author:     kumarp    25-November-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "afileint.h"
#include "afilestr.h"
#include "afilexp.h"
#include "errorlog.h"
#include "kkenet.h"
#include "kkreg.h"
#include "kkutils.h"
#include "ncerror.h"
#include "ncnetcfg.h"
#include "netcfgn.h"
#include "netcfgp.h"
#include "nsbase.h"
#include "resource.h"
#include "upgrade.h"
#include "ncreg.h"

#include "ncmisc.h"
#include "oemupgrd.h"
#include "ncsetup.h"
#include "nsexports.h"
#include "nslog.h"
#include "netshell.h"
#include "ncnetcon.h"
#include "lancmn.h"
#include "compid.h"
#include "nceh.h"

// ----------------------------------------------------------------------
// String constants
// ----------------------------------------------------------------------
extern const WCHAR c_szYes[];
extern const WCHAR c_szNo[];
extern const WCHAR c_szDevice[];

extern const WCHAR c_szInfId_MS_GPC[];
extern const WCHAR c_szInfId_MS_MSClient[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_Server[];
extern const WCHAR c_szInfId_MS_TCPIP[];

const WCHAR sz_DLC[] = L"MS_DLC";
const WCHAR sz_DLC_NT40_Inf[] = L"system32\\oemnxpdl.inf";
const WCHAR sz_DLC_Win2k_Inf[] = L"inf\\netdlc.inf";
const WCHAR sz_DLC_Win2k_Pnf[] = L"inf\\netdlc.pnf";
const WCHAR sz_DLC_Sys[] = L"system32\\drivers\\dlc.sys";
const WCHAR sz_DLC_Dll[] = L"system32\\dlcapi.dll";

// ----------------------------------------------------------------------
// Forward declarations
// ----------------------------------------------------------------------

//Misc. helper functions
PCWSTR GetDisplayModeStr(IN EPageDisplayMode pdmDisplay);
EPageDisplayMode MapToDisplayMode(IN PCWSTR pszDisplayMode);
DWORD MapToUpgradeFlag(IN PCWSTR pszUpgradeFromProduct);
HRESULT HrGetProductInfo (LPDWORD pdwUpgradeFrom,
                          LPDWORD pdwBuildNo);
INTERFACE_TYPE GetBusTypeFromName(IN PCWSTR pszBusType);

void AddAnswerFileError(IN DWORD dwErrorId);
void AddAnswerFileError(IN PCWSTR pszSectionName, IN DWORD dwErrorId);
void AddAnswerFileError(IN PCWSTR pszSectionName,
                        IN PCWSTR pszKeyName,
                        IN DWORD dwErrorId);
CNetComponent* FindComponentInList(IN CNetComponentList* pnclComponents,
                                   IN PCWSTR szInfID);
HRESULT HrRemoveNetComponents(IN INetCfg* pnc,
                              IN TStringList* pslComponents);

HRESULT HrSetLanConnectionName(IN GUID*   pguidAdapter,
                               IN PCWSTR szConnectionName);

VOID    RemoveFiles (IN PCWSTR szInfID);

// ----------------------------------------------------------------------

CErrorLog* g_elAnswerFileErrors;

// ======================================================================
// class CNetInstallInfo
// ======================================================================

CNetInstallInfo::CNetInstallInfo()
{
    TraceFileFunc(ttidGuiModeSetup);

    m_pwifAnswerFile = NULL;

    m_pnaiAdaptersPage = NULL;
    m_pnpiProtocolsPage = NULL;
    m_pnsiServicesPage = NULL;
    m_pnciClientsPage = NULL;
    m_pnbiBindingsPage = NULL;

    m_dwUpgradeFlag = 0;
    m_dwBuildNumber = 0;
    m_fProcessPageSections = TRUE;
    m_fUpgrade = FALSE;

    m_fInstallDefaultComponents = FALSE;
    ZeroMemory(&m_nui, sizeof(m_nui));
    m_hinfAnswerFile = NULL;

}
// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::CNetInstallInfo
//
// Purpose:   constructor for class CNetInstallInfo
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
// static
HRESULT
CNetInstallInfo::HrCreateInstance (
    IN PCWSTR pszAnswerFileName,
    OUT CNetInstallInfo** ppObj)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr;
    CNetInstallInfo* pObj;

    Assert(ppObj);
    *ppObj = NULL;

    hr = E_OUTOFMEMORY;
    pObj = new CNetInstallInfo ();

    if (pObj)
    {
        g_elAnswerFileErrors = new CErrorLog;

        pObj->m_pnaiAdaptersPage   = new CNetAdaptersPage(pObj);
        pObj->m_pnpiProtocolsPage  = new CNetProtocolsPage(pObj);
        pObj->m_pnsiServicesPage   = new CNetServicesPage(pObj);
        pObj->m_pnciClientsPage    = new CNetClientsPage(pObj);
        pObj->m_pnbiBindingsPage   = new CNetBindingsPage(pObj);

        if (g_elAnswerFileErrors &&
            pObj->m_pnaiAdaptersPage   &&
            pObj->m_pnpiProtocolsPage  &&
            pObj->m_pnsiServicesPage   &&
            pObj->m_pnciClientsPage    &&
            pObj->m_pnbiBindingsPage)
        {
            if ( pszAnswerFileName )
            {
                hr = pObj->HrInitFromAnswerFile (pszAnswerFileName);
            }
            else
            {
                hr = pObj->InitRepairMode();
            }

            if (S_OK == hr)
            {
                CBindingAction::m_pnii = pObj;
                *ppObj = pObj;
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::~CNetInstallInfo
//
// Purpose:   destructor for class CNetInstallInfo
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetInstallInfo::~CNetInstallInfo()
{
    TraceFileFunc(ttidGuiModeSetup);

    if (IsValidHandle(m_hinfAnswerFile))
    {
        SetupCloseInfFile (m_hinfAnswerFile);
    }

    delete m_pnaiAdaptersPage;
    delete m_pnpiProtocolsPage;
    delete m_pnsiServicesPage;
    delete m_pnciClientsPage;
    delete m_pnbiBindingsPage;

    if ( m_pwifAnswerFile )
    {
        delete m_pwifAnswerFile;
    }

    delete g_elAnswerFileErrors;
    g_elAnswerFileErrors = NULL;
}

HRESULT CNetInstallInfo::InitRepairMode (VOID)
{
    m_fProcessPageSections = FALSE;
    m_fInstallDefaultComponents = FALSE;
    m_fUpgrade = TRUE;
    HrGetProductInfo( &m_dwUpgradeFlag, &m_dwBuildNumber );
    m_nui.From.ProductType = m_nui.To.ProductType = MapProductFlagToProductType( m_dwUpgradeFlag );
    m_nui.From.dwBuildNumber = m_nui.To.dwBuildNumber = m_dwBuildNumber;
    m_dwUpgradeFlag |= NSF_PRIMARYINSTALL;

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::HrInitFromAnswerFile
//
// Purpose:   Initialize internal data by reading answer-file
//
// Arguments:
//    pwifAnswerFile [in] pointer to answer-file
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetInstallInfo::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetInstallInfo::HrInitFromAnswerFile(CWInfFile*)");

    TraceFunctionEntry(ttidNetSetup);

    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr, hrReturn=S_OK;
    tstring strUpgradeFromProduct;
    DWORD dwUpgradeFromProduct = 0;

    m_pwifAnswerFile = pwifAnswerFile;

    //Find upgrade info:
    CWInfSection* pwisNetworking;
    pwisNetworking = pwifAnswerFile->FindSection(c_szAfSectionNetworking);
    if (!pwisNetworking)
    {
        ShowProgressMessage(L"[%s] section is missing",
                            c_szAfSectionNetworking);
        hrReturn = NETSETUP_E_NO_ANSWERFILE;
        goto return_from_function;
    }

    // ProcessPageSections
    m_fProcessPageSections =
        pwisNetworking->GetBoolValue(c_szAfProcessPageSections, TRUE);

    //UpgradeFromProduct
    strUpgradeFromProduct =
        pwisNetworking->GetStringValue(c_szAfUpgradeFromProduct, c_szEmpty);

    if (strUpgradeFromProduct.empty())
    {
        // UpgradeFromProduct is missing, implies not an upgrade
        m_fUpgrade = FALSE;

        m_fInstallDefaultComponents = TRUE;
//            pwisNetworking->GetBoolValue(c_szAfInstallDefaultComponents, FALSE);
    }
    else
    {
        dwUpgradeFromProduct = MapToUpgradeFlag(strUpgradeFromProduct.c_str());
        m_dwUpgradeFlag |= dwUpgradeFromProduct;

        if (!dwUpgradeFromProduct)
        {
            AddAnswerFileError(c_szAfSectionNetworking,
                               c_szAfUpgradeFromProduct,
                               IDS_E_AF_InvalidValueForThisKey);
            hrReturn = NETSETUP_E_ANS_FILE_ERROR;
            goto return_from_function;
        }
        else
        {
            m_fUpgrade = TRUE;
        }
    }

    // installing using an answerfile is ALWAYS a primary-install
    //
    m_dwUpgradeFlag |= NSF_PRIMARYINSTALL;

    //BuildNumber
    DWORD dwDummy;
    dwDummy = 0;
    m_dwBuildNumber = pwisNetworking->GetIntValue(c_szAfBuildNumber, dwDummy);
    if (m_fUpgrade && !m_dwBuildNumber)
    {
        AddAnswerFileError(c_szAfSectionNetworking,
                           c_szAfBuildNumber,
                           IDS_E_AF_InvalidValueForThisKey);
        hrReturn = NETSETUP_E_ANS_FILE_ERROR;
    }

    m_nui.From.ProductType = MapProductFlagToProductType(dwUpgradeFromProduct);
    m_nui.From.dwBuildNumber = m_dwBuildNumber;

    m_nui.To = GetCurrentProductInfo();

    // the following two keys are currently unsupported
    //
    pwisNetworking->GetStringListValue(c_szAfNetComponentsToRemove,
                                       m_slNetComponentsToRemove);

    if (!m_fProcessPageSections)
    {
        // we are upgrading from NT5
        // no other sections need to be parsed
        TraceTag(ttidNetSetup, "%s: %S is FALSE, did not process page sections",
                 __FUNCNAME__, c_szAfProcessPageSections);
        return hrReturn;
    }

    hr = m_pnaiAdaptersPage->HrInitFromAnswerFile(pwifAnswerFile);
    if (FAILED(hr))
    {
        hrReturn = hr;
    }

    // HrInitFromAnswerFile returns FALSE if [NetProtocols] is missing
    hr = m_pnpiProtocolsPage->HrInitFromAnswerFile(pwifAnswerFile);
    if ((S_FALSE == hr) && m_fInstallDefaultComponents)
    {
        // the section is missing, initialize so that
        // default components will be installed
        ShowProgressMessage(L"Since InstallDefaultComponents is specified "
                            L" and the section [%s] is missing, default "
                            L"components for this section will be installed",
                            c_szAfSectionNetProtocols);
        hr = m_pnpiProtocolsPage->HrInitForDefaultComponents();
    }

    if (FAILED(hr))
    {
        hrReturn = hr;
    }

    // HrInitFromAnswerFile returns FALSE if [NetServices] is missing
    hr = m_pnsiServicesPage->HrInitFromAnswerFile(pwifAnswerFile);
    if ((S_FALSE == hr) && m_fInstallDefaultComponents)
    {
        // the section is missing, initialize so that
        // default components will be installed
        ShowProgressMessage(L"Since InstallDefaultComponents is specified "
                            L" and the section [%s] is missing, default "
                            L"components for this section will be installed",
                            c_szAfSectionNetServices);
        hr = m_pnsiServicesPage->HrInitForDefaultComponents();
    }

    if (FAILED(hr))
    {
        hrReturn = hr;
    }

    // HrInitFromAnswerFile returns FALSE if [NetClients] is missing
    hr = m_pnciClientsPage->HrInitFromAnswerFile(pwifAnswerFile);
    if ((S_FALSE == hr) && m_fInstallDefaultComponents)
    {
        // the section is missing, initialize so that
        // default components will be installed
        ShowProgressMessage(L"Since InstallDefaultComponents is specified "
                            L" and the section [%s] is missing,  default "
                            L"components for this section will be installed",
                            c_szAfSectionNetClients);
        hr = m_pnciClientsPage->HrInitForDefaultComponents();
    }

    if (FAILED(hr))
    {
        hrReturn = hr;
    }

    hr = m_pnbiBindingsPage->HrInitFromAnswerFile(pwifAnswerFile);
    if (FAILED(hr))
    {
        hrReturn = hr;
    }

return_from_function:
    TraceErrorOptional(__FUNCNAME__, hrReturn,
                       ((hrReturn == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) ||
                        (hrReturn == NETSETUP_E_NO_ANSWERFILE)));

    // ERROR_FILE_NOT_FOUND and NETSETUP_E_NO_ANSWERFILE are not treated
    // as error by the caller of this function since they have a defined
    // meaning in the context of initializing from answerfile.
    // However, if logged unchanged, they will be treated as errors
    // by the loggin code which will cause GUI setup to halt and display
    // setuperr.log. To avoid this, change hr to S_OK if hrReturn is
    // set to one of the above error codes.
    //
    hr = hrReturn;
    if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ||
        (NETSETUP_E_NO_ANSWERFILE == hr))
    {
        hr = S_OK;
    }
    NetSetupLogHrStatusV(hr, SzLoadIds(IDS_INIT_FROM_ANSWERFILE), hr);

    return hrReturn;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::HrInitFromAnswerFile
//
// Purpose:   Initialize internal data by reading answer-file
//
// Arguments:
//    pwifAnswerFile [in] name of answer-file
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetInstallInfo::HrInitFromAnswerFile(IN PCWSTR pszAnswerFileName)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetInstallInfo::HrInitFromAnswerFile(PCWSTR)");

    TraceFunctionEntry(ttidNetSetup);

    AssertValidReadPtr(pszAnswerFileName);

    HRESULT hr;

    hr = E_OUTOFMEMORY;
    m_pwifAnswerFile = new CWInfFile();

    // initialize answer file class
    if ((m_pwifAnswerFile == NULL) ||
        (m_pwifAnswerFile->Init() == FALSE))
    {
        AssertSz(FALSE,"CNetInstallInfo::HrInitFromAnswerFile - Failed to initialize CWInfFile");
        return(E_OUTOFMEMORY);
    }

    if (m_pwifAnswerFile)
    {
        BOOL fStatus = m_pwifAnswerFile->Open(pszAnswerFileName);
        if (fStatus)
        {
            hr = HrInitFromAnswerFile(m_pwifAnswerFile);

            if (S_OK == hr)
            {
                hr = HrSetupOpenInfFile(
                        pszAnswerFileName, NULL,
                        INF_STYLE_OLDNT | INF_STYLE_WIN4,
                        NULL, &m_hinfAnswerFile);
            }
        }
        else
        {
            hr = NETSETUP_E_NO_ANSWERFILE;
        }
    }

    TraceErrorOptional(__FUNCNAME__, hr,
                       (hr == NETSETUP_E_NO_ANSWERFILE));
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::AnswerFileName
//
// Purpose:
//
// Arguments: None
//
// Returns:   Name of answer-file or NULL if not yet initialized
//
// Author:    kumarp 25-November-97
//
// Notes:
//
PCWSTR CNetInstallInfo::AnswerFileName()
{
    TraceFileFunc(ttidGuiModeSetup);

    if (!m_pwifAnswerFile)
    {
        return NULL;
    }
    else
    {
        return m_pwifAnswerFile->FileName();
    }
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::HrGetInstanceGuidOfPreNT5NetCardInstance
//
// Purpose:   Find and return instance guid of a net-card whose
//            pre-nt5 instance is known
//
// Arguments:
//    szPreNT5NetCardInstance [in]  pre-nt5 instance of a net-card
//    pguid                   [out] pointer to
//
// Returns:   S_OK if found, S_FALSE if not
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetInstallInfo::HrGetInstanceGuidOfPreNT5NetCardInstance (
    IN PCWSTR szPreNT5NetCardInstance,
    OUT LPGUID pguid)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_FALSE;

    CNetAdapter* pna;

    pna = m_pnaiAdaptersPage->FindAdapterFromPreUpgradeInstance(
            szPreNT5NetCardInstance);
    if (pna)
    {
        pna->GetInstanceGuid(pguid);
        hr = S_OK;
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::Find
//
// Purpose:   Find a component using its name in answerfile
//
// Arguments:
//    pszComponentName [in]  name in answerfile, e.g. Adapter01 | MS_TCPIP
//
// Returns:   pointer to CNetComponent object found, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetInstallInfo::Find(IN PCWSTR pszComponentName) const
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszComponentName);

    CNetComponent* pnc;

    (pnc = m_pnaiAdaptersPage->Find(pszComponentName))  ||
        (pnc = m_pnpiProtocolsPage->Find(pszComponentName)) ||
        (pnc = m_pnsiServicesPage->Find(pszComponentName))  ||
        (pnc = m_pnciClientsPage->Find(pszComponentName));

    return pnc;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::FindFromInfID
//
// Purpose:   Find a component using its InfID in answerfile
//
// Arguments:
//    szInfID [in]  InfID of component
//
// Returns:   pointer to CNetComponent object found, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetInstallInfo::FindFromInfID(IN PCWSTR szInfID) const
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(szInfID);

    CNetComponent* pnc;

    (pnc = m_pnaiAdaptersPage->FindFromInfID(szInfID))  ||
        (pnc = m_pnpiProtocolsPage->FindFromInfID(szInfID)) ||
        (pnc = m_pnsiServicesPage->FindFromInfID(szInfID))  ||
        (pnc = m_pnciClientsPage->FindFromInfID(szInfID));

    return pnc;
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::FindAdapter
//
// Purpose:   Find adapter with a given net-card-address in anwerfile
//
// Arguments:
//    qwNetCardAddress [in]  net card address
//
// Returns:   pointer to CNetAdapter object found, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetInstallInfo::FindAdapter (
    IN QWORD qwNetCardAddress,
    CNetAdapter** ppNetAdapter) const
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(m_pnaiAdaptersPage);

    return m_pnaiAdaptersPage->FindAdapter(qwNetCardAddress, ppNetAdapter);
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::FindAdapter
//
// Purpose:   Find adapter with a given net-card-address in anwerfile
//
// Arguments:
//    qwNetCardAddress [in]  net card address
//
// Returns:   pointer to CNetAdapter object found, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetInstallInfo::FindAdapter (
    IN DWORD BusNumber,
    IN DWORD Address,
    CNetAdapter** ppNetAdapter) const
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(m_pnaiAdaptersPage);

    return m_pnaiAdaptersPage->FindAdapter(BusNumber, Address, ppNetAdapter);
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::FindAdapter
//
// Purpose:   Find adapter with given InfID in answerfile
//
// Arguments:
//    pszInfId [in]  InfID of an adapter
//
// Returns:   pointer to CNetAdapter object found, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetAdapter* CNetInstallInfo::FindAdapter(IN PCWSTR pszInfId) const
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(m_pnaiAdaptersPage);

    return m_pnaiAdaptersPage->FindAdapter(pszInfId);
}

// ----------------------------------------------------------------------
//
// Function:  CNetInstallInfo::HrDoUnattended
//
// Purpose:   Run answerfile section corresponding to idPage and
//            install components specified in that section
//
// Arguments:
//    hwndParent     [in]  handle of parent window
//    punk           [in]  pointer to an interface
//    idPage         [in]  indicates which section to run
//    ppdm           [out] pointer to
//    pfAllowChanges [out] pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetInstallInfo::HrDoUnattended(
    IN HWND hwndParent,
    IN IUnknown* punk,
    IN EUnattendWorkType uawType,
    OUT EPageDisplayMode* ppdm,
    OUT BOOL* pfAllowChanges)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetInstallInfo::HrDoUnattended");

    TraceFunctionEntry(ttidNetSetup);

    AssertValidWritePtr(ppdm);
    AssertValidWritePtr(pfAllowChanges);

    // set the defaults in case they are not specified in the answer-file
    *ppdm = PDM_ONLY_ON_ERROR;
    *pfAllowChanges = FALSE;

    HRESULT hr=S_OK;

    INetCfg * pnc = reinterpret_cast<INetCfg *>(punk);

    switch(uawType)
    {
    case UAW_NetAdapters:
        (void) m_pnaiAdaptersPage->HrDoOemPostUpgradeProcessing(pnc, hwndParent);
        (void) m_pnaiAdaptersPage->HrSetConnectionNames();
        break;

    case UAW_NetProtocols:
        m_pnpiProtocolsPage->GetDisplaySettings(ppdm, pfAllowChanges);
        if (m_fProcessPageSections)
        {
            hr = m_pnpiProtocolsPage->HrDoNetworkInstall(hwndParent, pnc);
        }
        else if (m_fUpgrade)
        {
            hr = m_pnpiProtocolsPage->HrDoOsUpgrade(pnc);
        }
        break;

    case UAW_NetClients:
        m_pnciClientsPage->GetDisplaySettings(ppdm, pfAllowChanges);
        if (m_fProcessPageSections)
        {
            hr = m_pnciClientsPage->HrDoNetworkInstall(hwndParent, pnc);
        }
        else if (m_fUpgrade)
        {
            hr = m_pnciClientsPage->HrDoOsUpgrade(pnc);
        }
        break;

    case UAW_NetServices:
        m_pnsiServicesPage->GetDisplaySettings(ppdm, pfAllowChanges);
        if (m_fProcessPageSections)
        {
            // we ignore the error code since we want to do other
            // things even if HrDoNetworkInstall fails
            //
            hr = m_pnsiServicesPage->HrDoNetworkInstall(hwndParent, pnc);

            // if we installed Router during upgrade, we need to call the
            // router upgrade dll to munge the registry at this point
            //
            if (m_fUpgrade)
            {
                hr = HrUpgradeRouterIfPresent(pnc, this);
                if (FAILED(hr))
                {
                    TraceError(__FUNCNAME__, hr);
                    TraceTag(ttidError, "%s: router upgrade failed, but the failure was ignored", __FUNCNAME__);
                    hr = S_OK;
                }

                hr = HrUpgradeTapiServer(m_hinfAnswerFile);
                if (S_OK != hr)
                {
                    TraceTag(ttidError, "%s: TAPI server upgrade failed, but the failure was ignored. error code: 0x%x", __FUNCNAME__, hr);
                    hr = S_OK;
                }

                if ( m_pwifAnswerFile )
                {
                    (void) HrRestoreServiceStartValuesToPreUpgradeSetting(m_pwifAnswerFile);
                }

                // RAID 332622 (jeffspr)
                //
                (void) HrRemoveEvilIntelWinsockSPs();

                // hr = HrRestoreWinsockProviderOrder(m_pwifAnswerFile);
            }
        }
        else if (m_fUpgrade)
        {
            hr = m_pnsiServicesPage->HrDoOsUpgrade(pnc);

            // RAID:NTBUG9:25950 - We need to even do this for NT5 services.
            if ( m_pwifAnswerFile )
            {
                (void) HrRestoreServiceStartValuesToPreUpgradeSetting(m_pwifAnswerFile);
            }
        }
        break;

    case UAW_NetBindings:
        if (m_fProcessPageSections)
        {
            m_pnbiBindingsPage->GetDisplaySettings(ppdm, pfAllowChanges);
            hr = m_pnbiBindingsPage->HrDoUnattended(pnc);
        }
        break;

    case UAW_RemoveNetComponents:
        hr = HrRemoveNetComponents(pnc, &m_slNetComponentsToRemove);
        break;

    default:
        AssertSz(FALSE, "HrDoUnattended: Invalid Page ID passed");
    }

    // normalize result
    //
    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ======================================================================
// class CPageDisplayCommonInfo: public functions
// ======================================================================


// ----------------------------------------------------------------------
//
// Function:  CPageDisplayCommonInfo::CPageDisplayCommonInfo
//
// Purpose:   constructor for class CPageDisplayCommonInfo
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CPageDisplayCommonInfo::CPageDisplayCommonInfo()
{
    TraceFileFunc(ttidGuiModeSetup);

    //    InitDefaults();
    m_pdmDisplay    = PDM_ONLY_ON_ERROR;
    m_fAllowChanges = TRUE;
}

// ----------------------------------------------------------------------
//
// Function:  CPageDisplayCommonInfo::HrInitFromAnswerFile
//
// Purpose:   Initialize display related keys from anwerfile
//
// Arguments:
//    pwifAnswerFile [in] pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CPageDisplayCommonInfo::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CPageDisplayCommonInfo::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr=S_OK;

    //Defaults for AnswerFile mode
    m_pdmDisplay    = PDM_ONLY_ON_ERROR;
    m_fAllowChanges = TRUE;

    //Display
    PCWSTR pszDisplayMode;
    pszDisplayMode  = GetDisplayModeStr(m_pdmDisplay);
    pszDisplayMode  = pwifAnswerFile->GetStringValue(c_szAfDisplay, pszDisplayMode);
    m_pdmDisplay    = MapToDisplayMode(pszDisplayMode);
    if (m_pdmDisplay == PDM_UNKNOWN)
    {
        AddAnswerFileError(pwifAnswerFile->CurrentReadSection()->Name(),
                           c_szAfDisplay,
                           IDS_E_AF_InvalidValueForThisKey);
        hr = NETSETUP_E_ANS_FILE_ERROR;
    }

    //AllowChanges
    m_fAllowChanges = pwifAnswerFile->GetBoolValue(c_szAfAllowChanges,
                                                   m_fAllowChanges);

    TraceFunctionError(hr);

    return hr;
}

// ======================================================================
// class CNetComponentsPageBase
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::CNetComponentsPageBase
//
// Purpose:   constructor for class CNetComponentsPageBase
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponentsPageBase::CNetComponentsPageBase(
    IN CNetInstallInfo* pnii,
    IN const GUID* lpguidDevClass) : CPageDisplayCommonInfo()
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pnii);
    AssertValidReadPtr(lpguidDevClass);

    //InitDefaults();

    if (lpguidDevClass == &GUID_DEVCLASS_NET)
    {
        m_pszClassName = L"Network Cards";
        m_eType        = NCT_Adapter;
    }
    else if (lpguidDevClass == &GUID_DEVCLASS_NETTRANS)
    {
        m_pszClassName = L"Network Protocols";
        m_eType        = NCT_Protocol;
    }
    else if (lpguidDevClass == &GUID_DEVCLASS_NETSERVICE)
    {
        m_pszClassName = L"Network Services";
        m_eType        = NCT_Service;
    }
    else if (lpguidDevClass == &GUID_DEVCLASS_NETCLIENT)
    {
        m_pszClassName = L"Network Clients";
        m_eType        = NCT_Client;
    }
    else
    {
        m_pszClassName = L"unknown";
        m_eType        = NCT_Unknown;
    }

    m_pnii = pnii;
    m_lpguidDevClass = lpguidDevClass;
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::~CNetComponentsPageBase
//
// Purpose:   destructor for class CNetComponentsPageBase
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponentsPageBase::~CNetComponentsPageBase()
{
    TraceFileFunc(ttidGuiModeSetup);

    EraseAndDeleteAll(m_pnclComponents);
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::HrInitFromAnswerFile
//
// Purpose:   Initialize from the specified section in answerfile
//
// Arguments:
//    pwifAnswerFile [in] pointer to CWInfFile object
//    pszSectionName [in] section to initialize from
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetComponentsPageBase::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile,
                                                     IN PCWSTR    pszSectionName)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetComponentsPageBase::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);
    AssertValidReadPtr(pszSectionName);

    HRESULT hr=S_OK, hrReturn=S_OK;

    PCWInfSection pwisComponents=NULL;

    pwisComponents = pwifAnswerFile->FindSection(pszSectionName);
    if (!pwisComponents)
    {
        // not an error if the entire section is missing
        // AddAnswerFileError(pszSectionName, IDS_E_AF_Missing);
        TraceTag(ttidNetSetup, "%s: the section [%S] is missing",
                 __FUNCNAME__, pszSectionName);
        return S_FALSE;
    }

    PCWInfKey pwikComponent=NULL;
    CWInfContext cwicTemp;
    tstring strParamsSections;

    EraseAndDeleteAll(m_pnclComponents);

    do
    {
        pwikComponent = pwisComponents->NextKey();
        ContinueIf(!pwikComponent);

        strParamsSections = pwikComponent->GetStringValue(c_szEmpty);
        if (strParamsSections.empty())
        {
            AddAnswerFileError(pszSectionName, pwikComponent->Name(),
                               IDS_E_AF_InvalidValueForThisKey);
            hrReturn = NETSETUP_E_ANS_FILE_ERROR;
            continue;
        }

        CNetComponent *pnc = GetNewComponent(pwikComponent->Name());
        ReturnErrorIf(!pnc, E_OUTOFMEMORY);

        // pnc->HrInitFromAnswerFile() destroys our context, need to save it
        cwicTemp = pwifAnswerFile->CurrentReadContext();
        hr = pnc->HrInitFromAnswerFile(pwifAnswerFile, strParamsSections.c_str());
        // now, restore the read context
        pwifAnswerFile->SetReadContext(cwicTemp);

        if (FAILED(hr))
        {
            ShowProgressMessage(L"component %s has answerfile errors, "
                                L"it will not be installed/updated",
                                pwikComponent->Name());
            delete pnc;
            hrReturn = hr;
            continue;
        }

        m_pnclComponents.insert(m_pnclComponents.end(), pnc);
    }
    while (pwikComponent);

    if (E_OUTOFMEMORY != hrReturn)
    {
        // we do not want to break upgrade if a single component has answerfile errors
        // only in case E_OUTOFMEMORY we want the upgrade to fail
        hrReturn = S_OK;
    }

    TraceErrorOptional(__FUNCNAME__, hrReturn, (S_FALSE == hr));

    return hrReturn;
}

// type of PFN_EDC_CALLBACK
VOID
CALLBACK
DefaultComponentCallback (
    IN EDC_CALLBACK_MESSAGE Message,
    IN ULONG_PTR MessageData,
    IN PVOID pvCallerData OPTIONAL)
{
    TraceFileFunc(ttidGuiModeSetup);

    CNetComponentsPageBase* pCallbackData;

    pCallbackData = (CNetComponentsPageBase*)pvCallerData;

    Assert (pCallbackData);

    if (EDC_INDICATE_COUNT == Message)
    {
    }
    else if (EDC_INDICATE_ENTRY == Message)
    {
        const EDC_ENTRY* pEntry = (const EDC_ENTRY*)MessageData;

        if (*pEntry->pguidDevClass == *pCallbackData->m_lpguidDevClass)
        {
            CNetComponent* pnc;

            pnc = pCallbackData->GetNewComponent(pEntry->pszInfId);
            if (pnc)
            {
                ShowProgressMessage(L"adding default component: %s",
                                    pEntry->pszInfId);
                pnc->m_strParamsSections = c_szAfNone;
                pCallbackData->m_pnclComponents.push_back(pnc);
            }
        }
    }
}


// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::HrInitForComponents
//
// Purpose:   Initialize data as if the components passed in the specified
//            array were really present in the answerfile.
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:     This function is used when a top level component section
//            is missing. e.g. if [NetProtocols] section is missing, this
//            function initializes the internal data such that
//            MS_TCPIP (the default protocol) gets installed.
//
HRESULT CNetComponentsPageBase::HrInitForDefaultComponents()
{
    TraceFileFunc(ttidGuiModeSetup);

    EnumDefaultComponents (
        EDC_DEFAULT,
        DefaultComponentCallback,
        this);

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::Find
//
// Purpose:   Find the component with the specified name
//
// Arguments:
//    pszComponentName [in]  name of component to find
//
// Returns:   pointer to CNetComponent object found or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetComponentsPageBase::Find(IN PCWSTR pszComponentName) const
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszComponentName);

    CNetComponent *pnc = NULL;

    TPtrListIter pos;
    pos = m_pnclComponents.begin();
    while (pos != m_pnclComponents.end())
    {
        pnc = (CNetComponent*) *pos++;
        if (!lstrcmpiW(pnc->Name().c_str(), pszComponentName))
        {
            return pnc;
        }
    }

    return NULL;
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::FindFromInfID
//
// Purpose:   Find the component with the specified InfID
//
// Arguments:
//    szInfID [in]
//
// Returns:   pointer to CNetComponent object or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetComponentsPageBase::FindFromInfID(IN PCWSTR szInfID) const
{
    TraceFileFunc(ttidGuiModeSetup);

    return FindComponentInList(
            const_cast<CNetComponentList*>(&m_pnclComponents),
            szInfID);
}


// ----------------------------------------------------------------------
//
// Function:  ForceDeleteFile
//
// Purpose:   Delete file whether it is readonly or not
//
// Arguments:
//    lpFileName [in]
//
// Returns:   TRUE for success, FALSE for failure
//
// Notes:
//
BOOL
ForceDeleteFile(IN LPCWSTR lpFileName)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(lpFileName);

    BOOL lRet = DeleteFile(lpFileName);

    if (!lRet && (ERROR_ACCESS_DENIED == GetLastError()))
    {
        // kill the readonly bit, and try again
        //
        DWORD dwAttr = GetFileAttributes(lpFileName);
        SetFileAttributes(lpFileName, (dwAttr & ~FILE_ATTRIBUTE_READONLY));

        lRet = DeleteFile(lpFileName);
    }

    return lRet;
}

#if 0
// ----------------------------------------------------------------------
//
// Function:  HrCopyNovellInf
//
// Purpose:   Copies the Novell Client32's INF (iwclient.inf) so that setup will
//            find it in the INF directory when we try to upgrade the client.
//            Currently there is no other way to upgrade non-netclass OEM components
//            on NT5->NT5 upgrades.
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Special case code that should be folded into a more generic solution
//            as other users for this are found.
//

HRESULT
HrCopyNovellInf(INetCfgComponent* pINetCfgComponent)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;
    tstring strTemp;
    tstring strNewNovellInfName;

    DefineFunctionName("HrCopyNovellInf");

    TraceFunctionEntry(ttidNetSetup);

    AssertValidReadPtr(pINetCfgComponent);

    // get the windir location
    //
    WCHAR szWindowsDir[MAX_PATH+1];

    TraceTag(ttidNetSetup, "%s: about to get windows dir", __FUNCNAME__);

    if (GetWindowsDirectory(szWindowsDir, MAX_PATH))
    {
        tstring strTemp;

        //
        //  old Novell INFs used to copy themselves as part of their install.
        //  This is unnecessary, and will confuse setup when it grouts around
        //  for INFs.  Delete this file.
        //
        strTemp = szWindowsDir;
        strTemp += L"\\inf\\iwclient.inf";
        TraceTag(ttidNetSetup, "%s: deleting old Novell INF file (%S)",
                 __FUNCNAME__, strTemp.c_str());
        if (!ForceDeleteFile (strTemp.c_str()))
        {
            TraceTag(ttidNetSetup, "%s: old iwclient.inf not found", __FUNCNAME__);
        }
        else
        {
            TraceTag(ttidNetSetup, "%s: old iwclient.inf found and deleted", __FUNCNAME__);
        }
        strTemp = szWindowsDir;
        strTemp += L"\\inf\\iwclient.Pnf";
        ForceDeleteFile(strTemp.c_str());

        //
        //  copy in the new INF file, and remember the destination name.
        //
        if (S_OK == hr)
        {
            static const WCHAR c_szNovellSubDir[] = L"\\netsetup\\novell";
            static const WCHAR c_szNovellInfFile[] = L"\\iwclient.inf";

            tstring strDir = szWindowsDir;
            strDir += c_szNovellSubDir;

            strTemp = szWindowsDir;
            strTemp += c_szNovellSubDir;
            strTemp += c_szNovellInfFile;

            TraceTag(ttidNetSetup, "%s: Copying new Novell INF", __FUNCNAME__, strTemp.c_str());

            hr = HrSetupCopyOemInf(strTemp, strDir, SPOST_PATH, 0, NULL, &strNewNovellInfName);
            if (S_OK == hr)
            {
                TraceTag(ttidNetSetup, "%s: New Novell INF copied", __FUNCNAME__);
            }
        }

        //
        //  There may be duplicate INF(s) for nw_nwfs remaining in the INF dir.
        //  Find and delete them all, making sure we *don't* delete the one we just copied.
        //
        TStringList     lstrNovellInfs;
        HINF            hinf;
        INFCONTEXT      ic;
        HANDLE          hfile;
        WIN32_FIND_DATA FindData;
        WCHAR           szTemplate[MAX_PATH+1];

        wcscpy(szTemplate, szWindowsDir);
        wcscat(szTemplate, L"\\inf\\oem*.inf");

        hfile = FindFirstFile(szTemplate, &FindData);

        while (INVALID_HANDLE_VALUE != hfile)
        {
            // if it's the file we just copied, skip it.
            if (0 == lstrcmpiW(FindData.cFileName, strNewNovellInfName.c_str()))
                goto loopcleanup;

            // try it
            hr = HrSetupOpenInfFile(FindData.cFileName, NULL, INF_STYLE_WIN4,
                                    NULL, &hinf);
            if (S_OK == hr)
            {
                // look in a section titled [Novell]...
                //
                hr = HrSetupFindFirstLine(hinf, L"Novell", NULL, &ic);
                if (S_OK == hr)
                {
                    WCHAR   szBuf[LINE_LEN];    // LINE_LEN defined in setupapi.h as 256
                    do
                    {
                        // ... for a line that looks like "... = ... , nw_nwfs".
                        //
                        hr = HrSetupGetStringField(ic, 2, szBuf,
                                                   celems(szBuf), NULL);
                        if ((S_OK == hr) && !lstrcmpiW(szBuf, L"nw_nwfs"))
                        {
                            // another old INF file for Novell Client32!
                            TraceTag(ttidNetSetup, "%s: found dup INF for nw_nwfs (%S)",
                                     __FUNCNAME__, FindData.cFileName);

                            // add to list for later deletion
                            NC_TRY
                            {
                                lstrNovellInfs.push_back(new tstring(FindData.cFileName));
                            }
                            NC_CATCH_ALL
                            {
                                hr = E_OUTOFMEMORY;
                                break;
                            }

                            // generate the PNF name and add that too.
                            //
                            if (S_OK == hr)
                            {
                                WCHAR szPNF[MAX_PATH+1];

                                wcscpy(szPNF, FindData.cFileName);
                                szPNF[wcslen(szPNF) - 3] = L'p';

                                NC_TRY
                                {
                                    lstrNovellInfs.push_back(new tstring(szPNF));
                                }
                                NC_CATCH_ALL
                                {
                                    hr = E_OUTOFMEMORY;
                                    break;
                                }
                            }
                        }
                    }
                    while (S_OK == (hr = HrSetupFindNextLine(ic, &ic)));
                }

                SetupCloseInfFile(hinf);
                if (SUCCEEDED(hr) || (HRESULT_FROM_WIN32(SPAPI_E_LINE_NOT_FOUND) == hr))
                {
                    // S_FALSE is returned when HrSetupFindNextLine can find no more lines.
                    // line_not_found indicates HrSetupFindFirstLine didn't find a Novell section.
                    hr = S_OK;
                }
            }

            if (S_OK != hr)
            {
                break;
            }

loopcleanup:
            if (!FindNextFile(hfile, &FindData))
            {
                if (ERROR_NO_MORE_FILES != GetLastError())
                {
                    hr = HrFromLastWin32Error();
                }
                // either way, end the loop
                break;
            }
        }

        if (INVALID_HANDLE_VALUE != hfile)
        {
            FindClose(hfile);
        }


        //
        //  and finally, delete the old INF and PNF.
        //
        if (S_OK == hr)
        {
            TStringListIter iterlstr;

            for (iterlstr = lstrNovellInfs.begin();
                 iterlstr != lstrNovellInfs.end();
                 iterlstr++)
            {
                tstring strInfName = szWindowsDir;
                strInfName += L"\\inf\\";
                strInfName += (*iterlstr)->c_str();

                TraceTag(ttidNetSetup, "%s: deleting %S", __FUNCNAME__, strInfName.c_str());
                if (!ForceDeleteFile (strInfName.c_str()))
                {
                    TraceTag(ttidNetSetup, "%s: strange - we just found this file,",
                                           " now it is deleted...", __FUNCNAME__);
                }
                else
                {
                    TraceTag(ttidNetSetup, "%s: Old Novell INF or PNF deleted (%S)",
                             __FUNCNAME__, strInfName.c_str());
                }
                // no errors returned for delete failures...
            }
        }

        EraseAndDeleteAll(&lstrNovellInfs);
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}
#endif

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::HrDoOsUpgrade
//
// Purpose:   call Upgrade function of each component in order to
//            upgrade it from earlier build of NT5.
//
// Arguments:
//    pnc [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
HRESULT CNetComponentsPageBase::HrDoOsUpgrade(IN INetCfg* pnc)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr;

    DefineFunctionName("CNetComponentsPageBase::HrDoOsUpgrade");

    TraceFunctionEntry(ttidNetSetup);
    AssertValidReadPtr(m_pnii);

    TraceTag(ttidNetSetup, "%s: upgrading components of class: %S",
             __FUNCNAME__, m_pszClassName);

    INetCfgInternalSetup* pInternalSetup;
    hr = pnc->QueryInterface (
                IID_INetCfgInternalSetup,
                (VOID**)&pInternalSetup);

    if (S_OK == hr)
    {
        INetCfgComponent* pINetCfgComponent;
        CIterNetCfgComponent nccIter(pnc, m_lpguidDevClass);

        while (S_OK == nccIter.HrNext(&pINetCfgComponent))
        {
            PWSTR pszInfId;

            if (FAILED(pINetCfgComponent->GetId(&pszInfId)))
            {
                ReleaseObj(pINetCfgComponent);
                continue;
            }

            TraceTag(ttidNetSetup,
                     "%s: Calling INetCfgInstaller::Update for: %S",
                         __FUNCNAME__, pszInfId);

#if 0
            // NOVELL Client32 special casing
            //
            if (!lstrcmpiW(pszInfId, L"nw_nwfs"))
            {
                hr = HrCopyNovellInf(pINetCfgComponent);

                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: Novell Client32 INF copy failed, upgrade will likely fail : hr = %08lx",
                             __FUNCNAME__, hr);
                }
            }
            // end special case
#endif

            hr = pInternalSetup->UpdateNonEnumeratedComponent (
                    pINetCfgComponent,
                    m_pnii->UpgradeFlag(),
                    m_pnii->BuildNumber());

            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: error upgrading %S: hr = %08lx",
                         __FUNCNAME__, pszInfId, hr);
            }

            NetSetupLogComponentStatus(pszInfId, SzLoadIds (IDS_UPDATING), hr);

            // we dont want to quit upgrade just because 1 component
            // failed OsUpgrade, therefore reset hr to S_OK
            hr = S_OK;

            CoTaskMemFree(pszInfId);
            ReleaseObj(pINetCfgComponent);
        }
    }

    ReleaseObj(pInternalSetup);

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::HrDoNetworkInstall
//
// Purpose:   call Install function of each component
//            in the answerfile in order to install it.
//
// Arguments:
//    hwndParent [in]  handle of parent window
//    pnc        [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetComponentsPageBase::HrDoNetworkInstall (
    IN HWND hwndParent,
    IN INetCfg* pnc)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetComponentsPageBase::HrDoNetworkInstall");

    TraceFunctionEntry(ttidNetSetup);

    AssertValidReadPtr(pnc);

    if (m_pnclComponents.size() > 0)
    {
        ShowProgressMessage(L"Installing components of class: %s",
                            m_pszClassName);
    }
    else
    {
        ShowProgressMessage(L"No components to install/update for class: %s",
                            m_pszClassName);
    }

    HRESULT hr;
    INetCfgClassSetup* pINetCfgClassSetup;

    hr = pnc->QueryNetCfgClass(m_lpguidDevClass, IID_INetCfgClassSetup,
                reinterpret_cast<void**>(&pINetCfgClassSetup));

    if (S_OK == hr)
    {
        INetCfgComponent* pINetCfgComponent;
        CNetComponentList::iterator pos;
        CNetComponent* pncTemp;
        OBO_TOKEN OboToken;

        ZeroMemory (&OboToken, sizeof(OboToken));
        OboToken.Type = OBO_USER;

        for (pos  = m_pnclComponents.begin();
             pos != m_pnclComponents.end();
             pos++)
        {
            pncTemp  = (CNetComponent*)*pos;
            Assert(pncTemp);

            PCWSTR pszInfId;
            PCWSTR pszParamsSections;

            pszInfId = pncTemp->InfID().c_str();
            pszParamsSections = pncTemp->ParamsSections().c_str();

            // cant install a component whose InfID is "Unknown"
            // the down-level upgrade DLL, dumps correct InfID
            // for only the supported components,
            // all others are dumped as "Unknown"
            //
            if (!_wcsicmp(pszInfId, c_szAfUnknown))
            {
                continue;
            }

            hr = pnc->FindComponent(pszInfId, &pINetCfgComponent);

            if (FAILED(hr))
            {
                continue;
            }
            else if (S_FALSE == hr)
            {
                // currently the SkipInstall feature is used only by
                // SNA for its peculiar upgrade requirements. This may or may
                // not become a documented feature.
                //
                if (pncTemp->m_fSkipInstall)
                {
                    TraceTag(ttidNetSetup,
                             "%s: SkipInstall is TRUE for %S --> "
                             "skipped its install",
                             __FUNCNAME__, pszInfId);
                    pINetCfgComponent = NULL;
                    hr = S_OK;
                }
                else
                {
                    // component is not installed. need to install it first
                    //
                    ShowProgressMessage(
                        L"Installing '%s' and applying "
                        L"properties in section [%s] to it... ",
                        pszInfId, pszParamsSections);

                    TraceTag(ttidNetSetup,
                             "%s: UpgradeFlag: 0x%x, BuildNumber: %d",
                             __FUNCNAME__,
                             m_pnii->UpgradeFlag(),
                             m_pnii->BuildNumber());

                    Assert (!pINetCfgComponent);

                    hr = pINetCfgClassSetup->Install(
                            pszInfId,
                            &OboToken,
                            m_pnii->UpgradeFlag(),
                            m_pnii->BuildNumber(),
                            m_pnii->AnswerFileName(),
                            pszParamsSections,
                            &pINetCfgComponent);

                    if (SUCCEEDED(hr))
                    {
                        ShowProgressMessage(L"...successfully installed %s",
                                            pszInfId);
                        GUID guid;
                        pINetCfgComponent->GetInstanceGuid(&guid);
                        pncTemp->SetInstanceGuid(&guid);
                    }
                    else
                    {
                        ShowProgressMessage(L"...error installing: %s, "
                                            L"errcode: %08lx", pszInfId, hr);

                        // Answerfile specified a non-existent INF.
                        if (SPAPI_E_NO_DRIVER_SELECTED == hr)
                        {
                            hr = S_OK;
                            continue;
                        }
                    }
                    NetSetupLogComponentStatus(pszInfId,
                            SzLoadIds (IDS_INSTALLING), hr);
                }
            }
            else // S_FALSE != hr IOW ( (SUCCEEDED(hr)) && (S_FALSE != hr) )
            {
                Assert (pINetCfgComponent);

                // Component is already installed, just call ReadAnswerFile
                // Need to query for the private component interface which
                // gives us access to the notify object.
                //
                INetCfgComponentPrivate* pComponentPrivate;
                hr = pINetCfgComponent->QueryInterface(
                        IID_INetCfgComponentPrivate,
                        reinterpret_cast<void**>(&pComponentPrivate));

                if (S_OK == hr)
                {
                    INetCfgComponentSetup* pINetCfgComponentSetup;

                    // Query the notify object for its setup interface.
                    // If it doesn't support it, that's okay, we can continue.
                    //
                    hr = pComponentPrivate->QueryNotifyObject(
                            IID_INetCfgComponentSetup,
                            (void**) &pINetCfgComponentSetup);
                    if (S_OK == hr)
                    {
                        ShowProgressMessage(L"Applying properties in section [%s] to component: %s",
                                            pszParamsSections,
                                            pszInfId);

                        hr = pINetCfgComponentSetup->ReadAnswerFile(
                                m_pnii->AnswerFileName(),
                                pszParamsSections);

                        ReleaseObj(pINetCfgComponentSetup);

                        if (SUCCEEDED(hr))
                        {
                            if (S_OK == hr)
                            {
                                hr = pComponentPrivate->SetDirty();
                            }
                            ShowProgressMessage(L"...successfully applied properties to %s",
                                                pszInfId);
                        }
                        else
                        {
                            ShowProgressMessage(L"...error applying properties to: %s, "
                                                L"errcode: %08lx",
                                                pszInfId, hr);
                        }

                        NetSetupLogComponentStatus(pszInfId,
                                                   SzLoadIds (IDS_CONFIGURING), hr);
                    }
                    else if (E_NOINTERFACE == hr)
                    {
                        hr = S_OK;
                    }

                    ReleaseObj (pComponentPrivate);
                }
            }

            if (S_OK == hr)
            {
                // If required, run OEM INF against the Params key
                // of the component that we just installed
                //
                if (pncTemp->m_fIsOemComponent)
                {
                    HKEY hkeyParams;

                    // currently the SkipInstall feature is used only by
                    // SNA for its peculiar upgrade requirements. This may or may
                    // not become a documented feature.
                    //
                    if (pncTemp->m_fSkipInstall)
                    {
                        hkeyParams = NULL;
                    }
                    else
                    {
                        hr = pINetCfgComponent->OpenParamKey(&hkeyParams);
                    }

                    // if specified, run OEM INF section to patch
                    // the component Params key
                    //
                    if ((S_OK == hr) &&
                        !pncTemp->m_strInfToRunAfterInstall.empty())
                    {
                        TraceTag(ttidNetSetup,
                                 "%s: running InfToRunAfterInstall for %S, "
                                 "INF: %S, section: %S",
                                 __FUNCNAME__, pszInfId,
                                 pncTemp->m_strInfToRunAfterInstall.c_str(),
                                 pncTemp->m_strSectionToRunAfterInstall.c_str());

                        hr = HrInstallFromInfSectionInFile(
                                hwndParent,
                                pncTemp->m_strInfToRunAfterInstall.c_str(),
                                pncTemp->m_strSectionToRunAfterInstall.c_str(),
                                hkeyParams, TRUE);
                        if (S_OK != hr)
                        {
                            TraceTag(ttidNetSetup, "%s: error applying OEM INF for %S, "
                                     "INF: %S, section: %S",
                                     __FUNCNAME__, pszInfId,
                                     pncTemp->m_strInfToRunAfterInstall.c_str(),
                                     pncTemp->m_strSectionToRunAfterInstall.c_str());
                        }

                        NetSetupLogComponentStatus(pszInfId,
                                 SzLoadIds (IDS_APPLY_INFTORUN), hr);
                    }

                    // If specified, load OEM DLL and call migration function
                    //
                    if ((S_OK == hr) &&
                        !pncTemp->m_strOemDll.empty())
                    {
                        hr = HrProcessOemComponent(
                                hwndParent,
                                pncTemp->m_strOemDir.c_str(),
                                pncTemp->m_strOemDll.c_str(),
                                &m_pnii->m_nui,
                                hkeyParams,
                                pncTemp->m_strInfID.c_str(),
                                pncTemp->m_strInfID.c_str(),
                                m_pnii->m_hinfAnswerFile,
                                pncTemp->m_strParamsSections.c_str());
                        NetSetupLogComponentStatus(pszInfId,
                               SzLoadIds (IDS_PROCESSING_OEM), hr);
                    }
                    RegSafeCloseKey(hkeyParams);
                }
            }

            ReleaseObj(pINetCfgComponent);
        }

        ReleaseObj(pINetCfgClassSetup);

        pnc->Apply();
    }

    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);
    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  CNetComponentsPageBase::HrValidate
//
// Purpose:   Validate data read from the answerfile
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetComponentsPageBase::HrValidate() const
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetComponentsPageBase::HrValidate");

    HRESULT hr = E_FAIL;

    TPtrListIter pos;
    CNetComponent* pnc;

    pos = m_pnclComponents.begin();
    while (pos != m_pnclComponents.end())
    {
        pnc = (CNetComponent *) *pos++;
        hr = pnc->HrValidate();
        ReturnHrIfFailed(hr);
    }

    TraceFunctionError(hr);

    return hr;
}

// ======================================================================
// class CNetAdaptersPage
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::CNetAdaptersPage
//
// Purpose:   constructor for class CNetAdaptersPage
//
// Arguments:
//    pnii [in]  pointer to CNetInstallInfo object
//
// Returns:
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetAdaptersPage::CNetAdaptersPage(IN CNetInstallInfo* pnii)
    : CNetComponentsPageBase(pnii, &GUID_DEVCLASS_NET)
{
    TraceFileFunc(ttidGuiModeSetup);

}


// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::HrInitFromAnswerFile
//
// Purpose:   Initialize from [NetAdapters] section in the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetAdaptersPage::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdaptersPage::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;

    hr = CNetComponentsPageBase::HrInitFromAnswerFile(pwifAnswerFile,
                                                      c_szAfSectionNetAdapters);
    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::FindAdapter
//
// Purpose:   Find adapter with a given net-card-address in anwerfile
//
// Arguments:
//    qwNetCardAddress [in]   net card address
//
// Returns:   pointer to CNetAdapter object
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetAdaptersPage::FindAdapter(
    IN QWORD qwNetCardAddress,
    OUT CNetAdapter** ppNetAdapter) const
{
    TraceFileFunc(ttidGuiModeSetup);

    CNetAdapter* pna;
    HRESULT hr;
    TPtrListIter pos;

    Assert(ppNetAdapter);

    hr = NETSETUP_E_NO_EXACT_MATCH;

    pos = m_pnclComponents.begin();
    while (pos != m_pnclComponents.end())
    {
        pna = (CNetAdapter*) *pos++;
        if (pna->NetCardAddr() == qwNetCardAddress)
        {
            *ppNetAdapter = pna;
            hr = S_OK;
            break;
        }
        else if (0 == pna->NetCardAddr())
        {
            hr = NETSETUP_E_AMBIGUOUS_MATCH;
        }
    }

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::FindAdapter
//
// Purpose:   Find adapter with a given net-card-address in anwerfile
//
// Arguments:
//    qwNetCardAddress [in]   net card address
//
// Returns:   pointer to CNetAdapter object
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetAdaptersPage::FindAdapter(
    IN DWORD BusNumber,
    IN DWORD Address,
    OUT CNetAdapter** ppNetAdapter) const
{
    TraceFileFunc(ttidGuiModeSetup);

    CNetAdapter* pna;
    HRESULT hr;
    TPtrListIter pos;

    Assert(ppNetAdapter);

    hr = NETSETUP_E_NO_EXACT_MATCH;

    pos = m_pnclComponents.begin();
    while (pos != m_pnclComponents.end())
    {
        pna = (CNetAdapter*) *pos++;

        // Only check sections that did not specify a MAC address and
        // did specify PCI location info.
        //
        if ((0 == pna->NetCardAddr()) && pna->FPciInfoSpecified())
        {
            if ((pna->PciBusNumber() == BusNumber) &&
                (pna->PciAddress() == Address))
            {
                *ppNetAdapter = pna;
                hr = S_OK;
                break;
            }
        }
        else
        {
            hr = NETSETUP_E_AMBIGUOUS_MATCH;
        }
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::FindAdapter
//
// Purpose:   Find adapter with the given InfID
//
// Arguments:
//    szInfID [in] InfID of the adapter to be located
//
// Returns:   pointer to CNetAdapter object, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetAdapter* CNetAdaptersPage::FindAdapter(IN PCWSTR szInfID) const
{
    TraceFileFunc(ttidGuiModeSetup);

    return (CNetAdapter*) FindComponentInList(
                const_cast<CNetComponentList*>(&m_pnclComponents),
                szInfID);
}

// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::FindAdapterFromPreUpgradeInstance
//
// Purpose:   Find adapter with the given pre-upgrade instance
//
// Arguments:
//    szPreUpgradeInstance [in]
//
// Returns:   pointer to CNetAdapter object
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetAdapter* CNetAdaptersPage::FindAdapterFromPreUpgradeInstance(IN PCWSTR szPreUpgradeInstance)
{
    CNetAdapter* pna;

    TPtrListIter pos;
    pos = m_pnclComponents.begin();
    while (pos != m_pnclComponents.end())
    {
        pna = (CNetAdapter*) *pos++;
        if (!lstrcmpiW(pna->PreUpgradeInstance(), szPreUpgradeInstance))
        {
            return pna;
        }
    }

    return NULL;
}

// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::GetNumCompatibleAdapters
//
// Purpose:   Find the total number of adapters in the answerfile that
//            are compatible with the given list of adapters
//
// Arguments:
//    mszInfID [in] list of adapters as a multi-sz
//
// Returns:   number of such adapters found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
DWORD CNetAdaptersPage::GetNumCompatibleAdapters(IN PCWSTR mszInfID) const
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdaptersPage::GetNumCompatibleAdapters");

    if ((NULL == mszInfID) || (0 == *mszInfID))
    {
        return 0;
    }

    CNetAdapter* pna;

    TPtrListIter pos;
    pos = m_pnclComponents.begin();
    DWORD dwNumAdapters=0;
    PCWSTR szInfId;

    while (pos != m_pnclComponents.end())
    {
        pna = (CNetAdapter*) *pos++;

        if ((0 == pna->NetCardAddr()) && !pna->FPciInfoSpecified())
        {
            szInfId = pna->InfID().c_str();
            if (0 == lstrcmpiW(szInfId, c_szAfInfIdWildCard))
            {

                TraceTag(ttidNetSetup, "%s: InfID=%S matches %S",
                         __FUNCNAME__, c_szAfInfIdWildCard, mszInfID);
                dwNumAdapters++;
            }
            else if (FIsSzInMultiSzSafe(szInfId, mszInfID))
            {
                dwNumAdapters++;
            }
        }
    }

    return dwNumAdapters;
}


// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::FindCompatibleAdapter
//
// Purpose:   Find an adapter in the answerfile that
//            is compatible with the given list of adapters
//
// Arguments:
//    mszInfIDs [in]   list of adapters as a multi-sz
//
// Returns:   pointer to CNetAdapter object, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetAdapter* CNetAdaptersPage::FindCompatibleAdapter(IN PCWSTR mszInfIDs) const
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdaptersPage::FindCompatibleAdapter");


    CNetAdapter* pna;

    TPtrListIter pos;
    pos = m_pnclComponents.begin();
    PCWSTR szInfId;

    while (pos != m_pnclComponents.end())
    {
        pna = (CNetAdapter*) *pos++;

        // Only compare with those sections that did not specify an ethernet
        // address or PCI location info.
        //
        if ((0 == pna->NetCardAddr()) && !pna->FPciInfoSpecified())
        {
            szInfId = pna->InfID().c_str();

            if (0 == lstrcmpiW(szInfId, c_szAfInfIdWildCard))
            {
                TraceTag(ttidNetSetup, "%s: InfID=%S matched to %S",
                         __FUNCNAME__, c_szAfInfIdWildCard, mszInfIDs);
                return pna;
            }
            else if (FIsSzInMultiSzSafe(szInfId, mszInfIDs))
            {
                return pna;
            }
        }
    }

    return NULL;
}

// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::HrResolveNetAdapters
//
// Purpose:   Enumerate over installed adapters and determine which
//            installed adapter corresponds to which adapter specified in
//            the answerfile.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-December-97
//
// Notes:
//
HRESULT CNetAdaptersPage::HrResolveNetAdapters(IN INetCfg* pnc)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdaptersPage::HrResolveNetAdapters");

    HRESULT hr=S_OK;

    AssertValidReadPtr(m_pnii);
    AssertValidReadPtr(m_pnii->AnswerFile());

    CWInfSection* pwisNetAdapters;
    pwisNetAdapters =
        m_pnii->AnswerFile()->FindSection(c_szAfSectionNetAdapters);

    if (!pwisNetAdapters)
    {
        TraceTag(ttidNetSetup, "%s: not resolving adapters, since section [%S]"
                 " is missing",
                 __FUNCNAME__, c_szAfSectionNetAdapters);
        return S_OK;
    }

    INetCfgComponent* pINetCfgComponent;
    GUID guid;
    PWSTR pszInfId;
    PWSTR pmszInfIDs = NULL;
    CNetAdapter* pna;
    WORD cNumAdapters;
    WCHAR szServiceInstance[_MAX_PATH];
    DWORD dwcc;                 // component characteristics

    ShowProgressMessage(L"Matching installed adapters to the ones "
                        L"specified in the answerfile...");

    CIterNetCfgComponent nccIter(pnc, m_lpguidDevClass);

    while ((S_OK == hr) && (S_OK == (hr = nccIter.HrNext(&pINetCfgComponent))))
    {
        hr = pINetCfgComponent->GetId(&pszInfId);

        if (S_OK == hr)
        {
            hr = pINetCfgComponent->GetCharacteristics(&dwcc);

            if (S_OK == hr)
            {
                if (dwcc & NCF_PHYSICAL)
                {
                    ShowProgressMessage(L"Trying to resolve adapter '%s'...", pszInfId);


                    // the defs of HIDWORD and LODWORD are wrong in byteorder.hxx

#   define LODWORD(a) (DWORD)( (a) & ( (DWORD)~0 ))
#   define HIDWORD(a) (DWORD)( (a) >> (sizeof(DWORD)*8) )

                    // since we have more than one adapters of the same type
                    // we need to compare their netcard address in order to find a match
                    QWORD qwNetCardAddr=0;
                    PWSTR pszBindName;

                    hr = pINetCfgComponent->GetBindName (&pszBindName);
                    if (S_OK == hr)
                    {
                        wcscpy (szServiceInstance, c_szDevice);
                        wcscat (szServiceInstance, pszBindName);
                        hr = HrGetNetCardAddr(szServiceInstance,
                                &qwNetCardAddr);

                        if (S_OK == hr)
                        {
                            // there is a bug in wvsprintfA (used in trace.cpp)
                            // because of which it does not handle %I64x
                            // therefore we need to show the QWORD addr as follows
                            //
                            ShowProgressMessage(
                                    L"\t... net card address of %s is 0x%x%x",
                                    szServiceInstance, HIDWORD(qwNetCardAddr),
                                    LODWORD(qwNetCardAddr));

                            hr = FindAdapter(qwNetCardAddr, &pna);
                            if (NETSETUP_E_NO_EXACT_MATCH == hr)
                            {
                                ShowProgressMessage(
                                        L"\t... there is no card with this "
                                        L"netcard address in the answerfile");
                                hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                            }
                        }
                        else
                        {
                            ShowProgressMessage(
                                    L"\t... unable to find netcard addr of %s",
                                    pszInfId);
                        }
                        CoTaskMemFree (pszBindName);
                    }

                    hr = HrGetCompatibleIdsOfNetComponent(pINetCfgComponent,
                                                          &pmszInfIDs);
                    if (FAILED(hr))
                    {
                        hr = E_OUTOFMEMORY;
                        // make this single InfID into a msz
                        //
                        UINT cchInfId = wcslen (pszInfId);
                        pmszInfIDs = (PWSTR)MemAlloc ((cchInfId + 2) *
                                sizeof (WCHAR));

                        if (pmszInfIDs)
                        {
                            hr = S_OK;
                            wcscpy (pmszInfIDs, pszInfId);
                            pmszInfIDs[cchInfId + 1] = '\0';
                        }
                    }

                    if (S_OK == hr)
                    {
                        cNumAdapters=0;
                        pna = NULL;
                        cNumAdapters = GetNumCompatibleAdapters(pmszInfIDs);

                        if (cNumAdapters == 1)
                        {
                            // no need to match the netcard address

                            pna = (CNetAdapter*) FindCompatibleAdapter(pmszInfIDs);
                            AssertValidReadPtr(pna);
                        }
                        else
                        {
                            // no matching adapters found
                            ShowProgressMessage(L"... answerfile does not have the "
                                                L"installed card %s", pszInfId);
                        }

                        if (!pna)
                        {
                            hr = NETSETUP_E_NO_EXACT_MATCH;
                        }
                        MemFree (pmszInfIDs);
                    }

                    if (S_OK == hr)
                    {
                        hr = pINetCfgComponent->GetInstanceGuid(&guid);
                        if (S_OK == hr)
                        {
                            pna->SetInstanceGuid(&guid);

                            WCHAR szGuid[c_cchGuidWithTerm];
                            StringFromGUID2(guid, szGuid, c_cchGuidWithTerm);
                            ShowProgressMessage(L"%s == %s (%s)",
                                                pna->Name().c_str(),
                                                pszInfId, szGuid);
                        }
                    }

                }
                else
                {
                    TraceTag(ttidNetSetup,
                             "%s: skipped non-physical adapter %S",
                             __FUNCNAME__, pszInfId);
                }
            }
            CoTaskMemFree(pszInfId);
        }

        ReleaseObj(pINetCfgComponent);
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrFindByInstanceGuid
//
// Purpose:   Get INetCfgComponent* from the instance GUID
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    pguidDevClass [in]  pointer to class GUID
//    pguid         [in]  pointer to instance GUID
//    ppncc         [out] pointer to INetCfgComponent* to return
//
// Returns:   S_OK on success, S_FALSE if not found,
//            otherwise an error code
//
// Author:    kumarp 10-September-98
//
// Notes:
//
HRESULT HrFindByInstanceGuid(IN  INetCfg*           pnc,
                             IN  const GUID*        pguidDevClass,
                             IN  LPGUID             pguid,
                             OUT INetCfgComponent** ppncc)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrFindByInstanceGuid");

    HRESULT hr=S_FALSE;
    CIterNetCfgComponent nccIter(pnc, pguidDevClass);
    GUID guid;
    INetCfgComponent* pINetCfgComponent;
    int cAdapter=0;

    *ppncc = NULL;

    while (S_OK == (hr = nccIter.HrNext(&pINetCfgComponent)))
    {
        hr = pINetCfgComponent->GetInstanceGuid(&guid);

        if (S_OK == hr)
        {
#ifdef ENABLETRACE
            WCHAR szGuid[c_cchGuidWithTerm];
            StringFromGUID2(guid, szGuid, c_cchGuidWithTerm);

            TraceTag(ttidNetSetup, "%s: ...%d]  %S",
                     __FUNCNAME__, ++cAdapter, szGuid);
#endif
            if (*pguid == guid)
            {
                hr = S_OK;
                *ppncc = pINetCfgComponent;
                break;
            }
        }
        ReleaseObj(pINetCfgComponent);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::HrDoOemPostUpgradeProcessing
//
// Purpose:   Call the post-upgrade functions from OEM DLL
//
// Arguments:
//    pnc        [in]  pointer to INetCfg object
//    hwndParent [in]  handle of parent window
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 10-September-98
//
// Notes:
//
HRESULT CNetAdaptersPage::HrDoOemPostUpgradeProcessing(IN INetCfg* pnc,
                                                       IN HWND hwndParent)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdaptersPage::HrDoOemPostUpgradeProcessing");

    TPtrListIter pos;

    CNetComponent* pncTemp;
    HRESULT hr=S_OK;
    PCWSTR szInfID;
    HKEY hkeyParams;
    GUID guid;
    INetCfgComponent* pncc=NULL;

    pos = m_pnclComponents.begin();

    while (pos != m_pnclComponents.end())
    {
        pncTemp  = (CNetComponent*) *pos++;
        AssertSz(pncTemp,
                 "HrDoOemPostUpgradeProcessing: pncTemp cannot be null!");

        szInfID = pncTemp->InfID().c_str();


        // cant process a component whose InfID is "Unknown"
        //
        if (!_wcsicmp(szInfID, c_szAfUnknown))
        {
            continue;
        }

        // we process only those components that specify OemDll
        //
        if (pncTemp->OemDll().empty())
        {
            continue;
        }

        Assert(!pncTemp->OemDir().empty());

        TraceTag(ttidNetSetup, "%s: processing %S (%S)...",
                 __FUNCNAME__, pncTemp->Name().c_str(), szInfID);

        pncTemp->GetInstanceGuid(&guid);
#ifdef ENABLETRACE
        WCHAR szGuid[c_cchGuidWithTerm];
        StringFromGUID2(guid, szGuid, c_cchGuidWithTerm);

        TraceTag(ttidNetSetup, "%s: ...%S == %S",
                 __FUNCNAME__, pncTemp->Name().c_str(), szGuid);
#endif
        hr = HrFindByInstanceGuid(pnc, m_lpguidDevClass,
                                  &guid, &pncc);
        if (S_OK == hr)
        {
            hr = pncc->OpenParamKey(&hkeyParams);

            if (S_OK == hr)
            {
                hr = HrProcessOemComponent(
                        hwndParent,
                        pncTemp->OemDir().c_str(),
                        pncTemp->OemDll().c_str(),
                        &m_pnii->m_nui,
                        hkeyParams,
                        szInfID,
                        szInfID,
                        m_pnii->m_hinfAnswerFile,
                        pncTemp->m_strParamsSections.c_str());
                NetSetupLogComponentStatus(szInfID,
                        SzLoadIds (IDS_PROCESSING_OEM), hr);
                RegSafeCloseKey(hkeyParams);
            }
            ReleaseObj(pncc);
        }
#ifdef ENABLETRACE
        else
        {
            TraceTag(ttidNetSetup, "%s: ...could not locate %S",
                     __FUNCNAME__, pncTemp->Name().c_str());
        }
#endif
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::HrSetConnectionNames
//
// Purpose:   Enumerate over each adapter specified in the answerfile
//            and rename the corresponding connection if
//            ConnectionName is specified for that adapter.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-September-98
//
// Notes:
//
HRESULT CNetAdaptersPage::HrSetConnectionNames()
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrSetConnectionNames");

    HRESULT hr=S_OK;
    TPtrListIter pos;
    CNetAdapter* pncTemp;
    GUID guid;
    PCWSTR szConnectionName;
    PCWSTR szAdapterName;

    pos = m_pnclComponents.begin();

    while (pos != m_pnclComponents.end())
    {
        pncTemp  = (CNetAdapter*) *pos++;
        AssertSz(pncTemp,
                 "HrSetConnectionNames: pncTemp cannot be null!");
        pncTemp->GetInstanceGuid(&guid);

        if (GUID_NULL != guid)
        {
            szAdapterName    = pncTemp->Name().c_str();
            szConnectionName = pncTemp->ConnectionName();
            if (wcslen(szConnectionName) > 0)
            {
                hr = HrSetLanConnectionName(&guid, szConnectionName);
                if (S_OK == hr)
                {
                    ShowProgressMessage(L"Name of the connection represented by '%s' set to '%s'", szAdapterName, szConnectionName);
                }
                else
                {
                    ShowProgressMessage(L"Could not set name of the connection represented by '%s' to '%s'. Error code: 0x%lx", szAdapterName, szConnectionName, hr);
                }
            }
        }
#ifdef ENABLETRACE
        else
        {
            TraceTag (ttidNetSetup, "An exact owner could not be found for section %S", pncTemp->m_strParamsSections.c_str());
        }
#endif
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  CNetAdaptersPage::GetNewComponent
//
// Purpose:   Create and return a new component suitabe for this class
//
// Arguments:
//    pszName [in]  name of component to create
//
// Returns:   pointer to CNetComponent object created
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetAdaptersPage::GetNewComponent(IN PCWSTR pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszName);

    return new CNetAdapter(pszName);
}

// ======================================================================
// class CNetProtocolsPage
// ======================================================================


// ----------------------------------------------------------------------
//
// Function:  CNetProtocolsPage::CNetProtocolsPage
//
// Purpose:   constructor for class CNetProtocolsPage
//
// Arguments:
//    pnii [in]  pointer to CNetInstallInfo object
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetProtocolsPage::CNetProtocolsPage(IN CNetInstallInfo* pnii)
    : CNetComponentsPageBase(pnii, &GUID_DEVCLASS_NETTRANS)
{
    TraceFileFunc(ttidGuiModeSetup);
}

// ----------------------------------------------------------------------
//
// Function:  CNetProtocolsPage::HrInitFromAnswerFile
//
// Purpose:   Initialize from the [NetProtocols] section in the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetProtocolsPage::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetProtocolsPage::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;

    hr = CNetComponentsPageBase::HrInitFromAnswerFile(pwifAnswerFile,
                                                      c_szAfSectionNetProtocols);

    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetProtocolsPage::GetNewComponent
//
// Purpose:   Create and return a new component suitabe for this class
//
// Arguments:
//    pszName [in]  name of
//
// Returns:   pointer to CNetComponent object
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetProtocolsPage::GetNewComponent(IN PCWSTR pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszName);

    return new CNetProtocol(pszName);
}

// ======================================================================
// class CNetServicesPage
// ======================================================================


// ----------------------------------------------------------------------
//
// Function:  CNetServicesPage::CNetServicesPage
//
// Purpose:   constructor for class CNetServicesPage
//
// Arguments:
//    pnii [in]  pointer to CNetInstallInfo object
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetServicesPage::CNetServicesPage(IN CNetInstallInfo* pnii)
    : CNetComponentsPageBase(pnii, &GUID_DEVCLASS_NETSERVICE)
{
    TraceFileFunc(ttidGuiModeSetup);

}

// ----------------------------------------------------------------------
//
// Function:  CNetServicesPage::HrInitFromAnswerFile
//
// Purpose:   Initialize from the [NetServices] section in the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetServicesPage::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetServicesPage::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;

    hr = CNetComponentsPageBase::HrInitFromAnswerFile(pwifAnswerFile,
                                                      c_szAfSectionNetServices);
    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetServicesPage::GetNewComponent
//
// Purpose:   Create and return a new component suitabe for this class
//
// Arguments:
//    pszName [in]  name of  component to be created
//
// Returns:   pointer to CNetComponent object
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetServicesPage::GetNewComponent(IN PCWSTR pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszName);

    return new CNetService(pszName);
}

// ======================================================================
// class CNetClientsPage
// ======================================================================


// ----------------------------------------------------------------------
//
// Function:  CNetClientsPage::CNetClientsPage
//
// Purpose:   constructor for class CNetClientsPage
//
// Arguments:
//    pnii [in]  pointer to CNetInstallInfo object
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetClientsPage::CNetClientsPage(IN CNetInstallInfo* pnii)
    : CNetComponentsPageBase(pnii, &GUID_DEVCLASS_NETCLIENT)
{
    TraceFileFunc(ttidGuiModeSetup);
}

// ----------------------------------------------------------------------
//
// Function:  CNetClientsPage::HrInitFromAnswerFile
//
// Purpose:   Initialize from the [NetClients] section in the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetClientsPage::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetClientsPage::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;

    hr = CNetComponentsPageBase::HrInitFromAnswerFile(pwifAnswerFile,
                                                      c_szAfSectionNetClients);
    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetClientsPage::GetNewComponent
//
// Purpose:   Create and return a new component suitabe for this class
//
// Arguments:
//    pszName [in]  name of
//
// Returns:   pointer to CNetComponent object
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* CNetClientsPage::GetNewComponent(IN PCWSTR pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszName);

    return new CNetClient(pszName);
}

// ======================================================================
// class CNetBindingsPage
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetBindingsPage::CNetBindingsPage
//
// Purpose:   constructor for class CNetBindingsPage
//
// Arguments:
//    pnii [in]  pointer to CNetInstallInfo object
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetBindingsPage::CNetBindingsPage(IN CNetInstallInfo* pnii)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pnii);
    m_pnii = pnii;
}

// ----------------------------------------------------------------------
//
// Function:  CNetBindingsPage::HrInitFromAnswerFile
//
// Purpose:   Initialize from the [NetBindings] section in the answerfile
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetBindingsPage::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetBindingsPage::HrInitFromAnswerFile");
    AssertValidReadPtr(pwifAnswerFile);

    HRESULT hr;

    PCWInfSection pwisBindings;
    pwisBindings = pwifAnswerFile->FindSection(c_szAfSectionNetBindings);
    if (!pwisBindings)
    {
        //it is not an error if the Bindings section is missing
        return S_OK;
    }

    EraseAndDeleteAll(m_plBindingActions);

    hr = E_OUTOFMEMORY;
    CBindingAction* pba = new CBindingAction();
    if (pba)
    {
        hr = S_OK;

        PCWInfKey pwikKey;

        for (pwikKey = pwisBindings->FirstKey();
             pwikKey;
             pwikKey = pwisBindings->NextKey())
        {
            HRESULT hrT = pba->HrInitFromAnswerFile(pwikKey);
            if (S_OK == hrT)
            {
                AddAtEndOfPtrList(m_plBindingActions, pba);
                pba = new CBindingAction();
                if (!pba)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
        }

        delete pba;
    }

    TraceFunctionError(hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetBindingsPage::HrDoUnattended
//
// Purpose:   Perform instrunctions specified in the [NetBindings] section
//            in the answerfile
//
// Arguments:
//    hwndParent [in]  handle of parent window
//    pnc        [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT
CNetBindingsPage::HrDoUnattended (
    IN INetCfg* pnc)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetBindingsPage::HrDoUnattended");

    HRESULT hr;

    if (m_plBindingActions.size() > 0)
    {
        ShowProgressMessage(L"Applying bindings...");
    }
    else
    {
        ShowProgressMessage(L"No binding actions to apply");
    }

    TPtrListIter pos = m_plBindingActions.begin();
    CBindingAction* pba;

    while (pos != m_plBindingActions.end())
    {
        pba = (CBindingAction*) *pos++;
        // ignore the return code so that we can try to perform
        // remaining actions
        hr = pba->HrPerformAction(pnc);
    }

    hr = pnc->Apply();

    TraceFunctionError(hr);
    return hr;
}

// ======================================================================
// class CBindingAction
// ======================================================================

CNetInstallInfo* CBindingAction::m_pnii = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   CBindingAction::CBindingAction
//
//  Purpose:    constructor
//
//  Arguments:  (none)
//
//
//  Returns:    none
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
CBindingAction::CBindingAction()
{
    TraceFileFunc(ttidGuiModeSetup);

    m_eBindingAction = BND_Unknown;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBindingAction::~CBindingAction
//
//  Purpose:    destructor
//
//  Arguments:  (none)
//
//  Returns:    none
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
CBindingAction::~CBindingAction()
{
}

//+---------------------------------------------------------------------------
//
//  Function:   MapBindingActionName
//
//  Purpose:    maps the answerfile token to appropriate binding action
//
//  Arguments:
//      pszActionName [in]  answer-file token, e.g. "Disable"
//
//  Returns:    enum for binding action, or BND_Unknown if incorrect token passed
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
EBindingAction MapBindingActionName(IN PCWSTR pszActionName)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszActionName);

    if (!_wcsicmp(c_szAfEnable, pszActionName))
        return BND_Enable;
    else if (!_wcsicmp(c_szAfDisable, pszActionName))
        return BND_Disable;
    else if (!_wcsicmp(c_szAfPromote, pszActionName))
        return BND_Promote;
    else if (!_wcsicmp(c_szAfDemote, pszActionName))
        return BND_Demote;
    else
        return BND_Unknown;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBindingAction::HrInitFromAnswerFile
//
//  Purpose:    Reads value of a single key passed as argument and initializes
//              internal data
//
//  Arguments:
//      pwikKey [in]  pointer to CWInfKey
//
//  Returns:    S_OK if success or NETSETUP_E_ANS_FILE_ERROR on failure
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
HRESULT CBindingAction::HrInitFromAnswerFile(IN const CWInfKey* pwikKey)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CBindingAction::HrInitFromAnswerFile");

    AssertValidReadPtr(pwikKey);

    HRESULT hr=E_FAIL;
    tstring strComponent;
    TStringListIter pos;

    m_eBindingAction = MapBindingActionName(pwikKey->Name());
    if (m_eBindingAction == BND_Unknown)
    {
        AddAnswerFileError(c_szAfSectionNetBindings,
                           pwikKey->Name(),
                           IDS_E_AF_InvalidBindingAction);
        hr = NETSETUP_E_ANS_FILE_ERROR;
    }
    else
    {
        BOOL fStatus;
        TStringList slComponents;
#if DBG
        m_strBindingPath = pwikKey->GetStringValue(c_szAfUnknown);
#endif
        fStatus = pwikKey->GetStringListValue(m_slBindingPath);
        DWORD cComponentsInBindingPath = m_slBindingPath.size();
        // we need binding path to have atleast 2 items
        // e.g. Disable=service1,proto1,adapter1
        // we do not process binding actions like
        // Disable=proto1,adapter1 or Disable=adapter1
        //
        if (!fStatus || (cComponentsInBindingPath < 2))
        {
            AddAnswerFileError(c_szAfSectionNetBindings,
                               pwikKey->Name(),
                               IDS_E_AF_InvalidValueForThisKey);
            hr = NETSETUP_E_ANS_FILE_ERROR;
#if DBG
            if (cComponentsInBindingPath < 2)
            {
                ShowProgressMessage(L"ignored binding path %s of length %d",
                                    m_strBindingPath.c_str(),
                                    cComponentsInBindingPath);
            }
#endif
        }
        else
        {
            hr = S_OK;
        }
    }

    TraceFunctionError(hr);

    return hr;
}

// =================================================================
// Add to common

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseINetCfgComponentsAndEraseList
//
//  Purpose:    releases INetCfgComponent pointers in the passed list
//              and then erases the list
//
//  Arguments:
//      pplComponents [in] list of INetCfgComponent pointers
//
//  Returns:    none
//
//  Author:     kumarp    05-July-97
//
//  Notes:      Does NOT free the passed list
//
void ReleaseINetCfgComponentsAndEraseList(TPtrList* pplComponents)
{
    TraceFileFunc(ttidGuiModeSetup);

    INetCfgComponent* pncc;

    TPtrListIter pos;
    pos = pplComponents->begin();
    while (pos != pplComponents->end())
    {
        pncc = (INetCfgComponent*) *pos++;
        ReleaseObj(pncc);
    }
    EraseAll(pplComponents);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetBindingPathStr
//
//  Purpose:    Gets a string representation of a given binding-path
//
//  Arguments:
//      pncbp           [in]   binding path
//      pstrBindingPath [out]  string representation of the binding path
//
//  Returns:    S_OK if success, error code returned by respective COM
//              interfaces otherwise
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
HRESULT HrGetBindingPathStr(INetCfgBindingPath *pncbp, tstring* pstrBindingPath)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetBindingPathStr");

    AssertValidReadPtr(pncbp);
    AssertValidWritePtr(pstrBindingPath);

    HRESULT                     hr=S_OK;
    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface *   pncbi;
    INetCfgComponent *          pncc = NULL;
    BOOL fFirstInterface=TRUE;
    PWSTR szInfId;

    while (SUCCEEDED(hr) && (S_OK == (hr = ncbiIter.HrNext(&pncbi))))
    {
        if (fFirstInterface)
        {
            fFirstInterface = FALSE;
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&szInfId);
                ReleaseObj(pncc);
                if (SUCCEEDED(hr))
                {
                    *pstrBindingPath = szInfId;
                    CoTaskMemFree(szInfId);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pncbi->GetLowerComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&szInfId);
                if (SUCCEEDED(hr))
                {
                    AssertSz(!fFirstInterface, "fFirstInterface should be FALSE");

                    if (!pstrBindingPath->empty())
                    {
                        *pstrBindingPath += L" -> ";
                    }
                    *pstrBindingPath += szInfId;
                    CoTaskMemFree(szInfId);
                }
                ReleaseObj(pncc);
            }
        }
        ReleaseObj(pncbi);
    }

    if (hr == S_FALSE)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   TraceBindPath
//
//  Purpose:    Traces string representation of a given binding-path using
//              the given trace id
//
//  Arguments:
//      pncbp [in]   binding path
//      ttid  [out]  trace tag id as defined in tracetag.cpp
//
//  Returns:    none
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
void TraceBindPath(INetCfgBindingPath *pncbp, TraceTagId ttid)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pncbp);

    tstring strBindingPath;
    HRESULT hr;

    hr = HrGetBindingPathStr(pncbp, &strBindingPath);

    if (SUCCEEDED(hr))
    {
        TraceTag(ttid, "Binding path = %S", strBindingPath.c_str());
    }
    else
    {
        TraceTag(ttid, "Error dumping binding path.");
    }
}
#endif

// =================================================================

//+---------------------------------------------------------------------------
//
//  Function:   HrGetINetCfgComponentOfComponentsInBindingPath
//
//  Purpose:    Finds the INetCfgComponent interface of all components in a
//              binding path.
//
//  Arguments:
//      pncbp         [in]  binding path
//      pplComponents [out] list of INetCfgComponent
//
//  Returns:    S_OK if found all, or an error code if not.
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//      Makes error handling easier since this returns either all components
//      or none.
//      The caller must release the INetCfgComponent interfaces thus obtained.
//
HRESULT HrGetINetCfgComponentOfComponentsInBindingPath(IN INetCfgBindingPath* pncbp,
                                                       OUT TPtrList* pplComponents)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetINetCfgComponentOfComponentsInBindingPath");


    AssertValidReadPtr(pncbp);
    AssertValidWritePtr(pplComponents);

    HRESULT hr=S_OK;

    CIterNetCfgBindingInterface ncbiIter(pncbp);
    INetCfgBindingInterface *   pncbi;
    INetCfgComponent *          pncc = NULL;
    BOOL                        fFirstInterface = TRUE;

    while (SUCCEEDED(hr) && (S_OK == (hr = ncbiIter.HrNext(&pncbi))))
    {
        if (fFirstInterface)
        {
            fFirstInterface = FALSE;
            hr = pncbi->GetUpperComponent(&pncc);

            if (SUCCEEDED(hr))
            {
                pplComponents->push_back(pncc);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pncbi->GetLowerComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                AssertSz(!fFirstInterface, "fFirstInterface shouldn't be TRUE");

                pplComponents->push_back(pncc);
            }
        }
        ReleaseObj(pncbi);

        if (SUCCEEDED(hr))
        {
            DWORD dwcc=0;

            hr = pncc->GetCharacteristics(&dwcc);
            if (S_OK == hr)
            {
                if (dwcc & NCF_DONTEXPOSELOWER)
                {
                    // if this component does not want to expose components
                    // below it, set hr to  end the while loop
                    //
                    hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);

#ifdef ENABLETRACE
                    PWSTR szInfId;
                    BOOL fFree = TRUE;
                    if (FAILED(pncc->GetId(&szInfId)))
                    {
                        szInfId = L"<GetId failed!>";
                        fFree = FALSE;
                    }

                    TraceTag(ttidNetSetup,
                             "%s: Component '%S' has NCF_DONTEXPOSELOWER "
                             "set. Further components will not be added to "
                             "the list of INetCfgComponent in this binding path",
                             __FUNCNAME__, szInfId);
                    if (fFree)
                    {
                        CoTaskMemFree(szInfId);
                    }
#endif
                }
            }
        }
    }

    if ((hr == S_FALSE) ||
        (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)))
    {
        hr = S_OK;
    }
    else if (FAILED(hr))
    {
        // need to release all INetCfgComponent found so far
        ReleaseINetCfgComponentsAndEraseList(pplComponents);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidOfComponents
//
//  Purpose:    Finds the instance guid of all INetCfgComponents in a list
//
//  Arguments:
//      pplINetCfgComponent [in]  list of INetCfgComponent interfaces
//      pplInstanceGuids    [out] list of instance guids
//
//  Returns:    S_OK if found all, or an error code if not.
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//      Makes error handling easier since this returns either all instance guids
//      or none.
//      The caller must free each instance guid and the list elements.
//
HRESULT HrGetInstanceGuidOfComponents(IN  TPtrList* pplINetCfgComponent,
                                      OUT TPtrList* pplInstanceGuids)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetInstanceGuidOfComponents");

    HRESULT hr = S_OK;

    TPtrListIter iter;
    INetCfgComponent* pncc;
    GUID guidComponentInstance;

    for (iter = pplINetCfgComponent->begin();
         (iter != pplINetCfgComponent->end()) && (S_OK == hr);
         iter++)
    {
        pncc = (INetCfgComponent*) *iter;
        Assert (pncc);

        hr = pncc->GetInstanceGuid(&guidComponentInstance);
        if (S_OK == hr)
        {
            GUID* pguidTemp = new GUID;
            if (pguidTemp)
            {
                *pguidTemp = guidComponentInstance;
                pplInstanceGuids->push_back(pguidTemp);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (S_OK != hr)
    {
        // need to free all instace guids found so far
        EraseAndDeleteAll(pplInstanceGuids);
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidOfComponentsInBindingPath
//
//  Purpose:    Finds the instance guid of all components in a binding path.
//
//  Arguments:
//      pncbp             [in]  binding path
//      pplComponentGuids [out] list of instance guids
//
//  Returns:    S_OK if found all, or an error code if not.
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//      Makes error handling easier since this returns either all components
//      or none.
//      The caller must free each instance guid and the list elements.
//
HRESULT HrGetInstanceGuidOfComponentsInBindingPath(IN  INetCfgBindingPath* pncbp,
                                                   OUT TPtrList* pplComponentGuids)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetInstanceGuidOfComponentsInBindingPath");

    HRESULT hr=E_FAIL;
    TPtrList plINetCfgComponent;

    hr = HrGetINetCfgComponentOfComponentsInBindingPath(pncbp, &plINetCfgComponent);
    if (SUCCEEDED(hr))
    {
        hr = HrGetInstanceGuidOfComponents(&plINetCfgComponent,
                                           pplComponentGuids);
        ReleaseINetCfgComponentsAndEraseList(&plINetCfgComponent);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidOfComponentInAnswerFile
//
//  Purpose:    Finds the instance guid of a component specified in the answerfile
//              or an already installed component
//
//  Arguments:
//      pszComponentName [in]  component id to find.
//      pguid            [out] instance guid of the component
//
//  Returns:    S_OK if found, S_FALSE if not, or an error code.
//
//  Author:     kumarp    05-July-97
//
//  Notes:      Caller must free the instance guid
//
HRESULT
HrGetInstanceGuidOfComponentInAnswerFile (
    IN INetCfg* pnc,
    IN PCWSTR pszComponentName,
    OUT LPGUID pguid)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetInstanceGuidOfComponentInAnswerFile");

    TraceFunctionEntry(ttidNetSetup);

    AssertValidReadPtr(pnc);
    AssertValidReadPtr(pszComponentName);
    AssertValidWritePtr(pguid);
    AssertValidReadPtr(g_pnii);

#if DBG
    tstring strGuid;
#endif

    HRESULT hr=E_FAIL;

    if (!g_pnii->AnswerFileInitialized())
    {
        hr = E_FAIL;
        goto return_from_function;
    }

    INetCfgComponent* pncc;

    hr = pnc->FindComponent(pszComponentName, &pncc);

    if (hr == S_OK)
    {
        hr = pncc->GetInstanceGuid(pguid);
        ReleaseObj(pncc);
    }
    else if (S_FALSE == hr)
    {
        TraceTag(ttidNetSetup, "%s: '%S' is not installed on system, "
                 "let's see if is in the answerfile",
                 __FUNCNAME__, pszComponentName);

        // couldnt find as an installed component, try to see if it is
        // in the answer-file-map
        //
        CNetComponent* pnc;
        pnc = g_pnii->Find(pszComponentName);
        if (!pnc)
        {
            hr = S_FALSE;
        }
        else
        {
            pnc->GetInstanceGuid(pguid);
            hr = S_OK;
        }
    }

#if DBG
    if (S_OK == hr)
    {
        WCHAR szGuid[c_cchGuidWithTerm];
        StringFromGUID2(*pguid, szGuid, c_cchGuidWithTerm);
        strGuid = szGuid;
    }
    else
    {
        strGuid = c_szAfUnknown;
    }
    TraceTag(ttidNetSetup, "%s: %S = %S",
             __FUNCNAME__, pszComponentName, strGuid.c_str());
#endif

    NetSetupLogComponentStatus(pszComponentName,
            SzLoadIds (IDS_GETTING_INSTANCE_GUID), hr);

return_from_function:
    TraceFunctionError((S_FALSE == hr) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetInstanceGuidOfComponentsInAnswerFile
//
//  Purpose:    Finds the instance guid of a component specified in the answerfile
//              or an already installed component
//
//  Arguments:
//      pslComponents    [in]  list of component ids to find.
//      pguid            [out] list of instance guids
//
//  Returns:    S_OK if found all, or an error code.
//
//  Author:     kumarp    05-July-97
//
//  Notes:      Caller must free the instance guids and the list items.
//
HRESULT HrGetInstanceGuidOfComponentsInAnswerFile(
    IN INetCfg* pnc,
    IN TStringList* pslComponents,
    OUT TPtrList*    pplComponentGuids)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetInstanceGuidOfComponentsInAnswerFile");

    AssertValidReadPtr(pnc);
    AssertValidReadPtr(pslComponents);
    AssertValidWritePtr(pplComponentGuids);

    HRESULT hr = S_OK;
    TStringListIter iter;
    tstring* pstr;
    GUID guidComponentInstance;

    for (iter = pslComponents->begin();
         (iter != pslComponents->end()) && (S_OK == hr);
         iter++)
    {
        pstr = *iter;

        hr = HrGetInstanceGuidOfComponentInAnswerFile(
                pnc, pstr->c_str(), &guidComponentInstance);
        if (hr == S_OK)
        {
            GUID* pguidTemp = new GUID;
            if (pguidTemp)
            {
                *pguidTemp = guidComponentInstance;
                pplComponentGuids->push_back(pguidTemp);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (S_OK != hr)
    {
        // need to free all instace guids found so far
        EraseAndDeleteAll(pplComponentGuids);
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FAreBindingPathsEqual
//
//  Purpose:    Compares two representations of binding paths to find
//              if they represent the same binding path
//
//  Arguments:
//      pncbp                         [in] binding path 1
//      pplBindingPathComponentGuids2 [in] list of instance guids representing
//                                         binding path 2
//
//  Returns:    TRUE if paths are equal, FALSE otherwise
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
BOOL FAreBindingPathsEqual(INetCfgBindingPath* pncbp,
                           TPtrList* pplBindingPathComponentGuids2)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("FAreBindingPathsEqual");

    BOOL fEqual = FALSE;

    HRESULT hr=E_FAIL;
    TPtrList plBindingPathComponentGuids1;

    hr = HrGetInstanceGuidOfComponentsInBindingPath(pncbp, &plBindingPathComponentGuids1);
    if (SUCCEEDED(hr))
    {
        // now compare the two lists to see if they are equal
        if (plBindingPathComponentGuids1.size() ==
            pplBindingPathComponentGuids2->size())
        {
            fEqual = TRUE;

            TPtrListIter pos1, pos2;
            GUID guid1, guid2;

            pos1 = plBindingPathComponentGuids1.begin();
            pos2 = pplBindingPathComponentGuids2->begin();

            while (fEqual && (pos1 != plBindingPathComponentGuids1.end()))
            {
                AssertSz(pos2 != pplBindingPathComponentGuids2->end(),
                         "reached end of other list ??");

                guid1 = *((LPGUID) *pos1++);
                guid2 = *((LPGUID) *pos2++);

                fEqual = (guid1 == guid2);
            }
        }
        EraseAndDeleteAll(plBindingPathComponentGuids1);
    }

    TraceError(__FUNCNAME__, hr);

    return fEqual;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetBindingPathFromStringList
//
//  Purpose:    Finds the binding path represented by a list of string tokens.
//              Each token in the list may either be InfID of a networking
//              component or a component specified in the answerfile.
//
//  Arguments:
//      pnc              [in]  INetCfg interface
//      pslBindingPath   [in]  list of component ids to find.
//      ppncbp           [out] INetCfgBindingPath
//
//  Returns:    S_OK if found, S_FALSE if not found or an error code.
//
//  Author:     kumarp    05-July-97
//
//  Notes:      Caller must release the binding path
//
HRESULT HrGetBindingPathFromStringList(IN  INetCfg* pnc,
                                       IN  TStringList* pslBindingPath,
                                       OUT INetCfgBindingPath** ppncbp)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("GetBindingPathFromStringList");

    HRESULT hr=S_FALSE;

    //initialize out param
    *ppncbp = NULL;

#if DBG
    tstring strBindingPath;
    ConvertStringListToCommaList(*pslBindingPath, strBindingPath);
    TraceTag(ttidNetSetup, "%s: trying to find binding path: %S", __FUNCNAME__,
             strBindingPath.c_str());
#endif

    TPtrList plComponentGuids;
    TStringListIter pos;
    pos = pslBindingPath->begin();
    tstring strTopComponent;
    strTopComponent = **pos++;
    INetCfgComponent* pnccTop;
    BOOL fFound=FALSE;

    hr = pnc->FindComponent(strTopComponent.c_str(), &pnccTop);

    if (hr == S_OK)
    {
        hr = HrGetInstanceGuidOfComponentsInAnswerFile(pnc,
                                                       pslBindingPath,
                                                       &plComponentGuids);

        if (hr == S_OK)
        {
            CIterNetCfgBindingPath ncbpIter(pnccTop);
            INetCfgBindingPath*  pncbp;

            while (!fFound && (S_OK == (hr = ncbpIter.HrNext(&pncbp))))
            {
#if DBG
                TraceBindPath(pncbp, ttidNetSetup);
#endif
                if (FAreBindingPathsEqual(pncbp, &plComponentGuids))
                {
                    *ppncbp = pncbp;
                    fFound = TRUE;
                }
                else
                {
                    ReleaseObj(pncbp);
                }
            }
            EraseAndDeleteAll(plComponentGuids);
            if (!fFound && (SUCCEEDED(hr)))
            {
                hr = S_FALSE;
            }
        }
        ReleaseObj(pnccTop);
    }

#if DBG
    if (hr != S_OK)
    {
        TraceTag(ttidNetSetup, "%s: could not find binding path: %S", __FUNCNAME__,
                 strBindingPath.c_str());
    }
#endif

    TraceError(__FUNCNAME__, (S_FALSE == hr) ? S_OK : hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CBindingAction::HrPerformAction
//
//  Purpose:    Performs the binding action specified in the answerfile
//
//  Arguments:  none
//
//  Returns:    S_OK if success, or an error code.
//
//  Author:     kumarp    05-July-97
//
//  Notes:
//
HRESULT CBindingAction::HrPerformAction(IN INetCfg* pnc)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CBindingAction::HrPerformAction");

    HRESULT hr=S_OK;

    INetCfgBindingPath* pINetCfgBindingPath;

    AssertValidReadPtr(m_pnii);

#if DBG
    switch (m_eBindingAction)
    {
    case BND_Enable:
        TraceTag(ttidNetSetup, "%s: Enabling: %S",
                 __FUNCNAME__, m_strBindingPath.c_str());
        break;

    case BND_Disable:
        TraceTag(ttidNetSetup, "%s: Disabling: %S",
                 __FUNCNAME__, m_strBindingPath.c_str());
        break;

    case BND_Promote:
        TraceTag(ttidNetSetup, "%s: Promoting: %S",
                 __FUNCNAME__, m_strBindingPath.c_str());
        break;

    case BND_Demote:
        TraceTag(ttidNetSetup, "%s: Demoting: %S",
                 __FUNCNAME__, m_strBindingPath.c_str());
        break;

    default:
        TraceTag(ttidNetSetup, "%s: Cannot perform invalid binding action",
                 __FUNCNAME__);
        hr = E_FAIL;
        goto return_from_function;
        break;
    }
#endif

    hr = HrGetBindingPathFromStringList(pnc,
                                        &m_slBindingPath,
                                        &pINetCfgBindingPath);

    if (hr == S_OK)
    {
#if DBG
        TraceTag(ttidNetSetup, "%s: bindpath matches %S",
                 __FUNCNAME__, m_strBindingPath.c_str());
#endif
        switch (m_eBindingAction)
        {
        default:
            hr = S_FALSE;
            TraceTag(ttidNetSetup, "%s: ignored unknown binding action",
                     __FUNCNAME__);
            break;

        case BND_Enable:
            hr = pINetCfgBindingPath->Enable(TRUE);
            break;

        case BND_Disable:
            hr = pINetCfgBindingPath->Enable(FALSE);
            break;

        case BND_Promote:
        case BND_Demote:
            AssertValidReadPtr(m_pnii);
            AssertValidReadPtr(pnc);

            INetCfgComponentBindings* pncb;
            INetCfgComponent* pncc;
            tstring strTopComponent;

            strTopComponent = **(m_slBindingPath.begin());
            hr = pnc->FindComponent(strTopComponent.c_str(), &pncc);

            if (hr == S_OK)
            {
                hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                          (void**) &pncb);
                if (SUCCEEDED(hr))
                {
                    AssertValidReadPtr(pncb);

                    if (m_eBindingAction == BND_Promote)
                    {
                        hr = pncb->MoveBefore(pINetCfgBindingPath, NULL);
                    }
                    else
                    {
                        hr = pncb->MoveAfter(pINetCfgBindingPath, NULL);
                    }
                    ReleaseObj(pncb);
                }
                ReleaseObj(pncc);
            }
            break;
        }
#if DBG
        if (S_OK == hr)
        {
            TraceTag(ttidNetSetup, "%s: ...successfully performed binding action",
                     __FUNCNAME__);
        }
#endif
        ReleaseObj(pINetCfgBindingPath);
    }

#if DBG
return_from_function:
#endif

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceFunctionError(hr);

    return hr;
}


// ======================================================================
// class CNetComponent
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetComponent::CNetComponent
//
// Purpose:   constructor for class CNetComponent
//
// Arguments:
//    pszName [in]  name of the component
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent::CNetComponent(IN PCWSTR pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszName);

    m_strName = pszName;

    // for all components except adapters, name is same as InfID
    m_strInfID = pszName;
    m_fIsOemComponent = FALSE;

    // currently the SkipInstall feature is used only by
    // SNA for its peculiar upgrade requirements. This may or may
    // not become a documented feature.
    //
    m_fSkipInstall = FALSE;

    m_guidInstance = GUID_NULL;
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponent::GetInstanceGuid
//
// Purpose:   Get instance guid of this component
//
// Arguments:
//    pguid [out]  pointer to guid to be returned
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
VOID
CNetComponent::GetInstanceGuid (
    OUT LPGUID pguid) const
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert (pguid);

    if (IsInitializedFromAnswerFile() && (m_guidInstance == GUID_NULL))
    {
        // the Instance GUID is not in memory, need to get it from
        // the registry location where it has been saved by an earlier
        // instance of netsetup.dll
        //
        HrLoadInstanceGuid(Name().c_str(), (LPGUID) &m_guidInstance);
    }

    *pguid = m_guidInstance;
}


// ----------------------------------------------------------------------
//
// Function:  CNetComponent::SetInstanceGuid
//
// Purpose:   Set instance guid of this component
//
// Arguments:
//    pguid [in] pointer to the guid to set to
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
VOID
CNetComponent::SetInstanceGuid (
    IN const GUID* pguid)
{
    TraceFileFunc(ttidGuiModeSetup);

    m_guidInstance = *pguid;
    if (IsInitializedFromAnswerFile())
    {
        HrSaveInstanceGuid(Name().c_str(), pguid);
    }
}


// ----------------------------------------------------------------------
//
// Function:  CNetComponent::HrInitFromAnswerFile
//
// Purpose:   Initialize initialize basic information from the section of
//            this component in the answerfile
//
// Arguments:
//    pwifAnswerFile    [in]  pointer to CWInfFile object
//    pszParamsSections [in]  parameters section name
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetComponent::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile,
                                            IN PCWSTR pszParamsSections)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetComponent::HrInitFromAnswerFile");

    AssertValidReadPtr(pwifAnswerFile);
    AssertValidReadPtr(pszParamsSections);

    HRESULT hr=S_OK;

    m_strParamsSections = pszParamsSections;

    TStringList slParamsSections;
    ConvertCommaDelimitedListToStringList(m_strParamsSections, slParamsSections);

    tstring strSection;
    CWInfSection *pwisSection;
    tstring strInfID;
    tstring strInfIDReal;

    //if there are multiple sections, InfID could be in any one of them
    //we need to search all.
    TStringListIter pos = slParamsSections.begin();
    while (pos != slParamsSections.end())
    {
        strSection  = **pos++;
        pwisSection = pwifAnswerFile->FindSection(strSection.c_str());
        if (!pwisSection)
        {
            TraceTag(ttidNetSetup, "%s: warning: section %S is missing",
                     __FUNCNAME__, strSection.c_str());
            continue;
        }

        // it is really an error to specify different InfIDs in different
        // sections. We just take the last one found and overwrite earlier one.
        if (pwisSection->GetStringValue(c_szAfInfid, strInfID))
        {
            //InfId
            m_strInfID = strInfID;
        }

        if (pwisSection->GetStringValue(c_szAfInfidReal, strInfIDReal))
        {
            //InfIdReal
            m_strInfIDReal = strInfIDReal;
        }

        // currently the SkipInstall feature is used only by
        // SNA and MS_NetBIOS for their peculiar upgrade requirements.
        // This may or may not become a documented feature.
        //
        m_fSkipInstall = pwisSection->GetBoolValue(c_szAfSkipInstall, FALSE);

        if (m_strOemSection.empty())
        {
            m_strOemSection =
                pwisSection->GetStringValue(c_szAfOemSection, c_szEmpty);
            m_strOemDir     =
                pwisSection->GetStringValue(c_szAfOemDir, c_szEmpty);
            m_strOemDll     =
                pwisSection->GetStringValue(c_szAfOemDllToLoad, c_szEmpty);

            if (!m_strOemSection.empty() &&
                !m_strOemDir.empty())
            {
                m_fIsOemComponent = TRUE;
                CWInfSection* pwisOemSection;
                pwisOemSection =
                    pwifAnswerFile->FindSection(m_strOemSection.c_str());
                if (pwisOemSection)
                {
                    TStringArray saTemp;

                    if (pwisOemSection->GetStringArrayValue(c_szInfToRunBeforeInstall,
                                                            saTemp))
                    {
                        m_strInfToRunBeforeInstall     = *saTemp[0];
                        m_strSectionToRunBeforeInstall = *saTemp[1];
                        TraceTag(ttidNetSetup, "%s: '%S' specified %S: %S, %S",
                                 __FUNCNAME__, InfID().c_str(),
                                 c_szInfToRunBeforeInstall,
                                 m_strInfToRunBeforeInstall.c_str(),
                                 m_strSectionToRunBeforeInstall.c_str());
                    }


                    if (pwisOemSection->GetStringArrayValue(c_szInfToRunAfterInstall,
                                                            saTemp))
                    {
                        m_strInfToRunAfterInstall      = *saTemp[0];
                        m_strSectionToRunAfterInstall  = *saTemp[1];

                        if (m_strInfToRunAfterInstall.empty())
                        {
                            m_strInfToRunAfterInstall = pwifAnswerFile->FileName();
                        }
                        TraceTag(ttidNetSetup, "%s: '%S' specified %S: %S, %S",
                                 __FUNCNAME__, InfID().c_str(),
                                 c_szInfToRunAfterInstall,
                                 m_strInfToRunAfterInstall.c_str(),
                                 m_strSectionToRunAfterInstall.c_str());
                    }
                    EraseAndDeleteAll(&saTemp);
                }
            }
        }
    }

//  cleanup:
    EraseAndDeleteAll(slParamsSections);

    TraceFunctionError(hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CNetComponent::HrValidate
//
// Purpose:   Validate keys specified in the parameters section
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetComponent::HrValidate() const
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetComponent::HrValidate");

    HRESULT hr=S_OK;

//     BOOL fStatus = !(m_strInfID.empty() || m_strParamsSections.empty());
//     HRESULT hr = fStatus ? S_OK : NETSETUP_E_ANS_FILE_ERROR;

    TraceFunctionError(hr);
    return hr;
}

// ======================================================================
// class CNetAdapter
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetAdapter::CNetAdapter
//
// Purpose:   constructor for class CNetAdapter
//
// Arguments:
//    pszName [in]  name of the adapter
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetAdapter::CNetAdapter(IN PCWSTR pszName)
    : CNetComponent(pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

    m_fDetect = FALSE;
    m_fPseudoAdapter = FALSE;
    m_itBus = Isa;
    m_wIOAddr = 0;
    m_wIRQ = 0;
    m_wDMA = 0;
    m_dwMem = 0;
    m_qwNetCardAddress = 0;
    m_PciBusNumber = 0xFFFF;
    m_PciDeviceNumber = 0xFFFF;
    m_PciFunctionNumber = 0xFFFF;
    m_fPciLocationInfoSpecified = FALSE;
}


// ----------------------------------------------------------------------
//
// Function:  CNetAdapter::HrInitFromAnswerFile
//
// Purpose:   Initialize from the parameters section of this adapter
//            in the answerfile
//
// Arguments:
//    pwifAnswerFile    [in]  pointer to CWInfFile object
//    pszParamsSections [in]  name of the parameters section
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT CNetAdapter::HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile,
                                          IN PCWSTR pszParamsSections)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdapter::HrInitFromAnswerFile");


    AssertValidReadPtr(pwifAnswerFile);
    AssertValidReadPtr(pszParamsSections);

    HRESULT hr, hrReturn=S_OK;

    hrReturn = CNetComponent::HrInitFromAnswerFile(pwifAnswerFile,
                                                   pszParamsSections);


    PCWInfSection pwisParams;
    pwisParams = pwifAnswerFile->FindSection(pszParamsSections);
    if (!pwisParams)
    {
        AddAnswerFileError(pszParamsSections, IDS_E_AF_Missing);
        return NETSETUP_E_ANS_FILE_ERROR;
    }

    PCWSTR pszTemp;
    DWORD dwDefault = 0;

    //Detect
    m_fDetect     = pwisParams->GetBoolValue(c_szAfDetect, TRUE);

    if (!m_fDetect && m_strInfID.empty())
    {
        AddAnswerFileError(pszParamsSections,
                           IDS_E_AF_SpecifyInfIdWhenNotDetecting);
        hrReturn = NETSETUP_E_ANS_FILE_ERROR;
    }

    //PreUpgradeInstance
    m_strPreUpgradeInstance = pwisParams->GetStringValue(c_szAfPreUpgradeInstance,
                                                         c_szEmpty);

    //PseudoAdapter
    m_fPseudoAdapter = pwisParams->GetBoolValue(c_szAfPseudoAdapter, FALSE);

    //if it is a PseudoAdapter, no need to get values of other parameters
    if (m_fPseudoAdapter)
    {
        TraceFunctionError(hrReturn);
        return hrReturn;
    }

    // ConnectionName
    m_strConnectionName = pwisParams->GetStringValue(c_szAfConnectionName,
                                                     c_szEmpty);

    //BusType
    pszTemp = pwisParams->GetStringValue(c_szAfBusType, c_szEmpty);
    m_itBus = GetBusTypeFromName(pszTemp);

    //IOAddr
    m_wIOAddr = pwisParams->GetIntValue(c_szAfIoAddr, dwDefault);

    //IRQ
    m_wIRQ    = pwisParams->GetIntValue(c_szAfIrq, dwDefault);

    //DMA
    m_wDMA    = pwisParams->GetIntValue(c_szAfDma, dwDefault);

    //MEM
    m_dwMem   = pwisParams->GetIntValue(c_szAfMem, dwDefault);

    //NetCardAddr
    pwisParams->GetQwordValue(c_szAfNetCardAddr, &m_qwNetCardAddress);

    // BusNumber
    m_PciBusNumber = pwisParams->GetIntValue (L"PciBusNumber", 0xFFFF);
    if (0xFFFF != m_PciBusNumber)
    {
        // DeviceNumber
        m_PciDeviceNumber = pwisParams->GetIntValue (L"PciDeviceNumber", 0xFFFF);
        if (0xFFFF != m_PciDeviceNumber)
        {
            // FunctionNumber
            m_PciFunctionNumber = pwisParams->GetIntValue (L"PciFunctionNumber",
                    0xFFFF);
            if (0xFFFF != m_PciFunctionNumber)
            {
                m_fPciLocationInfoSpecified = TRUE;
            }
        }
    }

    TraceFunctionError(hrReturn);

    return hrReturn;
}

// ----------------------------------------------------------------------
//
// Function:  CNetAdapter::HrValidate
//
// Purpose:   Validate netcard parameters
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT CNetAdapter::HrValidate()
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("CNetAdapter::HrValidate");

    HRESULT hr;

    hr = CNetComponent::HrValidate();
    ReturnHrIfFailed(hr);

    //$ REVIEW  kumarp 21-April-97
    // no additinal checking for now

    TraceFunctionError(hr);

    return hr;
}

// ======================================================================
// class CNetProtocol
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetProtocol::CNetProtocol
//
// Purpose:   constructor for class CNetProtocol
//
// Arguments:
//    pszName [in]  name of the protocol
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetProtocol::CNetProtocol(IN PCWSTR pszName)
    : CNetComponent(pszName)
{
}


// ======================================================================
// class CNetService
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetService::CNetService
//
// Purpose:   constructor for class CNetService
//
// Arguments:
//    pszName [in]  name of the service
//
// Returns:
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetService::CNetService(IN PCWSTR pszName)
    : CNetComponent(pszName)
{
    TraceFileFunc(ttidGuiModeSetup);

}

// ======================================================================
// class CNetClient
// ======================================================================

// ----------------------------------------------------------------------
//
// Function:  CNetClient::CNetClient
//
// Purpose:   constructor for class CNetClient
//
// Arguments:
//    pszName [in]  name of the client
//
// Returns:
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetClient::CNetClient(IN PCWSTR pszName)
    : CNetComponent(pszName)
{
    TraceFileFunc(ttidGuiModeSetup);
}

// ----------------------------------------------------------------------
// Misc. Helper Functions
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
//
// Function:  FindComponentInList
//
// Purpose:   Find component in the given list
//
// Arguments:
//    pnclComponents [in]  pointer to list of components
//    szInfID        [in]  component to find
//
// Returns:   pointer to CNetComponent object, or NULL if not found
//
// Author:    kumarp 25-November-97
//
// Notes:
//
CNetComponent* FindComponentInList(
    IN CNetComponentList* pnclComponents,
    IN PCWSTR szInfID)
{
    TraceFileFunc(ttidGuiModeSetup);

    CNetComponent* pna;

    TPtrListIter pos;
    pos = pnclComponents->begin();
    while (pos != pnclComponents->end())
    {
        pna = (CNetComponent*) *pos++;
        if (0 == lstrcmpiW(pna->InfID().c_str(), szInfID))
        {
            return pna;
        }
    }

    return NULL;
}

// ----------------------------------------------------------------------
//
// Function:  GetDisplayModeStr
//
// Purpose:   Get string representation of DisplayMode
//
// Arguments:
//    pdmDisplay [in]  display mode
//
// Returns:
//
// Author:    kumarp 23-December-97
//
// Notes:
//
PCWSTR GetDisplayModeStr(EPageDisplayMode pdmDisplay)
{
    TraceFileFunc(ttidGuiModeSetup);

    switch (pdmDisplay)
    {
    case PDM_YES:
        return c_szYes;

    case PDM_NO:
        return c_szNo;

    case PDM_ONLY_ON_ERROR:
    default:
        return c_szAfOnlyOnError;
    }
}

// ----------------------------------------------------------------------
//
// Function:  MapToDisplayMode
//
// Purpose:   Map display mode string to proper enum value
//
// Arguments:
//    pszDisplayMode [in] display mode string
//
// Returns:   enum corresponding to the string
//
// Author:    kumarp 25-November-97
//
// Notes:
//
EPageDisplayMode MapToDisplayMode(IN PCWSTR pszDisplayMode)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszDisplayMode);

    if (!lstrcmpiW(pszDisplayMode, c_szYes))
        return PDM_YES;
    else if (!lstrcmpiW(pszDisplayMode, c_szNo))
        return PDM_NO;
    else if (!lstrcmpiW(pszDisplayMode, c_szAfOnlyOnError))
        return PDM_ONLY_ON_ERROR;
    else
        return PDM_UNKNOWN;
}

// ----------------------------------------------------------------------
//
// Function:  MapToUpgradeFlag
//
// Purpose:   Map string to proper upgrade flag value
//
// Arguments:
//    pszUpgradeFromProduct [in] string describing product
//
// Returns:   flag corresponding to the string
//
// Author:    kumarp 25-November-97
//
// Notes:
//
DWORD MapToUpgradeFlag(IN PCWSTR pszUpgradeFromProduct)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszUpgradeFromProduct);

    if (!lstrcmpiW(pszUpgradeFromProduct, c_szAfNtServer))
        return NSF_WINNT_SVR_UPGRADE;
    else if (!lstrcmpiW(pszUpgradeFromProduct, c_szAfNtSbServer))
        return NSF_WINNT_SBS_UPGRADE;
    else if (!lstrcmpiW(pszUpgradeFromProduct, c_szAfNtWorkstation))
        return NSF_WINNT_WKS_UPGRADE;
    else if (!lstrcmpiW(pszUpgradeFromProduct, c_szAfWin95))
        return NSF_WIN95_UPGRADE;
    else
        return 0;
}

HRESULT HrGetProductInfo (LPDWORD pdwUpgradeFrom,
                          LPDWORD pdwBuildNo)
{
    OSVERSIONINFOEX osvi;
    HRESULT hr;

    *pdwUpgradeFrom = 0;
    *pdwBuildNo = 0;

    ZeroMemory( &osvi,
                sizeof(OSVERSIONINFOEX) );

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if ( GetVersionEx((LPOSVERSIONINFO)&osvi) )
    {
        *pdwBuildNo = osvi.dwBuildNumber;

        if ( osvi.wSuiteMask & (VER_SUITE_SMALLBUSINESS | VER_SUITE_SMALLBUSINESS_RESTRICTED) )
        {
            *pdwUpgradeFrom = NSF_WINNT_SBS_UPGRADE;
        }
        else if ( osvi.wProductType == VER_NT_WORKSTATION )
        {
            *pdwUpgradeFrom = NSF_WINNT_WKS_UPGRADE;
        }
        else
        {
            *pdwUpgradeFrom = NSF_WINNT_SVR_UPGRADE;
        }

        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  GetBusTypeFromName
//
// Purpose:   Map bus-type enum from string
//
// Arguments:
//    pszBusType [in] name of the bus
//
// Returns:   enum INTERFACE_TYPE corresponding to the string
//
// Author:    kumarp 25-November-97
//
// Notes:
//
INTERFACE_TYPE GetBusTypeFromName(IN PCWSTR pszBusType)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszBusType);

    if (!_wcsicmp(pszBusType, c_szAfBusInternal))
        return Internal;
    else if (!_wcsicmp(pszBusType, c_szAfBusIsa))
        return Isa;
    else if (!_wcsicmp(pszBusType, c_szAfBusEisa))
        return Eisa;
    else if (!_wcsicmp(pszBusType, c_szAfBusMicrochannel))
        return MicroChannel;
    else if (!_wcsicmp(pszBusType, c_szAfBusTurbochannel))
        return TurboChannel;
    else if (!_wcsicmp(pszBusType, c_szAfBusPci))
        return PCIBus;
    else if (!_wcsicmp(pszBusType, c_szAfBusVme))
        return VMEBus;
    else if (!_wcsicmp(pszBusType, c_szAfBusNu))
        return NuBus;
    else if (!_wcsicmp(pszBusType, c_szAfBusPcmcia))
        return PCMCIABus;
    else if (!_wcsicmp(pszBusType, c_szAfBusC))
        return CBus;
    else if (!_wcsicmp(pszBusType, c_szAfBusMpi))
        return MPIBus;
    else if (!_wcsicmp(pszBusType, c_szAfBusMpsa))
        return MPSABus;
    else if (!_wcsicmp(pszBusType, c_szAfBusProcessorinternal))
        return ProcessorInternal;
    else if (!_wcsicmp(pszBusType, c_szAfBusInternalpower))
        return InternalPowerBus;
    else if (!_wcsicmp(pszBusType, c_szAfBusPnpisa))
        return PNPISABus;
    else
        return InterfaceTypeUndefined;
};

// ----------------------------------------------------------------------
//
// Function:  AddAnswerFileError
//
// Purpose:   Add error with given resource id to the answerfile error-list
//
// Arguments:
//    dwErrorId [in] resource id
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
void AddAnswerFileError(IN DWORD dwErrorId)
{
    TraceFileFunc(ttidGuiModeSetup);

    g_elAnswerFileErrors->Add(dwErrorId);
}

// ----------------------------------------------------------------------
//
// Function:  AddAnswerFileError
//
// Purpose:   Add error with given section name and error id
//            to the answerfile error-list
//
// Arguments:
//    pszSectionName [in]  name of section where error occurred
//    dwErrorId      [in]  error id
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
void AddAnswerFileError(IN PCWSTR pszSectionName, IN DWORD dwErrorId)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszSectionName);

    tstring strMsgPrefix = pszSectionName;
    strMsgPrefix = L"Section [" + strMsgPrefix + L"] : ";
    g_elAnswerFileErrors->Add(strMsgPrefix.c_str(), dwErrorId);
}

// ----------------------------------------------------------------------
//
// Function:  AddAnswerFileError
//
// Purpose:   Add error with given section name, key name and error id
//            to the answerfile error-list
//
// Arguments:
//    pszSectionName [in]  name of section where error occurred
//    pszKeyName     [in]  name of key where error occurred
//    dwErrorId      [in]  error id
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
void AddAnswerFileError(IN PCWSTR pszSectionName,
                        IN PCWSTR pszKeyName,
                        IN DWORD dwErrorId)
{
    TraceFileFunc(ttidGuiModeSetup);

    AssertValidReadPtr(pszSectionName);
    AssertValidReadPtr(pszKeyName);

    tstring strMsgPrefix = pszSectionName;
    strMsgPrefix = L"Section [" + strMsgPrefix + L"]: Key \"" +
        pszKeyName + L"\" : ";
    g_elAnswerFileErrors->Add(strMsgPrefix.c_str(), dwErrorId);
}

// ----------------------------------------------------------------------
//
// Function:  ShowAnswerFileErrorsIfAny
//
// Purpose:   Display messagebox if there are errors in the answerfile
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
void ShowAnswerFileErrorsIfAny()
{
    TraceFileFunc(ttidGuiModeSetup);

    static const WCHAR c_szNewLine[] = L"\n";

    TStringList* pslErrors=NULL;
    GetAnswerFileErrorList_Internal(pslErrors);

    if (pslErrors && (pslErrors->size() > 0))
    {
        tstring strErrors;
        strErrors = SzLoadIds(IDS_E_AF_AnsFileHasErrors);
        strErrors += c_szNewLine;
        strErrors += c_szNewLine;
        TStringListIter pos;
        pos = pslErrors->begin();

        while (pos != pslErrors->end())
        {
            strErrors += **pos++;
            strErrors += c_szNewLine;
        }
        MessageBox (NULL, strErrors.c_str(), NULL, MB_OK | MB_TASKMODAL);
    }
}

// ----------------------------------------------------------------------
//
// Function:  GetAnswerFileErrorList
//
// Purpose:   Return list of errors in the answerfile
//
// Arguments:
//    slErrors [out] pointer to list of errors
//
// Returns:   None
//
// Author:    kumarp 25-November-97
//
// Notes:
//
VOID
GetAnswerFileErrorList_Internal(OUT TStringList*& slErrors)
{
    TraceFileFunc(ttidGuiModeSetup);

    g_elAnswerFileErrors->GetErrorList(slErrors);
}

// ----------------------------------------------------------------------
//
// Function:  HrRemoveNetComponents
//
// Purpose:   Remove (DeInstall) specified components
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    pslComponents [in]  pointer to list of components to be removed
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 25-November-97
//
// Notes:
//
HRESULT HrRemoveNetComponents(IN INetCfg* pnc,
                              IN TStringList* pslComponents)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrDeInstallNetComponents");

    AssertValidReadPtr(pslComponents);

    HRESULT hr=S_OK;
    TStringListIter pos;
    PCWSTR szComponentId;
    INetCfgComponent* pINetCfgComponent;
    GUID guidClass;

    for (pos = pslComponents->begin(); pos != pslComponents->end(); pos++)
    {
        szComponentId = (*pos)->c_str();

        ShowProgressMessage(L"Trying to remove %s...", szComponentId);

        hr = pnc->FindComponent(szComponentId, &pINetCfgComponent);

        if (S_OK == hr)
        {
            hr = pINetCfgComponent->GetClassGuid(&guidClass);

            if (S_OK == hr)
            {
                hr = HrRemoveComponentOboUser(pnc, guidClass, szComponentId);

                if (S_OK == hr)
                {
                    ShowProgressMessage(L"...successfully removed %s",
                                        szComponentId);
                }
            }

            if (S_OK != hr)
            {
                ShowProgressMessage(L"...error removing %s, error code: 0x%x",
                                    szComponentId, hr);
            }
            ReleaseObj(pINetCfgComponent);
        }
        else
        {
            ShowProgressMessage(L"...component %s is not installed",
                                szComponentId);
        }

        // Remove the files.

        RemoveFiles( szComponentId );

        // we ignore any errors so that we can remove as many components
        // as possible
        //
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  RemoveFiles
//
// Purpose:   Remove the files of the specified component.
//
// Arguments:
//    szInfID [in]  Infid of the component.
//
// Returns:
//
// Author:    asinha 02-April-2001
//
// Notes:
//

VOID  RemoveFiles (IN PCWSTR szInfID)
{
    tstring strFilename;
    WCHAR   szWindowsDir[MAX_PATH+2];
    int     len;

    if ( _wcsicmp(szInfID, sz_DLC) == 0 )
    {
        len = GetWindowsDirectoryW(szWindowsDir, MAX_PATH+1);
        if ( szWindowsDir[len-1] != L'\\' )
        {
            szWindowsDir[len] = L'\\';
            szWindowsDir[len+1] = NULL;
        }

        // Don't know if it is an upgrade from NT 4.0 or Win2k, so
        // try to delete the inf file of both the OS's.
        //

        strFilename = szWindowsDir;
        strFilename += sz_DLC_NT40_Inf;
        DeleteFile( strFilename.c_str() );

        strFilename = szWindowsDir;
        strFilename += sz_DLC_Win2k_Inf;
        DeleteFile( strFilename.c_str() );

        strFilename = szWindowsDir;
        strFilename += sz_DLC_Win2k_Pnf;
        DeleteFile( strFilename.c_str() );

        strFilename = szWindowsDir;
        strFilename += sz_DLC_Sys;
        DeleteFile( strFilename.c_str() );

        strFilename = szWindowsDir;
        strFilename += sz_DLC_Dll;
        DeleteFile( strFilename.c_str() );
    }

    return;
}

static ProgressMessageCallbackFn g_pfnProgressMsgCallback;

EXTERN_C
VOID
WINAPI
NetSetupSetProgressCallback (
    ProgressMessageCallbackFn pfn)
{
    TraceFileFunc(ttidGuiModeSetup);

    g_pfnProgressMsgCallback = pfn;
}

VOID
ShowProgressMessage (
    IN PCWSTR szFormatStr, ...)
{
    TraceFileFunc(ttidGuiModeSetup);

    va_list arglist;

    va_start (arglist, szFormatStr);

    if (g_pfnProgressMsgCallback)
    {
        g_pfnProgressMsgCallback(szFormatStr, arglist);
    }
#ifdef ENABLETRACE
    else
    {
        static WCHAR szTempBuf[1024];

        _vstprintf(szTempBuf, szFormatStr, arglist);
        TraceTag(ttidNetSetup, "%S", szTempBuf);
    }
#endif

    va_end(arglist);
}

// ----------------------------------------------------------------------
//
// Function:  HrMakeCopyOfAnswerFile
//
// Purpose:   Make a backup copy of the answerfile. Base setup has started
//            deleting it after GUI mode setup, but we want to retain
//            the file for debugging/support purpose.
//
// Arguments:
//    szAnswerFileName [in]  full path+name of AnswerFile
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 12-January-98
//
// Notes:
//
HRESULT HrMakeCopyOfAnswerFile(IN PCWSTR szAnswerFileName)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrMakeCopyOfAnswerFile");

    TraceFunctionEntry(ttidNetSetup);

    static const WCHAR c_szAnswerFileCopyName[] = L"af.txt";

    HRESULT hr=S_OK;
    WCHAR szWindowsDir[MAX_PATH+1];
    tstring strAnswerFileCopyName;

    DWORD cNumCharsReturned = GetSystemWindowsDirectory(szWindowsDir, MAX_PATH);
    if (cNumCharsReturned)
    {
        static const WCHAR c_szNetsetupTempSubDir[] = L"\\netsetup\\";

        strAnswerFileCopyName = szWindowsDir;
        strAnswerFileCopyName += c_szNetsetupTempSubDir;

        DWORD err = 0;
        DWORD status;
        status = CreateDirectory(strAnswerFileCopyName.c_str(), NULL);

        if (!status)
        {
            err = GetLastError();
        }

        if (status || (ERROR_ALREADY_EXISTS == err))
        {
            hr = S_OK;
            strAnswerFileCopyName += c_szAnswerFileCopyName;
            status = CopyFile(szAnswerFileName,
                              strAnswerFileCopyName.c_str(), FALSE);
            if (status)
            {
                hr = S_OK;
                TraceTag(ttidNetSetup, "%s: AnswerFile %S copied to %S",
                         __FUNCNAME__, szAnswerFileName,
                         strAnswerFileCopyName.c_str());
            }
            else
            {
                hr = HrFromLastWin32Error();
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(err);
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetConnectionFromAdapterGuid
//
// Purpose:   Get INetConnection* for a given adapter guid
//
// Arguments:
//    pguidAdapter [in]  pointer to the instance GUID of an adapter
//    ppconn       [out] the corresponding INetConnection*
//
// Returns:   S_OK on success, otherwise an error code
//            S_FALSE if connection was not found.
//
// Author:    kumarp 23-September-98
//
// Notes:
//
HRESULT HrGetConnectionFromAdapterGuid(IN  GUID* pguidAdapter,
                                       OUT INetConnection** ppconn)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrGetConnectionFromAdapterGuid");

    HRESULT hr=S_OK;
    BOOL fFound = FALSE;

    // Iterate all LAN connections
    //
    INetConnectionManager * pconMan;

    hr = HrCreateInstance(
        CLSID_LanConnectionManager,
        CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        &pconMan);

    TraceHr(ttidError, FAL, hr, FALSE, "HrCreateInstance");

    if (SUCCEEDED(hr))
    {
        CIterNetCon         ncIter(pconMan, NCME_DEFAULT);
        INetConnection*     pconn = NULL;

        while (!fFound && (S_OK == (ncIter.HrNext(&pconn))))
        {
            if (FPconnEqualGuid(pconn, *pguidAdapter))
            {
                fFound = TRUE;
                *ppconn = pconn;
            }
            else
            {
                ReleaseObj(pconn);
            }
        }

        ReleaseObj(pconMan);
    }

    if (!fFound)
        hr = S_FALSE;

    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrSetLanConnectionName
//
// Purpose:   Rename the connection spcified by its adapter guid
//            to the given name
//
// Arguments:
//    pguidAdapter     [in]  pointer to the instance GUID of an adapter
//    szConnectionName [in]  name of Connection
//
// Returns:   S_OK on success, otherwise an error code
//            S_FALSE if connection was not found
//
// Author:    kumarp 23-September-98
//
// Notes:
//
HRESULT HrSetLanConnectionName(IN GUID*   pguidAdapter,
                               IN PCWSTR szConnectionName)
{
    TraceFileFunc(ttidGuiModeSetup);

    DefineFunctionName("HrSetConnectionName");

    HRESULT hr=S_OK;
    INetConnection* pconn;

    hr = HrGetConnectionFromAdapterGuid(pguidAdapter, &pconn);
    if (S_OK == hr)
    {
        hr = pconn->Rename(szConnectionName);
        ReleaseObj(pconn);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// =======================================================================
// defunct code
// =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\afileint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A F I L E X P . H
//
//  Contents:   Interface classes to access the AnswerFile in modular way.
//
//  Author:     kumarp    25-November-97
//
//----------------------------------------------------------------------------

#pragma once
#include "edc.h"
#include "kkcwinf.h"
#include "netcfgp.h"
#include "oemupgrd.h"
#include "nsexports.h"

enum EPageDisplayMode { PDM_UNKNOWN, PDM_NO, PDM_YES, PDM_ONLY_ON_ERROR };

// ----------------------------------------------------------------------
// forward declarations
// ----------------------------------------------------------------------
class CNetInstallInfo;
class CPageDisplayCommonInfo;
class CCommonInfo;
class CNetComponentsPageBase;
class CNetAdaptersPage;
class CNetProtocolsPage;
class CNetServicesPage;
class CNetClientsPage;
class CNetBindingsPage;
class CNetComponent;
class CNetComponentList;
class CNetAdapter;
class CNetProtocol;
class CNetService;
class CNetClient;

enum ENetComponentType;

class CNetComponentList : public TPtrList
{
};

// ----------------------------------------------------------------------
class CNetInstallInfo
{
private:
    CNetInstallInfo();
public:
    ~CNetInstallInfo();

    static
    HRESULT
    HrCreateInstance (
        IN PCWSTR pszAnswerFileName,
        OUT CNetInstallInfo** ppObj);

    //void InitDefaults();

    HRESULT CNetInstallInfo::InitRepairMode (VOID);
    HRESULT HrInitFromAnswerFile(IN PCWSTR pszAnswerFileName);
    HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);
    BOOL    AnswerFileInitialized()           { return m_pwifAnswerFile != NULL;}
    PCWSTR AnswerFileName();
    CWInfFile* AnswerFile()                   { return m_pwifAnswerFile; }
    HRESULT HrInitForDefaultComponents();

    CNetComponent* Find(IN PCWSTR pszComponentName) const;
    CNetComponent* FindFromInfID(IN PCWSTR szInfID) const;

    HRESULT
    FindAdapter (
        IN QWORD qwNetCardAddress,
        OUT CNetAdapter** ppNetAdapter) const;

    HRESULT
    FindAdapter (
        IN DWORD BusNumber,
        IN DWORD Address,
        OUT CNetAdapter** ppNetAdapter) const;

    CNetAdapter*   FindAdapter(IN PCWSTR pszInfID) const;

    HRESULT HrGetInstanceGuidOfPreNT5NetCardInstance(IN PCWSTR szPreNT5NetCardInstance,
                                                     OUT LPGUID pguid);
    HRESULT HrDoUnattended(IN HWND hParent, IN IUnknown * punk,
                           IN  EUnattendWorkType uawType,
                           OUT EPageDisplayMode *ppdm, OUT BOOL *pfAllowChanges);

    CNetAdaptersPage*    AdaptersPage()       { return m_pnaiAdaptersPage; }
    CNetProtocolsPage*   ProtocolsPage()      { return m_pnpiProtocolsPage;}
    CNetServicesPage*    ServicesPage()       { return m_pnsiServicesPage; }
    CNetClientsPage*     ClientsPage()        { return m_pnciClientsPage; }
    CNetBindingsPage*    BindingsPage()       { return m_pnbiBindingsPage; }

    DWORD                UpgradeFlag() const  { return m_dwUpgradeFlag;    }
    DWORD                BuildNumber() const  { return m_dwBuildNumber;    }

private:
    CWInfFile*            m_pwifAnswerFile;

    CNetAdaptersPage*     m_pnaiAdaptersPage;
    CNetProtocolsPage*    m_pnpiProtocolsPage;
    CNetServicesPage*     m_pnsiServicesPage;
    CNetClientsPage*      m_pnciClientsPage;
    CNetBindingsPage*     m_pnbiBindingsPage;

    DWORD                 m_dwUpgradeFlag;
    DWORD                 m_dwBuildNumber;
    BOOL                  m_fProcessPageSections;
    BOOL                  m_fUpgrade;

    BOOL                  m_fInstallDefaultComponents;
    TStringList           m_slNetComponentsToRemove;

public:
    NetUpgradeInfo        m_nui;
    HINF                  m_hinfAnswerFile;
};

extern CNetInstallInfo* g_pnii;

// ----------------------------------------------------------------------
class CPageDisplayCommonInfo
{
public:
    CPageDisplayCommonInfo();

    //void            InitDefaults();
    virtual HRESULT    HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);

    EPageDisplayMode Display() const     { return m_pdmDisplay;    }
    BOOL            AllowChanges() const { return m_fAllowChanges; }
    void            GetDisplaySettings(OUT EPageDisplayMode* ppdm,
                                       OUT BOOL* pfAllowChanges) const
                                    { *ppdm = m_pdmDisplay;
                                      *pfAllowChanges = m_fAllowChanges; }

private:
    EPageDisplayMode m_pdmDisplay;
    BOOL            m_fAllowChanges;
};

// ----------------------------------------------------------------------

class CNetComponentsPageBase : public CPageDisplayCommonInfo
{
public:
    CNetComponentsPageBase(IN CNetInstallInfo* pnii,
                           IN const GUID* lpguidDevClass);
    ~CNetComponentsPageBase();

    virtual HRESULT    HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile,
                                            IN PCWSTR    pszSectionName);
    HRESULT      HrInitForDefaultComponents();


    CNetComponent*  Find(IN PCWSTR pszComponentName) const;
    CNetComponent*  FindFromInfID(IN PCWSTR szInfID) const;
    virtual HRESULT    HrValidate() const;
    virtual CNetComponent* GetNewComponent(IN PCWSTR pszName) = 0;

    virtual HRESULT HrDoNetworkInstall(IN HWND hParent, IN INetCfg* pnc);
    virtual HRESULT HrDoOsUpgrade(IN INetCfg* pnc);

protected:
    CNetInstallInfo*    m_pnii;
    const GUID*         m_lpguidDevClass;
    CNetComponentList   m_pnclComponents;
    PCWSTR              m_pszClassName;
    ENetComponentType   m_eType;;

friend
    VOID
    CALLBACK
    DefaultComponentCallback (
        IN EDC_CALLBACK_MESSAGE Message,
        IN ULONG_PTR MessageData,
        IN PVOID pvCallerData OPTIONAL);
};

// ----------------------------------------------------------------------
class CNetAdaptersPage : public CNetComponentsPageBase
{
public:
    CNetAdaptersPage(IN CNetInstallInfo* pnii);

    virtual CNetComponent* GetNewComponent(IN PCWSTR pszName);

    HRESULT      HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);

    HRESULT
    FindAdapter(IN QWORD qwNetCardAddress, OUT CNetAdapter** ppNetAdapter ) const;

    HRESULT
    FindAdapter (IN DWORD BusNumber, IN DWORD Address, OUT CNetAdapter** ppNetAdapter) const;

    CNetAdapter* FindAdapter(IN PCWSTR pszInfID) const;
    CNetAdapter* FindCompatibleAdapter(IN PCWSTR mszInfIDs) const;
    CNetAdapter* FindAdapterFromPreUpgradeInstance(IN PCWSTR szPreUpgradeInstance);

    DWORD        GetNumCompatibleAdapters(IN PCWSTR mszInfID) const;
    HRESULT      HrResolveNetAdapters(IN INetCfg* pnc);
    HRESULT      HrDoOemPostUpgradeProcessing(IN INetCfg* pnc,
                                              IN HWND hwndParent);
    HRESULT      HrSetConnectionNames();

private:
};

// ----------------------------------------------------------------------
class CNetProtocolsPage : public CNetComponentsPageBase
{
public:
    CNetProtocolsPage(IN CNetInstallInfo* pnii);

    virtual CNetComponent* GetNewComponent(IN PCWSTR pszName);
    HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);

private:
};

// ----------------------------------------------------------------------
class CNetServicesPage : public CNetComponentsPageBase
{
public:
    CNetServicesPage(IN CNetInstallInfo* pnii);

    virtual CNetComponent* GetNewComponent(IN PCWSTR pszName);
    HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);

private:
};

// ----------------------------------------------------------------------
class CNetClientsPage : public CNetComponentsPageBase
{
public:
    CNetClientsPage(IN CNetInstallInfo* pnii);

    virtual CNetComponent* GetNewComponent(IN PCWSTR pszName);
    HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);

private:
};

// ----------------------------------------------------------------------
class CNetBindingsPage : public CPageDisplayCommonInfo
{
public:
    CNetBindingsPage(IN CNetInstallInfo* pnii);

    HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile);
    virtual HRESULT HrDoUnattended(IN INetCfg* pnc);

private:
    CNetInstallInfo*   m_pnii;

    TPtrList           m_plBindingActions;
};
// ----------------------------------------------------------------------

enum ENetComponentType { NCT_Unknown, NCT_Client, NCT_Service,
                         NCT_Protocol, NCT_Adapter };

class CNetComponent
{
    friend HRESULT CNetComponentsPageBase::HrDoNetworkInstall(IN HWND hParent,
                                                              IN INetCfg* pnc);
public:
    CNetComponent(IN PCWSTR pszName);

    ENetComponentType Type()  const        { return m_eType;             }

    virtual HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile,
                                    IN PCWSTR pszParamsSections);

    const tstring& Name() const            { return m_strName;           }
    const tstring& InfID()  const          { return m_strInfID;          }
    const tstring& InfIDReal() const       { return m_strInfIDReal;      }
    const tstring& ParamsSections() const  { return m_strParamsSections; }
    const tstring& OemDll() const          { return m_strOemDll;         }
    const tstring& OemDir() const          { return m_strOemDir;         }

    void  GetInstanceGuid(LPGUID pguid) const;

    void  SetInfID(IN PCWSTR pszInfID)    { m_strInfID = pszInfID;      }
    void  SetInstanceGuid(const GUID* pguid);

    virtual BOOL IsInitializedFromAnswerFile() const
                                     { return ! m_strParamsSections.empty(); }
    virtual HRESULT HrValidate() const;

    tstring   m_strParamsSections;

protected:
    ENetComponentType m_eType;

    tstring   m_strName;
    tstring   m_strInfID;
    tstring   m_strInfIDReal;
    GUID      m_guidInstance;

    BOOL      m_fIsOemComponent;
    BOOL      m_fSkipInstall;
    tstring   m_strOemSection;
    tstring   m_strOemDir;
    tstring   m_strOemDll;
    tstring   m_strInfToRunBeforeInstall;
    tstring   m_strSectionToRunBeforeInstall;
    tstring   m_strInfToRunAfterInstall;
    tstring   m_strSectionToRunAfterInstall;
};

// ----------------------------------------------------------------------
class CNetAdapter : public CNetComponent
{
public:
    CNetAdapter(IN PCWSTR pszName);

    virtual HRESULT HrInitFromAnswerFile(IN CWInfFile* pwifAnswerFile,
                                         IN PCWSTR pszParamsSections);

    virtual HRESULT HrValidate();

    PCWSTR          PreUpgradeInstance() const
                                      { return m_strPreUpgradeInstance.c_str();}
    INTERFACE_TYPE   BusType()  const { return m_itBus;   }
    WORD             IOAddr()   const { return m_wIOAddr; }
    WORD             IRQ()      const { return m_wIRQ;    }
    WORD             DMA()      const { return m_wDMA;    }
    DWORD            Mem()      const { return m_dwMem;   }
    QWORD            NetCardAddr() const { return m_qwNetCardAddress; }
    BOOL             IsPseudoAdapter() const { return m_fPseudoAdapter; }
    PCWSTR          ConnectionName() const { return m_strConnectionName.c_str();}
    DWORD            PciAddress () const { return MAKELONG(m_PciFunctionNumber, m_PciDeviceNumber); }
    DWORD            PciBusNumber () const { return m_PciBusNumber; }
    BOOL             FPciInfoSpecified() const { return m_fPciLocationInfoSpecified; }

private:
    BOOL             m_fDetect;
    BOOL             m_fPseudoAdapter;
    tstring          m_strPreUpgradeInstance;
    INTERFACE_TYPE   m_itBus;
    WORD             m_wIOAddr;
    WORD             m_wIRQ;
    WORD             m_wDMA;
    DWORD            m_dwMem;
    WORD             m_PciBusNumber;
    WORD             m_PciDeviceNumber;
    WORD             m_PciFunctionNumber;
    BOOL             m_fPciLocationInfoSpecified;
    QWORD            m_qwNetCardAddress;
    tstring          m_strConnectionName;
};

// ----------------------------------------------------------------------
class CNetProtocol : public CNetComponent
{
public:
    CNetProtocol(IN PCWSTR pszName);
};

// ----------------------------------------------------------------------
class CNetService : public CNetComponent
{
public:
    CNetService(IN PCWSTR pszName);
};

// ----------------------------------------------------------------------
class CNetClient : public CNetComponent
{
public:
    CNetClient(IN PCWSTR pszName);
};

// ----------------------------------------------------------------------

enum EBindingAction
{
    BND_Unknown,
    BND_Enable,
    BND_Disable,
    BND_Promote,
    BND_Demote
};

class CBindingAction
{
friend
    HRESULT
    CNetInstallInfo::HrCreateInstance (
        IN PCWSTR pszAnswerFileName,
        OUT CNetInstallInfo** ppObj);

public:
    CBindingAction();
    ~CBindingAction();

    HRESULT HrInitFromAnswerFile(IN const CWInfKey* pwikKey);

    HRESULT HrPerformAction(IN INetCfg* pnc);

private:
    static CNetInstallInfo* m_pnii;

    EBindingAction      m_eBindingAction;
    TStringList         m_slBindingPath;
#if DBG
    tstring             m_strBindingPath;
#endif
};


// ----------------------------------------------------------------------

VOID
GetAnswerFileErrorList_Internal(OUT TStringList*& slErrors);

void ShowAnswerFileErrorsIfAny();

void ShowProgressMessage(IN PCWSTR szFormatStr, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\compid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O M P I D . C P P
//
//  Contents:   Functions dealing with compatible ids
//
//  Notes:
//
//  Author:     kumarp    04-September-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkutils.h"
#include "ncsetup.h"
#include "ncnetcfg.h"

// ----------------------------------------------------------------------
//
// Function:  HrGetCompatibleIds
//
// Purpose:   Get a list of PnpIds compatible to the given net device
//
// Arguments:
//    hdi                [in]  handle of device info
//    pdeid              [in]  pointer to device info data
//    ppmszCompatibleIds [out] pointer to multisz to receive the list
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-March-98
//
// Notes:
//
HRESULT HrGetCompatibleIds(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PWSTR* ppmszCompatibleIds)
{
    Assert(IsValidHandle(hdi));
    AssertValidReadPtr(pdeid);
    AssertValidWritePtr(ppmszCompatibleIds);

    // Now we need to build a list of all the possible ids this
    // device could have so that netsetup can find the correct match.
    //

    HRESULT hr;

    // First we get the multi sz of hardware ids
    //
    PWSTR pszHwIds = NULL;
    PWSTR pszCompatIds = NULL;
    PWSTR pszIdList = NULL;

    *ppmszCompatibleIds = NULL;

    hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (hdi, pdeid,
            SPDRP_HARDWAREID, NULL, (BYTE**)&pszHwIds);

    if (S_OK == hr)
    {
        // Now we get the multi sz of compatible ids
        // Note: we can still attempt to get parameters with
        // the hardware ids so if the next call fails, we will
        // continue
        (void) HrSetupDiGetDeviceRegistryPropertyWithAlloc (hdi, pdeid,
                SPDRP_COMPATIBLEIDS, NULL, (BYTE**)&pszCompatIds);

        // Get the lengths of the ids
        //

        // Get the length of the hardware ids without the extra null
        Assert (CchOfMultiSzAndTermSafe (pszHwIds) > 0);
        ULONG cbHwIds = CchOfMultiSzSafe (pszHwIds) * sizeof (WCHAR);

        ULONG cbCompatIds = CchOfMultiSzAndTermSafe (pszCompatIds) *
                sizeof (WCHAR);


        // If there was a compatible id list we need to make one concatenated list
        //
        if (cbCompatIds)
        {
            hr = E_OUTOFMEMORY;

            // allocate the buffer
            pszIdList = (PWSTR)MemAlloc (cbHwIds + cbCompatIds);

            if (pszIdList)
            {
                // copy the two lists
                // The hwids length does not contain the extra null, but
                // the compat id list does, so it works out when
                // concatenating
                //
                hr = S_OK;
                CopyMemory (pszIdList, pszHwIds, cbHwIds);

                Assert (0 == (cbHwIds % sizeof(WCHAR)));
                CopyMemory ((BYTE*)pszIdList + cbHwIds, pszCompatIds,
                        cbCompatIds);

                *ppmszCompatibleIds = pszIdList;
            }

            MemFree (pszCompatIds);
            MemFree (pszHwIds);
        }
        else
        {
            // only the main (Hardware Ids) list is available so
            // just assign to the list variable
            *ppmszCompatibleIds = pszHwIds;
        }
    }

    TraceHr (ttidNetSetup, FAL, hr, FALSE, "HrGetCompatibleIds");

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrIsAdapterInstalled
//
// Purpose:   Find out if the specified adapter is installed
//
// Arguments:
//    szAdapterId [in]  PnP Id
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 17-September-98
//
// Notes:
//
HRESULT HrIsAdapterInstalled(IN PCWSTR szAdapterId)
{
    DefineFunctionName("HrIsAdapterInstalled2");

    AssertValidReadPtr(szAdapterId);

    HRESULT hr=S_OK;
        HDEVINFO hdi;
    DWORD dwIndex=0;
    SP_DEVINFO_DATA deid;
    WCHAR szInstance[MAX_DEVICE_ID_LEN];
    BOOL fFound = FALSE;

    hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
                               DIGCF_PRESENT, &hdi);

    if (S_OK == hr)
    {
        while (!fFound &&
               SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(hdi, dwIndex, &deid)))
        {
            dwIndex++;

            hr = HrSetupDiGetDeviceInstanceId(hdi, &deid, szInstance,
                    MAX_DEVICE_ID_LEN, NULL);
            if (S_OK == hr)
            {
                PWSTR pmszCompatibleIds;

                hr = HrGetCompatibleIds(hdi, &deid, &pmszCompatibleIds);
                if (S_OK == hr)
                {
                    if (FIsSzInMultiSzSafe(szAdapterId, pmszCompatibleIds))
                    {
                        fFound = TRUE;
                        hr = S_OK;
                    }

                    MemFree(pmszCompatibleIds);
                }
            }

        }
        SetupDiDestroyDeviceInfoList(hdi);
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_FALSE;
    }

    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrGetCompatibleIdsOfNetComponent
//
// Purpose:   Find compatible PnP IDs of the adapter
//            specified by the given INetCfgComponent
//
// Arguments:
//    pncc               [in]  pointer to INetCfgComponent object
//    ppmszCompatibleIds [out] pointer to compatible IDs multisz
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 28-September-98
//
// Notes:
//
HRESULT HrGetCompatibleIdsOfNetComponent(IN INetCfgComponent* pncc,
                                         OUT PWSTR* ppmszCompatibleIds)
{
    DefineFunctionName("HrIsAdapterInstalled2");

    HRESULT hr=S_OK;
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    tstring strInstance;
    PWSTR pszPnpDevNodeId=NULL;

    hr = pncc->GetPnpDevNodeId(&pszPnpDevNodeId);

    if (S_OK == hr)
    {
        // Use the instanceID to get the key to the parameters
        // using Device Installer APIs (PNP)
        //
        hr = HrSetupDiCreateDeviceInfoList(&GUID_DEVCLASS_NET, NULL, &hdi);
        if (S_OK == hr)
        {
            // Open the devnode.
            //
            SP_DEVINFO_DATA deid;
            hr = HrSetupDiOpenDeviceInfo(hdi, pszPnpDevNodeId, NULL,
                                         0, &deid);
            if (S_OK == hr)
            {
                hr = HrGetCompatibleIds(hdi, &deid, ppmszCompatibleIds);
            }

            SetupDiDestroyDeviceInfoList(hdi);
        }
        CoTaskMemFree(pszPnpDevNodeId);
    }

    TraceErrorSkip1(__FUNCNAME__, hr, S_FALSE);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\compid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C O M P I D . H
//
//  Contents:   Functions dealing with compatible ids
//
//  Notes:
//
//  Author:     kumarp    04-September-98
//
//----------------------------------------------------------------------------

HRESULT HrIsAdapterInstalled(IN PCWSTR szAdapterId);
HRESULT HrGetCompatibleIdsOfNetComponent(IN INetCfgComponent* pncc,
                                         OUT PWSTR* pmszCompatibleIds);
HRESULT HrGetCompatibleIds(IN  HDEVINFO hdi,
                           IN  PSP_DEVINFO_DATA pdeid,
                           OUT PWSTR* pmszCompatibleIds);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\errorlog.h ===
#pragma once

class CErrorLog
{
public:
    CErrorLog();

    void  Add(IN PCWSTR pszError);
    void  Add(IN DWORD dwErrorId);
    void  Add(IN PCWSTR pszErrorPrefix, IN DWORD dwErrorId);

    DWORD GetCount()        { return m_slErrors.size(); }
    void  GetErrorList(OUT TStringList*& slErrors);

private:
    TStringList m_slErrors;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\errorlog.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nsbase.h"
#include "kkstl.h"
#include "errorlog.h"



CErrorLog::CErrorLog()
{
}

void CErrorLog::Add(IN PCWSTR pszError)
{
    AssertValidReadPtr(pszError);

    AddAtEndOfStringList(m_slErrors, pszError);
    TraceTag(ttidNetSetup, "AnswerFile Error: %S", pszError);
}

void CErrorLog::Add(IN DWORD dwErrorId)
{
    PCWSTR pszError = SzLoadIds(dwErrorId);
    AddAtEndOfStringList(m_slErrors, pszError);
    TraceTag(ttidNetSetup, "AnswerFile Error: %S", pszError);
}

void CErrorLog::Add(IN PCWSTR pszErrorPrefix, IN DWORD dwErrorId)
{
    AssertValidReadPtr(pszErrorPrefix);

    PCWSTR pszError = SzLoadIds(dwErrorId);
    tstring strError = pszError;
    strError = pszErrorPrefix + strError;
    AddAtEndOfStringList(m_slErrors, strError.c_str());
    TraceTag(ttidNetSetup, "AnswerFile Error: %S", strError.c_str());
}

void CErrorLog::GetErrorList(OUT TStringList*& slErrors)
{
    slErrors = &m_slErrors;
}

// ======================================================================
// defunct code
// ======================================================================

/*
TStringList* g_slErrors;

BOOL InitErrorModule()
{
    if (!g_slErrors)
    {
        g_slErrors = new TStringList;
    }

    return g_slErrors != NULL;
}

void ReportError(IN PCWSTR pszError)
{
    g_slErrors->AddTail(pszError);
}

void GetErrors(OUT TStringList*& rpslErrors)
{
    rpslErrors = g_slErrors;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\hnethlp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       H N E T H L P . CPP
//
//  Contents:   Functions that is related to the unattended install
//              and upgrade of HomeNet settings
//
//
//  Author:     NSun
//  Date:       April 2001
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma  hdrstop
#include <atlbase.h>
#include "hnetcfg.h"

/*++

Routine Description:

    Create a bridge

Arguments:

    rgspNetConns [IN] the array with a NULL terminator. Contains the connections 
                    that needs to be bridged together

    ppBridge     [OUT] the newly created bridge. The caller can pass a NULL in
                    if the caller do not need this info

Return Value:

    standard HRESULT

--*/
HRESULT HNetCreateBridge(
         IN INetConnection * rgspNetConns[],
         OUT IHNetBridge ** ppBridge
         )
{
    if (ppBridge)
    {
        *ppBridge = NULL;
    }

    //calculate the count and ensure it's at least two
    for (int cnt = 0; NULL != rgspNetConns[cnt]; cnt++);

    if (cnt < 2)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    
    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.
    
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;
    
    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
                    NULL, 
                    CLSCTX_ALL,
                    IID_IHNetCfgMgr, 
                    (LPVOID*)((IHNetCfgMgr**)&spIHNetCfgMgr));

    if (FAILED(hr))
    {
        return hr;
    }

    Assert(spIHNetCfgMgr.p);

    CComPtr<IHNetBridgeSettings> spIHNetBridgeSettings;
    
    hr = spIHNetCfgMgr->QueryInterface(IID_IHNetBridgeSettings, 
                (void**)((IHNetBridgeSettings**) &spIHNetBridgeSettings));
    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IHNetBridge> spHNetBridge;
    hr = spIHNetBridgeSettings->CreateBridge( &spHNetBridge );
    if (FAILED(hr))
    {
        return hr;
    }

    for (cnt = 0; NULL != rgspNetConns[cnt]; cnt++)
    {
        CComPtr<IHNetConnection> spHNetConnection;
        hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( 
                                rgspNetConns[cnt], 
                                &spHNetConnection );

        if (FAILED(hr))
        {
            break;
        }

        CComPtr<IHNetBridgedConnection> spBridgedConn;
        
        hr = spHNetBridge->AddMember( spHNetConnection, &spBridgedConn );

        if (FAILED(hr))
        {
            break;
        }
    }

    //if failure, destroy the bridge that are just constructed
    if (FAILED(hr) && spHNetBridge.p)
    {
        spHNetBridge->Destroy();
    }
    
    if (SUCCEEDED(hr) && ppBridge)
    {
        *ppBridge = spHNetBridge;
        (*ppBridge)->AddRef();
    }
    
    return hr;
}

/*++

Routine Description:

    Enable the Personal Firewall on the connections

Arguments:

    rgspNetConns [IN] the array with a NULL terminator. Contains the connections 
                    that needs to turn firewall on


Return Value:

    standard HRESULT

--*/
HRESULT HrEnablePersonalFirewall(
            IN  INetConnection * rgspNetConns[]
            )
{
    HRESULT hr = S_OK;

    // Create Homenet Configuration Manager COM Instance
    // and obtain connection settings.
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;
    
    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
        NULL, 
        CLSCTX_ALL,
        IID_IHNetCfgMgr, 
        (LPVOID*)((IHNetCfgMgr**)&spIHNetCfgMgr));
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    Assert(spIHNetCfgMgr.p);

    HRESULT hrTemp = S_OK;

    CComPtr<IHNetConnection> spHNetConnection;
    for (int i = 0; NULL != rgspNetConns[i]; i++)
    {
        //release the ref count if we are holding one
        spHNetConnection = NULL;
        hrTemp = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( 
                                    rgspNetConns[i], 
                                    &spHNetConnection );
        
        if (SUCCEEDED(hr))
        {
            hr = hrTemp;
        }

        if (FAILED(hrTemp))
        {
            continue;
        }

        CComPtr<IHNetFirewalledConnection> spFirewalledConn;
        hrTemp = spHNetConnection->Firewall( &spFirewalledConn );

        if (SUCCEEDED(hr))
        {
            hr = hrTemp;
        }
    }
    

    return hr;
}

/*++

Routine Description:

    Enable ICS

Arguments:

    pPublicConnection [IN]  the public connection
    pPrivateConnection [IN] the private connection


Return Value:

    standard HRESULT

--*/
HRESULT HrCreateICS(
            IN INetConnection * pPublicConnection,
            IN INetConnection * pPrivateConnection
            )
{
    if (!pPublicConnection || !pPrivateConnection)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;
    
    hr = CoCreateInstance(CLSID_HNetCfgMgr, 
        NULL, 
        CLSCTX_ALL,
        IID_IHNetCfgMgr, 
        (LPVOID*)((IHNetCfgMgr**)&spIHNetCfgMgr));
    
    if (FAILED(hr))
    {
        return hr;
    }
    
    Assert(spIHNetCfgMgr.p);

    CComPtr<IHNetConnection> spHNetPubConn;
    hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( 
            pPublicConnection, 
            &spHNetPubConn );

    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr<IHNetConnection> spHNetPrivConn;
    hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection( 
            pPrivateConnection, 
            &spHNetPrivConn);
    
    if (FAILED(hr))
    {
        return hr;
    }

    
    CComPtr<IHNetIcsPublicConnection> spIcsPublicConn;
    hr = spHNetPubConn->SharePublic(&spIcsPublicConn);
    
    if (FAILED(hr))
    {
        return hr;
    }
        
    CComPtr<IHNetIcsPrivateConnection> spIcsPrivateConn;
    hr = spHNetPrivConn->SharePrivate(&spIcsPrivateConn);

    //roll back the changes if the operation failed
    if (FAILED(hr) && spIcsPublicConn.p)
    {
        spIcsPublicConn->Unshare();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\icsupgrd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I C S U P G R D . CPP
//
//  Contents:   Functions that is related to 
//              o upgrade of ICS from Win98 SE, WinMe and Win2K to Whistler
//              o unattended clean install of Homenet on Whistler or later
//
//  Date:       20-Sept-2000
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma  hdrstop
#include <winsock2.h>
#include <netcon.h>
#include <netconp.h>
#include <shfolder.h>
#include <hnetcfg.h>

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include "ncatl.h"
#include "ncui.h"

#include "ncstring.h"
#include "ncnetcfg.h"
#include "kkutils.h"
#include "kkcwinf.h"
#include "nslog.h"
#include "afilexp.h"
#include "ncras.h"
#include "ncreg.h"

extern "C" 
{
// Fix IA64 conflict with Shell Macro
#undef IS_ALIGNED
#include <ipnat.h>
}

#include "IcsUpgrd.h"
#include "resource.h" // need to use string resource ids


/*++

Routine Description:
    This function drives the FIcsUpgrade call by
    passing a init'ed and opened CWInfFile object.

Arguments:  
    None
                            

Returns:    TRUE if succeeded

Notes: 

--*/
BOOL FDoIcsUpgradeIfNecessary()
{
    BOOL    fRet = FALSE;
    HRESULT hr;
    tstring strAnswerFileName;
    
    hr = HrGetAnswerFileName(&strAnswerFileName);   
    if (S_OK == hr)
    {
        CWInfFile wifIcsAnswerFile;
    
        // initialize answer file
        if (wifIcsAnswerFile.Init())
        {
            if (wifIcsAnswerFile.Open(strAnswerFileName.c_str()))
            {
                TraceTag(ttidNetSetup, "calling FIcsUpgrade now..."); 
                
                fRet = FIcsUpgrade(&wifIcsAnswerFile);
                wifIcsAnswerFile.Close();
            }
            else
            {
                TraceTag(ttidNetSetup, "wifIcsAnswerFile.Open failed"); 
            }
        }
        else
        {
            TraceTag(ttidNetSetup, "wifIcsAnswerFile.Init failed"); 
        }
    }
    else
    {
        TraceTag(ttidNetSetup, "HrGetAnswerFileName failed");   
    }
    return fRet;
}

/*++

Routine Description:
    Perform the upgrade of 
    o ICS from Win98 SE, WinMe and Win2K
    o Unattended Homenet clean install
    
Arguments:  
    [in] pwifAnswerFile  The answer-file contains upgrade info from Win9x or 
                         Windows XP unattended clean install.

Returns:    TRUE if succeeded

Notes: 

--*/
BOOL FIcsUpgrade(CWInfFile* pwifAnswerFile)
{
    HRESULT hr = S_OK;
    ICS_UPGRADE_SETTINGS iusSettings;
    BOOL fUpgradeIcsToRrasNat = FALSE;
    BOOL fCoUninitialize = FALSE;


    DefineFunctionName("FIcsUpgrade");
    TraceFunctionEntry(ttidNetSetup);

    hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        fCoUninitialize = TRUE;
    }
    else
    {
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
        else
        {
            TraceTag(ttidError, 
                    "%s: CoInitialize failed: 0x%lx", 
                    __FUNCNAME__, hr);
            NetSetupLogStatusV(
                            LogSevError,
                            SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));

            return FALSE;
        }
    }

    do
    {
        SetIcsDefaultSettings(&iusSettings);

        // check if we are upgrading from Windows 2000
        if (FNeedIcsUpgradeFromWin2K())
        {
            hr = BuildIcsUpgradeSettingsFromWin2K(&iusSettings);
            if (FAILED(hr))
            {
                TraceTag(ttidError, 
                    "%s: BuildIcsUpgradeSettingsFromWin2K failed: 0x%lx", 
                    __FUNCNAME__, hr);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));
                
                break;
            }
            
            // ICS installed on Win2K if we are here
            if (FOsIsAdvServerOrHigher())
            {
                TraceTag(ttidNetSetup, 
                    "%s: We're running on ADS/DTC SKUs, won't upgrade ICS from Win2K.", 
                    __FUNCNAME__); 
                
                
                fUpgradeIcsToRrasNat = TRUE;
                break;
            }
            // OS version is less than Advanced Server if we are here
        }
        else 
        {
            // we need to check if we are doing ICS upgrade from Win9x or
            // doing unattended Homenet install on Windows XP or later
            if (NULL == pwifAnswerFile)
            {
                TraceTag(ttidNetSetup, 
                    "%s: Not an ICS Upgrade from Win2K and no answer-file.", 
                    __FUNCNAME__); 
                
                break;
            }
            // Try to load "Homenet" section data from Answer-File
            hr = LoadIcsSettingsFromAnswerFile(pwifAnswerFile, &iusSettings);
            if (S_FALSE == hr)
            {
                // no Homenet section
                hr = S_OK;
                break;
            }
            if (FAILED(hr))
            {
                TraceTag(ttidNetSetup, 
                    "%s: LoadIcsSettingsFromAnswerFile failed: 0x%lx", 
                    __FUNCNAME__, hr);

                // this may not be an error because of bug# 253074 in Win9x
                // OEM ICS upgrade
                // I'm not going to log this to setup log
                if (iusSettings.fEnableICS && iusSettings.fWin9xUpgrade)
                {
                    hr = S_OK; // ICS enabled but no internal/external adapters.
                }
                break;
            }

            // Assert: Answer file has valid [Homenet] section.
            // make sure OS SKU is less than Advanced Server
            if (FOsIsAdvServerOrHigher())
            {
                TraceTag(ttidNetSetup, 
                    "%s: We're running on ADS/DTC SKUs, won't do any homenet unattended setup.", 
                    __FUNCNAME__);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS_ADS_DTC));
                
                break;
            }
        }

        // upgrade ics settings to XP or do unattended Homenet if we 
        // can reach here
        hr = UpgradeIcsSettings(&iusSettings);
        if (S_OK != hr)
        {
            TraceTag(ttidError, 
                    "%s: UpgradeIcsSettings failed : 0x%lx", 
                    __FUNCNAME__, hr);   
            NetSetupLogStatusV(
                            LogSevInformation,
                            SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));
        }

    } while (FALSE);

    if (fUpgradeIcsToRrasNat)
    {   
        // If we are here, ICS installed on Win2K and this is an upgrade of OS
        // to ADS/DTC SKUs. We won't upgrade ICS on ADS/DTC SKUs
        TraceTag(ttidNetSetup, 
                "%s: We are not upgrading ICS on ADS/DTC SKUs", 
                __FUNCNAME__);
        
        // During the "Report System Compatiblilty" stage (winnt32.exe) of this
        // OS upgrade process, user has already been notified that we're not 
        // upgrading ICS on ADS/DTC SKUs.
        
        // we will still log a message to setupact.log file.
        NetSetupLogStatusV(
                            LogSevInformation,
                            SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS_ADS_DTC));

        // we need to delete and backup the old ICS registry settings
        hr = BackupAndDelIcsRegistryValuesOnWin2k();
        if (FAILED(hr))
        {
            TraceTag(ttidNetSetup, 
                    "%s: BackupAndDelIcsRegistryValuesOnWin2k failed: 0x%lx", 
                    __FUNCNAME__, hr);

        }
    }

    // Free iusSettings contents if needed
    FreeIcsUpgradeSettings(&iusSettings);

    if (fCoUninitialize)
    {
        CoUninitialize();
    }

    return (S_OK == hr? TRUE : FALSE);
}


//--------- ICS Upgrade helpers begin----------------------------

/*++

Routine Description:
    Gets the current shared ICS connection On Win2K

Arguments:  
    [out] pConnection  The shared connection information

Returns:    S_OK if succeeded

Notes: Returns the interface connected to the internet

--*/
HRESULT GetSharedConnectionOnWin2k(LPRASSHARECONN pConnection)
{
    HKEY   hKey = NULL;
    HRESULT hr = S_OK;

    DefineFunctionName("GetSharedConnectionOnWin2k");
    TraceFunctionEntry(ttidNetSetup);

    Assert(pConnection);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_wszRegKeySharedAccessParams, KEY_ALL_ACCESS, &hKey);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegOpenKeyEx failed: 0x%lx", 
            __FUNCNAME__, hr);

        return hr;
    }
    Assert(hKey);

    DWORD  dwType      = REG_BINARY;
    PBYTE  pByte       = NULL;
    DWORD  dwValueSize = 0;
    
    hr = HrRegQueryValueWithAlloc(hKey, c_wszRegValSharedConnection, &dwType, &pByte, &dwValueSize);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegQueryValueWithAlloc %S failed: 0x%lx", 
            __FUNCNAME__, c_wszRegValSharedConnection, hr);

        goto Exit;
    }
    if (dwValueSize > sizeof(RASSHARECONN))
    {
        TraceTag(ttidError, 
            "%s: RASSHARECONN size too big: 0x%lx bytes", 
            __FUNCNAME__, dwValueSize);

        hr = E_FAIL;
        goto Exit;
    }

    // transfer value
    memcpy(pConnection, pByte, dwValueSize);

Exit:
    // Close the key, if opened
    RegSafeCloseKey(hKey);

    // Clean up the registry buffer
    if (pByte)
    {
        MemFree(pByte);
    }

    return hr;
} 

/*++

Routine Description:
    Gets the current private LAN connection on Win2K

Arguments:  
    [out] pGuid  The private LAN information

Returns:    S_OK if succeeded

Notes: Returns the interface connected to the private LAN
       On Win2K, there is only 1 private LAN connection
       
--*/
HRESULT GetSharedPrivateLanOnWin2K(GUID *pGuid)
{
    HKEY   hKey = NULL;
    HRESULT hr = S_OK;

    DefineFunctionName("GetSharedPrivateLanOnWin2K");
    TraceFunctionEntry(ttidNetSetup);

    Assert(pGuid);
  
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_wszRegKeySharedAccessParams, KEY_ALL_ACCESS, &hKey);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegOpenKeyEx failed: 0x%lx", 
            __FUNCNAME__, hr);

        return hr;
    }
    Assert(hKey);
    
    DWORD  dwType      = REG_SZ;
    PBYTE  pByte       = NULL;
    DWORD  dwValueSize = 0;

    hr = HrRegQueryValueWithAlloc(hKey, c_wszRegValSharedPrivateLan, &dwType, &pByte, &dwValueSize);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegQueryValueWithAlloc %S failed: 0x%lx", 
            __FUNCNAME__, c_wszRegValSharedPrivateLan, hr);

        goto Exit;
    }
    // SharedPrivateLan is of type REG_SZ, pByte should have included 
    // the terminating null character.
    hr = CLSIDFromString(reinterpret_cast<PWCHAR>(pByte), pGuid);

Exit:
    // Close the key, if opened
    RegSafeCloseKey(hKey);

    // Clean up the registry buffer
    if (pByte)
    {
        MemFree(pByte);
    }

    return hr;
}

/*++

Routine Description:
    Delete and backup SharedConnection and SharedPrivateLan registry values

Arguments:  none

Returns:    S_OK if succeeded

Notes: 

--*/
HRESULT BackupAndDelIcsRegistryValuesOnWin2k()
{
    HKEY hKey  = NULL;
    HRESULT hr = S_OK;

    DefineFunctionName("BackupAndDelIcsRegistryValuesOnWin2k");
    TraceFunctionEntry(ttidNetSetup);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_wszRegKeySharedAccessParams, KEY_ALL_ACCESS, &hKey);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegOpenKeyEx failed: 0x%lx", 
            __FUNCNAME__, hr);

        return hr;
    }
    Assert(hKey);
    
    DWORD  dwType      = REG_BINARY;
    PBYTE  pByte       = NULL;
    DWORD  dwValueSize = 0;

    // backup SharedConnection
    hr = HrRegQueryValueWithAlloc(hKey, c_wszRegValSharedConnection, &dwType, &pByte, &dwValueSize);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegQueryValueWithAlloc %S failed: 0x%lx", 
            __FUNCNAME__, c_wszRegValSharedConnection, hr);

        goto Exit;
    }
    hr = HrRegSetValueEx(hKey, c_wszRegValBackupSharedConnection, dwType, pByte, dwValueSize);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegSetValueEx %S failed: 0x%lx", 
            __FUNCNAME__, c_wszRegValBackupSharedConnection, hr);

        goto Exit;
    }
    if (pByte)
    {
        MemFree(pByte);
    }
   
    // Reset values
    pByte       = NULL;
    dwValueSize = 0;
    dwType      = REG_SZ;

    // backup SharedPrivateLan
    hr = HrRegQueryValueWithAlloc(hKey, c_wszRegValSharedPrivateLan, &dwType, &pByte, &dwValueSize);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegQueryValueWithAlloc %S failed: 0x%lx", 
            __FUNCNAME__, c_wszRegValSharedPrivateLan, hr);

        goto Exit;
    }

    hr = HrRegSetValueEx(hKey, c_wszRegValBackupSharedPrivateLan, dwType, pByte, dwValueSize);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: HrRegSetValueEx %S failed: 0x%lx", 
            __FUNCNAME__, c_wszRegValBackupSharedPrivateLan, hr);

        goto Exit;
    }

Exit:
    // Delete SharedConnection and ShardPrivateLan named values, ignore any errors
    HrRegDeleteValue(hKey,  c_wszRegValSharedConnection);
    HrRegDeleteValue(hKey,  c_wszRegValSharedPrivateLan);

    RegSafeCloseKey(hKey);
    if (pByte)
    {
        MemFree(pByte);
    }

    return hr;
} 

/*++

Routine Description:
    Gets the RAS phonebook directory

Arguments:  
    [out] pszPathBuf    The phone book path

Returns:    S_OK if succeeded
Notes: 

--*/
HRESULT GetPhonebookDirectory(WCHAR* pwszPathBuf)
// Loads caller's 'pszPathBuf' (should have length MAX_PATH + 1) with the
// path to the directory containing phonebook files for the given mode,
// e.g. c:\nt\system32\ras\" for mode PBM_Router.  Note the
// trailing backslash.
//
// Returns true if successful, false otherwise.  Caller is guaranteed that
// an 8.3 filename will fit on the end of the directory without exceeding
// MAX_PATH.
//
{
    DefineFunctionName("GetPhonebookDirectory");
    TraceFunctionEntry(ttidNetSetup);


    HANDLE hToken = NULL;
    
    PFNSHGETFOLDERPATHW pfnSHGetFolderPathW;
    HINSTANCE Hinstance;
    
    //
    // Load ShFolder.dll, which contains the 'SHGetFolderPath' entrypoint
    // that we will use to get the Application data for all users path

    if (!(Hinstance = LoadLibraryW(c_wszShFolder)) ||
        !(pfnSHGetFolderPathW = (PFNSHGETFOLDERPATHW)
                            GetProcAddress(Hinstance, c_szSHGetFolderPathW))) 
    {
        if (Hinstance)
        {
            FreeLibrary(Hinstance);
        }
        return E_FAIL;
    }

    if ((OpenThreadToken(
        GetCurrentThread(), 
        TOKEN_QUERY | TOKEN_IMPERSONATE, 
        TRUE, 
        &hToken)
        || OpenProcessToken(
        GetCurrentProcess(), 
        TOKEN_QUERY | TOKEN_IMPERSONATE, 
        &hToken)))
    {
        HRESULT hr;
        INT csidl = CSIDL_COMMON_APPDATA;
        
        hr = pfnSHGetFolderPathW(NULL, csidl, hToken, 0, pwszPathBuf);
        
        if (SUCCEEDED(hr))
        {
            if(lstrlen(pwszPathBuf) <=
                (MAX_PATH - 
                (lstrlen(c_wszPhoneBookPath))))
            {
                lstrcat(pwszPathBuf, c_wszPhoneBookPath);
                CloseHandle(hToken);
                FreeLibrary(Hinstance);
                return S_OK;
            }
        }
        else
        {
            TraceTag(ttidError, "%s:  SHGetFolderPath failed: 0x%lx", 
                                            __FUNCNAME__, hr);
        }
        
        CloseHandle(hToken);
    }
    FreeLibrary(Hinstance);
    return E_FAIL;
}

/*++

Routine Description:

    CSharedAccessServer::CSharedAccessServer() Constructor

Arguments: none

Return Value: none

Notes: 

--*/
CSharedAccessServer::CSharedAccessServer()
{
    m_wPort = 0;
    m_wInternalPort = 0;
    m_bBuiltIn = FALSE;
    m_bSelected = FALSE;
    m_dwSectionNum = 0;
};



/*++

Routine Description:
    Returns the current list of Shared Access Servers

Arguments:  
    [in,out]  lstSharedAccessServers  List of SharedAccessServers

Returns:    S_OK if succeeded

Notes: Reads the sharedaccess.ini phonebook file for server mappings.

--*/
HRESULT GetServerMappings(list<CSharedAccessServer> &lstSharedAccessServers)
{
    WCHAR wszPathBuf[MAX_PATH + 1];
    HRESULT hr = GetPhonebookDirectory(wszPathBuf);
    if FAILED(hr)
        return hr;

    tstring strIniFile; // full pathname to sharedaccess.ini
    strIniFile = wszPathBuf;
    strIniFile += c_wszFileSharedAccess;

    const DWORD dwBufSize = 32768; // limit the section buffer size to the same value as Win9x max. buffer size 
    PWCHAR wszLargeReturnedString = new WCHAR[dwBufSize];
    if (NULL == wszLargeReturnedString)
    {
        return E_OUTOFMEMORY;
    }
    
    DWORD dwResult;
    dwResult = GetPrivateProfileSection(c_wszContentsServer, wszLargeReturnedString, dwBufSize-1, strIniFile.c_str());
    if (dwResult)
    {
        PWCHAR wszEnd = wszLargeReturnedString + dwResult;
        
        for (PWCHAR wszServer = wszLargeReturnedString; (*wszServer) && (wszServer < wszEnd); wszServer += wcslen(wszServer) + 1)
        {
            WCHAR  wszReturnedString[MAX_PATH];
            PWCHAR wszSectionNum = NULL;
            PWCHAR wszEnabled;
            
            // prefix bug# 295834
            wszSectionNum = new WCHAR[wcslen(wszServer)+1];
            if (NULL == wszSectionNum)
            {
                delete [] wszLargeReturnedString;
                return E_OUTOFMEMORY;
            }
            wcscpy(wszSectionNum, wszServer);
            PWCHAR wszAssign = wcschr(wszSectionNum, L'=');
            if (wszAssign)
            {
                *wszAssign = NULL;
                wszEnabled = wszAssign + 1;
            }
            else
            {
                wszEnabled = FALSE;
            }

            tstring strSectionName;
            strSectionName = c_wszServerPrefix; // prefix bug# 295835
            strSectionName += wszSectionNum;    // prefix bug# 295836
            
            CSharedAccessServer SharedAccessServer;
            SharedAccessServer.m_dwSectionNum = _wtoi(wszSectionNum);
            SharedAccessServer.m_bSelected = _wtoi(wszEnabled);
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszInternalName, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_szInternalName = wszReturnedString;
            }
            
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszTitle, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_szTitle = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszInternalPort, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_wInternalPort = static_cast<USHORT>(_wtoi(wszReturnedString));
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszPort, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_wPort = static_cast<USHORT>(_wtoi(wszReturnedString));
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszReservedAddress, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_szReservedAddress = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszProtocol, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_szProtocol = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszBuiltIn, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessServer.m_bBuiltIn = static_cast<USHORT>(_wtoi(wszReturnedString));
            }
            lstSharedAccessServers.insert(lstSharedAccessServers.end(), SharedAccessServer);
            delete [] wszSectionNum;
            wszSectionNum = NULL;
        }
    }

    delete [] wszLargeReturnedString;
    return S_OK;
}



/*++

Routine Description:
    Returns the current list of Shared Access Applications

Arguments:  
    [in,out]  lstSharedAccessApplications  List of SharedAccessApplications

Returns:    S_OK if succeeded

Notes: Reads the sharedaccess.ini phonebook file for application mappings.

--*/
HRESULT GetApplicationMappings(list<CSharedAccessApplication> &lstSharedAccessApplications)
{
    WCHAR wszPathBuf[MAX_PATH + 1];
    HRESULT hr = GetPhonebookDirectory(wszPathBuf);
    if FAILED(hr)
        return hr;

    tstring strIniFile; // full pathname to sharedaccess.ini
    strIniFile = wszPathBuf;
    strIniFile += c_wszFileSharedAccess;
    
    const DWORD dwBufSize = 32768; // limit the section buffer size to the same value as Win9x max. buffer size 
    PWCHAR wszLargeReturnedString = new WCHAR[dwBufSize];
    if (NULL == wszLargeReturnedString)
    {
        return E_OUTOFMEMORY;
    }

    DWORD dwResult;
    dwResult = GetPrivateProfileSection(c_wszContentsApplication, wszLargeReturnedString, dwBufSize-1, strIniFile.c_str());
    if (dwResult)
    {
        PWCHAR wszEnd = wszLargeReturnedString + dwResult;
        
        for (PWCHAR wszApplication = wszLargeReturnedString; (*wszApplication) && (wszApplication < wszEnd); wszApplication += wcslen(wszApplication) + 1)
        {
            WCHAR  wszReturnedString[MAX_PATH];
            PWCHAR wszSectionNum = NULL;
            PWCHAR wszEnabled;
            
            // prefix bug# 295838
            wszSectionNum = new WCHAR[wcslen(wszApplication)+1];
            if (NULL == wszSectionNum)
            {
                delete [] wszLargeReturnedString;
                return E_OUTOFMEMORY;
            }
            wcscpy(wszSectionNum, wszApplication);
            PWCHAR wszAssign = wcschr(wszSectionNum, L'=');
            if (wszAssign)
            {
                *wszAssign = NULL;
                wszEnabled = wszAssign + 1;
            }
            else
            {
                wszEnabled = FALSE;
            }

            tstring strSectionName;
            strSectionName = c_wszApplicationPrefix; // prefix bug# 295839
            strSectionName += wszSectionNum;         // prefix bug# 295840

            CSharedAccessApplication SharedAccessApplication;
            SharedAccessApplication.m_dwSectionNum = _wtoi(wszSectionNum);
            SharedAccessApplication.m_bSelected = _wtoi(wszEnabled);
            
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszTitle, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessApplication.m_szTitle = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszProtocol, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessApplication.m_szProtocol = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszPort, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessApplication.m_wPort = static_cast<USHORT>(_wtoi(wszReturnedString));
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszTcpResponseList, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessApplication.m_szTcpResponseList = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszUdpResponseList, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessApplication.m_szUdpResponseList = wszReturnedString;
            }
            dwResult = GetPrivateProfileString(strSectionName.c_str(), c_wszBuiltIn, L"", wszReturnedString, MAX_PATH, strIniFile.c_str());
            if (dwResult)
            {
                SharedAccessApplication.m_bBuiltIn = static_cast<USHORT>(_wtoi(wszReturnedString));
            }
            lstSharedAccessApplications.insert(lstSharedAccessApplications.end(), SharedAccessApplication);
            delete [] wszSectionNum;
            wszSectionNum = NULL;
        }
    }

    delete [] wszLargeReturnedString;
    return S_OK;
}

/*++

Routine Description:
    Add ResponseList string into vector of HNET_RESPONSE_RANGE

Arguments:     
    [in] rssaAppProt - ref. to the CSharedAccessApplication obj.
    [in] ucProtocol - NAT_PROTOCOL_TCP or NAT_PROTOCOL_UDP
    [out] rvecResponseRange - add new HNET_RESPONSE_RANGE(s) to this vector

Returns:    S_OK if succeeded
              
Notes: In case of failure, contents of rvecResponseRange will be erased.
       Design by contract: ucProtocol could only be NAT_PROTOCOL_TCP or
       NAT_PROTOCOL_UDP  
       
--*/
HRESULT AddResponseStringToVector(
    CSharedAccessApplication& rsaaAppProt,
    UCHAR ucProtocol,
    vector<HNET_RESPONSE_RANGE>& rvecResponseRange // vector of response range
    )
{
    WCHAR* Endp;
    USHORT EndPort;   // the End port # in the range of response port #
    USHORT StartPort; // the starting port # in the range of response port #
    const WCHAR* pwszValue = NULL; // the tcp or udp ResponseString to be converted. 
                                   // (e.g "1300-1310,1450" or "1245")
    HNET_RESPONSE_RANGE hnrrResponseRange; // the response range 
    HRESULT hr = S_OK;
    


    // select the ResponseList to be added
    if (NAT_PROTOCOL_TCP == ucProtocol)
    {
        pwszValue = rsaaAppProt.m_szTcpResponseList.c_str();
    }
    else if (NAT_PROTOCOL_UDP == ucProtocol)
    {
        pwszValue = rsaaAppProt.m_szUdpResponseList.c_str();
    }

    if (NULL == pwszValue)
    {
        // no operation
        goto Exit;
    }

    while (*pwszValue) 
    {
        // Read either a single port or a range of ports.
        if (!(StartPort = (USHORT)wcstoul(pwszValue, &Endp, 10))) 
        {
            hr = E_FAIL;
            goto Exit;
        } 
        else if (!*Endp || *Endp == L',') 
        {
            EndPort = StartPort;
            pwszValue = (!*Endp ? Endp : Endp + 1);
        } 
        else if (*Endp != L'-') 
        {
            hr = E_FAIL;
            goto Exit;
        } 
        else if (!(EndPort = (USHORT)wcstoul(++Endp, (WCHAR**)&pwszValue, 10))) 
        {
            hr = E_FAIL;
            goto Exit;
        } 
        else if (EndPort < StartPort) 
        {
            hr = E_FAIL;
            goto Exit;
        } 
        else if (*pwszValue && *pwszValue++ != L',') 
        {
            hr = E_FAIL;
            goto Exit;
        }
       
        // transfer values
        hnrrResponseRange.ucIPProtocol = ucProtocol;
        hnrrResponseRange.usStartPort = HTONS(StartPort);
        hnrrResponseRange.usEndPort = HTONS(EndPort);

        rvecResponseRange.push_back(hnrrResponseRange);
    }
Exit:
    if (FAILED(hr))
    {
        rvecResponseRange.erase(rvecResponseRange.begin(), rvecResponseRange.end());
    }
    return hr;
}

/*++

Routine Description:
    Converts ResponseList string into array of HNET_RESPONSE_RANGE

Arguments:  
      
      [in]  rssaAppProt - ref. to the CSharedAccessApplication obj.
      [out] puscResponse - number of HNET_RESPONSE_RANGE converted
      [out] pphnrrResponseRange - array of HNET_RESPONSE_RANGE converted

Returns:    S_OK if succeeded

Notes: User is responsible to free pphnrrResponseRange by
       "delete [] (BYTE*)(*pphnrrResponseRange)" if *puscResponse > 0

--*/
HRESULT PutResponseStringIntoArray(
    CSharedAccessApplication& rsaaAppProt, // Application Protocol
    USHORT* puscResponse,
    HNET_RESPONSE_RANGE** pphnrrResponseRange
    )
{
    HRESULT hr;
    DWORD dwIdx = 0;

    Assert(pphnrrResponseRange != NULL);
    Assert(puscResponse != NULL);
    *pphnrrResponseRange = NULL;
    *puscResponse = 0;

    vector<HNET_RESPONSE_RANGE> vecResponseRange; // vector of response range

    if (! rsaaAppProt.m_szTcpResponseList.empty()) 
    {
        //TcpResponseList is not empty
        hr = AddResponseStringToVector(rsaaAppProt, NAT_PROTOCOL_TCP, vecResponseRange);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    
    if (! rsaaAppProt.m_szUdpResponseList.empty()) 
    {
        // UdpResponseList is not empty
        hr = AddResponseStringToVector(rsaaAppProt, NAT_PROTOCOL_UDP, vecResponseRange);
        if (FAILED(hr))
        {
            return hr;
        }
    }
    
    HNET_RESPONSE_RANGE* phnrrResponseRange = NULL;
    USHORT uscResponseRange = (USHORT) vecResponseRange.size();
    if (1 > uscResponseRange)
    {
        // we should have at least 1 ReponseRange
        hr = E_FAIL;
        goto Exit;
    }

    phnrrResponseRange = (HNET_RESPONSE_RANGE*) 
                            new BYTE[sizeof(HNET_RESPONSE_RANGE) * uscResponseRange];
    if (phnrrResponseRange == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    for (vector<HNET_RESPONSE_RANGE>::iterator iter = vecResponseRange.begin();
                                                iter != vecResponseRange.end();
                                                ++iter, ++dwIdx)
    {
        phnrrResponseRange[dwIdx] = *iter;
    }
    // transfer values
    *pphnrrResponseRange = phnrrResponseRange;
    *puscResponse        = uscResponseRange;

Exit:
    vecResponseRange.erase(vecResponseRange.begin(), vecResponseRange.end());
    return hr;
}

/*++

Routine Description:
    Check if we need to upgrade ICS from Win2K

Returns:    TRUE or FALSE

Notes:  
          1. Check if registry value names (SharedConnection and
             SharedPrivateLan) exist.
          2. Check if sharedaccess.ini file exists
             After upgrade, the registry names should be deleted because
             ICS will use settings from WMI repository.
    We don't Check if the IPNATHLP service exists, because it is
    removed in ADS and DTC SKUs
--*/
BOOL FNeedIcsUpgradeFromWin2K()
{    
    // 1. Check if registry key values exist
    HKEY   hKey = NULL;
    HRESULT hr = S_OK;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_wszRegKeySharedAccessParams, KEY_ALL_ACCESS, &hKey);
    if (FAILED(hr))
    {
        return FALSE;
    }
    Assert(hKey);

    DWORD  dwType      = REG_BINARY;
    PBYTE  pByte       = NULL;
    DWORD  dwValueSize = 0;
    
    hr = HrRegQueryValueWithAlloc(hKey, c_wszRegValSharedConnection, &dwType, &pByte, &dwValueSize);
    if (FAILED(hr))
    {
        RegSafeCloseKey(hKey);
        return FALSE;
    }
    if (pByte)
    {
        MemFree(pByte);
    }
   
    // Reset values
    pByte       = NULL;
    dwValueSize = 0;
    dwType      = REG_SZ;
    
    hr = HrRegQueryValueWithAlloc(hKey, c_wszRegValSharedPrivateLan, &dwType, &pByte, &dwValueSize);
    if (FAILED(hr))
    {
        RegSafeCloseKey(hKey);
        return FALSE;
    }
    if (pByte)
    {
        MemFree(pByte);
    }

    // 2. Check if sharedaccess.ini file exists
    WCHAR wszPathBuf[MAX_PATH + 1];
    hr = GetPhonebookDirectory(wszPathBuf);
    if FAILED(hr)
        return FALSE;

    tstring strShareAccessFile;
    strShareAccessFile = wszPathBuf;
    strShareAccessFile += c_wszFileSharedAccess;
   
    HANDLE hOpenFile = 
            CreateFileW(strShareAccessFile.c_str(),          // open file
                GENERIC_READ,              // open for reading 
                FILE_SHARE_READ,           // share for reading 
                NULL,                      // no security 
                OPEN_EXISTING,             // existing file only 
                FILE_ATTRIBUTE_NORMAL,     // normal file 
                NULL);                     // no attr. template 

    if (INVALID_HANDLE_VALUE == hOpenFile)
    {
        return FALSE;
    }            
    CloseHandle(hOpenFile);
    
    return TRUE;
}

/*++

Routine Description:
    Upgrade ICS Settings

Arguments:
    [in] pIcsUpgradeSettings - the ICS UPGRADE SETTINGS

Returns:    standard HRESULT

Notes:  
  
--*/
HRESULT UpgradeIcsSettings(ICS_UPGRADE_SETTINGS * pIcsUpgrdSettings)
{
    HRESULT hr;

    DefineFunctionName("UpgradeIcsSettings");
    TraceFunctionEntry(ttidNetSetup);

    CIcsUpgrade IcsUpgradeObj;
    hr = IcsUpgradeObj.Init(pIcsUpgrdSettings);
    if (S_OK != hr)
    {
        TraceTag(ttidError, 
            "%s: IcsUpgradeObj.Init failed: 0x%lx", 
            __FUNCNAME__, hr);
        return hr;
    }
    return IcsUpgradeObj.StartUpgrade();
}


/*++

Routine Description:

    Build the ICS_UPGRADE_SETTINGS struct from Win2K ICS settings

Arguments:

    [in] pIcsUpgrdSettings - pointer to the ICS_UPGRADE_SETTINGS

Return Value: standard HRESULT

Notes: 

--*/
HRESULT BuildIcsUpgradeSettingsFromWin2K(ICS_UPGRADE_SETTINGS* pIcsUpgrdSettings)
{
    HRESULT hr;

    DefineFunctionName("BuildIcsUpgradeSettingsFromWin2K");
    TraceFunctionEntry(ttidNetSetup);

    Assert(pIcsUpgrdSettings != NULL);
    
    
    GUID guid;
    hr = GetSharedPrivateLanOnWin2K(&guid);
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: GetSharedPrivateLanOnWin2K failed: 0x%lx", 
                                           __FUNCNAME__, hr);
        return hr;
    }
    
    hr = GetSharedConnectionOnWin2k(&(pIcsUpgrdSettings->rscExternal));
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: GetSharedConnectionOnWin2k failed: 0x%lx", 
                                           __FUNCNAME__, hr);
        return hr;
    }

    hr = GetServerMappings(pIcsUpgrdSettings->listSvrPortmappings);
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: Ignore error from GetServerMappings : 0x%lx", 
                                           __FUNCNAME__, hr);
    }
    
    hr = GetApplicationMappings(pIcsUpgrdSettings->listAppPortmappings);
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: Ignore error from GetApplicationMappings : 0x%lx", 
                                           __FUNCNAME__, hr);
    }
    
    // transfer values
    pIcsUpgrdSettings->guidInternal          = guid;
    pIcsUpgrdSettings->fInternalAdapterFound = TRUE;
    pIcsUpgrdSettings->fDialOnDemand         = TRUE;
    pIcsUpgrdSettings->fEnableICS            = TRUE;
    pIcsUpgrdSettings->fShowTrayIcon         = TRUE;
    pIcsUpgrdSettings->fWin2KUpgrade         = TRUE;
    
    return S_OK;
}

/*++

Routine Description:

    Free resources inside the ICS_UPGRADE_SETTINGS

Arguments:

    [in] pIcsUpgrdSettings - pointer to the ICS_UPGRADE_SETTINGS

Return Value: none

    Note. 

--*/
void    FreeIcsUpgradeSettings(ICS_UPGRADE_SETTINGS* pIcsUpgrdSettings)
{
    Assert(pIcsUpgrdSettings != NULL);

    list<GUID>& rlistPersonalFirewall = pIcsUpgrdSettings->listPersonalFirewall;
    list<GUID>& rlistBridge = pIcsUpgrdSettings->listBridge;
    list<CSharedAccessServer>& rlistSvrPortmappings = pIcsUpgrdSettings->listSvrPortmappings;
    list<CSharedAccessApplication>& rlistAppPortmappings = pIcsUpgrdSettings->listAppPortmappings;

    rlistPersonalFirewall.erase(rlistPersonalFirewall.begin(), rlistPersonalFirewall.end());
    rlistBridge.erase(rlistBridge.begin(), rlistBridge.end());
    rlistSvrPortmappings.erase(rlistSvrPortmappings.begin(), rlistSvrPortmappings.end());
    rlistAppPortmappings.erase(rlistAppPortmappings.begin(), rlistAppPortmappings.end());
}

/*++

Routine Description:

    convert a list of adapter strings into a list of its corresponding GUID

Arguments:

    [in] rslAdapters - reference to the list of adapter strings
    [in out] rlistGuid - a list of the converted GUIDs
    
Return Value: 
    S_OK - if either all of the adapter strings converted to its corresponding
           GUIDs or the input is an empty list of adapter strings.
    S_FALSE - if it can convert at least one of the adaper strings.
    E_FAIL - if none of the adapter strings could be converted to its 
             corresponding GUIDs 

--*/
HRESULT ConvertAdapterStringListToGuidList(IN TStringList& rslAdapters, 
                                           IN OUT list<GUID>& rlistGuid)
{
    HRESULT hr        = S_OK;
    GUID guidTemp     = {0};
    tstring* pstrTemp = NULL;
    TStringList::iterator iter;

    if (rslAdapters.empty())
        return hr;

    // init the [in out] parameter first
    rlistGuid.erase(rlistGuid.begin(), rlistGuid.end());    
    
    for (iter = rslAdapters.begin(); iter != rslAdapters.end(); ++iter)
    {
        pstrTemp = *iter;
        
        Assert(pstrTemp);
        if (!FGetInstanceGuidOfComponentFromAnswerFileMap(pstrTemp->c_str(), &guidTemp))
        {
            TraceTag(ttidError, 
                "FGetInstanceGuidOfComponentFromAnswerFileMap failed to match GUID for adapter %S", 
                pstrTemp->c_str());
            NetSetupLogStatusV(
                LogSevInformation,
                SzLoadIds (IDS_TXT_E_ADAPTER_TO_GUID), 
                pstrTemp->c_str());
        }
        else
        {
            rlistGuid.push_back(guidTemp);
        }
    }

    if (rlistGuid.empty())
    {
        hr = E_FAIL;
    }
    if (rlistGuid.size() < rslAdapters.size())
    {
        hr = S_FALSE;
    }
    return hr;
}

/*++

Routine Description:

    remove duplicates in a TStringList

Arguments:

    [in, out] sl - the string list contains duplicates to be removed
    

Return Value: none


--*/
void RemoveDupsInTStringList(IN OUT TStringList& sl)
{
    for (list<tstring*>::iterator i = sl.begin(); i != sl.end(); ++i)
    {
        list<tstring*>::iterator tmpI = i;
        for (list<tstring*>::iterator j = ++tmpI; j != sl.end(); ++j)
        {
            list<tstring*>::iterator tmpJ = j;
            list<tstring*>::iterator k = --tmpJ;
            if (!_wcsicmp((*i)->c_str(), (*j)->c_str()))
            {
                TraceTag(ttidNetSetup, 
                    "RemoveDupsInTStringList: found duplicated string %S", 
                    (*i)->c_str());
                
                delete *j;   // free the resource
                sl.erase(j); // erase the list item
                j = k;       // adjust the iterator to the previous one
            }
        }

    }
}

/*++

Routine Description:

    remove items in slDest if the item is also in slSrc

Arguments:

    [in] slSrc - the source string list contains items to be matched
    [in, out] slDest - the string list where equal items are removed

Return Value: none

Note : Both slSrc and slDest MUST not contain duplicated items. 

--*/
void RemoveEqualItems(IN const TStringList& slSrc, IN OUT TStringList& slDest)
{
    list<tstring*>::iterator _F = slSrc.begin(), _L = slSrc.end(), pos;
    if (slDest.empty())
        return;
    while (_F != _L)
    {
        if (FIsInStringList(slDest, (*_F)->c_str(), &pos))
        {
            TraceTag(ttidNetSetup, 
                "RemoveEqualItems: '%S' appeared in both slSrc and slDest lists, remove it from slDest.", 
                (*_F)->c_str());

            // found a matched item.
            delete *pos;
            slDest.erase(pos);
            if (slDest.empty())
                return;
        }
        ++_F;
    }
}

/*++

Routine Description:

    remove item in slDest if the item is the same as pstrSrc

Arguments:

    [in] strSrc - the source string to be matched
    [in, out] slDest - the string list where equal item is removed

Return Value: none

Note : Both slDest MUST not contain duplicated items. 

--*/
void RemoveEqualItems(IN const tstring& strSrc, IN OUT TStringList& slDest)
{
    list<tstring*>::iterator pos;
    if (FIsInStringList(slDest,  strSrc.c_str(), &pos))
    {
        TraceTag(ttidNetSetup, 
            "RemoveEqualItems: remove '%S' from slDest.", 
            strSrc.c_str());

        // found a matched item.
        delete *pos;
        slDest.erase(pos);
        if (slDest.empty())
            return;
    }
}

/*++

Routine Description:
    Load Homenet settings from the answer file and put the
    settings into the ICS_UPGRADE_SETTINGS structure

Arguments:  
    [in]     pwifAnswerFile  the access point of the answer file
    [in/out] pSettings       it contains the settings when the 
                             routine returns S_OK

Returns:    S_OK if there are Homenet settings in the answer file
            S_FALSE: no Homenet settings present in the answer file
            otherwise the failure code

Notes:
    Bug# 253047, the Answer-File for a Win9x ICS upgrade will
    look like the following (if  Clean install WinMe, selecting custom 
    installation, and select ICS as an optional component.): 
[Homenet]
IsW9xUpgrade='1'
EnableICS="1"
ShowTrayIcon="1"
 
    Bug# 304474, in this case, Answer-File for a Win9x ICS upgrade will look 
    like (There is no value for ExternalAdapter or 
    ExternalConnectionName key.):
[Homenet]
IsW9xUpgrade='1'
InternalAdapter="Adapter2"
DialOnDemand="0"
EnableICS="1"
ShowTrayIcon="1"

    
More notes regarding validation of Answer File:
    1. if adapter found in both the PersonalFirewall list and Bridge list, 
       remove that adaper from the PersonalFirewall list.
    2. if ICS public LAN found in Bridge list, it will be removed from the
       Bridge list.
    3. if ICS private found in Firewall list, remove that adapter from the
       PersonalFirewall list.

--*/
HRESULT LoadIcsSettingsFromAnswerFile(
                        CWInfFile* pwifAnswerFile, 
                        PICS_UPGRADE_SETTINGS pSettings
                        )
{
    HRESULT hr = S_OK;
    BOOL fRet;
    PCWInfSection pwifSection = NULL;
    //BOOL fInternalAdapterFound = FALSE;

    DefineFunctionName("LoadIcsSettingsFromAnswerFile");
    TraceFunctionEntry(ttidNetSetup);
    
    Assert(pwifAnswerFile);
    Assert(pSettings);

    pwifSection = pwifAnswerFile->FindSection(c_wszHomenetSection);
    if (NULL == pwifSection)
        return S_FALSE;

    tstring strTemp;
    TStringList slICF, slBridge;  // hold comma-delimited string into a list
    GUID guidTemp = {0};
    BOOL fTemp = FALSE;

    do
    {
        // ICS Upgrade from Win9x or Unattended Homenet clean install


        // determine if this answer file is for Win9x upgrade or 
        // Homenet unattended clean install
        pSettings->fWin9xUpgrade = pwifSection->GetBoolValue(c_wszIsW9xUpgrade, FALSE);
        pSettings->fXpUnattended = !pSettings->fWin9xUpgrade;

        // default value for EnableICS is FALSE
        pSettings->fEnableICS = pwifSection->GetBoolValue(c_wszICSEnabled, FALSE);

        // default value for InternalIsBridge is FALSE
        pSettings->fInternalIsBridge = pwifSection->GetBoolValue(c_wszInternalIsBridge, FALSE);

        TraceTag(ttidNetSetup, 
            "IsW9xUpgrade: %S, EnableICS: %S, InternalIsBridge: %S",
                pSettings->fWin9xUpgrade        ? L"Yes" : L"No", 
                pSettings->fEnableICS           ? L"Yes" : L"No",
                pSettings->fInternalIsBridge    ? L"Yes" : L"No");

        //
        // get a list of interface GUID for the Internet Connection Firewall 
        // (ICF) and a list of interface GUID that forms the bridge. We'll also
        // do validation before converting adapter names to interface GUID
        //
        fRet = pwifSection->GetStringListValue(c_wszPersonalFirewall, slICF);
        if (fRet)
        {
            // remove duplicates within slICF
            RemoveDupsInTStringList(slICF);
        }
        fRet = pwifSection->GetStringListValue(c_wszBridge, slBridge);
        if (fRet)
        {
            // remove duplicates within slBridge
            RemoveDupsInTStringList(slBridge);
        }
        if (!slICF.empty() && !slBridge.empty())
        {
            // remove items in slICF if the item is also in slBridge
            RemoveEqualItems(slBridge, slICF);
        }

        // if ICS is enabled, get the share connection.
        // If the share connection is a LAN connection, make sure it is
        // not a member of the bridge.
        if (pSettings->fEnableICS)
        {
            fRet = pwifSection->GetStringValue(c_wszExternalAdapter, strTemp);
            if (fRet)
            {
                if (!FGetInstanceGuidOfComponentFromAnswerFileMap(strTemp.c_str(), &guidTemp))
                {
                    TraceTag(ttidError, 
                        "FGetInstanceGuidOfComponentFromAnswerFileMap failed to match GUID for adapter %S", 
                        strTemp.c_str());
                    NetSetupLogStatusV(
                        LogSevInformation,
                        SzLoadIds (IDS_TXT_E_ADAPTER_TO_GUID), 
                        strTemp.c_str());
                    
                    hr = E_FAIL;
                    break;
                }
                pSettings->rscExternal.fIsLanConnection = TRUE;
                pSettings->rscExternal.guid = guidTemp;
                // Another validation:
                // ICS public LAN adapter couldn't be a member of a bridge
                if (! slBridge.empty())
                {
                    RemoveEqualItems(strTemp, slBridge);
                }
            }
            else
            {
                // Can't find "ExternalAdapter" key in answer-file.
                // We'll try the "ExternalConnectionName" key.
                
                TraceTag(ttidNetSetup, 
                    "pwifSection->GetStringValue failed to get %S, we will try to get %S", 
                    c_wszExternalAdapter, c_wszExternalConnectionName);
                
                fRet = pwifSection->GetStringValue(c_wszExternalConnectionName, strTemp);
                if (! fRet)
                {
                    if (pSettings->fWin9xUpgrade)
                    {
                        TraceTag(ttidNetSetup, 
                            "pwifSection->GetStringValue failed to get %S too.", 
                            c_wszExternalConnectionName);
                        TraceTag(ttidNetSetup, 
                            "We will try to look for a WAN connectoid as the ExternalConnectionName.");
                        // Bug# 304474
                        // Cook up a fake WAN connectoid name, the code in 
                        // GetINetConnectionByName will later try to resolve it 
                        // to a WAN connectoid if there is *only 1* WAN 
                        // connectoid left on the system. WAN connectoid has 
                        // media types of either NCM_PHONE, NCM_ISDN or 
                        // NCM_TUNNEL.
                        lstrcpynW(pSettings->rscExternal.name.szEntryName, 
                            L"X1-2Bogus-3WAN-4Conn-5Name", 
                            celems(pSettings->rscExternal.name.szEntryName));
                    }
                    else
                    {
                        TraceTag(ttidError, 
                            "pwifSection->GetStringValue failed to get %S too.", 
                            c_wszExternalConnectionName);
                        
                        hr = E_FAIL;
                        break;
                    }
                }
                else
                {
                    lstrcpynW(pSettings->rscExternal.name.szEntryName, 
                        strTemp.c_str(), 
                        celems(pSettings->rscExternal.name.szEntryName));
                }
                
                pSettings->rscExternal.fIsLanConnection = FALSE;
            }
        }

        // convert bridge adapter names to interface GUID
        if (!slBridge.empty())
        {
            hr = ConvertAdapterStringListToGuidList(slBridge, pSettings->listBridge);
            if (FAILED(hr))
            {
                TraceTag(
                    ttidError, 
                    "Error in converting Personal Firewall string list to GUID list");
                break;
            }
            if (S_FALSE == hr)
            {
                hr = S_OK; // convert any S_FALSE to S_OK
            }
        }
        // we will convert the slICF list later because we need to check if
        // ICS private adapter is also in slICF, if yes, we need to remove it 
        // from the slICF list.
        
        //
        // get the internal adapter GUID
        //
        fRet = pwifSection->GetStringValue(c_wszInternalAdapter, strTemp);
        if (fRet && !pSettings->fInternalIsBridge && !pSettings->fEnableICS)
        {
            // invalid parameters from answer file (AF) 
            TraceTag(ttidError, 
                "Invalid AF settings: InternalAdapter=%S, InternalIsBridge='0', EnableICS='0'.", 
                strTemp.c_str());
            NetSetupLogStatusV(
                LogSevInformation,
                SzLoadIds (IDS_TXT_HOMENET_INVALID_AF_SETTINGS));
            
            hr = E_FAIL;
            break;
            
        }
        if (fRet && pSettings->fInternalIsBridge)
        {
            TraceTag(ttidError, 
                "Invalid AF settings: InternalAdapter=%S, InternalIsBridge='1'.", 
                strTemp.c_str());
            NetSetupLogStatusV(
                LogSevInformation,
                SzLoadIds (IDS_TXT_HOMENET_INVALID_AF_SETTINGS));
            
            hr = E_FAIL;
            break;
        }
        if (fRet)
        {
            // get the internal adapter GUID if InternalIsBridge is '0'
            Assert(!pSettings->fInternalIsBridge);
            if (!FGetInstanceGuidOfComponentFromAnswerFileMap(strTemp.c_str(), &guidTemp))
            {
                    TraceTag(ttidError, 
                        "FGetInstanceGuidOfComponentFromAnswerFileMap failed to match GUID for adapter %S", 
                        strTemp.c_str());
                    NetSetupLogStatusV(
                        LogSevInformation,
                        SzLoadIds (IDS_TXT_E_ADAPTER_TO_GUID), 
                        strTemp.c_str());
                
                    hr = E_FAIL;
                    break;
            }
            else
            {
                pSettings->fInternalAdapterFound = TRUE;
                pSettings->guidInternal = guidTemp;
                // another validation:
                // remove ICS private from the firewall list (slICF) 
                // if necessary.
                if (!slICF.empty())
                {
                    RemoveEqualItems(strTemp, slICF);
                }
            }
        }

        // check for other answer file errors
        if (pSettings->fWin9xUpgrade && !pSettings->fEnableICS)
        {
            TraceTag(
                ttidError, 
                "Invalid AF settings: IsW9xUpgrade='1', EnableICS='0'");
            
            hr = E_FAIL;
            break;
        }

        // special case for Win9x ICS upgrade. 
        if ( pSettings->fWin9xUpgrade)
        { 
            // Bug# 315265
            if ( pSettings->fInternalIsBridge &&
                 1 == (pSettings->listBridge).size() )
            {
                // for Win9x ICS upgrade, one of the 2 internal adapters is 
                // broken, we will continue to do the upgrade without creating 
                // the internal bridge.

                // adjust answer file parameters
                pSettings->fWin9xUpgradeAtLeastOneInternalAdapterBroken = TRUE;
                pSettings->fInternalAdapterFound = TRUE;
                pSettings->guidInternal = *((pSettings->listBridge).begin());
                // note: On Win9x ICS upgrade, there will be no firewall list,
                //       so, we don't try to remove this ICS private from the
                //       firewall list (slICF).
                pSettings->fInternalIsBridge = FALSE;
                pSettings->listBridge.erase(pSettings->listBridge.begin(), 
                                        pSettings->listBridge.end());

                TraceTag(
                    ttidNetSetup, 
                    "On Win9x ICS upgrade, one internal adapter couldn't be upgraded.");
            }
        }

        if ( (pSettings->fInternalIsBridge && (pSettings->listBridge).size() < 2) ||
                (1 == (pSettings->listBridge).size()) )
        {
            TraceTag(
                ttidError, 
                "Invalid setting: fInternalIsBridge: %S, size of listBridge: %d",
                pSettings->fInternalIsBridge ? L"TRUE" : L"FALSE",
                (pSettings->listBridge).size());
            NetSetupLogStatusV(
                LogSevInformation,
                SzLoadIds (IDS_TXT_HOMENET_INVALID_AF_SETTINGS));

            hr = E_FAIL;
            break;
        }

        if ( pSettings->fEnableICS && 
            !pSettings->fInternalIsBridge &&
            !pSettings->fInternalAdapterFound)
        {
            // Bug# 304474 falls under this case
            TraceTag(
                ttidError, 
                "Invalid AF settings: no InternalAdapter, InternalIsBridge='0', EnableICS='1'.");
            NetSetupLogStatusV(
                LogSevInformation,
                SzLoadIds (IDS_TXT_HOMENET_INVALID_AF_SETTINGS));

            hr = E_FAIL;
            break;
        }

        // convert firewall adapter names to interface GUID
        if (!slICF.empty())
        {
            hr = ConvertAdapterStringListToGuidList(slICF, pSettings->listPersonalFirewall);
            if (FAILED(hr))
            {
                TraceTag(
                    ttidError, 
                    "Error in converting Personal Firewall string list to GUID list");
                break;
            }  
            if (S_FALSE == hr)
            {
                hr = S_OK; // convert any S_FALSE to S_OK
            }
        }

        // default value for DialOnDemand is FALSE
        pSettings->fDialOnDemand = pwifSection->GetBoolValue(c_wszDialOnDemand, FALSE);

        // default value for ShowTrayIcon is TRUE
        pSettings->fShowTrayIcon = pwifSection->GetBoolValue(c_wszShowTrayIcon, TRUE);
      

    } while(FALSE);

    // free resource if necessary
    EraseAndDeleteAll(&slICF);
    EraseAndDeleteAll(&slBridge);
    return hr;
}

/*++

Routine Description:

    Set some default values into ICS_UPGRADE_SETTINGS

Arguments:

    [in] pIcsUpgrdSettings - pointer to the ICS_UPGRADE_SETTINGS

Return Value: none

    Note. 

--*/
void SetIcsDefaultSettings(ICS_UPGRADE_SETTINGS * pSettings)
{
    //initialize the settings here
    pSettings->fDialOnDemand = FALSE;
    pSettings->fEnableICS    = FALSE;
    pSettings->fShowTrayIcon = TRUE;

    pSettings->fWin9xUpgrade = FALSE;
    pSettings->fWin9xUpgradeAtLeastOneInternalAdapterBroken = FALSE;

    pSettings->fWin2KUpgrade = FALSE;
    pSettings->fXpUnattended = FALSE;
    pSettings->fInternalIsBridge = FALSE;
    pSettings->fInternalAdapterFound = FALSE;
}

/*++

Routine Description:

    Check current OS version

Arguments:

    None
Return Value: returns TRUE if current OS version is Adv. Server or higher

    Note. 

--*/
BOOL FOsIsAdvServerOrHigher()
{
    OSVERSIONINFOEXW verInfo = {0};
    ULONGLONG ConditionMask = 0;

    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    verInfo.wSuiteMask   = VER_SUITE_ENTERPRISE;
    verInfo.wProductType = VER_NT_SERVER;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    return VerifyVersionInfo(&verInfo,
                        VER_PRODUCT_TYPE | VER_SUITENAME,
                        ConditionMask);
}

//--------- ICS Upgrade helpers end -----------------------------



//--------- HNet helpers begin ----------------------------------
// extract from %sdxroot%\net\rras\ras\ui\common\nouiutil\noui.c
DWORD
IpPszToHostAddr(
    IN  LPCTSTR cp )

    // Converts an IP address represented as a string to
    // host byte order.
    //
{
    DWORD val, base, n;
    TCHAR c;
    DWORD parts[4], *pp = parts;

again:
    // Collect number up to ``.''.
    // Values are specified as for C:
    // 0x=hex, 0=octal, other=decimal.
    //
    val = 0; base = 10;
    if (*cp == TEXT('0'))
        base = 8, cp++;
    if (*cp == TEXT('x') || *cp == TEXT('X'))
        base = 16, cp++;
    while (c = *cp)
    {
        if ((c >= TEXT('0')) && (c <= TEXT('9')))
        {
            val = (val * base) + (c - TEXT('0'));
            cp++;
            continue;
        }
        if ((base == 16) &&
            ( ((c >= TEXT('0')) && (c <= TEXT('9'))) ||
              ((c >= TEXT('A')) && (c <= TEXT('F'))) ||
              ((c >= TEXT('a')) && (c <= TEXT('f'))) ))
        {
            val = (val << 4) + (c + 10 - (
                        ((c >= TEXT('a')) && (c <= TEXT('f')))
                            ? TEXT('a')
                            : TEXT('A') ) );
            cp++;
            continue;
        }
        break;
    }
    if (*cp == TEXT('.'))
    {
        // Internet format:
        //  a.b.c.d
        //  a.b.c   (with c treated as 16-bits)
        //  a.b (with b treated as 24 bits)
        //
        if (pp >= parts + 3)
            return (DWORD) -1;
        *pp++ = val, cp++;
        goto again;
    }

    // Check for trailing characters.
    //
    if (*cp && (*cp != TEXT(' ')))
        return 0xffffffff;

    *pp++ = val;

    // Concoct the address according to
    // the number of parts specified.
    //
    n = (DWORD) (pp - parts);
    switch (n)
    {
    case 1:             // a -- 32 bits
        val = parts[0];
        break;

    case 2:             // a.b -- 8.24 bits
        val = (parts[0] << 24) | (parts[1] & 0xffffff);
        break;

    case 3:             // a.b.c -- 8.8.16 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
            (parts[2] & 0xffff);
        break;

    case 4:             // a.b.c.d -- 8.8.8.8 bits
        val = (parts[0] << 24) | ((parts[1] & 0xff) << 16) |
              ((parts[2] & 0xff) << 8) | (parts[3] & 0xff);
        break;

    default:
        return 0xffffffff;
    }

    return val;
}

/*++

Routine Description:

    Sets the standard COM security settings on the proxy for an
    object.

Arguments:

    pUnk - the object to set the proxy blanket on

Return Value:

    Note. Even if the CoSetProxyBlanket calls fail, pUnk remains
    in a usable state. Failure is expected in certain contexts, such
    as when, for example, we're being called w/in the netman process --
    in this case, we have direct pointers to the netman objects, instead
    of going through a proxy.

--*/
VOID SetProxyBlanket(IUnknown *pUnk)
{
    HRESULT hr;

    Assert(pUnk);

    hr = CoSetProxyBlanket(
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE
            );

    if (SUCCEEDED(hr)) 
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(&pUnkSet);
        if (SUCCEEDED(hr)) 
        {
            hr = CoSetProxyBlanket(
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE
                    );
                    
            pUnkSet->Release();
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CIcsUpgrade public methods
/////////////////////////////////////////////////////////////////////////////
/*++

Routine Description:

    Init ourself with the pIcsUpgradeSettings, we also cache the
    IEnumNetConnection object in our m_spEnum.

Arguments:

    [in] pIcsUpgradeSettings - the ICS UPGRADE SETTINGS

Return Value:

    standard HRESULT

--*/

HRESULT CIcsUpgrade::Init(ICS_UPGRADE_SETTINGS * pIcsUpgradeSettings)
{
    HRESULT hr;

    if (!pIcsUpgradeSettings)
    {
        return E_INVALIDARG;
    }

    if (pIcsUpgradeSettings->fWin9xUpgrade)
    {
        // validate parameters for Win9x ICS upgrade
        if (!pIcsUpgradeSettings->fEnableICS)
        {
            return E_INVALIDARG;
        }
        if (pIcsUpgradeSettings->fInternalIsBridge)
        {
            // internal is a bridge
            if ( (pIcsUpgradeSettings->listBridge).size() < 2 ) 
            {
                return E_INVALIDARG;
            }
        }
        else
        {
            if (!pIcsUpgradeSettings->fInternalAdapterFound)
            {
                return E_INVALIDARG;
            }
        }
    }
    else if (pIcsUpgradeSettings->fWin2KUpgrade)
    {
        // validate parameters for Win2K ICS upgrade
        if (pIcsUpgradeSettings->fInternalIsBridge || 
            !pIcsUpgradeSettings->fEnableICS ||
            !pIcsUpgradeSettings->fInternalAdapterFound)
        {
            return E_INVALIDARG;
        }

    }
   
    if (!m_fInited)
    {
        // Get the net connection manager
        INetConnectionManager *pConnMan;

        hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                                CLSCTX_ALL,
                                IID_INetConnectionManager,
                                (LPVOID *)&pConnMan);
        if (S_OK == hr)
        {
            // Get the enumeration of connections
            SetProxyBlanket(pConnMan);
            hr = pConnMan->EnumConnections(NCME_DEFAULT, &m_spEnum);
            pConnMan->Release();
        }
        else
        {
            return E_FAIL;
        }

        if (S_OK == hr)
        {
            SetProxyBlanket(m_spEnum);
            m_fInited = TRUE;
        }
        else
        {
            return E_FAIL;
        }
    }
    m_pIcsUpgradeSettings = pIcsUpgradeSettings;
    return S_OK;
}

/*++

Routine Description:

    Enable ICS on external adapter and internal adapters.
    Enable personal firewall on the external adapter.
    Migrating the server and application port mappings.

Arguments:

    None

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::StartUpgrade()
{
    HRESULT hr;

    DefineFunctionName("CIcsUpgrade::StartUpGrade");
    TraceFunctionEntry(ttidNetSetup);
    
    if (m_fInited)
    {
        if (m_pIcsUpgradeSettings->fWin2KUpgrade)
        {
            // we need to delete Win2K registry named value
            hr = BackupAndDelIcsRegistryValuesOnWin2k();
            if (FAILED(hr))
            {
                TraceTag(ttidError, 
                    "%s: Ignore BackupAndDelIcsRegistryValuesOnWin2k failed: 0x%lx", 
                    __FUNCNAME__, hr);
            }
        
            hr = SetupApplicationProtocol();
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: SetupApplicationProtocol failed: 0x%lx", 
                                    __FUNCNAME__, hr);
                return hr;
            }
            hr = SetupServerPortMapping();
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: SetupServerPortMapping failed: 0x%lx", 
                                    __FUNCNAME__, hr);
                return hr;
            }
        }

        hr = SetupHomenetConnections();
        if (FAILED(hr))
        {
            TraceTag(ttidError, "%s: SetupHomenetConnections failed: 0x%lx", 
                                __FUNCNAME__, hr);
            return hr;
        }

        hr = SetupIcsMiscItems();
        if (FAILED(hr))
        {
            TraceTag(ttidError, 
                    "%s: Ignore SetupIcsMiscItems failed: 0x%lx", 
                    __FUNCNAME__, hr);
        }
    }
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CIcsUpgrade private methods
/////////////////////////////////////////////////////////////////////////////
/*++

Routine Description:

    Free all cached resources,
    CComPtr smart pointer will be released when this object is out of scope or
    being deleted.

Arguments:

    None

Return Value:

    None

--*/
void CIcsUpgrade::FinalRelease()
{
    if (m_pExternalNetConn)
    {
        m_pExternalNetConn->Release();
        m_pExternalNetConn = NULL;
    }
    

    if (m_hIcsUpgradeEvent)
    {
        CloseHandle(m_hIcsUpgradeEvent);
        m_hIcsUpgradeEvent = NULL;
    }
}

/*++
Routine Description:

    Setup Homenet connections based on parameters from m_pIcsUpgradeSettings.

Arguments:

    None

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::SetupHomenetConnections()
{
    DefineFunctionName("CIcsUpgrade::SetupHomenetConnections");
    TraceFunctionEntry(ttidNetSetup);

    HRESULT hr = S_OK;
    INetConnection** prgINetConn = NULL; // array of INetConnection*
    DWORD cINetConn = 0; // number of INetConnection* in the array
    INetConnection* pExternalNetConn = NULL;
    INetConnection* pInternalNetConn = NULL;

    // Create a named event to notify other components that we're
    // in GUI Mode ICS Upgrade. Reason: sharedaccess service
    // fails to start during the GUI Mode Setup. 
    hr = CreateIcsUpgradeNamedEvent();
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: CreateIcsUpgradeNamedEvent failed: 0x%lx", 
            __FUNCNAME__, hr);

        return hr;
    }

    // create a bridge if we have more than 1 adapter guid
    if ( (m_pIcsUpgradeSettings->listBridge).size() > 1 )
    {
        do
        {
        
            hr = GetINetConnectionArray(m_pIcsUpgradeSettings->listBridge, 
                                        &prgINetConn, &cINetConn);
            TraceTag(ttidNetSetup, 
                "after GetINetConnectionArray for bridge.");
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: GetINetConnectionArray failed: 0x%lx line: %d", 
                        __FUNCNAME__, hr, __LINE__);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_CREATE_BRIDGE));
            
                break;
            }
            
            TraceTag(ttidNetSetup, "calling HNetCreateBridge.");
            hr = HNetCreateBridge(prgINetConn, NULL);
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: HNetCreateBridge failed: 0x%lx", 
                        __FUNCNAME__, hr);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_CREATE_BRIDGE));
            
                break;
            }
        } while (FALSE);

        // free resource if necessary
        for (DWORD i = 0; i < cINetConn ; ++i)
        {
            if (prgINetConn[i])
                prgINetConn[i]->Release();
        }
        if (prgINetConn)
        {
            delete [] (BYTE*)prgINetConn;
        }
        prgINetConn = NULL;
        cINetConn   = 0;
    }


    // create ICS
    if (m_pIcsUpgradeSettings->fEnableICS)
    {
        do
        {
            if (m_pExternalNetConn == NULL)
            {   // no cached copy
                hr = GetExternalINetConnection(&pExternalNetConn);
                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: GetExternalINetConnection failed: 0x%lx", 
                            __FUNCNAME__, hr);
                    NetSetupLogStatusV(
                        LogSevInformation,
                        SzLoadIds (IDS_TXT_CANT_CREATE_ICS));

                    break;
                }
            }
            else
            {
                pExternalNetConn = m_pExternalNetConn; // use the cached copy
            }

            if (m_pIcsUpgradeSettings->fInternalIsBridge)
            {
                hr = GetBridgeINetConn(&pInternalNetConn);
                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: GetBridgeINetConn failed: 0x%lx", 
                            __FUNCNAME__, hr);
                    NetSetupLogStatusV(
                        LogSevInformation,
                        SzLoadIds (IDS_TXT_CANT_CREATE_ICS));

                    break;
                }
            }
            else
            {
                hr = GetINetConnectionByGuid(
                                        &m_pIcsUpgradeSettings->guidInternal,
                                        &pInternalNetConn);
                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: GetINetConnectionByGuid failed: 0x%lx line: %d", 
                            __FUNCNAME__, hr, __LINE__);
                    NetSetupLogStatusV(
                        LogSevInformation,
                        SzLoadIds (IDS_TXT_CANT_CREATE_ICS));

                    break;
                }
            }

            TraceTag(ttidNetSetup, "calling HrCreateICS.");
            hr = HrCreateICS(pExternalNetConn, pInternalNetConn);
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: HNetCreateBridge failed: 0x%lx", 
                        __FUNCNAME__, hr);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_CREATE_ICS));
                
                break;
            }
            m_fICSCreated = TRUE;
        } while (FALSE);
        
        // cleanup if necessary
        if (pInternalNetConn)
        {
            pInternalNetConn->Release();
        }
        if (FAILED(hr))
        {
            if (pExternalNetConn && !m_pExternalNetConn)
            {
                pExternalNetConn->Release();
            }
        }
        else
        {
            // cache External INetConnections if necessary
            if (!m_pExternalNetConn)
            {
                m_pExternalNetConn = pExternalNetConn;
            }
        }
    }
    
    // enable firewall on each connection specified from answer file
    // note: ICS private couldn't be firewalled, bridge couldn't be firewalled.
    if ( (m_pIcsUpgradeSettings->listPersonalFirewall).size() > 0 )
    {
        do
        {
            hr = GetINetConnectionArray(
                            m_pIcsUpgradeSettings->listPersonalFirewall, 
                            &prgINetConn, &cINetConn);
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: GetINetConnectionArray failed: 0x%lx line: %d", 
                        __FUNCNAME__, hr, __LINE__);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_FIREWALL));

                break;
            }
        
            TraceTag(ttidNetSetup, "calling HrEnablePersonalFirewall.");
            hr = HrEnablePersonalFirewall(prgINetConn);
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: HrEnablePersonalFirewall failed: 0x%lx", 
                        __FUNCNAME__, hr);
                NetSetupLogStatusV(
                LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_FIREWALL));
            
                break;
            }
        } while(FALSE);

        // free resource if necessary
        for (DWORD i = 0; i < cINetConn ; ++i)
        {
            if (prgINetConn[i])
                prgINetConn[i]->Release();
        }
        if (prgINetConn)
        {
            delete [] (BYTE*)prgINetConn;
        }
        prgINetConn = NULL;
        cINetConn   = 0;
    }

    return hr;
}

/*++

Routine Description:
    Get an array of INetConnection interface pointers 
    corresponds to a list of GUID in rlistGuid.
    
Arguments:
    [in]      rlistGuid - a list of interface Guid.
    [in, out] pprgInternalNetConn - an array of INetConnection*
    [in, out] pcInternalNetConn - number of INetConnection* in the array

Return Value:
    standard HRESULT

Note :
    -User needs to release the returned INetConnection interface pointers in 
     the array.
    -User needs to free the memory allocated for the array by using
     "delete [] (BYTE*)prgInternalNetConn".
    -The array is NULL terminated (similar to "char** argv" argument in 
      main())

--*/

HRESULT CIcsUpgrade::GetINetConnectionArray(
    IN     list<GUID>&       rlistGuid,
    IN OUT INetConnection*** pprgINetConn, 
    IN OUT DWORD*            pcINetConn)
{
    DefineFunctionName("CIcsUpgrade::GetINetConnectionArray");
    TraceFunctionEntry(ttidNetSetup);

    HRESULT hr;

    Assert(pprgINetConn);
    Assert(pcINetConn);

    *pprgINetConn = NULL;
    *pcINetConn   = 0;


    DWORD cConnections = rlistGuid.size();
    if (cConnections < 1)
    {
        return E_FAIL;
    }

    // Note that we allocated an extra entry since this is a null-terminated 
    // array
    DWORD dwSize = (cConnections + 1) * sizeof(INetConnection*);
    INetConnection** prgINetConn =  (INetConnection**) new BYTE[dwSize];
    if (prgINetConn)
    {
        ZeroMemory((PVOID) prgINetConn, dwSize);
        DWORD i = 0;
        for (list<GUID>::iterator iter = rlistGuid.begin(); 
                iter != rlistGuid.end(); ++iter, ++i)
        {
            hr = GetINetConnectionByGuid( &(*iter), &prgINetConn[i]);
            if (FAILED(hr))
            {
                for (DWORD j = 0; j < i; ++j)
                {
                    if (prgINetConn[j])
                    {
                        prgINetConn[j]->Release();
                    }
                }
                delete [] (BYTE*)prgINetConn;
                return hr;
            }
        }
    }
    else
    {
         hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        *pcINetConn = cConnections;
        *pprgINetConn = prgINetConn;
    }

    return hr;
}

/*++

Routine Description:

    Retrieves the INetConnection that corresponds to the LPRASSHARECONN
    in m_pIcsUpgradeSettings->pExternal.

Arguments:

    [out] ppNetConn - receives the interface

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::GetExternalINetConnection(INetConnection** ppNetConn)
{
    LPRASSHARECONN pRasShareConn = &(m_pIcsUpgradeSettings->rscExternal);
    
    if (pRasShareConn->fIsLanConnection)
    {
        return GetINetConnectionByGuid(&(pRasShareConn->guid), ppNetConn);
    }
    else
    {
        return GetINetConnectionByName((pRasShareConn->name).szEntryName, 
                                        ppNetConn);
    }
}

/*++

Routine Description:

    Retrieves the INetConnection that corresponds to the given GUID.
    We will enumerate the INetConnection using our cached m_spEnum.

Arguments:

    [in]  pGuid - the guid of the connection
    [out] ppNetCon - receives the interface

Return Value:

    standard HRESULT

--*/
HRESULT
CIcsUpgrade::GetINetConnectionByGuid(
    GUID* pGuid,
    INetConnection** ppNetCon)
{
    HRESULT hr;
    INetConnection* pConn;

    Assert(NULL != pGuid);
    Assert(NULL != ppNetCon);
    
    *ppNetCon = NULL;

    // Search for the connection with the correct guid
        
    ULONG ulCount;
    BOOLEAN fFound = FALSE;

#if DBG
    WCHAR szGuid[c_cchGuidWithTerm];       
    if (SUCCEEDED(StringFromGUID2(*pGuid, szGuid, c_cchGuidWithTerm)))
    {
        TraceTag(ttidNetSetup, "GetINetConnectionByGuid: pGuid is: %S", szGuid);
    }
#endif
        
    // reset our cache m_spEnum
    m_spEnum->Reset();
    do
    {
        NETCON_PROPERTIES* pProps;
            
        hr = m_spEnum->Next(1, &pConn, &ulCount);
        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            SetProxyBlanket(pConn);

            hr = pConn->GetProperties(&pProps);
            if (S_OK == hr)
            {
                if (IsEqualGUID(pProps->guidId, *pGuid))
                {
                    fFound = TRUE;
                    *ppNetCon = pConn;
                    (*ppNetCon)->AddRef();
                }
                    
                NcFreeNetconProperties(pProps);
            }

            pConn->Release();
        }
    } while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

    // Normalize hr
    hr = (fFound ? S_OK : E_FAIL);

    return hr;
}

/*++

Routine Description:

    Retrieves the INetConnection that corresponds to the given Name
    of the Connection Icon in Network Connection Folder.
    We will enumerate the INetConnection using our cached m_spEnum.

Arguments:

    [in]  pwszConnName - the connection name to search
    [out] ppNetCon - receives the interface

Return Value:

    standard HRESULT

Note: Bug# 304474: If we couldn't find the INetConnection corresponding
      to the given name from the pwszConnName parameter and there is
      exactly one WAN MediaType connection left, we'll return the
      INetconnection for that WAN connection. WAN media types are either
      NCM_PHONE, NCM_ISDN or NCM_TUNNEL.

--*/
HRESULT CIcsUpgrade::GetINetConnectionByName(
    WCHAR* pwszConnName, 
    INetConnection** ppNetCon)
{
    HRESULT hr;
    INetConnection* pConn;

    Assert(NULL != pwszConnName);
    Assert(NULL != ppNetCon);
    
    *ppNetCon = NULL;

    TraceTag(ttidNetSetup, "GetINetConnectionByName: pwszConnName: %S", pwszConnName); 

    // Search for the connection with the correct connection name
        
    ULONG           ulCount;
    BOOLEAN         fFound     = FALSE;
    INetConnection* pWANConn   = NULL;
    ULONG           ulcWANConn = 0;
    
    // reset our cache m_spEnum
    m_spEnum->Reset();
    do
    {
        NETCON_PROPERTIES* pProps;
            
        hr = m_spEnum->Next(1, &pConn, &ulCount);
        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            SetProxyBlanket(pConn);

            hr = pConn->GetProperties(&pProps);
            if (S_OK == hr)
            {
                TraceTag(ttidNetSetup, "GetINetConnectionByName: Connection Name: %S", pProps->pszwName);
      
                if (    (NCM_PHONE == pProps->MediaType) || 
                        (NCM_ISDN  == pProps->MediaType) ||
                        (NCM_TUNNEL  == pProps->MediaType)
                    )
                {
                    TraceTag(
                        ttidNetSetup, 
                        "GetINetConnectionByName: Connection Name: %S is WAN, MediaType is %d", 
                        pProps->pszwName, pProps->MediaType);
                    ulcWANConn++;
                    if (1 == ulcWANConn)
                    {
                        // save the 1st WAN connection found
                        TraceTag(ttidNetSetup, "GetINetConnectionByName: Connection Name: %S is 1st WAN found", pProps->pszwName);
                        pWANConn = pConn;  
                        pWANConn->AddRef();
                    }
                }
                if (wcscmp(pProps->pszwName, pwszConnName) == 0)
                {
                    fFound = TRUE;
                    *ppNetCon = pConn;
                    (*ppNetCon)->AddRef();
                }
                    
                NcFreeNetconProperties(pProps);
            }

            pConn->Release();
        }
    }
    while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

    if (fFound)
    {
        if (pWANConn)
        {
            // No matter how many WAN connections we have,
            // release the saved WAN connection.
            pWANConn->Release();
        }
    }
    else
    {
        TraceTag(ttidNetSetup, "GetINetConnectionByName: Can't find pwszConnName: %S", pwszConnName); 
        
        // no connection has the name specified by the pwszConnName [in] parameter
        if (1 == ulcWANConn && pWANConn)
        {
            // There is exactly ONE WAN connection left on the sysetm.
            // Transfer this as the INetConnection output.
            TraceTag(ttidNetSetup, "GetINetConnectionByName: will use the only one WAN connectoid left"); 
            *ppNetCon = pWANConn;
            fFound = TRUE;
        }
        else if (ulcWANConn > 1 && pWANConn)
        {
            // not found and there are more than 1 WAN connections
            TraceTag(ttidNetSetup, "GetINetConnectionByName: more than one WAN connectoid found"); 
            pWANConn->Release();
        }
    }

    // Normalize hr
    hr = (fFound ? S_OK : E_FAIL);

    return hr;
}

/*++

Routine Description:

    Setup the global Application Protocol

Arguments:

    None

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::SetupApplicationProtocol()
{
    DefineFunctionName("CIcsUpgrade::SetupApplicationProtocol");
    TraceFunctionEntry(ttidNetSetup);

    HRESULT hr;
    list<CSharedAccessApplication>& rListAppProt = 
                        m_pIcsUpgradeSettings->listAppPortmappings;

    if ( rListAppProt.size() == 0)
    {
        // no Application Protocol to set
        return S_OK;
    }


    // 1. Get the INetProtocolSettings interface to control system-wide
    //    ICS and firewall settings (i.e port mappings and applications).

    // Create Homenet Configuration Manager COM Instance
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, 
                                CLSCTX_ALL,
                                IID_IHNetCfgMgr, 
                                (LPVOID *)&spIHNetCfgMgr);
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: CoCreateInstance CLSID_HNetCfgMgr failed: 0x%lx", 
                                           __FUNCNAME__, hr);
        return hr;
    }
  
    // Get the IHNetProtocolSettings      
    CComPtr<IHNetProtocolSettings> spHNetProtocolSettings;
    hr = spIHNetCfgMgr->QueryInterface(IID_IHNetProtocolSettings, 
                                        (LPVOID *)&spHNetProtocolSettings);

    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: QueryInterface IID_IHNetProtocolSettings failed: 0x%lx", 
                                           __FUNCNAME__, hr);
        return hr;
    }

    
    // 2. For each enabled CSharedAccessApplication
    //      if (there is no existing matching ApplicationProtocol
    //          invoke INetProtocolSettings::CreateApplicationProtocol
    //      else
    //          update the existing ApplicaitonProtocol
    for (list<CSharedAccessApplication>::iterator iter = rListAppProt.begin();
                                                iter != rListAppProt.end();
                                                ++iter)
    {
        HNET_RESPONSE_RANGE* pHNetResponseArray = NULL;
        USHORT uscResponseRange = 0; // number of HNET_RESPONSE_RANGE returned

        if ((*iter).m_bSelected)
        {
            // migrate the enabled one only
            UCHAR ucProtocol;
            if (lstrcmpiW( ((*iter).m_szProtocol).c_str(), c_wszTCP) == 0)
            {
                ucProtocol = NAT_PROTOCOL_TCP;
            }
            else if (lstrcmpiW( ((*iter).m_szProtocol).c_str(), c_wszUDP) == 0)
            {
                ucProtocol = NAT_PROTOCOL_UDP;
            }
            else
            {
                // ignore others
                continue;
            }
            USHORT usPort = HTONS((*iter).m_wPort);
            WCHAR* pwszTitle = (WCHAR*)((*iter).m_szTitle).c_str();

            hr = PutResponseStringIntoArray(*iter, &uscResponseRange, 
                                            &pHNetResponseArray);
            if (FAILED(hr))
            {
                TraceTag(ttidError, 
                        "%s:  Ignore error in PutResponseStringIntoArray : 0x%lx", 
                        __FUNCNAME__, hr);
            }
            if (S_OK == hr)
            {
                Assert(pHNetResponseArray != NULL);
                CComPtr<IHNetApplicationProtocol> spHNetAppProt;

                hr = FindMatchingApplicationProtocol(
                        spHNetProtocolSettings, ucProtocol, usPort, 
                        &spHNetAppProt);
                if (S_OK == hr)
                {
                    TraceTag(ttidNetSetup, 
                                "%s: Update existing ApplicationProtocol for %S", 
                                __FUNCNAME__, pwszTitle);
                    // there is existing ApplicatonProtocol
                    hr = spHNetAppProt->SetName(pwszTitle);
                    if (S_OK != hr)
                    {
                        TraceTag(ttidError, "%s: spHNetAppProt->SetName failed: 0x%lx", 
                                           __FUNCNAME__, hr);
                    }
                    
                    hr = spHNetAppProt->SetResponseRanges(uscResponseRange,
                                        pHNetResponseArray);
                    if (S_OK != hr)
                    {
                        TraceTag(ttidError, "%s: spHNetAppProt->SetResponseRanges failed: 0x%lx", 
                                           __FUNCNAME__, hr);
                    }

                    hr = spHNetAppProt->SetEnabled(TRUE);
                    if (S_OK != hr)
                    {
                        TraceTag(ttidError, "%s: spHNetAppProt->SetEnabled failed: 0x%lx", 
                                           __FUNCNAME__, hr);
                    }

                }
                else
                {
                    // no existing ApplicationProtocol, create a new one
                    hr =  spHNetProtocolSettings->CreateApplicationProtocol(
                            pwszTitle,
                            ucProtocol,
                            usPort,
                            uscResponseRange,
                            pHNetResponseArray,
                            &spHNetAppProt);
                    if (S_OK != hr)
                    {
                        TraceTag(ttidError, 
                                "%s:  CreateApplicationProtocol failed: 0x%lx", 
                                __FUNCNAME__, hr);
                    }
                    else
                    {
                        hr = spHNetAppProt->SetEnabled(TRUE);
                        if (S_OK != hr)
                        {
                            TraceTag(ttidError, 
                                    "%s: spHNetAppProt->SetEnabled failed: 0x%lx", 
                                    __FUNCNAME__, hr);
                        }
                    }
                }
                
                delete [] (BYTE*) pHNetResponseArray;
                pHNetResponseArray = NULL;
                uscResponseRange = 0;
            }
        }
    } //end for

    return S_OK;
}

/*++

Routine Description:

    Setup the Server Port Mapping Protocol on the external connection.

Arguments:

    None

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::SetupServerPortMapping()
{
    HRESULT hr;
    list<CSharedAccessServer>& rListSvrPortMappings = 
                        m_pIcsUpgradeSettings->listSvrPortmappings;
    
    DefineFunctionName("CIcsUpgrade::SetupServerPortMapping");
    TraceFunctionEntry(ttidNetSetup);

    if ( rListSvrPortMappings.size() == 0 )
    {
        // no Server Port Mappings to set
        return S_OK;
    }

    // 1. Get the INetProtocolSettings interface to control system-wide
    //    ICS and firewall settings (i.e port mappings and applications).

    // Create Homenet Configuration Manager COM Instance
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, 
                                CLSCTX_ALL,
                                IID_IHNetCfgMgr, 
                                (LPVOID *)&spIHNetCfgMgr);
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: CoCreateInstance CLSID_HNetCfgMgr failed: 0x%lx", 
                                           __FUNCNAME__, hr);
        return hr;
    }
  
    // Get the IHNetProtocolSettings      
    CComPtr<IHNetProtocolSettings> spHNetProtocolSettings;
    hr = spIHNetCfgMgr->QueryInterface(IID_IHNetProtocolSettings, 
                                        (LPVOID *)&spHNetProtocolSettings);

    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: QueryInterface IID_IHNetProtocolSettings failed: 0x%lx", 
                                           __FUNCNAME__, hr);
        return hr;
    }

    // 2. For each enabled CSharedAccessServer x
    //      if (there is no PortMapping Protocol corresponding to the
    //          x.m_szProtocol and x.m_wInternalPort)
    //          call INetProtocolSettings::CreatePortMappingProtocol 
    //          to get an IHNetPortMappingProtocol interface ptr;
    //      else
    //          get an existing IHNetPortMappingProtocol interface ptr
    //          
    //      Get IHNetPortMappingBinding interface ptr by calling
    //      IHNetConnection::GetBindingForPortMappingProtocol by passing the
    //      IHNetPortMappingProtocol iface ptr on the public IHNetConnection;
    //      call IHNetPortMappingBinding::SetTargetComputerName;
    for (list<CSharedAccessServer>::iterator iter = 
                                    rListSvrPortMappings.begin();
                                    iter != rListSvrPortMappings.end();
                                    ++iter)
    { 
        // migrate the enabled one only
        if ((*iter).m_bSelected)
        {
            UCHAR ucProtocol;
            if (lstrcmpiW( ((*iter).m_szProtocol).c_str(), c_wszTCP) == 0)
            {
                ucProtocol = NAT_PROTOCOL_TCP;
            }
            else if (lstrcmpiW( ((*iter).m_szProtocol).c_str(), c_wszUDP) == 0)
            {
                ucProtocol = NAT_PROTOCOL_UDP;
            }
            else
            {
                // ignore others
                continue;
            }
            USHORT usPort = HTONS((*iter).m_wInternalPort);
            WCHAR* pwszTitle = (WCHAR*) ((*iter).m_szTitle).c_str();

            // get the IHNetPortMappingProtocol iface ptr
            CComPtr<IHNetPortMappingProtocol> spHNetPortMappingProt;
            
            hr = FindMatchingPortMappingProtocol(
                spHNetProtocolSettings, ucProtocol, usPort, 
                &spHNetPortMappingProt);
            if (S_OK == hr)
            {
                TraceTag(ttidNetSetup, 
                                "%s: Update existing PortMappingProtocol for %S", 
                                __FUNCNAME__, pwszTitle);
                // change the name of the title
                hr= spHNetPortMappingProt->SetName(pwszTitle);
                if (FAILED(hr))
                {
                    TraceTag(ttidError, 
                            "%s: spHNetPortMappingProt->SetName failed: 0x%lx", 
                            __FUNCNAME__, hr);
                    hr = S_OK;  // we still want to invoke 
                                // IHNetPortMappingBinding::SetEnabled() below.
                }
            }
            else
            {
                TraceTag(ttidNetSetup, 
                                "%s: CreatePortMappingProtocol for %S", 
                                __FUNCNAME__, pwszTitle);
                // no existing PortMappingProtocol, create a new one
                hr =  spHNetProtocolSettings->CreatePortMappingProtocol(
                            pwszTitle,               // Title
                            ucProtocol,              // Protocol
                            usPort,                  // InternalPort           
                            &spHNetPortMappingProt); // returned iface ptr
                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: CreatePortMappingProtocol failed: 0x%lx", 
                                           __FUNCNAME__, hr);
                }
            }

            if (S_OK == hr)
            {
                CComPtr<IHNetConnection> spExternalHNetConn;

                if (m_pExternalNetConn == NULL)
                {
                    hr = GetExternalINetConnection(&m_pExternalNetConn);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidError, "%s: GetExternalINetConnection failed: 0x%lx", 
                                           __FUNCNAME__, hr);
                        return hr; // fatal return
                    }
                }
                

                // get the external/public IHNetConnection iface ptr
                hr = spIHNetCfgMgr->GetIHNetConnectionForINetConnection(
                                                        m_pExternalNetConn,
                                                        &spExternalHNetConn);
                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: GetIHNetConnectionForINetConnection failed: 0x%lx", 
                                           __FUNCNAME__, hr);
                }
                if (S_OK == hr)
                {
                    // Get IHNetPortMappingBinding interface ptr
                    CComPtr<IHNetPortMappingBinding> spHNetPortMappingBinding;
                    
                    hr = spExternalHNetConn->GetBindingForPortMappingProtocol(
                                                    spHNetPortMappingProt,
                                                    &spHNetPortMappingBinding);
                    if (FAILED(hr))
                    {
                        TraceTag(ttidError, 
                                "%s: GetBindingForPortMappingProtocol failed: 0x%lx", 
                                __FUNCNAME__, hr);
                        return hr;
                    }
                    if (S_OK == hr)
                    {
                        ULONG ulAddress = INADDR_NONE;
                        WCHAR* pwszInternalName = (OLECHAR *)((*iter).m_szInternalName).c_str();
                        if ( ((*iter).m_szInternalName).length() > 7)
                        {
                            // 1.2.3.4 -- minimum of 7 characters
                            ulAddress = IpPszToHostAddr(pwszInternalName);
                        }
        
                        if (INADDR_NONE == ulAddress)
                        {
                            hr = spHNetPortMappingBinding->SetTargetComputerName(
                                                                    pwszInternalName);
                           
                            if (FAILED(hr))
                            {
                                TraceTag(ttidError, 
                                        "%s: SetTargetComputerName failed: 0x%lx", 
                                        __FUNCNAME__, hr);
                            }
                        }
                        else
                        {
                            hr = spHNetPortMappingBinding->SetTargetComputerAddress(
                                                                    HTONL(ulAddress));
                            if (FAILED(hr))
                            {
                                TraceTag(ttidError, 
                                        "%s: SetTargetComputerAddress failed: 0x%lx", 
                                        __FUNCNAME__, hr);
                            }
                        }
                        if (S_OK == hr)
                        {
                            hr = spHNetPortMappingBinding->SetEnabled(TRUE);
                            if (FAILED(hr))
                            {
                                TraceTag(ttidError, 
                                            "%s: SetEnabled failed: 0x%lx", 
                                            __FUNCNAME__, hr);
                            }
                        }

                    }

                }
            }
        } // end if ((*iter).m_bSelected)
    } //end for  

    return S_OK;
}

/*++

Routine Description:

    retrive a matching IHNetPortMappingProtocol object which matches the
    given protocol (ucProtocol) and port number (usPort)

Arguments:

    [in] pHNetProtocolSettings - IHNetProtocolSettings iface ptr
    [in] ucProtocol - NAT_PROTOCOL_TCP or NAT_PROTOCOL_UDP
    [in] usPort - port number used by this server PortMapping Protocol
    [out] ppHNetPortMappingProtocol - return the matching 
                                      IHNetPortMappingProtocol
Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::FindMatchingPortMappingProtocol(
    IHNetProtocolSettings*      pHNetProtocolSettings, 
    UCHAR                       ucProtocol, 
    USHORT                      usPort, 
    IHNetPortMappingProtocol**  ppHNetPortMappingProtocol)
{
    HRESULT hr;

    Assert(pHNetProtocolSettings != NULL);
    Assert(ppHNetPortMappingProtocol != NULL);

    DefineFunctionName("CIcsUpgrade::FindMatchingPortMappingProtocol");
    TraceFunctionEntry(ttidNetSetup);
    
    
    *ppHNetPortMappingProtocol = NULL;

    CComPtr<IEnumHNetPortMappingProtocols> spServerEnum;
    hr = pHNetProtocolSettings->EnumPortMappingProtocols(
                                        &spServerEnum);
    if (FAILED(hr))
    {
        return hr;
    }
   
    IHNetPortMappingProtocol* pServer;

    ULONG ulCount;
    do
    {
        UCHAR ucFoundProtocol;
        USHORT usFoundPort;

        hr = spServerEnum->Next(
                        1,
                        &pServer,
                        &ulCount
                        );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            hr = pServer->GetIPProtocol(&ucFoundProtocol);
            if (FAILED(hr))
            {
                pServer->Release();
                return hr;
            }
            hr = pServer->GetPort(&usFoundPort);
            if (FAILED(hr))
            {
                pServer->Release();
                return hr;
            }

            if (ucFoundProtocol == ucProtocol &&
                usFoundPort == usPort)
            {
                // found mathcing one, transfer value
                *ppHNetPortMappingProtocol = pServer;
                return S_OK;
            }
            pServer->Release();
        }
    } while (SUCCEEDED(hr) && 1 == ulCount);

    return E_FAIL;  // not found          
}


/*++

Routine Description:

    retrive a matching IHNetApplicationProtocol object which matches the
    given protocol (ucProtocol) and port number (usPort)

Arguments:

    [in] pHNetProtocolSettings - IHNetProtocolSettings iface ptr
    [in] ucProtocol - NAT_PROTOCOL_TCP or NAT_PROTOCOL_UDP
    [in] usPort - port number used by this server PortMapping Protocol
    [out] ppHNetApplicationProtocol - return the matching 
                                      IHNetApplicationProtocol
Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::FindMatchingApplicationProtocol(
    IHNetProtocolSettings*      pHNetProtocolSettings, 
    UCHAR                       ucProtocol, 
    USHORT                      usPort, 
    IHNetApplicationProtocol**  ppHNetApplicationProtocol)
{
    HRESULT hr;

    Assert(pHNetProtocolSettings != NULL);
    Assert(ppHNetApplicationProtocol != NULL);

    DefineFunctionName("CIcsUpgrade::FindMatchingApplicationProtocol");
    TraceFunctionEntry(ttidNetSetup);
    
    
    *ppHNetApplicationProtocol = NULL;

    CComPtr<IEnumHNetApplicationProtocols> spAppEnum;
    hr = pHNetProtocolSettings->EnumApplicationProtocols(
                                        FALSE,
                                        &spAppEnum);
    if (FAILED(hr))
    {
        return hr;
    }
   
    IHNetApplicationProtocol* pApp;

    ULONG ulCount;
    do
    {
        UCHAR ucFoundProtocol;
        USHORT usFoundPort;

        hr = spAppEnum->Next(
                        1,
                        &pApp,
                        &ulCount
                        );

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            hr = pApp->GetOutgoingIPProtocol(&ucFoundProtocol);
            if (FAILED(hr))
            {
                pApp->Release();
                return hr;
            }
            hr = pApp->GetOutgoingPort(&usFoundPort);
            if (FAILED(hr))
            {
                pApp->Release();
                return hr;
            }

            if (ucFoundProtocol == ucProtocol &&
                usFoundPort == usPort)
            {
                // found mathcing one, transfer value
                *ppHNetApplicationProtocol = pApp;
                return S_OK;
            }
            pApp->Release();
        }
    } while (SUCCEEDED(hr) && 1 == ulCount);

    return E_FAIL;  // not found          
}

/*++

Routine Description:

    Setup ICS misc. settings from m_pIcsUpgradeSettings

Arguments:

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::SetupIcsMiscItems()
{
    HRESULT hr = S_OK;

    if (NULL == m_pIcsUpgradeSettings)
    {
        return E_UNEXPECTED;
    }

    DefineFunctionName("CIcsUpgrade::SetupIcsMiscItems");
    TraceFunctionEntry(ttidNetSetup);

    if (!m_fICSCreated)
    {
        // no need to continue if ICS has not been created
        return hr;
    }

    // If Win9x/Win2K ICS upgrade, firewall the ICS public connection
    if (m_pIcsUpgradeSettings->fWin9xUpgrade ||
        m_pIcsUpgradeSettings->fWin2KUpgrade)
    {
        INetConnection* rgINetConn[2] = {0, 0}; 
        if (m_pExternalNetConn)
        {
            rgINetConn[0] = m_pExternalNetConn;
            hr = HrEnablePersonalFirewall(rgINetConn);
            if (FAILED(hr))
            {
                TraceTag(ttidError, "%s: HrEnablePersonalFirewall failed: 0x%lx line: %d", 
                    __FUNCNAME__, hr, __LINE__);
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_FIREWALL));

                hr = S_OK; // continue with the rest.
            }
        }
    }

    // Bug# 315265, 315242
    // post-processing to fix up IP Configuration on private connection
    // (1) if there is at least one internal adapter couldn't be upgraded from
    //     Win9x ICS upgrade, we have to make sure the survival internal adapter 
    //     has static IP address 192.168.0.1, subnet mask 255.255.255.0
    // (2) if we create a bridge for Win9x ICS upgrade, we need to set static
    //     IP address 192.168.0.1, subnet mask 255.255.255.0 for TcpIp bound to 
    //     the bridge.
    // Note: (1) and (2) are exclusive.
    //
    // For WinXP Unattended clean install, 
    // (3) if an internal ICS adapter is found, set static IP address 
    //     192.168.0.1, subnet mask 255.255.255.0 for the TCPIP bound to the 
    //     internal adapter.
    // (4) if ICS is enabled and the bridge is the ICS private connection. 
    //     Set static IP address 192.168.0.1, subnet mask 255.255.255.0 for
    //     TcpIp bound to the bridge.
    // Note: (3) and (4) are exclusive.
    if ( m_pIcsUpgradeSettings->fInternalAdapterFound && 
        (m_pIcsUpgradeSettings->fWin9xUpgradeAtLeastOneInternalAdapterBroken || 
         m_pIcsUpgradeSettings->fXpUnattended) )
    {
        hr = SetPrivateIpConfiguration(m_pIcsUpgradeSettings->guidInternal);
        if (FAILED(hr))
        {
            // logging, but we'll continue to do the rest of the ICS upgrade though.
            TraceTag(ttidError, 
                    "%s: SetPrivateIpConfiguration on private adapter failed: 0x%lx", 
                    __FUNCNAME__, hr);
            NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));
        }
    }
    else if ( ((m_pIcsUpgradeSettings->listBridge).size() >= 2) &&
                !m_pIcsUpgradeSettings->fInternalAdapterFound)
    {
        // A bridge was created as ICS private. 
        // We need to setup its static IP Configuration since
        // these settings are not configured when it was created a while ago.
        GUID guidBridge;
        hr = GetBridgeGuid(guidBridge);
        if (SUCCEEDED(hr))
        {
            hr = SetPrivateIpConfiguration(guidBridge);
            if (FAILED(hr))
            {
                // logging, but we'll continue to do the rest of the ICS upgrade though.
                TraceTag(ttidError, 
                        "%s: SetPrivateIpConfiguration for bridge failed: 0x%lx", 
                        __FUNCNAME__, hr);
                NetSetupLogStatusV(
                        LogSevInformation,
                        SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));
            
            } 

        }
        else
        {
            // logging, but we'll continue to do the rest of the ICS upgrade though.
            TraceTag(ttidError, 
                    "%s: GetBridgeGuid failed: 0x%lx", 
                    __FUNCNAME__, hr);
            NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));
        }
    }

    LPRASSHARECONN pRasShareConn = &(m_pIcsUpgradeSettings->rscExternal);

    // set the fShowTrayIcon to the external INetConnection
    // note: this property has already migrated for Win2K upgrade
    if ( (m_pExternalNetConn) &&
            (m_pIcsUpgradeSettings->fWin9xUpgrade || 
             m_pIcsUpgradeSettings->fXpUnattended) )
    {
        if (pRasShareConn->fIsLanConnection)
        {
            INetLanConnection* pLanConn = NULL;
            
            hr = HrQIAndSetProxyBlanket(m_pExternalNetConn, &pLanConn);
            if (SUCCEEDED(hr) && pLanConn)
            {
                LANCON_INFO linfo = {0};
                linfo.fShowIcon = m_pIcsUpgradeSettings->fShowTrayIcon;
                // Set new value of show icon property
                hr = pLanConn->SetInfo(LCIF_ICON, &linfo);
                
                if (FAILED(hr))
                {
                    TraceTag(ttidError, "%s: pLanConn->SetInfo failed: 0x%lx", 
                                           __FUNCNAME__, hr);

                }                   
                pLanConn->Release();
            }
            else
            {
                TraceTag(
                    ttidError, 
                    "%s: HrQIAndSetProxyBlanket for  INetLanConnection failed: 0x%lx", 
                    __FUNCNAME__, hr);
            }
        }
        else
        {
            // this is a WAN connection

            RASCON_INFO rci;
            LPRASENTRY  pRasEntry = NULL;
            DWORD       dwRasEntrySize;
            
            hr = HrRciGetRasConnectionInfo(m_pExternalNetConn, &rci); 
            if (SUCCEEDED(hr))
            {
                hr = HrRasGetEntryProperties(rci.pszwPbkFile, rci.pszwEntryName, 
                                                &pRasEntry, &dwRasEntrySize);
                if (SUCCEEDED(hr) && pRasEntry)
                {
                    DWORD dwRet;
                               
                    if (m_pIcsUpgradeSettings->fShowTrayIcon)
                        pRasEntry->dwfOptions |= RASEO_ModemLights;
                    else
                        pRasEntry->dwfOptions &= (~RASEO_ModemLights);
                            
                    dwRet = RasSetEntryProperties(rci.pszwPbkFile, rci.pszwEntryName, 
                                                    pRasEntry, dwRasEntrySize, 0, 0);
                    if (0 != dwRet)
                    {
                        TraceTag(
                            ttidError, 
                            "%s: RasSetEntryProperties failed: 0x%lx", 
                            __FUNCNAME__, GetLastError());
                        
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                                    
                    MemFree(pRasEntry);
                }
                else
                {
                    TraceTag(
                        ttidError, 
                        "%s: HrRasGetEntryProperties failed: 0x%lx", 
                        __FUNCNAME__, hr);
                }
                RciFree (&rci);
            }
            else
            {
                TraceTag(
                    ttidError, 
                    "%s: HrRciGetRasConnectionInfo failed: 0x%lx", 
                    __FUNCNAME__, hr);
            }
        }
    }
    
    // Set the dial on demand setting. 
    // We don't need to do it for 2 cases:
    // 1. Win2K ICS upgrade because the registry settings is already migrated.
    // 2. the ICS public is a LAN connection.
    if (pRasShareConn->fIsLanConnection || m_pIcsUpgradeSettings->fWin2KUpgrade)
    {
        // no need to set dial on-demand for external lan connection
        return hr; 
    }

    
    // Get the IHNetIcsSettings interface to control system-wide
    // ICS settings
    
    // Create Homenet Configuration Manager COM Instance
    CComPtr<IHNetCfgMgr> spIHNetCfgMgr;

    hr = CoCreateInstance(CLSID_HNetCfgMgr, NULL, 
                            CLSCTX_ALL,
                            IID_IHNetCfgMgr, 
                            (LPVOID *)&spIHNetCfgMgr);
    if (FAILED(hr))
    {
        TraceTag(ttidError, "%s: CoCreateInstance CLSID_HNetCfgMgr failed: 0x%lx", 
                __FUNCNAME__, hr);
        return hr;
    }
  
    // Get the IHNetIcsSettings      
    CComPtr<IHNetIcsSettings> spHNetIcsSettings;
    hr = spIHNetCfgMgr->QueryInterface(IID_IHNetIcsSettings, 
                                        (LPVOID *)&spHNetIcsSettings);

    if (FAILED(hr))
    {
        TraceTag(ttidError, 
                "%s: QueryInterface IID_IHNetIcsSettings failed: 0x%lx", 
                __FUNCNAME__, hr);
        return hr;
    }
    hr = spHNetIcsSettings->SetAutodialSettings(!!(m_pIcsUpgradeSettings->fDialOnDemand));
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
                "%s: Ignore SetAutodialSettings failed: 0x%lx", 
                __FUNCNAME__, hr);
        hr = S_OK;
    }
    
    return hr;
}

/*++

Routine Description:

    The interface given by rAdapterGuid will be configured to
    use ICS static IP 192.168.0.1, subnet mask 255.255.255.0

Arguments:

    [in]  rInterfaceGuid -- the Guid of the TcpIp interface

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::SetPrivateIpConfiguration(IN GUID& rInterfaceGuid)
{
    HRESULT hr                 = S_OK;
    HKEY    hkeyTcpipInterface = NULL;

    DefineFunctionName("CIcsUpgrade::SetPrivateIpConfiguration");
    TraceFunctionEntry(ttidNetSetup);

    hr = OpenTcpipInterfaceKey(rInterfaceGuid, &hkeyTcpipInterface);
    if (FAILED(hr))
    {
        TraceTag(ttidError, 
            "%s: OpenTcpipInterfaceKey failed: 0x%lx", 
            __FUNCNAME__, hr);

        return hr;
    }
    Assert(hkeyTcpipInterface);

    // IPAddress
    hr = HrRegSetMultiSz(hkeyTcpipInterface,
                            c_wszIPAddress,
                            c_mszScopeAddress);
    if(FAILED(hr))
    {
        TraceTag(ttidError,
            "%s: failed to set %S to the registry. hr = 0x%lx.",
            __FUNCNAME__, c_wszIPAddress, 
            hr);

        goto Error;
    }

    // SubnetMask
    hr = HrRegSetMultiSz(hkeyTcpipInterface,
                            c_wszSubnetMask,
                            c_mszScopeMask);
    if(FAILED(hr))
    {
        TraceTag(ttidError,
            "%s: failed to set %S to the registry. hr = 0x%lx.",
            __FUNCNAME__, c_wszIPAddress, 
            hr);

        goto Error;
    }

    // EnableDHCP
    hr = HrRegSetDword(hkeyTcpipInterface,
                        c_wszEnableDHCP,
                        0);
    if(FAILED(hr))
    {
        TraceTag(ttidError,
            "%s: failed to set %S to the registry. hr = 0x%lx.",
            __FUNCNAME__, c_wszEnableDHCP, 
            hr);

        goto Error;
    }

Error:

    RegSafeCloseKey(hkeyTcpipInterface);
    return hr;
}

/*++

Routine Description:

    Get the interface guid of a bridge.

Arguments:

    [out]  rInterfaceGuid -- receive the Guid from the bridge interface

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::GetBridgeGuid(OUT GUID& rInterfaceGuid)
{
    HRESULT         hr      = S_OK;
    BOOLEAN         fFound  = FALSE;
    INetConnection* pConn   = NULL;
    ULONG           ulCount = 0;
    

    DefineFunctionName("CIcsUpgrade::GetBridgeGuid");
    TraceFunctionEntry(ttidNetSetup);

    // we don't use the cached m_spEnum because it may be in a stale
    // state (a bridge has just been created).
    CComPtr<IEnumNetConnection> spEnum; 

    // Get the net connection manager
    INetConnectionManager* pConnMan = NULL;

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                            CLSCTX_ALL,
                            IID_INetConnectionManager,
                            (LPVOID *)&pConnMan);
    if (SUCCEEDED(hr))
    {
        // Get the enumeration of connections
        SetProxyBlanket(pConnMan);
        hr = pConnMan->EnumConnections(NCME_DEFAULT, &spEnum);
        pConnMan->Release(); // don't need this anymore
        if (SUCCEEDED(hr))
        {
            SetProxyBlanket(spEnum);
        }
        else
        {
            TraceTag(ttidError,
                "%s: EnumConnections failed: 0x%lx.",
                __FUNCNAME__, hr);

            return hr;
        }
    }
    else
    {
        TraceTag(ttidError,
            "%s: CoCreateInstance failed: 0x%lx.",
            __FUNCNAME__, hr);

        return hr;
    }

    hr = spEnum->Reset();
    if (FAILED(hr))
    {
        TraceTag(ttidError,
            "%s: Reset failed: 0x%lx.",
            __FUNCNAME__, hr);

        return hr;
    }    
    do
    {
        NETCON_PROPERTIES* pProps;
            
        hr = spEnum->Next(1, &pConn, &ulCount);
        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            SetProxyBlanket(pConn);

            hr = pConn->GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                if (NCM_BRIDGE == pProps->MediaType)
                {
                    // transfer value
                    rInterfaceGuid = pProps->guidId;
                    fFound = TRUE;
                }   
                NcFreeNetconProperties(pProps);
            }
            pConn->Release();
        }
    } while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

    // Normalize hr
    hr = (fFound ? S_OK : E_FAIL);

    return hr;
}

/*++

Routine Description:

    Get the INetConnection of a bridge.

Arguments:

    [out]  ppINetConn -- receive the INetConnection from the bridge interface

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::GetBridgeINetConn(OUT INetConnection** ppINetConn)
{
    HRESULT         hr      = S_OK;
    BOOLEAN         fFound  = FALSE;
    INetConnection* pConn   = NULL;
    ULONG           ulCount = 0;
    

    DefineFunctionName("CIcsUpgrade::GetBridgeINetConn");
    TraceFunctionEntry(ttidNetSetup);

    Assert(ppINetConn);
    *ppINetConn = NULL;
    // we don't use the cached m_spEnum because it may be in a stale
    // state (a bridge has just been created).
    CComPtr<IEnumNetConnection> spEnum; 

    // Get the net connection manager
    INetConnectionManager* pConnMan = NULL;

    hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                            CLSCTX_ALL,
                            IID_INetConnectionManager,
                            (LPVOID *)&pConnMan);
    if (SUCCEEDED(hr))
    {
        // Get the enumeration of connections
        SetProxyBlanket(pConnMan);
        hr = pConnMan->EnumConnections(NCME_DEFAULT, &spEnum);
        pConnMan->Release(); // don't need this anymore
        if (SUCCEEDED(hr))
        {
            SetProxyBlanket(spEnum);
        }
        else
        {
            TraceTag(ttidError,
                "%s: EnumConnections failed: 0x%lx.",
                __FUNCNAME__, hr);

            return hr;
        }
    }
    else
    {
        TraceTag(ttidError,
            "%s: CoCreateInstance failed: 0x%lx.",
            __FUNCNAME__, hr);

        return hr;
    }

    hr = spEnum->Reset();
    if (FAILED(hr))
    {
        TraceTag(ttidError,
            "%s: Reset failed: 0x%lx.",
            __FUNCNAME__, hr);

        return hr;
    }    
    do
    {
        NETCON_PROPERTIES* pProps;
            
        hr = spEnum->Next(1, &pConn, &ulCount);
        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            SetProxyBlanket(pConn);

            hr = pConn->GetProperties(&pProps);
            if (SUCCEEDED(hr))
            {
                if (NCM_BRIDGE == pProps->MediaType)
                {
                    // transfer value
                    *ppINetConn = pConn;
                    fFound = TRUE;
                }   
                NcFreeNetconProperties(pProps);
            }
            if (!fFound)
            {
                pConn->Release();
            }
        }
    } while (FALSE == fFound && SUCCEEDED(hr) && 1 == ulCount);

    // Normalize hr
    hr = (fFound ? S_OK : E_FAIL);

    return hr;
}

/*++

Routine Description:

    Open the Ip Configuration registry Key of an interface

Arguments:

    [in]  rGuid -- the Guid of the TcpIp interface
    [out] phKey -- receives the opened key

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::OpenTcpipInterfaceKey(
    IN  GUID&   rGuid,
    OUT PHKEY   phKey)
{
    HRESULT hr;
    LPWSTR  wszSubKeyName;
    ULONG   ulSubKeyNameLength;
    LPWSTR  wszGuid;

    Assert(phKey);

    hr = StringFromCLSID(rGuid, &wszGuid);    
    if (SUCCEEDED(hr))
    {
        ulSubKeyNameLength =
            wcslen(c_wszTcpipParametersKey) + 1 +
            wcslen(c_wszInterfaces) + 1 +
            wcslen(wszGuid) + 2;

        wszSubKeyName = new WCHAR[ulSubKeyNameLength];
        if (NULL != wszSubKeyName)
        {
            swprintf(
                wszSubKeyName,
                L"%ls\\%ls\\%ls",
                c_wszTcpipParametersKey,
                c_wszInterfaces,
                wszGuid
                );
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        CoTaskMemFree(wszGuid);
    }

    if (SUCCEEDED(hr))
    { 
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, wszSubKeyName, KEY_ALL_ACCESS, phKey);
        delete [] wszSubKeyName;
    }

    return hr;
}

/*++

Routine Description:

    Create a named event to notify other components that we're
    in GUI Mode Setup of Win2K ICS Upgrade 

Arguments:

Return Value:

    standard HRESULT

--*/
HRESULT CIcsUpgrade::CreateIcsUpgradeNamedEvent()
{
    DefineFunctionName("CIcsUpgrade::CreateIcsUpgradeNamedEvent");
    TraceFunctionEntry(ttidNetSetup);

    // create an auto-reset, nonsingaled, named event
    m_hIcsUpgradeEvent = CreateEvent(NULL, FALSE, FALSE, c_wszIcsUpgradeEventName);
    if (NULL == m_hIcsUpgradeEvent)
    {
        TraceTag(ttidError, 
                    "%s: CreateEvent failed: 0x%lx",  
                    __FUNCNAME__, GetLastError()); 
                   
        NetSetupLogStatusV(
                LogSevError,
                SzLoadIds (IDS_TXT_CANT_UPGRADE_ICS));

        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}
//--------- HNet helpers end ------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\edc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E D C . H
//
//  Contents:   Routines to enumerate (via a callback) the set of "default"
//              components that are installed under various conditions.
//
//  Notes:      We have default components and mandatory components.
//              Default components (which also include the mandatory
//              components) are installed during attended fresh installs.
//              Mandatory components are potentially installed during
//              upgrades to make sure that the basic (mandatory) networking
//              components are present.
//
//              Default components may also depend on on the suite or platform
//              currently running.  For example, WLBS is a default component
//              on the Enterprise suite, but not on normal Professional or
//              Server products.  Representing this flexibility is the main
//              reason a callback interface was chosen, instead of returning
//              static arrays of components.
//
//              Callers often need to know how many components will be
//              enumerated before they actually enumerate them.  To satisfy
//              this, the callback is first called with the count of items
//              to follow.  The callback routine therefore is passed a
//              message (EDC_INDICATE_COUNT or EDC_INDICATE_ENTRY) to indicate
//              the purpose of the call.
//
//  Author:     shaunco   18 May 1999
//
//----------------------------------------------------------------------------

#pragma once

// EDC_ENTRY.dwEntryType values
//
#define EDC_DEFAULT     0x00000001
#define EDC_MANDATORY   0x00000002

struct EDC_ENTRY
{
    PCWSTR      pszInfId;
    const GUID* pguidDevClass;
    DWORD       dwEntryType;
    USHORT      wSuiteMask;
    USHORT      wProductType;
    BOOL        fInvertInstallCheck;
};

enum EDC_CALLBACK_MESSAGE
{
    EDC_INDICATE_COUNT,     // ulData is a UINT
    EDC_INDICATE_ENTRY,     // ulData is a const EDC_ENTRY*
};

typedef VOID
(CALLBACK* PFN_EDC_CALLBACK) (
    IN EDC_CALLBACK_MESSAGE Message,
    IN ULONG_PTR MessageData,
    IN PVOID pvCallerData OPTIONAL);

VOID
EnumDefaultComponents (
    IN DWORD dwEntryType,
    IN PFN_EDC_CALLBACK pfnCallback,
    IN PVOID pvCallerData OPTIONAL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\edc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E D C . C P P
//
//  Contents:   Routines to enumerate (via a callback) the set of "default"
//              components that are installed under various conditions.
//
//  Notes:      (See edc.h for notes on the interface to this module.)
//
//  Author:     shaunco   18 May 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "edc.h"

extern const WCHAR c_szInfId_MS_ALG[];
extern const WCHAR c_szInfId_MS_GPC[];
extern const WCHAR c_szInfId_MS_MSClient[];
extern const WCHAR c_szInfId_MS_RasCli[];
extern const WCHAR c_szInfId_MS_RasSrv[];
extern const WCHAR c_szInfId_MS_Server[];
extern const WCHAR c_szInfId_MS_TCPIP[];
extern const WCHAR c_szInfId_MS_WLBS[];
extern const WCHAR c_szInfId_MS_PSched[];
extern const WCHAR c_szInfId_MS_WZCSVC[];
extern const WCHAR c_szInfId_MS_NDISUIO[];
extern const WCHAR c_szInfId_MS_WebClient[];

static const EDC_ENTRY c_aDefault [] =
{
// On IA64, all homenet technologies are unavailable.
#ifndef _WIN64
    {   c_szInfId_MS_ALG,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT | EDC_MANDATORY,
        VER_SUITE_ENTERPRISE | VER_SUITE_DATACENTER,
        0,
        TRUE },  // Install everywhere *except* DTC and ADS
#endif

    {   c_szInfId_MS_GPC,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_TCPIP,
        &GUID_DEVCLASS_NETTRANS,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_PSched,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT,
        0,
        VER_NT_WORKSTATION,
        FALSE },

    {   c_szInfId_MS_WebClient,
        &GUID_DEVCLASS_NETCLIENT,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_MSClient,
        &GUID_DEVCLASS_NETCLIENT,
        EDC_DEFAULT,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_Server,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_RasCli,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_RasSrv,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_WLBS,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT,
        0,
        VER_NT_SERVER,
        FALSE },

    {   c_szInfId_MS_NDISUIO,
        &GUID_DEVCLASS_NETTRANS,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },

    {   c_szInfId_MS_WZCSVC,
        &GUID_DEVCLASS_NETSERVICE,
        EDC_DEFAULT | EDC_MANDATORY,
        0,
        0,
        FALSE },
};

BOOL FCheckSuite(WORD wSuiteMask)
{
    // Succeed if they are not asking us to verify anything
    if(!wSuiteMask)
    {
        return true;
    }

    OSVERSIONINFOEX osiv;
    ULONGLONG ConditionMask;

    ZeroMemory (&osiv, sizeof(osiv));
    osiv.dwOSVersionInfoSize = sizeof(osiv);
    osiv.wSuiteMask = wSuiteMask;
    ConditionMask = 0;

    // Succeed if any of the requested suites are present
    // on this machine
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_OR);

    return STATUS_SUCCESS == RtlVerifyVersionInfo(
        &osiv, VER_SUITENAME, ConditionMask);
}

BOOL FCheckProductType(WORD wProductType)
{
    // Succeed if they are not asking us to verify anything
    if(!wProductType)
    {
        return true;
    }

    OSVERSIONINFOEX osiv;
    ULONGLONG ConditionMask;

    ZeroMemory (&osiv, sizeof(osiv));
    osiv.dwOSVersionInfoSize = sizeof(osiv);
    osiv.wProductType = wProductType;
    ConditionMask = 0;
    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);

    return STATUS_SUCCESS == RtlVerifyVersionInfo(
        &osiv, VER_PRODUCT_TYPE, ConditionMask);
}

VOID
EnumDefaultComponents (
    IN DWORD dwEntryType,
    IN PFN_EDC_CALLBACK pfnCallback,
    IN PVOID pvCallerData OPTIONAL
    )
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert (dwEntryType);
    Assert (pfnCallback);

    // An array of flags.  If a flag at index 'i' is TRUE, it means
    // we will enumerate c_aDefault[i].
    //
    BYTE afEnumEntry [celems(c_aDefault)];
    UINT cEntries = 0;

    // Figure out which components we will be enumerating based on
    // the caller's requested entry type.  For each that we will enumerate,
    // set the flag at the index in afEnumEntry.
    //
    for (UINT i = 0; i < celems(c_aDefault); i++)
    {
        BOOL     fShouldInstall;

        afEnumEntry[i] = FALSE;

        // If no match on the entry type, continue to the next entry.
        //
        if (!(dwEntryType & c_aDefault[i].dwEntryType))
        {
            continue;
        }

        // Check for product suite or type.
        //
        fShouldInstall = FCheckSuite(c_aDefault[i].wSuiteMask) &&
                         FCheckProductType(c_aDefault[i].wProductType);

        // Some components express the conditions under which they
        // should be installed with a NOT
        //
        if( c_aDefault[i].fInvertInstallCheck )
        {
            fShouldInstall = !fShouldInstall;
        }

        if(! fShouldInstall)
        {
            continue;
        }

        // If we got to this point, it means this entry is valid to be
        // enumerated to the caller.  Add it (by setting the flag in
        // the local BYTE array at the same index as the entry).
        //
        afEnumEntry[i] = TRUE;
        cEntries++;
    }

    // Call the callback and indicate the count of times we will be
    // calling it with entries.  This allows the callback to know, ahead
    // of time, how much work needs to be done.
    //
    pfnCallback (EDC_INDICATE_COUNT, cEntries, pvCallerData);

    // Call the callback for each entry to be enumerated.
    //
    for (i = 0; i < celems(c_aDefault); i++)
    {
        if (!afEnumEntry[i])
        {
            continue;
        }

        pfnCallback (EDC_INDICATE_ENTRY, (ULONG_PTR)&c_aDefault[i],
            pvCallerData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\ncfgval.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C F G V A L . H
//
//  Contents:   Validation on interfaces in the NetCfg project.
//
//  Notes:
//
//  Author:     danielwe   19 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncvalid.h"

#define Validate_INetCfgIdentification_Validate ;/##/
#define Validate_INetCfgIdentification_Cancel   ;/##/
#define Validate_INetCfgIdentification_Apply    ;/##/

inline BOOL FBadArgs_INetCfgIdentification_GetWorkgroupName(PWSTR* a)
{
    return FBadOutPtr(a);
}
#define Validate_INetCfgIdentification_GetWorkgroupName(a)  \
    if (FBadArgs_INetCfgIdentification_GetWorkgroupName(a)) \
        { \
            TraceError("Validate_INetCfgIdentification_GetWorkgroupName", E_INVALIDARG); \
            return E_INVALIDARG; \
        }

inline BOOL FBadArgs_INetCfgIdentification_GetDomainName(PWSTR* a)
{
    return FBadOutPtr(a);
}
#define Validate_INetCfgIdentification_GetDomainName(a) \
    if (FBadArgs_INetCfgIdentification_GetDomainName(a)) \
        { \
            TraceError("Validate_INetCfgIdentification_GetDomainName", E_INVALIDARG); \
            return E_INVALIDARG; \
        }

inline BOOL FBadArgs_INetCfgIdentification_JoinWorkgroup(PCWSTR a)
{
    return FBadInPtr(a);
}
#define Validate_INetCfgIdentification_JoinWorkgroup(a) \
    if (FBadArgs_INetCfgIdentification_JoinWorkgroup(a)) \
        { \
            TraceError("Validate_INetCfgIdentification_JoinWorkgroup", E_INVALIDARG); \
            return E_INVALIDARG; \
        }

inline BOOL FBadArgs_INetCfgIdentification_JoinDomain(PCWSTR a, PCWSTR b, PCWSTR c)
{
    return FBadInPtr(a) ||
           FBadInPtr(b) ||
           FBadInPtr(c);
}
#define Validate_INetCfgIdentification_JoinDomain(a, b, c) \
    if (FBadArgs_INetCfgIdentification_JoinDomain(a, b, c)) \
        { \
            TraceError("Validate_INetCfgIdentification_JoinDomain", E_INVALIDARG); \
            return E_INVALIDARG; \
        }

inline BOOL FBadArgs_INetCfgIdentification_GetComputerRole(DWORD* a)
{
    return FBadOutPtr(a);
}
#define Validate_INetCfgIdentification_GetComputerRole(a) \
    if (FBadArgs_INetCfgIdentification_GetComputerRole(a)) \
        { \
            TraceError("Validate_INetCfgIdentification_GetComputerRole", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\ncident.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I D E N T . H
//
//  Contents:   CNetCfgIdentification object.
//
//  Notes:
//
//  Author:     danielwe  19 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "resource.h"

// Include new NetSetup APIs
extern "C"
{
    #include <lmcons.h>
    #include <lmerr.h>
    #include <lmapibuf.h>
    #include <lmjoin.h>
}

typedef enum tagROLE_FLAGS
{
    GCR_STANDALONE   = 0x0001,
    GCR_MEMBER       = 0x0002,
    GCR_PDC          = 0x0004,
    GCR_BDC          = 0x0008,
} ROLE_FLAGS;

typedef enum tagJOIN_DOMAIN_FLAGS
{
    JDF_CREATE_ACCOUNT  = 0x0001,
    JDF_WIN9x_UPGRADE   = 0x0002,
    JDF_JOIN_UNSECURE   = 0x0004,
    JDF_MACHINE_PWD_PASSED = 0x0008
} JOIN_DOMAIN_FLAGS;


class CNetCfgIdentification
{
public:
    CNetCfgIdentification();
    ~CNetCfgIdentification();

// INetCfgIdentification
    STDMETHOD(Validate)();
    STDMETHOD(Cancel)();
    STDMETHOD(Apply)();
    STDMETHOD(GetWorkgroupName)(PWSTR* ppszwWorkgroup);
    STDMETHOD(GetDomainName)(PWSTR* ppszwDomain);
    STDMETHOD(GetComputerRole)(DWORD* pdwRoleFlags);
    STDMETHOD(JoinWorkgroup)(PCWSTR pszwWorkgroup);
    STDMETHOD(JoinDomain)(PCWSTR pszwDomain, PCWSTR pszMachineObjectOU,
                          PCWSTR pszwUserName,
                          PCWSTR pszwPassword, DWORD dwJoinFlags);

private:
    // Need to hold onto info until Apply() is called.
    PWSTR      m_szwNewDWName;         // New domain or workgroup name.

    PWSTR      m_szwPassword;          // Password.
    PWSTR      m_szwUserName;          // User name.
    PWSTR      m_szMachineObjectOU;    // Machine Object OU

    PWSTR      m_szwCurComputerName;   // Current computer name
    PWSTR      m_szwCurDWName;         // Current domain or workgroup name

    NETSETUP_JOIN_STATUS    m_jsCur;    // Determines whether m_szwCurDWName
                                        // is a domain name or workgroup name
    NETSETUP_JOIN_STATUS    m_jsNew;    // Determines whether m_szwNewDWName
                                        // is a domain name or workgroup name

    DWORD       m_dwJoinFlags;          // Join flags for domain.
    DWORD       m_dwCreateFlags;        // Flags for creating domain controller.
    BOOL        m_fValid;               // TRUE if all data has been validated

    HRESULT HrValidateMachineName(PCWSTR pszwName);
    HRESULT HrValidateWorkgroupName(PCWSTR pszwName);
    HRESULT HrValidateDomainName(PCWSTR pszwName, PCWSTR pszwUserName,
                                 PCWSTR pszwPassword);
    HRESULT HrSetComputerName(VOID);
    HRESULT HrJoinWorkgroup(VOID);
    HRESULT HrJoinDomain(VOID);
    HRESULT HrGetCurrentComputerName(PWSTR* ppszwComputer);
    HRESULT HrGetNewComputerName(PWSTR* ppszwComputer);
    HRESULT HrGetNewestComputerName(PCWSTR* pwszName);
    HRESULT HrGetNewestDomainOrWorkgroupName(NETSETUP_JOIN_STATUS js,
                                             PCWSTR* pwszName);
    HRESULT HrEnsureCurrentComputerName(VOID);
    HRESULT HrEnsureCurrentDomainOrWorkgroupName(VOID);
    HRESULT HrEstablishNewDomainOrWorkgroupName(NETSETUP_JOIN_STATUS js);
#ifdef DBG
    BOOL FIsJoinedToDomain(VOID);
#else
    BOOL FIsJoinedToDomain()
    {
        AssertSzH(m_szwCurDWName, "I can't tell you if you're joined because "
                "I don't know yet!");
        return !!(m_jsCur == NetSetupDomainName);
    }
#endif
    NETSETUP_JOIN_STATUS GetCurrentJoinStatus(VOID);
    NETSETUP_JOIN_STATUS GetNewJoinStatus(VOID);
};

inline NETSETUP_JOIN_STATUS CNetCfgIdentification::GetCurrentJoinStatus()
{
    AssertSzH((m_jsCur == NetSetupDomainName) ||
              (m_jsCur == NetSetupWorkgroupName), "Invalid current join status!");
    AssertSzH(m_szwCurDWName, "Why are you asking for this without knowing "
              "what the current domain or workgroup name is??");

    return m_jsCur;
}

inline NETSETUP_JOIN_STATUS CNetCfgIdentification::GetNewJoinStatus()
{
    AssertSzH((m_jsNew == NetSetupDomainName) ||
              (m_jsNew == NetSetupWorkgroupName), "Invalid new join status!");
    AssertSzH(m_szwNewDWName, "Why are you asking for this without knowing "
              "what the new domain or workgroup name is??");

    return m_jsNew;
}

inline CNetCfgIdentification::CNetCfgIdentification() :
    m_szwNewDWName(NULL),
    m_szwPassword(NULL),
    m_szwUserName(NULL),
    m_szMachineObjectOU(NULL),
    m_szwCurComputerName(NULL),
    m_szwCurDWName(NULL),
    m_dwJoinFlags(0),
    m_dwCreateFlags(0),
    m_fValid(FALSE),
    m_jsCur(NetSetupUnjoined),
    m_jsNew(NetSetupUnjoined)
{
}

inline CNetCfgIdentification::~CNetCfgIdentification()
{
    delete m_szwNewDWName;
    delete m_szwCurComputerName;
    delete m_szMachineObjectOU;
    delete m_szwCurDWName;
    delete m_szwPassword;
    delete m_szwUserName;
}

//
// Global functions
//
HRESULT HrFromNerr(NET_API_STATUS nerr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\ncident.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       ncident.cpp
//
//  Contents:   Implementation of CNetCfgIdentification.
//
//  Notes:
//
//  History:    21 Mar 1997   danielwe   Created
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <nceh.h>
#include "ncfgval.h"
#include "ncident.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "nsbase.h"
#include "nccom.h"
#include "ncerror.h"

//+---------------------------------------------------------------------------
//
//  Function:   DeleteStringAndSetNull
//
//  Purpose:    Frees the given string with delete, and sets it to
//              NULL before exiting.
//
//  Arguments:
//      pszw   [in, out] Pointer to string to be freed. The pointer is set to
//                      NULL before the function exits.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   1 Apr 1997
//
//  Notes:
//
inline VOID DeleteStringAndSetNull(PWSTR *pszw)
{
    AssertSz(pszw, "Param is NULL!");

    delete *pszw;
    *pszw = NULL;
}

inline HRESULT HrNetValidateName(IN PCWSTR lpMachine,
                                 IN PCWSTR lpName,
                                 IN PCWSTR lpAccount,
                                 IN PCWSTR lpPassword,
                                 IN NETSETUP_NAME_TYPE  NameType)
{
    NET_API_STATUS  nerr;

    nerr = NetValidateName(const_cast<PWSTR>(lpMachine),
                           const_cast<PWSTR>(lpName),
                           const_cast<PWSTR>(lpAccount),
                           const_cast<PWSTR>(lpPassword),
                           NameType);

    TraceError("NetValidateName", HRESULT_FROM_WIN32(nerr));
    return HrFromNerr(nerr);
}


inline HRESULT HrNetJoinDomain(IN PWSTR lpMachine,
                               IN PWSTR lpMachineObjectOU,
                               IN PWSTR lpDomain,
                               IN PWSTR lpAccount,
                               IN PWSTR lpPassword,
                               IN DWORD fJoinOptions)
{
    NET_API_STATUS  nerr;
    HRESULT         hr;

    if ( fJoinOptions & NETSETUP_JOIN_DOMAIN )
    {
        hr = HrNetValidateName( lpMachine, lpDomain, lpAccount,
                                lpPassword, NetSetupDomain );
    }
    else
    {
        hr = HrNetValidateName( lpMachine, lpDomain, lpAccount,
                                lpPassword, NetSetupWorkgroup );
    }

    if (SUCCEEDED(hr))
    {
        nerr = NetJoinDomain(lpMachine, lpDomain, lpMachineObjectOU,
                             lpAccount, lpPassword, fJoinOptions);

        TraceError("NetJoinDomain", HRESULT_FROM_WIN32(nerr));

        hr = HrFromNerr(nerr);
    }

    return hr;
}

inline HRESULT HrNetRenameInDomain(IN PWSTR lpMachine,
                                   IN PWSTR lpNewMachine,
                                   IN PWSTR lpAccount,
                                   IN PWSTR lpPassword,
                                   IN DWORD fJoinOptions)
{
    NET_API_STATUS  nerr;

    nerr = NetRenameMachineInDomain(lpMachine, lpNewMachine, lpAccount,
                                    lpPassword, fJoinOptions);
    TraceError("NetRenameMachineInDomain", HRESULT_FROM_WIN32(nerr));
    return HrFromNerr(nerr);
}

inline HRESULT HrNetUnjoinDomain(IN PWSTR lpAccount,
                                 IN PWSTR lpPassword,
                                 IN DWORD fJoinOptions)
{
    NET_API_STATUS  nerr;

    nerr = NetUnjoinDomain(NULL,lpAccount, lpPassword, fJoinOptions);

    TraceError("NetUnjoinDomain", HRESULT_FROM_WIN32(nerr));
    return HrFromNerr(nerr);
}

inline HRESULT HrNetGetJoinInformation(IN PWSTR lpNameBuffer,
                                       OUT LPDWORD lpNameBufferSize,
                                       OUT PNETSETUP_JOIN_STATUS BufferType)
{
    NET_API_STATUS  nerr;
    PWSTR JoinBuff = NULL;

    nerr = NetGetJoinInformation(NULL, &JoinBuff, BufferType);

    if ( nerr == NERR_Success ) {

        if ( *BufferType == NetSetupUnjoined ) {

            *lpNameBufferSize = 0;
            *lpNameBuffer = UNICODE_NULL;

        } else {

            if ( *lpNameBufferSize >= ( wcslen( JoinBuff ) +1 ) * sizeof( WCHAR ) ) {

                wcscpy( lpNameBuffer, JoinBuff );

            }

            *lpNameBufferSize = wcslen( JoinBuff ) +1;

            NetApiBufferFree( JoinBuff );

        }

    }

    TraceError("NetGetJoinInformation", HRESULT_FROM_WIN32(nerr));
    return HrFromNerr(nerr);
}

#ifdef DBG
BOOL CNetCfgIdentification::FIsJoinedToDomain()
{
    HRESULT                 hr = S_OK;
    NETSETUP_JOIN_STATUS    js;
    WCHAR                   wszBuffer[256];
    DWORD                   cchBuffer = celems(wszBuffer);

    hr = HrNetGetJoinInformation(wszBuffer, &cchBuffer, &js);
    if (SUCCEEDED(hr))
    {
        if (js == NetSetupUnjoined)
        {
            // If we're as yet unjoined, only make sure that we marked our
            // internal state as being joined to a workgroup called "WORKGROUP"
            AssertSz(m_jsCur == NetSetupWorkgroupName, "We're unjoined but not "
                     "joined to a workgroup!");
            AssertSz(m_szwCurDWName, "No current domain or "
                     "workgroup name?");
            AssertSz(!lstrcmpiW(m_szwCurDWName,
                               SzLoadIds(IDS_WORKGROUP)),
                     "Workgroup name is not generic!");
        }
        else
        {
            AssertSz(js == m_jsCur, "Join status is not what we think it is!!");
        }
    }

    TraceError("CNetCfgIdentification::FIsJoinedToDomain - "
               "HrNetGetJoinInformation", hr);

    return (m_jsCur == NetSetupDomainName);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   HrFromNerr
//
//  Purpose:    Converts a NET_API_STATUS code into a NETCFG_E_* HRESULT
//              value.
//
//  Arguments:
//      nerr [in]   Status code to convert.
//
//  Returns:    HRESULT, Converted HRESULT value.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
HRESULT HrFromNerr(NET_API_STATUS nerr)
{
    HRESULT     hr;

    switch (nerr)
    {
    case NERR_Success:
        hr = S_OK;
        break;
    case NERR_SetupAlreadyJoined:
        hr = NETCFG_E_ALREADY_JOINED;
        break;
    case ERROR_DUP_NAME:
        hr = NETCFG_E_NAME_IN_USE;
        break;
    case NERR_SetupNotJoined:
        hr = NETCFG_E_NOT_JOINED;
        break;
//    case NERR_SetupIsDC:
//        hr = NETCFG_E_MACHINE_IS_DC;
//        break;
//    case NERR_SetupNotAServer:
//        hr = NETCFG_E_NOT_A_SERVER;
//        break;
//    case NERR_SetupImproperRole:
//        hr = NETCFG_E_INVALID_ROLE;
//        break;
    case ERROR_INVALID_PARAMETER:
        hr = E_INVALIDARG;
        break;
    case ERROR_ACCESS_DENIED:
        hr = E_ACCESSDENIED;
        break;
    case NERR_InvalidComputer:
    case ERROR_NO_SUCH_DOMAIN:
        hr = NETCFG_E_INVALID_DOMAIN;
        break;
    default:
        // Generic INetCfgIdentification error
        //$ REVIEW (danielwe) 24 Jun 1997: What if this isn't a Win32 error?
        hr = HRESULT_FROM_WIN32(nerr);
        break;
    }

    return hr;
}


//
// INetCfgIdentification implementation
//

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrEnsureCurrentComputerName
//
//  Purpose:    Ensures that the current computer name exists to act on.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:      Sets the m_szwCurComputerName variable.
//
HRESULT CNetCfgIdentification::HrEnsureCurrentComputerName()
{
    HRESULT    hr = S_OK;

    if (!m_szwCurComputerName)
    {
        PWSTR pszwComputer;

        // Go get the current computer name because we don't know it yet.
        hr = HrGetCurrentComputerName(&pszwComputer);
        if (SUCCEEDED(hr))
        {
            // m_szwCurComputerName is now set as a side effect

            CoTaskMemFree(pszwComputer);
        }
    }

    AssertSz(FImplies(SUCCEEDED(hr), m_szwCurComputerName),
             "I MUST have a name here!");

    TraceError("CNetCfgIdentification::HrEnsureCurrentComputerName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrGetNewestComputerName
//
//  Purpose:    Places the most recently referenced computer name into the
//              output parameter.
//
//  Arguments:
//      pwszName [out]     Most recently referenced computer name.
//
//  Returns:    Possible Win32 error code.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      If the SetComputerName() method was never called, this sets
//              the m_szwCurComputerName variable and returns a pointer to it.
//              Otherwise, it will return a pointer to the computer name
//              given in the SetComputerName() call.
//
HRESULT CNetCfgIdentification::HrGetNewestComputerName(PCWSTR *pwszName)
{
    HRESULT    hr = S_OK;

    AssertSz(pwszName, "NULL out param!");

    *pwszName = NULL;

    // New computer name is absent, use current computer name.
    hr = HrEnsureCurrentComputerName();
    if (FAILED(hr))
        goto err;

    *pwszName = m_szwCurComputerName;

err:
    TraceError("CNetCfgIdentification::HrGetNewestComputerName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrValidateMachineName
//
//  Purpose:    Validates the given machine name.
//
//  Arguments:
//      szwName [in]   Machine name to validate.
//
//  Returns:    S_OK if machine name is valid, NETCFG_E_NAME_IN_USE if machine
//              name is in use.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:
//
HRESULT CNetCfgIdentification::HrValidateMachineName(PCWSTR szwName)
{
    HRESULT         hr = S_OK;

    // Only validate if networking is installed
    hr = HrIsNetworkingInstalled();
    if (hr == S_OK)
    {
        // Current computer name is unused for validation of machine name.
        hr = HrNetValidateName(NULL,
                               szwName,
                               NULL, NULL,
                               NetSetupMachine);
        if (FAILED(hr))
        {
            //$REVIEW(danielwe): What error code to return here?
            TraceError("NetValidateName - Machine Name", hr);
        }
    }
    else if (hr == S_FALSE)
    {
        // no networking installed. We're fine.
        hr = S_OK;
    }

    TraceError("CNetCfgIdentification::HrValidateMachineName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrValidateWorkgroupName
//
//  Purpose:    Validates the given workgroup name.
//
//  Arguments:
//      szwName [in]   Workgroup name to validate.
//
//  Returns:    S_OK if machine name is valid, NETCFG_E_NAME_IN_USE if machine
//              name is in use.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:
//
HRESULT CNetCfgIdentification::HrValidateWorkgroupName(PCWSTR szwName)
{
    HRESULT         hr = S_OK;
    PCWSTR         wszComputerName = NULL;

    // If the user has changed the computer name, use it, otherwise get the
    // current computer name and use that.
    hr = HrGetNewestComputerName(&wszComputerName);
    if (FAILED(hr))
        goto err;

    AssertSz(wszComputerName, "We don't have a computer name!");

    hr = HrNetValidateName(const_cast<PWSTR>(wszComputerName),
                           szwName, NULL, NULL, NetSetupWorkgroup);
    if (FAILED(hr))
    {
        //$REVIEW(danielwe): What error code to return here?
        TraceError("NetValidateName - Workgroup Name", hr);
        goto err;
    }
err:
    TraceError("CNetCfgIdentification::HrValidateWorkgroupName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrValidateDomainName
//
//  Purpose:    Validates the given domain name.
//
//  Arguments:
//      szwName     [in]   Name of domain to validate.
//      szwUserName [in]   Username for authorization purposes.
//      szwPassword [in]   Password for authorization purposes.
//
//  Returns:    S_OK if machine name is valid, NETCFG_E_INVALID_DOMAIN if
//              domain name is invalid (or non-existent).
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:
//
HRESULT CNetCfgIdentification::HrValidateDomainName(PCWSTR szwName,
                                                    PCWSTR szwUserName,
                                                    PCWSTR szwPassword)
{
    HRESULT         hr = S_OK;

    // NetValidateName does not use the machine name in validating the
    // domain name. So it is NULL here.
    hr = HrNetValidateName(NULL, szwName,
                           szwUserName,
                           szwPassword,
                           NetSetupDomain);
    if (FAILED(hr))
    {
        //$REVIEW(danielwe): What error code to return here?
        TraceError("NetValidateName - Domain Name", hr);
        goto err;
    }
err:
    TraceError("CNetCfgIdentification::HrValidateDomainName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::Validate
//
//  Purpose:    Implements COM function to validate current set of values
//              used during the lifetime of this object.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
STDMETHODIMP CNetCfgIdentification::Validate()
{
    HRESULT         hr = S_OK;

    Validate_INetCfgIdentification_Validate();

    COM_PROTECT_TRY
    {
        if (m_szwNewDWName)
        {
            if (GetNewJoinStatus() == NetSetupWorkgroupName)
            {
                // Validate workgroup name
                hr = HrValidateWorkgroupName(m_szwNewDWName);
                if (FAILED(hr))
                    goto err;
            }
            else if (GetNewJoinStatus() == NetSetupDomainName)
            {
                // Validate domain name
                hr = HrValidateDomainName(m_szwNewDWName, m_szwUserName,
                                          m_szwPassword);
                if (FAILED(hr))
                    goto err;
            }
#ifdef DBG
            else
            {
                AssertSz(FALSE, "Invalid join status!");
            }
#endif
        }
    }
    COM_PROTECT_CATCH;

err:
    // Translate all errors to S_FALSE.
    if (SUCCEEDED(hr))
    {
        m_fValid = TRUE;
    }
    else
    {
        // spew out trace *before* the assignment so we know what the *real*
        // error code was.
        TraceError("CNetCfgIdentification::Validate (before S_FALSE)", hr);
        hr = S_FALSE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::Cancel
//
//  Purpose:    Cancels any changes made during the lifetime of the object.
//
//  Arguments:
//      (none)
//
//  Returns:
//
//  Author:     danielwe   25 Mar 1997
//
//  Notes:      Resets state information and frees any memory previously
//              allocted.
//
STDMETHODIMP CNetCfgIdentification::Cancel()
{
    HRESULT hr = S_OK;

    Validate_INetCfgIdentification_Cancel();

    COM_PROTECT_TRY
    {
        DeleteStringAndSetNull(&m_szwNewDWName);
        DeleteStringAndSetNull(&m_szwPassword);
        DeleteStringAndSetNull(&m_szwUserName);
        DeleteStringAndSetNull(&m_szwCurComputerName);
        DeleteStringAndSetNull(&m_szwCurDWName);

        m_dwJoinFlags = 0;
        m_dwCreateFlags = 0;
        m_fValid = FALSE;
        m_jsNew = NetSetupUnjoined;
    }

    COM_PROTECT_CATCH;

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::Apply
//
//  Purpose:    Implements COM function to apply changes that were made
//              during the lifetime of this object.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
STDMETHODIMP CNetCfgIdentification::Apply()
{
    HRESULT     hr = S_OK;

    Validate_INetCfgIdentification_Apply();

    COM_PROTECT_TRY
    {
        // Has data been validated?
        if (!m_fValid)
        {
            hr = E_UNEXPECTED;
            goto err;
        }

        if (m_szwNewDWName)
        {
            if (GetNewJoinStatus() == NetSetupWorkgroupName)
            {
                // The user specified a workgroup name. This means they want
                // to join a workgroup.
                hr = HrJoinWorkgroup();
                if (FAILED(hr))
                    goto err;
            }
            else if (GetNewJoinStatus() == NetSetupDomainName)
            {
                // The user specified a domain name. This means they want to
                // join a domain.
                hr = HrJoinDomain();
                if (FAILED(hr))
                    goto err;
            }
#ifdef DBG
            else
            {
                AssertSz(FALSE, "Invalid join status!");
            }
#endif
        }
    }
    COM_PROTECT_CATCH;

err:
    // Regardless of result, set valid flag to false again to require
    // Validate() to be called again before calling Apply().
    // $REVIEW (danielwe): Is this how we want to do it?
    m_fValid = FALSE;

    TraceError("CNetCfgIdentification::Apply", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrGetCurrentComputerName
//
//  Purpose:    Calls the Win32 GetComputerName API to get the current
//              computer name.
//
//  Arguments:
//      ppszwComputer [out]     Returned computer name.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:      Makes a private copy of the computer name if obtained from the
//              system (for further use).
//
HRESULT CNetCfgIdentification::HrGetCurrentComputerName(PWSTR* ppszwComputer)
{
    HRESULT     hr = S_OK;
    WCHAR       szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD       cchBuffer = celems(szBuffer);

    if (::GetComputerName(szBuffer, &cchBuffer))
    {
        // Make a copy for the out param.
        hr = HrCoTaskMemAllocAndDupSz (
                szBuffer, ppszwComputer);
        if (SUCCEEDED(hr))
        {
            // Make another copy for our own use.
            DeleteStringAndSetNull(&m_szwCurComputerName);
            m_szwCurComputerName = SzDupSz(szBuffer);

            AssertSz((DWORD)lstrlenW(*ppszwComputer) == cchBuffer,
                    "This is not how big the string is!");
        }
    }
    else
    {
        TraceLastWin32Error("::GetComputerName");
        hr = HrFromLastWin32Error();
    }

    TraceError("CNetCfgIdentification::HrGetCurrentComputerName", hr);
    return hr;
}

static const WCHAR c_szRegKeyComputerName[]     = L"System\\CurrentControlSet\\Control\\ComputerName\\ComputerName";
static const WCHAR c_szRegValueComputerName[]   = L"ComputerName";

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrGetNewComputerName
//
//  Purpose:    Helper function to retreive the new computer name from the
//              registry. This will be the same as the active computer name
//              unless the user has changed the computer name since booting.
//
//  Arguments:
//      ppszwComputer [out]     Returns new computer name.
//
//  Returns:    S_OK if successful, Win32 error code otherwise.
//
//  Author:     danielwe   21 May 1997
//
//  Notes:
//
HRESULT CNetCfgIdentification::HrGetNewComputerName(PWSTR* ppszwComputer)
{
    HRESULT     hr = S_OK;
    WCHAR       szBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD       cbBuffer = sizeof(szBuffer);
    HKEY        hkeyComputerName;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyComputerName,
                        KEY_READ, &hkeyComputerName);
    if (SUCCEEDED(hr))
    {
        hr = HrRegQuerySzBuffer(hkeyComputerName, c_szRegValueComputerName,
                                szBuffer, &cbBuffer);
        if (SUCCEEDED(hr))
        {
            // Make a copy for the out param.
            hr = HrCoTaskMemAllocAndDupSz (
                    szBuffer, ppszwComputer);

            AssertSz(FImplies(SUCCEEDED(hr),
                (lstrlenW(*ppszwComputer) + 1) * sizeof(WCHAR) == cbBuffer),
                "This is not how big the string is!");
        }

        RegCloseKey(hkeyComputerName);
    }

    TraceError("CNetCfgIdentification::HrGetCurrentComputerName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrEnsureCurrentDomainOrWorkgroupName
//
//  Purpose:    Obtains the current domain or workgroup to which this machine
//              belongs.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, error code otherwise.
//
//  Author:     danielwe   26 Mar 1997
//
//  Notes:      A machine can be joined to either or workgroup or a domain. It
//              must be joined to one or the other. If it is not, we'll use a
//              more or less hardcoded string and "fake it" as if the machine
//              was joined to a workgroup. The member variables:
//              m_jsCur and m_szwCurDWName are set by this function.
//
//              This call only does work once. Subsequent calls do nothing.
//
HRESULT CNetCfgIdentification::HrEnsureCurrentDomainOrWorkgroupName()
{
    HRESULT     hr = S_OK;

    if (!m_szwCurDWName)
    {
        NETSETUP_JOIN_STATUS    js;
        WCHAR                   wszBuffer[256];
        PCWSTR                 wszName;
        DWORD                   cchBuffer = celems(wszBuffer);

        hr = HrNetGetJoinInformation(wszBuffer, &cchBuffer, &js);
        if (FAILED(hr))
            goto err;

        AssertSz(FIff(*wszBuffer, cchBuffer), "Buffer size inconsistency!");

        if (js == NetSetupUnjoined)
        {
            // Uh oh. Machine is not joined to workgroup OR domain. Set
            // default workgroup name and proceed as if joined to a workgroup.
            js = NetSetupWorkgroupName;

            // Use default name since HrNetGetJoinInformation() will return
            // an empty string which is useless.
            wszName = SzLoadIds(IDS_WORKGROUP);
        }
        else
        {
            // Use string returned from HrNetGetJoinInformation().
            wszName = wszBuffer;
        }

        m_szwCurDWName = SzDupSz(wszName);

        m_jsCur = js;

        AssertSz(GetCurrentJoinStatus() == NetSetupWorkgroupName ||
                 GetCurrentJoinStatus() == NetSetupDomainName,
                 "Invalid join status flag!");
    }

err:
    TraceError("CNetCfgIdentification::HrEnsureCurrentDomainOrWorkgroupName",
               hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrGetNewestDomainOrWorkgroupName
//
//  Purpose:    Returns the domain or workgroup name that was most recently
//              referenced.
//
//  Arguments:
//      js       [in]   Tells whether the domain or workgroup name is wanted.
//      pwszName [out]  Domain or workgroup name.
//
//  Returns:    S_OK if success, E_OUTOFMEMORY if no memory.
//
//  Author:     danielwe   26 Mar 1997
//
//  Notes:      If the requested name has not been set by the user in a prior
//              call, the current name is returned. Otherwise the name the
//              user chose previously is returned.
//
HRESULT CNetCfgIdentification::HrGetNewestDomainOrWorkgroupName(
                                                    NETSETUP_JOIN_STATUS js,
                                                    PCWSTR *pwszName)
{
    HRESULT     hr = S_OK;
    PWSTR      szwOut = NULL;

    Assert(pwszName);

    if (m_szwNewDWName && (GetNewJoinStatus() == js))
    {
        // Give them back a copy of the domain or workgroup name they
        // previously gave us.
        szwOut = m_szwNewDWName;
    }
    else
    {
        // Get the current workgroup or domain for this machine. It has
        // to be in one or the other.
        hr = HrEnsureCurrentDomainOrWorkgroupName();
        if (FAILED(hr))
            goto err;

        if (GetCurrentJoinStatus() == js)
        {
            // Use the current name.
            szwOut = m_szwCurDWName;
        }
    }

    Assert(SUCCEEDED(hr));

    *pwszName = szwOut;

err:
    TraceError("CNetCfgIdentification::HrGetNewestDomainOrWorkgroupName", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::GetWorkgroupName
//
//  Purpose:    Implements COM function to get the current workgroup name.
//
//  Arguments:
//      ppszwWorkgroup [out]    Returns name of current workgroup.
//
//  Returns:    S_OK if succeeded, S_FALSE if machine is not joined to a
//              workgroup, error code otherwise.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
STDMETHODIMP CNetCfgIdentification::GetWorkgroupName(PWSTR* ppszwWorkgroup)
{
    HRESULT     hr = S_OK;
    PCWSTR     szwWorkgroup = NULL;

    Validate_INetCfgIdentification_GetWorkgroupName(ppszwWorkgroup);

    COM_PROTECT_TRY
    {
        *ppszwWorkgroup = NULL;

        hr = HrGetNewestDomainOrWorkgroupName(NetSetupWorkgroupName,
                                              &szwWorkgroup);
        if (FAILED(hr))
            goto err;

        if (szwWorkgroup)
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    szwWorkgroup, ppszwWorkgroup);

            AssertSz(FImplies(SUCCEEDED(hr), lstrlenW(*ppszwWorkgroup) > 0),
                      "Why is *ppszwWorkgroup empty?");
        }
        else
        {
            // Not joined to a workgroup
            hr = S_FALSE;
        }
    }
    COM_PROTECT_CATCH;

err:
    TraceError("CNetCfgIdentification::GetWorkgroupName",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::GetDomainName
//
//  Purpose:    Implements COM function to get the current domain name.
//
//  Arguments:
//      ppszwDomain [out]   Returns name of domain to which this computer
//                          currently belongs.
//
//  Returns:    S_OK if succeeded, S_FALSE if machine is not joined to a
//              domain, error code otherwise.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
STDMETHODIMP CNetCfgIdentification::GetDomainName(PWSTR* ppszwDomain)
{
    HRESULT     hr = S_OK;
    PCWSTR     szwDomain = NULL;

    Validate_INetCfgIdentification_GetDomainName(ppszwDomain);

    COM_PROTECT_TRY
    {
        *ppszwDomain = NULL;

        hr = HrGetNewestDomainOrWorkgroupName(NetSetupDomainName,
                                              &szwDomain);
        if (FAILED(hr))
            goto err;

        if (szwDomain)
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    szwDomain, ppszwDomain);

            AssertSz(FImplies(SUCCEEDED(hr), lstrlenW(*ppszwDomain) > 0),
                     "Why is *ppszwDomain empty?");
        }
        else
        {
            // Not joined to a domain
            hr = S_FALSE;
        }
    }
    COM_PROTECT_CATCH;

err:
    TraceError("CNetCfgIdentification::GetDomainName",
               (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrJoinWorkgroup
//
//  Purpose:    Actually performs the JoinWorkgroup function.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
HRESULT CNetCfgIdentification::HrJoinWorkgroup()
{
    HRESULT         hr = S_OK;
    PCWSTR         wszComputerName = NULL;

    AssertSz(m_szwNewDWName &&
             GetNewJoinStatus() == NetSetupWorkgroupName,
             "If there was no workgroup name, why'd you call me?!");

    // If the user has changed the computer name, use it, otherwise get the
    // current computer name and use that.
    hr = HrGetNewestComputerName(&wszComputerName);
    if (FAILED(hr))
        goto err;

    AssertSz(wszComputerName, "We don't have a computer name!");

    hr = HrEnsureCurrentDomainOrWorkgroupName();
    if (FAILED(hr))
        goto err;

    if (FIsJoinedToDomain())
    {
        // Must unjoin from domain if currently joined.
        // If currently joined to a workgroup, this is not necessary.
        hr = HrNetUnjoinDomain(m_szwUserName, m_szwPassword, 0);
        if (FAILED(hr))
            goto err;

        // Free username and password
        DeleteStringAndSetNull(&m_szwPassword);
        DeleteStringAndSetNull(&m_szwUserName);
    }

    // Go ahead and join the workgroup
    hr = HrNetJoinDomain(const_cast<PWSTR>(wszComputerName),
                         m_szMachineObjectOU,
                         m_szwNewDWName, NULL, NULL, 0);
    if (FAILED(hr))
        goto err;

    // Make the current workgroup name the new one since the join on the
    // new workgroup has succeeded
    hr = HrEstablishNewDomainOrWorkgroupName(NetSetupWorkgroupName);
    if (FAILED(hr))
        goto err;

err:
    TraceError("CNetCfgIdentification::HrJoinWorkgroup", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::JoinWorkgroup
//
//  Purpose:    Implements COM interface to join this computer to a new
//              workgroup.
//
//  Arguments:
//      szwWorkgroup [in]  Name of new workgroup to join.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:      Validates, but does not actually join the workgroup. Only holds
//              onto the information until Apply() is called.
//
STDMETHODIMP CNetCfgIdentification::JoinWorkgroup(PCWSTR szwWorkgroup)
{
    HRESULT         hr = S_OK;

    Validate_INetCfgIdentification_JoinWorkgroup(szwWorkgroup);

    COM_PROTECT_TRY
    {
        hr = HrValidateWorkgroupName(szwWorkgroup);
        if (FAILED(hr))
            goto err;

        // Free domain and password given if JoinDomain was called previously
        DeleteStringAndSetNull(&m_szwPassword);
        DeleteStringAndSetNull(&m_szwUserName);

        // Assign in new workgroup name.
        m_szwNewDWName = SzDupSz(szwWorkgroup);

        m_jsNew = NetSetupWorkgroupName;
    }
    COM_PROTECT_CATCH;

err:
    TraceError("CNetCfgIdentification::JoinWorkgroup", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrEstablishNewDomainOrWorkgroupName
//
//  Purpose:    When the computer is joined to a new domain or workgroup, this
//              function is called to set the correct member variables and
//              free the old ones.
//
//  Arguments:
//      js [in]     Indicates whether the computer is joined to a domain or
//                  workgroup.
//
//  Returns:    S_OK, or E_OUTOFMEMORY.
//
//  Author:     danielwe   1 Apr 1997
//
//  Notes:      Replaces the m_szwCurDWName variable with the new one
//              (m_szwNewDWName).
//
HRESULT CNetCfgIdentification::HrEstablishNewDomainOrWorkgroupName(
                                             NETSETUP_JOIN_STATUS js)
{
    HRESULT     hr = S_OK;

    // Make the current domain or workgroup name the new one.
    DeleteStringAndSetNull(&m_szwCurDWName);
    m_szwCurDWName = SzDupSz(m_szwNewDWName);

    m_jsCur = js;

    AssertSz(GetCurrentJoinStatus() == NetSetupWorkgroupName ||
             GetCurrentJoinStatus() == NetSetupDomainName,
             "Invalid join status flag!");

    // Free "new" name
    DeleteStringAndSetNull(&m_szwNewDWName);

    // Also make sure that we don't have a "new" join status either
    m_jsNew = NetSetupUnjoined;

    TraceError("CNetCfgIdentification::HrEstablishNewDomainOrWorkgroupName",
               hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::HrJoinDomain
//
//  Purpose:    Actually performs the JoinDomain function.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:
//
HRESULT CNetCfgIdentification::HrJoinDomain()
{
    HRESULT         hr = S_OK;
    PCWSTR         wszComputerName = NULL;
    DWORD           dwJoinOption = 0;
    BOOL            fIsRename = FALSE;
    BOOL            fUseNulls = FALSE;

    AssertSz(m_szwNewDWName && m_jsNew == NetSetupDomainName,
             "If there was no domain name, why'd you call me?!");
    AssertSz(FImplies(m_szwPassword,
                      m_szwUserName),
             "Password without username!!");

    // If the user has changed the computer name, use it, otherwise get the
    // current computer name and use that.
    hr = HrGetNewestComputerName(&wszComputerName);
    if (FAILED(hr))
        goto err;
    {
        AssertSz(wszComputerName == m_szwCurComputerName, "If I don't have a "
                 "new computer name, this better be the original one!");
        dwJoinOption |= NETSETUP_JOIN_DOMAIN;
    }

    AssertSz(wszComputerName, "We don't have a computer name!");
    AssertSz(dwJoinOption, "No option was set??");

    AssertSz(FImplies(m_szwPassword,
                      m_szwUserName),
             "Password without username!");

    // Create a machine account if so asked.
    if (m_dwJoinFlags & JDF_CREATE_ACCOUNT)
    {
        dwJoinOption |= NETSETUP_ACCT_CREATE;
    }

    if (m_dwJoinFlags & JDF_WIN9x_UPGRADE)
    {
        dwJoinOption |= NETSETUP_WIN9X_UPGRADE;
    }

    if (m_dwJoinFlags & JDF_JOIN_UNSECURE)
    {
        dwJoinOption |= NETSETUP_JOIN_UNSECURE;
    }

#if defined(REMOTE_BOOT)
    // TEMP: On a remote boot machine, prevent machine password change
    if (HrIsRemoteBootMachine() == S_OK)
    {
        TraceTag (ttidNetcfgBase,
                  "Machine is remote boot, specifying WIN9X_UPGRADE flag to JoinDomain.");
        dwJoinOption |= NETSETUP_WIN9X_UPGRADE;
    }
#endif // defined(REMOTE_BOOT)

    //$ REVIEW (danielwe) 2 Apr 1997: If new domain is same as old, unjoin
    // then rejoin??

    if (!(fIsRename) && FIsJoinedToDomain())
    {
        // Must unjoin from domain if currently joined.
        // If currently joined to a workgroup, this is not necessary.
        // Also we don't unjoin if we are renaming the machine in the domain.
        hr = HrNetUnjoinDomain(m_szwUserName,
                               m_szwPassword, 0);
        if (FAILED(hr))
            goto err;
    }

    if (FInSystemSetup())
    {
        // During system setup, need to pass special flag that tells join code
        // to not do certain operations because SAM is not initialized yet.
        dwJoinOption |= NETSETUP_INSTALL_INVOCATION;
    }

    // If the supplied username has astring length of zero, then the join
    // API's should be called with NULL's.
    //
    if ((NULL == m_szwUserName) || (0 == wcslen(m_szwUserName)))
    {
        fUseNulls = TRUE;
    }

    // Go ahead and join the domain
    if( fIsRename) {

        hr = HrNetRenameInDomain(const_cast<PWSTR>(wszComputerName),
                               m_szwNewDWName,
                               (fUseNulls ? NULL : m_szwUserName),
                               (fUseNulls ? NULL : m_szwPassword),
                               dwJoinOption);

    } else {

        hr = HrNetJoinDomain(const_cast<PWSTR>(wszComputerName),
                             m_szMachineObjectOU,
                             m_szwNewDWName,
                             (fUseNulls ? NULL : m_szwUserName),
                             (fUseNulls ? NULL : m_szwPassword),
                             dwJoinOption);
    }

    if (FAILED(hr))
    {
        // Note: (danielwe) Making assumption that failure to join a domain puts us in
        // a workgroup. MacM owns the code responsible for this.
        m_jsCur = NetSetupWorkgroupName;
        goto err;
    }

    // Make the current domain name the new one since the join on the
    // new domain has succeeded
    hr = HrEstablishNewDomainOrWorkgroupName(NetSetupDomainName);
    if (FAILED(hr))
        goto err;

err:
    // Free username and password
    DeleteStringAndSetNull(&m_szwPassword);
    DeleteStringAndSetNull(&m_szwUserName);

    TraceError("CNetCfgIdentification::HrJoinDomain", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::JoinDomain
//
//  Purpose:    Implements COM interface to join this computer to a new
//              domain.
//
//  Arguments:
//      szwDomain         [in]   New domain name.
//      szMachineObjectOU [in]   Machine object OU (optional)
//      szwUserName       [in]   User name to use in validation.
//      szwPassword       [in]   Password to use in validation.
//      dwJoinFlags       [in]   Currently can be 0 or JDF_CREATE_ACCOUNT.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   21 Mar 1997
//
//  Notes:      Validates, but does not actually join the domain. Only holds
//              onto the information until Apply() is called.
//
STDMETHODIMP CNetCfgIdentification::JoinDomain(PCWSTR szwDomain,
                                               PCWSTR szMachineObjectOU,
                                               PCWSTR szwUserName,
                                               PCWSTR szwPassword,
                                               DWORD dwJoinFlags)
{
    HRESULT         hr = S_OK;
    static const WCHAR c_wszBackslash[] = L"\\";
    static const WCHAR c_wszAt[] = L"@";

    COM_PROTECT_TRY
    {
        Validate_INetCfgIdentification_JoinDomain(szwDomain, szwUserName,
                                                  szwPassword);

#if defined(REMOTE_BOOT)
       if (HrIsRemoteBootMachine() == S_FALSE)
#endif  // defined(REMOTE_BOOT)
        {
            // look for non-empty password and empty username or username
            // consisting of only the backslash character
            if (!FIsStrEmpty(szwPassword) && FIsStrEmpty(szwUserName) ||
                !lstrcmpW(szwUserName, c_wszBackslash))
            {
                // Password without username is invalid.
                hr = E_INVALIDARG;
                goto err;
            }

            PWSTR  wszNewUserName;
            INT     cchNewUserName;

            // Check if username that was passed in has a backslash in it or
            // an '@', or if it is empty.
            if (FIsStrEmpty(szwUserName) ||
                wcschr(szwUserName, c_wszBackslash[0]) ||
                wcschr(szwUserName, c_wszAt[0]))
            {
                // if so, don't do anything extra
                wszNewUserName = NULL;
            }
            else
            {
                // if not, we have to append the domain name to the username

                cchNewUserName = lstrlenW(szwUserName) +   // original username
                                 lstrlenW(szwDomain) +     // domain name
                                 1 +                        // backslash character
                                 1;                         // terminating NULL

                wszNewUserName = new WCHAR[cchNewUserName];

                if(wszNewUserName)
                {
                    // Turn username into domain\username format
                    lstrcpyW(wszNewUserName, szwDomain);
                    lstrcatW(wszNewUserName, c_wszBackslash);
                    lstrcatW(wszNewUserName, szwUserName);

                    AssertSz(lstrlenW(wszNewUserName) + 1 == cchNewUserName,
                             "Possible memory overwrite in username!");
                }
            }

            // Use wszNewUserName if non-NULL, otherwise use szwUserName

            PCWSTR szwUserNameToCopy;

            szwUserNameToCopy = wszNewUserName ? wszNewUserName : szwUserName;
            m_szwUserName = SzDupSz(szwUserNameToCopy);
            m_szwPassword = SzDupSz(szwPassword);

            delete [] wszNewUserName;
        }

        AssertSz(FImplies(m_szwPassword,
                          m_szwUserName),
                 "Password without username!");

        hr = HrValidateDomainName(szwDomain, m_szwUserName, m_szwPassword);
        if (FAILED(hr))
            goto err;

        // Assign in new strings
        m_szwNewDWName = SzDupSz(szwDomain);
        if (szMachineObjectOU)
        {
            m_szMachineObjectOU = SzDupSz(szMachineObjectOU);
        }

        m_dwJoinFlags = dwJoinFlags;
        m_jsNew = NetSetupDomainName;
err:
        // suppress compiler error
        ;
    }
    COM_PROTECT_CATCH;

    TraceError("CNetCfgIdentification::JoinDomain", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetCfgIdentification::GetComputerRole
//
//  Purpose:    Returns the current role of the computer.
//
//  Arguments:
//      pdwRoleFlags [out]  Returns value which determines the role of this
//                          computer.
//
//  Returns:    S_OK if success, error code otherwise.
//
//  Author:     danielwe   26 Mar 1997
//
//  Notes:      Returned role can be one of:
//              SERVER_STANDALONE - The machine is part of a workgroup.
//              SERVER_MEMBER - The machine is joined to the domain.
//              SERVER_PDC -  The machine is a primary domain controller.
//              SERVER_BDC - The machine is a backup domain controller.
//
STDMETHODIMP CNetCfgIdentification::GetComputerRole(DWORD* pdwRoleFlags)
{
    HRESULT    hr = S_OK;

    Validate_INetCfgIdentification_GetComputerRole(pdwRoleFlags);

    COM_PROTECT_TRY
    {
        *pdwRoleFlags = 0;

        hr = HrEnsureCurrentDomainOrWorkgroupName();
        if (SUCCEEDED(hr))
        {
            if (m_jsNew == NetSetupUnjoined)
            {
                // The workgroup or domain has not been changed since this
                // object was instantiated

                if (GetCurrentJoinStatus() == NetSetupDomainName)
                {
                    *pdwRoleFlags = GCR_MEMBER;
                }
                else if (GetCurrentJoinStatus() == NetSetupWorkgroupName)
                {
                    *pdwRoleFlags = GCR_STANDALONE;
                }
    #ifdef DBG
                else
                {
                    AssertSz(FALSE, "Invalid join status flag!");
                }
    #endif
            }
            else
            {
                // This means the workgroup or domain name has been changed
                // since this object was instantiated

                if (GetNewJoinStatus() == NetSetupDomainName)
                {
                    *pdwRoleFlags = GCR_MEMBER;
                }
                else if (GetNewJoinStatus() == NetSetupWorkgroupName)
                {
                    *pdwRoleFlags = GCR_STANDALONE;
                }
    #ifdef DBG
                else
                {
                    AssertSz(FALSE, "Invalid join status flag!");
                }
    #endif
            }
        }
    }
    COM_PROTECT_CATCH;

    TraceError("CNetCfgIdentification::GetComputerRole", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\icsupgrd.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       I C S U P G R D . H
//
//  Contents:   Functions that is related to 
//              o upgrade of ICS from Win98 SE, WinMe and Win2K to Whistler
//              o unattended clean install of Homenet on Whistler or later
//
//
//  Date:       20-Sept-2000
//
//----------------------------------------------------------------------------
#pragma once

// entry point to upgrade ICS
BOOL FDoIcsUpgradeIfNecessary();
BOOL FIcsUpgrade(CWInfFile* pwifAnswerFile); 

//----------------------ICS Upgrade const literals begin------------------
// Win2K ICS registry settings
const TCHAR c_wszRegKeySharedAccessParams[]     = L"SYSTEM\\CurrentControlSet\\Services\\SharedAccess\\Parameters";
const TCHAR c_wszRegValSharedConnection[]       = L"SharedConnection";
const TCHAR c_wszRegValSharedPrivateLan[]       = L"SharedPrivateLan";
const WCHAR c_wszRegValBackupSharedConnection[] = L"BackupSharedConnection";
const WCHAR c_wszRegValBackupSharedPrivateLan[] = L"BackupSharedPrivateLan";

// ICS Upgrade named event
const WCHAR c_wszIcsUpgradeEventName[]          = L"IcsUpgradeEventName_";

// Win2K ICS Application and Server PortMapping stuff
const WCHAR c_wszPhoneBookPath[]                = L"\\Microsoft\\Network\\Connections\\Pbk\\";
const WCHAR c_wszFileSharedAccess[]             = L"SharedAccess.ini";
const WCHAR c_wszContentsServer[]               = L"Contents.Server";
const WCHAR c_wszContentsApplication[]          = L"Contents.Application";
const WCHAR c_wszServerPrefix[]                 = L"Server.";
const WCHAR c_wszApplicationPrefix[]            = L"Application.";
const WCHAR c_wszInternalName[]                 = L"InternalName";
const WCHAR c_wszTitle[]                        = L"Title";
const WCHAR c_wszInternalPort[]                 = L"InternalPort";
const WCHAR c_wszPort[]                         = L"Port";
const WCHAR c_wszReservedAddress[]              = L"ReservedAddress";
const WCHAR c_wszProtocol[]                     = L"Protocol";
const WCHAR c_wszBuiltIn[]                      = L"BuiltIn";
const WCHAR c_wszTcpResponseList[]              = L"TcpResponseList";
const WCHAR c_wszUdpResponseList[]              = L"UdpResponseList";
const WCHAR c_wszTCP[]                          = L"TCP";
const WCHAR c_wszUDP[]                          = L"UDP";

// Tcp/Ip registry configuration
const WCHAR c_wszEnableDHCP[]                   = L"EnableDHCP";
const WCHAR c_wszInterfaces[]                   = L"Interfaces";
const WCHAR c_wszIPAddress[]                    = L"IPAddress";
const WCHAR c_wszSubnetMask[]                   = L"SubnetMask";
const WCHAR c_wszTcpipParametersKey[]           = L"SYSTEM\\CurrentControlSet\\Services"
                                                  L"\\Tcpip\\Parameters";
const WCHAR c_mszScopeAddress[]                 = L"192.168.0.1\0";   // multi_sz
const WCHAR c_mszScopeMask[]                    = L"255.255.255.0\0"; // multi_sz

// These are constant for Homenet Answer-File
const WCHAR c_wszHomenetSection[]               = L"Homenet"; // section name
const WCHAR c_wszExternalAdapter[]              = L"ExternalAdapter";
const WCHAR c_wszExternalConnectionName[]       = L"ExternalConnectionName";
const WCHAR c_wszInternalAdapter[]              = L"InternalAdapter";
const WCHAR c_wszInternalAdapter2[]             = L"InternalAdapter2";
const WCHAR c_wszDialOnDemand[]                 = L"DialOnDemand";
const WCHAR c_wszICSEnabled[]                   = L"EnableICS";
const WCHAR c_wszShowTrayIcon[]                 = L"ShowTrayIcon";
const WCHAR c_wszInternalIsBridge[]             = L"InternalIsBridge";
const WCHAR c_wszPersonalFirewall[]             = L"InternetConnectionFirewall"; // multi_sz key
const WCHAR c_wszBridge[]                       = L"Bridge"; // multi_sz key

// keys which are not published
const WCHAR c_wszIsW9xUpgrade[]               = L"IsW9xUpgrade";

// ShFolder.dll imports
const WCHAR c_wszShFolder[]                     = L"SHFOLDER.DLL";
const CHAR c_szSHGetFolderPathW[]               = "SHGetFolderPathW";
// hnetcfg.dll imports
const WCHAR c_wszHNetCfgDll[] = L"hnetcfg.dll";
const CHAR c_szHNetSetShareAndBridgeSettings[]  = "HNetSetShareAndBridgeSettings";

//--------- ICS Upgrade const literals end---------------------------


//--------- ICS Upgrade helpers begin---------------------------
#define HTONS(s) ((UCHAR)((s) >> 8) | ((UCHAR)(s) << 8))
#define HTONL(l) ((HTONS(l) << 16) | HTONS((l) >> 16))
#define NTOHS(s) HTONS(s)
#define NTOHL(l) HTONL(l)

// note: we are using the tstring from config\inc\ncstlstr.h

// Application Protocol
class CSharedAccessApplication
{
public:
    tstring m_szTitle;
    tstring m_szProtocol;
    WORD    m_wPort;
    tstring m_szTcpResponseList;
    tstring m_szUdpResponseList;
    BOOL    m_bBuiltIn;
    BOOL    m_bSelected;
    DWORD   m_dwSectionNum;
};

// Server PortMapping Protocol
class CSharedAccessServer
{
public:
    CSharedAccessServer();
    tstring m_szTitle;
    tstring m_szProtocol;
    WORD    m_wPort;
    WORD    m_wInternalPort;
    tstring m_szInternalName;
    tstring m_szReservedAddress;
    BOOL    m_bBuiltIn;
    BOOL    m_bSelected;
    DWORD   m_dwSectionNum;

};

// ICS upgrade settings
typedef struct _ICS_UPGRADE_SETTINGS
{
  RASSHARECONN rscExternal;
  list<CSharedAccessServer>      listSvrPortmappings;
  list<CSharedAccessApplication> listAppPortmappings;
  list<GUID>   listPersonalFirewall; // a list of interface guid to be firewall
  list<GUID>   listBridge;    // a list of interface guid to form a bridge
  
  GUID guidInternal;          // internal interface guid of ICS
  BOOL fInternalAdapterFound; // guidInternal is valid
  BOOL fInternalIsBridge;     // ICS private is a bridge
  
  BOOL fEnableICS;            // ICS enabled
  BOOL fShowTrayIcon;
  BOOL fDialOnDemand;

  // flag to tell this is an upgrade from Win9x
  BOOL fWin9xUpgrade;
  // flag to tell at least one of the internal adapters couldn't be upgraded
  BOOL fWin9xUpgradeAtLeastOneInternalAdapterBroken;
  // flag to tell this is an upgrade from Windows 2000
  BOOL fWin2KUpgrade;
  // flag to tell this is an unattended Homenet clean setup on XP or later
  BOOL fXpUnattended;
} ICS_UPGRADE_SETTINGS, *PICS_UPGRADE_SETTINGS;


HRESULT GetPhonebookDirectory(TCHAR* pszPathBuf);
HRESULT GetServerMappings(list<CSharedAccessServer> &lstSharedAccessServers);
HRESULT GetApplicationMappings(list<CSharedAccessApplication> &lstSharedAccessApplications);
HRESULT PutResponseStringIntoArray(CSharedAccessApplication& rsaaAppProt,
        USHORT* pdwcResponse, HNET_RESPONSE_RANGE** pphnrrResponseRange);
HRESULT BuildIcsUpgradeSettingsFromWin2K(ICS_UPGRADE_SETTINGS* pIcsUpgrdSettings);
HRESULT UpgradeIcsSettings(ICS_UPGRADE_SETTINGS * pIcsUpgrdSettings);
HRESULT BackupAndDelIcsRegistryValuesOnWin2k();
HRESULT LoadIcsSettingsFromAnswerFile(CWInfFile* pwifAnswerFile, 
                                        PICS_UPGRADE_SETTINGS pSettings);
HRESULT ConvertAdapterStringListToGuidList(IN TStringList& rslAdapters, 
                                           IN OUT list<GUID>& rlistGuid);
void    FreeIcsUpgradeSettings(ICS_UPGRADE_SETTINGS* pIcsUpgrdSettings);
void    SetIcsDefaultSettings(ICS_UPGRADE_SETTINGS * pSettings);
BOOL    FNeedIcsUpgradeFromWin2K();
BOOL    FOsIsAdvServerOrHigher();


extern HRESULT HNetCreateBridge(                    
                IN INetConnection * rgspNetConns[],
                OUT IHNetBridge ** ppBridge);
extern HRESULT HrEnablePersonalFirewall(
                IN  INetConnection * rgspNetConns[] );
extern HRESULT HrCreateICS(
                IN INetConnection * pPublicConnection,    
                IN INetConnection * pPrivateConnection);
                    
                                 
                                 
                                 
                         
                         
                         
//--------- ICS Upgrade helpers end---------------------------

//--------- HNet helpers begin---------------------------
class CIcsUpgrade
{
public:
    CIcsUpgrade() : m_pIcsUpgradeSettings(0), m_spEnum(0), 
            m_fInited(FALSE), m_fICSCreated(FALSE),
            m_hIcsUpgradeEvent(NULL), m_pExternalNetConn(0) {};
    ~CIcsUpgrade() {FinalRelease();};
    HRESULT Init(ICS_UPGRADE_SETTINGS* pIcsUpgradeSettings);
    HRESULT StartUpgrade();
private:
    // disallow copy constructor and assignment
    CIcsUpgrade(CIcsUpgrade&);
    CIcsUpgrade& operator=(CIcsUpgrade&);

    void FinalRelease();
    HRESULT SetupHomenetConnections();
    HRESULT CIcsUpgrade::GetINetConnectionArray(
                IN     list<GUID>&       rlistGuid,
                IN OUT INetConnection*** pprgINetConn, 
                IN OUT DWORD*            pcINetConn);
    HRESULT GetExternalINetConnection(INetConnection** ppNetCon);
    HRESULT GetINetConnectionByGuid(GUID* pGuid, INetConnection** ppNetCon);
    HRESULT GetINetConnectionByName(WCHAR* pwszConnName, INetConnection** ppNetCon);

    HRESULT SetupApplicationProtocol();
    HRESULT SetupServerPortMapping();
    HRESULT SetupIcsMiscItems();

    HRESULT FindMatchingPortMappingProtocol(
                IHNetProtocolSettings*      pHNetProtocolSettings, 
                UCHAR                       ucProtocol, 
                USHORT                      usPort, 
                IHNetPortMappingProtocol**  ppHNetPortMappingProtocol);
    HRESULT FindMatchingApplicationProtocol(
                IHNetProtocolSettings*      pHNetProtocolSettings, 
                UCHAR                       ucProtocol, 
                USHORT                      usPort, 
                IHNetApplicationProtocol**  ppHNetApplicationProtocol);

    // named event to let HNetCfg know that we're in GUI Mode Setup
    HRESULT CreateIcsUpgradeNamedEvent();
    
    // methods to fix IP configuration of private interface on Win9x Upgrade
    HRESULT SetPrivateIpConfiguration(IN GUID& rInterfaceGuid);
    HRESULT GetBridgeGuid(OUT GUID& rInterfaceGuid);
    HRESULT GetBridgeINetConn(OUT INetConnection** ppINetConn);
    HRESULT OpenTcpipInterfaceKey(
            IN  GUID&   rGuid,
            OUT PHKEY   phKey);

    // upgrade settings
    ICS_UPGRADE_SETTINGS* m_pIcsUpgradeSettings;
    
    // Init() called
    BOOL m_fInited;

    BOOL m_fICSCreated; // succeeded in creating ICS.

    // named event in GUI Mode setup,
    // hnetcfg will check this to avoid any problems in GUI Mode Setup
    HANDLE m_hIcsUpgradeEvent;

    // cached HNet stuff
    CComPtr<IEnumNetConnection> m_spEnum;
    INetConnection* m_pExternalNetConn;
};
//--------- HNet helpers end---------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\netoemdh.h ===
#pragma once

HRESULT HrSetupNetOemDhInfo();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\ncsysprp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       N C S Y S P R P . C P P
//
//  Contents:   Functions that related to SysPrep.exe requiremnts.
//
//  Notes: 1. 
//          1.a sysprep calls NetSetupPrepareSysPrep
//          1.b NetSetup saves adapter specific settings into $ncsp$.inf file.
//              NetSetup does this by calling INetCfgComponent::SaveAdapterParameters
//              implemented by notify object.
//
//         2.
//          2.a Mini-Setup calls NetSetupRequestWizardPages passing the 
//              "SETUPOPER_MINISETUP" flag right after PnP device installation.
//          2.b NetSetup's InstallUpgradeWorkThrd thread checks the "SETUPOPER_MINISETUP" flag, 
//              if set, it calls FNetSetupApplySysPrep which reads Answer-File "$ncsp$.inf".
//              It then calls notify object's INetCfgComponent::RestoreAdapterParameters
//              to restore adapter specific parameter settings from "$ncsp$.inf" Answer-File.
//
//         3. Only ONE network adapter card is supported on this version.
//
//  Author:     FrankLi    22-April-2000
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma  hdrstop
#include "kkcwinf.h"
#include "ncstring.h"
#include "netcfgp.h"
#include "nsbase.h"
#include "kkutils.h" 
#include "ncnetcfg.h"
#include "lancmn.h"
#include "ncreg.h"
#include "ncsysprp.h"
#include "resource.h"


// constants from ncnetcfg\netinfid.cpp
extern WCHAR c_szInfId_MS_TCPIP[]              = L"ms_tcpip";
extern WCHAR c_szInfId_MS_MSClient[]           = L"ms_msclient";
extern WCHAR c_szInfId_MS_NWClient[]           = L"ms_nwclient";

// constants from ncbase\afilestr.cpp
extern WCHAR c_szRegKeyAnswerFileMap[]         = L"SYSTEM\\Setup\\AnswerFileMap";

// constants for adapter specific sections
const WCHAR c_szParams_MS_TCPIP_Adapter01[]    = L"params.ms_tcpip_Adapter01";
//const WCHAR c_szParams_MS_MSClient_Adapter01[] = L"params.ms_msclient_Adapter01";
//const WCHAR c_szParams_MS_NWClient_Adapter01[] = L"params.ms_nwclient_Adapter01";

// The Answer-File name to save registry settings
static const WCHAR c_szNetConfigSysPrepAnswerFile[]   = L"\\$ncsp$.inf";

// struct to map component Id to its corresponding adapter specific parameter 
// Answer-File section
struct
{
    PCWSTR pwszId;
    PCWSTR pwszIdAdapterParamsSection;
} g_IdMap[] = {{c_szInfId_MS_TCPIP, c_szParams_MS_TCPIP_Adapter01},
                   // no adapter specific parameters for MSClient and NWClient
                   //{c_szInfId_MS_MSClient, c_szParams_MS_MSClient_Adapter01},
                   //{c_szInfId_MS_NWClient, c_szParams_MS_NWClient_Adapter01}
                };

// forward declaration
HRESULT HrSaveNetworkComponentsForSysPrep(INetCfg* pNetCfg);
HRESULT HrRestoreNetworkComponentsForSysPrep(INetCfg* pNetCfg);
HRESULT HrGetFirstAdapterInstanceGuid(INetCfg * pnc, BOOL fDuringSetup, GUID * pGuidAdapter);
BOOL    FSectionHasAtLeastOneKey(IN CWInfFile* pwifAnswerFile, IN PCWSTR pszSection);



//-------------------------------------------------------------------------
// internal helper APIs used by CNetCfgSysPrep implementation 
// to save settings from notify object:

// Purpose: save REG_DWORD to our internal CWinfFile object
inline HRESULT HrSetupSetFirstDword(IN HWIF   hwif,
                                    IN PCWSTR pwszSection,
                                    IN PCWSTR pwszKey,
                                    IN DWORD  dwValue)
{
    Assert (hwif && pwszSection && pwszKey);
    CWInfFile* pwifAnswerFile = reinterpret_cast<PCWInfFile>(hwif);
    PCWInfSection pwifSection = pwifAnswerFile->FindSection(pwszSection);
    if (pwifSection)
    {
        pwifAnswerFile->GotoEndOfSection(pwifSection);
        pwifAnswerFile->AddKey(pwszKey, dwValue);
        return S_OK;
    }
    else
        return S_FALSE;
}

// Purpose: save REG_SZ to our internal CWinfFile object
inline HRESULT HrSetupSetFirstString(IN HWIF   hwif,
                                     IN PCWSTR pwszSection,
                                     IN PCWSTR pwszKey,
                                     IN PCWSTR pwszValue)
{
    Assert (hwif && pwszSection && pwszKey && pwszValue);
    CWInfFile* pwifAnswerFile = reinterpret_cast<PCWInfFile>(hwif);

    PCWInfSection pwifSection = pwifAnswerFile->FindSection(pwszSection);
    if (pwifSection)
    {
        pwifAnswerFile->GotoEndOfSection(pwifSection);
        pwifAnswerFile->AddKey(pwszKey, pwszValue);
        return S_OK;
    }
    else
        return S_FALSE;
}

// Purpose: save BOOL data to our internal CWinfFile object
inline HRESULT HrSetupSetFirstStringAsBool(IN HWIF   hwif,
                                           IN PCWSTR pwszSection,
                                           IN PCWSTR pwszKey,
                                           IN BOOL   fValue)
{
    Assert (hwif && pwszSection && pwszKey);
    CWInfFile* pwifAnswerFile = reinterpret_cast<PCWInfFile>(hwif);

    PCWInfSection pwifSection = pwifAnswerFile->FindSection(pwszSection);
    if (pwifSection)
    {
        pwifAnswerFile->GotoEndOfSection(pwifSection);
        pwifAnswerFile->AddBoolKey(pwszKey, fValue);
        return S_OK;
    }
    else
        return S_FALSE;
}

// Purpose: save MULTI_SZ to our internal CWinfFile object
HRESULT HrSetupSetFirstMultiSzField(IN HWIF   hwif,
                                    IN PCWSTR pwszSection,
                                    IN PCWSTR pwszKey, 
                                    IN PCWSTR pmszValue)
{
    HRESULT  hr = S_OK;
    
    Assert (hwif && pwszSection && pwszKey && pmszValue);

    TStringList slValues;
    MultiSzToColString(pmszValue, &slValues);
    if (slValues.empty())
    {
        // empty pmszValue
        return HrSetupSetFirstString(hwif, pwszSection, pwszKey, pmszValue);
    }
    else
    {
        CWInfFile* pwifAnswerFile = reinterpret_cast<PCWInfFile>(hwif);
        PCWInfSection pwifSection = pwifAnswerFile->FindSection(pwszSection);
        if (pwifSection)
        {
            pwifAnswerFile->GotoEndOfSection(pwifSection);
            pwifAnswerFile->AddKey(pwszKey, slValues);
        }
        else
            hr = S_FALSE;
    }
    EraseAndDeleteAll(&slValues);
    return hr;
}

//--------------------------------------------------------------------------
// Implementation of INetCfgSysPrep component
inline HRESULT CNetCfgSysPrep::HrSetupSetFirstDword(
                                                    IN PCWSTR pwszSection, 
                                                    IN PCWSTR pwszKey, 
                                                    IN DWORD  dwValue)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csWrite);
    if (m_hwif)
	{
        hr = ::HrSetupSetFirstDword(
						m_hwif,
                        pwszSection,
						pwszKey,
						dwValue);
	}
	else
	{
		hr = E_FAIL;
	}
    LeaveCriticalSection(&m_csWrite);
    return hr;
}

inline HRESULT CNetCfgSysPrep::HrSetupSetFirstString(
                                                     IN PCWSTR pwszSection, 
                                                     IN PCWSTR pwszKey, 
                                                     IN PCWSTR pwszValue)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csWrite);
    if (m_hwif)
	{
        hr = ::HrSetupSetFirstString(
						m_hwif,
                        pwszSection,
						pwszKey,
						pwszValue);
	}
	else
	{
		hr = E_FAIL;
	}
    LeaveCriticalSection(&m_csWrite);
    return hr;
}

inline HRESULT CNetCfgSysPrep::HrSetupSetFirstStringAsBool(
                                                           IN PCWSTR pwszSection, 
                                                           IN PCWSTR pwszKey, 
                                                           IN BOOL   fValue)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csWrite);
    if (m_hwif)
	{
        hr = ::HrSetupSetFirstStringAsBool(
						m_hwif,
                        pwszSection,
						pwszKey,
						fValue);
	}
	else
	{
		hr = E_FAIL;
	}
    LeaveCriticalSection(&m_csWrite);
    return hr;
}

inline HRESULT CNetCfgSysPrep::HrSetupSetFirstMultiSzField(
                                                           IN PCWSTR pwszSection, 
                                                           IN PCWSTR pwszKey, 
                                                           IN PCWSTR pmszValue)
{
    HRESULT hr = S_OK;

    EnterCriticalSection(&m_csWrite);
    if (m_hwif)
	{
        hr = ::HrSetupSetFirstMultiSzField(
						m_hwif,
                        pwszSection,
						pwszKey,
						pmszValue);
	}
	else
	{
		hr = E_FAIL;
	}
    LeaveCriticalSection(&m_csWrite);
    return hr;
}

//
// Function:    FNetSetupPrepareSysPrep
//
// Purpose:     wrapper for HrSaveNetworkComponentsForSysPrep
//
// Parameters:  
//
// Returns:     TRUE on success, otherwise, FALSE
//
// 
BOOL FNetSetupPrepareSysPrep()
{
    INetCfg* pNetCfg        = NULL;
    BOOL     fInitCom       = TRUE;
    HRESULT  hr;    

    DefineFunctionName("FNetSetupPrepareSysPrep");
    TraceFunctionEntry(ttidNetSetup);

    hr = HrCreateAndInitializeINetCfg(&fInitCom, &pNetCfg, 
                                       FALSE, // no write lock
                                       0,     // don't wait for it
                                       L"Save Configuration for SysPrep",
                                       NULL);
    if (SUCCEEDED(hr))
    {
        // Retain our success in initializing COM only if we asked to
        // initialize COM in the first place.
        if (! fInitCom)
        {
            TraceTag(ttidNetSetup, "%s: Failed to init COM", __FUNCNAME__);
            return FALSE;
        }
        // Save network component per adapter registry settings
        hr = HrSaveNetworkComponentsForSysPrep(pNetCfg);
        if (hr == S_OK)
        {
            // delete the HKLM\SYSTEM\Setup\AnswerFileMap registry key if it exits
            HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyAnswerFileMap);
        }

        HrUninitializeAndReleaseINetCfg (fInitCom, pNetCfg, FALSE);
    }

    TraceError("FNetSetupPrepareSysPrep", hr);
    return (hr == S_OK)? TRUE : FALSE;   
}


//
// Function:    HrSaveNetworkComponentsForSysPrep
//
// Purpose:     Ask notify object to save adapter specific settings
//
// Parameters:  pNetCfg [IN]     - An INetCfg interface
//
// Returns:     HRESULT, S_OK on success
//
// 
// Note: only 1 network adapter card is supported. If there are more than 1,
//       we'll pick the first working one.
HRESULT HrSaveNetworkComponentsForSysPrep(INetCfg* pNetCfg)
{
    HRESULT hr = S_OK;
    GUID    guidAdapter;         // network adapter's Instance GUID
    BOOL    fApplyWrite = FALSE; // flag to save internal registry settings to Answer-File
    BOOL    fRet = TRUE;

    DefineFunctionName("HrSaveNetworkComponentsForSysPrep");

    hr = HrGetFirstAdapterInstanceGuid(pNetCfg, FALSE, &guidAdapter); // FALSE ==> not in setup    
    if (hr != S_OK)
    {
        TraceTag(ttidNetSetup, "%s: HrGetFirstAdapterInstanceGuid failed 0x%08x", __FUNCNAME__, hr);
        return S_FALSE;
    }

    CWInfFile* pwifAnswerFile = new CWInfFile();
    // initialize answer file class
    if ((pwifAnswerFile == NULL) || (pwifAnswerFile->Init() == FALSE))
	{
	    AssertSz(FALSE,"HrSaveNetworkComponentsForSysPrep - Failed to initialize CWInfFile");
        if (pwifAnswerFile)
            delete pwifAnswerFile;
		return(E_OUTOFMEMORY);
	}

    // access INetCfgSysPrep ATL component using C++ instead of CoCreateInstance
    CComObject<CNetCfgSysPrep>* pncsp = new CComObject<CNetCfgSysPrep>;
    // initialize CNetCfgSysPrep class
    if ((pncsp == NULL) || (pncsp->HrInit((HWIF) pwifAnswerFile) != S_OK))
	{
	    AssertSz(FALSE,"HrSaveNetworkComponentsForSysPrep - Failed to initialize CWInfFile");
        delete pwifAnswerFile;
        if (pncsp)
            delete pncsp;
		return(E_OUTOFMEMORY);
	}
    pncsp->AddRef(); // keep a reference to our component

    for (UINT nIdx = 0; nIdx < celems(g_IdMap); nIdx++)
    {
        INetCfgComponent* pINetCfgComponent;
        PCWSTR pwszInfId;
        PCWSTR pwszAdapterParamsSections;

        
        pwszInfId = g_IdMap[nIdx].pwszId;
        pwszAdapterParamsSections = g_IdMap[nIdx].pwszIdAdapterParamsSection;

        hr = pNetCfg->FindComponent(pwszInfId, &pINetCfgComponent);
       
        if (hr == S_OK)
        {
            Assert (pINetCfgComponent);
            // Component has already installed, we'll call notify object's 
            // INetCfgComponentSysPrep::SaveAdapterParameters
            
            // Need to query for the private component interface which
            // gives us access to the notify object.
            //
            INetCfgComponentPrivate* pComponentPrivate;
            hr = pINetCfgComponent->QueryInterface(
                        IID_INetCfgComponentPrivate,
                        reinterpret_cast<void**>(&pComponentPrivate));

            if (hr == S_OK)
            {
                INetCfgComponentSysPrep* pINetCfgComponentSysPrep;

                // Query the notify object for its INetCfgComponentSysPrep interface.
                // If it doesn't support it, that's okay, we can continue.
                //

                hr = pComponentPrivate->QueryNotifyObject(
                                IID_INetCfgComponentSysPrep, 
                                (void**) &pINetCfgComponentSysPrep);
                if (S_OK == hr)
                {
                    // add a section first
                    pwifAnswerFile->AddSection(pwszAdapterParamsSections);
                    // trigger Notify object to save registry settings
                    hr = pINetCfgComponentSysPrep->SaveAdapterParameters(
                                reinterpret_cast<INetCfgSysPrep*>(pncsp), pwszAdapterParamsSections, &guidAdapter);
                    if (hr == S_OK)
                        fApplyWrite = TRUE;
                    ReleaseObj(pINetCfgComponentSysPrep);
                }
                else if (hr == E_NOINTERFACE)
                {
                    TraceTag(ttidNetSetup, "%s: %S component doesn't support IID_INetCfgComponentSysPrep", __FUNCNAME__, pwszInfId);
                }
                else
                    fRet = FALSE; // unexpected error
                ReleaseObj(pComponentPrivate);
            }
            else
            {
                TraceTag(ttidNetSetup, "%s: can't find IID_INetCfgComponentPrivate for component %S", __FUNCNAME__, pwszInfId);
                fRet = FALSE;
            }

            ReleaseObj (pINetCfgComponent);
        }
        else
        {
            // it is okay that this component has not been installed
            TraceTag(ttidNetSetup, "%s: Can't find %S component", __FUNCNAME__, pwszInfId);
        }
    } // end for


    pncsp->SetHWif(NULL); // no more writes for those components holding our INetCfgSysPrep interface
    ReleaseObj(pncsp);    // done with the usage of INetCfgSysPrep component

    if (fApplyWrite)
    {
        WCHAR wszSystemDir[MAX_PATH]; 
        
        // get the path to $ncsp$.inf (NetConfig SysPrep Answer-File)
        if (GetSystemDirectory(wszSystemDir, MAX_PATH) != 0)
        {
            tstring strAnswerFile;
            strAnswerFile = wszSystemDir;
            strAnswerFile += c_szNetConfigSysPrepAnswerFile;
            // save the parameters filled by notify object to Answer-File
            if (! pwifAnswerFile->SaveAsEx(strAnswerFile.c_str()))
                fRet = FALSE;
        }
        else
        {
            TraceTag(ttidNetSetup, "%s: GetSystemDirectory failed 0x%8x", __FUNCNAME__, GetLastError());
            fRet = FALSE;
        }
    }    

    delete pwifAnswerFile;

    return fRet? S_OK : S_FALSE;
}

//
// Function:    FNetSetupApplySysPrep
//
// Purpose:     wrapper for HrRestoreNetworkComponentsForSysPrep
//
// Parameters:  
//
// Returns:     TRUE on success, otherwise, FALSE
//
// Notes:       This causes NetSetup to load the content of 
//              %systemroot%\system32\$ncsp$.inf into a CWInfFile object.
//              Then, NetSetup will instruct notify object to restore their
//              per adatper settings from the corresponding sections of the
//              $ncsp$.inf file. 

BOOL FNetSetupApplySysPrep()
{
    INetCfg* pNetCfg        = NULL;
    BOOL     fInitCom       = TRUE;
    HRESULT  hr;    
    

    DefineFunctionName("FNetSetupApplySysPrep");
    TraceFunctionEntry(ttidNetSetup);

    hr = HrCreateAndInitializeINetCfg(&fInitCom, &pNetCfg, 
                                       FALSE, // no write lock
                                       0,     // don't wait for it
                                       L"Restore Configuration for SysPrep",
                                       NULL);
    if (SUCCEEDED(hr))
    {
        // Retain our success in initializing COM only if we asked to
        // initialize COM in the first place.
        if (! fInitCom)
        {
            TraceTag(ttidNetSetup, "%s: Failed to init COM", __FUNCNAME__);
            return FALSE;
        }
        // Restore network component per adapter registry settings
        hr = HrRestoreNetworkComponentsForSysPrep(pNetCfg);

        HrUninitializeAndReleaseINetCfg (fInitCom, pNetCfg, FALSE);
    }
    
    TraceError("FNetSetupApplySysPrep", hr);
    return (hr == S_OK)? TRUE : FALSE;
}

//
// Function:    HrRestoreNetworkComponentsForSysPrep
//
// Purpose:     read $ncsp$.inf file. If this file has
//              adapter specific sections, trigger the corresponding
//              notify object to restore the settings to registry.
//
// Parameters:  pNetCfg [IN]     - An INetCfg interface
//
// Returns:     HRESULT, S_OK on success
//
// 
HRESULT HrRestoreNetworkComponentsForSysPrep(INetCfg* pNetCfg)
{
    HRESULT hr = S_OK;
    GUID    guidAdapter; // network adapter's Instance GUID
    WCHAR   wszSystemDir[MAX_PATH]; // system32 directory
    tstring strAnswerFile; // Answer-File which was saved by SysPrep
    BOOL    fRet = TRUE; // notify object's status in restore settings

    DefineFunctionName("HrRestoreNetworkComponentsForSysPrep");


    // get the path to $ncsp$.inf (NetConfig SysPrep Answer-File)
    if (GetSystemDirectory(wszSystemDir, MAX_PATH) != 0)
    {
        strAnswerFile = wszSystemDir;
        strAnswerFile += c_szNetConfigSysPrepAnswerFile;
    }
    else
    {
        TraceTag(ttidNetSetup, "%s: GetSystemDirectory failed 0x%8x", __FUNCNAME__, GetLastError());
        return S_FALSE;
    }

    hr = HrGetFirstAdapterInstanceGuid(pNetCfg, TRUE, &guidAdapter); // TRUE ==> during setup
    if (hr != S_OK)
    {
        TraceTag(ttidNetSetup, "%s: HrGetFirstAdapterInstanceGuid failed 0x%08x", __FUNCNAME__, hr);
        return S_FALSE;
    }

    CWInfFile* pwifAnswerFile = new CWInfFile();
    // initialize answer file class
    if ((pwifAnswerFile == NULL) || (pwifAnswerFile->Init() == FALSE))
	{
	    AssertSz(FALSE,"HrRestoreNetworkComponentsForSysPrep - Failed to initialize CWInfFile");
        if (pwifAnswerFile)
            delete pwifAnswerFile;
		return(E_OUTOFMEMORY);
	}
    // read $ncsp$.inf Answer-File into pwifAnswerFile object
    if (pwifAnswerFile->Open(strAnswerFile.c_str()) == FALSE)
    {
        TraceTag(ttidNetSetup, "%s: pwifAnswerFile->Open failed 0x%08x", __FUNCNAME__);
        delete pwifAnswerFile;
        return S_FALSE;
    }

    for (UINT nIdx = 0; nIdx < celems(g_IdMap); nIdx++)
    {
        INetCfgComponent* pINetCfgComponent;
        PCWSTR pwszInfId;  // component ID
        PCWSTR pwszAdapterParamsSections; // adapter specific parameter section 

        
        pwszInfId = g_IdMap[nIdx].pwszId;
        pwszAdapterParamsSections = g_IdMap[nIdx].pwszIdAdapterParamsSection;

        // trigger Notify object to restore registry settings if
        // the section has at least one line of parameter
        pwifAnswerFile->FindSection(pwszAdapterParamsSections);
        if (FSectionHasAtLeastOneKey(pwifAnswerFile, pwszAdapterParamsSections))
        {
            hr = pNetCfg->FindComponent(pwszInfId, &pINetCfgComponent);
            if (hr == S_OK)
            {
                Assert (pINetCfgComponent);
                // Component has already installed, just call notify object's
                // INetCfgComponentSysPrep::RestoreAdapterParameters
            
                // Need to query for the private component interface which
                // gives us access to the notify object.
                //
                INetCfgComponentPrivate* pComponentPrivate;
                hr = pINetCfgComponent->QueryInterface(
                            IID_INetCfgComponentPrivate,
                            reinterpret_cast<void**>(&pComponentPrivate));

                if (hr == S_OK)
                {
                    INetCfgComponentSysPrep* pINetCfgComponentSysPrep;

                    // Query the notify object for its INetCfgComponentSysPrep interface.
                    // If it doesn't support it, that's okay, we can continue.
                    //

                    hr = pComponentPrivate->QueryNotifyObject(
                                    IID_INetCfgComponentSysPrep,
                                    (void**) &pINetCfgComponentSysPrep);
                    if (S_OK == hr)
                    {                    
                        hr = pINetCfgComponentSysPrep->RestoreAdapterParameters(
                                    strAnswerFile.c_str(), pwszAdapterParamsSections, &guidAdapter);
                        if (hr != S_OK)
                            fRet = FALSE; // notify object can't restore settings
                        ReleaseObj(pINetCfgComponentSysPrep);
                    }
                    else if (hr == E_NOINTERFACE)
                    {
                        TraceTag(ttidNetSetup, "%s: %S component doesn't support IID_INetCfgComponentSysPrep", __FUNCNAME__, pwszInfId);

                    }
                    else
                        fRet = FALSE; // unexpected error
                    ReleaseObj(pComponentPrivate);
                }
                else
                {
                    TraceTag(ttidNetSetup, "%s: can't find IID_INetCfgComponentPrivate for component %S", __FUNCNAME__, pwszInfId);
                    fRet = FALSE;
                }
                ReleaseObj (pINetCfgComponent);
            }
            else
            {
                // this component wasn't installed before SysPrep
                TraceTag(ttidNetSetup, "%s: Can't find %S component", __FUNCNAME__, pwszInfId);
            }
        } // end if section has at least one key to restore setting
    } // end for

    // delete the Answer-File in free build.
#ifndef DBG
    DeleteFile(strAnswerFile.c_str());
#endif
    delete pwifAnswerFile;
    return fRet? S_OK : S_FALSE;
}

//
// Function:    FSectionHasAtLeastOneKey
//
// Purpose:     Check if an Answer-File section has at least one key 
//
// Parameters:  pwifAnswerFile [IN] - pointer to a CWInfFile object
//              pszSection [IN]     - the section to check
//
// Returns:     TRUE if found else FALSE
//
BOOL FSectionHasAtLeastOneKey(IN CWInfFile* pwifAnswerFile, IN PCWSTR pwszSection)
{
    Assert(pwifAnswerFile && pwszSection);
    PCWInfSection pwifs = pwifAnswerFile->FindSection(pwszSection);
    if (pwifs == NULL)
        return FALSE;
    PCWInfKey pwifk = pwifs->FirstKey();
    if (pwifs == NULL)
        return FALSE;
    return TRUE;
}

//
// Function:    HrGetFirstAdapterInstanceGuid
//
// Purpose:     Get the first installed adapter instance guid 
//
// Parameters:  pnc [IN]     - An INetCfg interface
//              fDuringSetup [IN] - TRUE when this is being called during the setup time
//              pGuidAdapter [IN,OUT] - Receives an instance GUID of an adapter
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrGetFirstAdapterInstanceGuid(INetCfg * pnc, BOOL fDuringSetup, GUID * pGuidAdapter)
{
    HRESULT      hr = S_OK;

    DefineFunctionName("HrGetFirstAdapterInstanceGuid");
    TraceTag(ttidNetSetup, "HrGetFirstAdapterInstanceGuid - Enter Find first available adapter");

    // Enumerate the available adapters
    Assert(pnc && pGuidAdapter);
    CIterNetCfgComponent nccIter(pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent*    pncc;
    while (SUCCEEDED(hr) &&  (S_OK == (hr = nccIter.HrNext(&pncc))))
    {
        hr = HrIsLanCapableAdapter(pncc);
        TraceError("HrIsLanCapableAdapter", hr);
        if (S_OK == hr)
        {
            DWORD        dw;
            ULONG        ul;
            
            TraceTag(ttidNetSetup, "%s: Found HrIsLanCapableAdapter", __FUNCNAME__);

            if (! fDuringSetup)
            {
                // Is it in used in a connection?
                hr = HrIsConnection(pncc);
                if (hr != S_OK)
                {
                    TraceError("HrGetFirstAdapterInstanceGuid: HrIsConnection", hr);
                    goto NextAdapter;
                }
            }

            // Is this a virtual adapter?
            hr = pncc->GetCharacteristics(&dw);
            if (hr != S_OK)
            {
                TraceError("GetCharacteristics", hr);
                goto NextAdapter;
            }
            if (! (dw & NCF_PHYSICAL))
            {
                TraceTag(ttidNetSetup, "%s: It is not a PHYSICAL adapter", __FUNCNAME__);
                goto NextAdapter;
            }

            // Check device, if not present skip it
            //
            hr = pncc->GetDeviceStatus(&ul);
            if ((hr != S_OK) || (ul != 0))
            {
                TraceTag(ttidNetSetup, "%s: device is not active.", __FUNCNAME__);
                goto NextAdapter;
            }

            // Get the adapter instance guid
            hr = pncc->GetInstanceGuid(pGuidAdapter);
            if (hr != S_OK)
            {
                TraceError("GetInstanceGuid", hr); //
                goto NextAdapter;
            }

            ReleaseObj(pncc);
            return S_OK;
        }

NextAdapter:
        ReleaseObj(pncc);
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\netoemdh.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N E T O E M D H . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "kkutils.h"
#include "ncreg.h"
#include "ncsetup.h"


const INT MAX_TEMPSTR_SIZE = 1024;

static const WCHAR c_szKeyRoot[]     = L"SYSTEM\\CurrentControlSet\\Services\\Ndis\\NetDetect\\";
static const WCHAR c_szInfFileName[] = L"NetOemDh.Inf";


//+---------------------------------------------------------------------------
//
//  function:   SetupNetOemDhInfo
//
//  Purpose:    Create netcard detection info in registry
//
//  Arguments:  none
//
//  Author:     kumarp    17-June-97
//
//  Notes:      this function replaces ParseNetoemdhInfFile.
//              it uses the Win95 style INF file to create the same info
//              that the old function ParseNetoemdhInfFile created.
//              Thus functionally this does not require change in other modules.
//
HRESULT HrSetupNetOemDhInfo()
{
    DefineFunctionName("SetupNetOemDhInfo");

    TraceFunctionEntry(ttidNetSetup);

    HINF hinf=NULL;
    HWND hwnd = NULL;

    HRESULT hr = HrSetupOpenInfFile(c_szInfFileName, NULL,
                    INF_STYLE_WIN4, NULL, &hinf);
    if (SUCCEEDED(hr))
    {
        HKEY hkey;

        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szKeyRoot,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE,
                              NULL, &hkey, NULL);
        if (SUCCEEDED(hr))
        {
            BOOL fStatus =
                ::SetupInstallFromInfSection(hwnd, hinf, L"NetDetect",
                                             SPINST_REGISTRY, hkey,
                                             NULL, NULL, NULL, NULL, NULL, NULL);
            if (!fStatus)
            {
                hr = HrFromLastWin32Error();
            }
            RegSafeCloseKey(hkey);
        }
        ::SetupCloseInfFile(hinf);
    }

    TraceFunctionError(hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\ncsysprp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       N C S Y S P R P . H
//
//  Contents:   INetCfgSysPrep interface declaration
//
//  Notes: 
//
//  Author:     FrankLi    22-April-2000
//
//----------------------------------------------------------------------------

#pragma once
#include <objbase.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "netcfgx.h"
#include "netcfgn.h"


// helpers used by implementation of INetCfgSysPrep to save notify object's 
// registry settings into CWInfFile object
// note: these functions are not thread safe.

typedef LPVOID HWIF; // an opaque type for out internal HrSetupSetXxx APIs
HRESULT
HrSetupSetFirstDword                    (IN HWIF   hwif,
                                         IN PCWSTR pwszSection, // section
                                         IN PCWSTR pwszKey,   // Answer-File key
                                         IN DWORD  dwValue); // Answer-File value
HRESULT
HrSetupSetFirstString                   (IN HWIF   hwif,
                                         IN PCWSTR pwszSection,
                                         IN PCWSTR pwszKey,
                                         IN PCWSTR pwszValue);
HRESULT
HrSetupSetFirstStringAsBool             (IN HWIF   hwif,
                                         IN PCWSTR pwszSection,
                                         IN PCWSTR pwszKey,
                                         IN BOOL   fValue);
HRESULT
HrSetupSetFirstMultiSzField             (IN HWIF   hwif,
                                         IN PCWSTR pwszSection,
                                         IN PCWSTR pwszKey, 
                                         IN PCWSTR pmszValue);

// Implementation of INetCfgSysPrep interface.
// We don't need a class factory, we just need the IUnknown
// implementation from ATL
class ATL_NO_VTABLE CNetCfgSysPrep :
	public CComObjectRoot,
	public INetCfgSysPrep
{
public:

	CNetCfgSysPrep() : m_hwif(NULL) {};
    ~CNetCfgSysPrep() {DeleteCriticalSection(&m_csWrite);};

    BEGIN_COM_MAP(CNetCfgSysPrep)
		COM_INTERFACE_ENTRY(INetCfgSysPrep)
	END_COM_MAP()

	// INetCfgSysPrep methods
	STDMETHOD (HrSetupSetFirstDword) (
        /* [in] */ PCWSTR pwszSection,
	    /* [in] */ PCWSTR pwszKey,
        /* [in] */ DWORD dwValue
        );
    STDMETHOD (HrSetupSetFirstString) (
        /* [in] */ PCWSTR pwszSection,
	    /* [in] */ PCWSTR pwszKey,
        /* [in] */ PCWSTR pwszValue
        );
    STDMETHOD (HrSetupSetFirstStringAsBool) (
        /* [in] */ PCWSTR pwszSection,
	    /* [in] */ PCWSTR pwszKey,
        /* [in] */ BOOL   fValue
        );
    STDMETHOD (HrSetupSetFirstMultiSzField) (
        /* [in] */ PCWSTR pwszSection,
	    /* [in] */ PCWSTR pwszKey,
        /* [in] */ PCWSTR  pmszValue
        );


    HRESULT HrInit(HWIF hwif)
	{
        m_hwif = hwif;
        __try
        {
		    InitializeCriticalSection(&m_csWrite);
            return S_OK;
        }
        __except(GetExceptionCode() == STATUS_NO_MEMORY )
        {
            return (E_OUTOFMEMORY);
        }
        // return E_FAIL for any other exception codes
        return E_FAIL;
	};
    void SetHWif(HWIF hwif) {EnterCriticalSection(&m_csWrite);m_hwif = hwif;LeaveCriticalSection(&m_csWrite);};

protected:
	HWIF    m_hwif;   // handle that will pass to ::HrSetupSetXxx internal APIs
    CRITICAL_SECTION m_csWrite; // crtical section to protect non-atomic writes
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\nuoemupg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N U O E M U P G . C P P
//
//  Contents:   Just includes ..\netupgrd\oemupgex.cpp
//
//  Notes:
//
//  Author:     kumarp    12-November-97
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "..\..\upgrade\netupgrd\oemupgex.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\nslog.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N S L O G . C P P
//
//  Contents:   Functions to log setup errors
//
//  Notes:
//
//  Author:     kumarp    13-May-98
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop

#include <setupapi.h>

#include <nslog.h>

// ----------------------------------------------------------------------
//
// Function:  NetSetupLogStatusVa
//
// Purpose:   Log info to setuplog
//
// Arguments:
//    ls       [in]  type of status
//    szFormat [in]  format str
//    arglist  [in]  list of arguments
//
// Returns:   None
//
// Author:    kumarp 04-June-98
//
// Notes:
//
void NetSetupLogStatusVa(IN LogSeverity ls,
                         IN PCWSTR szFormat,
                         IN va_list arglist)
{
    static WCHAR szTempBuf[2048];
    static const WCHAR c_szPrefix[] = L"NetSetup: ";
    static const UINT c_cchPrefix = celems(c_szPrefix) - 1;

    wcscpy(szTempBuf, c_szPrefix);
    vswprintf(szTempBuf + c_cchPrefix, szFormat, arglist);

    TraceTag(ttidNetSetup, "%S", szTempBuf + c_cchPrefix);
    wcscat(szTempBuf, L"\r\n");

    if (SetupOpenLog(FALSE)) // dont erase existing log file
    {
        if (!SetupLogError(szTempBuf, ls))
        {
            TraceLastWin32Error("SetupLogError failed");
        }
        SetupCloseLog();
    }
    else
    {
        TraceLastWin32Error("Could not open SetupLog!!");
    }
}


// ----------------------------------------------------------------------
//
// Function:  NetSetupLogStatusVa
//
// Purpose:   Log info to setuplog
//
// Arguments:
//    ls       [in]  type of status
//    szFormat [in]  format str
//    ...      [in]  list of arguments
//
// Returns:   None
//
// Author:    kumarp 04-June-98
//
// Notes:
//
void NetSetupLogStatusV(IN LogSeverity ls,
                        IN PCWSTR szFormat,
                        IN ...)
{
    va_list arglist;

    va_start(arglist, szFormat);
    NetSetupLogStatusVa(ls, szFormat, arglist);
    va_end(arglist);
}

// ----------------------------------------------------------------------
//
// Function:  MapHresultToLogSev
//
// Purpose:   Map an HRESULT to LogSeverity
//
// Arguments:
//    hr [in]  status code
//
// Returns:   mapped LogSeverity code
//
// Author:    kumarp 04-June-98
//
// Notes:
//
LogSeverity MapHresultToLogSev(IN HRESULT hr)
{
    LogSeverity ls;

    if (SUCCEEDED(hr))
    {
        ls = LogSevInformation;
    }
    else
    {
        if ((E_FAIL == hr) ||
            (E_OUTOFMEMORY == hr))
        {
            ls = LogSevFatalError;
        }
        else
        {
            ls = LogSevError;
        }
    }

    return ls;
}

// ----------------------------------------------------------------------
//
// Function:  NetSetupLogHrStatusV
//
// Purpose:   Log status using HRESULT status code
//
// Arguments:
//    hr       [in]  status code
//    szFormat [in]  format str
//
// Returns:   None
//
// Author:    kumarp 04-June-98
//
// Notes:
//
void NetSetupLogHrStatusV(IN HRESULT hr,
                          IN PCWSTR szFormat,
                          ...)
{
    va_list arglist;
    LogSeverity ls;
    ls = MapHresultToLogSev(hr);

    va_start(arglist, szFormat);
    NetSetupLogStatusVa(ls, szFormat, arglist);
    va_end(arglist);
}


// ----------------------------------------------------------------------
//
// Function:  NetSetupLogComponentStatus
//
// Purpose:   Log status of performing specified action on a component
//
// Arguments:
//    szCompId [in]  component
//    szAction [in]  action
//    hr       [in]  statuc code
//
// Returns:   None
//
// Author:    kumarp 04-June-98
//
// Notes:
//
void NetSetupLogComponentStatus(IN PCWSTR szCompId,
                                IN PCWSTR szAction,
                                IN HRESULT hr)
{
    static const WCHAR c_szFmt[] =
        L"Status of %s '%s': 0x%x";

    NetSetupLogHrStatusV(hr, c_szFmt, szAction, szCompId, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\nslog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N S L O G . H
//
//  Contents:   Functions to log setup errors
//
//  Notes:
//
//  Author:     kumarp    13-May-98
//
//----------------------------------------------------------------------------

#pragma once

void NetSetupLogStatusVa(IN LogSeverity ls,
                         IN PCWSTR szFormat,
                         IN va_list arglist);
void NetSetupLogStatusV(IN LogSeverity ls,
                        IN PCWSTR szFormat,
                        IN ...);
void NetSetupLogComponentStatus(IN PCWSTR szCompId,
                                IN PCWSTR szAction,
                                IN HRESULT hr);
void NetSetupLogHrStatusV(IN HRESULT hr,
                          IN PCWSTR szFormat,
                          ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\netsetup.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsvc.h"
#include "nslog.h"
#include "wizard.h"



// Setup Wizard Global - Only used during setup.
extern CWizard * g_pSetupWizard;

BOOL FSetupRequestWizardPages(HPROPSHEETPAGE* pahpsp,
                              UINT* pcPages,
                              PINTERNAL_SETUP_DATA psp);
BOOL FSetupFreeWizardPages();
BOOL FNetSetupPrepareSysPrep();
#if !defined(WIN64) && !defined(_WIN64)
BOOL FDoIcsUpgradeIfNecessary();
#endif // !defined(WIN64) && !defined(_WIN64)

//+---------------------------------------------------------------------------
//
//  Function:   DoInitialCleanup
//
//  Purpose:    Called from syssetup before any device is installed.
//
//  Arguments:
//      hwnd [in] parent window
//      pisd [in] setup data
//
//  Returns:    TRUE or FALSE
//
//  Author:     kumarp   3 Dec 1997
//
//  Notes:      This must have the signature of NETSETUPINSTALLSOFTWAREPROC
//              defined in syssetup.h
//
//              DoInitialCleanup is called from syssetup during installs before
//              any device is installed.
//              If you want something to happen before any PnP / wizard
//              stuff happens, this function is the best place to put that code.
//
//
BOOL
WINAPI
DoInitialCleanup (
    HWND hwnd,
    PINTERNAL_SETUP_DATA pisd)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(pisd);

#if DBG
    RtlValidateProcessHeaps ();
#endif

    NetSetupLogStatusV (LogSevInformation,
        SzLoadIds (IDS_SETUP_MODE_STATUS),
        pisd->SetupMode,
        pisd->ProductType,
        pisd->OperationFlags);

    if (pisd->OperationFlags & SETUPOPER_NTUPGRADE)
    {
        extern HRESULT HrEnableServicesDisabledDuringUpgrade();

        // Delete the old NT4 legacy network key.  Valid items will be
        // rewritten on each device install.
        //
        extern const WCHAR c_szRegKeyNt4Adapters[];
        (VOID) HrRegDeleteKeyTree (HKEY_LOCAL_MACHINE, c_szRegKeyNt4Adapters);
    }

    extern HRESULT HrRunAnswerFileCleanSection(IN PCWSTR pszAnswerFileName);
    extern HRESULT HrProcessInfToRunBeforeInstall(IN HWND hwndParent,
                                                  IN PCWSTR szAnswerFileName);
    extern HRESULT HrNetSetupCopyOemInfs(IN PCWSTR szAnswerFileName);

    // Run the [Clean] section in the answerfile
    //
    if (pisd->OperationFlags & SETUPOPER_BATCH)
    {
        AssertValidReadPtr(pisd->UnattendFile);

        // We cannot abort upgrade in GUI setup, so we need to continue
        // even if an error occurs in any of the following functions

        (VOID) HrRunAnswerFileCleanSection(pisd->UnattendFile);

        (VOID) HrProcessInfToRunBeforeInstall(hwnd, pisd->UnattendFile);

        // Copy OEM net INF files using SetupCopyOemInf, if any
        // we want to ignore any error here

        (VOID) HrNetSetupCopyOemInfs(pisd->UnattendFile);
    }

#if DBG
    RtlValidateProcessHeaps ();
#endif

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   NetSetupInstallSoftware
//
//  Purpose:    Exported entrypoint to install network software.
//
//  Arguments:
//      hwnd [in] parent window
//      pisd [in] setup data
//
//  Returns:    TRUE or FALSE
//
//  Author:     scottbri   5 Jul 1997
//
//  Notes:      This must have the signature of NETSETUPINSTALLSOFTWAREPROC
//              defined in syssetup.h
//
EXTERN_C
BOOL
WINAPI
NetSetupInstallSoftware(
    HWND                    hwnd,
    PINTERNAL_SETUP_DATA    pisd )
{
    TraceFileFunc(ttidGuiModeSetup);
    
#if DBG
    RtlValidateProcessHeaps ();
#endif
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   NetSetupRequestWizardPages
//
//  Purpose:    Exported request for wizard pages
//
//  Arguments:
//      pahpsp  [out] property pages provided by us
//      pcPages [out] number of pages provided
//      psp     [in]  setup data
//
//  Returns:
//
//  Author:     scottbri   5 Jul 1997
//
//  Notes:      This must have the signature of NETSETUPPAGEREQUESTPROCNAME
//              defined in syssetup.h
//
EXTERN_C
BOOL
WINAPI
NetSetupRequestWizardPages(
    HPROPSHEETPAGE*         pahpsp,
    UINT*                   pcPages,
    PINTERNAL_SETUP_DATA    psp)
{
    TraceFileFunc(ttidGuiModeSetup);
    
#if DBG
    RtlValidateProcessHeaps ();
#endif
    return FSetupRequestWizardPages(pahpsp, pcPages, psp);
}

//+---------------------------------------------------------------------------
//
//  Function:   NetSetupFinishInstall
//
//  Purpose:    Exported function to finish network installation
//
//  Arguments:
//      hwnd [in] parent window
//      pisd [in] setup data
//
//  Returns:    TRUE or FALSE
//
//  Author:     scottbri   5 Jul 1997
//
//  Notes:      This must have the signature of NETSETUPFINISHINSTALLPROCNAME
//              defined in syssetup.h
//

EXTERN_C
BOOL
WINAPI
NetSetupFinishInstall(
    HWND                    hwnd,
    PINTERNAL_SETUP_DATA    pisd )
{
    TraceFileFunc(ttidGuiModeSetup);
    
#if DBG
    RtlValidateProcessHeaps ();
#endif

#if !defined(WIN64) && !defined(_WIN64)
    // do the ICS Upgrade from Win9x/Win2K if necessary
    // we are doing ICS upgrade here, because
    // 1. we need to wait until HNetCfg.dll components have been registered.
    // 2. we need to wait until Win9x Dial-Up connections have been migrated.

    FDoIcsUpgradeIfNecessary();
#endif // !defined(WIN64) && !defined(_WIN64)

    return FSetupFreeWizardPages();
}

//+---------------------------------------------------------------------------
//
//  Function:   NetSetupAddRasConnection
//
//  Purpose:    Create a new RAS connection.
//
//  Arguments:
//      hwnd   []
//      ppConn []
//
//  Returns:    S_OK, S_FALSE if cancelled or reentered, or an error code.
//
//  Author:     scottbri   3 Nov 1997
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
NetSetupAddRasConnection (
    HWND hwnd,
    INetConnection**    ppConn)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert (FImplies(hwnd, IsWindow(hwnd)));
    Assert (ppConn);

    // Initialize the output parameter.
    //
    *ppConn = NULL;

    HRESULT hr      = S_FALSE;
    HANDLE  hMutex  = NULL;

    // If the PostInstall wizard flag the wizard has already been launched
    //
    hMutex = CreateMutex(NULL, TRUE, SzLoadIds(IDS_WIZARD_CAPTION));
    if ((NULL == hMutex) || (ERROR_ALREADY_EXISTS == GetLastError()))
    {
        // if the mutex already exists try to find the connection window
        //
        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            // Try to get the window handle and set to for ground
            HWND hwndWizard = FindWindow(NULL, SzLoadIds(IDS_WIZARD_CAPTION));
            if (IsWindow(hwndWizard))
            {
                SetForegroundWindow(hwndWizard);
            }
        }
    }
    else
    {
    #ifdef DBG
        if (FIsDebugFlagSet (dfidBreakOnWizard))
        {
            ShellExecute(NULL, L"open", L"cmd.exe", NULL, NULL, SW_SHOW);
            AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                     "\"BreakOnWizard\" has been set. Set your breakpoints now.");
        }
    #endif // DBG

        hr = HrRunWizard(hwnd, FALSE, ppConn, FALSE);
    }

    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "NetSetupAddRasConnection");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   NetSetupPrepareSysPrep
//
//  Purpose:    Exported entrypoint to prepare work items related to SysPrep
//
//  Arguments:
//      None
//
//  Returns:    TRUE or FALSE
//
//  Author:     FrankLi 22 April 2000
//
//  Notes:      This causes NetConfig to save network component per adapter
//              registry settings to an internal persistent format. Initially,
//              a CWInfFile object is used to save the settings in memory. 
//              Finally, the content of the CWInfFile object will be saved as              
//              file in %systemroot%\system32\$ncsp$.inf  (NetConfigSysPrep)
//
EXTERN_C
BOOL
WINAPI
NetSetupPrepareSysPrep()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    return FNetSetupPrepareSysPrep();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\oemupgrd.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O E M U P G R D . H
//
//  Contents:   Functions for OEM upgrade
//
//  Notes:
//
//  Author:     kumarp    13-November-97
//
//----------------------------------------------------------------------------

#pragma once

#include "ncmisc.h"             // for PRODUCT_FLAVOR
#include "ncstring.h"
#include "oemupgex.h"


class COemInfo
{
public:
    COemInfo();
    ~COemInfo();

    HMODULE m_hOemDll;
    tstring m_strOemDir;
    tstring m_strOemDll;
    DWORD   m_dwError;
    PostUpgradeInitializePrototype   m_pfnPostUpgradeInitialize;
    DoPostUpgradeProcessingPrototype m_pfnDoPostUpgradeProcessing;
};


HRESULT HrProcessOemComponent(IN  HWND      hParentWindow,
                              IN  PCWSTR   szOemDir,
                              IN  PCWSTR   szOemDll,
                              IN  NetUpgradeInfo* pNetUpgradeInfo,
                              IN  HKEY      hkeyParams,
                              IN  PCWSTR   szPreNT5Instance,
                              IN  PCWSTR   szNT5InfId,
                              IN  HINF      hinfAnswerFile,
                              IN  PCWSTR   szSectionName);
PRODUCTTYPE MapProductFlagToProductType(IN DWORD dwUpgradeFromProductFlag);
PRODUCTTYPE MapProductFlavorToProductType(IN PRODUCT_FLAVOR pf);
ProductInfo GetCurrentProductInfo();
HRESULT HrProcessInfToRunBeforeInstall(IN HWND hwndParent,
                                       IN PCWSTR szAnswerFileName);

//----------------------------------------------------------------------------

typedef enum
{
    I2R_BeforeInstall,
    I2R_AfterInstall
} EInfToRunValueType;

HRESULT HrAfGetInfToRunValue(IN HINF hinfAnswerFile,
                             IN PCWSTR szAnswerFileName,
                             IN PCWSTR szParamsSection,
                             IN EInfToRunValueType itrType,
                             OUT tstring* pstrInfToRun,
                             OUT tstring* pstrSectionToRun,
                             OUT tstring* pstrInfToRunType);

HRESULT HrNetSetupCopyOemInfs(IN PCWSTR szAnswerFileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\resource.h ===
#pragma once

// Dialog IDs
#define IDD_Exit                       21000
#define IDD_Finish                     21001
#define IDD_FinishSetup                21002
#define IDD_Guard                      21003
#define IDD_Join                       21004
#define IDD_Main                       21005
#define IDD_MainIntro                  21006
#define IDD_Upgrade                    21007
#define IDD_Welcome                    21008
#define IDD_Connect                    21010
#define IDD_Advanced                   21011
#define IDD_Internet_Connection        21012
#define IDD_NetDevSelect               21013
#define IDD_ISP                        21014
#define IDD_FinishOtherWays            21015
#define IDD_ISPSoftwareCD              21016
#define IDD_Broadband_Always_On        21017
#define IDD_FinishNetworkSetupWizard   21018
#define MAX_NET_PAGES                  (IDD_FinishNetworkSetupWizard - IDD_Exit)

#define IDD_Duplicate_Name             21020
#define IDC_ST_AUTOCONFIGLINK          21040
#define IDC_ST_INTERNETLINK            21041
#define IDC_ST_CONNECT_DIALOGPROMPT    21042
#define IDC_ST_DSL_HELPLINK            21043

#define IDC_SELECT_ISP_FINISH          21044
#define IDC_SELECT_MSN_ISP             21045
#define IDC_CLOSE_CHOICE_FINISH        21046

// Control IDs
#define IDC_STATIC1                        -1
#define IDC_STATIC2                        -2
#define IDC_STATIC3                        -3
#define IDC_STATIC4                        -4
#define IDC_STATIC5                        -5

#define TXT_CONNECT_INTERNET            21085
#define TXT_CONNECT_PRIVATE             21086
#define TXT_CONNECTHOME                 21087

#define TXT_UPGRADE_WAIT                21088
#define TXT_UPGRADE_ICON                21089
#define TXT_UPGRADE_INSTRUCTIONS        21090
#define TXT_UPGRADE_TYPICAL_1           21091
#define TXT_UPGRADE_CUSTOM_1            21092
#define TXT_UPGRADE_TYPICAL_1_WS        21093
#define BTN_UPGRADE_TYPICAL             21095
#define BTN_UPGRADE_CUSTOM              21096
#define IDC_UPGRADE_PROGRESS            21197
#define IDC_WELCOME_TEXT1               21098
#define IDC_WELCOME_TEXT2               21099
#define IDC_WELCOME_TEXT3               21100
#define EDT_FINISH_NAME                 21101
#define TXT_FINISH_EDIT_PROMPT          21102
#define TXT_FINISH_PROMPT               21104
#define CHK_CREATE_SHORTCUT             21005
#define TXT_JOIN_DESC                   21106
#define BTN_JOIN_WORKGROUP              21107
#define BTN_JOIN_DOMAIN                 21108
#define EDT_WORKGROUPJOIN_NAME          21109
#define EDT_DOMAINJOIN_NAME             21110
#define TXT_JOIN_WORKGROUP_LINE2        21111
#define CHK_JOIN_CREDS                  21112
#define TXT_MAIN_INTRO_TITLE            21115
#define IDC_WELCOME_CAPTION             21116
#define LVC_NETDEVLIST                  21117

#define CHK_MAIN_DIALUP                 22118 // Must be consecutive
#define CHK_MAIN_VPN                    22119 // Must be consecutive
#define CHK_MAIN_INTERNET               22120 // Must be consecutive
#define CHK_MAIN_PPPOE                  22121 // Must be consecutive
#define CHK_MAIN_ALWAYS_ON              22122 // Must be consecutive
#define CHK_MAIN_INBOUND                22123 // Must be consecutive
#define CHK_MAIN_DIRECT                 22124 // Must be consecutive
#define CHK_MAIN_INTERNET_CONNECTION    22125 // Must be consecutive
#define CHK_MAIN_CONNECTION             22126 // Must be consecutive
#define CHK_MAIN_ADVANCED               22127 // Must be consecutive
#define CHK_MAIN_HOMENET                22128 // Must be consecutive
#define CHK_ISP_INTERNET_CONNECTION     22129 // Must be consecutive
#define CHK_ISP_SOFTWARE_CD             22130 // Must be consecutive
#define CHK_ISP_OTHER_WAYS              22131 // Must be consecutive
#define CHK_SETUP_MSN                   22132 // Must be consecutive
#define CHK_SELECTOTHER                 22133 // Must be consecutive

#define TXT_MAIN_HOMENET                21131
#define TXT_MAIN_DIALUP_1               21132
#define TXT_MAIN_INTERNET_CONNECTION_1  21133
#define TXT_MAIN_VPN_1                  21134
#define TXT_MAIN_INBOUND_1              21135
#define TXT_MAIN_DIRECT_1               21136
#define TXT_MAIN_CONNECTION_1           21137
#define TXT_MAIN_ADVANCED_1             21138
#define TXT_MAIN_PPPOE_1                21139
#define TXT_MAIN_ALWAYS_ON_1            22139
#define TXT_MAIN_INTERNET_1             21140
#define EDT_New_Name                    21141
#define TXT_Caption                     21142
#define EDT_FINISH_TYPE1                21143
#define EDT_FINISH_TYPE2                21144
#define EDT_FINISH_TYPE3                21145
#define EDT_FINISH_TYPE4                21146
#define IDC_FINISH_CHK1                 21160
#define IDC_FINISH_CHK2                 21161
#define IDC_FINISH_CHK3                 21162
#define IDC_FINISH_CHK4                 21163

#define IDS_NCWF_SHARED                 21147
#define IDS_NCWF_FIREWALLED             21148
#define IDS_NCWF_DEFAULT                21149
#define IDS_NCWF_GLOBAL_CREDENTIALS     21150
#define IDS_NCWF_ALLUSER_CONNECTION     21151

// Resource IDs
#define IDR_AVI_SEARCH                  21200
#define IDB_WIZINTRO                    21201
#define IDB_WIZHDR                      21202

// String IDs for Wizard Captions

#define IDS_T_Finish                    21400
#define IDS_ST_Finish                   21401
#define IDS_T_Join                      21402
#define IDS_ST_Join                     21403
#define IDS_T_NetDev                    21404
#define IDS_ST_NetDev                   21405
#define IDS_T_Upgrade                   21406
#define IDS_ST_Upgrade                  21407
#define IDS_T_Main                      21408
#define IDS_ST_Main                     21409
#define IDS_T_Connect                   21410
#define IDS_ST_Connect                  21411
#define IDS_T_Advanced                  21412
#define IDS_ST_Advanced                 21413
#define IDS_T_Internet_Connection       21414
#define IDS_ST_Internet_Connection      21415
#define IDS_T_ISP                       22416
#define IDS_ST_ISP                      22417
#define IDS_T_ConnectionName            22418
#define IDS_ST_ConnectionName_PHONE     22419
#define IDS_DTEXT_ConnectionName_PHONE  22420
#define IDS_ST_ConnectionName_VPN       22421
#define IDS_DTEXT_ConnectionName_VPN    22422
#define IDS_ST_ConnectionName_PPPOE     22423
#define IDS_DTEXT_ConnectionName_PPPOE  22424
#define IDS_ST_ConnectionName_DIRECT    22425
#define IDS_DTEXT_ConnectionName_DIRECT 22426

#define IDS_ERR_COULD_NOT_OPEN_DIR      22427
#define IDS_OnlineServices              22428

// String IDs for joining workgroups and domain
// also for component installation
#define IDS_LAN_FINISH_CAPTION          21416
#define IDS_WIZARD_CAPTION              21417
#define IDS_WORKGROUP                   21418
#define IDS_DOMAIN                      21419
#define IDS_SETUP_CAPTION               21420
#define IDS_DOMMGR_CANT_CONNECT_DC_PW   21421
#define IDS_DOMMGR_CANT_FIND_DC1        21422
#define IDS_DOMMGR_CANT_CONNECT_DC      21423
#define IDS_DOMMGR_CREDENTIAL_CONFLICT  21424
#define IDS_DOMMGR_INVALID_PASSWORD     21425
#define IDS_DOMMGR_ACCESS_DENIED        21426
#define IDS_DOMMGR_NETWORK_UNREACHABLE  21427
#define IDS_DOMMGR_ALREADY_JOINED       21428
#define IDS_DOMMGR_NAME_IN_USE          21429
#define IDS_DOMMGR_NOT_JOINED           21430
#define IDS_DOMMGR_INVALID_DOMAIN       21431
#define IDS_DOMMGR_INVALID_WORKGROUP    21432
#define IDS_E_UNEXPECTED                21433
#define IDS_E_CREATECONNECTION          21434
#define IDS_E_NO_NETCFG                 21435
#define IDS_E_DUP_NAME                  21436
#define IDS_E_INVALID_NAME              21437
#define IDS_E_COMPUTER_NAME_INVALID     21438
#define IDS_E_COMPUTER_NAME_DUPE        21439
#define IDS_E_UNATTENDED_JOIN_DOMAIN    21440
#define IDS_E_UNATTENDED_JOIN_WORKGROUP 21441
#define IDS_E_UNATTENDED_JOIN_DEFAULT_WROKGROUP 21442
#define IDS_E_UNATTENDED_INVALID_ID_SECTION     21443
#define IDS_E_UNATTENDED_COMPUTER_NAME_CHANGED  21444
#define IDS_E_UPGRADE_DNS_INVALID_NAME          21445
#define IDS_E_UPGRADE_DNS_INVALID_NAME_CHAR     21446
#define IDS_E_UPGRADE_DNS_INVALID_NAME_NONRFC   21447
#define IDS_WORKGROUP_PERSONAL          21448
#define IDS_E_FIREWALL_FAILED           21449

// String IDs for strings displayed in dialogs
#define IDS_WELCOME_TEXT2_1             21450
#define IDS_WELCOME_TEXT2_2             21451
#define IDS_JOIN_FAILURE                21452
#define IDS_JOIN_E_WORKGROUP_MSG        21453
#define IDS_JOIN_E_DOMAIN_MSG           21454
#define IDS_JOIN_E_DOMAIN_INVALID_NAME  21455
#define IDS_JOIN_E_DOMAIN_WIN9X_MSG_1   21457
#define IDS_JOIN_E_DOMAIN_WIN9X_MSG_2   21458
#define IDS_TXT_JOIN_DESC_1             21461
#define IDS_TXT_JOIN_DESC_2             21462
#define IDS_TXT_MODE_DESC_1             21463
#define IDS_TXT_MODE_DESC_2             21464
#define IDS_TXT_MAIN_INTRO_TITLE_1      21465
#define IDS_TXT_MAIN_INTRO_TITLE_2      21466
#define IDS_DEFAULT_CONN_NAME           21467
#define IDS_LARGEFONTNAME               21468
#define IDS_LARGEFONTSIZE               21469
#define IDS_FINISH_READONLY_EDT_PROMPT  21470
#define IDS_FINISH_DEFAULT_EDT_PROMPT   21471
#define IDS_FINISH_DEFAULT_PROMPT       21472
#define IDS_BB_NETWORK                  21473
#define IDC_BULLET_1                    21474
#define IDC_BULLET_2                    21475
#define IDC_BULLET_3                    21476
#define IDS_JOIN_DOMAIN_TEXT            21477
#define IDS_JOIN_DOMAIN_CAPTION         21478

// Strings IDs for Provider Name/Descriptions
#define IDS_PROV_LAN                   21480
#define IDS_PROV_LAN_DESC              21481
#define IDS_PROV_DIALUP                21482
#define IDS_PROV_DIALUP_DESC           21483
#define IDS_PROV_VPN                   21484
#define IDS_PROV_VPN_DESC              21485
#define IDS_PROV_INTERNET              21486
#define IDS_PROV_INTERNET_DESC         21487
#define IDS_PROV_INBOUND               21488
#define IDS_PROV_INBOUND_DESC          21489
#define IDS_PROV_DIRECT                21490
#define IDS_PROV_DIRECT_DESC           21491

// String IDS for netsetup log
#define IDS_INIT_FROM_ANSWERFILE         21492
#define IDS_UPDATING                     21493
#define IDS_INSTALLING                   21494
#define IDS_CONFIGURING                  21495
#define IDS_APPLY_INFTORUN               21496
#define IDS_PROCESSING_OEM               21497
#define IDS_GETTING_INSTANCE_GUID        21498
#define IDS_STATUS_OF_APPLYING           21499
#define IDS_CALLING_DETECTION            21500
#define IDS_DETECTION_COMPLETE           21501
#define IDS_TOTAL_CARDS_DETECTED         21502
#define IDS_IGNORED_DETECTED_CARD        21503
#define IDS_DETECTED_CARD                21504
#define IDS_DETECTED_PNP_CARD            21505
#define IDS_ADDED_UNDETECTED_CARD        21506
#define IDS_DIDNT_ADD_UNDETECTED_CARD    21507
#define IDS_DETECTION_STATUS             21508
#define IDS_SETUP_MODE_STATUS            21509
#define IDS_LOADING                      21510
#define IDS_POSTUPGRADEINIT_EXCEPTION    21511
#define IDS_POSTUPGRADE_INIT             21512
#define IDS_POSTUPGRADE_PROCESSING       21513
#define IDS_POSTUPGRADEPROC_EXCEPTION    21514
#define IDS_OEMINF_COPY                  21515
#define IDS_CALLING_COPY_OEM_INF         21516
#define IDS_INVALID_PREUPGRADE_START     21517
#define IDS_IGNORED_SERVICE_PREUPGRADE   21518
#define IDS_FORCING_DEMAND_START         21519
#define IDS_RESTORING_START_TYPE         21520
#define IDS_ANSWERFILE_SECTION_NOT_FOUND 21521
#define IDS_ONLY_ONE_INBOUND             21522

// String IDS for Homenet unattended and ICS upgrade.
#define IDS_TXT_CANT_UPGRADE_ICS            21523
#define IDS_TXT_CANT_UPGRADE_ICS_ADS_DTC    21524
#define IDS_TXT_CANT_CREATE_BRIDGE          21525
#define IDS_TXT_CANT_CREATE_ICS             21526
#define IDS_TXT_CANT_FIREWALL               21527
#define IDS_TXT_HOMENET_INVALID_AF_SETTINGS 21528
#define IDS_TXT_E_ADAPTER_TO_GUID           21529


// Answerfile errors
#define IDS_E_AF_InvalidValueForThisKey                     4001
#define IDS_E_AF_JoinDomainOrWorkgroup                      4002
#define IDS_E_AF_AdminNameAndPasswordMsg                    4003
#define IDS_E_AF_NoAdminInfoOnJoinWorkgroup                 4004
#define IDS_E_AF_Missing                                    4006
#define IDS_E_AF_SpecifyInfIdWhenNotDetecting               4007
#define IDS_E_AF_InvalidBindingAction                       4008
#define IDS_E_AF_AnsFileHasErrors                           4009
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\version.h ===
#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Setup Wizard"
#define VER_INTERNALNAME_STR            "netshell.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\upgrade.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       U P G R A D E . C P P
//
//  Contents:   functions related only to network upgrade
//              (i.e. not used when installing fresh)
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nsbase.h"

#include "afileint.h"
#include "afilestr.h"
#include "afilexp.h"
#include "kkreg.h"
#include "kkutils.h"
#include "ncatl.h"
#include "nceh.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "resource.h"
#include "upgrade.h"
#include "nslog.h"
#include "winsock2.h"       // For WSCEnumProtocols
#include "ws2spi.h"
#include "sporder.h"        // For WSCWriteProviderOrder

// ----------------------------------------------------------------------
// String constants
// ----------------------------------------------------------------------
extern const WCHAR c_szSvcRasAuto[];
extern const WCHAR c_szSvcRouter[];
extern const WCHAR c_szSvcRemoteAccess[];
extern const WCHAR c_szSvcRipForIp[];
extern const WCHAR c_szSvcRipForIpx[];
extern const WCHAR c_szSvcDhcpRelayAgent[];
extern const WCHAR c_szInfId_MS_RasSrv[];

// ----------------------------------------------------------------------
// forward declarations
// ----------------------------------------------------------------------
// returns S_OK on success.
typedef HRESULT (*HrOemComponentUpgradeFnPrototype) (IN DWORD   dwUpgradeFlag,
                                                     IN DWORD   dwUpgradeFromBuildNumber,
                                                     IN PCWSTR pszAnswerFileName,
                                                     IN PCWSTR pszAnswerFileSectionName);


BOOL InitWorkForWizIntro();

// ----------------------------------------------------------------------

static const WCHAR c_szCleanSection[]        = L"Clean";
static const WCHAR c_szCleanServicesSection[]= L"Clean.Services";

const WCHAR c_szRouterUpgradeDll[] = L"rtrupg.dll";
const CHAR  c_szRouterUpgradeFn[] =  "RouterUpgrade";


// ----------------------------------------------------------------------

#define RGAS_SERVICES_HOME              L"SYSTEM\\CurrentControlSet\\Services"

// ----------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   HrRunAnswerFileCleanSection
//
//  Purpose:    Runs the [Clean] section of the answer file to remove old
//              registry entries and services.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if succeeded, SetupAPI error otherwise
//
//  Author:     danielwe   12 Jun 1997
//
//  Notes:
//
HRESULT HrRunAnswerFileCleanSection(IN PCWSTR pszAnswerFileName)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrRunAnswerFileCleanSection");
    TraceFunctionEntry(ttidNetSetup);

    AssertValidReadPtr(pszAnswerFileName);

    TraceTag(ttidNetSetup, "%s: Cleaning services and registry keys based "
             "on params in the answer file %S.", __FUNCNAME__, pszAnswerFileName);

    HRESULT hr;
    HINF    hinf;
    hr = HrSetupOpenInfFile(pszAnswerFileName, NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL, &hinf);
    if (S_OK == hr)
    {
        BOOL frt;

        // It may say "Install" but this really deletes a bunch of
        // registry "leftovers" from previous installs
        frt = SetupInstallFromInfSection(NULL, hinf, c_szCleanSection,
                                         SPINST_ALL, NULL, NULL, NULL,
                                         NULL, NULL, NULL, NULL);
        if (frt)
        {
            frt = SetupInstallServicesFromInfSection(hinf,
                                                     c_szCleanServicesSection,
                                                     0);
            if (!frt)
            {
                hr = HrFromLastWin32Error();
                TraceErrorOptional("SetupInstallServicesFromInfSection", hr,
                                   (hr == HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND)));
            }
        }
        else
        {
            hr = HrFromLastWin32Error();
            TraceErrorOptional("SetupInstallServicesFromInfSection", hr,
                               (hr == HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND)));
        }
        SetupCloseInfFile(hinf);
    }

    if (HRESULT_FROM_SETUPAPI(ERROR_SECTION_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceError("HrRunAnswerFileCleanSection", hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrSaveInstanceGuid
//
// Purpose:   Save instance guid of the specified component to the registry
//
// Arguments:
//    pszComponentName [in]  name of
//    pguidInstance    [in]  pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT HrSaveInstanceGuid(
    IN PCWSTR pszComponentName,
    IN const GUID* pguidInstance)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrSaveInstanceGuid");

    AssertValidReadPtr(pszComponentName);
    AssertValidReadPtr(pguidInstance);

    HRESULT hr;
    HKEY hkeyMap;

    hr = HrRegCreateKeyEx (
            HKEY_LOCAL_MACHINE,
            c_szRegKeyAnswerFileMap,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
            &hkeyMap, NULL);

    if (S_OK == hr)
    {
        hr = HrRegSetGuidAsSz (hkeyMap, pszComponentName, *pguidInstance);

        RegCloseKey (hkeyMap);
    }

    TraceFunctionError(hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrLoadInstanceGuid
//
// Purpose:   Load instance guid of the specified component from registry
//
// Arguments:
//    pszComponentName [in]  name of
//    pguidInstance    [out] pointer to
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT HrLoadInstanceGuid(
    IN PCWSTR pszComponentName,
    OUT LPGUID  pguidInstance)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrLoadInstanceGuid");

    Assert (pszComponentName);
    Assert (pguidInstance);

    HRESULT hr;
    HKEY hkeyMap;

    ZeroMemory(pguidInstance, sizeof(GUID));

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            c_szRegKeyAnswerFileMap,
            KEY_READ,
            &hkeyMap);

    if (S_OK == hr)
    {
        WCHAR szGuid[c_cchGuidWithTerm];
        DWORD cbGuid = sizeof(szGuid);

        hr = HrRegQuerySzBuffer (
                hkeyMap,
                pszComponentName,
                szGuid,
                &cbGuid);

        if (S_OK == hr)
        {
            hr = IIDFromString (szGuid, pguidInstance);
        }

        RegCloseKey (hkeyMap);
    }

    TraceFunctionError(hr);
    return hr;
}

static const PCWSTR c_aszServicesToIgnore[] =
{
    L"afd",
    L"asyncmac",
    L"atmarp",
    L"dhcp",
    L"nbf",                // see bug 143346
    L"ndistapi",
    L"ndiswan",
    L"nwlnkipx",
    L"nwlnknb",
    L"nwlnkspx",
    L"rpcss",
    L"wanarp",
};

// ----------------------------------------------------------------------
//
// Function:  HrRestoreServiceStartValuesToPreUpgradeSetting
//
// Purpose:   Restore start value of each network service to
//            what was before upgrade
//
// Arguments:
//    pwifAnswerFile [in]  pointer to CWInfFile object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT HrRestoreServiceStartValuesToPreUpgradeSetting(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrRestoreServiceStartValuesToPreUpgradeSetting");

    CWInfSection* pwisServiceStartTypes;

    pwisServiceStartTypes = pwifAnswerFile->FindSection(c_szAfServiceStartTypes);
    if (!pwisServiceStartTypes)
    {
        return S_OK;
    }

    HRESULT hr;
    CServiceManager scm;

    hr = scm.HrOpen();
    if (SUCCEEDED(hr))
    {
        DWORD dwPreUpgRouterStartType=0;
        DWORD dwPreUpgRemoteAccessStartType=0;
        DWORD dwRRASStartType=0;
        DWORD dwPreUpgRipForIpStartType=0;
        DWORD dwPreUpgRipForIpxStartType=0;
        DWORD dwPreUpgDhcpRelayAgentStartType=0;

        // In Windows2000, Router and RemoteAccess have merged.
        // If they have differing service start types before upgrade
        // we use the lower of the two start-type values to set
        // the start-type of "Routing and remote access" service.
        //
        // for more info see bug# 260253
        //
        if (pwisServiceStartTypes->GetIntValue(c_szSvcRouter,
                                               &dwPreUpgRouterStartType) &&
            pwisServiceStartTypes->GetIntValue(c_szSvcRemoteAccess,
                                               &dwPreUpgRemoteAccessStartType))
        {
            dwRRASStartType = min(dwPreUpgRemoteAccessStartType,
                                  dwPreUpgRouterStartType);
            TraceTag(ttidNetSetup, "%s: pre-upg start-types:: Router: %d, RemoteAccess: %d",
                     __FUNCNAME__, dwPreUpgRouterStartType,
                     dwPreUpgRemoteAccessStartType);
        }

        // 306202: if IPRIP/IPXRIP/DHCPrelayagent were in use on NT4, set RRAS to Auto
        //
        if (pwisServiceStartTypes->GetIntValue(c_szSvcRipForIp, &dwPreUpgRipForIpStartType) &&
            (SERVICE_AUTO_START == dwPreUpgRipForIpStartType))
        {
            TraceTag(ttidNetSetup, "%s: pre-upg start-types:: IPRIP: %d, RemoteAccess: %d",
                     __FUNCNAME__, dwPreUpgRipForIpStartType,
                     dwPreUpgRemoteAccessStartType);
            dwRRASStartType = SERVICE_AUTO_START;
        }

        if (pwisServiceStartTypes->GetIntValue(c_szSvcRipForIpx, &dwPreUpgRipForIpxStartType) &&
            (SERVICE_AUTO_START == dwPreUpgRipForIpxStartType))
        {
            TraceTag(ttidNetSetup, "%s: pre-upg start-types:: RipForIpx: %d, RemoteAccess: %d",
                     __FUNCNAME__, dwPreUpgRipForIpxStartType,
                     dwPreUpgRemoteAccessStartType);
            dwRRASStartType = SERVICE_AUTO_START;
        }

        if (pwisServiceStartTypes->GetIntValue(c_szSvcDhcpRelayAgent, &dwPreUpgDhcpRelayAgentStartType) &&
            (SERVICE_AUTO_START == dwPreUpgDhcpRelayAgentStartType))
        {
            TraceTag(ttidNetSetup, "%s: pre-upg start-types:: DHCPRelayAgent: %d, RemoteAccess: %d",
                     __FUNCNAME__, dwPreUpgDhcpRelayAgentStartType,
                     dwPreUpgRemoteAccessStartType);
            dwRRASStartType = SERVICE_AUTO_START;
        }

        // end 306202

        for (CWInfKey* pwik = pwisServiceStartTypes->FirstKey();
             pwik;
             pwik = pwisServiceStartTypes->NextKey())
        {
            PCWSTR  pszServiceName;
            DWORD    dwPreUpgradeStartValue;

            pszServiceName = pwik->Name();
            AssertValidReadPtr(pszServiceName);

            dwPreUpgradeStartValue = pwik->GetIntValue(-1);
            if (dwPreUpgradeStartValue > SERVICE_DISABLED)
            {
                NetSetupLogStatusV(
                    LogSevError,
                    SzLoadIds (IDS_INVALID_PREUPGRADE_START),
                    pszServiceName);
                continue;
            }

            // We do not want to restore the pre-upgrade start type if:
            // - it is one of c_aszServicesToIgnore AND
            //
            if (FIsInStringArray(c_aszServicesToIgnore,
                                 celems(c_aszServicesToIgnore),
                                 pszServiceName))
            {
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_IGNORED_SERVICE_PREUPGRADE), pszServiceName);
                continue;
            }

            // special case for RRAS, see the comment before the while loop
            if ((dwRRASStartType != 0) &&
                !lstrcmpiW(pszServiceName, c_szSvcRemoteAccess))
            {
                dwPreUpgradeStartValue = dwRRASStartType;
            }

            // 305065: if RasAuto was not disabled on NT4, make it demand-start on NT5
            else if ((SERVICE_DISABLED != dwPreUpgradeStartValue) &&
                !lstrcmpiW(pszServiceName, c_szSvcRasAuto))
            {
                dwPreUpgradeStartValue = SERVICE_DEMAND_START;
                NetSetupLogStatusV(
                    LogSevInformation,
                    SzLoadIds (IDS_FORCING_DEMAND_START),
                    pszServiceName);
            }

            CService service;
            hr = scm.HrOpenService(&service, pszServiceName);

            if (S_OK == hr)
            {
                DWORD dwStartValue;

                hr = service.HrQueryStartType(&dwStartValue);

                if ((S_OK == hr) && (dwStartValue != dwPreUpgradeStartValue))
                {
                    hr = service.HrSetStartType(dwPreUpgradeStartValue);

                    NetSetupLogHrStatusV(hr,
                        SzLoadIds (IDS_RESTORING_START_TYPE),
                        pszServiceName, dwStartValue, dwPreUpgradeStartValue, hr);
                }
            }
        }

        // ignore any errors
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// GUIDs provided for the sole use of this function, which removes incompatible
// Intel Winsock providers
//
const GUID GUID_INTEL_RSVP  = 
    { 0x0f1e5156L, 0xf07a, 0x11cf, 0x98, 0x0e, 0x00, 0xaa, 0x00, 0x58, 0x0a, 0x07 };
const GUID GUID_INTEL_GQOS1 = 
    { 0xbca8a790L, 0xc186, 0x11d0, 0xb8, 0x69, 0x00, 0xa0, 0xc9, 0x08, 0x1e, 0x34 };
const GUID GUID_INTEL_GQOS2 = 
    { 0xf80d1d20L, 0x8b7a, 0x11d0, 0xb8, 0x53, 0x00, 0xa0, 0xc9, 0x08, 0x1e, 0x34 };

//+---------------------------------------------------------------------------
//
//  Function:   HrRemoveEvilIntelRSVPWinsockSPs
//
//  Purpose:    Remove the Intel RSVP Winsock SP's so they don't conflict
//              with the Windows 2000 RSVP provider. This is a complete hack
//              to cure RAID 332622, but it's all we can do this late in the
//              ship cycle. There's not a good general-case fix for this
//              problem.
//
//  Arguments:  
//      (none)
//
//  Returns:    
//
//  Author:     jeffspr   22 Aug 1999
//
//  Notes:      
//
HRESULT HrRemoveEvilIntelWinsockSPs()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr  = S_OK;

    // Now read the new IDs and order them in memory
    //
    INT                 nErr = NO_ERROR;
    ULONG               ulRes;
    DWORD               cbInfo = 0;
    WSAPROTOCOL_INFO*   pwpi = NULL;
    WSAPROTOCOL_INFO*   pwpiInfo = NULL;

    // First get the size needed
    //
    ulRes = WSCEnumProtocols(NULL, NULL, &cbInfo, &nErr);
    if ((SOCKET_ERROR == ulRes) && (WSAENOBUFS == nErr))
    {
        pwpi = reinterpret_cast<WSAPROTOCOL_INFO*>(new BYTE[cbInfo]);
        if (pwpi)
        {
            // Find out all the protocols on the system
            //
            ulRes = WSCEnumProtocols(NULL, pwpi, &cbInfo, &nErr);
            if (SOCKET_ERROR != ulRes)
            {
                ULONG cProt = 0;

                for (pwpiInfo = pwpi, cProt = ulRes;
                     cProt;
                     cProt--, pwpiInfo++)
                {
                    BOOL fDeleteMe = FALSE;

                    if (IsEqualGUID(GUID_INTEL_RSVP, pwpiInfo->ProviderId))
                    {
                        fDeleteMe = TRUE;
                    }
                    else if (IsEqualGUID(GUID_INTEL_GQOS1, pwpiInfo->ProviderId))
                    {
                        fDeleteMe = TRUE;
                    }
                    else if (IsEqualGUID(GUID_INTEL_GQOS2, pwpiInfo->ProviderId))
                    {
                        fDeleteMe = TRUE;
                    }

                    if (fDeleteMe)
                    {
                        int iErrNo = 0;
                        int iReturn = WSCDeinstallProvider(
                            &pwpiInfo->ProviderId, &iErrNo);

                        TraceTag(ttidNetSetup, 
                            "SP Removal guid: %08x %04x %04x %02x%02x %02x%02x%02x%02x%02x%02x", 
                            pwpiInfo->ProviderId.Data1,
                            pwpiInfo->ProviderId.Data2,
                            pwpiInfo->ProviderId.Data3,
                            pwpiInfo->ProviderId.Data4[0],
                            pwpiInfo->ProviderId.Data4[1],
                            pwpiInfo->ProviderId.Data4[2],
                            pwpiInfo->ProviderId.Data4[3],
                            pwpiInfo->ProviderId.Data4[4],
                            pwpiInfo->ProviderId.Data4[5],
                            pwpiInfo->ProviderId.Data4[6],
                            pwpiInfo->ProviderId.Data4[7],
                            pwpiInfo->ProviderId.Data4[8]);

                        TraceTag(ttidNetSetup, 
                            "Removing incompatible RSVP WS provider: %S (%d, %04x), ret=%d, ierr=%d",
                            pwpiInfo->szProtocol, pwpiInfo->dwCatalogEntryId, 
                            pwpiInfo->dwCatalogEntryId,
                            iReturn, iErrNo);
                    }
                }
            }
            else
            {
                TraceTag(ttidNetSetup, "Socket error in secondary WSCEnumProtocols");
            }

            delete pwpi;
        }
    }
    else
    {
        TraceTag(ttidNetSetup, "Socket error in initial WSCEnumProtocols");
    }

    TraceHr(ttidNetSetup, FAL, hr, FALSE, "HrRemoveEvilIntelWinsockSPs");

    // Yes, we track hr for debugging purposes, but we don't ever want to 
    // fail based on a failed removal of incompatible Winsock providers
    //
    return S_OK;
}

BOOL FIsValidCatalogId(WSAPROTOCOL_INFO *pwpi, ULONG cProt, DWORD dwCatId)
{                    
    TraceFileFunc(ttidGuiModeSetup);
    
    for (; cProt; cProt--, pwpi++)
    {
        if (dwCatId == pwpi->dwCatalogEntryId)
            return TRUE;
    }

    return FALSE;
}

HRESULT HrRestoreWinsockProviderOrder(IN CWInfFile* pwifAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT         hr = S_OK;
    vector<DWORD>   vecIds;
    CWInfSection *  pwisWinsock;

    DefineFunctionName("HrRestoreWinsockProviderOrder");

    // First get the old IDs into a vector of DWORDs
    //
    pwisWinsock = pwifAnswerFile->FindSection(c_szAfSectionWinsock);
    if (pwisWinsock)
    {
        tstring     strOrder;
        PWSTR       pszOrder;
        PWSTR       pszId;

        pwisWinsock->GetStringValue(c_szAfKeyWinsockOrder, strOrder);
        if (!strOrder.empty())
        {
            pszOrder = SzDupSz(strOrder.c_str());

            pszId = wcstok(pszOrder, L".");
            while (pszId)
            {
                DWORD   dwId = wcstoul(pszId, NULL, 10);

                vecIds.push_back(dwId);
                pszId = wcstok(NULL, L".");
            }

            delete pszOrder;

            // Now read the new IDs and order them in memory
            //
            INT                 nErr;
            ULONG               ulRes;
            DWORD               cbInfo = 0;
            WSAPROTOCOL_INFO*   pwpi = NULL;
            WSAPROTOCOL_INFO*   pwpiInfo = NULL;

            // First get the size needed
            //
            ulRes = WSCEnumProtocols(NULL, NULL, &cbInfo, &nErr);
            if ((SOCKET_ERROR == ulRes) && (WSAENOBUFS == nErr))
            {
                pwpi = reinterpret_cast<WSAPROTOCOL_INFO*>(new BYTE[cbInfo]);
                if (pwpi)
                {
                    // Find out all the protocols on the system
                    //
                    ulRes = WSCEnumProtocols(NULL, pwpi, &cbInfo, &nErr);

                    if (SOCKET_ERROR != ulRes)
                    {
                        ULONG   cProt;
                        vector<DWORD>::iterator     iterLocation;

                        iterLocation = vecIds.begin();

                        for (pwpiInfo = pwpi, cProt = ulRes;
                             cProt;
                             cProt--, pwpiInfo++)
                        {
                            if (vecIds.end() == find(vecIds.begin(),
                                                     vecIds.end(),
                                                     pwpiInfo->dwCatalogEntryId))
                            {
                                // Not already in the list.. Add it after the last
                                // entry we added (or the front if this is the first
                                // addition)
                                iterLocation = vecIds.insert(iterLocation,
                                                             pwpiInfo->dwCatalogEntryId);
                            }
                        }

                        DWORD * pdwIds = NULL;
                        DWORD * pdwCurId;
                        DWORD   cdwIds = vecIds.size();

                        pdwIds = new DWORD[ulRes];
                        if (pdwIds)
                        {
#if DBG
                            DWORD   cValid = 0;
#endif
                            for (pdwCurId = pdwIds, iterLocation = vecIds.begin();
                                 iterLocation != vecIds.end();
                                 iterLocation++, pdwCurId++)
                            {
                                // Make sure we only re-order valid catalog
                                // IDs
                                if (FIsValidCatalogId(pwpi, ulRes, *iterLocation))
                                {
#if DBG
                                    cValid++;
#endif
                                    *pdwCurId = *iterLocation;
                                }
                            }

                            AssertSz(ulRes == cValid, "Number of providers is"
                                     " different!");

                            // Restore the winsock provider order
                            //
                            nErr = WSCWriteProviderOrder(pdwIds, cdwIds);

                            delete pdwIds;
                        }
                    }

                    delete pwpi;
                }
            }
        }
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrUpgradeOemComponent
//
// Purpose:   Upgrade a component. This started as a generalized function
//            but currently it is being used only by HrUpgradeRouterIfPresent
//
// Arguments:
//    pszComponentToUpgrade     [in]  component to upgrade
//    pszDllName                [in]  name of DLL to load
//    psznEntryPoint             [in]  entry point to call
//    dwUpgradeFlag            [in]  upgrade flag
//    dwUpgradeFromBuildNumber [in]  upgrade to build number
//    pszAnswerFileName         [in]  name of answerfile
//    pszAnswerFileSectionName  [in]  name of answerfile section name to use
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT
HrUpgradeOemComponent (
    IN PCWSTR pszComponentToUpgrade,
    IN PCWSTR pszDllName,
    IN PCSTR psznEntryPoint,
    IN DWORD dwUpgradeFlag,
    IN DWORD dwUpgradeFromBuildNumber,
    IN PCWSTR pszAnswerFileName,
    IN PCWSTR pszAnswerFileSectionName)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrUpgradeOemComponent");

    HRESULT hr=E_FAIL;

    HrOemComponentUpgradeFnPrototype pfn;
    HMODULE hLib;

    TraceTag(ttidNetSetup,
             "%s: calling function '%s' in '%S' to upgrade component: %S...",
             __FUNCNAME__, psznEntryPoint, pszDllName, pszComponentToUpgrade);

    hr = HrLoadLibAndGetProc(pszDllName, psznEntryPoint, &hLib, (FARPROC*) &pfn);
    if (S_OK == hr)
    {
        NC_TRY
        {
            hr = pfn(dwUpgradeFlag, dwUpgradeFromBuildNumber,
                     pszAnswerFileName, pszAnswerFileSectionName);
        }
        NC_CATCH_ALL
        {
            hr = E_UNEXPECTED;
        }
        FreeLibrary(hLib);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrUpgradeRouterIfPresent
//
// Purpose:   Upgrade the Router service if present
//
// Arguments:
//    pnii [in]  pointer to CNetInstallInfo object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 23-December-97
//
// Notes:
//
HRESULT HrUpgradeRouterIfPresent(
    IN INetCfg* pNetCfg,
    IN CNetInstallInfo* pnii)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrUpgradeRouterIfPresent");

    HRESULT hr=S_FALSE;
    INFCONTEXT ic;
    PCWSTR pszRouterParamsSection=NULL;

    CNetComponent* pnc = pnii->FindFromInfID(L"ms_rasrtr");
    if (pnc)
    {
        // Ensure RemoteAccess is installed.  In the case of upgrade from
        // NT4 with Steelhead, we wouldn't have written a section to
        // the answerfile for RemoteAccess and consequently it would not
        // have been installed yet.  We need to install it before we turn
        // the router upgrade DLL loose.  In the case when RemoteAccess
        // is already installed, this is a no-op.
        //
        hr = HrInstallComponentOboUser (pNetCfg, NULL,
                GUID_DEVCLASS_NETSERVICE,
                c_szInfId_MS_RasSrv,
                NULL);


        if (SUCCEEDED(hr))
        {
            // we call rtrupg.dll if atleast one of the following keys
            // is present in the params.MS_RasRtr section
            // - PreUpgradeRouter
            // - Sap.Parameters
            // - IpRip.Parameters
            //
            pszRouterParamsSection = pnc->ParamsSections().c_str();

            hr = HrSetupFindFirstLine(pnii->m_hinfAnswerFile, pszRouterParamsSection,
                                      c_szAfPreUpgradeRouter, &ic);
            if (S_OK != hr)
            {
                hr = HrSetupFindFirstLine(pnii->m_hinfAnswerFile, pszRouterParamsSection,
                                          c_szAfNwSapAgentParams, &ic);
            }

            if (S_OK != hr)
            {
                hr = HrSetupFindFirstLine(pnii->m_hinfAnswerFile, pszRouterParamsSection,
                                          c_szAfIpRipParameters, &ic);
            }

            if (S_OK != hr)
            {
                hr = HrSetupFindFirstLine(pnii->m_hinfAnswerFile, pszRouterParamsSection,
                                          c_szAfDhcpRelayAgentParameters, &ic);
            }

            if (S_OK == hr)
            {
                hr = HrUpgradeOemComponent(L"ms_rasrtr",
                                           c_szRouterUpgradeDll,
                                           c_szRouterUpgradeFn,
                                           pnii->UpgradeFlag(),
                                           pnii->BuildNumber(),
                                           pnii->AnswerFileName(),
                                           pszRouterParamsSection);
            }
        }
    }

    if (!pnc ||
        (SPAPI_E_LINE_NOT_FOUND == hr))
    {
        TraceTag(ttidNetSetup, "%s: PreUpgradeRouter/Sap.Parameters/IpRip.Parameters key is not in answerfile, %S will not be called", __FUNCNAME__,
                 c_szRouterUpgradeDll);
    }

    TraceErrorOptional(__FUNCNAME__, hr, ((hr == S_FALSE) ||
                                          (SPAPI_E_LINE_NOT_FOUND == hr)));

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUpgradeTapiServer
//
// Purpose:   Handle upgrade requirements of TAPI server
//
// Arguments:
//    hinfAnswerFile [in]  handle of AnswerFile
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 28-January-99
//
// Notes:
//
HRESULT HrUpgradeTapiServer(IN HINF hinfAnswerFile)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(hinfAnswerFile);

    DefineFunctionName("HrUpgradeTapiServer");
    TraceFunctionEntry(ttidNetSetup);

    HRESULT hr=S_OK;
    BOOL fRunInSeparateInstance=FALSE;

    hr = HrSetupGetFirstStringAsBool(hinfAnswerFile,
                                     c_szAfMiscUpgradeData,
                                     c_szAfTapiSrvRunInSeparateInstance,
                                     &fRunInSeparateInstance);
    if ((S_OK == hr) && fRunInSeparateInstance)
    {
        static const WCHAR c_szTapisrv[] = L"Tapisrv";
        static const CHAR  c_szSvchostChangeSvchostGroup[] =
            "SvchostChangeSvchostGroup";
        static const WCHAR c_szNetcfgxDll[] = L"netcfgx.dll";

        TraceTag(ttidNetSetup, "%s: TapiSrvRunInSeparateInstance is TRUE...",
                 __FUNCNAME__);
        typedef HRESULT (STDAPICALLTYPE *SvchostChangeSvchostGroupFn) (PCWSTR pszService, PCWSTR pszNewGroup);
        SvchostChangeSvchostGroupFn pfnSvchostChangeSvchostGroup;
        HMODULE hNetcfgx;

        hr = HrLoadLibAndGetProc(c_szNetcfgxDll, c_szSvchostChangeSvchostGroup,
                                 &hNetcfgx,
                                 (FARPROC*) &pfnSvchostChangeSvchostGroup);
        if (S_OK == hr)
        {
            hr = pfnSvchostChangeSvchostGroup(c_szTapisrv, c_szTapisrv);
            FreeLibrary(hNetcfgx);
        }
    }

    if ((SPAPI_E_LINE_NOT_FOUND == hr) ||
        (SPAPI_E_SECTION_NOT_FOUND == hr))
    {
        TraceTag(ttidNetSetup, "%s: %S not found in section [%S]",
                 __FUNCNAME__, c_szAfTapiSrvRunInSeparateInstance,
                 c_szAfMiscUpgradeData);
        hr = S_OK;
    }

        TraceError(__FUNCNAME__, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\oemupgrd.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT5.0
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       O E M U P G R D . H
//
//  Contents:   Functions for OEM upgrade
//
//  Notes:
//
//  Author:     kumarp    13-November-97
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <setupapi.h>
#include "nsbase.h"

#include "afileint.h"
#include "afilestr.h"
#include "kkutils.h"
#include "ncatl.h"
#include "nceh.h"
#include "ncsetup.h"
#include "netcfgn.h"
#include "oemupgrd.h"
#include "nslog.h"
#include "resource.h"

static const PCWSTR c_aszComponentSections[] =
{
    c_szAfSectionNetAdapters,
    c_szAfSectionNetProtocols,
    c_szAfSectionNetClients,
    c_szAfSectionNetServices
};

// ----------------------------------------------------------------------
//
// Function:  COemInfo::COemInfo
//
// Purpose:   constructor for class COemInfo
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
COemInfo::COemInfo()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    m_hOemDll = 0;
    m_dwError = ERROR_SUCCESS;
    m_pfnPostUpgradeInitialize = 0;
    m_pfnDoPostUpgradeProcessing = 0;
}

// ----------------------------------------------------------------------
//
// Function:  COemInfo::~COemInfo
//
// Purpose:   destructor for class COemInfo
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 24-December-97
//
// Notes:
//
COemInfo::~COemInfo()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("COemInfo::~COemInfo");

    if (m_hOemDll)
    {
        TraceTag(ttidNetSetup, "%s: unloading OEM DLL: %S\\%S",
                 __FUNCNAME__, m_strOemDir.c_str(), m_strOemDll.c_str());
        ::FreeLibrary(m_hOemDll);
    }
}

// ----------------------------------------------------------------------
//
// Function:  HrLoadAndVerifyOemDll
//
// Purpose:   Load OEM upgrade DLL and verify that it has
//            correct exported functions
//
// Arguments:
//    poi      [in/out]  pointer to COemInfo object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 19-February-98
//
// Notes:
//
HRESULT HrLoadAndVerifyOemDll(IN OUT COemInfo* poi)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    AssertValidWritePtr(poi);

    DefineFunctionName("HrLoadAndVerifyOemDll");

    HRESULT hr=S_OK;

    if (!poi->m_hOemDll)
    {
        tstring strOemDllFullPath;

        strOemDllFullPath = poi->m_strOemDir;
        AppendToPath(&strOemDllFullPath, poi->m_strOemDll.c_str());

        TraceTag(ttidNetSetup, "%s: loading OEM DLL: %S",
                 __FUNCNAME__, strOemDllFullPath.c_str());

        hr = HrLoadLibAndGetProcsV(strOemDllFullPath.c_str(),
                                   &poi->m_hOemDll,
                                   c_szPostUpgradeInitialize,
                                   (FARPROC*) &poi->m_pfnPostUpgradeInitialize,
                                   c_szDoPostUpgradeProcessing,
                                   (FARPROC*) &poi->m_pfnDoPostUpgradeProcessing,
                                   NULL);


        if (S_OK != hr)
        {
            FreeLibrary(poi->m_hOemDll);
            poi->m_hOemDll = NULL;
            poi->m_pfnPostUpgradeInitialize   = NULL;
            poi->m_pfnDoPostUpgradeProcessing = NULL;
            poi->m_dwError = ERROR_DLL_INIT_FAILED;
        }
        NetSetupLogComponentStatus(poi->m_strOemDll.c_str(),
                SzLoadIds (IDS_LOADING), hr);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrLoadAndInitOemDll
//
// Purpose:   Load OEM DLL, verify that it exports correct functions
//            and call DoPostUpgradeInitialize
//
// Arguments:
//    poi             [in]  pointer to COemInfo object
//    pNetUpgradeInfo [in]  pointer to NetUpgradeInfo
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrLoadAndInitOemDll(IN  COemInfo* poi,
                            IN  NetUpgradeInfo* pNetUpgradeInfo)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrLoadAndInitOemDll");

    HRESULT hr=S_OK;
    DWORD dwError=ERROR_SUCCESS;
    hr = HrLoadAndVerifyOemDll(poi);

    VENDORINFO vi;

    if (S_OK == hr)
    {
        if ((ERROR_SUCCESS == poi->m_dwError) &&
            poi->m_pfnPostUpgradeInitialize)
        {
            NC_TRY
            {
                TraceTag(ttidNetSetup, "%s: initializing OEM DLL: %S\\%S",
                         __FUNCNAME__, poi->m_strOemDir.c_str(),
                         poi->m_strOemDll.c_str());

                dwError = poi->m_pfnPostUpgradeInitialize(poi->m_strOemDir.c_str(),
                                                          pNetUpgradeInfo,
                                                          &vi, NULL);
                // ensure that this function gets called only once
                //
                poi->m_pfnPostUpgradeInitialize = NULL;

                if (ERROR_SUCCESS == dwError)
                {
                    hr = S_OK;
                }
            }
            NC_CATCH_ALL
            {
                dwError = ERROR_DLL_INIT_FAILED;
                NetSetupLogHrStatusV(S_FALSE,
                        SzLoadIds (IDS_POSTUPGRADEINIT_EXCEPTION),
                        poi->m_strOemDll.c_str());
            }

            poi->m_dwError = dwError;
            NetSetupLogComponentStatus(poi->m_strOemDll.c_str(),
            SzLoadIds (IDS_POSTUPGRADE_INIT), dwError);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


typedef list<COemInfo*> TOemInfoList;
typedef TOemInfoList::iterator TOemInfoListIter;

static TOemInfoList* g_plOemInfo;

// ----------------------------------------------------------------------
//
// Function:  HrGetOemInfo
//
// Purpose:   Locate (create if not found) and return COemInfo
//            for the given dir & dll
//
// Arguments:
//    pszOemDir [in]  full path to OEM temp dir
//    pszOemDll [in]  full path to OEM DLL
//    ppoi     [out] pointer to pointer to COemInfo object
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrGetOemInfo(IN  PCWSTR    pszOemDir,
                     IN  PCWSTR    pszOemDll,
                     OUT COemInfo** ppoi)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrGetOemInfo");

    HRESULT hr=E_OUTOFMEMORY;

    *ppoi = NULL;

    if (!g_plOemInfo)
    {
        g_plOemInfo = new TOemInfoList;
    }

    if (g_plOemInfo)
    {
        TOemInfoListIter pos;
        COemInfo* poi;

        for (pos=g_plOemInfo->begin(); pos != g_plOemInfo->end(); pos++)
        {
            poi = (COemInfo*) *pos;

            if (!lstrcmpiW(pszOemDir, poi->m_strOemDir.c_str()) &&
                !lstrcmpiW(pszOemDll, poi->m_strOemDll.c_str()))
            {
                *ppoi = poi;
                hr = S_OK;
                break;
            }
        }

        if (!*ppoi)
        {
            hr = E_OUTOFMEMORY;
            *ppoi = new COemInfo;
            if (*ppoi)
            {
                (*ppoi)->m_strOemDir = pszOemDir;
                (*ppoi)->m_strOemDll = pszOemDll;
                g_plOemInfo->push_back(*ppoi);
                hr = S_OK;
            }
        }
    }

    TraceError(__FUNCNAME__, hr);
    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  CleanupOemInfo
//
// Purpose:   Cleanup OEM data
//
// Arguments: None
//
// Returns:   None
//
// Author:    kumarp 04-March-98
//
// Notes:
//
void CleanupOemInfo()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if (g_plOemInfo)
    {
        FreeCollectionAndItem(*g_plOemInfo);
        g_plOemInfo = 0;
    }
}

// ----------------------------------------------------------------------
//
// Function:  HrProcessOemComponent
//
// Purpose:   Process upgrade an OEM component in the following steps
//            - if OEM upgrade DLL is not loaded, load it and
//              verify that it exports the required functions
//            - call DoPostUpgradeInitialize only once
//            - call DoPostUpgradeProcessing
//
// Arguments:
//    hwndParent       [in]  handle of parent window
//    pszOemDir         [in]  OEM working temp dir
//    pszOemDll         [in]  full path to OEM DLL
//    pNetUpgradeInfo  [in]  pointer to NetUpgradeInfo
//    hkeyParams       [in]  handle of Parameters regkey
//    pszPreNT5Instance [in]  pre-NT5 instance e.g. IEEPRO3
//    pszNT5InfId       [in]  NT5 InfID/PnpID
//    hinfAnswerFile   [in]  handle of AnswerFile
//    pszSectionName    [in]  name of OEM Section
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrProcessOemComponent(IN  HWND      hwndParent,
                              IN  PCWSTR   pszOemDir,
                              IN  PCWSTR   pszOemDll,
                              IN  NetUpgradeInfo* pNetUpgradeInfo,
                              IN  HKEY      hkeyParams,
                              IN  PCWSTR   pszPreNT5Instance,
                              IN  PCWSTR   pszNT5InfId,
                              IN  HINF      hinfAnswerFile,
                              IN  PCWSTR   pszSectionName)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrProcessOemComponent");

    VENDORINFO vi;

    TraceTag(ttidNetSetup,
             "%s: Processing OEM component: %S, instance: %S",
             __FUNCNAME__, pszNT5InfId, pszPreNT5Instance);

    HRESULT hr=S_OK;
    COemInfo* poi;

    hr = HrGetOemInfo(pszOemDir, pszOemDll, &poi);

    DWORD dwError;
    DWORD dwErrorMessageId=0;

    if (S_OK == hr)
    {
        hr = HrLoadAndInitOemDll(poi, pNetUpgradeInfo);
    }

    if ((S_OK == hr) && (ERROR_SUCCESS == poi->m_dwError))
    {
        Assert(poi->m_pfnDoPostUpgradeProcessing);

        NC_TRY
        {
            TraceTag(ttidNetSetup,
                     "%s: calling DoPostUpgradeProcessing in %S\\%S for %S",
                     __FUNCNAME__, poi->m_strOemDll.c_str(),
                     poi->m_strOemDir.c_str(), pszNT5InfId);

            dwError =
                poi->m_pfnDoPostUpgradeProcessing(hwndParent, hkeyParams,
                                                  pszPreNT5Instance,
                                                  pszNT5InfId, hinfAnswerFile,
                                                  pszSectionName, &vi, NULL);
            NetSetupLogComponentStatus(pszNT5InfId,
                    SzLoadIds (IDS_POSTUPGRADE_PROCESSING), dwError);
        }
        NC_CATCH_ALL
        {
            dwError = ERROR_OPERATION_ABORTED;
            NetSetupLogHrStatusV(S_FALSE,
                    SzLoadIds (IDS_POSTUPGRADEPROC_EXCEPTION), pszOemDll,
                    pszNT5InfId);
        }

        if (dwError == ERROR_SUCCESS)
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }

        poi->m_dwError = dwError;
        NetSetupLogComponentStatus(pszOemDll,
                                   SzLoadIds (IDS_POSTUPGRADE_PROCESSING),
                                   hr);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(poi->m_dwError);
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  MapProductFlagToProductType
//
// Purpose:   Map Product flag (NSF_*) to PRODUCTTYPE
//
// Arguments:
//    dwUpgradeFromProductFlag [in]  product flag
//
// Returns:   PRODUCTTYPE
//
// Author:    kumarp 04-March-98
//
// Notes:
//
PRODUCTTYPE MapProductFlagToProductType(IN DWORD dwUpgradeFromProductFlag)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    PRODUCTTYPE pt;

    switch (dwUpgradeFromProductFlag)
    {
    case NSF_WINNT_SVR_UPGRADE:
    case NSF_WINNT_SBS_UPGRADE:
        pt = NT_SERVER;
        break;

    case NSF_WINNT_WKS_UPGRADE:
        pt = NT_WORKSTATION;
        break;

    default:
        pt = UNKNOWN;
        break;
    }

    return pt;
}

// ----------------------------------------------------------------------
//
// Function:  GetCurrentProductBuildNumber
//
// Purpose:   Get build number of NT on which we are running
//
// Arguments: None
//
// Returns:   build number
//
// Author:    kumarp 04-March-98
//
// Notes:
//
DWORD GetCurrentProductBuildNumber()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    OSVERSIONINFO osv;

    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osv);
    return osv.dwBuildNumber;
}

// ----------------------------------------------------------------------
//
// Function:  MapProductFlavorToProductType
//
// Purpose:   Map from PRODUCT_FLAVOR to PRODUCTTYPE
//
// Arguments:
//    pf [in]  product flavor
//
// Returns:   product type
//
// Author:    kumarp 04-March-98
//
// Notes:
//
PRODUCTTYPE MapProductFlavorToProductType(IN PRODUCT_FLAVOR pf)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    PRODUCTTYPE pt;

    switch (pf)
    {
    case PF_WORKSTATION:
        pt = NT_WORKSTATION;
        break;

    case PF_SERVER:
        pt = NT_SERVER;
        break;
    }

    return pt;
}

// ----------------------------------------------------------------------
//
// Function:  GetCurrentProductInfo
//
// Purpose:   Get info. on the product on which we are running
//
// Arguments: None
//
// Returns:   pointer to
//
// Author:    kumarp 04-March-98
//
// Notes:
//
ProductInfo GetCurrentProductInfo()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    ProductInfo pi;
    pi.dwBuildNumber = GetCurrentProductBuildNumber();

    PRODUCT_FLAVOR pf;
    GetProductFlavor(NULL, &pf);

    pi.ProductType = MapProductFlavorToProductType(pf);

    return pi;
}

// ----------------------------------------------------------------------
//
// Function:  HrSetupGetFieldCount
//
// Purpose:   Wrapper for SetupGetFieldCount
//
// Arguments:
//    pic         [in]  pointer to INFCONTEXT
//    pcNumFields [out] pointer to number of fields
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrSetupGetFieldCount(IN  INFCONTEXT* pic,
                             OUT UINT* pcNumFields)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr=S_OK;

    if (!(*pcNumFields = SetupGetFieldCount(pic)))
    {
        hr = HrFromLastWin32Error();
    }

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrAfGetInfToRunValue
//
// Purpose:   Helper fn. to parse and locate the INF/section to run
//            Before/After installing an OEM component
//
// Arguments:
//    hinfAnswerFile   [in]  handle of AnswerFile
//    szAnswerFileName [in]  name of AnswerFile
//    szParamsSection  [in]  name of Params section
//    itrType          [in]  type of InfToRun key (Before/After)
//    pstrInfToRun     [out] pointer to the name of INF to run
//    pstrSectionToRun [out] pointer to the name of section to run
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrAfGetInfToRunValue(IN HINF hinfAnswerFile,
                             IN PCWSTR szAnswerFileName,
                             IN PCWSTR szParamsSection,
                             IN EInfToRunValueType itrType,
                             OUT tstring* pstrInfToRun,
                             OUT tstring* pstrSectionToRun,
                             OUT tstring* pstrInfToRunType)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrAfGetInfToRunValue");

    HRESULT hr=S_OK;
    INFCONTEXT ic, ic2;
    PCWSTR szInfToRunKey;

    if (itrType == I2R_BeforeInstall)
    {
        szInfToRunKey = c_szInfToRunBeforeInstall;
    }
    else
    {
        szInfToRunKey = c_szInfToRunAfterInstall;
    }

    *pstrInfToRunType = szInfToRunKey;

    hr = HrSetupFindFirstLine(hinfAnswerFile, szParamsSection,
                              c_szAfOemSection, &ic);
    if (S_OK == hr)
    {
        tstring strOemSection;

        hr = HrSetupGetStringField(ic, 1, &strOemSection);

        if (S_OK == hr)
        {
            hr = HrSetupFindFirstLine(hinfAnswerFile, strOemSection.c_str(),
                                      szInfToRunKey, &ic2);
            if (S_OK == hr)
            {
                UINT cNumFields=0;

                hr = HrSetupGetFieldCount(&ic2, &cNumFields);

                if (S_OK == hr)
                {
                    if (2 == cNumFields)
                    {
                        hr = HrSetupGetStringField(ic2, 1, pstrInfToRun);
                        if (S_OK == hr)
                        {
                            if (pstrInfToRun->empty())
                            {
                                if (itrType == I2R_AfterInstall)
                                {
                                    *pstrInfToRun = szAnswerFileName;
                                }
                                else
                                {
                                    hr = SPAPI_E_LINE_NOT_FOUND;
                                }
                            }

                            if (S_OK == hr)
                            {
                                hr = HrSetupGetStringField(ic2, 2,
                                                           pstrSectionToRun);
                            }
                        }
                    }
                    else
                    {
                        hr = SPAPI_E_LINE_NOT_FOUND;
                    }
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }

    TraceErrorOptional(__FUNCNAME__, hr,
                       ((SPAPI_E_LINE_NOT_FOUND == hr) || (S_FALSE == hr)));

    return hr;
}

// ----------------------------------------------------------------------
//
// Function:  HrProcessInfToRunForComponent
//
// Purpose:   Run INF/section indicated by InfToRunBefore/AfterInstall
//            key of a given OEM component
//
// Arguments:
//    hinfAnswerFile   [in]  handle of AnswerFile
//    szAnswerFileName [in]  name of AnswerFile
//    szParamsSection  [in]  parameters section of a component
//    itrType          [in]  type of InfToRun key (Before/After)
//    hwndParent       [in]  handle of parent window
//    hkeyParams       [in]  handle of Parameters regkey
//    fQuietInstall    [in]  TRUE if we do not want any UI to popup
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrProcessInfToRunForComponent(IN HINF hinfAnswerFile,
                                      IN PCWSTR szAnswerFileName,
                                      IN PCWSTR szParamsSection,
                                      IN EInfToRunValueType itrType,
                                      IN HWND hwndParent,
                                      IN HKEY hkeyParams,
                                      IN BOOL fQuietInstall)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrProcessInfToRunForComponent");

    HRESULT hr=S_OK;

    tstring strInfToRun;
    tstring strSectionToRun;
    tstring strInfToRunType;

    hr = HrAfGetInfToRunValue(hinfAnswerFile, szAnswerFileName,
                              szParamsSection, itrType,
                              &strInfToRun, &strSectionToRun, &strInfToRunType);
    if (S_OK == hr)
    {
        hr = HrInstallFromInfSectionInFile(hwndParent,
                                           strInfToRun.c_str(),
                                           strSectionToRun.c_str(),
                                           hkeyParams,
                                           fQuietInstall);
        NetSetupLogHrStatusV(hr, SzLoadIds (IDS_STATUS_OF_APPLYING),
                             szParamsSection,
                             strInfToRunType.c_str(),
                             strSectionToRun.c_str(),
                             strInfToRun.c_str());
    }
    else if (SPAPI_E_LINE_NOT_FOUND == hr)
    {
        hr = S_FALSE;
    }

    TraceErrorOptional(__FUNCNAME__, hr, (S_FALSE == hr));

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  HrProcessInfToRunBeforeInstall
//
// Purpose:   Process the answerfile and run any INFs/sections
//            indicated by InfToRunBeforeInstall keys
//
// Arguments:
//    hwndParent       [in]  handle of parent window
//    szAnswerFileName [in]  name of AnswerFile
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 04-March-98
//
// Notes:
//
HRESULT HrProcessInfToRunBeforeInstall(IN HWND hwndParent,
                                       IN PCWSTR szAnswerFileName)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    AssertValidReadPtr(szAnswerFileName);

    DefineFunctionName("HrRunInfToRunBeforeInstall");

    HRESULT hr;
    HINF hinf;

    hr = HrSetupOpenInfFile(szAnswerFileName, NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL, &hinf);
    if (S_OK == hr)
    {
        PCWSTR szSection;
        INFCONTEXT ic;
        tstring strParamsSection;

        for (int iSection=0; iSection < celems(c_aszComponentSections); iSection++)
        {
            szSection = c_aszComponentSections[iSection];
            TraceTag(ttidNetSetup, "%s: Processing section [%S]",
                     __FUNCNAME__, szSection);

            hr = HrSetupFindFirstLine(hinf, szSection, NULL, &ic);
            if (S_OK == hr)
            {
                do
                {
                    hr = HrSetupGetStringField(ic, 1, &strParamsSection);

                    if (S_OK == hr)
                    {
                        hr = HrProcessInfToRunForComponent(hinf, szAnswerFileName,
                                                           strParamsSection.c_str(),
                                                           I2R_BeforeInstall,
                                                           hwndParent,
                                                           NULL, // HKR
                                                           TRUE); // fQuietInstall
                        if (SUCCEEDED(hr))
                        {
                            hr = HrSetupFindNextLine(ic, &ic);
                        }
                    }
                } while (S_OK == hr);
            }
            else if ((SPAPI_E_SECTION_NOT_FOUND == hr) ||
                     (SPAPI_E_LINE_NOT_FOUND == hr))
            {
                hr = S_OK;
            }
        }

        SetupCloseInfFile(hinf);
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}


// ----------------------------------------------------------------------
//
// Function:  HrNetSetupCopyOemInfs
//
// Purpose:   Copies all OEM INF files using SetupCopyOemInf
//
// Arguments:
//    szAnswerFileName [in]  name of AnswerFile
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 12-May-98
//
// Notes:
//
HRESULT HrNetSetupCopyOemInfs(IN PCWSTR szAnswerFileName)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DefineFunctionName("HrNetSetupCopyOemInfs");

    TraceTag(ttidNetSetup, "----> entering %s", __FUNCNAME__);

    AssertValidReadPtr(szAnswerFileName);

    HRESULT hr=S_OK;
    HINF hinf=NULL;
    INFCONTEXT ic;
    tstring strParamsSection;
    tstring strOemDir;
    tstring strOemInf;
    WCHAR   szInfNameAfterCopy[MAX_PATH+1];

    hr = HrSetupOpenInfFile(szAnswerFileName, NULL,
                            INF_STYLE_OLDNT | INF_STYLE_WIN4,
                            NULL, &hinf);
    if (S_OK == hr)
    {
        PCWSTR szSection;

        for (int iSection=0; iSection < celems(c_aszComponentSections); iSection++)
        {
            szSection = c_aszComponentSections[iSection];
            TraceTag(ttidNetSetup, "%s: Processing section [%S]",
                     __FUNCNAME__, szSection);

            hr = HrSetupFindFirstLine(hinf, szSection, NULL, &ic);
            if (S_OK == hr)
            {
                do
                {
                    hr = HrSetupGetStringField(ic, 1, &strParamsSection);

                    if (S_OK == hr)
                    {
                        hr = HrSetupGetFirstString(hinf, strParamsSection.c_str(),
                                                   c_szAfOemInf, &strOemInf);
                        if (S_OK == hr)
                        {
                            hr = HrSetupGetFirstString(hinf,
                                                       strParamsSection.c_str(),
                                                       c_szAfOemDir,
                                                       &strOemDir);
                            if (S_OK == hr)
                            {
                                AppendToPath(&strOemDir, strOemInf.c_str());
                                TraceTag(ttidNetSetup,
                                         "%s: calling SetupCopyOemInf for %S",
                                         __FUNCNAME__, strOemDir.c_str());
                                if (SetupCopyOEMInf(strOemDir.c_str(),
                                                    NULL, SPOST_PATH,
                                                    0, szInfNameAfterCopy,
                                                    MAX_PATH, NULL, NULL))
                                {
                                    ShowProgressMessage(
                                            L"...%s was copied as %s",
                                             strOemDir.c_str(),
                                             szInfNameAfterCopy);
                                    NetSetupLogHrStatusV(S_OK,
                                            SzLoadIds (IDS_OEMINF_COPY),
                                            strOemDir.c_str(),
                                            szInfNameAfterCopy);

                                }
                                else
                                {
                                    hr = HrFromLastWin32Error();
                                    ShowProgressMessage(
                                            L"...SetupCopyOemInf failed for %s: error code: 0x%08x",
                                            strOemDir.c_str(), hr);
                                    NetSetupLogComponentStatus(strOemDir.c_str(),
                                            SzLoadIds (IDS_CALLING_COPY_OEM_INF), hr);

                                }
                            }
                            else if (SPAPI_E_LINE_NOT_FOUND == hr)
                            {
                                TraceTag(ttidNetSetup,
                                         "%s: Found %S but not %S!!",
                                         __FUNCNAME__, c_szAfOemInf, c_szAfOemDir);
                                hr = S_OK;
                            }
                        }
                        else
                        {
                            if (SPAPI_E_LINE_NOT_FOUND == hr)
                            {
                                hr = S_OK;
                            }
                        }
                    }

                    // ignore all earlier errors, see if we can do the
                    // next item right
                    //
                    hr = HrSetupFindNextLine(ic, &ic);
                } while (S_OK == hr);
            }
            else if ((SPAPI_E_SECTION_NOT_FOUND == hr) ||
                     (SPAPI_E_LINE_NOT_FOUND == hr))
            {
                hr = S_OK;
            }
        }

        SetupCloseInfFile(hinf);
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceError(__FUNCNAME__, hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\upgrade.h ===
#pragma once

HRESULT
HrRunAnswerFileCleanSection (
    IN PCWSTR pszAnswerFileName);

HRESULT
HrSaveInstanceGuid (
    IN PCWSTR pszComponentName,
    IN const GUID* pguidInstance);

HRESULT
HrLoadInstanceGuid (
    IN  PCWSTR pszComponentName,
    OUT LPGUID pguidInstance);


class CWInfFile;

HRESULT
HrRestoreServiceStartValuesToPreUpgradeSetting (
    IN CWInfFile* pwifAnswerFile);

HRESULT HrRemoveEvilIntelWinsockSPs();

HRESULT HrRestoreWinsockProviderOrder (
    IN CWInfFile* pwifAnswerFile);

inline
BOOL
IsNetworkUpgradeMode (DWORD dwOperationFlags)
{
    return (dwOperationFlags & SETUPOPER_NTUPGRADE) ||
           (dwOperationFlags & SETUPOPER_WIN95UPGRADE) ||
           (dwOperationFlags & SETUPOPER_BATCH);
}

HRESULT
HrUpgradeOemComponent (
    IN PCWSTR pszComponentToUpgrade,
    IN PCWSTR pszDllName, IN PCWSTR pszEntryPoint,
    IN DWORD   dwUpgradeFlag,
    IN DWORD   dwUpgradeFromBuildNumber,
    IN PCWSTR pszAnswerFileName,
    IN PCWSTR pszAnswerFileSectionName);

HRESULT
HrUpgradeRouterIfPresent (
    IN INetCfg* pNetCfg,
    IN CNetInstallInfo* pnii);

extern const WCHAR c_szRouterUpgradeDll[];
extern const CHAR  c_szRouterUpgradeFn[];

HRESULT
HrUpgradeTapiServer (
    IN HINF hinfAnswerFile);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wconnect.cpp ===
// ***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"
#include "ncreg.h"
#include "ncui.h"

extern const WCHAR c_szEmpty[];

// ***************************************************************************
// Function:    SetupFonts
//
// Purpose:     Generate bold or large bold fonts based on the font of the
//              window specified
//
// Parameters:  hwnd       [IN] - Handle of window to base font on
//              pBoldFont [OUT] - The newly generated font, NULL if the
//                                font could not be generated
//              fLargeFont [IN] - If TRUE, generate a 12 point bold font for
//                                use in the wizard "welcome" page.
//
// Returns:     nothing
// ***************************************************************************

VOID SetupConnectFonts(HWND hwnd, HFONT * pBoldFont, BOOL fLargeFont)
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    WCHAR   FontSizeString[MAX_PATH];
    INT     FontSize;

    Assert(pBoldFont);
    *pBoldFont = NULL;

    // Get the font used by the specified window

    hFont = (HFONT)::SendMessage(hwnd, WM_GETFONT, 0, 0L);

    if (NULL == hFont)
    {
        // If not found then the control is using the system font

        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    }

    if (hFont)
    {
        // Get the font info so we can generate the BOLD version

        if (GetObject(hFont, sizeof(BoldLogFont), &BoldLogFont))
        {
            // Create the Bold Font

            BoldLogFont.lfWeight   = FW_BOLD;

            HDC hdc = GetDC(hwnd);

            if (hdc)
            {
                // Large (tall) font is an option

                if (fLargeFont)
                {
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.

                    UINT nLen = lstrlenW(SzLoadIds(IDS_LARGEFONTNAME));

                    if ((0 < nLen) && (nLen < LF_FACESIZE))
                    {
                        lstrcpyW(BoldLogFont.lfFaceName,SzLoadIds(IDS_LARGEFONTNAME));
                    }

                    FontSize = 12;
                    nLen = lstrlen(SzLoadIds(IDS_LARGEFONTSIZE));

                    if ((nLen < celems(FontSizeString)) && (0 < nLen))
                    {
                        lstrcpyW(FontSizeString, SzLoadIds(IDS_LARGEFONTSIZE));
                        FontSize = wcstoul(FontSizeString, NULL, 10);
                    }

                    BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);
                }

                *pBoldFont = CreateFontIndirect(&BoldLogFont);
                ReleaseDC(hwnd, hdc);
            }
        }
    }
}

// ***************************************************************************
// Function:    OnConnectPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg [IN] - Handle to the Connect dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnConnectPageActivate(HWND hwndDlg)
{
    TraceTag(ttidWizard, "Entering Connect Menu page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0L);

    CWizard * pWizard =
          reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    if (pWizard->GetFirstPage() == IDD_Connect)
    {
        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);
    }
    else
    {
        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
    }

    return TRUE;
}

// ***************************************************************************
// Function:    OnConnectWizNext
//
// Purpose:     Handle the PSN_WIZNEXT notification
//
// Parameters:  hwndDlg [IN] - Handle to the Connect dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnConnectWizNext(HWND hwndDlg)
{
    tstring str;

    // Retrieve the CWizard instance from the dialog

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    if ( ! IsPostInstall(pWizard) || (0 == pWizard->UlProviderCount()))
    {
        return TRUE;
    }

    // Find the selected provider and go to it's first page

    for (ULONG ulIdx = 0; ulIdx < pWizard->UlProviderCount(); ulIdx++)
    {
        CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);
        Assert(NULL != pWizProvider);
        Assert(0 != pWizProvider->ULPageCount());

        if (IsDlgButtonChecked(hwndDlg, pWizProvider->GetBtnIdc()))
        {
            pWizard->SetCurrentProvider(ulIdx);
            HPROPSHEETPAGE hPage = (pWizProvider->PHPropPages())[0];
            Assert(NULL != hPage);
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                        (LPARAM)(HPROPSHEETPAGE)hPage);
        }
    }

    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}

// ***************************************************************************

BOOL OnConnectDialogInit(HWND hwndDlg, LPARAM lParam)
{
    INT nIdx;
    INT nrgIdc[] = {CHK_MAIN_DIALUP, TXT_MAIN_DIALUP_1,
                    CHK_MAIN_VPN,       TXT_MAIN_VPN_1};

    // The order here should be the same as the vertical order in the resources

    INT nrgChks[] = {CHK_MAIN_DIALUP, CHK_MAIN_VPN};

    // Initialize our pointers to property sheet info.

    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    if (pWizard->GetFirstPage() == IDD_Connect)
    {
        pWizard->LoadAndInsertDeferredProviderPages(::GetParent(hwndDlg), IDD_Advanced);
    }
    
    // Get the bold font for the radio buttons

    HFONT hBoldFont = NULL;
    SetupConnectFonts(hwndDlg, &hBoldFont, FALSE);

    if (NULL != hBoldFont)
    {
        // Remember the font handle so we can free it on exit

        pWizard->SetPageData(IDD_Connect, (LPARAM)hBoldFont);

        for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
        {
            HWND hwndCtl = GetDlgItem(hwndDlg, nrgChks[nIdx]);
            Assert(NULL != hwndCtl);
            SetWindowFont(hwndCtl, hBoldFont, TRUE);
        }
    }

    // Populate the UI

    for (ULONG ulIdx = 0;
         ulIdx < pWizard->UlProviderCount();
         ulIdx++)
    {
        CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);
        Assert(NULL != pWizProvider);
        Assert(0 != pWizProvider->ULPageCount());

        // Get the radio button associated with this provider

        INT nIdcBtn = pWizProvider->GetBtnIdc();

        // Find the set of controls to enable in the array

        for (nIdx = 0; nIdx < celems(nrgIdc); nIdx += 2)
        {
            if (nrgIdc[nIdx] == nIdcBtn)
            {
                // Enable the controls

                for (INT un = 0; un < 2; un++)
                {
                    HWND hwndBtn = GetDlgItem(hwndDlg, nrgIdc[nIdx + un]);
                    Assert(NULL != hwndBtn);
                    EnableWindow(hwndBtn, TRUE);
                }

                break;
            }
        }
    }

    // Find the top most enabled radio button

    for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
    {
        if (IsWindowEnabled(GetDlgItem(hwndDlg, nrgChks[nIdx])))
        {
            CheckRadioButton(hwndDlg, CHK_MAIN_DIALUP, CHK_MAIN_VPN, nrgChks[nIdx]);
            break;
        }
    }

    return TRUE;
}

// ***************************************************************************
// Function:    dlgprocConnect
//
// Purpose:     Dialog Procedure for the Connect wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
// ***************************************************************************

INT_PTR CALLBACK dlgprocConnect( HWND hwndDlg, UINT uMsg,
                              WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnConnectDialogInit(hwndDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnConnectPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Main);
                return(TRUE);

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnConnectWizNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return(frt);
}

// ***************************************************************************
// Function:    ConnectPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
// ***************************************************************************

VOID ConnectPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    HFONT hBoldFont = (HFONT)pWizard->GetPageData(IDD_Connect);

    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }
}

// ***************************************************************************
// Function:    CreateConnectPage
//
// Purpose:     To determine if the Connect page needs to be shown, and to
//              to create the page if requested.  Note the Main page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
// ***************************************************************************

HRESULT HrCreateConnectPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                          BOOL fCountOnly, UINT *pnPages)
{
    HRESULT hr = S_OK;

    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        // RAS PostInstall only

        (*pnPages)++;

        // If not only counting, create and register the page

        if ( ! fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating Connect Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_Connect );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocConnect;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);
            psp.pszHeaderTitle = SzLoadIds(IDS_T_Connect);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Connect);

            hpsp = CreatePropertySheetPage( &psp );

            if (hpsp)
            {
                pWizard->RegisterPage(IDD_Connect, hpsp,
                                      ConnectPageCleanup, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateConnectPage");
    return hr;
}

// ***************************************************************************
// Function:    AppendConnectPage
//
// Purpose:     Add the Connect page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
// ***************************************************************************

VOID AppendConnectPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Connect);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wadvanced.cpp ===
// ***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"
#include "ncreg.h"
#include "ncui.h"
#include <ncperms.h>

static const CLSID CLSID_InboundConnection =
         {0xBA126AD9,0x2166,0x11D1,{0xB1,0xD0,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
extern const WCHAR c_szEmpty[];

// ***************************************************************************
// Function:    SetupFonts
//
// Purpose:     Generate bold or large bold fonts based on the font of the
//              window specified
//
// Parameters:  hwnd       [IN] - Handle of window to base font on
//              pBoldFont [OUT] - The newly generated font, NULL if the
//                                font could not be generated
//              fLargeFont [IN] - If TRUE, generate a 12 point bold font for
//                                use in the wizard "welcome" page.
//
// Returns:     nothing
// ***************************************************************************

VOID SetupAdvancedFonts(HWND hwnd, HFONT * pBoldFont, BOOL fLargeFont)
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    WCHAR   FontSizeString[MAX_PATH];
    INT     FontSize;

    Assert(pBoldFont);
    *pBoldFont = NULL;

    // Get the font used by the specified window

    hFont = (HFONT)::SendMessage(hwnd, WM_GETFONT, 0, 0L);

    if (NULL == hFont)
    {
        // If not found then the control is using the system font

        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    }

    if (hFont)
    {
        // Get the font info so we can generate the BOLD version

        if (GetObject(hFont, sizeof(BoldLogFont), &BoldLogFont))
        {
            // Create the Bold Font
            //
            BoldLogFont.lfWeight   = FW_BOLD;

            HDC hdc = GetDC(hwnd);

            if (hdc)
            {
                // Large (tall) font is an option

                if (fLargeFont)
                {
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.

                    UINT nLen = lstrlenW(SzLoadIds(IDS_LARGEFONTNAME));

                    if ((0 < nLen) && (nLen < LF_FACESIZE))
                    {
                        lstrcpyW(BoldLogFont.lfFaceName,SzLoadIds(IDS_LARGEFONTNAME));
                    }

                    FontSize = 12;
                    nLen = lstrlen(SzLoadIds(IDS_LARGEFONTSIZE));

                    if ((nLen < celems(FontSizeString)) && (0 < nLen))
                    {
                        lstrcpyW(FontSizeString, SzLoadIds(IDS_LARGEFONTSIZE));
                        FontSize = wcstoul(FontSizeString, NULL, 10);
                    }

                    BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);
                }

                *pBoldFont = CreateFontIndirect(&BoldLogFont);
                ReleaseDC(hwnd, hdc);
            }
        }
    }
}

// ***************************************************************************
// Function:    AlreadyHaveIncomingConnection
//
// Purpose:     Check if there are any inbound connections already
//
// Returns:     TRUE - there is one
//              FALSE - none
// ***************************************************************************

BOOL AlreadyHaveIncomingConnection(CWizard* pWizard)
{
    HRESULT hr;
    BOOL ret = FALSE;
    INetConnectionManager * pConnectionMgr = NULL;
    
    hr = CoCreateInstance(CLSID_ConnectionManager, NULL,
                          CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                          IID_INetConnectionManager,
                          (LPVOID *)&pConnectionMgr);
    if (SUCCEEDED(hr))
    {
        IEnumNetConnection* pEnum;
        hr = pConnectionMgr->EnumConnections(NCME_DEFAULT, &pEnum);

        if (SUCCEEDED(hr))
        {
            INetConnection* aNetCon [512];
            ULONG           cNetCon;
            hr = pEnum->Next (celems(aNetCon), aNetCon, &cNetCon);

            if (SUCCEEDED(hr))
            {
                for (ULONG i = 0; (i < cNetCon) && (ret == FALSE); i++)
                {
                    INetConnection* pNetCon = aNetCon[i];

                    NETCON_PROPERTIES* pProps;
                    hr = pNetCon->GetProperties (&pProps);

                    if (SUCCEEDED(hr))
                    {
                        if (pWizard->CompareCLSID(pProps->clsidThisObject, CLSID_InboundConnection) == TRUE)
                        {
                            ret = TRUE;
                        }

                        CoTaskMemFree(pProps);
                    }

                    ReleaseObj (pNetCon);
                }
            }

            pEnum->Release();
        }

        pConnectionMgr->Release();
    }

    return(ret);
}

// ***************************************************************************
// Function:    OnAdvancedPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg [IN] - Handle to the Main dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnAdvancedPageActivate(HWND hwndDlg)
{
    TraceTag(ttidWizard, "Entering Advanced Menu page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0L);
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}

// ***************************************************************************
// Function:    OnAdvancedWizNext
//
// Purpose:     Handle the PSN_WIZNEXT notification
//
// Parameters:  hwndDlg [IN] - Handle to the Main dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnAdvancedWizNext(HWND hwndDlg)
{
    // Retrieve the CWizard instance from the dialog

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    if ( ! IsPostInstall(pWizard) || (0 == pWizard->UlProviderCount()))
    {
        return TRUE;
    }

    // Find the selected provider and go to it's first page
    for (ULONG ulIdx = 0; ulIdx < pWizard->UlProviderCount(); ulIdx++)
    {
        CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);
        Assert(NULL != pWizProvider);
        Assert(0 != pWizProvider->ULPageCount());

        if (IsDlgButtonChecked(hwndDlg, pWizProvider->GetBtnIdc()))
        {
            pWizard->SetCurrentProvider(ulIdx);
            HPROPSHEETPAGE hPage = (pWizProvider->PHPropPages())[0];
            Assert(NULL != hPage);
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                        (LPARAM)(HPROPSHEETPAGE)hPage);
        }
    }

    return TRUE;
}

// ***************************************************************************

BOOL OnAdvancedDialogInit(HWND hwndDlg, LPARAM lParam)
{
    INT nIdx;
    INT nrgIdc[] = {CHK_MAIN_INBOUND,   TXT_MAIN_INBOUND_1,
                    CHK_MAIN_DIRECT,    TXT_MAIN_DIRECT_1};

    // The order here should be the same as the vertical order in the resources

    INT nrgChks[] = {CHK_MAIN_INBOUND, CHK_MAIN_DIRECT};

    // Initialize our pointers to property sheet info.

    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    // Get the bold font for the radio buttons

    HFONT hBoldFont = NULL;
    SetupAdvancedFonts(hwndDlg, &hBoldFont, FALSE);

    if (NULL != hBoldFont)
    {
        // Remember the font handle so we can free it on exit

        pWizard->SetPageData(IDD_Main, (LPARAM)hBoldFont);

        for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
        {
            HWND hwndCtl = GetDlgItem(hwndDlg, nrgChks[nIdx]);
            Assert(NULL != hwndCtl);
            SetWindowFont(hwndCtl, hBoldFont, TRUE);
        }
    }

    // Populate the UI
    //

    for (ULONG ulIdx = 0;
         ulIdx < pWizard->UlProviderCount();
         ulIdx++)
    {
        CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);
        Assert(NULL != pWizProvider);
        Assert(0 != pWizProvider->ULPageCount());

        // Get the radio button associated with this provider

        INT nIdcBtn = pWizProvider->GetBtnIdc();

        // Find the set of controls to enable in the array

        for (nIdx = 0; nIdx < celems(nrgIdc); nIdx+=2)
        {
            if (nrgIdc[nIdx] == nIdcBtn)
            {
                // Enable the controls

                for (INT un = 0; un < 2; un++)
                {
                    HWND hwndBtn = GetDlgItem(hwndDlg, nrgIdc[nIdx + un]);
                    Assert(NULL != hwndBtn);
                    EnableWindow(hwndBtn, TRUE);
                }

                break;
            }
        }
    }

    if (!FIsUserAdmin())
    {
        EnableWindow(GetDlgItem(hwndDlg, CHK_MAIN_INBOUND), FALSE);
    }
    
    // Find the top most enabled radio button

    for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
    {
        if (IsWindowEnabled(GetDlgItem(hwndDlg, nrgChks[nIdx])))
        {
            CheckRadioButton(hwndDlg, CHK_MAIN_INBOUND, CHK_MAIN_DIRECT, nrgChks[nIdx]);
            break;
        }
    }

    return TRUE;
}

// ***************************************************************************
// Function:    dlgprocAdvanced
//
// Purpose:     Dialog Procedure for the Advanced wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
// ***************************************************************************

INT_PTR CALLBACK dlgprocAdvanced( HWND hwndDlg, UINT uMsg,
                                  WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnAdvancedDialogInit(hwndDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnAdvancedPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Main);
                return(TRUE);

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnAdvancedWizNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

// ***************************************************************************
// Function:    AdvancedPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
// ***************************************************************************

VOID AdvancedPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    HFONT hBoldFont = (HFONT)pWizard->GetPageData(IDD_Advanced);

    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }
}

// ***************************************************************************
// Function:    CreateMainPage
//
// Purpose:     To determine if the Main page needs to be shown, and to
//              to create the page if requested.  Note the Main page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
// ***************************************************************************

HRESULT HrCreateAdvancedPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                             BOOL fCountOnly, UINT *pnPages)
{
    HRESULT hr = S_OK;

    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        // RAS PostInstall only

        (*pnPages)++;

        // If not only counting, create and register the page

        if ( ! fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating Advanced Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_Advanced );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocAdvanced;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);
            psp.pszHeaderTitle = SzLoadIds(IDS_T_Advanced);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Advanced);

            hpsp = CreatePropertySheetPage( &psp );

            if (hpsp)
            {
                pWizard->RegisterPage(IDD_Advanced, hpsp,
                                      AdvancedPageCleanup, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateAdvancedPage");
    return hr;
}

// ***************************************************************************
// Function:    AppendAdvancedPage
//
// Purpose:     Add the Advanced page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
// ***************************************************************************

VOID AppendAdvancedPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Advanced);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wgenericpage.h ===
#pragma once

#define MAKERESOURCEINT(i) (WORD)((DWORD_PTR)((LPSTR)(i)))

class CGenericFinishPage;

class CGenericFinishPage
{
typedef map<DWORD, CGenericFinishPage*> IDDLIST;

private:
    DWORD m_dwMyIDD;
    HFONT m_hBoldFont;

    BOOL OnCGenericFinishPagePageNext(HWND hwndDlg);
    BOOL OnCGenericFinishPagePageBack(HWND hwndDlg);
    BOOL OnCGenericFinishPagePageActivate(HWND hwndDlg);
    BOOL OnCGenericFinishPageInitDialog(HWND hwndDlg, LPARAM lParam);
    BOOL CGenericFinishPagePageOnClick(HWND hwndDlg, UINT idFrom);


static IDDLIST  m_dwIddList;

static HRESULT GetCGenericFinishPageFromHWND(HWND hwndDlg, CGenericFinishPage **pCGenericFinishPage);
static HRESULT GetCGenericFinishPageFromIDD(DWORD idd, CGenericFinishPage **pCGenericFinishPage);

static INT_PTR CALLBACK dlgprocCGenericFinishPage( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
static VOID CALLBACK CGenericFinishPagePageCleanup(CWizard *pWizard, LPARAM lParam);

public:
static HRESULT HrCreateCGenericFinishPagePage(DWORD idd, CWizard *pWizard, PINTERNAL_SETUP_DATA pData, BOOL fCountOnly, UINT *pnPages);
static VOID    AppendCGenericFinishPagePage(DWORD idd, CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\winstall.h ===
#pragma once
#include "wizard.h"

VOID
InstallDefaultComponents (
    IN CWizard* pWizard,
    IN DWORD dwKind, /*EDC_DEFAULT || EDC_MANDATORY */
    IN HWND hwndProgress OPTIONAL);

VOID
InstallDefaultComponentsIfNeeded (
    IN CWizard* pWizard);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wfinish.cpp ===
#include "pch.h"
#pragma hdrstop
#include <shlobj.h>
#include "ncatlui.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "ncui.h"
#include "resource.h"
#include "shortcut.h"
#include "wizard.h"
#include "ncstl.h"
#include "foldinc.h"

static const WCHAR c_szNetConUserPath[] = NETCON_HKEYCURRENTUSERPATH;
static const WCHAR c_szFinishShortCut[] = NETCON_DESKTOPSHORTCUT;
static const WCHAR c_szNewRasConn[]     = L"NewRasCon";
static const WCHAR c_szAdvancedPath[]   = L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced";
static const WCHAR c_szCascadeNetworkConnections[] = L"CascadeNetworkConnections";
static const WCHAR c_szYES[]            = L"YES";
static const WCHAR c_szShellMenu[]      = L"ShellMenu";

struct HFONTS
{
    HFONT hFontBold;
    HFONT hFontBoldLarge;
    HFONT hMarlettFont;
};

//
// Function:    HrFinishPageSaveConnection
//
// Purpose:     Take the name from the dialog and call the provider to
//              create the new connection
//
// Parameters:  hwndDlg [IN] - Handle to the Finish dialog
//              pWizard [IN] - Ptr to a wizard instance
//              ppConn [OUT] - Ptr to the newly created connection
//
// Returns:     HRESULT
//
HRESULT HrFinishPageSaveConnection(HWND hwndDlg, CWizard * pWizard,
                                   INetConnection ** ppConn,
                                   BOOL * pfRetry)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT          hr;
    HWND             hwndEdit = GetDlgItem(hwndDlg, EDT_FINISH_NAME);
    INetConnection * pConn    = NULL;

    Assert(pfRetry);
    *pfRetry = TRUE;

    CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
    Assert(NULL != pWizProvider);
    Assert(NULL != pWizProvider->PWizardUi());

    if (IsPostInstall(pWizard))
    {
        // Set the connections name from the edit control data
        //
        Assert(0 < GetWindowTextLength(hwndEdit));
        Assert(NETCON_MAX_NAME_LEN >= GetWindowTextLength(hwndEdit));
        WCHAR szName[NETCON_MAX_NAME_LEN + 10];

        *ppConn = NULL;

        GetWindowText(hwndEdit, szName, NETCON_MAX_NAME_LEN);
        szName[NETCON_MAX_NAME_LEN] = 0;

        hr = (pWizProvider->PWizardUi())->SetConnectionName(szName);
    }
    else
    {
        hr = S_OK;
    }

    BOOL fFirewallErrorDlg = FALSE;

    if (SUCCEEDED(hr))
    {
        // Create the connection if it's not already set
        //
        hr = (pWizProvider->PWizardUi())->GetNewConnection(&pConn);
        TraceHr(ttidWizard, FAL, hr, FALSE, "FinishPageSaveConnection - Failed to GetNewConnection");
        if (SUCCEEDED(hr))
        {
            // Stash the new connection away
            //
            *ppConn = pConn;
        }
        else
        {
            // Don't let user retry as RAS will AV (#333893)
            *pfRetry = FALSE;
        }

        DWORD dwWizFlags;
        NETCON_MEDIATYPE MediaType;
        hr = (pWizProvider->PWizardUi())->GetNewConnectionInfo(&dwWizFlags, &MediaType);
        if (SUCCEEDED(hr))
        {
            if (dwWizFlags & NCWF_FIREWALLED)
            {
                CComPtr<IHNetCfgMgr> pHNetCfgMgr;
                CComPtr<IHNetConnection> pHNConn;
                CComPtr<IHNetFirewalledConnection> pFWConn;
                hr = CoCreateInstance(
                        CLSID_HNetCfgMgr,
                        NULL,
                        CLSCTX_ALL,
                        IID_IHNetCfgMgr,
                        reinterpret_cast<void**>(&pHNetCfgMgr)
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pHNetCfgMgr->GetIHNetConnectionForINetConnection(pConn, &pHNConn);
                    if (SUCCEEDED(hr))
                    {
                        hr = pHNConn->Firewall(&pFWConn);
                    }
                }

                fFirewallErrorDlg = TRUE;
            }
        }
    }

    if (FAILED(hr) && IsPostInstall(pWizard))
    {
        if (fFirewallErrorDlg)
        {
            LPWSTR szFirewallError;
            LPWSTR pszError;
            if (FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                           NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                           (PWSTR)&pszError, 0, NULL))
            {
                if (DwFormatStringWithLocalAlloc(SzLoadIds(IDS_E_FIREWALL_FAILED), &szFirewallError, pszError))
                {
                    if (MessageBox(GetParent(hwndDlg), szFirewallError, SzLoadIds(IDS_SETUP_CAPTION), MB_OK | MB_ICONEXCLAMATION))
                    {
                        hr = S_OK;
                    }
                    LocalFree(szFirewallError);
                }
                LocalFree(pszError);
            }
        }

        if (FAILED(hr))
        {
            INT idsErr = IDS_E_CREATECONNECTION;

            if (HRESULT_FROM_WIN32(ERROR_DUP_NAME) == hr)
                idsErr = IDS_E_DUP_NAME;
            else
                if (HRESULT_FROM_WIN32(ERROR_INVALID_NAME) == hr)
                    idsErr = IDS_E_INVALID_NAME;

            // Tell the user what went wrong
            //
            NcMsgBox(GetParent(hwndDlg), IDS_SETUP_CAPTION, idsErr, MB_OK);
        }

        return hr;
    }

    return hr;
}

BOOL ConnListDuplicateNameCheck(IN CIntelliName *pIntelliName, IN LPCTSTR szName, NETCON_MEDIATYPE *pncm, NETCON_SUBMEDIATYPE *pncms)
{
    HRESULT hr = S_OK;
    BOOL fDupFound = FALSE;

    Assert(pncm);
    Assert(pncms);

    ConnListEntry cleDup;
    hr = g_ccl.HrFindConnectionByName(szName, cleDup);
    if (S_OK == hr)
    {
        fDupFound = TRUE;
        *pncm = cleDup.ccfe.GetNetConMediaType();

        NETCON_MEDIATYPE ncmPseudo;
        hr = pIntelliName->HrGetPseudoMediaTypes(cleDup.ccfe.GetGuidID(), &ncmPseudo, pncms);
        if (FAILED(hr))
        {
            AssertSz(FALSE, "Could not obtain Pseudo Media type");
            fDupFound = FALSE;

            if (*pncm == NCM_LAN)
            {
                Assert(ncmPseudo == NCM_LAN);
            }
        }
    }
    else
    {
        fDupFound = FALSE;
    }
    return fDupFound;
}

// ISSUE: guidAdapter can be GUID_NULL
VOID GenerateUniqueConnectionName(REFGUID guidAdapter, tstring * pstr, CWizProvider * pWizProvider)
{
    TraceFileFunc(ttidGuiModeSetup);
    HRESULT hr = S_OK;

    Assert(pstr);
    Assert(pWizProvider);

    CIntelliName IntelliName(_Module.GetResourceInstance(), ConnListDuplicateNameCheck);

    NETCON_MEDIATYPE ncm;
    DWORD dwFlags;
    hr = (pWizProvider->PWizardUi())->GetNewConnectionInfo(&dwFlags, &ncm);

    Assert(SUCCEEDED(hr));
    if (FAILED(hr))
    {
        return;
    }

    tstring szConnNameHint;

    PWSTR pszSuggested;
    hr = (pWizProvider->PWizardUi())->GetSuggestedConnectionName(&pszSuggested);
    if (SUCCEEDED(hr))
    {
        szConnNameHint = pszSuggested;
        CoTaskMemFree(pszSuggested);
    }

    DWORD dwNCCF = 0;
    if (dwFlags & NCWF_INCOMINGCONNECTION)
    {
        dwNCCF |= NCCF_INCOMING_ONLY;
    }

    DWORD dwTries = 0;
    do
    {
        LPWSTR szName;
        if (szConnNameHint.empty())
        {
            hr = IntelliName.GenerateName(guidAdapter, ncm, dwNCCF, NULL, &szName);
        }
        else
        {
            hr = IntelliName.GenerateName(guidAdapter, ncm, dwNCCF, szConnNameHint.c_str(), &szName);
        }

        if (SUCCEEDED(hr))
        {
            hr = (pWizProvider->PWizardUi())->SetConnectionName(szName);
            *pstr = szName;
            CoTaskMemFree(szName);
        }

        AssertSz(dwTries < 64, "Something is wrong. GenerateName should have by now generated a unique name!");
        dwTries++;
    }
    while ( (dwTries < 64) && (HRESULT_FROM_WIN32(ERROR_DUP_NAME) == hr) );
    // This can only happens if somebody else created a duplicated name at this EXACT instance. So try again a few times.
   
}

VOID FinishGenerateUniqueNameInUI(HWND hwndDlg, CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    tstring str;
    HWND    hwndEdit     = GetDlgItem(hwndDlg, EDT_FINISH_NAME);
    WCHAR   szName[NETCON_MAX_NAME_LEN + 10] = {0};
    CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
    Assert(NULL != pWizProvider);
    Assert(NULL != pWizProvider->PWizardUi());

    // Populate the Edit control if it's empty
    DWORD Flags = 0;
    NETCON_MEDIATYPE   MediaType;

    HRESULT hr = (pWizProvider->PWizardUi())->GetNewConnectionInfo(&Flags, &MediaType);
    if (SUCCEEDED(hr) & (Flags & NCWF_RENAME_DISABLE))
    {
        LPWSTR szSuggestedName;
        hr = (pWizProvider->PWizardUi())->GetSuggestedConnectionName(&szSuggestedName);
        if (SUCCEEDED(hr))
        {
            str = szSuggestedName;
            CoTaskMemFree(szSuggestedName);
        }
        else
        {
            GenerateUniqueConnectionName(GUID_NULL, &str, pWizProvider);
        }
    }
    else
    {
        GenerateUniqueConnectionName(GUID_NULL, &str, pWizProvider);
    }

    // reset provider changed flag
    pWizard->ClearProviderChanged();

    SetWindowText(hwndEdit, str.c_str());
}

BOOL FCheckAllUsers(NETCON_PROPERTIES* pConnProps)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(NULL != pConnProps);

    if ((NCM_LAN != pConnProps->MediaType) &&
        (NCCF_ALL_USERS & pConnProps->dwCharacter))
    {
        return TRUE;
    }

    return FALSE;
}

//
// Function:    OnFinishPageNext
//
// Purpose:     Handle the pressing of the Next button
//
// Parameters:  hwndDlg [IN] - Handle to the finish dialog
//
// Returns:     BOOL, TRUE
//
BOOL OnFinishPageNext(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HCURSOR          hOldCursor = NULL;
    INetConnection * pConn = NULL;

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);
    HWND        hwndEdit = GetDlgItem(hwndDlg, EDT_FINISH_NAME);
    HRESULT     hr;
    WCHAR       szConnName[NETCON_MAX_NAME_LEN + 1];

    int cchText = GetWindowText(hwndEdit, reinterpret_cast<PWSTR>(&szConnName),
                                NETCON_MAX_NAME_LEN);

    if (IsPostInstall(pWizard))
    {
        if (!FIsValidConnectionName(szConnName))
        {
            SendMessage(hwndEdit, EM_SETSEL, 0, -1);
            SetFocus(hwndEdit);
            MessageBox(GetParent(hwndDlg), SzLoadIds(IDS_E_INVALID_NAME),
                       SzLoadIds(IDS_SETUP_CAPTION), MB_OK | MB_ICONSTOP);
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
            return TRUE;
        }
    }

    hOldCursor = BeginWaitCursor();

    BOOL fRetry;
    hr = HrFinishPageSaveConnection(hwndDlg, pWizard, &pConn, &fRetry);
    if (IsPostInstall(pWizard) && FAILED(hr))
    {
        EndWaitCursor(hOldCursor);

        if (fRetry)
        {
            // Don't leave the page
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
        }
        else
        {
            // Jump to the Exit page
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                        (LPARAM)pWizard->GetPageHandle(IDD_Exit));
    
        }   

        EndWaitCursor(hOldCursor);
        return TRUE;
    }

    // If it's post install cache the connection
    if (IsPostInstall(pWizard))
    {
        DWORD   dwDisposition;
        HKEY    hkey = NULL;

        hr = HrRegCreateKeyEx(HKEY_CURRENT_USER, c_szNetConUserPath,
                              REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                              &hkey, &dwDisposition);
        if (SUCCEEDED(hr))
        {
            DWORD dw;

            // Have we ever created a connection with this wizard before
            //
            hr = HrRegQueryDword (hkey, c_szNewRasConn, &dw);
            if (FAILED(hr))
            {
                HKEY hkeyAdvanced = NULL;

                // First time, retain the fact we created a RAS connection
                //
                (VOID)HrRegSetDword (hkey, c_szNewRasConn, 1);

                // Update the Start Menu to cascade the folder auto-magically
                //
                hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szAdvancedPath,
                                    KEY_WRITE, &hkeyAdvanced);
                if (SUCCEEDED(hr))
                {
                    (VOID)HrRegSetSz(hkeyAdvanced,
                                     c_szCascadeNetworkConnections,
                                     c_szYES);
                    RegCloseKey(hkeyAdvanced);

                    ULONG_PTR lres = 0;
                    LRESULT lr = SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, NULL,
                                reinterpret_cast<LPARAM>(c_szShellMenu), SMTO_ABORTIFHUNG | SMTO_NOTIMEOUTIFNOTHUNG,
                                30 * 1000, &lres);

                    if (lr == 0)
                    {
                        if (GetLastError() == 0)
                        {
                            TraceError("SendMessageTimeout timed out sending WM_SETTINGCHANGE broadcast message", E_FAIL);
                        }
                        else
                        {
                            TraceError("SendMessageTimeout failed", HRESULT_FROM_WIN32(GetLastError()));
                        }
                    }
                }
                hr = S_OK;
            }
        }

        // If the Shortcut check box is visible we might need to create a shortcut
        //
        if (IsWindowVisible(GetDlgItem(hwndDlg, CHK_CREATE_SHORTCUT)))
        {
            // Retain the shortcut "check" state for future invocations
            //
            BOOL fCreateShortcut = (BST_CHECKED ==
                        IsDlgButtonChecked(hwndDlg, CHK_CREATE_SHORTCUT));

            if (hkey)
            {
                (VOID)HrRegSetDword (hkey, c_szFinishShortCut,
                        (fCreateShortcut) ? 1 : 0);
            }

            // If the shortcut box is checked, try to create a shortcut
            //
            if (fCreateShortcut && (NULL != pConn))
            {
                NETCON_PROPERTIES* pConnProps = NULL;

                hr = pConn->GetProperties(&pConnProps);
                if (SUCCEEDED(hr))
                {
                    BOOL fAllUsers = FCheckAllUsers(pConnProps);

                    (VOID)HrCreateStartMenuShortCut(GetParent(hwndDlg),
                                                    fAllUsers,
                                                    pConnProps->pszwName,
                                                    pConn);
                    FreeNetconProperties(pConnProps);
                }
            }
        }

        RegCloseKey(hkey);

        // Save the Connection so we can hand it back to the connections folder
        pWizard->CacheConnection(pConn);
        pConn = NULL;
    }

    // Release the object since we don't need it any more
    ReleaseObj(pConn);

    // Whack the text so we requery it the next time around
    SetWindowText(hwndEdit, c_szEmpty);

    // On PostInstall there is no need to request the "Next" adapter as
    // the wizard is a one time through entity
    if (IsPostInstall(pWizard))
    {
        if (pWizard->FProcessLanPages())
        {
            (VOID)HrCommitINetCfgChanges(GetParent(hwndDlg), pWizard);
        }

        // Jump to the Exit page
        PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                    (LPARAM)pWizard->GetPageHandle(IDD_Exit));

        EndWaitCursor(hOldCursor);
        return TRUE;
    }
    else
    {
        // Do one of the following (as appropriate):
        //      Process the next adapter if it exists
        //      Jump to the join page (!IsPostInstall)
        //      Jump to the exit page
        //
        EndWaitCursor(hOldCursor);
        return OnProcessNextAdapterPageNext(hwndDlg, FALSE);
    }
}

//
// Function:    OnFinishPageBack
//
// Purpose:     Handle the BACK notification on the finish page
//
// Parameters:  hwndDlg [IN] - Handle to the finish dialog
//
// Returns:     BOOL, TRUE
//
BOOL OnFinishPageBack(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    UINT           nCnt = 0;
    HPROPSHEETPAGE hPage = NULL;

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    if (IsWindowVisible(GetDlgItem(hwndDlg, CHK_CREATE_SHORTCUT)))
    {
        // Retain the shortcut "check" state

        DWORD dw;
        HKEY  hKey = NULL;
        BOOL fCreateShortcut = IsDlgButtonChecked(hwndDlg, CHK_CREATE_SHORTCUT);

        if (fCreateShortcut == BST_CHECKED)
        {
            dw = 1;
        }
        else
        {
            dw = 0;
        }

        HRESULT hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szNetConUserPath,
                                    KEY_WRITE, &hKey);

        if (SUCCEEDED(hr))
        {
            HrRegSetValueEx(hKey, c_szFinishShortCut, REG_DWORD, (BYTE *)&dw, sizeof(DWORD));
            RegCloseKey(hKey);
        }
    }

    HWND     hwndEdit        = GetDlgItem(hwndDlg, EDT_FINISH_NAME);
    SetWindowText(hwndEdit, _T(""));
    
    // Goto the guard page of the current provider

    AppendGuardPage(pWizard, pWizard->GetCurrentProvider(),
                    &hPage, &nCnt);
    Assert(nCnt);

    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    // Goto to the guard page of the current provider
    PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                (LPARAM)(HPROPSHEETPAGE)hPage);

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
    return TRUE;
}


VOID FinishUpdateButtons(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    // Only play with the UI when the page is shown postinstall
    if (IsPostInstall(pWizard))
    {
        LPARAM lFlags = PSWIZB_BACK | PSWIZB_FINISH;
        PropSheet_SetWizButtons(GetParent(hwndDlg), lFlags);
    }
}

//
// Function:    OnFinishPageActivate
//
// Purpose:     Handle the page activation
//
// Parameters:  hwndDlg [IN] - Handle to the finish dialog
//
// Returns:     BOOL, TRUE
//
BOOL OnFinishPageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT  hr;
    HWND     hwndEdit        = GetDlgItem(hwndDlg, EDT_FINISH_NAME);
    HWND     hwndChkShortCut = GetDlgItem(hwndDlg, CHK_CREATE_SHORTCUT);

    CWizard* pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    TraceTag(ttidWizard, "Entering finish page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);

    if (IsPostInstall(pWizard))
    {
        FinishGenerateUniqueNameInUI(hwndDlg, pWizard);
        FinishUpdateButtons(hwndDlg);


        const DWORD MAXDLG_FINISH_CONTROLS = 4;
        UINT uiCtls[MAXDLG_FINISH_CONTROLS];
        uiCtls[0] = EDT_FINISH_TYPE1;
        uiCtls[1] = EDT_FINISH_TYPE2;
        uiCtls[2] = EDT_FINISH_TYPE3;
        uiCtls[3] = EDT_FINISH_TYPE4;

        UINT uiLbls[MAXDLG_FINISH_CONTROLS];
        uiLbls[0] = IDC_FINISH_CHK1;
        uiLbls[1] = IDC_FINISH_CHK2;
        uiLbls[2] = IDC_FINISH_CHK3;
        uiLbls[3] = IDC_FINISH_CHK4;

        DWORD dwCurrentControl = 0;

        CWizProvider * pProv = pWizard->GetCurrentProvider();
        if (NULL != pProv)
        {
            DWORD dwWizFlags;
            BOOL  fAllowShortCut = FALSE;
            BOOL  fCheckShortCut = FALSE;
            NETCON_MEDIATYPE MediaType;

            Assert(NULL != pProv->PWizardUi());

            hr = (pProv->PWizardUi())->GetNewConnectionInfo(&dwWizFlags, &MediaType);
            if (SUCCEEDED(hr))
            {
                fAllowShortCut = !!(dwWizFlags & NCWF_SHORTCUT_ENABLE);

                if (dwWizFlags & NCWF_DEFAULT)
                {
                    SetDlgItemText(hwndDlg, uiCtls[dwCurrentControl++], SzLoadIds(IDS_NCWF_DEFAULT));
                }
                if (dwWizFlags & NCWF_FIREWALLED)
                {
                    SetDlgItemText(hwndDlg, uiCtls[dwCurrentControl++], SzLoadIds(IDS_NCWF_FIREWALLED));
                }
                if (dwWizFlags & NCWF_ALLUSER_CONNECTION)
                {
                    SetDlgItemText(hwndDlg, uiCtls[dwCurrentControl++], SzLoadIds(IDS_NCWF_ALLUSER_CONNECTION));
                }
                if (dwWizFlags & NCWF_GLOBAL_CREDENTIALS)
                {
                    SetDlgItemText(hwndDlg, uiCtls[dwCurrentControl++], SzLoadIds(IDS_NCWF_GLOBAL_CREDENTIALS));
                }
    //          if (dwWizFlags & NCWF_SHARED)
    //          {
    //              SetDlgItemText(hwndDlg, uiCtls[dwCurrentControl++], SzLoadIds(IDS_NCWF_SHARED));
    //          }
            }

            Assert(dwCurrentControl <= MAXDLG_FINISH_CONTROLS);

            for (DWORD x = 0; x < MAXDLG_FINISH_CONTROLS; x++)
            {
                HWND hwndCtrl = GetDlgItem(hwndDlg, uiCtls[x]);
                if (hwndCtrl)
                {
                    if (x < dwCurrentControl)
                    {
                        EnableWindow(hwndCtrl, TRUE);
                        ShowWindow(hwndCtrl, SW_SHOW);
                    }
                    else
                    {
                        EnableWindow(hwndCtrl, FALSE);
                        ShowWindow(hwndCtrl, SW_HIDE);
                    }
                }
                else
                {
                    AssertSz(FALSE, "Could not load type edit control");
                }

                hwndCtrl = GetDlgItem(hwndDlg, uiLbls[x]);
                if (hwndCtrl)
                {
                    if (x < dwCurrentControl)
                    {
                        EnableWindow(hwndCtrl, TRUE);
                        ShowWindow(hwndCtrl, SW_SHOW);
                    }
                    else
                    {
                        EnableWindow(hwndCtrl, FALSE);
                        ShowWindow(hwndCtrl, SW_HIDE);
                    }
                }
                else
                {
                    AssertSz(FALSE, "Could not load bullet control");
                }
            }

            // Disable the connection name edit control if the connection type
            // does not support renaming

            ShowWindow(hwndChkShortCut, fAllowShortCut ? SW_SHOW : SW_HIDE);
            EnableWindow(hwndChkShortCut, fAllowShortCut);

            // Check the registry for the last setting of the checkbox state
            // if shortcuts are allowed
            //
            if (fAllowShortCut)
            {
                // Default Shortcut state (if allowed) is on.
                //
                fCheckShortCut = FALSE;

                DWORD dw;
                HKEY  hkey = NULL;

                hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szNetConUserPath,
                                    KEY_READ, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegQueryDword (hkey, c_szFinishShortCut, &dw);
                    if (SUCCEEDED(hr))
                    {
                        fCheckShortCut = (1==dw);
                    }
                    RegCloseKey(hkey);
                }
            }

            CheckDlgButton(hwndDlg, CHK_CREATE_SHORTCUT, fCheckShortCut);
        }
    }
    else
    {
        Assert(pWizard->FProcessLanPages());
        OnFinishPageNext(hwndDlg);

        // Temporarily briefly accept focus
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);
    }

    return TRUE;
}


// ***************************************************************************
//
// Function:    OnFinishInitDialog
//
// Purpose:     Handle WM_INITDIALOG message
//
// Parameters:  hwndDlg [IN] - Handle to the finish dialog
//              lParam  [IN] - LPARAM value from the WM_INITDIALOG message
//
// Returns:     FALSE - Accept default control activation
//
BOOL OnFinishInitDialog(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    // Initialize our pointers to property sheet info.
    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);

    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    HFONTS *phFonts = NULL;
    if (IsPostInstall(pWizard))
    {
        pWizard->SetPageData(IDD_Finish, (LPARAM)NULL);

        // Set up the Welcome font
        HFONT hBoldFontLarge = NULL;
        SetupFonts(hwndDlg, &hBoldFontLarge, TRUE);
        if (NULL != hBoldFontLarge)
        {
            phFonts = new HFONTS;
            ZeroMemory(phFonts, sizeof(HFONTS));
            phFonts->hFontBoldLarge = hBoldFontLarge;

            pWizard->SetPageData(IDD_Finish, (LPARAM)phFonts);
            HWND hwndCtl = GetDlgItem(hwndDlg, IDC_WELCOME_CAPTION);
            if (hwndCtl)
            {
                if (pWizard->FProcessLanPages())
                    SetWindowText(hwndCtl, SzLoadIds(IDS_LAN_FINISH_CAPTION));

                SetWindowFont(hwndCtl, hBoldFontLarge, TRUE);
            }
        }

        // Get the bold font for the radio buttons
        HFONT hBoldFont = NULL;
        SetupFonts(hwndDlg, &hBoldFont, FALSE);

        if (NULL != hBoldFont)
        {
            if (!phFonts)
            {
                phFonts = new HFONTS;
                ZeroMemory(phFonts, sizeof(HFONTS));
                pWizard->SetPageData(IDD_Finish, (LPARAM)hBoldFont);
            }
            
            phFonts->hFontBold = hBoldFont;

            HWND hwndCtl = GetDlgItem(hwndDlg, EDT_FINISH_NAME);
            if (hwndCtl)
            {
                SetWindowFont(hwndCtl, hBoldFont, TRUE);
            }
        }
    
       // Create the Marlett font.  In the Marlett font the "i" is a bullet.
       // Code borrowed from Add Hardware Wizard. 
       HFONT hFontCurrent;
       HFONT hFontCreated;
       LOGFONT LogFont;

       hFontCurrent = (HFONT)SendMessage(GetDlgItem(hwndDlg, IDC_FINISH_CHK1), WM_GETFONT, 0, 0);
       GetObject(hFontCurrent, sizeof(LogFont), &LogFont);
       LogFont.lfCharSet = SYMBOL_CHARSET;
       LogFont.lfPitchAndFamily = FF_DECORATIVE | DEFAULT_PITCH;
       lstrcpy(LogFont.lfFaceName, L"Marlett");
       hFontCreated = CreateFontIndirect(&LogFont);

       if (hFontCreated)
       {
           if (phFonts)
           {
               phFonts->hMarlettFont = hFontCreated;
           }
           //
           // An "i" in the marlett font is a small bullet.
           //
           SetWindowText(GetDlgItem(hwndDlg, IDC_FINISH_CHK1), L"i");
           SetWindowFont(GetDlgItem(hwndDlg, IDC_FINISH_CHK1), hFontCreated, TRUE);
           SetWindowText(GetDlgItem(hwndDlg, IDC_FINISH_CHK2), L"i");
           SetWindowFont(GetDlgItem(hwndDlg, IDC_FINISH_CHK2), hFontCreated, TRUE);
           SetWindowText(GetDlgItem(hwndDlg, IDC_FINISH_CHK3), L"i");
           SetWindowFont(GetDlgItem(hwndDlg, IDC_FINISH_CHK3), hFontCreated, TRUE);
           SetWindowText(GetDlgItem(hwndDlg, IDC_FINISH_CHK4), L"i");
           SetWindowFont(GetDlgItem(hwndDlg, IDC_FINISH_CHK4), hFontCreated, TRUE);
       }

       HKEY hKey;
       HRESULT hrT = HrRegCreateKeyEx(HKEY_CURRENT_USER, c_szNetConUserPath,
                        REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                        &hKey, NULL);

       if (SUCCEEDED(hrT))
       {
            RegCloseKey(hKey);
       }
    }

    // Clear the shortcut flag in the registry
    HKEY hKey;
    DWORD dw = 0;
    HRESULT hr = HrRegOpenKeyEx(HKEY_CURRENT_USER, c_szNetConUserPath,
                                KEY_WRITE, &hKey);

    if (SUCCEEDED(hr))
    {
        HrRegSetValueEx(hKey, c_szFinishShortCut, REG_DWORD, (BYTE *)&dw, sizeof(DWORD));
        RegCloseKey(hKey);
    }

    return FALSE;   // Accept default control focus
}

//
// Function:    dlgprocFinish
//
// Purpose:     Dialog Procedure for the Finish wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocFinish( HWND hwndDlg, UINT uMsg,
                             WPARAM wParam, LPARAM lParam )
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnFinishInitDialog(hwndDlg, lParam);
        break;

    case WM_COMMAND:
        if ((EN_CHANGE == HIWORD(wParam)) &&
            (GetDlgItem(hwndDlg, EDT_FINISH_NAME) == (HWND)lParam))
        {
            FinishUpdateButtons(hwndDlg);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnFinishPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                frt = OnFinishPageBack(hwndDlg);
                break;

            case PSN_WIZFINISH:
                {
                    // This page isn't displayed during setup.
                    // Finish Processing in setup is done in wupgrade.cpp
                    CWizard * pWizard =
                        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg,
                                                                       DWLP_USER));
                    Assert(NULL != pWizard);
                    if (IsPostInstall(pWizard))
                    {
                        frt = OnFinishPageNext(hwndDlg);
                    }
                }
                break;

            case PSN_WIZNEXT:
                frt = OnFinishPageNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}
//
// Function:    FinishPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID FinishPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if (IsPostInstall(pWizard))
    {
        HFONTS *phFonts = (HFONTS *)pWizard->GetPageData(IDD_Finish);
        if (NULL != phFonts)
        {
            if (phFonts->hFontBold)
            {
                DeleteObject(phFonts->hFontBold);
            }
            if (phFonts->hFontBoldLarge)
            {
                DeleteObject(phFonts->hFontBoldLarge);
            }
            if (phFonts->hMarlettFont)
            {
                DeleteObject(phFonts->hMarlettFont);
            }
            delete phFonts;
        }
    }
}

//
// Function:    CreateFinishPage
//
// Purpose:     To determine if the Finish page needs to be shown, and to
//              to create the page if requested.  Note the Finish page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateFinishPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                    BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;
    UINT nId = 0;

    (*pnPages)++;

    // If not only counting, create and register the page
    if (!fCountOnly)
    {
        HPROPSHEETPAGE hpsp;
        PROPSHEETPAGE psp;

        TraceTag(ttidWizard, "Creating Finish Page");
        psp.dwSize = sizeof( PROPSHEETPAGE );
        if (!IsPostInstall(pWizard))
        {
            nId = IDD_FinishSetup;

            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.pszHeaderTitle = SzLoadIds(IDS_T_Finish);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Finish);
        }
        else
        {
            nId = IDD_Finish;

            psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
        }
        Assert (nId);

        psp.pszTemplate = MAKEINTRESOURCE( nId );
        psp.hInstance = _Module.GetResourceInstance();
        psp.hIcon = NULL;
        psp.pfnDlgProc = dlgprocFinish;
        psp.lParam = reinterpret_cast<LPARAM>(pWizard);

        hpsp = CreatePropertySheetPage( &psp );
        if (hpsp)
        {
            pWizard->RegisterPage(nId, hpsp,
                                  FinishPageCleanup, NULL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateFinishPage");
    return hr;
}

//
// Function:    AppendFinishPage
//
// Purpose:     Add the Finish page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendFinishPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);

    UINT idd;

    if (!IsPostInstall(pWizard))
        idd = IDD_FinishSetup;
    else
        idd = IDD_Finish;

    HPROPSHEETPAGE hPage = pWizard->GetPageHandle(idd);
    Assert(hPage);
    pahpsp[*pcPages] = hPage;
    (*pcPages)++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wexit.cpp ===
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"

extern CWizard * g_pSetupWizard;

//
// Function:    OnExitPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification.
//
// Parameters:  hwndDlg [IN] - Handle to the exit child dialog
//
// Returns:     BOOL, TRUE on success
//
BOOL OnExitPageActivate( HWND hwndDlg )
{
    TraceFileFunc(ttidGuiModeSetup);
    
    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));

    TraceTag(ttidWizard, "Entering exit page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);

    // If we've past the point of no return do not allow the user to
    // back up from this page.
    if ((NULL == pWizard) || pWizard->FExitNoReturn())
    {
        // Note that this is failure handling.  Either no networking answerfile
        // section exists or there was an error in networking setup
        // clean up the global object.

        //
        // Note: scottbri 19-Feb-1998
        //
        // The OC networking components need access to INetCfg but we have it locked.
        // On top of this it (INetCfg) has been handed off to the LAN page which has
        // cached it away.  To free up INetCfg we need to delete g_pSetupWizard and
        // never allow the user to backup from this page.  Ideally base setup would
        // call us before the OC stuff is done, but OC is implemented as pages which
        // follow netsetup, even though you can't back up from them.
        //
        if (pWizard && !IsPostInstall(pWizard))
        {
            ::SetWindowLongPtr(hwndDlg, DWLP_USER, 0);
            Assert(pWizard == g_pSetupWizard);
            delete g_pSetupWizard;
            g_pSetupWizard = NULL;
        }

        PostMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, (WPARAM)(PSBTN_NEXT), 0);
        return TRUE;
    }

    Assert(pWizard);
    PAGEDIRECTION PageDir = pWizard->GetPageDirection(IDD_Exit);

    if (NWPD_FORWARD == PageDir)
    {
        pWizard->SetPageDirection(IDD_Exit, NWPD_BACKWARD);
        if (IsPostInstall(pWizard))
        {
            // Exit the wizard
            PropSheet_PressButton(GetParent(hwndDlg), PSBTN_FINISH);
        }
        else
        {
            //
            // Note: scottbri 19-Feb-1998
            //
            // The OC networking components need access to INetCfg but we have it locked.
            // On top of this it (INetCfg) has been handed off to the LAN page which has
            // cached it away.  To free up INetCfg we need to delete g_pSetupWizard and
            // never allow the user to backup from this page.  Ideally base setup would
            // call us before the OC stuff is done, but OC is implemented as pages which
            // follow netsetup, even though you can't back up from them.
            //
            if (!IsPostInstall(pWizard))
            {
                ::SetWindowLongPtr(hwndDlg, DWLP_USER, 0);
                Assert(pWizard == g_pSetupWizard);
                delete g_pSetupWizard;
                g_pSetupWizard = NULL;
            }

            // Goto the page after the exit page
            PostMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, (WPARAM)(PSBTN_NEXT), 0);
        }
    }
    else
    {
        // Goto the page before the exit page
        pWizard->SetPageDirection(IDD_Exit, NWPD_FORWARD);
        if (IsPostInstall(pWizard))
        {
            // Main page
            TraceTag(ttidWizard, "Exit page to Main Page...");
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Main);
        }
        else
        {
            // try to get the join page
            TraceTag(ttidWizard, "Exit page to Join Page...");
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Join);
        }
    }

    return TRUE;
}

//
// Function:    dlgprocExit
//
// Purpose:     Dialog Procedure for the Exit wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocExit( HWND hwndDlg, UINT uMsg,
                           WPARAM wParam, LPARAM lParam )
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // Initialize our pointers to property sheet info.
            PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
            Assert(psp->lParam);
            ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnExitPageActivate( hwndDlg );
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    ExitPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID ExitPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
}

//
// Function:    CreateExitPage
//
// Purpose:     To determine if the Exit page needs to be shown, and to
//              to create the page if requested.  Note the Exit page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateExitPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                    BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;

    (*pnPages)++;

    // If not only counting, create and register the page
    if (!fCountOnly)
    {
        HPROPSHEETPAGE hpsp;
        PROPSHEETPAGE psp;

        TraceTag(ttidWizard, "Creating Exit Page");
        psp.dwSize = sizeof( PROPSHEETPAGE );
        psp.dwFlags = 0;
        psp.hInstance = _Module.GetResourceInstance();
        psp.pszTemplate = MAKEINTRESOURCE( IDD_Exit );
        psp.hIcon = NULL;
        psp.pfnDlgProc = dlgprocExit;
        psp.lParam = reinterpret_cast<LPARAM>(pWizard);

        hpsp = CreatePropertySheetPage( &psp );
        if (hpsp)
        {
            pWizard->RegisterPage(IDD_Exit, hpsp,
                                  ExitPageCleanup, NULL);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateExitPage");
    return hr;
}

//
// Function:    AppendExitPage
//
// Purpose:     Add the Exit page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendExitPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Exit);
    Assert(hPage);
    pahpsp[*pcPages] = hPage;
    (*pcPages)++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wguard.cpp ===
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"



typedef struct tagGuardData
{
    CWizard *       pWizard;
    CWizProvider *  pWizProvider;
} GuardData;

BOOL OnGuardPageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HPROPSHEETPAGE hPage;
    GuardData *    pData = reinterpret_cast<GuardData *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));

    TraceTag(ttidWizard, "Entering guard page...");
    Assert(NULL != pData);

    CWizard *      pWizard      = pData->pWizard;
    CWizProvider * pWizProvider = pData->pWizProvider;
    LPARAM         ulId         = reinterpret_cast<LPARAM>(pWizProvider);
    PAGEDIRECTION  PageDir      = pWizard->GetPageDirection(ulId);

    // If the current provider is not the provider whose pages this
    // page is guarding, return to the main or install mode page
    // as appropriate
    Assert(pWizard->GetCurrentProvider());
    if (pWizProvider != pWizard->GetCurrentProvider())
    {
        // Doesn't hurt to set this providers guard page to face forward
        pWizard->SetPageDirection(ulId, NWPD_FORWARD);

        // Since guard pages always follow a provider's pages, and in the
        // LAN case there is only one provider.  We can assert that this is
        // the post install case, and that we're not processing the LAN, and
        // that the Main page exists
        Assert(IsPostInstall(pWizard));
        Assert(!pWizard->FProcessLanPages());

        CWizProvider* pWizProvider = pWizard->GetCurrentProvider();

        switch (pWizProvider->GetBtnIdc())
        {
            case CHK_MAIN_PPPOE:
            case CHK_MAIN_INTERNET:
                Assert(NULL != pWizard->GetPageHandle(IDD_Internet_Connection));
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Internet_Connection);
                TraceTag(ttidWizard, "Guard page to Internet page...");
                break;

            // return to the Connect menu dialog
            case CHK_MAIN_DIALUP:
            case CHK_MAIN_VPN:
                Assert(NULL != pWizard->GetPageHandle(IDD_Connect));
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Connect);
                TraceTag(ttidWizard, "Guard page to Connect page...");
                break;

            // return to the Advanced menu dialog
            case CHK_MAIN_INBOUND:
            case CHK_MAIN_DIRECT:
                Assert(NULL != pWizard->GetPageHandle(IDD_Advanced));
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Advanced);
                TraceTag(ttidWizard, "Guard page to Advanced page...");
                break;

            // all others return to the Main dialog
            default:
                Assert(NULL != pWizard->GetPageHandle(IDD_Main));
                ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Main);
                TraceTag(ttidWizard, "Guard page to Main page...");
        }
    }
    else
    {
        // This is the current providers guard page, which way do we go?
        if (NWPD_FORWARD == PageDir)
        {
            UINT idd;
            if (!IsPostInstall(pWizard))
                idd = IDD_FinishSetup;
            else
                idd = IDD_Finish;

            // Going forward means go to the finish page
            pWizard->SetPageDirection(ulId, NWPD_BACKWARD);
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, idd);
            TraceTag(ttidWizard, "Guard page to Finish page...");
        }
        else
        {
            // Temporarily accept focus
            //
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);
            pWizard->SetPageDirection(ulId, NWPD_FORWARD);
            TraceTag(ttidWizard, "Guard page to last of the provider's pages...");

            // Going backward means go to the last of the provider's pages
            //
            Assert(0 < pWizProvider->ULPageCount());
            if (pWizard->FProcessLanPages())
            {
                // For the LAN case, jump directly to the last page
                //
                HPROPSHEETPAGE * rghPage = pWizProvider->PHPropPages();
                hPage = rghPage[pWizProvider->ULPageCount() - 1];

                PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                            (LPARAM)(HPROPSHEETPAGE)hPage);
            }
            else
            {
                // The RAS pages don't want to work very hard at tracking
                // direction and supporting jumping to their last page so
                // we'll help them a bit by accepting focus here and then
                // backing up
                //
                PropSheet_PressButton(GetParent(hwndDlg), PSBTN_BACK);
            }
        }
    }

    return TRUE;
}

//
// Function:    dlgprocGuard
//
// Purpose:     Dialog Procedure for the Guard wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocGuard( HWND hwndDlg, UINT uMsg,
                               WPARAM wParam, LPARAM lParam )
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // Initialize our pointers to property sheet info.
            PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
            Assert(psp->lParam);
            ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnGuardPageActivate( hwndDlg );
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    GuardPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID GuardPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
#if DBG
    CWizProvider *p = reinterpret_cast<CWizProvider *>(lParam);
#endif
    MemFree(reinterpret_cast<void*>(lParam));
}

//
// Function:    HrCreateGuardPage
//
// Purpose:     To determine if the Guard page needs to be shown, and to
//              to create the page if requested.  Note the Guard page is
//              responsible for initial installs also.
//
// Parameters:  pWizard      [IN] - Ptr to a Wizard instance
//              pWizProvider [IN] - Ptr to the wizard provider this guard
//                                  page will be associated with.
//
// Returns:     HRESULT, S_OK on success
//
NOTHROW
HRESULT HrCreateGuardPage(CWizard *pWizard, CWizProvider *pWizProvider)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT        hr = E_OUTOFMEMORY;
    HPROPSHEETPAGE hpsp;
    PROPSHEETPAGE  psp;

    GuardData * pData = reinterpret_cast<GuardData*>(MemAlloc(sizeof(GuardData)));
    if (pData)
    {
        TraceTag(ttidWizard, "Creating Guard Page");
        psp.dwSize = sizeof( PROPSHEETPAGE );
        psp.dwFlags = 0;
        psp.hInstance = _Module.GetResourceInstance();
        psp.pszTemplate = MAKEINTRESOURCE(IDD_Guard);
        psp.hIcon = NULL;
        psp.pfnDlgProc = dlgprocGuard;
        psp.lParam = reinterpret_cast<LPARAM>(pData);

        hpsp = CreatePropertySheetPage(&psp);
        if (hpsp)
        {
            pData->pWizard      = pWizard;
            pData->pWizProvider = pWizProvider;

            pWizard->RegisterPage(reinterpret_cast<LPARAM>(pWizProvider),
                                  hpsp, GuardPageCleanup,
                                  reinterpret_cast<LPARAM>(pData));

            hr = S_OK;
        }
        else
        {
            MemFree(pData);
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrGetGuardPage");
    return hr;
}

//
// Function:    AppendGuardPage
//
// Purpose:     Add the Guard page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard      [IN] - Ptr to a Wizard instance
//              pWizProvider [IN] - Ptr to a WizProvider instance
//              pahpsp   [IN,OUT] - Array of pages to add our page to
//              pcPages  [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendGuardPage(CWizard *pWizard, CWizProvider *pWizProvider,
                     HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(NULL != pWizard);
    Assert(NULL != pWizProvider);

    HPROPSHEETPAGE hPage = pWizard->GetPageHandle(reinterpret_cast<LPARAM>(pWizProvider));
    if (hPage)
    {
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
    else
    {
        // page should be there
        Assert(0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\winstall.cpp ===
#include "pch.h"
#pragma hdrstop
#include "edc.h"
#include "ncnetcfg.h"
#include "netcfgn.h"
#include "winstall.h"

struct INSTALL_PROGRESS_DATA
{
    CWizard*                pWizard;
    HWND                    hwndProgress;   // NULL if no progress window
    UINT                    nProgressDelta;
};

// type of PFN_EDC_CALLBACK
VOID
CALLBACK
InstallCallback (
    IN EDC_CALLBACK_MESSAGE Message,
    IN ULONG_PTR MessageData,
    IN PVOID pvCallerData OPTIONAL)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    INSTALL_PROGRESS_DATA* pCallbackData;
    UpgradeData* pUpgradeData;

    pCallbackData = (INSTALL_PROGRESS_DATA*)pvCallerData;

    Assert (pCallbackData);

    if ( !pCallbackData ) {
        return;
    }

    Assert (pCallbackData->pWizard);

    if ( !pCallbackData->pWizard ) {
        return;
    }

    pUpgradeData = (UpgradeData*)pCallbackData->pWizard->GetPageData(IDD_Upgrade);
    Assert(pUpgradeData);

    if ( !pUpgradeData ) {
        return;
    }

    if (EDC_INDICATE_COUNT == Message)
    {
        // 0-nCurrentCap and (c_nMaxProgressRange - 10) through
        // c_nMaxProgressRange are spoken for.  So the the delta is the
        // number of items to install divided into the range remaining.
        //
        UINT Count = (UINT)MessageData;

        pCallbackData->nProgressDelta =
            ((c_nMaxProgressRange - 10) - pUpgradeData->nCurrentCap) / Count;
    }
    else if (EDC_INDICATE_ENTRY == Message)
    {
        const EDC_ENTRY* pEntry = (const EDC_ENTRY*)MessageData;

        NETWORK_INSTALL_PARAMS nip = {0};
        nip.dwSetupFlags = NSF_PRIMARYINSTALL;

        if (pCallbackData->hwndProgress)
        {
            OnUpgradeUpdateProgressCap (
                pCallbackData->hwndProgress,
                pCallbackData->pWizard,
                pUpgradeData->nCurrentCap + pCallbackData->nProgressDelta);
        }

        (VOID) HrInstallComponentOboUser(
                pCallbackData->pWizard->PNetCfg(),
                &nip,
                *pEntry->pguidDevClass,
                pEntry->pszInfId,
                NULL);
    }
}

VOID
InstallDefaultComponents (
    IN CWizard* pWizard,
    IN DWORD dwSetupFlags,
    IN HWND hwndProgress OPTIONAL)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    INSTALL_PROGRESS_DATA CallbackData = {0};

    CallbackData.pWizard = pWizard;
    CallbackData.hwndProgress = hwndProgress;

    EnumDefaultComponents (
        dwSetupFlags,
        InstallCallback,
        &CallbackData);
}

VOID
InstallDefaultComponentsIfNeeded (
    IN CWizard* pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;
    BOOL    fNetworkingPresent = FALSE;

    // If at least one LAN capable protocol is installed then networking is installed
    //
    Assert(NULL != pWizard->PNetCfg());
    CIterNetCfgComponent nccIter(pWizard->PNetCfg(), &GUID_DEVCLASS_NETTRANS);
    INetCfgComponent* pncc;
    while (!fNetworkingPresent && SUCCEEDED(hr) &&
           (S_OK == (hr = nccIter.HrNext (&pncc))))
    {
        // Hack (Sort of) - Basically we want to install default networking if networking is
        // not already installed.  Unfortunately Ndiswan can bind to ndisatm, so using the
        // "Can the protocol bind to an adapter?" is not sufficent.  given that the users
        // impression of is networking installed, is really based on what they can visually
        // see in the UI.  We'll (and this is the hack part), ignore hidden protocols when
        // considering if a protocol can bind to and adapter.
        DWORD dwCharacteristics;

        hr = pncc->GetCharacteristics(&dwCharacteristics);
        if (SUCCEEDED(hr) && !(dwCharacteristics & NCF_HIDDEN))
        {
            // Check if the protocol binds to "Lan" type adapter interfaces
            //
            hr = HrIsLanCapableProtocol(pncc);
            if (S_OK == hr)
            {
                fNetworkingPresent = TRUE;
            }
        }

        ReleaseObj(pncc);
    }

    if (!fNetworkingPresent)
    {
        InstallDefaultComponents(pWizard, EDC_DEFAULT, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wgenericpage.cpp ===
#include "pch.h"
#pragma hdrstop
#include <shlobj.h>
#include <shlobjp.h>
#include "ncatlui.h"
#include "ncnetcon.h"
#include "ncreg.h"
#include "ncui.h"
#include "resource.h"
#include "shortcut.h"
#include "wizard.h"
#include "htmlhelp.h"
#include "wgenericpage.h"

static const WCHAR c_szHomenetWizDLL[]         = L"hnetwiz.dll";
static const CHAR  c_szfnHomeNetWizardRunDll[] = "HomeNetWizardRunDll";
static const WCHAR c_szMSNPath[]               = L"\\MSN\\MSNCoreFiles\\msn6.exe";
static const WCHAR c_szMigrationWiz[]          = L"\\usmt\\migwiz.exe";
static const DWORD c_dwStartupmsForExternalApps = 500;
static const WCHAR c_szOnlineServiceEnglish[]  = L"Online Services";

CGenericFinishPage::IDDLIST CGenericFinishPage::m_dwIddList;

typedef void APIENTRY FNHomeNetWizardRunDll(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);

//
// Function:    RunHomeNetWizard
//
// Purpose:     Thread to execute the Network Setup Wizard
//
// Parameters:  
//              lpParameter [in] - Reserved - must be NULL
//
// Returns:     HRESULT converted to DWORD
//
// Author:      deon   12 April 2001
//
DWORD CALLBACK RunHomeNetWizard(PVOID lpParameter)
{
    HRESULT hrExitCode = S_OK;
    __try
    {
        HMODULE hModHomeNet = LoadLibrary(c_szHomenetWizDLL);
        if (hModHomeNet)
        {
            FNHomeNetWizardRunDll *pfnHomeNewWizardRunDll = reinterpret_cast<FNHomeNetWizardRunDll *>(GetProcAddress(hModHomeNet, c_szfnHomeNetWizardRunDll));
            if (pfnHomeNewWizardRunDll)
            {
                pfnHomeNewWizardRunDll(NULL, _Module.GetModuleInstance(), NULL, 0);
            }
            else
            {
                hrExitCode = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            }
            FreeLibrary(hModHomeNet);
        }
        else
        {
            hrExitCode = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        hrExitCode = HRESULT_FROM_WIN32(GetLastError());
        if (SUCCEEDED(hrExitCode))
        {
            hrExitCode = E_FAIL;
        }
    }
    return static_cast<DWORD>(hrExitCode);
}

BOOL fIsMSNPresent()
{
    BOOL bRet = TRUE;

    WCHAR szExecutePath[MAX_PATH+1];
    HRESULT hr = SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, szExecutePath);
    if (SUCCEEDED(hr))
    {
        WCHAR szPath[MAX_PATH+1];
        DwFormatString(L"%1!s!%2!s!", szPath, celems(szPath), szExecutePath, c_szMSNPath);

        DWORD dwRet = GetFileAttributes(szPath);
        if (0xFFFFFFFF != dwRet)
        {
            hr = S_OK;
        }
        else
        {
            bRet = FALSE;
        }
    }
    return bRet;
}
//
// Function:    ShellExecuteFromCSIDL
//
// Purpose:     Execute a command on this computer based on a CSIDL
//
// Parameters:  
//              hwndParent  [in] - Handle of parent, or NULL for Desktop
//              nFolder     [in] - CSIDL of base path
//              szCommand   [in] - Command to be appended to CSIDL
//              fIsFolder   [in] - Open a folder?
//              dwSleepTime [in] - Time to sleep after execute or 0 for none
//
// Returns:     HRESULT
//
// Author:      deon   12 April 2001
//
HRESULT ShellExecuteFromCSIDL(HWND hWndParent, int nFolder, LPCWSTR szCommand, BOOL fIsFolder, DWORD dwSleepTime)
{
    HRESULT hr = S_OK;

    WCHAR szExecutePath[MAX_PATH+1];
    hr = SHGetFolderPath(NULL, nFolder, NULL, SHGFP_TYPE_CURRENT, szExecutePath);
    if (SUCCEEDED(hr))
    {
        if (NULL == hWndParent)
        {
            hWndParent = GetDesktopWindow();
        }

        wcsncat(szExecutePath, szCommand, MAX_PATH);

        if (fIsFolder)
        {
            // Make sure path points to a folder and not some or other virus
            DWORD dwRet = GetFileAttributes(szExecutePath);
            if ( (0xFFFFFFFF != dwRet) &&
                 (FILE_ATTRIBUTE_DIRECTORY & dwRet) )
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Execute the file / folder
            if (::ShellExecute(hWndParent, NULL, szExecutePath, NULL, NULL, SW_SHOWNORMAL) <= reinterpret_cast<HINSTANCE>(32)) 
            {
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;
                if (dwSleepTime)
                {
                    Sleep(dwSleepTime); // Give time to startup
                }
            }
        }
        
        if (FAILED(hr))
        {
            NcMsgBox(_Module.GetResourceInstance(),
                        NULL,
                        IDS_WIZARD_CAPTION,
                        IDS_ERR_COULD_NOT_OPEN_DIR,
                        MB_OK | MB_ICONERROR,
                        szExecutePath);
        }
    }
    else
    {
        NcMsgBox(_Module.GetResourceInstance(),
                    NULL,
                    IDS_WIZARD_CAPTION,
                    IDS_ERR_COULD_NOT_OPEN_DIR,
                    MB_OK | MB_ICONERROR,
                    szCommand);
    }

    return hr;
}

//
// Function:    CGenericFinishPage::OnCGenericFinishPagePageNext
//
// Purpose:     Handle the pressing of the Next button
//
// Parameters:  hwndDlg [IN] - Handle to the CGenericFinishPage dialog
//
// Returns:     BOOL, TRUE
//
BOOL CGenericFinishPage::OnCGenericFinishPagePageNext(HWND hwndDlg)
{
    TraceFileFunc(ttidWizard);

    HCURSOR          hOldCursor = NULL;
    INetConnection * pConn = NULL;

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    HRESULT hr = S_OK;
    switch (m_dwMyIDD)
    {
        case IDD_FinishOtherWays:
        {
            if (IsDlgButtonChecked(hwndDlg, CHK_SETUP_MSN) && 
                (fIsMSNPresent()) )
            {
                hr = ShellExecuteFromCSIDL(NULL, CSIDL_PROGRAM_FILES, c_szMSNPath, FALSE, c_dwStartupmsForExternalApps);
            }
            else if (fIsMSNPresent() || IsDlgButtonChecked(hwndDlg, CHK_SELECTOTHER))
            {
                WCHAR szPath[MAX_PATH+1];

                // As per RAID: 450478.
                // If we are running on a MUI platform and the user is logged in a non-primary
                // language (IOW: not English), the UserDefaultUILanguage will be different from the 
                // SystemDefaultUILanguage
                if (GetUserDefaultUILanguage() != GetSystemDefaultUILanguage())
                {
                    // Use the English name instead, since on the MUI platform
                    // the folder name wil be in English.
                    //
                    // ISSUE: This will cause the caption of the folder to appear in English
                    //        for a non-Enlish user.
                    DwFormatString(L"\\%1!s!", szPath, celems(szPath), c_szOnlineServiceEnglish);
                }
                else
                {
                    DwFormatString(L"\\%1!s!", szPath, celems(szPath), SzLoadIds(IDS_OnlineServices));
                }

                hr = ShellExecuteFromCSIDL(NULL, CSIDL_PROGRAM_FILES, szPath, TRUE, c_dwStartupmsForExternalApps);
            }
        }
        break;

        case IDD_FinishNetworkSetupWizard:
        {
            Assert(S_OK == HrShouldHaveHomeNetWizard());

            DWORD dwThreadId;
            HANDLE hHomeNetThread = CreateThread(NULL, STACK_SIZE_COMPACT, RunHomeNetWizard, NULL, 0, &dwThreadId);
            if (NULL != hHomeNetThread)
            {
                HRESULT hrExitCode = S_OK;
                ShowWindow(GetParent(hwndDlg), SW_HIDE);
                WaitForSingleObject(hHomeNetThread, INFINITE);
                GetExitCodeThread(hHomeNetThread, reinterpret_cast<LPDWORD>(&hrExitCode));
                if (S_OK == hrExitCode) // user finished the wizard
                {
        #ifdef DBG
                    // Make sure we don't leave the window open & hidden
                    ShowWindow(GetParent(hwndDlg), SW_SHOW);
        #endif
                    // Go to close page
                    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                    PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0, (LPARAM)pWizard->GetPageHandle(IDD_Exit));
                }
                else if (S_FALSE == hrExitCode) // user pressed back button
                {
                    ShowWindow(GetParent(hwndDlg), SW_SHOW);
                }
                else
                {
                    ShowWindow(GetParent(hwndDlg), SW_SHOW);
                }
                CloseHandle(hHomeNetThread);
            }
         }   

        default:
        break;
    }
    
    if (SUCCEEDED(hr))
    {
        PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0, (LPARAM)pWizard->GetPageHandle(IDD_Exit));
    }
    else
    {
        PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0, (LPARAM)pWizard->GetPageHandle(m_dwMyIDD));
    }

    return TRUE;
}

//
// Function:    CGenericFinishPage::OnCGenericFinishPagePageBack
//
// Purpose:     Handle the BACK notification on the CGenericFinishPage page
//
// Parameters:  hwndDlg [IN] - Handle to the CGenericFinishPage dialog
//
// Returns:     BOOL, TRUE
//
BOOL CGenericFinishPage::OnCGenericFinishPagePageBack(HWND hwndDlg)
{
    TraceFileFunc(ttidWizard);
    
    UINT           nCnt = 0;
    HPROPSHEETPAGE hPage = NULL;

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    DWORD iddOrigin = pWizard->GetPageOrigin(m_dwMyIDD, NULL);
    if (iddOrigin)
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, iddOrigin);
    }

    return TRUE;
}

//
// Function:    OnCGenericFinishPagePageActivate
//
// Purpose:     Handle the page activation
//
// Parameters:  hwndDlg [IN] - Handle to the CGenericFinishPage dialog
//
// Returns:     BOOL, TRUE
//
BOOL CGenericFinishPage::OnCGenericFinishPagePageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidWizard);
    
    HRESULT  hr;

    CWizard* pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    TraceTag(ttidWizard, "Entering generic page...");

    if (IsPostInstall(pWizard))
    {
        LPARAM lFlags = PSWIZB_BACK | PSWIZB_FINISH;
        PropSheet_SetWizButtons(GetParent(hwndDlg), lFlags);
    }
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);

    if (fIsMSNPresent())
    {
        ShowWindow(GetDlgItem(hwndDlg, IDC_SELECT_ISP_FINISH)  , SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, CHK_SETUP_MSN)  , SW_SHOW);
        ShowWindow(GetDlgItem(hwndDlg, IDC_SELECT_MSN_ISP)    , SW_SHOW);
        ShowWindow(GetDlgItem(hwndDlg, IDC_CLOSE_CHOICE_FINISH)    , SW_SHOW);
        ShowWindow(GetDlgItem(hwndDlg, CHK_SELECTOTHER), SW_SHOW);
    }
    else
    {
        ShowWindow(GetDlgItem(hwndDlg, IDC_SELECT_ISP_FINISH)  , SW_SHOW);
        ShowWindow(GetDlgItem(hwndDlg, CHK_SETUP_MSN)  , SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_SELECT_MSN_ISP)    , SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, IDC_CLOSE_CHOICE_FINISH)    , SW_HIDE);
        ShowWindow(GetDlgItem(hwndDlg, CHK_SELECTOTHER), SW_HIDE);
        CheckDlgButton(hwndDlg, CHK_SELECTOTHER, BST_CHECKED);
    }

    return TRUE;
}

// ***************************************************************************
//
// Function:    OnCGenericFinishPageInitDialog
//
// Purpose:     Handle WM_INITDIALOG message
//
// Parameters:  hwndDlg [IN] - Handle to the CGenericFinishPage dialog
//              lParam  [IN] - LPARAM value from the WM_INITDIALOG message
//
// Returns:     FALSE - Accept default control activation
//
BOOL CGenericFinishPage::OnCGenericFinishPageInitDialog(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidWizard);
    
    // Initialize our pointers to property sheet info.
    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);

    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    SetupFonts(hwndDlg, &m_hBoldFont, TRUE);
    if (NULL != m_hBoldFont)
    {
        HWND hwndCtl = GetDlgItem(hwndDlg, IDC_WELCOME_CAPTION);
        if (hwndCtl)
        {
            SetWindowFont(hwndCtl, m_hBoldFont, TRUE);
        }
    }

    switch (m_dwMyIDD)
    {
        case IDD_FinishOtherWays:
        {
            INT nrgChks[] = {CHK_SETUP_MSN, CHK_SELECTOTHER};
            // Find the top most enabled radio button

            for (int nIdx = 0; nIdx < celems(nrgChks); nIdx++)
            {
                if (IsWindowEnabled(GetDlgItem(hwndDlg, nrgChks[nIdx])))
                {
                    CheckRadioButton(hwndDlg, CHK_SETUP_MSN, CHK_SELECTOTHER, nrgChks[nIdx]);
                    break;
                }
            }
        }
        break;
        default:
        break;
    }

    return FALSE;   // Accept default control focus
}

BOOL CGenericFinishPage::CGenericFinishPagePageOnClick(HWND hwndDlg, UINT idFrom)
{
    BOOL fRet = TRUE;
    switch (idFrom)
    {
        case IDC_ST_AUTOCONFIGLINK:
            {
                HRESULT hr = ShellExecuteFromCSIDL(hwndDlg, CSIDL_SYSTEM, c_szMigrationWiz, FALSE, 0);
                if (FAILED(hr))
                {
                    fRet= FALSE;
                }
            }
            break;
        case IDC_ST_DSL_HELPLINK:
            // HtmlHelp(hwndDlg, L"netcfg.chm::/howto_highspeed_repair.htm", HH_DISPLAY_TOPIC, 0);
            ShellExecute(NULL, NULL, L"HELPCTR.EXE", L" -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=ms-its%3A%25HELP_LOCATION%25%5Cnetcfg.chm%3A%3A/howto_highspeed_repair.htm", NULL, SW_SHOWNORMAL);
            
            break;
        case IDC_ST_INTERNETLINK:
            // HtmlHelp(hwndDlg, L"netcfg.chm::/i_client.htm", HH_DISPLAY_TOPIC, 0);
            ShellExecute(NULL, NULL, L"HELPCTR.EXE", L" -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=ms-its%3A%25HELP_LOCATION%25%5Cnetcfg.chm%3A%3A/i_client.htm", NULL, SW_SHOWNORMAL);

            break;
        default:
            AssertSz(FALSE, "Unexpected notify message");
    }

    return fRet;
}

//
// Function:    CGenericFinishPage::CreateCGenericFinishPagePage
//
// Purpose:     To determine if the CGenericFinishPage page needs to be shown, and to
//              to create the page if requested.  Note the CGenericFinishPage page is
//              responsible for initial installs also.
//
// Parameters:  idd         [IN] - IDD of dialog
//              pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CGenericFinishPage::HrCreateCGenericFinishPagePage(DWORD idd, CWizard *pWizard, PINTERNAL_SETUP_DATA pData, BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidWizard);
    
    CGenericFinishPage *pCGenericFinishPage = new CGenericFinishPage;
    if (!pCGenericFinishPage)
    {
        return E_OUTOFMEMORY;
    }
    pCGenericFinishPage->m_dwMyIDD = idd;

    HRESULT hr = S_OK;
    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        (*pnPages)++;

        // If not only counting, create and register the page

        if ( ! fCountOnly)
        {
            LinkWindow_RegisterClass();

            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;
            ZeroMemory(&psp, sizeof(PROPSHEETPAGE));

            TraceTag(ttidWizard, "Creating CGenericFinishPage Page for IID %d", idd);
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( idd );
            psp.hIcon = NULL;
            psp.pfnDlgProc = CGenericFinishPage::dlgprocCGenericFinishPage;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);

            hpsp = CreatePropertySheetPage( &psp );

            if (hpsp)
            {
                pWizard->RegisterPage(idd, hpsp,
                                CGenericFinishPage::CGenericFinishPagePageCleanup, idd);

                m_dwIddList[idd] = pCGenericFinishPage;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateCGenericFinishPagePage");
    return hr;
}

//
// Function:    CGenericFinishPage::AppendCGenericFinishPagePage
//
// Purpose:     Add the CGenericFinishPage page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  idd         [IN] - IDD of the dialog - should be created with HrCreateCGenericFinishPagePage first.
//              pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID CGenericFinishPage::AppendCGenericFinishPagePage(DWORD idd, CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidWizard);

    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(idd);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}


//
// Function:    CGenericFinishPage::dlgproCGenericFinishPage
//
// Purpose:     Dialog Procedure for the CGenericFinishPage wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK CGenericFinishPage::dlgprocCGenericFinishPage( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    TraceFileFunc(ttidWizard);

    BOOL frt = FALSE;
    CGenericFinishPage *pCGenericFinishPage = NULL;
    // Can't do a GetCGenericFinishPageFromHWND over here, since it will recurse & stack overflow.
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE *pPropSheetPage = reinterpret_cast<PROPSHEETPAGE *>(lParam);
            if (FAILED(GetCGenericFinishPageFromIDD(MAKERESOURCEINT(pPropSheetPage->pszTemplate), &pCGenericFinishPage)))
            {
                return FALSE;
            }

            frt = pCGenericFinishPage->OnCGenericFinishPageInitDialog(hwndDlg, lParam);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            case NM_CLICK:
                if (FAILED(GetCGenericFinishPageFromHWND(hwndDlg, &pCGenericFinishPage)))
                {
                    return FALSE;
                }
                frt = pCGenericFinishPage->CGenericFinishPagePageOnClick(hwndDlg, pnmh->idFrom);
                break;

            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                if (FAILED(GetCGenericFinishPageFromHWND(hwndDlg, &pCGenericFinishPage)))
                {
                    return FALSE;
                }
                frt = pCGenericFinishPage->OnCGenericFinishPagePageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                if (FAILED(GetCGenericFinishPageFromHWND(hwndDlg, &pCGenericFinishPage)))
                {
                    return FALSE;
                }
                frt = pCGenericFinishPage->OnCGenericFinishPagePageBack(hwndDlg);
                break;

            case PSN_WIZFINISH:
                if (FAILED(GetCGenericFinishPageFromHWND(hwndDlg, &pCGenericFinishPage)))
                {
                    return FALSE;
                }
                frt = pCGenericFinishPage->OnCGenericFinishPagePageNext(hwndDlg);
                break;

            case PSN_WIZNEXT:
                if (FAILED(GetCGenericFinishPageFromHWND(hwndDlg, &pCGenericFinishPage)))
                {
                    return FALSE;
                }
                frt = pCGenericFinishPage->OnCGenericFinishPagePageNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    CGenericFinishPage::CGenericFinishPagePageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID CGenericFinishPage::CGenericFinishPagePageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidWizard);
    Assert(lParam);

    CGenericFinishPage *pCGenericFinishPage;
    if (FAILED(GetCGenericFinishPageFromIDD(lParam, &pCGenericFinishPage)))
    {
        AssertSz(FALSE, "Could not find page");
        return;
    }

    if (IsPostInstall(pWizard))
    {
        LinkWindow_UnregisterClass(_Module.GetResourceInstance());

        if (NULL != pCGenericFinishPage->m_hBoldFont)
            DeleteObject(pCGenericFinishPage->m_hBoldFont);

        // 1 means it removed 1 element
        Assert(1 == CGenericFinishPage::m_dwIddList.erase(pCGenericFinishPage->m_dwMyIDD));
        
        delete pCGenericFinishPage;
    }
}


HRESULT CGenericFinishPage::GetCGenericFinishPageFromIDD(DWORD idd, CGenericFinishPage **pCGenericFinishPage)
{
    AssertSz(pCGenericFinishPage, "Invalid pointer to GetCGenericFinishPageFromHWND");
    if (!pCGenericFinishPage)
    {
        return E_POINTER;
    }

    IDDLIST::const_iterator iter = CGenericFinishPage::m_dwIddList.find(idd);
    if (iter != CGenericFinishPage::m_dwIddList.end())
    {
        *pCGenericFinishPage = iter->second;
    }
    else
    {
        AssertSz(FALSE, "Could not find this page in the IDD map");
        return E_FAIL;
    }

    return S_OK;
}

HRESULT CGenericFinishPage::GetCGenericFinishPageFromHWND(HWND hwndDlg, CGenericFinishPage **pCGenericFinishPage)
{
    AssertSz(pCGenericFinishPage, "Invalid pointer to GetCGenericFinishPageFromHWND");
    if (!pCGenericFinishPage)
    {
        return E_POINTER;
    }

    *pCGenericFinishPage = NULL;
    int iIndex = PropSheet_HwndToIndex(GetParent(hwndDlg), hwndDlg);
    AssertSz(-1 != iIndex, "Could not convert HWND to Index");
    if (-1 == iIndex)
    {
        return E_FAIL;
    }

    int iIdd = PropSheet_IndexToId(GetParent(hwndDlg), iIndex);
    AssertSz(iIdd, "Could not convert Index to IDD");
    if (!iIdd)
    {
        return E_FAIL;
    }

    return GetCGenericFinishPageFromIDD(iIdd, pCGenericFinishPage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\winternet.cpp ===
// ***************************************************************************
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:  winternet.cpp
//
//  Contents: Internet selection dialog for the New Connection Wizard
//
//  Author:     Dave Armour  8-25-00
//
// ***************************************************************************

#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"
#include "ncreg.h"
#include "ncui.h"

const WCHAR c_szICWPath[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\ICWCONN1.EXE";
extern const WCHAR c_szEmpty[];

// ***************************************************************************
// Function:    SetupFonts
//
// Purpose:     Generate bold or large bold fonts based on the font of the
//              window specified
//
// Parameters:  hwnd       [IN] - Handle of window to base font on
//              pBoldFont [OUT] - The newly generated font, NULL if the
//                                font could not be generated
//              fLargeFont [IN] - If TRUE, generate a 12 point bold font for
//                                use in the wizard "welcome" page.
//
// Returns:     nothing
// ***************************************************************************

VOID SetupInternetConnectFonts(HWND hwnd, HFONT * pBoldFont, BOOL fLargeFont)
{
    LOGFONT BoldLogFont;
    HFONT   hFont;
    WCHAR   FontSizeString[MAX_PATH];
    INT     FontSize;

    Assert(pBoldFont);
    *pBoldFont = NULL;

    // Get the font used by the specified window

    hFont = (HFONT)::SendMessage(hwnd, WM_GETFONT, 0, 0L);

    if (NULL == hFont)
    {
        // If not found then the control is using the system font

        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    }

    if (hFont)
    {
        // Get the font info so we can generate the BOLD version

        if (GetObject(hFont, sizeof(BoldLogFont), &BoldLogFont))
        {
            // Create the Bold Font

            BoldLogFont.lfWeight   = FW_BOLD;

            HDC hdc = GetDC(hwnd);

            if (hdc)
            {
                // Large (tall) font is an option

                if (fLargeFont)
                {
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.

                    UINT nLen = lstrlenW(SzLoadIds(IDS_LARGEFONTNAME));

                    if ((0 < nLen) && (nLen < LF_FACESIZE))
                    {
                        lstrcpyW(BoldLogFont.lfFaceName,SzLoadIds(IDS_LARGEFONTNAME));
                    }

                    FontSize = 12;
                    nLen = lstrlen(SzLoadIds(IDS_LARGEFONTSIZE));

                    if ((nLen < celems(FontSizeString)) && (0 < nLen))
                    {
                        lstrcpyW(FontSizeString, SzLoadIds(IDS_LARGEFONTSIZE));
                        FontSize = wcstoul(FontSizeString, NULL, 10);
                    }

                    BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);
                }

                *pBoldFont = CreateFontIndirect(&BoldLogFont);
                ReleaseDC(hwnd, hdc);
            }
        }
    }
}

// ***************************************************************************
// Function:    OnInternetPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg [IN] - Handle to the Internet dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnInternetPageActivate(HWND hwndDlg)
{
    TraceTag(ttidWizard, "Entering Internet Menu page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0L);

    CWizard * pWizard =
          reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}

// ***************************************************************************
// Function:    OnInternetWizNext
//
// Purpose:     Handle the PSN_WIZNEXT notification
//
// Parameters:  hwndDlg [IN] - Handle to the Internet dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnInternetWizNext(HWND hwndDlg)
{
    tstring str;

    // Retrieve the CWizard instance from the dialog

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    if ( ! IsPostInstall(pWizard) || (0 == pWizard->UlProviderCount()))
    {
        return TRUE;
    }
    
    // Find the selected provider and go to it's first page
    if (IsDlgButtonChecked(hwndDlg, CHK_MAIN_ALWAYS_ON))
    {
        pWizard->SetPageOrigin(IDD_Broadband_Always_On, IDD_Internet_Connection, CHK_MAIN_ALWAYS_ON);
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Broadband_Always_On);
    }
    else
    {
        for (ULONG ulIdx = 0; ulIdx < pWizard->UlProviderCount(); ulIdx++)
        {
            CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);

            Assert(NULL != pWizProvider);
            Assert(0 != pWizProvider->ULPageCount());

            if (IsDlgButtonChecked(hwndDlg, pWizProvider->GetBtnIdc()))
            {

                pWizard->SetCurrentProvider(ulIdx);
                HPROPSHEETPAGE hPage = (pWizProvider->PHPropPages())[0];
                Assert(NULL != hPage);
                PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                            (LPARAM)(HPROPSHEETPAGE)hPage);
            }
        }
    }

    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}


BOOL OnInternetWizBack(HWND hwndDlg)
{
    tstring str;

    // Retrieve the CWizard instance from the dialog

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    pWizard->SetPageOrigin(IDD_ISP, IDD_Internet_Connection, CHK_MAIN_INTERNET);
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_ISP);
    
    return TRUE;   
}


// ***************************************************************************

BOOL OnInternetDialogInit(HWND hwndDlg, LPARAM lParam)
{
    INT nIdx;
    INT nrgICW[] = {CHK_MAIN_INTERNET, TXT_MAIN_INTERNET_1};
    INT nrgIdc[] = {CHK_MAIN_INTERNET, TXT_MAIN_INTERNET_1,
                    CHK_MAIN_PPPOE,    TXT_MAIN_PPPOE_1,
                    CHK_MAIN_ALWAYS_ON,TXT_MAIN_ALWAYS_ON_1};

    // The order here should be the same as the vertical order in the resources

    INT nrgChks[] = {CHK_MAIN_INTERNET, CHK_MAIN_PPPOE, CHK_MAIN_ALWAYS_ON};

    // Initialize our pointers to property sheet info.

    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    // Get the bold font for the radio buttons

    HFONT hBoldFont = NULL;
    SetupInternetConnectFonts(hwndDlg, &hBoldFont, FALSE);

    if (NULL != hBoldFont)
    {
        // Remember the font handle so we can free it on exit

        pWizard->SetPageData(IDD_Internet_Connection, (LPARAM)hBoldFont);

        for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
        {
            HWND hwndCtl = GetDlgItem(hwndDlg, nrgChks[nIdx]);
            Assert(NULL != hwndCtl);
            SetWindowFont(hwndCtl, hBoldFont, TRUE);
        }
    }

    // Populate the UI

    for (ULONG ulIdx = 0;
         ulIdx < pWizard->UlProviderCount();
         ulIdx++)
    {
        CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);
        Assert(NULL != pWizProvider);
        Assert(0 != pWizProvider->ULPageCount());

        // Get the radio button associated with this provider

        INT nIdcBtn = pWizProvider->GetBtnIdc();

        // Find the set of controls to enable in the array

        for (nIdx = 0; nIdx < celems(nrgIdc); nIdx += 2)
        {
            if (nrgIdc[nIdx] == nIdcBtn)
            {
                // Enable the controls

                for (INT un = 0; un < 2; un++)
                {
                    HWND hwndBtn = GetDlgItem(hwndDlg, nrgIdc[nIdx + un]);
                    Assert(NULL != hwndBtn);
                    EnableWindow(hwndBtn, TRUE);
                }

                break;
            }
        }
    }

    // Find the top most enabled radio button

    for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
    {
        if (IsWindowEnabled(GetDlgItem(hwndDlg, nrgChks[nIdx])))
        {
            CheckRadioButton(hwndDlg, CHK_MAIN_INTERNET, CHK_MAIN_ALWAYS_ON, nrgChks[nIdx]);
            break;
        }
    }

    return TRUE;
}

// ***************************************************************************
// Function:    dlgprocInternet
//
// Purpose:     Dialog Procedure for the Internet wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
// ***************************************************************************

INT_PTR CALLBACK dlgprocInternet( HWND hwndDlg, UINT uMsg,
                              WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnInternetDialogInit(hwndDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnInternetPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                frt = OnInternetWizBack(hwndDlg);
                return(TRUE);

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnInternetWizNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return(frt);
}

// ***************************************************************************
// Function:    InternetPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
// ***************************************************************************

VOID InternetPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    HFONT hBoldFont = (HFONT)pWizard->GetPageData(IDD_Internet_Connection);

    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }
}

// ***************************************************************************
// Function:    CreateInternetPage
//
// Purpose:     To determine if the Internet page needs to be shown, and to
//              to create the page if requested.  Note the Main page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
// ***************************************************************************

HRESULT HrCreateInternetPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                             BOOL fCountOnly, UINT *pnPages)
{
    HRESULT hr = S_OK;

    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        // RAS PostInstall only

        (*pnPages)++;

        // If not only counting, create and register the page

        if ( ! fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating Internet Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_Internet_Connection );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocInternet;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);
            psp.pszHeaderTitle = SzLoadIds(IDS_T_Internet_Connection);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Internet_Connection);

            hpsp = CreatePropertySheetPage( &psp );

            if (hpsp)
            {
                pWizard->RegisterPage(IDD_Internet_Connection, hpsp,
                                      InternetPageCleanup, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateInternetPage");
    return hr;
}

// ***************************************************************************
// Function:    AppendInternetPage
//
// Purpose:     Add the Internet page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
// ***************************************************************************

VOID AppendInternetPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Internet_Connection);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wmainint.cpp ===
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"
#include "ncui.h"

static const UINT WM_DEFERREDINIT   = WM_USER + 100;

typedef struct
{
    HFONT   hBoldFont;
    HFONT   hMarlettFont;
    BOOL    fProcessed;
} MAININTRO_DATA;

//
// Function:    OnMainIntroPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg [IN] - Handle to the MainIntro dialog
//
// Returns:     BOOL
//
BOOL OnMainIntroPageActivate(HWND hwndDlg)
{
    INT nBtn = PSWIZB_NEXT;
    TraceTag(ttidWizard, "Entering MainIntro Menu page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0L);

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    if (pWizard)
    {
        MAININTRO_DATA * pData = reinterpret_cast<MAININTRO_DATA *>
                                        (pWizard->GetPageData(IDD_MainIntro));

        if ((pData && !pData->fProcessed) && pWizard->FDeferredProviderLoad())
        {
            nBtn = 0;
        }
    }

    PropSheet_SetWizButtons(GetParent(hwndDlg), nBtn);
    return TRUE;
}

//
// Function:    OnMainIntroDialogInit
//
// Purpose:     Handle the WM_INITDIALOG notification
//
// Parameters:  hwndDlg [IN] - Handle to the MainIntro dialog
//              lParam  [IN] -
//
// Returns:     BOOL
//
BOOL OnMainIntroDialogInit(HWND hwndDlg, LPARAM lParam)
{
    // Initialize our pointers to property sheet info.
    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);

    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    MAININTRO_DATA * pData = reinterpret_cast<MAININTRO_DATA *>
                                    (pWizard->GetPageData(IDD_MainIntro));
    Assert(NULL != pData);

    // Center the window and retain the current wizard hwnd
    //
    HWND hwndParent = GetParent(hwndDlg);
    CenterWizard(hwndParent);

    // Hide the close and context help buttons - Raid 249287
    long lStyle = GetWindowLong(hwndParent,GWL_STYLE);
    lStyle &= ~WS_SYSMENU;
    SetWindowLong(hwndParent,GWL_STYLE,lStyle);

   //
   // Create the Marlett font.  In the Marlett font the "i" is a bullet.
   // Code borrowed from Add Hardware Wizard. 
   HFONT hFontCurrent;
   HFONT hFontCreated;
   LOGFONT LogFont;

   hFontCurrent = (HFONT)SendMessage(GetDlgItem(hwndDlg, IDC_BULLET_1), WM_GETFONT, 0, 0);
   GetObject(hFontCurrent, sizeof(LogFont), &LogFont);
   LogFont.lfCharSet = SYMBOL_CHARSET;
   LogFont.lfPitchAndFamily = FF_DECORATIVE | DEFAULT_PITCH;
   lstrcpy(LogFont.lfFaceName, L"Marlett");
   hFontCreated = CreateFontIndirect(&LogFont);

   if (hFontCreated)
   {
       pData->hMarlettFont = hFontCreated;
       //
       // An "i" in the marlett font is a small bullet.
       //
       SetWindowText(GetDlgItem(hwndDlg, IDC_BULLET_1), L"i");
       SetWindowFont(GetDlgItem(hwndDlg, IDC_BULLET_1), hFontCreated, TRUE);
       SetWindowText(GetDlgItem(hwndDlg, IDC_BULLET_2), L"i");
       SetWindowFont(GetDlgItem(hwndDlg, IDC_BULLET_2), hFontCreated, TRUE);
       SetWindowText(GetDlgItem(hwndDlg, IDC_BULLET_3), L"i");
       SetWindowFont(GetDlgItem(hwndDlg, IDC_BULLET_3), hFontCreated, TRUE);
   }

    // Load the description
    //
   
    HFONT hBoldFont = NULL;
    SetupFonts(hwndDlg, &hBoldFont, TRUE);
    if (NULL != hBoldFont)
    {
        pData->hBoldFont = hBoldFont;

        HWND hwndCtl = GetDlgItem(hwndDlg, IDC_WELCOME_CAPTION);
        if (hwndCtl)
        {
             SetWindowFont(hwndCtl, hBoldFont, TRUE);
        }
    }

    if (S_OK != HrShouldHaveHomeNetWizard())
    {
        ::ShowWindow(GetDlgItem(hwndDlg, IDC_BULLET_3), SW_HIDE);
        ::ShowWindow(GetDlgItem(hwndDlg, TXT_CONNECTHOME), SW_HIDE);
    }

    // if the provider load was deferred until now...disable things
    // and let the first WM_PAINT take care of the final provider load.
    //
    if (pWizard->FDeferredProviderLoad())
    {
        PropSheet_SetWizButtons(hwndParent, 0);
        EnableWindow(GetDlgItem(hwndParent, IDCANCEL), FALSE);
    }

    return TRUE;
}

//
// Function:    OnMainIntroDeferredInit
//
// Purpose:     Handle the WM_DEFERREDINIT notification
//
// Parameters:  hwndDlg [IN] - Handle to the MainIntro dialog
//
// Returns:     BOOL
//
BOOL OnMainIntroDeferredInit(HWND hwndDlg)
{
    CWaitCursor wc;

    HWND hwndParent = GetParent(hwndDlg);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));

    pWizard->LoadAndInsertDeferredProviderPages(hwndParent, IDD_Advanced);
    PropSheet_SetWizButtons(hwndParent, PSWIZB_NEXT);
    EnableWindow(GetDlgItem(hwndParent, IDCANCEL), TRUE);

    return FALSE;
}

//
// Function:    OnMainIntroPaint
//
// Purpose:     Handle the WM_PAINT notification
//
// Parameters:  hwndDlg [IN] - Handle to the MainIntro dialog
//
// Returns:     BOOL
//
BOOL OnMainIntroPaint(HWND hwndDlg)
{
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));

    MAININTRO_DATA * pData = reinterpret_cast<MAININTRO_DATA *>
                                    (pWizard->GetPageData(IDD_MainIntro));
    Assert(NULL != pData);

    if (pData && !pData->fProcessed)
    {
        pData->fProcessed = TRUE;
        if (pWizard->FDeferredProviderLoad())
        {
            PostMessage(hwndDlg, WM_DEFERREDINIT, 0, 0);
        }
    }
    return FALSE;
}

//
// Function:    dlgprocMainIntro
//
// Purpose:     Dialog Procedure for the MainIntro wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocMainIntro(HWND hwndDlg, UINT uMsg,
                               WPARAM wParam, LPARAM lParam)
{
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnMainIntroDialogInit(hwndDlg, lParam);
        break;

    case WM_DEFERREDINIT:
        frt = OnMainIntroDeferredInit(hwndDlg);
        break;

    case WM_PAINT:
        frt = OnMainIntroPaint(hwndDlg);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnMainIntroPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    MainIntroPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID MainIntroPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    MAININTRO_DATA * pData = reinterpret_cast<MAININTRO_DATA *>(lParam);
    if (pData)
    {
        if (pData->hBoldFont)
        {
            DeleteObject(pData->hBoldFont);
        }

        if (pData->hMarlettFont)
        {
            DeleteObject(pData->hMarlettFont);
        }

        MemFree(reinterpret_cast<void*>(lParam));
    }
}

//
// Function:    CreateMainIntroPage
//
// Purpose:     To determine if the MainIntro page needs to be shown, and to
//              to create the page if requested.  Note the MainIntro page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateMainIntroPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                              BOOL fCountOnly, UINT *pnPages)
{
    HRESULT hr = S_OK;

    if (IsPostInstall(pWizard) && !pWizard->FProcessLanPages())
    {
        // RAS PostInstall only
        (*pnPages)++;

        // If not only counting, create and register the page
        if (!fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;
            MAININTRO_DATA * pData;

            TraceTag(ttidWizard, "Creating MainIntro Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_DEFAULT | PSP_HIDEHEADER;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE(IDD_MainIntro);
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocMainIntro;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);

            hr = E_OUTOFMEMORY;
            pData = reinterpret_cast<MAININTRO_DATA *>(MemAlloc(sizeof(MAININTRO_DATA)));
            if (pData)
            {
                pData->hBoldFont  = NULL;
                pData->hMarlettFont = NULL;
                pData->fProcessed = FALSE;

                hpsp = CreatePropertySheetPage(&psp);
                if (hpsp)
                {
                    pWizard->RegisterPage(IDD_MainIntro, hpsp,
                                          MainIntroPageCleanup,
                                          reinterpret_cast<LPARAM>(pData));
                    hr = S_OK;
                }
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateMainIntroPage");
    return hr;
}

//
// Function:    AppendMainIntroPage
//
// Purpose:     Add the MainIntro page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendMainIntroPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    if (IsPostInstall(pWizard) && !pWizard->FProcessLanPages())
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_MainIntro);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wmi.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ndisguid.h>
#include "afilexp.h"
#include "edc.h"
#include "lm.h"
#include "nceh.h"
#include "ncerror.h"
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "ncsetup.h"
#include "ncatlui.h"
#include "netcfgn.h"
#include "netsetup.h"
#include "nslog.h"
#include "nsres.h"
#include "resource.h"
#include "upgrade.h"
#include "windns.h"
#include "winstall.h"

#include <hnetcfg.h>
#include "icsupgrd.h"


static const WCHAR szBefore[] = L"Before";
static const WCHAR szWMI[] = L"WMI";
static const WCHAR szAfter[] = L"After";

void DumpDependencyList(
    const WCHAR * Name,
    PWCHAR List
    )
{
    PWCHAR p;

    TraceTag(ttidWmi,
             "%ws Dependency List",
             Name);

    p = List;
    while (*p != 0)
    {
        TraceTag(ttidWmi,
                 "    %ws",
                 p);
        while (*p++ != 0) ;
    }
    
}

void FixWmiServiceDependencies(
    const WCHAR *ServiceName
    )
{
    SC_HANDLE ScmHandle, ServiceHandle;
    LPQUERY_SERVICE_CONFIG Config;
    PUCHAR Buffer;
    ULONG SizeNeeded = sizeof(QUERY_SERVICE_CONFIG) + 256*sizeof(TCHAR);
    PWCHAR p, pSrc, pDest;
    ULONG Bytes;
    BOOLEAN Working;
    
    TraceTag(ttidWmi,
             "Entering FixWmiServiceDependcies for %ws...",
             ServiceName);
    
    ScmHandle = OpenSCManager(NULL,
                             NULL,
                             SC_MANAGER_ALL_ACCESS);
    if (ScmHandle != NULL)
    {
        ServiceHandle = OpenService(ScmHandle,
                                    ServiceName,
                                    SERVICE_ALL_ACCESS);

        if (ServiceHandle != NULL)
        {
            Working = TRUE;
            do
            {
                Buffer = (PUCHAR)MemAlloc(SizeNeeded);
                if (Buffer != NULL)
                {
                    Config = (LPQUERY_SERVICE_CONFIG)Buffer;
                    if (QueryServiceConfig(ServiceHandle,
                                           Config,
                                           SizeNeeded,
                                           &SizeNeeded))
                    {
                        p = Config->lpDependencies;
                        DumpDependencyList(szBefore, Config->lpDependencies);
                        while (*p != 0)
                        {
                            if (_wcsicmp(p, szWMI) == 0)
                            {
                                //
                                // We found the WMI dependency on the
                                // list
                                //
                                TraceTag(ttidWmi,
                                         "FixWmiServiceDependcies: Found WMI Dependency at %p",
                                         p);
                                pDest = p;

                                //
                                // Advance to next string
                                //
                                while (*p++ != 0) ;

                                //
                                // Figure out number of byes left at
                                // end of string
                                //
                                pSrc = p;
                                while ((*p != 0) || (*(p+1) != 0))
                                {
                                    p++;
                                }
                                Bytes = ((p + 2) - pSrc) * sizeof(TCHAR);

                                TraceTag(ttidWmi,
                                         "FixWmiServiceDependcies: Copy 0x%x bytes from %ws to %ws",
                                         Bytes,
                                         pSrc,
                                         pDest);
                                memcpy(pDest, pSrc, Bytes);

                                DumpDependencyList(szAfter, Config->lpDependencies);
                                
                                if (! ChangeServiceConfig(ServiceHandle,
                                                          SERVICE_NO_CHANGE,
                                                          SERVICE_NO_CHANGE,
                                                          SERVICE_NO_CHANGE,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          Config->lpDependencies,
                                                          NULL,
                                                          NULL,
                                                          NULL))
                                {
                                    //
                                    // This is bad
                                    //
                                    TraceError(
                                             "FixWmiServiceDependcies: ChangeServiceConfig failed",
                                             GetLastError());
                                }
                            } else {
                                //
                                // Advance to next string in list
                                //
                                TraceTag(ttidWmi,
                                         "FixWmiServiceDependcies: skipping dependency %ws",
                                         p);

                                while (*p++ != 0) ;
                            }
                        }
                        Working = FALSE;
                    } else {
                        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                        {
                            //
                            // This is bad, but what can we do ??
                            //
                            Working = FALSE;
                            TraceError(
                                     "FixWmiServiceDependcies: QueryServiceConfig failed",
                                     GetLastError());

                        }
                    }
                    
                    MemFree(Buffer);
                } else {
                    //
                    // This is bad, but what can we do ??
                    //
                    TraceTag(ttidWmi,
                             "FixWmiServiceDependcies: BufferAlloc for %d failed",
                             SizeNeeded);
                    Working = FALSE;
                }
            } while(Working);
            CloseServiceHandle(ServiceHandle);
        } else {
            TraceError(
                     "FixWmiServiceDependcies: OpenService failed",
                     GetLastError());
            
        }
        CloseServiceHandle(ScmHandle);
    } else {
        TraceError(
                 "FixWmiServiceDependcies: OpenSCManager failed",
                 GetLastError());
            
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wmain.cpp ===
// ***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"
#include "ncreg.h"
#include "ncui.h"

extern const WCHAR c_szEmpty[];

// ***************************************************************************
// Function:    SetupFonts
//
// Purpose:     Generate bold or large bold fonts based on the font of the
//              window specified
//
// Parameters:  hwnd       [IN] - Handle of window to base font on
//              pBoldFont [OUT] - The newly generated font, NULL if the
//                                font could not be generated
//              fLargeFont [IN] - If TRUE, generate a 12 point bold font for
//                                use in the wizard "welcome" page.
//
// Returns:     nothing
// ***************************************************************************

VOID SetupFonts(HWND hwnd, HFONT * pBoldFont, BOOL fLargeFont)
{
    TraceFileFunc(ttidGuiModeSetup);

    LOGFONT BoldLogFont;
    HFONT   hFont;
    WCHAR   FontSizeString[MAX_PATH];
    INT     FontSize;

    Assert(pBoldFont);
    *pBoldFont = NULL;

    // Get the font used by the specified window

    hFont = (HFONT)::SendMessage(hwnd, WM_GETFONT, 0, 0L);

    if (NULL == hFont)
    {
        // If not found then the control is using the system font

        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
    }

    if (hFont)
    {
        // Get the font info so we can generate the BOLD version

        if (GetObject(hFont, sizeof(BoldLogFont), &BoldLogFont))
        {
            // Create the Bold Font

            BoldLogFont.lfWeight   = FW_BOLD;

            HDC hdc = GetDC(hwnd);

            if (hdc)
            {
                // Large (tall) font is an option

                if (fLargeFont)
                {
                    // Load size and name from resources, since these may change
                    // from locale to locale based on the size of the system font, etc.

                    UINT nLen = lstrlenW(SzLoadIds(IDS_LARGEFONTNAME));

                    if ((0 < nLen) && (nLen < LF_FACESIZE))
                    {
                        lstrcpyW(BoldLogFont.lfFaceName,SzLoadIds(IDS_LARGEFONTNAME));
                    }

                    FontSize = 12;
                    nLen = lstrlen(SzLoadIds(IDS_LARGEFONTSIZE));

                    if ((nLen < celems(FontSizeString)) && (0 < nLen))
                    {
                        lstrcpyW(FontSizeString, SzLoadIds(IDS_LARGEFONTSIZE));
                        FontSize = wcstoul(FontSizeString, NULL, 10);
                    }

                    BoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);
                }

                *pBoldFont = CreateFontIndirect(&BoldLogFont);
                ReleaseDC(hwnd, hdc);
            }
        }
    }
}

// ***************************************************************************

VOID CenterWizard(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    RECT rc;
    int nWidth = GetSystemMetrics(SM_CXSCREEN);
    int nHeight = GetSystemMetrics(SM_CYSCREEN);

    GetWindowRect(hwndDlg, &rc);
    SetWindowPos(hwndDlg, NULL,
                 ((nWidth / 2) - ((rc.right - rc.left) / 2)),
                 ((nHeight / 2) - ((rc.bottom - rc.top) / 2)),
                 0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
}

// ***************************************************************************
// Function:    OnMainPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg [IN] - Handle to the Main dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnMainPageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    TraceTag(ttidWizard, "Entering Main Menu page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0L);
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    return TRUE;
}

RECT RectTranslateLocal(RECT rcContainee, RECT rcContainer)
{
    Assert(rcContainee.left   >= rcContainer.left);
    Assert(rcContainee.top    >= rcContainer.top);
    Assert(rcContainee.right  <= rcContainer.right);
    Assert(rcContainee.bottom <= rcContainer.bottom);

    // e.g.    10,10,100,100
    // inside   5, 5,110,110
    // should give: 5,5,95,95

    RECT rcTemp;
    rcTemp.left   = rcContainee.left   - rcContainer.left;
    rcTemp.top    = rcContainee.top    - rcContainer.top;
    rcTemp.right  = rcContainee.right  - rcContainer.left;
    rcTemp.bottom = rcContainee.bottom - rcContainer.top;
    return rcTemp;
}

// ***************************************************************************
// Function:    OnMainDialogInit
//
// Purpose:     Handle the WM_INITDIALOG notification
//
// Parameters:  hwndDlg [IN] - Handle to the Main dialog
//              lParam  [IN] -
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnMainDialogInit(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    INT nIdx;

    // The order here should be the same as the vertical order in the resources

    INT nrgChks[] = {CHK_MAIN_INTERNET_CONNECTION, CHK_MAIN_CONNECTION, CHK_MAIN_HOMENET, CHK_MAIN_ADVANCED};

    if (S_OK != HrShouldHaveHomeNetWizard())
    {
        HWND hwndCHK_MAIN_HOMENET   = GetDlgItem(hwndDlg, CHK_MAIN_HOMENET);
        HWND hwndTXT_MAIN_HOMENET   = GetDlgItem(hwndDlg, TXT_MAIN_HOMENET);
        HWND hwndCHK_MAIN_ADVANCED  = GetDlgItem(hwndDlg, CHK_MAIN_ADVANCED);
        HWND hwndTXT_MAIN_ADVANCED_1= GetDlgItem(hwndDlg, TXT_MAIN_ADVANCED_1);

        EnableWindow(hwndCHK_MAIN_HOMENET, FALSE);
        ShowWindow(hwndCHK_MAIN_HOMENET, SW_HIDE);
        ShowWindow(hwndTXT_MAIN_HOMENET, SW_HIDE);

        RECT rcHomeNetChk;
        RECT rcAdvanceChk;
        RECT rcAdvanceTxt;
        RECT rcDialog;

        GetWindowRect(hwndCHK_MAIN_HOMENET,    &rcHomeNetChk);
        GetWindowRect(hwndCHK_MAIN_ADVANCED,   &rcAdvanceChk);
        GetWindowRect(hwndTXT_MAIN_ADVANCED_1, &rcAdvanceTxt);
        GetWindowRect(hwndDlg,                 &rcDialog);
        
        DWORD dwMoveUpBy = rcAdvanceChk.top - rcHomeNetChk.top;
        rcAdvanceChk.top    -= dwMoveUpBy;
        rcAdvanceChk.bottom -= dwMoveUpBy;
        rcAdvanceTxt.top    -= dwMoveUpBy;
        rcAdvanceTxt.bottom -= dwMoveUpBy;
        
        Assert(rcAdvanceChk.top == rcHomeNetChk.top);

        rcAdvanceChk = RectTranslateLocal(rcAdvanceChk, rcDialog);
        rcAdvanceTxt = RectTranslateLocal(rcAdvanceTxt, rcDialog);
        
        MoveWindow(hwndCHK_MAIN_ADVANCED,   rcAdvanceChk.left, rcAdvanceChk.top, rcAdvanceChk.right - rcAdvanceChk.left, rcAdvanceChk.bottom - rcAdvanceChk.top, TRUE);
        MoveWindow(hwndTXT_MAIN_ADVANCED_1, rcAdvanceTxt.left, rcAdvanceTxt.top, rcAdvanceTxt.right - rcAdvanceTxt.left, rcAdvanceTxt.bottom - rcAdvanceTxt.top, TRUE);
    }
    // Initialize our pointers to property sheet info.

    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    // Get the bold font for the radio buttons

    HFONT hBoldFont = NULL;
    SetupFonts(hwndDlg, &hBoldFont, FALSE);

    if (NULL != hBoldFont)
    {
        // Remember the font handle so we can free it on exit

        pWizard->SetPageData(IDD_Main, (LPARAM)hBoldFont);

        for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
        {
            HWND hwndCtl = GetDlgItem(hwndDlg, nrgChks[nIdx]);
            Assert(NULL != hwndCtl);
            SetWindowFont(hwndCtl, hBoldFont, TRUE);
        }
    }

    // Find the top most enabled radio button

    for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
    {
        if (IsWindowEnabled(GetDlgItem(hwndDlg, nrgChks[nIdx])))
        {
            CheckRadioButton(hwndDlg, CHK_MAIN_INTERNET_CONNECTION, CHK_MAIN_ADVANCED, nrgChks[nIdx]);
            break;
        }
    }

    return TRUE;
}

// ***************************************************************************
// Function:    OnMainWizNext
//
// Purpose:     Handle the PSN_WIZNEXT notification
//
// Parameters:  hwndDlg [IN] - Handle to the Main dialog
//
// Returns:     BOOL
// ***************************************************************************
BOOL OnMainWizNext(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    tstring str;

    // Retrieve the CWizard instance from the dialog

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    if ( ! IsPostInstall(pWizard) || (0 == pWizard->UlProviderCount()))
    {
        return TRUE;
    }

    if (IsDlgButtonChecked(hwndDlg, CHK_MAIN_INTERNET_CONNECTION) == BST_CHECKED)
    {
        pWizard->SetPageOrigin(IDD_ISP, IDD_Main, CHK_MAIN_INTERNET_CONNECTION);
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_ISP);
    }
    else if (IsDlgButtonChecked(hwndDlg, CHK_MAIN_CONNECTION) == BST_CHECKED)
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Connect);
    }
    else if (IsDlgButtonChecked(hwndDlg, CHK_MAIN_HOMENET) == BST_CHECKED)
    {
        pWizard->SetPageOrigin(IDD_FinishNetworkSetupWizard, IDD_Main, CHK_ISP_OTHER_WAYS);
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_FinishNetworkSetupWizard);
    }        
    else
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Advanced);
    }

    return TRUE;
}

// ***************************************************************************
// Function:    dlgprocMain
//
// Purpose:     Dialog Procedure for the Main wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
// ***************************************************************************

INT_PTR CALLBACK dlgprocMain(HWND hwndDlg, UINT uMsg,
                               WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnMainDialogInit(hwndDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnMainPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnMainWizNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

// ***************************************************************************
// Function:    MainPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
// ***************************************************************************

VOID MainPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HFONT hBoldFont = (HFONT)pWizard->GetPageData(IDD_Main);

    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }
}

// ***************************************************************************
// Function:    CreateMainPage
//
// Purpose:     To determine if the Main page needs to be shown, and to
//              to create the page if requested.  Note the Main page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
// ***************************************************************************

HRESULT HrCreateMainPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                         BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;

    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        // RAS PostInstall only

        (*pnPages)++;

        // If not only counting, create and register the page

        if ( ! fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating Main Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_Main );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocMain;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);
            psp.pszHeaderTitle = SzLoadIds(IDS_T_Main);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Main);

            hpsp = CreatePropertySheetPage( &psp );

            if (hpsp)
            {
                pWizard->RegisterPage(IDD_Main, hpsp,
                                      MainPageCleanup, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateMainPage");
    return hr;
}

// ***************************************************************************
// Function:    AppendMainPage
//
// Purpose:     Add the Main page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
// ***************************************************************************

VOID AppendMainPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Main);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wisp.cpp ===
// ***************************************************************************
#include "pch.h"
#pragma hdrstop
#include "resource.h"
#include "wizard.h"
#include "ncreg.h"
#include "ncui.h"

extern const WCHAR c_szEmpty[];

// ***************************************************************************
// Function:    OnISPPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg [IN] - Handle to the ISP dialog
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnISPPageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    TraceTag(ttidWizard, "Entering ISP Menu page...");
    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0L);
    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

#if defined (_X86_)
    if (IsOS(OS_ANYSERVER))
#endif
    { 
        // Skip over this page if we're on an x86server, or any other processor architecture.
        if (IDD_Main == pWizard->GetPageOrigin(IDD_ISP, NULL))
        {
            pWizard->SetPageOrigin(IDD_Internet_Connection, IDD_Main, CHK_ISP_INTERNET_CONNECTION);

            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
            // Jump to the IDD_Internet_Connection page
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0, (LPARAM)pWizard->GetPageHandle(IDD_Internet_Connection));
        }
        else
        {
            pWizard->SetPageOrigin(IDD_Main, IDD_Internet_Connection, CHK_ISP_INTERNET_CONNECTION);

            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
            // Jump to the IDD_Main page
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0, (LPARAM)pWizard->GetPageHandle(IDD_Main));
        }
    }

    return TRUE;
}

// ***************************************************************************
// Function:    OnISPDialogInit
//
// Purpose:     Handle the WM_INITDIALOG notification
//
// Parameters:  hwndDlg [IN] - Handle to the ISP dialog
//              lParam  [IN] -
//
// Returns:     BOOL
// ***************************************************************************

BOOL OnISPDialogInit(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    INT nIdx;

    // The order here should be the same as the vertical order in the resources

    INT nrgChks[] = {CHK_ISP_OTHER_WAYS, CHK_ISP_INTERNET_CONNECTION, CHK_ISP_SOFTWARE_CD};
    // Initialize our pointers to property sheet info.

    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);
    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    // Get the bold font for the radio buttons
    HFONT hBoldFont = NULL;
    SetupFonts(hwndDlg, &hBoldFont, FALSE);

    if (NULL != hBoldFont)
    {
        // Remember the font handle so we can free it on exit

        pWizard->SetPageData(IDD_ISP, (LPARAM)hBoldFont);

        for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
        {
            HWND hwndCtl = GetDlgItem(hwndDlg, nrgChks[nIdx]);
            Assert(NULL != hwndCtl);
            SetWindowFont(hwndCtl, hBoldFont, TRUE);
        }
    }

    // Find the top most enabled radio button

    for (nIdx = 0; nIdx < celems(nrgChks); nIdx++)
    {
        if (IsWindowEnabled(GetDlgItem(hwndDlg, nrgChks[nIdx])))
        {
            CheckRadioButton(hwndDlg, CHK_ISP_INTERNET_CONNECTION, CHK_ISP_OTHER_WAYS, nrgChks[nIdx]);
            break;
        }
    }

    return TRUE;
}

// ***************************************************************************
// Function:    OnISPWizNext
//
// Purpose:     Handle the PSN_WIZNEXT notification
//
// Parameters:  hwndDlg [IN] - Handle to the ISP dialog
//
// Returns:     BOOL
// ***************************************************************************
BOOL OnISPWizNext(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    tstring str;

    // Retrieve the CWizard instance from the dialog

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    if ( ! IsPostInstall(pWizard) || (0 == pWizard->UlProviderCount()))
    {
        return TRUE;
    }

    if (IsDlgButtonChecked(hwndDlg, CHK_ISP_INTERNET_CONNECTION) == BST_CHECKED)
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Internet_Connection);
    }
    else if (IsDlgButtonChecked(hwndDlg, CHK_ISP_SOFTWARE_CD) == BST_CHECKED)
    {
        pWizard->SetPageOrigin(IDD_ISPSoftwareCD, IDD_ISP, CHK_ISP_SOFTWARE_CD);
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_ISPSoftwareCD);
    }
    else if (IsDlgButtonChecked(hwndDlg, CHK_ISP_OTHER_WAYS) == BST_CHECKED)
    {
        pWizard->SetPageOrigin(IDD_FinishOtherWays, IDD_ISP, CHK_ISP_OTHER_WAYS);
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_FinishOtherWays);
    }
    else
    {
        AssertSz(FALSE, "What did you click on?");
    }

    return TRUE;
}

// ***************************************************************************
// Function:    dlgprocISP
//
// Purpose:     Dialog Procedure for the ISP wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
// ***************************************************************************

INT_PTR CALLBACK dlgprocISP(HWND hwndDlg, UINT uMsg,
                               WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        frt = OnISPDialogInit(hwndDlg, lParam);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnISPPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnISPWizNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

// ***************************************************************************
// Function:    ISPPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
// ***************************************************************************

VOID ISPPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HFONT hBoldFont = (HFONT)pWizard->GetPageData(IDD_ISP);

    if (NULL != hBoldFont)
    {
        DeleteObject(hBoldFont);
    }
}

// ***************************************************************************
// Function:    HrCreateISPPage
//
// Purpose:     To determine if the ISP page needs to be shown, and to
//              to create the page if requested.  
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
// ***************************************************************************

HRESULT HrCreateISPPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                         BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;

    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        // RAS PostInstall only

        (*pnPages)++;

        // If not only counting, create and register the page

        if ( ! fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating ISP Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_ISP );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocISP;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);
            psp.pszHeaderTitle = SzLoadIds(IDS_T_ISP);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_ISP);

            hpsp = CreatePropertySheetPage( &psp );

            if (hpsp)
            {
                pWizard->RegisterPage(IDD_ISP, hpsp,
                                      ISPPageCleanup, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateISPPage");
    return hr;
}

// ***************************************************************************
// Function:    AppendISPPage
//
// Purpose:     Add the ISP page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
// ***************************************************************************

VOID AppendISPPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if (IsPostInstall(pWizard) && ( ! pWizard->FProcessLanPages()))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_ISP);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}

// ***************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wizard.h ===
//----------------------------------------------------------------------------
//
//  File: wizard.h
//
//  Contents: defines the wizard specific private types and values
//
//----------------------------------------------------------------------------
#pragma once
#include "nsbase.h"
#include "netconp.h"
#include "resource.h"
#include <syssetup.h>
#include <windns.h>

HRESULT HrShouldHaveHomeNetWizard();

class CWizard;
typedef VOID (CALLBACK FAR * PFNPAGECLEANPROC)(CWizard *, LPARAM);

typedef list<GUID *> GUID_LIST;

// struct ProviderList
//
// Purpose: Contains the GUID for the provider instance and the id's of the
//          display strings to use.
//
typedef struct _tagProviderList
{
    const GUID * pguidProvider;
    UINT         nBtnIdc;
} ProviderList;

extern BOOL bCallRasDlgEntry;
//
// Class:   CWizardUiContext
//
// Purpose: To provide a means by which the wizard providers can find out
//          about the context in which they will run
//
class CWizardUiContext : public INetConnectionWizardUiContext
{
public:
    CWizardUiContext(PINTERNAL_SETUP_DATA pData)
                    {
                     m_pData = pData;
                     m_dwSetupMode = pData->SetupMode;
                     m_cRef = 1;
                     m_pINetCfg = NULL;
                     m_dwUnattendedMode = 0;
                    }
    ~CWizardUiContext() {ReleaseObj(m_pINetCfg);}

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // *** INetConnectionWizardUiContext methods ***
    STDMETHODIMP_(DWORD)GetSetupMode() {return m_dwSetupMode;}
    STDMETHODIMP_(DWORD)GetProductType() {return m_pData->ProductType;}
    STDMETHODIMP_(DWORD)GetOperationFlags() {return m_pData->OperationFlags;}
    STDMETHODIMP_(DWORD)GetUnattendedModeFlags() {return m_dwUnattendedMode;}
    STDMETHODIMP GetINetCfg(INetCfg ** ppINetCfg);

    VOID ChangeSetupMode(DWORD dw) {m_dwSetupMode = dw;}
    VOID SetUnattendedMode(DWORD dw) {m_dwUnattendedMode = dw;}
    VOID SetINetCfg(INetCfg * pINetCfg)
                            {
                                m_pINetCfg = pINetCfg;
                                AddRefObj(m_pINetCfg);
                            }
private:
    PINTERNAL_SETUP_DATA m_pData;
    DWORD                m_dwSetupMode;
    DWORD                m_dwUnattendedMode;
    ULONG                m_cRef;
    INetCfg *            m_pINetCfg;
};

//
// Class:   CWizProvider
//
// Purpose: Manage the wizard pages provided by a single connection provider.
//
class CWizProvider
{
public:
    NOTHROW static HRESULT  HrCreate(ProviderList *, CWizProvider **, BOOL fDeferred);
    ~CWizProvider();

    ULONG           ULPageCount()   {return m_ulPageCnt;}
    HPROPSHEETPAGE* PHPropPages()   {return m_rghPages;}

    NOTHROW HRESULT HrAddPages(INetConnectionWizardUiContext *);
    NOTHROW ULONG   UlGetMaxPageCount(INetConnectionWizardUiContext *);

    VOID            DeleteHPages();
    VOID            XFerDeleteResponsibilities() {m_fDeletePages = FALSE;}

    INetConnectionWizardUi* PWizardUi() {return m_pWizardUi;}

    UINT            GetBtnIdc() {return m_nBtnIdc;}

    HRESULT         HrSpecifyAdapterGuid(GUID *);
    HRESULT         HrGetLanInterface(INetLanConnectionWizardUi ** ppIntr);
    HRESULT         HrCompleteDeferredLoad();

private:
    CWizProvider(ProviderList *, BOOL);
    static BOOL FAddPropSheet(HPROPSHEETPAGE, LPARAM);

private:
    ULONG                   m_ulPageCnt;
    ULONG                   m_ulPageBufferLen;
    ULONG                   m_ulMaxPageCount;
    HPROPSHEETPAGE*         m_rghPages;

    BOOL                    m_fDeletePages;
    BOOL                    m_fDeferLoad;

    INetConnectionWizardUi* m_pWizardUi;

    GUID                    m_guidUiObject;

    UINT                    m_nBtnIdc;
};

// The wizard processes adapters, the list of adapters to process is
// maintained by the wizard.  The adapter list will contain adapters
// which have been processed as well as adapters to be processed.
// the AdapterEntry structure refers to a single adapter
//
typedef struct _tagAdapterEntry
{
    GUID guidAdapter;
    BOOL fProcessed;    // TRUE if a connection has been generated
                        // for this adapter
    BOOL fNew;          // TRUE if the adapter is being configured
                        // for the first time.
    BOOL fVirtual;
    BOOL fHide;         // True if the adapter should not
                        // be displayed to the user
} AdapterEntry;

class CAdapterList
{
public:
    CAdapterList();
    ~CAdapterList() {EmptyList();}

    VOID             EmptyList();
    VOID             HideAllAdapters();
    VOID             UnhideNewAdapters();
    BOOL             FAdaptersInstalled()   {return m_fAdaptersInstalled;}
    HRESULT          HrAppendEntries(AdapterEntry * pae, ULONG cae);
    HRESULT          HrCreateTypicalConnections(CWizard * pWizard);
    HRESULT          HrQueryUnboundAdapters(CWizard * pWizard);
    static HRESULT   HrQueryLanAdapters(INetCfg * pnc, CAdapterList * pAL);

    AdapterEntry *   PAE_Next();
    AdapterEntry *   PAE_Prev();
    AdapterEntry *   PAE_Current();

    GUID *           NextAdapter();
    GUID *           PrevAdapter();
    GUID *           CurrentAdapter();

private:
    AdapterEntry * m_prgAdapters;
    LONG           m_clAdapters;            // Count of adapters in the array
    LONG           m_lBufSize;              // Total available slots in the array
    LONG           m_lIdx;                  // Current adapter index (or -1)
    BOOL           m_fAdaptersInstalled;    // Adapters exist on the machine
                                            // regardless of whether any need
                                            // to be processed.
};

typedef enum {NWPD_FORWARD, NWPD_BACKWARD} PAGEDIRECTION;

//
// Class:   CWizard
//
// Purpose: Manage the wizard pages provided by all connection providers.
//
class CWizard
{
private:
    typedef struct _tagPageData
    {
        LPARAM              ulId;
        HPROPSHEETPAGE      hPage;
        LPARAM              lParam;
        PAGEDIRECTION       PageDirection;
        UINT                PageOrigin;
        UINT                PageOriginIDC;
        PFNPAGECLEANPROC    pfn;
    } PageData;

public:
    NOTHROW static HRESULT HrCreate(CWizard **, BOOL, PINTERNAL_SETUP_DATA, BOOL);
    ~CWizard();

    ULONG            UlProviderCount() {return m_ulWizProviderCnt;}
    CWizProvider *   PWizProviders(ULONG ulIdx)
                            {return ((ulIdx >= m_ulWizProviderCnt) ?
                                     NULL : m_rgpWizProviders[ulIdx]);}

    VOID             SetCurrentProvider(ULONG ulIdx);
    CWizProvider *   GetCurrentProvider();
    CWizProvider *   GetProviderN(ULONG ulIdx);

    BOOL             FProviderChanged() {return m_fProviderChanged;}
    VOID             ClearProviderChanged() { m_fProviderChanged = FALSE; }

    CWizardUiContext * GetUiContext() {return m_pUiContext;}

    VOID             CacheConnection(INetConnection * pConn);
    INetConnection * GetCachedConnection() {return m_pConn;}

    VOID             LoadWizProviders(ULONG, ProviderList *);
    HRESULT          HrCreateWizProviderPages(BOOL, UINT *);
    VOID             AppendProviderPages(HPROPSHEETPAGE *pahpsp, UINT *pcPages);

    HPROPSHEETPAGE   GetPageHandle(LPARAM ulId);
    LPARAM           GetPageData(LPARAM ulId);
    VOID             SetPageData(LPARAM ulId, LPARAM lParam);

    LPARAM           GetPageOrigin(LPARAM ulId, UINT *pOriginIDC);
    VOID             SetPageOrigin(LPARAM ulId, UINT uiOrigin, UINT uiOriginIDC);

    UINT             GetPageIndexFromIID(LPARAM ulId);
    UINT             GetPageIndexFromHPage(HPROPSHEETPAGE hPage);

    PAGEDIRECTION    GetPageDirection(LPARAM ulId);
    VOID             SetPageDirection(LPARAM ulId, PAGEDIRECTION PageDirection);
    VOID             RegisterPage(LPARAM, HPROPSHEETPAGE,
                                 PFNPAGECLEANPROC, LPARAM);

    VOID             DisableUnattended() {m_dwOperationFlags &= ~SETUPOPER_BATCH;}
    DWORD            OperationFlags() {return m_dwOperationFlags;}
    PINTERNAL_SETUP_DATA PSetupData() {return m_pSetupData;}
    VOID             ChangeSetupMode(DWORD dw)
                                {AssertH(m_pUiContext);
                                 m_pUiContext->ChangeSetupMode(dw);}

    VOID             SetUnattendedMode(UM_MODE UMMode) {m_UMMode = UMMode;
                                                        AssertH(m_pUiContext);
                                                        m_pUiContext->SetUnattendedMode(UMMode);}
    UM_MODE          GetUnattendedMode()               {return m_UMMode;}

    INetCfg *        PNetCfg() {return m_pNetCfg;}
    VOID             SetNetCfg(INetCfg *p);

    VOID             SetExitNoReturn()   {m_fExitNoReturn = TRUE;}
    BOOL             FExitNoReturn()     {return m_fExitNoReturn;}

    VOID             SetCoUninit(BOOL f) {m_fCoUninit = f;}
    BOOL             FCoUninit()         {return m_fCoUninit;}

    BOOL             FDeferredProviderLoad() {return m_fDeferredProviderLoad;}
    DWORD            GetFirstPage()                     {return m_dwFirstPage;}
    VOID             SetFirstPage(DWORD dwFirstPage)    {m_dwFirstPage = dwFirstPage;}

    BOOL             FProcessLanPages()  {return m_fLanPages;}

    CAdapterList *   PAdapterQueue()     {return &m_Adapters;}

    VOID             LoadAndInsertDeferredProviderPages(HWND, UINT);

    // Should this be a NetConfig wide available function?

    inline BOOL CompareCLSID (const CLSID& x, const CLSID& y)
    {
        return( (x.Data1 == y.Data1) && 
                (x.Data2 == y.Data2) &&
                (x.Data3 == y.Data3) &&
                ! (memcmp(x.Data4 , y.Data4, sizeof(x.Data4))));
    }

private:
    CWizard(BOOL, PINTERNAL_SETUP_DATA pData, BOOL);
    NOTHROW HRESULT  HrAddProvider(ProviderList *);
    VOID             DeferredLoadComplete() {m_fDeferredProviderLoad = FALSE;}

private:
    enum {m_eMaxProviders=6};   // Represents both max providers and the
                                // max # of guard pages we'll need
    enum {m_eMaxInternalPages=MAX_NET_PAGES};

    BOOL                    m_fLanPages;
    BOOL                    m_fExitNoReturn;
    BOOL                    m_fCoUninit;
    BOOL                    m_fDeferredProviderLoad;
    BOOL                    m_fProviderChanged;
    DWORD                   m_dwFirstPage;

    INetCfg *               m_pNetCfg;
    CWizardUiContext *      m_pUiContext;

    INetConnection *        m_pConn;

    PINTERNAL_SETUP_DATA    m_pSetupData;
    DWORD                   m_dwOperationFlags;
    UM_MODE                 m_UMMode;

    ULONG                   m_ulCurProvider;
    ULONG                   m_ulWizProviderCnt;
    CWizProvider *          m_rgpWizProviders[m_eMaxProviders];

    ULONG                   m_ulPageDataCnt;
    ULONG                   m_ulPageDataMRU;
    PageData                m_rgPageData[m_eMaxInternalPages + m_eMaxProviders];

public:
    // This is exposed by PAdapterQueue, so there is no use pretending its
    // private.
    //
    CAdapterList            m_Adapters;
};


struct InitThreadParam
{
    HWND        hwndDlg;
    CWizard*    pWizard;
};

struct UpgradeData
{
    BOOL     fProcessed;
    HFONT    hBoldFont;
    UINT     nCurrentCap;
};


                //**********************//
                //**********************//
                //   Inline Functions   //
                //**********************//
                //**********************//

inline VOID CWizard::CacheConnection(INetConnection * pConn)
{
    ReleaseObj(m_pConn);
    m_pConn = pConn;
}

inline VOID CWizard::SetNetCfg(INetCfg *p)
{
    AssertH(NULL == m_pNetCfg);
    AssertH(NULL != p);
    m_pNetCfg = p;
    if (m_pUiContext)
    {
        m_pUiContext->SetINetCfg(m_pNetCfg);
    }
}

inline VOID CWizard::SetCurrentProvider(ULONG ulIdx)
{
    AssertH(ulIdx < m_ulWizProviderCnt);

    if (m_ulCurProvider != ulIdx)
    {
        m_fProviderChanged  = TRUE;
    }

    m_ulCurProvider = ulIdx;
}

inline CWizProvider * CWizard::GetCurrentProvider()
{
    AssertH(m_ulCurProvider < m_ulWizProviderCnt);
    return m_rgpWizProviders[m_ulCurProvider];
}

inline CWizProvider * CWizard::GetProviderN(ULONG ulIdx)
{
    AssertH(ulIdx < m_ulWizProviderCnt);
    return m_rgpWizProviders[ulIdx];
}

inline BOOL IsPostInstall(CWizard *pWizard)
{
    AssertH(NULL != pWizard);
    return (pWizard->OperationFlags() & SETUPOPER_POSTSYSINSTALL);
}

inline BOOL IsUnattended(CWizard *pWizard)
{
    AssertH(NULL != pWizard);
    return (pWizard->OperationFlags() & SETUPOPER_BATCH);
}

inline BOOL IsFreshInstall(CWizard *pWizard)
{
    AssertH(NULL != pWizard);
    return (!(pWizard->OperationFlags() & (SETUPOPER_NTUPGRADE | SETUPOPER_POSTSYSINSTALL)));
}

inline BOOL IsUpgrade(CWizard *pWizard)
{
    AssertH(NULL != pWizard);
    return (pWizard->OperationFlags() & SETUPOPER_NTUPGRADE);
}

inline DWORD ProductType(CWizard *pWizard)
{
    AssertH(NULL != pWizard);
    AssertH(NULL != pWizard->PSetupData());
    return ((pWizard->PSetupData())->ProductType);
}

inline DWORD SetupMode(CWizard *pWizard)
{
    AssertH(NULL != pWizard);
    AssertH(NULL != pWizard->PSetupData());
    return ((pWizard->PSetupData())->SetupMode);
}


                //****************************//
                //****************************//
                // Page Specific Entry Points //
                //****************************//
                //****************************//

HRESULT HrCreateMainPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateConnectPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateAdvancedPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateISPPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateInternetPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateMainIntroPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateExitPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateFinishPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateJoinPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateUpgradePage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateWelcomePage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
HRESULT HrCreateNetDevPage(CWizard *, PINTERNAL_SETUP_DATA, BOOL, UINT *);
NOTHROW HRESULT HrCreateGuardPage(CWizard *, CWizProvider *);

VOID    AppendMainPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendConnectPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendAdvancedPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendISPPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendInternetPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendMainIntroPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendExitPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendFinishPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendJoinPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendUpgradePage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendWelcomePage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendNetDevPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages);
VOID    AppendGuardPage(CWizard *pWizard, CWizProvider *pWizProvider,
                        HPROPSHEETPAGE* pahpsp, UINT *pcPages);

                //********************************//
                //********************************//
                // Common Wizard Related Routines //
                //********************************//
                //********************************//

EXTERN_C HRESULT WINAPI HrRunWizard(HWND hwnd, BOOL fPnpAddAdapter, INetConnection ** ppConn, DWORD dwFirstPage);
EXTERN_C INT WINAPI StartNCW( HWND hwndOwner, HINSTANCE hInstance, PTSTR pszParms, INT nShow );

VOID    NetDevRetrieveInfo(CWizard * pWizard);
VOID    GenerateUniqueConnectionName(REFGUID guidAdapter, tstring * pstr, CWizProvider *   pWizProvider);
void    JoinDefaultWorkgroup(CWizard *pWizard, HWND hwndDlg);
BOOL    OnProcessNextAdapterPageNext(HWND hwndDlg, BOOL FOnActivate);
BOOL    OnProcessPrevAdapterPagePrev(HWND hwndDlg, UINT idd);
HRESULT HrInitAndGetINetCfg(CWizard *pWizard);
HRESULT HrCommitINetCfgChanges(HWND hwnd, CWizard * pWizard);
BOOL    IsSBS (VOID);
BOOL    IsMSClientInstalled(HWND hwnd, CWizard * pWizard);
DNS_STATUS IsValidDomainName (HWND hwndDlg);
HRESULT HrCreateTypicalConnections(CWizard * pWizard);
VOID    InstallDefaultNetworkingIfNeeded(CWizard * pWizard, DWORD dwInstallFlags);
VOID    SetupFonts(HWND hwnd, HFONT * pBoldFont, BOOL fLargeFont);
VOID    CenterWizard(HWND hwndDlg);
VOID    ReadAnswerFileSetupOptions(CWizard * pWizard);


const UINT c_nMaxProgressRange = 100;

VOID
OnUpgradeUpdateProgressCap (
    HWND hwndDlg,
    CWizard* pWizard,
    UINT nNewCap);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wjoin.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ntsam.h>
#include <lmerr.h>
#include <wincred.h>
#include "afilexp.h"
#include "dsgetdc.h"
#include "ncatlui.h"
#include "nccom.h"
#include "nceh.h"
#include "ncerror.h"
#include "ncident.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "ncui.h"
#include "resource.h"
#include "wizard.h"
#include "nslog.h"
#include "windns.h"

// header filename clash between config\inc\netsetup.h and
// private\net\inc\netsetup.h where this prototype lives.
// fix later.
//
EXTERN_C
NET_API_STATUS
NET_API_FUNCTION
NetpUpgradePreNT5JoinInfo( VOID );

// Setup Wizard Global - Only used during setup.
extern CWizard * g_pSetupWizard;

//
// NOTE: Set breakpoints in JoinDomainWorkThrd if debugging join problems
//

static const UINT PWM_JOINFAILURE    = WM_USER+1201;
static const UINT PWM_JOINSUCCESS    = WM_USER+1202;

static const INT MAX_USERNAME_LENGTH = UNLEN;

// the number of bytes in a full DNS name to reserve for stuff
// netlogon pre-/appends to DNS names when registering them
static const INT SRV_RECORD_RESERVE = 100;
static const INT MAX_DOMAINNAME_LENGTH = DNS_MAX_NAME_LENGTH - SRV_RECORD_RESERVE;
static const INT MAX_WORKGROUPNAME_LENGTH = 15;

static const INT MAX_TITLEBASE = 128;
static const INT MAX_TITLENEW = 256;
static const INT MAX_NAME_LENGTH = max( max( max( SAM_MAX_PASSWORD_LENGTH,
                                               MAX_USERNAME_LENGTH ),
                                          MAX_COMPUTERNAME_LENGTH ),
                                     MAX_DOMAINNAME_LENGTH) + 1;

const int nrgIdc[] = {EDT_WORKGROUPJOIN_NAME, EDT_DOMAINJOIN_NAME, BTN_JOIN_WORKGROUP, BTN_JOIN_DOMAIN, TXT_JOIN_WORKGROUP_LINE2};

const int nrgIdcWorkgroup[] = {EDT_WORKGROUPJOIN_NAME};
const int nrgIdcDomain[]    = {EDT_DOMAINJOIN_NAME};
const c_dwDomainJoinWaitDelay = 10000;

static const WCHAR c_szNetMsg[] = L"netmsg.dll";
static const WCHAR c_szIpParameters[] = L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";
static const WCHAR c_szSyncDomainWithMembership[] = L"SyncDomainWithMembership";
static const WCHAR c_szWinlogonPath[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon";
static const WCHAR c_szRunNetAccessWizard[] = L"RunNetAccessWizard";
static const WCHAR c_szAfSectionGuiUnattended[] = L"GuiUnattended";
static const WCHAR c_szAfAutoLogonAccountCreation[] = L"AutoLogonAccountCreation";

extern const WCHAR c_szAfSectionIdentification[]; // L"Identification";
extern const WCHAR c_szAfComputerName[];          // L"ComputerName";
extern const WCHAR c_szAfJoinWorkgroup[];         // L"JoinWorkgroup";
extern const WCHAR c_szAfJoinDomain[];            // L"JoinDomain";
extern const WCHAR c_szAfDomainAdmin[];           // L"DomainAdmin";
extern const WCHAR c_szAfDomainAdminPassword[];   // L"DomainAdminPassword";
extern const WCHAR c_szAfSectionNetworking[];     // L"Networking";
extern const WCHAR c_szAfUpgradeFromProduct[];    // L"UpgradeFromProduct";
extern const WCHAR c_szAfWin95[];                 // L"Windows95";
extern const WCHAR c_szSvcWorkstation[];          // L"LanmanWorkstation";
extern const WCHAR c_szAfMachineObjectOU[];       // L"MachineObjectOU";
extern const WCHAR c_szAfUnsecureJoin[];          // L"DoOldStyleDomainJoin";
extern const WCHAR c_szAfBuildNumber[];           // L"BuildNumber";
// For Secure Domain Join Support, the computer account password
extern const WCHAR c_szAfComputerPassword[];       // L"ComputerPassword";

typedef struct _tagJoinData
{
    BOOL                    fUpgraded;
    BOOL                    fUnattendedFailed;
    CNetCfgIdentification * pIdent;
    HCURSOR                 hClassCursor;
    HCURSOR                 hOldCursor;

    // Used by join thread
    //
    HWND                    hwndDlg;

    // Set from answer file or user input then supplied to the join thread
    // as the join parameters
    //
    DWORD                   dwJoinFlag;
    WCHAR                   szUserName[MAX_USERNAME_LENGTH + 1];
    WCHAR                   szPassword[SAM_MAX_PASSWORD_LENGTH + 1];
    WCHAR                   szDomain[MAX_DOMAINNAME_LENGTH + 1];
    WCHAR                   szComputerPassword[SAM_MAX_PASSWORD_LENGTH + 1];
    WCHAR                 * pszMachineObjectOU;
} JoinData;

typedef enum
{
    PSW_JOINEDDOMAIN = 2,
    PSW_JOINFAILED = 3
} POSTSETUP_STATE;

//
// Function:    IsRunningOnPersonal
//
// Purpose:     Determines whether running on Whistler Personal
//
// Returns:     Returns true if running on Personal - FALSE otherwise
BOOL
IsRunningOnPersonal(
    VOID
    )
{
    TraceFileFunc(ttidGuiModeSetup);

    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    return VerifyVersionInfo(&OsVer,
        VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask
        );
}

//
// Function:    IsValidDomainName
//
// Purpose:     Determines whether the domain name is valid.
//
// Returns:     See win32 documentation on DnsValidateName.
//
// Author:      Alok Sinha
//

DNS_STATUS IsValidDomainName (HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    WCHAR szDomain[MAX_DOMAINNAME_LENGTH+1];
    HWND hwndEdit;

    hwndEdit = GetDlgItem(hwndDlg, EDT_DOMAINJOIN_NAME);
    Assert(0 != GetWindowTextLength(hwndEdit));

    GetWindowText(hwndEdit, szDomain, MAX_DOMAINNAME_LENGTH + 1);

    return DnsValidateName( szDomain,
                            DnsNameDomain );
}

//
// Function:    SetCursorToHourglass
//
// Purpose:     Changes the cursor to hourglass.
//
// Returns:     Nothing
//
// Author:      asinha 3/28/2001
//

VOID SetCursorToHourglass (HWND hwndDlg, JoinData *pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert( pData != NULL);

    if ( pData )
    {
        pData->hClassCursor = (HCURSOR)GetClassLongPtr( hwndDlg, GCLP_HCURSOR );
        SetClassLongPtr( hwndDlg, GCLP_HCURSOR, (LONG_PTR)NULL );
        pData->hOldCursor = SetCursor( LoadCursor(NULL,IDC_WAIT) );

        SetCapture( hwndDlg );
    }

    return;
}

//
// Function:    RestoreCursor
//
// Purpose:     Changes the cursor back to its orginal state.
//
// Returns:     Nothing
//
// Author:      asinha 3/28/2001
//

VOID RestoreCursor (HWND hwndDlg, JoinData *pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert( pData != NULL);

    if ( pData )
    {
        if ( pData->hClassCursor )
        {
            SetClassLongPtr( hwndDlg, GCLP_HCURSOR, (LONG_PTR)pData->hClassCursor );
            pData->hClassCursor = NULL;
        }

        if ( pData->hOldCursor )
        {
            SetCursor( pData->hOldCursor );
            pData->hOldCursor = NULL;
        }

        ReleaseCapture();
    }

    return;
}

//
// Function:    NotifyPostSetupWizard
//
// Purpose:     Subclass the edit control so we can enable/disable the
//              Next button as the content of the name edit control changes
//
// Parameters:  State - Final Join State
//
// Returns:     nothing
//
VOID NotifyPostSetupWizard(POSTSETUP_STATE State, CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    HKEY hkey;
    HRESULT hr = S_OK;
    BOOL fRunNaWizard = TRUE;
    CSetupInfFile csif;

    // If this is an upgrade or an unattended install, or it's a server do nothing
    //
    if (IsUpgrade(pWizard) || IsUnattended(pWizard) || (PRODUCT_WORKSTATION != ProductType(pWizard)) )
    {
        fRunNaWizard = FALSE;
    }

    // Is there an unattended flag to override default behavior?
    if (IsUnattended(pWizard))
    {
        hr = csif.HrOpen(pWizard->PSetupData()->UnattendFile,
                         NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (SUCCEEDED(hr))
        {
            BOOL fValue = FALSE;
            hr = csif.HrGetStringAsBool(c_szAfSectionGuiUnattended,
                                        c_szAfAutoLogonAccountCreation,
                                        &fValue);
            if (SUCCEEDED(hr) && fValue)
            {
                fRunNaWizard = fValue;
            }
        }

        hr = S_OK;
    }

    if (fRunNaWizard)
    {
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWinlogonPath,
                            KEY_WRITE, &hkey);
        if (SUCCEEDED(hr))
        {
            hr = HrRegSetDword (hkey, c_szRunNetAccessWizard, (DWORD)State);
            TraceTag(ttidWizard, "NotifyPostSetupWizard - State = %d",(DWORD)State);

            RegCloseKey(hkey);
        }
    }

    TraceError("WJOIN.CPP - NotifyPostSetupWizard",hr);
}

//
// Function:    JoinEditSubclassProc
//
// Purpose:     Subclass the edit control so we can enable/disable the
//              Next button as the content of the name edit control changes
//
// Parameters:  std for a window proc
//
// Returns:     std for a window proc
//
STDAPI JoinEditSubclassProc(HWND hwnd, UINT wMsg,
                            WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);

    LONG      lReturn;
    HWND      hwndDlg   = GetParent(hwnd);

    lReturn = CallWindowProc((WNDPROC)::GetWindowLongPtr(hwnd, GWLP_USERDATA),
                             hwnd, wMsg, wParam, lParam);

    // If we processing a character send the message through the regular proc
    if (WM_CHAR == wMsg)
    {
        CWizard * pWizard   =
            reinterpret_cast<CWizard *> (::GetWindowLongPtr(hwndDlg, DWLP_USER));

        Assert(NULL != pWizard);

        if ( !pWizard )
        {
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
            return lReturn;
        }

        JoinData * pData = reinterpret_cast<JoinData *>
                                (pWizard->GetPageData(IDD_Join));
        Assert(NULL != pData);

        if ( !pData ) {
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
            return lReturn;
        }

        if (!IsUnattended(pWizard) ||
            (IsUnattended(pWizard) && pData->fUnattendedFailed))
        {
            if (0 == GetWindowTextLength(hwnd))
            {
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
            }
            else
            {
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
            }
        }
    }

    return lReturn;
}

HRESULT HrGetIdentInterface(CNetCfgIdentification ** ppIdent)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;

    *ppIdent = new CNetCfgIdentification;
    if (NULL == *ppIdent)
        hr = E_OUTOFMEMORY;

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrGetIdentInterface");
    return hr;
}

//
// Function:    IdsFromIdentError
//
// Purpose:     Map a error code into a display string.
//
// Parameters:  hr [IN] - Error code to map
//
// Returns:     INT, the string ID of the corresponding error message
//
INT IdsFromIdentError(HRESULT hr, BOOL fWorkgroup)
{
    TraceFileFunc(ttidGuiModeSetup);

    INT     ids = -1;

    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_NO_TRUST_SAM_ACCOUNT):
        ids = IDS_DOMMGR_CANT_CONNECT_DC_PW;
        break;

    case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
    case HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN):
        ids = IDS_DOMMGR_CANT_FIND_DC1;
        break;

    case HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
        ids = IDS_DOMMGR_INVALID_PASSWORD;
        break;

    case HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE):
        ids = IDS_DOMMGR_NETWORK_UNREACHABLE;
        break;

    case HRESULT_FROM_WIN32(ERROR_ACCOUNT_DISABLED):
    case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):
    case HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
        ids = IDS_DOMMGR_ACCESS_DENIED;
        break;

    case HRESULT_FROM_WIN32(ERROR_SESSION_CREDENTIAL_CONFLICT):
        ids = IDS_DOMMGR_CREDENTIAL_CONFLICT;
        break;

    case NETCFG_E_ALREADY_JOINED:
        ids = IDS_DOMMGR_ALREADY_JOINED;
        break;

    case NETCFG_E_NAME_IN_USE:
        ids = IDS_DOMMGR_NAME_IN_USE;
        break;

    case NETCFG_E_NOT_JOINED:
        ids = IDS_DOMMGR_NOT_JOINED;
        break;

    case NETCFG_E_INVALID_DOMAIN:
    case HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
        if (fWorkgroup)
            ids = IDS_DOMMGR_INVALID_WORKGROUP;
        else
            ids = IDS_DOMMGR_INVALID_DOMAIN;
        break;


    default:
        ids = IDS_E_UNEXPECTED;
        break;
    }

    return ids;
}

//
// Function:    SzFromError
//
// Purpose:     Convert an error code into a message displayable to the user.
//              The error message could come from our resources, or from netmsg.dll
//
// Parameters:  hr         [IN] - The error to map
//              fWorkgroup [IN] - Flag to provide "workgroup" flavored error
//                                messages for some cases.
//
// Returns:     PCWSTR, Pointer to a static buffer containing the error message
//
PCWSTR SzFromError(HRESULT hr, BOOL fWorkgroup)
{
    TraceFileFunc(ttidGuiModeSetup);

    static WCHAR szErrorMsg[1024];
    INT nIds = IdsFromIdentError(hr, fWorkgroup);

    // If the error string returned is unexpected, it means we couldn't
    // a local match for the string.  Search netmsg.dll if the errors'
    // range is correct
    if (IDS_E_UNEXPECTED == nIds)
    {
        // Extract the error code from the HRESULT
        DWORD dwErr = ((DWORD)hr & 0x0000FFFF);
        if ((NERR_BASE <= dwErr) && (MAX_NERR >= dwErr))
        {
            // The error is within the range hosted by netmsg.dll
            HMODULE hModule = LoadLibraryEx(c_szNetMsg, NULL,
                                            LOAD_LIBRARY_AS_DATAFILE);
            if (NULL != hModule)
            {
                // Try to locate the error string
                DWORD dwRet = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_IGNORE_INSERTS,
                                (LPVOID)hModule,
                                dwErr,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                szErrorMsg,           // Output buffer
                                1024, // szErrorMsg in characters.
                                NULL);

                FreeLibrary(hModule);

                if (dwRet)
                {
                    // We successfully found an error message
                    // Remove the trailing newline that format message adds
                    // This string is concatenated with another and the newline
                    // messes up the appearance.
                    //
                    // Raid 146173 - scottbri
                    //
                    int nLen = wcslen(szErrorMsg);
                    if ((nLen>2) && (L'\r' == szErrorMsg[nLen-2]))
                    {
                        szErrorMsg[nLen-2] = 0;
                    }
                    return szErrorMsg;
                }
            }
        }
        else if ( (dwErr >= 9000) && (dwErr <= 9999) )
        {
            // The error code from 9000-9999 is dns error code in which
            // case show the dns error message.
            //
            DWORD dwRet = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                            (LPVOID)NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            szErrorMsg,           // Output buffer
                            1024, // szErrorMsg in characters.
                            NULL);
            if (dwRet)
            {
                // We successfully found an error message
                // Remove the trailing newline that format message adds

                int nLen = wcslen(szErrorMsg);
                if ((nLen>2) && (L'\r' == szErrorMsg[nLen-2]))
                {
                    szErrorMsg[nLen-2] = 0;
                }
                return szErrorMsg;
            }
        }
    }

    // Load the error found
    wcscpy(szErrorMsg, SzLoadIds(nIds));
    return szErrorMsg;
}


//
// Function:    GetJoinNameIIDFromSelection
//
// Purpose:     Get the edit box for the workgroup / domain dialog depending on the current user selection
//
// Parameters:  hwndDlg - The join domain dialog
//
// Returns:
//
inline DWORD GetJoinNameIIDFromSelection(HWND hwndDlg)
{
    if (IsDlgButtonChecked(hwndDlg, BTN_JOIN_WORKGROUP))
    {
        return EDT_WORKGROUPJOIN_NAME;
    }
    else
    {
        return EDT_DOMAINJOIN_NAME;
    }
}

//
// Function:    UpdateNextBackBttns
//
// Purpose:
//
// Parameters:
//
// Returns:
//
VOID UpdateNextBackBttns(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    int b = PSWIZB_BACK;
    if (0 != GetWindowTextLength(GetDlgItem(hwndDlg, GetJoinNameIIDFromSelection(hwndDlg))))
    {
        b |= PSWIZB_NEXT;
    }

    PropSheet_SetWizButtons(GetParent(hwndDlg), b);
}

//
// Function:    EnableAndDisableWorkGroupDomainControls
//
// Purpose:     Disable the domain/workgroup edit boxes depending on the current user selection
//
// Parameters:  hwndDlg - The join domain dialog
//
// Returns:
//
VOID EnableAndDisableWorkGroupDomainControls(HWND hwndDlg)
{
    if (IsDlgButtonChecked(hwndDlg, BTN_JOIN_WORKGROUP))
    {
        EnableOrDisableDialogControls(hwndDlg, celems(nrgIdcWorkgroup), nrgIdcWorkgroup, TRUE);
        EnableOrDisableDialogControls(hwndDlg, celems(nrgIdcDomain), nrgIdcDomain, FALSE);
    }
    else
    {
        EnableOrDisableDialogControls(hwndDlg, celems(nrgIdcDomain), nrgIdcDomain, TRUE);
        EnableOrDisableDialogControls(hwndDlg, celems(nrgIdcWorkgroup), nrgIdcWorkgroup, FALSE);
    }
}

//
// Function:    JoinUpdatePromptText
//
// Purpose:     Update the prompt text
//
// Parameters:  hwndDlg [IN] - Current dialog handle
//
// Returns:     Nothing
//
VOID JoinUpdatePromptText(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    HWND  hwndDomain = NULL;
    int   idsNew     = IDS_WORKGROUP;
    int   idsOld     = IDS_DOMAIN;
    WCHAR szDomain[MAX_DOMAINNAME_LENGTH + 1];
    JoinData * pData=NULL;
    CWizard * pWizard = NULL;

    // Based on the button selected, update the Prompt text & dialog box
    if (!IsDlgButtonChecked(hwndDlg, BTN_JOIN_WORKGROUP))
    {
        hwndDomain = GetDlgItem(hwndDlg, EDT_DOMAINJOIN_NAME);
        idsNew    = IDS_DOMAIN;
        idsOld    = IDS_WORKGROUP;
    }
    else
    {
        hwndDomain = GetDlgItem(hwndDlg, EDT_WORKGROUPJOIN_NAME);
    }
    Assert(NULL != hwndDomain);

    EnableAndDisableWorkGroupDomainControls(hwndDlg);

    // Update the domain/workgroup only if the current contents
    // are the default workgroup/domain
    GetWindowText(hwndDomain, szDomain, celems(szDomain));
    if (0 == lstrcmpW(szDomain, SzLoadIds(idsOld)))
    {
        SetWindowText(hwndDomain, SzLoadIds(idsNew));
    }

    // Update the back/next buttons based on the selected button. See bug 355978

    pWizard = (CWizard *) ::GetWindowLongPtr(hwndDlg, DWLP_USER);
    Assert(NULL != pWizard);
    if ( pWizard)
    {
        pData = (JoinData *) pWizard->GetPageData(IDD_Join);
        Assert(NULL != pData);
    }

    if ( pWizard && pData )
    {
        if (!IsUnattended(pWizard) ||
            (IsUnattended(pWizard) && pData->fUnattendedFailed))
        {
            if (0 == GetWindowTextLengthW(hwndDomain))
            {
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK);
            }
            else
            {
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
            }
        }
    }
}

//
// Function:    UpdateJoinUsingComputerRole
//
// Purpose:
//
// Parameters:
//
// Returns:
//
VOID UpdateJoinUsingComputerRole(HWND      hwndDlg,
                                 CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT    hr;
    INetCfg *  pNetCfg = pWizard->PNetCfg();
    JoinData * pData   = reinterpret_cast<JoinData *>
                               (pWizard->GetPageData(IDD_Join));
    Assert(NULL != pNetCfg);
    Assert(NULL != pData);
    Assert(NULL != pData->pIdent);

    PWSTR pszwText = NULL;
    DWORD  computer_role;
    int    nIdc;

    Assert(NULL != pData->pIdent);

    if(!pData || !pData->pIdent)
    {
        return;
    }

    hr = pData->pIdent->GetComputerRole(&computer_role);
    if (SUCCEEDED(hr))
    {
        if (computer_role & GCR_STANDALONE)
        {
            // Get the workgroup name
            hr = pData->pIdent->GetWorkgroupName(&pszwText);
            Assert(NULL != pszwText);
            Assert(lstrlenW(pszwText) <= MAX_WORKGROUPNAME_LENGTH);
            nIdc = BTN_JOIN_WORKGROUP;
        }
        else
        {
            // Get the domain name
            hr = pData->pIdent->GetDomainName(&pszwText);
            Assert(NULL != pszwText);
            Assert(lstrlenW(pszwText) <= MAX_DOMAINNAME_LENGTH);
            nIdc = BTN_JOIN_DOMAIN;
        }
    }

    if (SUCCEEDED(hr))
    {
        HWND hwndEdit = GetDlgItem(hwndDlg, nIdc == BTN_JOIN_DOMAIN ?  EDT_DOMAINJOIN_NAME : EDT_WORKGROUPJOIN_NAME);
        Assert(NULL != hwndEdit);

        SetWindowText(hwndEdit, pszwText);
        CoTaskMemFree(pszwText);

        CheckRadioButton(hwndDlg, BTN_JOIN_WORKGROUP,
                         BTN_JOIN_DOMAIN, nIdc);
    }
    else
    {
        HWND hwndEdit = GetDlgItem(hwndDlg, EDT_WORKGROUPJOIN_NAME);
        Assert(NULL != hwndEdit);

        SetWindowText(hwndEdit, SzLoadIds(IDS_WORKGROUP));
        CheckRadioButton(hwndDlg, BTN_JOIN_WORKGROUP,
                         BTN_JOIN_DOMAIN, BTN_JOIN_WORKGROUP);
        TraceHr(ttidWizard, FAL, hr, FALSE,
                "UpdateJoinUsingComputerRole - Unable to determine role, using default");
    }

    JoinUpdatePromptText(hwndDlg);
}

//
// Function:    JoinDefaultWorkgroup
//
// Purpose:     Join the machine to the workgroup "WORKGROUP"
//
// Parameters:  pWizard [IN] - Ptr to a wizard instance, containing
//                             hopefully a INetCfg instance pointer
//              hwndDlg [IN] - HWND to parent error dialogs against
//
// Returns:     nothing
//
void JoinDefaultWorkgroup(CWizard *pWizard, HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    // Join default workgroup.
    CNetCfgIdentification *pINetid = NULL;
    HRESULT hr = S_OK;

    hr = HrGetIdentInterface(&pINetid);
    if (S_OK == hr)
    {
        if (IsRunningOnPersonal())
        {
            hr = pINetid->JoinWorkgroup(SzLoadIds(IDS_WORKGROUP_PERSONAL));
        }
        else
        {
            hr = pINetid->JoinWorkgroup(SzLoadIds(IDS_WORKGROUP));
        }

        if (SUCCEEDED(hr))
        {
            hr = pINetid->Validate();
            if (SUCCEEDED(hr))
            {
                hr = pINetid->Apply();
            }
        }
        if (FAILED(hr))
        {
            if (UM_FULLUNATTENDED == pWizard->GetUnattendedMode())
            {
                // Raid 380374: no UI allowed if in full unattended mode ..
                NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UNATTENDED_JOIN_DEFAULT_WROKGROUP));
            }
            else
            {
                MessageBox(GetParent(hwndDlg), SzFromError(hr, TRUE),
                           SzLoadIds(IDS_SETUP_CAPTION), MB_OK);
            }

            goto Done;
        }
    }
    else
    {
        AssertSz(0,"Cannot find the INegCfgIdentification interface!");
    }

Done:
    delete pINetid;
    TraceHr(ttidWizard, FAL, hr, FALSE, "JoinDefaultWorkgroup");
}

BOOL OnJoinSuccess(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    if ( !pWizard ) {
        return TRUE;
    }

    // Reset the Wait Cursor
    JoinData * pData = reinterpret_cast<JoinData *>
                            (pWizard->GetPageData(IDD_Join));
    Assert(NULL != pData);

    if ( !pData ) {
        return TRUE;
    }

    RestoreCursor( hwndDlg, pData );

    EnableOrDisableDialogControls(hwndDlg, celems(nrgIdc), nrgIdc, TRUE);
    EnableAndDisableWorkGroupDomainControls(hwndDlg);

    if (!(IsUnattended(pWizard) && pData->fUpgraded))
    {
        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
    }

    // Goto the Exit page
    pWizard->SetPageDirection(IDD_Join, NWPD_BACKWARD);
    HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Exit);
    PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                (LPARAM)(HPROPSHEETPAGE)hPage);

    return TRUE;
}

BOOL OnJoinFailure(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);

    JoinData * pData = NULL;
    BOOL fWorkgroup;
    tstring str;
    HRESULT    hr = (HRESULT)lParam;
    CWizard *  pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    if (pWizard)
    {

        pData   = reinterpret_cast<JoinData *>(pWizard->GetPageData(IDD_Join));
        Assert(NULL != pData);
    }

    fWorkgroup = !IsDlgButtonChecked(hwndDlg, BTN_JOIN_DOMAIN);

    if (fWorkgroup)
    {
        str = SzLoadIds(IDS_JOIN_E_WORKGROUP_MSG);
    }
    else
    {
        if (pData && (pData->dwJoinFlag & JDF_WIN9x_UPGRADE))
        {
            str =  SzLoadIds(IDS_JOIN_E_DOMAIN_WIN9X_MSG_1);
            str += SzLoadIds(IDS_JOIN_E_DOMAIN_WIN9X_MSG_2);
        }
        else
        {
            // Raid 372087: removed additional text
            str =  SzLoadIds(IDS_JOIN_E_DOMAIN_MSG);
        }
    }

    // If an error actually occurred, ask the user if they want to ignore
    // the error and proceed.  Note Unattended can succeed but require us
    // to stay on the page so this function is envoked to do this.
    if (FAILED(hr))
    {
        if (IDYES == NcMsgBox(GetParent(hwndDlg),
                             IDS_SETUP_CAPTION, IDS_JOIN_FAILURE,
                             MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2,
                             SzFromError(hr, fWorkgroup), str.c_str()))
        {
            // User choose to proceed in spite of the failure, go to the Exit page
            if (!fWorkgroup)
            {
                NotifyPostSetupWizard(PSW_JOINFAILED, pWizard);
            }

            OnJoinSuccess(hwndDlg);
            return TRUE;
        }
    }

    if (pData)
    {
        // Reset the Wait Cursor

        RestoreCursor( hwndDlg, pData );
    }

    // Make sure the page is visible.
    if (g_pSetupWizard != NULL)
    {
        g_pSetupWizard->PSetupData()->ShowHideWizardPage(TRUE);
    }

    // The user wants to stay and correct whatever's wrong
    EnableOrDisableDialogControls(hwndDlg, celems(nrgIdc), nrgIdc, TRUE);
    EnableAndDisableWorkGroupDomainControls(hwndDlg);

    UpdateNextBackBttns(hwndDlg);

    return TRUE;
}

// ONLY return failure if the workstation is installed and it doesn't start for 2 minutes
HRESULT HrWorkstationStart(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT         hr = S_OK;
    HRESULT         hrTmp;
    CServiceManager scm;

    TraceTag(ttidWizard, "Entering HrWorkstationStart...Checking for LanmanWorkstation presence");

    // Open the service control manager
    //
    hrTmp = scm.HrOpen();
    if (SUCCEEDED(hrTmp))
    {
        // Find the workstation service
        //
        SC_HANDLE hSvc = OpenService (scm.Handle(),
                            c_szSvcWorkstation,
                            SERVICE_QUERY_CONFIG |
                            SERVICE_QUERY_STATUS |
                            SERVICE_ENUMERATE_DEPENDENTS |
                            SERVICE_START | SERVICE_STOP |
                            SERVICE_USER_DEFINED_CONTROL);
        if (hSvc)
        {
            SERVICE_STATUS status;
            const UINT cmsWait  = 100;
            const UINT cmsTotal = 120000;    // 2 minutes
            UINT cLoop          = cmsTotal / cmsWait;

            // Check it's status, exit test once it's running
            //
            for (UINT nLoop = 0; nLoop < cLoop; nLoop++, Sleep (cmsWait))
            {
                BOOL fr = QueryServiceStatus (hSvc, &status);
                Assert(fr);

                if (SERVICE_RUNNING == status.dwCurrentState)
                {
                    break;
                }
            }

            if (SERVICE_RUNNING != status.dwCurrentState)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE);
#if DBG
                OutputDebugString (L"***ERROR*** NETCFG - Workstation service didn't start after more than 2 minutes!\n");
                OutputDebugString (L"***ERROR*** NETCFG - Join Domain will fail!\n");
#endif
            }

            CloseServiceHandle(hSvc);
        }

        scm.Close();
    }
    else
    {
        TraceError("WJOIN.CPP - HrWorkstationStart - Unable to open the Service Manager",hrTmp);
    }

    TraceError("WJOIN.CPP - HrWorkstationStart",hr);
    TraceTag(ttidWizard, "Leaving HrWorkstationStart");
    return hr;
}

// Purpose: Secure Domain Join with the new ComputerPassword Answer-File key.
// Domain Join tries to join the domain with the random precreated machine password.
// (the username is not required in this case)
// note: code path is inspired from HrAttemptJoin(JoinData * pData)

// functions defined in ncident.cpp
extern HRESULT HrNetValidateName(IN PCWSTR lpMachine,
                                 IN PCWSTR lpName,
                                 IN PCWSTR lpAccount,
                                 IN PCWSTR lpPassword,
                                 IN NETSETUP_NAME_TYPE  NameType);
extern HRESULT HrNetJoinDomain(IN PWSTR lpMachine,
                               IN PWSTR lpMachineObjectOU,
                               IN PWSTR lpDomain,
                               IN PWSTR lpAccount,
                               IN PWSTR lpPassword,
                               IN DWORD fJoinOptions);

EXTERN_C HRESULT HrAttemptSecureDomainJoin(JoinData * pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr;
    Assert(pData);

    // 1. wait for the start of LanmanWorkstation service
    // 2. check for valid domain
    // 3. secure join domain
     hr = HrWorkstationStart(pData->hwndDlg);
     if (SUCCEEDED(hr))
     {
        hr = HrNetValidateName(NULL, pData->szDomain , NULL, NULL, NetSetupDomain);

     }
     TraceHr(ttidWizard, FAL, hr, FALSE, "HrAttemptSecureDomainJoin - HrNetValidateName");

     if (SUCCEEDED(hr))
     {
        // do the secure join domain

        DWORD dwJoinOption = 0;

        dwJoinOption |= (NETSETUP_JOIN_DOMAIN | NETSETUP_JOIN_UNSECURE | NETSETUP_MACHINE_PWD_PASSED);
        if (FInSystemSetup())
        {
            // During system setup, need to pass special flag that tells join code
            // to not do certain operations because SAM is not initialized yet.
            dwJoinOption |= NETSETUP_INSTALL_INVOCATION;
        }
        hr = HrNetJoinDomain(NULL,pData->pszMachineObjectOU,
                             pData->szDomain, NULL, pData->szComputerPassword,
                             dwJoinOption);
        TraceHr(ttidWizard, FAL, hr, FALSE, "HrAttemptSecureDomainJoin - HrNetJoinDomain");

     }

    TraceError("HrAttemptSecureDomainJoin", hr);
    return hr;
}

EXTERN_C HRESULT HrAttemptJoin(JoinData * pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr;

    if (IsDlgButtonChecked(pData->hwndDlg, BTN_JOIN_DOMAIN))
    {
        hr = HrWorkstationStart(pData->hwndDlg);
        if (SUCCEEDED(hr))
        {
            hr = pData->pIdent->JoinDomain(pData->szDomain,
                                           pData->pszMachineObjectOU,
                                           pData->szUserName,
                                           pData->szPassword, pData->dwJoinFlag);
        }
        TraceHr(ttidWizard, FAL, hr, FALSE, "HrAttemptJoin - JoinDomain");
    }
    else
    {
        // Join a workgroup
        hr = pData->pIdent->JoinWorkgroup(pData->szDomain);
        TraceHr(ttidWizard, FAL, hr, FALSE, "HrAttemptJoin - JoinWorkgroup");
    }

    if (SUCCEEDED(hr))
    {
        if (S_OK == pData->pIdent->Validate())
        {
            hr = pData->pIdent->Apply();
            TraceHr(ttidWizard, FAL, hr, FALSE, "HrAttemptJoin - Apply");
        }
    }

    if (FAILED(hr))
    {
        // Rollback any changes
        pData->pIdent->Cancel();
    }

    TraceError("HrAttemptJoin",hr);
    return hr;
}

HRESULT HrAttemptJoin(JoinData * pData, DWORD dwRetries, DWORD dwDelayPeriod)
{
    HRESULT hr = E_FAIL;
    DWORD   dwCount = dwRetries;
    do
    {
        hr = HrAttemptJoin(pData);
        if (FAILED(hr))
        {
            dwCount--;
            Sleep(dwDelayPeriod);
        }
    } while (FAILED(hr) && (dwCount));
    return hr;
}

HRESULT HrAttemptSecureDomainJoin(JoinData * pData, DWORD dwRetries, DWORD dwDelayPeriod)
{
    HRESULT hr = E_FAIL;
    DWORD   dwCount = dwRetries;
    do
    {
        hr = HrAttemptSecureDomainJoin(pData);
        if (FAILED(hr))
        {
            dwCount--;
            Sleep(dwDelayPeriod);
        }
    } while (FAILED(hr) && (dwCount));
    return hr;
}

EXTERN_C DWORD JoinDomainWorkThrd(JoinData * pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    BOOL    fUninitCOM = FALSE;
    HRESULT hr;
    Assert(NULL != pData);

    CWizard *  pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(pData->hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    // Initialize COM on this thread
    //
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        // $REVIEW - LogError ?
        TraceTag(ttidWizard, "Failed to initialize COM join work thread");
        goto Done;
    }
    else
    {
        // Remember to uninitialize COM on thread exit
        fUninitCOM = TRUE;
    }

    DWORD dwNumTries = 1;

    if (IsDlgButtonChecked(pData->hwndDlg, BTN_JOIN_DOMAIN))
    {
        Sleep(c_dwDomainJoinWaitDelay);
        dwNumTries = 5;
    }

    if (pData->dwJoinFlag & JDF_MACHINE_PWD_PASSED)
    {   // Unattended Answer-File specified with ComputerPassword key
        // Try Secure Domain Join
        TraceTag(ttidWizard, "Attempting join with precreated computer password.");
        hr = HrAttemptSecureDomainJoin(pData, dwNumTries, c_dwDomainJoinWaitDelay);
        if (FAILED(hr))
        {
            // clear the secure domain join flag and try the normal join
            TraceTag(ttidWizard, "Failed in secure join domain.");
            pData->dwJoinFlag &= ~JDF_MACHINE_PWD_PASSED;
        }
        else
            goto Cleanup;
    }


    // Try the normal join
    //
    TraceTag(ttidWizard, "Attempting join WITHOUT trying to create an account.");
    hr = HrAttemptJoin(pData, 3, 10000);

    // If the join failed, and the Create Account flag has not been
    // specified, try adding it and reattempt the join.
    //
    if (FAILED(hr) && !(pData->dwJoinFlag & JDF_CREATE_ACCOUNT))
    {
        // Clear the Unsecure join flag if set, creating an account is
        // mutually exclusive.  Set the create account flag to reattempt.
        //
        pData->dwJoinFlag &= ~JDF_JOIN_UNSECURE;
        pData->dwJoinFlag |= JDF_CREATE_ACCOUNT;

        TraceTag(ttidWizard, "Attempting join but trying to create an account.");

        hr = HrAttemptJoin(pData, dwNumTries, c_dwDomainJoinWaitDelay);
    }

Cleanup:
    // Cleanup username/password and MachineObjectOU
    //
    pData->szUserName[0] = 0;
    pData->szPassword[0] = 0;
    pData->dwJoinFlag    = 0;
    MemFree(pData->pszMachineObjectOU);
    pData->pszMachineObjectOU = NULL;
    pData->szComputerPassword[0] = 0;

    if (FAILED(hr))
    {
        // Raid 380374: no UI allowed if in full unattended mode ..
        if (UM_FULLUNATTENDED == pWizard->GetUnattendedMode())
        {
            if (IsDlgButtonChecked(pData->hwndDlg, BTN_JOIN_DOMAIN))
            {
                NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UNATTENDED_JOIN_DOMAIN),
                                    pData->szDomain);
            }
            else
            {
                NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UNATTENDED_JOIN_WORKGROUP),
                                    pData->szDomain);
            }

            // proceed to the exit page
            PostMessage(pData->hwndDlg, PWM_JOINSUCCESS, 0, 0L);
        }
        else
        {
            // If we're in unattended mode, consider it failed.
            pData->fUnattendedFailed = TRUE;
            PostMessage(pData->hwndDlg, PWM_JOINFAILURE, 0, (LPARAM)hr);
        }
    }
    else
    {
        if (IsDlgButtonChecked(pData->hwndDlg, BTN_JOIN_DOMAIN))
            NotifyPostSetupWizard(PSW_JOINEDDOMAIN, pWizard);

        PostMessage(pData->hwndDlg, PWM_JOINSUCCESS, 0, 0L);
    }

Done:
    // Uninitialize COM for this thread
    //
    if (fUninitCOM)
    {
        CoUninitialize();
    }

    TraceTag(ttidWizard, "Leaving JoinDomainWorkThrd...");
    return( 0 );
}

//
// Function:    HrJoinProcessAnswerFile
//
// Purpose:     Read the answer file and populate the in memory structures
//              and UI with the data found
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//                       S_FALSE if required information is missing
//                       A failed error code on error
//
HRESULT HrJoinProcessAnswerFile(HWND hwndDlg, CWizard * pWizard,
                                JoinData * pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    CSetupInfFile csif;
    INFCONTEXT    ctx;
    BOOL          fValue;
    HRESULT       hr;
    int           nId    = BTN_JOIN_WORKGROUP;
    tstring       str;

    pData->dwJoinFlag    = 0;
    pData->szDomain[0]   = 0;
    pData->szUserName[0] = 0;
    pData->szPassword[0] = 0;
    pData->pszMachineObjectOU = NULL;
    pData->szComputerPassword[0] = 0;

    if ((NULL == pWizard->PSetupData()) ||
        (NULL == pWizard->PSetupData()->UnattendFile))
    {
        hr = NETSETUP_E_ANS_FILE_ERROR;
        goto Error;
    }

    // Open the answerfile
    //
    hr = csif.HrOpen(pWizard->PSetupData()->UnattendFile,
                     NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        hr = S_FALSE;
        TraceTag(ttidWizard, "Unable to open answer file!!!");
        goto Error;
    }


    // Check for existance of the identification section.  If it is not
    // present return S_FALSE to indicate identification info not supplied
    //
    hr = HrSetupFindFirstLine (csif.Hinf(), c_szAfSectionIdentification,
                               NULL, &ctx);
    if (SPAPI_E_LINE_NOT_FOUND == hr)
    {
        hr = S_FALSE;
        goto Error;
    }

    // Try to get the workgroup
    //

    hr = csif.HrGetString(c_szAfSectionIdentification,
                          c_szAfJoinWorkgroup, &str);
    if (SUCCEEDED(hr) && str.length())
    {
        if (MAX_WORKGROUPNAME_LENGTH >= str.length())
        {
            wcscpy(pData->szDomain, str.c_str());
            TraceTag(ttidWizard, "Joining workgroup: %S", pData->szDomain);
        }
        else
        {
             hr = NETSETUP_E_ANS_FILE_ERROR;
             TraceTag(ttidWizard, "JOIN Workgroup - Invalid workgroup supplied.");
             goto Error;
        }
    }
    else
    {
        // Try to get the domain
        //
        hr = csif.HrGetString(c_szAfSectionIdentification,
                              c_szAfJoinDomain, &str);
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            // No domain or workgroup entry, skip joining a domain
            hr = S_FALSE;
            goto Error;
        }
        else if (FAILED(hr) || (0 == str.length()) ||
                 (MAX_DOMAINNAME_LENGTH < str.length()))
        {
            hr = NETSETUP_E_ANS_FILE_ERROR;
            TraceTag(ttidWizard, "JOIN Domain - Invalid domain supplied.");
            goto Error;
        }

        // Joining a domain...
        //
        nId = BTN_JOIN_DOMAIN;
        wcscpy(pData->szDomain, str.c_str());
        TraceTag(ttidWizard, "Joining domain: %S", pData->szDomain);

        // If we're upgrading from win9x add the special flag
        //
        hr = csif.HrGetString(c_szAfSectionNetworking,
                              c_szAfUpgradeFromProduct, &str);
        if (SUCCEEDED(hr) &&
            (0 == lstrcmpiW(str.c_str(), c_szAfWin95)))
        {
            pData->dwJoinFlag |= JDF_WIN9x_UPGRADE;
        }

        // Support unsecure joins
        //
        hr = csif.HrGetStringAsBool(c_szAfSectionIdentification,
                                    c_szAfUnsecureJoin,
                                    &fValue);
        if (SUCCEEDED(hr) && fValue)
        {
            pData->dwJoinFlag |= JDF_JOIN_UNSECURE;
        }

        // Is a MachineObjectOU specified?
        //
        hr = csif.HrGetString(c_szAfSectionIdentification,
                              c_szAfMachineObjectOU, &str);
        if (SUCCEEDED(hr) && str.length())
        {
            pData->pszMachineObjectOU = reinterpret_cast<WCHAR *>(MemAlloc(sizeof(WCHAR) * (str.length() + 1)));
            if (pData->pszMachineObjectOU)
            {
                TraceTag(ttidWizard, "Machine Object OU: %S", pData->szDomain);
                lstrcpyW(pData->pszMachineObjectOU, str.c_str());
            }
        }

        // Bug# 204377 secure domain join shouldn't require both "ComputerPassword" and
        //             "DomainAdmin"/"DomainAdminPassword" options to be presence
        //             in Answer-File simultaneously.
        //
        // Bug# 204378 If the Answer-File specifies the "ComputerPassword" key
        //             in the "Indentification" section, the code should attempt
        //             a secure domain join, regardless of the presence of the
        //             "DoOldstyleDomainjoin" key

        // check if this is a secure domain join by
        // quering the random machine account password
        hr = csif.HrGetString(c_szAfSectionIdentification,
                              c_szAfComputerPassword, &str);
        if (SUCCEEDED(hr) && (str.length() <= SAM_MAX_PASSWORD_LENGTH) && str.length())
        {
            TraceTag(ttidWizard, "Got the value of ComputerPassword");
            wcscpy(pData->szComputerPassword, str.c_str());
            // signal that we need to try secure domain join by
            // passing the random machine password
            pData->dwJoinFlag |= JDF_MACHINE_PWD_PASSED;

            // Bug# 204378, make sure we won't do the unsecure domain join
            //              and we'll try to read "DomainAdmin"/"DomainAdminPassword"
            //              in the following if block.
            pData->dwJoinFlag &= ~JDF_JOIN_UNSECURE;
        }

        // If not a remote boot client, Query the username, unless this
        // is an unsecure domain join which doesn't need username/password.
        //
        if (
#if defined(REMOTE_BOOT)
            (S_FALSE == HrIsRemoteBootMachine()) ||
#endif // defined(REMOTE_BOOT)
            ((pData->dwJoinFlag & JDF_JOIN_UNSECURE) == 0))
        {
            hr = csif.HrGetString(c_szAfSectionIdentification,
                                  c_szAfDomainAdmin, &str);
            if (SUCCEEDED(hr) && (MAX_USERNAME_LENGTH > str.length()))
            {
                wcscpy(pData->szUserName, str.c_str());

                // Query the password
                //
                hr = csif.HrGetString(c_szAfSectionIdentification,
                                      c_szAfDomainAdminPassword, &str);
                if (SUCCEEDED(hr) && (SAM_MAX_PASSWORD_LENGTH > str.length()))
                {
                    wcscpy(pData->szPassword, str.c_str());

                    // Raid 195920 - If both username and password are
                    // present, treat this like a fresh install and DO NOT
                    // use the JDF_WIN9x_UPGRADE flag
                    pData->dwJoinFlag &= ~(JDF_WIN9x_UPGRADE | JDF_JOIN_UNSECURE);
                }
            }

            // Bug# 204377
            // ignore any error on reading of "DomainAdmin"/"DomainAdminPassword" keys
            // if "ComputerPassword" has been specified.
            if (! (pData->dwJoinFlag & JDF_MACHINE_PWD_PASSED) )
            {
                // If failed or either is longer than the maximum length return an error
                //
                if (FAILED(hr) || (MAX_USERNAME_LENGTH <= str.length()))
                {
                    hr = NETSETUP_E_ANS_FILE_ERROR;
                    TraceTag(ttidWizard, "JOIN Domain - Invalid username/password supplied.");
                    goto Error;
                }
            }
        }

    }

    // Normalize any optional errors
    //
    hr = S_OK;

Error:
    // Update the UI and pData with the info we managed to read.
    //
    CheckRadioButton(hwndDlg, BTN_JOIN_WORKGROUP, BTN_JOIN_DOMAIN, nId);
    SetWindowText(GetDlgItem(hwndDlg, nId == BTN_JOIN_DOMAIN ?  EDT_DOMAINJOIN_NAME : EDT_WORKGROUPJOIN_NAME ), pData->szDomain);
    JoinUpdatePromptText(hwndDlg);

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrJoinProcessAnswerFile");
    return hr;
}

//
// Function:    OnJoinDoUnattended
//
// Purpose:
//
// Parameters:
//
// Returns:     BOOL
//
BOOL OnJoinDoUnattended(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    DWORD     dwThreadId = 0;
    HRESULT   hr         = S_OK;
    CWizard * pWizard    =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    JoinData * pData = reinterpret_cast<JoinData *>
                                (pWizard->GetPageData(IDD_Join));
    Assert(NULL != pData);
    Assert(NULL != pData->pIdent);
    Assert(NULL != pData->hwndDlg);

    if(pData) {
        // Create the unattended thread
        //
        HANDLE hthrd = CreateThread(NULL, STACK_SIZE_TINY,
                                    (LPTHREAD_START_ROUTINE)JoinDomainWorkThrd,
                                    (LPVOID)pData, 0, &dwThreadId);
        if (NULL != hthrd)
        {
            // Set the wait cursor
            //

            SetCursorToHourglass( hwndDlg, pData );

            // Disable all the controls
            //
            PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
            EnableOrDisableDialogControls(hwndDlg, celems(nrgIdc), nrgIdc, FALSE);

            CloseHandle(hthrd);
        }
        else
        {
            hr = HrFromLastWin32Error();
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "OnJoinDoUnattended");
    return (SUCCEEDED(hr));
}



// Determines whether the computer DNS domain name should be kept in sync with
// the DNS domain name of the domain to which it is joined.  If no
// synchonization is required (unlikely, as sync is the default), do nothing.
//
// Otherwise, attempt to determine the DNS domain name of the domain and write
// this value into reg key.  If the DNS domain name cannot be determined,
// write a flag to a separate reg key to indicate that whatever services that
// care about the computer DNS domain name (i.e. kerberos authentication)
// should try to fix up the name.

void
fixupComputerDNSDomainName()
{
   TraceFileFunc(ttidGuiModeSetup);

   TraceTag(ttidWizard, "Entering fixupComputerDNSDomainName");

   // check a reg key for the sync flag.

   bool fSetName = false;
   HKEY hkeyParams = 0;

   HRESULT hr =
      HrRegOpenKeyEx(
         HKEY_LOCAL_MACHINE,
         c_szIpParameters,

         // all access as we may need to write a value here if we fail.
         KEY_READ_WRITE,
         &hkeyParams);

   if (SUCCEEDED(hr))
   {
      DWORD dwValue = 0;
      hr = HrRegQueryDword(hkeyParams, c_szSyncDomainWithMembership, &dwValue);
      if (SUCCEEDED(hr) && (1 == dwValue))
      {
         // the sync flag was present in the registry, and its value is true
         fSetName = true;
      }
      else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
      {
         // the sync flag was not present in the registry, which means we
         // assume the default value of true.
         fSetName = true;
         hr = S_OK;
      }
   }

   if (SUCCEEDED(hr) && fSetName)
   {
      bool fixup_success = false;

      // 293301 Here we attempt to determine the DNS domain name of the domain
      // the machine is joined to.  If we cannot determine that name (because
      // a dc could not be located, for example), then we will set a flag in
      // the registry so that kerberos authentication agents will come along
      // and fixup the DNS domain name.

      PDOMAIN_CONTROLLER_INFO pDCInfo = 0;
      DWORD dw =
         DsGetDcName(
            0,
            0,
            0,
            0,

            // make sure to ask for the DNS domain name, otherwise we're
            // likely to get the flatname
            DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
            &pDCInfo);

      if (NOERROR == dw)
      {
         Assert(pDCInfo->DomainName);
         Assert(pDCInfo->Flags & DS_DNS_DOMAIN_FLAG);

         TraceTag(ttidWizard, "DsGetDcName succeeded %s", pDCInfo->DomainName);

         if (pDCInfo->Flags & DS_DNS_DOMAIN_FLAG)
         {
            // the domain name is indeed the DNS name

            // chop off any trailing '.'
            WCHAR*  AbsoluteSignifier =
               &pDCInfo->DomainName[ wcslen(pDCInfo->DomainName) - 1 ];
            if (*AbsoluteSignifier == L'.')
            {
               *AbsoluteSignifier = 0;
            }

            // set the computer's DNS domain name.
            if (
               SetComputerNameEx(
                  ComputerNamePhysicalDnsDomain,
                  pDCInfo->DomainName) )
            {
               fixup_success = true;
            }
#if DBG
            else
            {
               // this just isn't our day.
               TraceTag(ttidWizard, "SetComputerNameEx failed");
            }
#endif
         }
         NetApiBufferFree(pDCInfo);
      }
#if DBG
      else
      {
         TraceTag(ttidWizard, "DsGetDcName returned %ld",dw);
      }
#endif

      // at this point, fixup_success will indicate whether we successfully
      // set the computer's domain DNS name, or not.  If not, then we need
      // to write a flag into the registry so that kerberos auth will fix
      // it up later.
      if (!fixup_success)
      {
         // write a flag to have someone else do the fixup
         HrRegSetDword(hkeyParams, L"DoDNSDomainFixup", 1);
      }
   }

   RegCloseKey(hkeyParams);
}



//
// Function:    JoinUpgradeNT351orNT4toNT5
//
// Purpose:     If currently processing NT4 -> NT5 upgrade, set the
//              computer name.
//
// Parameters:
//
// Returns:     none
//
VOID JoinUpgradeNT351orNT4toNT5(CWizard * pWizard, JoinData * pData)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;
    CSetupInfFile csif;
    INFCONTEXT    ctx;

    TraceTag(ttidWizard, "Checking for the need to do NT4->NT5 Join conversions...");

    // If unattended
    //
    if (IsUnattended(pWizard) && (NULL != pWizard->PSetupData()) &&
        (NULL != pWizard->PSetupData()->UnattendFile))
    {
        hr = csif.HrOpen(pWizard->PSetupData()->UnattendFile,
                         NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (SUCCEEDED(hr))
        {
            DWORD dw;

            hr = csif.HrGetDword(c_szAfSectionNetworking, c_szAfBuildNumber, &dw);
            if (SUCCEEDED(hr) && ((wWinNT4BuildNumber == dw) ||
                                  (wWinNT351BuildNumber == dw)))
            {
                hr = pData->pIdent->GetComputerRole(&dw);
                if (SUCCEEDED(hr) && (dw == GCR_MEMBER))
                {
                    //fixupComputerDNSDomainName();
                    NC_TRY
                    {
                        TraceTag (ttidWizard, "Calling NetpUpgradePreNT5JoinInfo...");
                        NetpUpgradePreNT5JoinInfo ();
                    }
                    NC_CATCH_ALL
                    {
                        TraceHr (
                            ttidWizard, FAL, E_FAIL, FALSE,
                            "NetpUpgradePreNT5JoinInfo failed.  "
                            "Likely delay load problem with netapi32.dll");
                    }
                }
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "JoinUpgradeNT351orNT4toNT5");
}

//
// Function:    OnJoinPageActivate
//
// Purpose:
//
// Parameters:
//
// Returns:
//
BOOL OnJoinPageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);
    JoinData * pData = reinterpret_cast<JoinData *>
                                (pWizard->GetPageData(IDD_Join));
    Assert(NULL != pData);

    TraceTag(ttidWizard, "Entering Join page...");

    if (ISDC(ProductType(pWizard)))
    {
        // 412142 : we are going to skip the Join page a little farther down, but
        //          even for a DC, we need to do this.
        //
        if (FALSE == pData->fUpgraded)
        {
            JoinUpgradeNT351orNT4toNT5(pWizard, pData);
            pData->fUpgraded = TRUE;
        }
    }

    // mbend 02/08/2000
    //
    // BUG 433915
    // Domain/Workgroup page in setup: Check to by-pass for SBS case

    // If this computer is a domain controller or there are no adapters or we don't
    // want activation, then don't show the Join page.
    //
    if (IsSBS() || ISDC(ProductType(pWizard)) || !pWizard->PAdapterQueue()->FAdaptersInstalled() ||
        (IsRunningOnPersonal() && !(IsUnattended(pWizard) && (FALSE == pData->fUpgraded))) )
    {
        PAGEDIRECTION  PageDir = pWizard->GetPageDirection(IDD_Join);

        if (NWPD_FORWARD == PageDir)
        {
            // if forward goto exit page
            //
            pWizard->SetPageDirection(IDD_Join, NWPD_BACKWARD);
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Exit);
        }
        else
        {
            // if backward goto upgrade page
            //
            pWizard->SetPageDirection(IDD_Join, NWPD_FORWARD);
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, IDD_Upgrade);
        }
    }
    else    // !DC
    {
        // Accept focus
        //
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);
        PropSheet_SetWizButtons(GetParent(hwndDlg), 0);

        // If we're in unattended mode and haven't tried to join a
        // domain/workgroup then give it a try
        //
        if (IsUnattended(pWizard) && (FALSE == pData->fUpgraded))
        {
            HRESULT hr;

            pData->fUpgraded = TRUE;

            // Raid 193450 - NT4 -> NT5 we need to SetComputerNameEx
            //
            JoinUpgradeNT351orNT4toNT5(pWizard, pData);

            // Get the join parameters from the answer file and populate the UI
            //
            hr = HrJoinProcessAnswerFile(hwndDlg, pWizard, pData);
            if (S_FALSE == hr)
            {
                // S_FALSE was returned, this means no answerfile section
                // for identification is present or not all the required
                // data is present. Advance without joining unless we're in
                // defaulthide mode.
                // Advance regardless if we're upgrading, or running on Personal.
                //
                Assert(S_FALSE == hr);

                if (((UM_DEFAULTHIDE == pWizard->GetUnattendedMode()) ||
                     (UM_READONLY == pWizard->GetUnattendedMode()))
                     && (!IsUpgrade(pWizard))
                     && (!IsRunningOnPersonal()) )
                {
                    // Pretend something failed so that pressing NEXT will
                    // do the join. Basically we just populated the UI from
                    // the answerfile.
                    //
                    pData->fUnattendedFailed = TRUE;
                }
                else
                {
                    PostMessage(hwndDlg, PWM_JOINSUCCESS, 0, 0L);
                }
            }
            else
            {
                if (FAILED(hr))
                {
                    if (UM_FULLUNATTENDED == pWizard->GetUnattendedMode())
                    {
                        // Raid 380374: no UI allowed if in full unattended mode ..
                        NetSetupLogStatusV( LogSevError,
                                            SzLoadIds (IDS_E_UNATTENDED_INVALID_ID_SECTION));

                        PostMessage(hwndDlg, PWM_JOINSUCCESS, 0, 0L);
                    }
                    else
                    {
                        // Stop on this page, something was wrong in the answerfile
                        //
                        pData->fUnattendedFailed = TRUE;
                    }
                }
                else
                {
                    // If we're in UM_FULLUNATTENDED or in UM_DEFAULTHIDE mode
                    // launch the thread which will do the unattended join
                    //
                    Assert(S_OK == hr);
                    if ((UM_FULLUNATTENDED == pWizard->GetUnattendedMode()) ||
                        (UM_DEFAULTHIDE == pWizard->GetUnattendedMode()) ||
                        (UM_READONLY == pWizard->GetUnattendedMode()))
                    {
                        OnJoinDoUnattended(hwndDlg);
                    }
                    else
                    {
                        // Pretend something failed so that pressing NEXT will
                        // do the join. Basically we just populated the UI from
                        // the answerfile.
                        //
                        pData->fUnattendedFailed = TRUE;
                    }
                }
            }
        }

        // If something failed in the unattended case or
        // If we are not unattended and we did not process this,
        // make sure the page shows if called from GUI mode setup.
        if ( pData->fUnattendedFailed ||
            !IsUnattended(pWizard) )
        {
            // Make the page visible if it is not an upgrade, otherwise just continue to the next page.

            if (!IsUpgrade(pWizard))
            {
                if (g_pSetupWizard != NULL)
                {
                    g_pSetupWizard->PSetupData()->ShowHideWizardPage(TRUE);
                }

                UpdateNextBackBttns(hwndDlg);
            }
            else
            {
                PostMessage(hwndDlg, PWM_JOINSUCCESS, 0, 0L);
            }
        }
    }

    return TRUE;
}

//
// Function:    OnJoinInitDialog
//
// Purpose:
//
// Parameters:
//
// Returns:
//
BOOL OnJoinInitDialog(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    HRESULT        hr;
    CWizard *      pWizard;
    JoinData *     pData;
    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);

    pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    pData = reinterpret_cast<JoinData *>(pWizard->GetPageData(IDD_Join));
    Assert(NULL != pData);

    if(!pData)
    {
        return false;
    }

    // Set the descriptive text
    tstring str = SzLoadIds(IDS_TXT_JOIN_DESC_1);
    str += L"\n";
    str += SzLoadIds(IDS_TXT_JOIN_DESC_2);
    SetWindowText(GetDlgItem(hwndDlg, TXT_JOIN_DESC), str.c_str());

    // Set the maximum length of text in the edit control, and
    // subclass it so when the control has no text the next bttn
    // is disabled.
    HWND hwndEditDomain = GetDlgItem(hwndDlg, EDT_DOMAINJOIN_NAME);
    SendMessage(hwndEditDomain, EM_LIMITTEXT, MAX_DOMAINNAME_LENGTH, 0L);
    ::SetWindowLongPtr(hwndEditDomain, GWLP_USERDATA, ::GetWindowLongPtr(hwndEditDomain, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEditDomain, GWLP_WNDPROC, (LONG_PTR)JoinEditSubclassProc);

    HWND hwndEditWorkgroup = GetDlgItem(hwndDlg, EDT_WORKGROUPJOIN_NAME);
    SendMessage(hwndEditWorkgroup, EM_LIMITTEXT, MAX_WORKGROUPNAME_LENGTH, 0L);
    ::SetWindowLongPtr(hwndEditWorkgroup, GWLP_USERDATA, ::GetWindowLongPtr(hwndEditWorkgroup, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndEditWorkgroup, GWLP_WNDPROC, (LONG_PTR)JoinEditSubclassProc);

    pData->hwndDlg = hwndDlg;

    // Initialize to Workgroup default
    CheckRadioButton(hwndDlg, BTN_JOIN_WORKGROUP,
                     BTN_JOIN_DOMAIN, BTN_JOIN_WORKGROUP);

    // Get the identification interface
    TraceTag(ttidWizard, "Querying computer role...");
    hr = HrGetIdentInterface(&pData->pIdent);
    if (FAILED(hr))
    {
        Assert(NULL == pData->pIdent);
        EnableOrDisableDialogControls(hwndDlg, celems(nrgIdc), nrgIdc, FALSE);
        PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_BACK | PSWIZB_NEXT);
    }
    else
    {
        // Update the UI based on the selection
        UpdateJoinUsingComputerRole(hwndDlg, pWizard);
    }

    return FALSE;
}

//
// Function:    OnJoinWizBack
//
// Purpose:
//
// Parameters:
//
// Returns:
//
BOOL OnJoinWizBack(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    OnProcessPrevAdapterPagePrev(hwndDlg, IDD_Upgrade);

    return TRUE;
}


//
// Function:    GetCredentials
//
// Purpose:     Prompt the user for username and password.
//
// Returns:     TRUE on success, otherwise FALSE.
//
// Author:      asinha 5/03/2001
//

BOOL GetCredentials (HWND hwndParent, JoinData *pData)
{
    WCHAR        szCaption[CREDUI_MAX_CAPTION_LENGTH+1];
    CREDUI_INFOW uiInfo;
    DWORD        dwErr;

    TraceFileFunc(ttidGuiModeSetup);

    DwFormatString(SzLoadIds(IDS_JOIN_DOMAIN_CAPTION), szCaption,
                   celems(szCaption), pData->szDomain);


    ZeroMemory( &uiInfo, sizeof(uiInfo) );
    uiInfo.cbSize = sizeof(CREDUI_INFOW);
    uiInfo.hwndParent = hwndParent;
    uiInfo.pszMessageText = SzLoadIds(IDS_JOIN_DOMAIN_TEXT);
    uiInfo.pszCaptionText = szCaption;

    dwErr = CredUIPromptForCredentialsW(
                                  &uiInfo,
                                  NULL,
                                  NULL,
                                  NO_ERROR,
                                  pData->szUserName,
                                  MAX_USERNAME_LENGTH+1,
                                  pData->szPassword,
                                  SAM_MAX_PASSWORD_LENGTH+1,
                                  NULL,
                                  CREDUI_FLAGS_DO_NOT_PERSIST |
                                  CREDUI_FLAGS_GENERIC_CREDENTIALS |
                                  CREDUI_FLAGS_VALIDATE_USERNAME |
                                  CREDUI_FLAGS_COMPLETE_USERNAME |
                                  CREDUI_FLAGS_ALWAYS_SHOW_UI );

    Assert(dwErr != ERROR_INVALID_PARAMETER);
    Assert(dwErr != ERROR_INVALID_FLAGS);

    if (dwErr == ERROR_CANCELLED)
    {
        pData->szUserName[0] = 0;
        pData->szPassword[0] = 0;
    }

    return NO_ERROR == dwErr; // e.g. ERROR_CANCELLED
}

//
// Function:    JoinWorkgroupDomain
//
// Purpose:
//
// Parameters:
//
// Returns:     nothing
//
VOID JoinWorkgroupDomain(HWND hwndDlg, CWizard * pWizard,
                         JoinData * pData)
{
    TraceFileFunc(ttidGuiModeSetup);
    DWORD    dwThreadId = 0;
    HANDLE   hthrd      = NULL;

    Assert(NULL != pData->pIdent);
    Assert(NULL != pData->hwndDlg);

    // Retain the domain/workgroup name.  Note that the answerfile
    // populates the UI before this routine is called so requerying
    // from the UI covers both cases (answerfile or user input)
    //

    if (IsDlgButtonChecked(hwndDlg, BTN_JOIN_DOMAIN))
    {
        HWND hwndEdit = GetDlgItem(hwndDlg, EDT_DOMAINJOIN_NAME);
        Assert(0 != GetWindowTextLength(hwndEdit));

        GetWindowText(hwndEdit, pData->szDomain, MAX_DOMAINNAME_LENGTH + 1);

        // If no information was seeded into the structure, prompt for it.
        //
        if (0 == pData->szUserName[0])
        {
            pData->szPassword[0] = 0;

            // Preserve the only Win9x upgrade flag if it was present
            //
            pData->dwJoinFlag &= JDF_WIN9x_UPGRADE;

            // Get the username/password when joining a domain
            //


            BOOL bRet;

            bRet = GetCredentials(GetParent(hwndDlg), pData);

            // Note: Must set return as -1 otherwise join page will advance
            //
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

            if (bRet == FALSE)
            {
                return;
            }
        }
    }
    else
    {
        HWND hwndEdit = GetDlgItem(hwndDlg, EDT_WORKGROUPJOIN_NAME);
        Assert(0 != GetWindowTextLength(hwndEdit));

        GetWindowText(hwndEdit, pData->szDomain, MAX_WORKGROUPNAME_LENGTH + 1);

        // Initialize the workstation settings for username/password
        // and join flags
        //
        pData->szUserName[0] = 0;
        pData->dwJoinFlag    = 0;
        pData->szPassword[0] = 0;
        MemFree(pData->pszMachineObjectOU);
        pData->pszMachineObjectOU = NULL;
        pData->szComputerPassword[0] = 0;
    }

    // Create the thread to join the workgroup/domain
    hthrd = CreateThread(NULL, STACK_SIZE_TINY,
                         (LPTHREAD_START_ROUTINE)JoinDomainWorkThrd,
                         (LPVOID)pData, 0, &dwThreadId);
    if (NULL != hthrd)
    {
        SetCursorToHourglass( hwndDlg, pData );

        PropSheet_SetWizButtons(GetParent(hwndDlg), 0);
        EnableOrDisableDialogControls(hwndDlg, celems(nrgIdc), nrgIdc, FALSE);
        CloseHandle(hthrd);
    }
    else
    {
        // Failed to create the required netsetup thread
        AssertSz(0,"Unable to create JoinWorkgroupDomain thread.");
        TraceHr(ttidWizard, FAL, E_OUTOFMEMORY, FALSE, "JoinWorkgroupDomain - Create thread failed");
    }
}

//
// Function:    OnJoinWizNext
//
// Purpose:
//
// Parameters:
//
// Returns:
//
BOOL OnJoinWizNext(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    JoinData * pData = reinterpret_cast<JoinData *>
                                (pWizard->GetPageData(IDD_Join));
    Assert(NULL != pData);

    if(!pData)
    {
        return false;
    }

    // Attempt to join the workgroup/domain if we have the Ident interface
    //
    if (pData->pIdent)
    {

        // Ensure the user supplied a workgroup/domain name
        //
        if (0 == GetWindowTextLength(GetDlgItem(hwndDlg, GetJoinNameIIDFromSelection(hwndDlg))))
        {
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
            return TRUE;
        }

        // Join the workgroup/domain
        //
        if (!IsUnattended(pWizard) || pData->fUnattendedFailed)
        {
            DNS_STATUS dnsStatus;

            if ( IsDlgButtonChecked(hwndDlg, BTN_JOIN_DOMAIN) )
            {

                dnsStatus = IsValidDomainName( hwndDlg );
            }
            else
            {
                dnsStatus = ERROR_SUCCESS;
            }

            if ( (dnsStatus == ERROR_SUCCESS) ||
                 (dnsStatus == DNS_ERROR_NON_RFC_NAME) )
            {
                JoinWorkgroupDomain(hwndDlg, pWizard, pData);
            }
            else
            {
                tstring str;

                str =  SzLoadIds(IDS_JOIN_E_DOMAIN_INVALID_NAME);

                MessageBox(GetParent(hwndDlg), str.c_str(),
                           SzLoadIds(IDS_SETUP_CAPTION), MB_OK);
             }
        }

        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
    }
    else
    {
        OnJoinSuccess(hwndDlg);
    }

    return TRUE;
}

//
// Function:    dlgprocJoin
//
// Purpose:     Dialog Procedure for the Join wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocJoin( HWND hwndDlg, UINT uMsg,
                              WPARAM wParam, LPARAM lParam )
{
    TraceFileFunc(ttidGuiModeSetup);
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case PWM_JOINFAILURE:
        frt = OnJoinFailure(hwndDlg, lParam);
        break;

    case PWM_JOINSUCCESS:
        frt = OnJoinSuccess(hwndDlg);
        break;

    case WM_INITDIALOG:
        frt = OnJoinInitDialog(hwndDlg, lParam);
        break;

    case WM_COMMAND:
        {
            if ((BN_CLICKED == HIWORD(wParam)) &&
                ((BTN_JOIN_DOMAIN == LOWORD(wParam)) ||
                 (BTN_JOIN_WORKGROUP == LOWORD(wParam))))
            {
                JoinUpdatePromptText(hwndDlg);
            }
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnJoinPageActivate(hwndDlg);
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                frt = OnJoinWizBack(hwndDlg);
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnJoinWizNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    JoinPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID JoinPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    JoinData * pData = reinterpret_cast<JoinData *>(lParam);
    if (NULL != pData)
    {
        delete pData->pIdent;
    }
    MemFree(reinterpret_cast<void*>(lParam));
}

//
// Function:    CreateJoinPage
//
// Purpose:     To determine if the Join page needs to be shown, and to
//              to create the page if requested.  Note the Join page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateJoinPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                    BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    HRESULT hr = S_OK;

    // Batch Mode or for fresh install
    if (!IsPostInstall(pWizard))
    {
        // If not only counting, create and register the page
        if (!fCountOnly)
        {
            JoinData *     pData = NULL;
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE  psp;

            TraceTag(ttidWizard, "Creating Join Page");
            hr = E_OUTOFMEMORY;
            pData = reinterpret_cast<JoinData *>(MemAlloc(sizeof(JoinData)));
            if (pData)
            {
                pData->fUnattendedFailed  = FALSE;
                pData->fUpgraded          = FALSE;
                pData->pIdent             = NULL;
                pData->hOldCursor         = NULL;
                pData->hwndDlg            = NULL;
                pData->dwJoinFlag         = 0;
                pData->szUserName[0]      = 0;
                pData->szPassword[0]      = 0;
                pData->szDomain[0]        = 0;
                pData->pszMachineObjectOU = NULL;
                pData->szComputerPassword[0] = 0;

                psp.dwSize = sizeof( PROPSHEETPAGE );
                psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
                psp.hInstance = _Module.GetResourceInstance();
                psp.pszTemplate = MAKEINTRESOURCE( IDD_Join );
                psp.hIcon = NULL;
                psp.pfnDlgProc = dlgprocJoin;
                psp.lParam = reinterpret_cast<LPARAM>(pWizard);
                psp.pszHeaderTitle = SzLoadIds(IDS_T_Join);
                psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Join);

                hpsp = CreatePropertySheetPage( &psp );
                if (hpsp)
                {
                    pWizard->RegisterPage(IDD_Join, hpsp,
                                          JoinPageCleanup,
                                          reinterpret_cast<LPARAM>(pData));
                    hr = S_OK;
                }
                else
                {
                    MemFree(pData);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            (*pnPages)++;
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateJoinPage");
    return hr;
}

//
// Function:    AppendJoinPage
//
// Purpose:     Add the Join page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendJoinPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    if (!IsPostInstall(pWizard))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Join);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wmode.cpp ===
#include "pch.h"
#pragma hdrstop
#include "pch.hxx"

#include "wizard.h"



//
// Function:    OnModeWizBackNext
//
// Purpose:     Handle the PSN_WIZ notification.
//
// Parameters:  hwndDlg [IN] - Handle to the exit child dialog
//
// Returns:     BOOL, TRUE on success
//
BOOL OnModeWizBackNext(HWND hwndDlg)
{
    HPROPSHEETPAGE hPage = NULL;

    // Retrieve the CWizard instance from the dialog
    LPARAM    lParam = GetWindowLong(hwndDlg, DWL_USER);
    CWizard * pWizard = reinterpret_cast<CWizard *>(lParam);
    Assert(NULL != pWizard);

    PAGEDIRECTION PageDir = pWizard->GetPageDirection(IDD_Mode);
    if (NWPD_FORWARD == PageDir)
    {
        if (IsDlgButtonChecked(hwndDlg, CHK_MODE_TYPICAL))
        {
            pWizard->ChangeSetupMode(NCWUC_SETUPMODE_TYPICAL);

            // Goto the Join page if not postinstall
            hPage = pWizard->GetPageHandle(IDD_Join);
        }
        else
        {
            HRESULT hr = S_OK;
            pWizard->ChangeSetupMode(NCWUC_SETUPMODE_CUSTOM);

            pWizard->SetCurrentProvider(0);
            CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
            Assert(NULL != pWizProvider);
            Assert(pWizProvider->ULPageCount());

            // Push the adapter guid onto the provider
            hr = pWizProvider->HrSpecifyAdapterGuid(
                                pWizard->GetCurrentAdapterGuid());

            // Goto the first page of the appropriate provider
            pWizard->SetPageDirection(IDD_Mode, NWPD_BACKWARD);
            CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
            Assert(NULL != pWizProvider);
            Assert(0 < pWizProvider->ULPageCount());
            hPage = (pWizProvider->PHPropPages())[0];
        }
    }
    else
    {
        // Back from here is wwelcome when postinstall
        // and wupgrade when not postinstall
        pWizard->SetPageDirection(IDD_Mode, NWPD_FORWARD);
        return FALSE;   // Let the default occur
    }

    Assert(hPage);
    SetWindowLong(hwndDlg, DWL_MSGRESULT, -1);
    PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                (LPARAM)(HPROPSHEETPAGE)hPage);

    return TRUE;    // The PostMessage will do the work
}

//
// Function:    dlgprocMode
//
// Purpose:     Dialog Procedure for the Mode wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocMode( HWND hwndDlg, UINT uMsg,
                              WPARAM wParam, LPARAM lParam )
{
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            // Initialize our pointers to property sheet info.
            PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
            Assert(psp->lParam);
            SetWindowLong(hwndDlg, DWL_USER, psp->lParam);

            tstring str = SzLoadIds(IDS_TXT_MODE_DESC_1);
            str += SzLoadIds(IDS_TXT_MODE_DESC_2);
            SetWindowText(GetDlgItem(hwndDlg, TXT_MODE_DESC), str.c_str());

            CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
            Assert(NULL != pWizard);
            CWizardUiContext * pCtx = pWizard->GetUiContext();
            Assert(NULL != pCtx);

            int idc = ((pCtx->GetSetupMode() & SETUPMODE_TYPICAL) ?
                        CHK_MODE_TYPICAL : CHK_MODE_CUSTOM);
            CheckRadioButton(hwndDlg, CHK_MODE_TYPICAL,
                             CHK_MODE_CUSTOM, idc);
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                TraceTag(ttidWizard, "Entering Mode page...");
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                frt = OnModeWizBackNext(hwndDlg);
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnModeWizBackNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    ModePageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID ModePageCleanup(CWizard *pWizard, LPARAM lParam)
{
}

//
// Function:    CreateModePage
//
// Purpose:     To determine if the Mode page needs to be shown, and to
//              to create the page if requested.  Note the Mode page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateModePage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                         BOOL fCountOnly, UINT *pnPages)
{
    HRESULT hr = S_OK;

    // Batch Mode or for fresh install
    if (pWizard->FProcessLanPages())
    {
        (*pnPages)++;

        // If not only counting, create and register the page
        if (!fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating Mode Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = 0;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_Mode );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocMode;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);

            hpsp = CreatePropertySheetPage( &psp );
            if (hpsp)
            {
                pWizard->RegisterPage(IDD_Mode, hpsp,
                                      ModePageCleanup, NULL);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateModePage");
    return hr;
}

//
// Function:    AppendModePage
//
// Purpose:     Add the Mode page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendModePage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    if (pWizard->FProcessLanPages())
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Mode);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wizard.cpp ===
#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "wizard.h"
#include "ncnetcfg.h"
#include "lancmn.h"
#include "cfg.h"
#include "wgenericpage.h"


//
// Function:    CWizProvider::CWizProvider
//
// Purpose:     ctor for the CWizProvider class
//
// Parameters:  pPL - Info corresponding to a Connection UI Object
//
// Returns:     nothing
//
CWizProvider::CWizProvider(ProviderList *pPL, BOOL fDeferLoad)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    memcpy(&m_guidUiObject, pPL->pguidProvider, sizeof(GUID));
    m_ulMaxPageCount        = 0xFFFFFFFF;
    m_ulPageCnt             = 0;
    m_ulPageBufferLen       = 0;
    m_rghPages              = NULL;
    m_pWizardUi             = NULL;
    m_fDeletePages          = TRUE;
    m_nBtnIdc               = pPL->nBtnIdc;
    m_fDeferLoad            = fDeferLoad;
}

//
// Function:    CWizProvider::~CWizProvider
//
// Purpose:     dtor for the CWizProvider class
//
// Parameters:  none
//
// Returns:     nothing
//
CWizProvider::~CWizProvider()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if (m_fDeletePages)
    {
        DeleteHPages();
    }

    MemFree(m_rghPages);

    ReleaseObj(m_pWizardUi);
}

//
// Function:    CWizProvider::HrCreate
//
// Purpose:     Two phase constructor for the CWizProvider class
//
// Parameters:  pPL        [IN] - Provider info from which to query the
//                                INetConnectionWizardUi interface.
//              pProvider [OUT] - If this function succeeds this pointer
//                                will contain the constructed and
//                                initialized CWizProvider instance.
//              fDeferLoad [IN] - Request the provider defer actual load
//
// Returns:     HRESULT, S_OK on success
//
NOTHROW
HRESULT CWizProvider::HrCreate(ProviderList *pPL,
                               CWizProvider ** ppProvider,
                               BOOL fDeferLoad)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT     hr = S_OK;
    CWizProvider *pprov = NULL;

    Assert((NULL != pPL) && (NULL != ppProvider));

    // Initialize output parameters
    *ppProvider = NULL;

    // Create the CWizProvider instance
    pprov = new CWizProvider(pPL, fDeferLoad);

    if ((NULL != pprov) && (FALSE == fDeferLoad))
    {
        Assert(pPL->pguidProvider);
        hr = CoCreateInstance(
                reinterpret_cast<REFCLSID>(*pPL->pguidProvider),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetConnectionWizardUi,
                (LPVOID*)&pprov->m_pWizardUi);

        TraceHr(ttidError, FAL, hr, FALSE, "CoCreateInstance");

        if (FAILED(hr))
        {
            delete pprov;
            pprov = NULL;
        }
    }

    // Save the new instance
    *ppProvider = pprov;

    TraceHr(ttidWizard, FAL, hr, (REGDB_E_CLASSNOTREG == hr), "CWizProvider::HrCreate");
    return hr;
}

//
// Function:    CWizProvider::HrCompleteDeferredLoad
//
// Purpose:     Complete the steps necessary to load what was a defer load object
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CWizProvider::HrCompleteDeferredLoad()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;

    if (m_fDeferLoad)
    {
        m_fDeferLoad = FALSE;

        // Attempt to create the UI Object
        //
        hr = CoCreateInstance(
                reinterpret_cast<REFCLSID>(m_guidUiObject),
                NULL,
                CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                IID_INetConnectionWizardUi,
                (LPVOID*)&m_pWizardUi);
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "CWizProvider::HrCompleteDeferredLoad");
    return hr;
}

//
// Function:    CWizProvider::UlGetMaxPageCount
//
// Purpose:     Queries from the provider the maximum number of pages
//              that it will return.  Subsequent calls to this routine
//              return the cached count without requerying the provider.
//
// Parameters:  pContext [IN] - Context information, supplied either by
//                              Setup or by the wizard itself (when not
//                              launched from Setup).
//
// Returns:     ULONG, Maximum number of pages provider will return.
//
NOTHROW
ULONG
CWizProvider::UlGetMaxPageCount(INetConnectionWizardUiContext *pContext)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT     hr = S_OK;

    if (NULL == m_pWizardUi)
    {
        m_ulMaxPageCount = 0;
    }
    else if (0xFFFFFFFF == m_ulMaxPageCount)
    {
        // Query the provider only once
        m_ulMaxPageCount = 0L;

        COM_PROTECT_TRY
        {
            Assert(NULL != m_pWizardUi);
            Assert(NULL != pContext);

            DWORD dwCount = 0L;
            hr = m_pWizardUi->QueryMaxPageCount(pContext, &dwCount);
            if (S_OK == hr)
            {
                m_ulMaxPageCount = dwCount;
            }
        }
        COM_PROTECT_CATCH
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "CWizProvider::GetMaxPageCount");
    return m_ulMaxPageCount;
}

//
// Function:    CWizProvider::DeleteHPages
//
// Purpose:     Call DestroyPropertySheetPage for each cached page
//
// Parameters:  none
//
// Returns:     nothing
//
VOID CWizProvider::DeleteHPages()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    for (ULONG ulIdx=0; ulIdx < ULPageCount(); ulIdx++)
    {
        DestroyPropertySheetPage(m_rghPages[ulIdx]);
    }
    m_ulPageCnt=0;
}

//
// Function:    CWizProvider::HrAddPages
//
// Purpose:     Calls the AddPages method of a provider's
//              INetConnectionWizardUi interface to allow for the
//              supply of Wizard Pages
//
// Parameters:  pContext [IN] - Context information, supplied either by
//                              Setup or by the wizard itself (when not
//                              launched from Setup).
//
// Returns:     HRESULT, S_OK on success
//
NOTHROW
HRESULT
CWizProvider::HrAddPages(INetConnectionWizardUiContext *pContext)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT     hr = S_OK;

    if (m_pWizardUi)
    {
        COM_PROTECT_TRY
        {
            // Ensure input params are valid
            Assert(NULL != m_pWizardUi);
            Assert(NULL != pContext);
            hr = m_pWizardUi->AddPages(pContext, CWizProvider::FAddPropSheet,
                                       reinterpret_cast<LPARAM>(this));
        }
        COM_PROTECT_CATCH
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "CWizProvider::HrAddPages");
    return hr;
}

//
// Function:    CWizProvider::FAddPropSheet
//
// Purpose:     Callback function for the AddPages API used to accept
//              wizard pages handed back from a provider.
//
// Parameters:  hPage  [IN] - The page to add
//              lParam [IN] - 'this' casted to an LPARAM
//
// Returns:     BOOL, TRUE if the page was successfully added.
//
BOOL
CWizProvider::FAddPropSheet(HPROPSHEETPAGE hPage, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    CWizProvider * pProvider;

    // Validate the input parameters
    if ((0L == lParam) || (NULL == hPage))
    {
        Assert(lParam);
        Assert(hPage);

        TraceHr(ttidWizard, FAL, E_INVALIDARG, FALSE, "CWizProvider::FAddPropSheet");
        return FALSE;
    }

    pProvider = reinterpret_cast<CWizProvider*>(lParam);

    // Grow the buffer if necessary
    if (pProvider->m_ulPageCnt == pProvider->m_ulPageBufferLen)
    {
        HPROPSHEETPAGE* rghPages = reinterpret_cast<HPROPSHEETPAGE*>(
            MemAlloc(sizeof(HPROPSHEETPAGE) * (pProvider->m_ulPageBufferLen + 10)));

        if (NULL == rghPages)
        {
            TraceHr(ttidWizard, FAL, E_OUTOFMEMORY, FALSE, "CWizProvider::FAddPropSheet");
            return FALSE;
        }

        // Copy the existing pages to the new buffer
        if (NULL != pProvider->m_rghPages)
        {
            memcpy(rghPages, pProvider->m_rghPages,
                   sizeof(HPROPSHEETPAGE) * pProvider->m_ulPageBufferLen);
            MemFree(pProvider->m_rghPages);
        }

        pProvider->m_rghPages = rghPages;
        pProvider->m_ulPageBufferLen += 10;
    }

    // Retain the new page
    pProvider->m_rghPages[pProvider->m_ulPageCnt++] = hPage;

    return TRUE;
}

//
// Function:    CWizProvider::HrGetLanInterface
//
// Purpose:     Get the special LAN interface
//
// Parameters:  ppIntr [OUT] - The special LAN specific interface
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CWizProvider::HrGetLanInterface(INetLanConnectionWizardUi ** ppIntr)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr;

    Assert(NULL != ppIntr);
    Assert(NULL != m_pWizardUi);

    *ppIntr = NULL;
    hr = m_pWizardUi->QueryInterface(IID_INetLanConnectionWizardUi,
                                     (LPVOID *)ppIntr);

    TraceHr(ttidWizard, FAL, hr, FALSE, "CWizProvider::HrGetLanInterface");
    return hr;
}

//
// Function:    CWizProvider::HrSpecifyAdapterGuid
//
// Purpose:     To notify the provider of the adapter guid to process
//
// Parameters:  pguid [IN] - The adapter guid to process
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CWizProvider::HrSpecifyAdapterGuid(GUID *pguid)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr;
    INetLanConnectionWizardUi *pIntr = NULL;

    hr = HrGetLanInterface(&pIntr);
    if (SUCCEEDED(hr))
    {
        hr = pIntr->SetDeviceComponent(pguid);
        ReleaseObj(pIntr);
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "CWizProvider::HrSpecifyAdapterGuid");
    return hr;
}

CAdapterList::CAdapterList()
{
    m_prgAdapters           = NULL;     // Adapter array
    m_clAdapters            = 0;        // Count of adapters in the array
    m_lBufSize              = 0;        // Total available slots in the array
    m_lIdx                  = -1;       // Current adapter index
                                        // Range is -1 to m_clAdapters
    m_fAdaptersInstalled    = FALSE;    // No adapters on the machine
}

AdapterEntry * CAdapterList::PAE_Current()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if ((m_lIdx > -1) && (m_lIdx < m_clAdapters))
    {
        Assert(NULL != m_prgAdapters);
        return &m_prgAdapters[m_lIdx];
    }
    else
    {
        return NULL;
    }
}

AdapterEntry * CAdapterList::PAE_Next()
{
    // Find the next, not hidden adapter
    //
    // Hidden adapters are those which were processed by a previous
    // run of setup
    //
    // Increment the index even if the count is zero
    //    m_lIdx == -1 means before the first adapter
    //    m_lIdx == m_clAdapters means after the last adapter
    while (m_lIdx < m_clAdapters)
    {
        m_lIdx++;

        if ((m_lIdx < m_clAdapters) && (!m_prgAdapters[m_lIdx].fHide))
            break;
    }

    Assert(m_lIdx >= -1);
    return PAE_Current();
}

AdapterEntry * CAdapterList::PAE_Prev()
{
    // Find the previous, not hidden adapter
    //
    // Hidden adapters are those which were processed by a previous
    // run of setup
    //
    // Decrement the index even if the count is zero
    //    m_lIdx == -1 means before the first adapter
    //    m_lIdx == m_clAdapters means after the last adapter
    while (-1 < m_lIdx)
    {
        m_lIdx--;

        if ((-1 < m_lIdx) && (!m_prgAdapters[m_lIdx].fHide))
            break;
    }

    Assert(m_lIdx < m_clAdapters);
    return PAE_Current();
}

GUID * CAdapterList::NextAdapter()
{
    AdapterEntry * pae = PAE_Next();
    if (NULL != pae)
        return &(pae->guidAdapter);
    else
        return NULL;
}

GUID * CAdapterList::PrevAdapter()
{
    AdapterEntry * pae = PAE_Prev();
    if (NULL != pae)
        return &(pae->guidAdapter);
    else
        return NULL;
}

GUID * CAdapterList::CurrentAdapter()
{
    AdapterEntry * pae = PAE_Current();
    if (NULL != pae)
        return &(pae->guidAdapter);
    else
        return NULL;
}

VOID CAdapterList::EmptyList()
{
    if (NULL != m_prgAdapters)
    {
        MemFree(m_prgAdapters);
        m_prgAdapters = NULL;
        m_clAdapters  = 0;        // Count of adapters in the array
        m_lBufSize    = 0;        // Total available slots in the array
        m_lIdx        = -1;
    }
}

VOID CAdapterList::HideAllAdapters()
{
    for (LONG lIdx=0; lIdx < m_clAdapters; lIdx++)
        m_prgAdapters[lIdx].fHide = TRUE;
}

VOID CAdapterList::UnhideNewAdapters()
{
    for (LONG lIdx=0; lIdx < m_clAdapters; lIdx++)
        if (m_prgAdapters[lIdx].fNew)
        {
            m_prgAdapters[lIdx].fHide = FALSE;
        }
}



HRESULT CAdapterList::HrAppendEntries(AdapterEntry * pae, ULONG cae)
{
    if (0 == cae)
    {
        return S_OK;
    }

    if (m_clAdapters + (LONG)cae > m_lBufSize)
    {
        // Grow the buffer
        AdapterEntry * prg = reinterpret_cast<AdapterEntry *>(
                    MemAlloc(sizeof(AdapterEntry) * (m_lBufSize + cae + 10)));

        if (NULL == prg)
        {
            TraceHr(ttidWizard, FAL, E_OUTOFMEMORY, FALSE, "CAdapterList::HrAppendEntries");
            return E_OUTOFMEMORY;
        }

        // Copy the existing pages to the new buffer
        if (NULL != m_prgAdapters)
        {
            memcpy(prg, m_prgAdapters, sizeof(AdapterEntry) * m_lBufSize);
            MemFree(m_prgAdapters);
        }

        m_prgAdapters = prg;
        m_lBufSize += (cae + 10);
    }

    memcpy(&m_prgAdapters[m_clAdapters], pae, cae * sizeof(AdapterEntry));
    m_clAdapters += cae;
    return S_OK;
}

//
// Function:    CAdapterList::HrQueryLanAdapters
//
// Purpose:     Query the available LAN adapters.
//
// Parameters:  pnc [IN]     - An INetCfg interface
//              pAL [IN,OUT] - Receives the list of LAN adapters
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CAdapterList::HrQueryLanAdapters(INetCfg * pnc, CAdapterList * pAL)
{
    HRESULT      hr = S_OK;
    CAdapterList ALphys;
    CAdapterList ALvirt;

    TraceTag(ttidWizard, "CAdapterList::HrQueryLanAdapters - Querying available adapters");

    // Enumerate the available adapters
    Assert(NULL != pnc);
    CIterNetCfgComponent nccIter(pnc, &GUID_DEVCLASS_NET);
    INetCfgComponent*    pncc;
    while (SUCCEEDED(hr) &&  (S_OK == (hr = nccIter.HrNext(&pncc))))
    {
        hr = HrIsLanCapableAdapter(pncc);
        if (S_OK == hr)
        {
            DWORD        dw;
            AdapterEntry ae;

            ae.fHide = FALSE;

            // Get the adapter instance guid
            hr = pncc->GetInstanceGuid(&ae.guidAdapter);
            if (FAILED(hr))
                goto NextAdapter;

            // Is it in used in a connection?
            hr = HrIsConnection(pncc);
            if (FAILED(hr))
                goto NextAdapter;

            ae.fProcessed = (S_OK == hr);
            ae.fNew = !ae.fProcessed;       // It's new if it has not been processed

            // Check device, if not present skip it
            //
            hr = pncc->GetDeviceStatus(&dw);
            if (FAILED(hr) || (CM_PROB_DEVICE_NOT_THERE == dw))
            {
                goto NextAdapter;
            }

            // Is this a virtual adapter?
            hr = pncc->GetCharacteristics(&dw);
            if (FAILED(hr))
                goto NextAdapter;

            ae.fVirtual = ((dw & NCF_VIRTUAL) ? TRUE : FALSE);

            // Add the entry to the appropriate list
            if (ae.fVirtual)
            {
                hr = ALvirt.HrAppendEntries(&ae, 1);
            }
            else
            {
                hr = ALphys.HrAppendEntries(&ae, 1);
            }

            if (FAILED(hr))
                goto NextAdapter;

            // Note the fact that LAN capable adapters exist.
            // Because in setup we will show the join page.
            pAL->m_fAdaptersInstalled = TRUE;
        }

NextAdapter:
        ReleaseObj(pncc);
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        // Merge the physical and virtual lists into the pAL input variable
        pAL->EmptyList();
        hr = pAL->HrAppendEntries(ALphys.m_prgAdapters, ALphys.m_clAdapters);
        if (SUCCEEDED(hr))
        {
            hr = pAL->HrAppendEntries(ALvirt.m_prgAdapters, ALvirt.m_clAdapters);
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "CAdapterList::HrQueryUnboundAdapters");
    return hr;
}

HRESULT CAdapterList::HrCreateTypicalConnections(CWizard * pWizard)
{
    HRESULT     hr = S_OK;

    // If there are no adapters in the queue or we have no LAN provider...
    if (0 == pWizard->UlProviderCount())
    {
        return S_OK;
    }

    // Set the current provider
    pWizard->SetCurrentProvider(0);
    CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
    Assert(NULL != pWizProvider);

    TraceTag(ttidWizard, "CAdapterList::HrCreateTypicalConnections - Creating any new LAN connections.");

    // For each adapter in the list create a connection
    for (LONG lIdx=0; lIdx<m_clAdapters; lIdx++)
    {
        AdapterEntry * pae = &m_prgAdapters[lIdx];
        if (!pae->fProcessed)
        {
#if DBG
            WCHAR szGuid[c_cchGuidWithTerm];
            szGuid[0] = 0;
            StringFromGUID2(pae->guidAdapter, szGuid, c_cchGuidWithTerm);
            TraceTag(ttidWizard, "   Guid: %S",szGuid);
#endif

            pae->fProcessed = TRUE;

            // Push the adapter guid onto the provider
            hr = pWizProvider->HrSpecifyAdapterGuid(&(pae->guidAdapter));
            if (SUCCEEDED(hr))
            {
                tstring str;
                INetConnection * pConn = NULL;

                GenerateUniqueConnectionName(pae->guidAdapter, &str, pWizProvider);
                TraceTag(ttidWizard, "   Name: %S", str.c_str());
                hr = (pWizProvider->PWizardUi())->GetNewConnection(&pConn);
                ReleaseObj(pConn);
            }

            // If we failed to create a connection we need to mark it as hidden
            // so it will be skipped in the future.  Eat the error or otherwise
            // setup will just stop.
            //
            if (FAILED(hr))
            {
                TraceHr(ttidWizard, FAL, hr, FALSE, "CAdapterList::HrCreateTypicalConnections - failed creating the connection");
                pae->fHide = TRUE;
                hr = S_OK;
            }
        }
    }

    // Ask the LAN provider to release any cached pointers.
    //
    (VOID)pWizProvider->HrSpecifyAdapterGuid(NULL);

    TraceHr(ttidWizard, FAL, hr, FALSE, "CAdapterList::HrCreateTypicalConnections");
    return hr;
}

HRESULT CAdapterList::HrQueryUnboundAdapters(CWizard * pWizard)
{
    HRESULT hr   = S_OK;
    LONG    lIdx;

    Assert(NULL != pWizard->PNetCfg());

    // Handle the first time the adapters are queried
    if (0 == m_clAdapters)
    {
        hr = HrQueryLanAdapters(pWizard->PNetCfg(), this);
        if (SUCCEEDED(hr))
        {
            // Mark all already bound adapters as hidden so they
            // won't be displayed in the UI
            for (lIdx=0; lIdx<m_clAdapters; lIdx++)
            {
                m_prgAdapters[lIdx].fHide = m_prgAdapters[lIdx].fProcessed;
            }

            // Create connections for all unbound adapters
            hr = HrCreateTypicalConnections(pWizard);
        }
    }
    else
    {
        CAdapterList AL;

        // Query the current adapters
        hr = HrQueryLanAdapters(pWizard->PNetCfg(), &AL);
        if (FAILED(hr))
            goto Error;

        // Eliminate adapters in the original set which are not
        // present in new list
        for (lIdx=0; lIdx<m_clAdapters; lIdx++)
        {
            BOOL fFound   = FALSE;
            LONG lIdxTemp;

            for (lIdxTemp=0; lIdxTemp<AL.m_clAdapters; lIdxTemp++)
            {
                if (m_prgAdapters[lIdx].guidAdapter ==
                    AL.m_prgAdapters[lIdxTemp].guidAdapter)
                {
                    fFound = TRUE;
                    break;
                }
            }

            if (fFound)
            {
                // Compress the located adapter from the new set
                if (lIdxTemp + 1 < AL.m_clAdapters)
                {
                    memcpy(&AL.m_prgAdapters[lIdxTemp],
                           &AL.m_prgAdapters[lIdxTemp+1],
                           sizeof(AdapterEntry) *
                              (AL.m_clAdapters - (lIdxTemp + 1)));
                }
                AL.m_clAdapters--;
            }
            else
            {
                // The source adapter is no longer in the set
                if (lIdx < m_lIdx)
                    m_lIdx--;
            }
        }

        Assert(m_lIdx <= m_clAdapters);
        if (m_lIdx == m_clAdapters)
            m_lIdx = m_clAdapters-1;

        // Create connections for the new adapters
        hr = AL.HrCreateTypicalConnections(pWizard);
        if (FAILED(hr))
            goto Error;

        // Append new adapters to the original list
        hr = HrAppendEntries(AL.m_prgAdapters, AL.m_clAdapters);
    }

Error:
    TraceHr(ttidWizard, FAL, hr, FALSE, "CAdapterList::HrQueryUnboundAdapters");
    return hr;
}

//
// Function:    CWizard::CWizard
//
// Purpose:     ctor for the CWizard class
//
// Parameters:  fLanPages [IN] - Processing LAN pages
//              pdata     [IN] - Wizard context info
//              fDeferred [IN] - Defered loading of providers
//
// Returns:     nothing
//
CWizard::CWizard(BOOL fLanPages, PINTERNAL_SETUP_DATA pData, BOOL fDeferred)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    m_fLanPages             = fLanPages;
    m_fExitNoReturn         = FALSE;
    m_fCoUninit             = FALSE;
    m_fDeferredProviderLoad = fDeferred;
    m_fProviderChanged      = FALSE;
    m_dwFirstPage           = 0;

    m_pConn                 = NULL;
    m_pNetCfg               = NULL;
    m_pUiContext            = NULL;

    Assert(NULL != pData);
    m_pSetupData            = pData;
    m_dwOperationFlags      = pData->OperationFlags;
    m_UMMode                = UM_DEFAULTHIDE;

    m_ulCurProvider         = 0;
    m_ulPageDataCnt         = 0;
    ZeroMemory(m_rgPageData, sizeof(m_rgPageData));

    m_ulWizProviderCnt      = 0;
    m_ulPageDataMRU         = 0;
    ZeroMemory(m_rgpWizProviders, sizeof(m_rgpWizProviders));
}

//
// Function:    CWizard::~CWizard
//
// Purpose:     dtor for the CWizProvider class
//
// Parameters:  none
//
// Returns:     nothing
//
// Note:     Remove CWizard member re-init from dtor.  Present only
//           to ensure complete appropriate release of all members
CWizard::~CWizard()
{
    TraceFileFunc(ttidGuiModeSetup);
    
    ULONG ulIdx;

    // Call the cleanup callback for all registered wizard internal pages
    for (ulIdx = 0; ulIdx < m_ulPageDataCnt; ulIdx++)
    {
        if (m_rgPageData[ulIdx].pfn)
        {
            m_rgPageData[ulIdx].pfn(this, m_rgPageData[ulIdx].lParam);
        }
    }
    m_ulPageDataCnt = 0L;

    // Note: Do not release m_pSetupData, it's only a reference
    m_pSetupData = NULL;

    // Release any providers that had been retained
    for (ulIdx = 0; ulIdx < m_ulWizProviderCnt; ulIdx++)
    {
        Assert(0 != m_rgpWizProviders[ulIdx]);
        delete m_rgpWizProviders[ulIdx];
        m_rgpWizProviders[ulIdx] = NULL;
    }
    m_ulWizProviderCnt = 0L;
    m_ulCurProvider    = 0;

    ReleaseObj(m_pUiContext);
    m_pUiContext       = NULL;

    ReleaseObj(m_pConn);
    m_pConn            = NULL;

    if (m_pNetCfg)
    {
        (VOID)HrUninitializeAndReleaseINetCfg(FCoUninit(), m_pNetCfg, TRUE);
    }
    m_pNetCfg          = NULL;
}

//
// Function:    CWizard::HrCreate
//
// Purpose:     Two phase constructor for the CWizard class
//
// Parameters:  ppWizard [OUT] - If this function succeeds this pointer
//                               will contain the constructed and
//              fLanPages [IN] - Processing LAN pages
//                               initialized CWizard instance.
//              pdata     [IN] - Wizard Context info
//              fDeferred [IN] - Providers are defer loaded
//
// Returns:     HRESULT, S_OK on success
//
NOTHROW
HRESULT CWizard::HrCreate(CWizard ** ppWizard,
                          BOOL       fLanPages,
                          PINTERNAL_SETUP_DATA pData,
                          BOOL       fDeferred)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT            hr = S_OK;
    CWizardUiContext * pContext = NULL;
    CWizard *          pWiz = NULL;
    Assert(NULL != ppWizard);

    // Initialize output parameters
    *ppWizard = NULL;

    // Create the CWizard instance
    pWiz = new CWizard(fLanPages, pData, fDeferred);
    pContext = new CWizardUiContext(pData);

    if ((NULL != pWiz) && (NULL != pContext))
    {
        // Save the new instance
        pWiz->m_pUiContext = pContext;
        *ppWizard = pWiz;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "CWizard::HrCreate");
    return hr;
}

//
// Function:    CWizard::HrAddProvider
//
// Purpose:     To add a connection provider to list of currently loaded
//              connection providers
//
// Parameters:  pPL   [IN] - GUID of conection provider which implements the
//                           INetConnectionWizardUi interface.
//
// Returns:     HRESULT, S_OK on success
//
NOTHROW
HRESULT CWizard::HrAddProvider(ProviderList *pPL)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT         hr  = E_OUTOFMEMORY;
    CWizProvider *  pProvider = NULL;

    Assert(NULL != pPL);
    Assert(m_eMaxProviders > m_ulWizProviderCnt);

    // Restrict the total number of providers managed
    if (m_eMaxProviders > m_ulWizProviderCnt)
    {
        // Instantiate a provider
        hr = CWizProvider::HrCreate(pPL, &pProvider,
                                    FDeferredProviderLoad());
        if (SUCCEEDED(hr))
        {
            m_rgpWizProviders[m_ulWizProviderCnt++] = pProvider;
        }
    }

    TraceHr(ttidWizard, FAL, hr, (REGDB_E_CLASSNOTREG == hr), "CWizard::HrAddProvider");
    return hr;
}

//
// Function:    CWizard::LoadWizProviders
//
// Purpose:     Load the requested wizard providers
//
// Parameters:  ulCntProviders [IN] - Count of guids in rgpguidProviders
//              rgProviders    [IN] - Guids of the providers to load
//
// Returns:     none
//
VOID CWizard::LoadWizProviders( ULONG ulCntProviders,
                                ProviderList * rgProviders)
{
    if (0 == m_ulWizProviderCnt)
    {
        TraceTag(ttidWizard, "Loading requested providers");

        // Load the connections providers used during Setup
        for (UINT nIdx=0; nIdx < ulCntProviders; nIdx++)
        {
            HRESULT hr = HrAddProvider(&rgProviders[nIdx]);
            TraceHr(ttidWizard, FAL, hr, FALSE,
                    "FSetupRequestWizardPages - Failed to load provider #%d",nIdx);
        }
    }
}

//
// Function:    CWizard::HrCreateWizProviderPages
//
// Purpose:     Load the requested wizard provider's pages, if requested.
//              Otherwise return the expected page count.
//
// Parameters:  fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CWizard::HrCreateWizProviderPages(BOOL fCountOnly, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;
    ULONG   ulCnt = 0;
    ULONG   ulIdx;

    Assert(NULL != m_pSetupData);
    Assert(NULL != m_pUiContext);

    // If provider loading was deferred, load them now
    //
    if (FDeferredProviderLoad())
    {
        // Count the maximum number of pages
        for (ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
        {
            HRESULT hrTmp = m_rgpWizProviders[ulIdx]->HrCompleteDeferredLoad();
        }

        // Deferred Load is no longer true.  Reset the state
        //
        DeferredLoadComplete();
    }

    if (fCountOnly)
    {
        // Count the maximum number of pages
        for (ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
        {
            Assert(m_rgpWizProviders[ulIdx]);
            if (m_rgpWizProviders[ulIdx]->UlGetMaxPageCount(m_pUiContext))
            {
                ulCnt += m_rgpWizProviders[ulIdx]->UlGetMaxPageCount(m_pUiContext);
                ulCnt += 1;     // For the guard page
            }
        }

    }
    else
    {
        TraceTag(ttidWizard, "Loading each providers pages");

        bCallRasDlgEntry = TRUE;
        // Load the pages
        for (ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
        {
            Assert(m_rgpWizProviders[ulIdx]);
            Assert(0xFFFFFFFF != m_rgpWizProviders[ulIdx]->UlGetMaxPageCount(m_pUiContext));
            if (0 != m_rgpWizProviders[ulIdx]->UlGetMaxPageCount(m_pUiContext))
            {
                HRESULT hrTmp = m_rgpWizProviders[ulIdx]->HrAddPages(m_pUiContext);
                TraceHr(ttidWizard, FAL, hrTmp, S_FALSE == hrTmp,
                        "CWizard::HrCreateWizProviderPages - %d", ulIdx);

                // We only care about out of memory errors when adding pages.
                // Providers which fail to add pages are removed from the
                // provider list m_rgpWizProviders.
                //
                if (E_OUTOFMEMORY == hrTmp)
                {
                    hr = hrTmp;
                    goto Error;
                }
            }
        }

        // Cull the providers which loaded no pages
        ULONG ulNewCnt = 0;
        for (ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
        {
            if (0 != m_rgpWizProviders[ulIdx]->ULPageCount())
            {
                m_rgpWizProviders[ulNewCnt++] = m_rgpWizProviders[ulIdx];
            }
            else
            {
                delete m_rgpWizProviders[ulIdx];
            }
        }
        m_ulWizProviderCnt = ulNewCnt;

        // Now count how many provider pages were actually loaded, and create
        // their associated guard pages
        for (ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
        {
            if (m_rgpWizProviders[ulIdx]->ULPageCount())
            {
                // Create the guard page for this provider
                // Note that the guard page's id is (CWizProvider *)
                hr = HrCreateGuardPage(this, m_rgpWizProviders[ulIdx]);
                if (SUCCEEDED(hr))
                {
                    // Includes the guard page
                    ulCnt += (m_rgpWizProviders[ulIdx]->ULPageCount() + 1);
                }
                else
                {
                    m_rgpWizProviders[ulIdx]->DeleteHPages();
                    TraceHr(ttidWizard, FAL, hr, FALSE,"CWizard::HrCreateWizProviderPages - Guard Page Create Failed");
                    hr = S_OK;
                }
            }
        }
    }

    (*pcPages) += ulCnt;

Error:
    TraceHr(ttidWizard, FAL, hr, S_FALSE == hr,"CWizard::HrCreateWizProviderPages");
    return hr;
}

//
// Function:    CWizard:AppendProviderPages
//
// Purpose:     Append wizard provider pages and their associated guard pages
//              to the HPROPSHEETPAGE array
//
// Parameters:  pahpsp [IN,OUT] - Ptr to the HPROPSHEETPAGE array which will
//                                receive the provider pages.
//              pcPages    [IN] - Ptr to indicate the number of pages added to
//                                the pahpsp array
// Returns:     nothing
//
VOID CWizard::AppendProviderPages(HPROPSHEETPAGE *pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    ULONG ulIdx;

    // Now count how many provider pages were actually loaded, and create
    // their associated guard pages
    for (ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
    {
        ULONG ulPageCnt = m_rgpWizProviders[ulIdx]->ULPageCount();
        if (ulPageCnt)
        {
            m_rgpWizProviders[ulIdx]->XFerDeleteResponsibilities();

            // Copy the providers pages
            memcpy(&pahpsp[*pcPages], m_rgpWizProviders[ulIdx]->PHPropPages(),
                   sizeof(HPROPSHEETPAGE) * ulPageCnt);
            (*pcPages) += ulPageCnt;

            // Append the guard page
            AppendGuardPage(this, m_rgpWizProviders[ulIdx], pahpsp, pcPages);
        }
    }
}

//
// Function:    CWizard:LoadAndInsertDeferredProviderPages
//
// Purpose:     Insert wizard provider pages and their associated guard pages
//              directly into the wizard
//
// Parameters:  hwndPropSheet [IN] - Handle to the property sheet
//              iddAfterPage  [IN] - Page to insert after.
//
// Returns:     nothing
//
VOID CWizard::LoadAndInsertDeferredProviderPages(HWND hwndPropSheet, UINT iddAfterPage)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr;
    UINT cPages = 0;

    // Create the pages
    //
    hr = HrCreateWizProviderPages(FALSE, &cPages);
    if (SUCCEEDED(hr))
    {
        HPROPSHEETPAGE hPage = GetPageHandle(iddAfterPage);
        Assert(hPage);

        for (ULONG ulIdx=0; ulIdx<m_ulWizProviderCnt; ulIdx++)
        {
            ULONG ulPageCnt = m_rgpWizProviders[ulIdx]->ULPageCount();
            Assert(0xFFFFFFFF != ulPageCnt);
            if (ulPageCnt)
            {
                BOOL fRet;
                HPROPSHEETPAGE hpsp = NULL;

                m_rgpWizProviders[ulIdx]->XFerDeleteResponsibilities();

                // Get the guard page and insert
                //
                cPages = 0;
                AppendGuardPage(this, m_rgpWizProviders[ulIdx], &hpsp, &cPages);
                fRet = PropSheet_InsertPage(hwndPropSheet, hPage, hpsp);
                Assert(fRet);

                // Copy the providers pages.
                do
                {
                    hpsp = (m_rgpWizProviders[ulIdx]->PHPropPages())[ulPageCnt - 1];
                    fRet = PropSheet_InsertPage(hwndPropSheet, hPage, hpsp);
                    Assert(fRet);
                }
                while (--ulPageCnt>0);
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE,"CWizard::LoadAndInsertDeferredProviderPages");
}

//
// Function:    CWizard::RegisterPage
//
// Purpose:     Allow a wizard internal page to register a callback function
//              and a page specific LPARAM along with the HPROPSHEETPAGE.
//
// Parameters:  ulId       [IN] - A page specific value, must be unique amoung
//                                all registering pages
//              hpsp       [IN] - Handle to the property page being registered
//              pfnCleanup [IN] - Callback function to call before CWizard
//                                is destroyed.
//              lParam     [IN] - Page specific parameter.
//
// Returns:     nothing
//
VOID CWizard::RegisterPage(LPARAM ulId, HPROPSHEETPAGE hpsp,
                           PFNPAGECLEANPROC pfnCleanup, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
#if DBG
    Assert(m_eMaxInternalPages + m_eMaxProviders> m_ulPageDataCnt);
    for (UINT nIdx=0;nIdx<m_ulPageDataCnt; nIdx++)
    {
        Assert(ulId != m_rgPageData[nIdx].ulId);
    }
#endif

    m_rgPageData[m_ulPageDataCnt].ulId          = ulId;
    m_rgPageData[m_ulPageDataCnt].hPage         = hpsp;
    m_rgPageData[m_ulPageDataCnt].lParam        = lParam;
    m_rgPageData[m_ulPageDataCnt].PageDirection = NWPD_FORWARD;
    m_rgPageData[m_ulPageDataCnt].pfn           = pfnCleanup;
    m_ulPageDataCnt++;
}

//
// Function:    CWizard::GetPageData
//
// Purpose:     Retrieve data cached by a page via the RegisterPage
//
// Parameters:  ulId       [IN] - A page specific value, must be unique amoung
//                                all registering pages
//
// Returns:     LPARAM, the data associated with the registered page
//
LPARAM CWizard::GetPageData(LPARAM ulId)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(m_ulPageDataMRU < m_ulPageDataCnt);
    if (ulId == m_rgPageData[m_ulPageDataMRU].ulId)
    {
        return (m_rgPageData[m_ulPageDataMRU].lParam);
    }

    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_ulPageDataMRU = ulIdx;
            return (m_rgPageData[ulIdx].lParam);
        }
    }

    Assert(0);  // PageData not found
    return 0L;
}

//
// Function:    CWizard::SetPageData
//
// Purpose:     Set data value for a page registered via the RegisterPage
//
// Parameters:  ulId   [IN] - A page specific value, must be unique amoung
//                            all registering pages
//              lParam [IN] - Data to cache with registered page
//
// Returns:     nothing
//
VOID CWizard::SetPageData(LPARAM ulId, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_rgPageData[ulIdx].lParam = lParam;
            return;
        }
    }

    Assert(0);  // Page not found
}

//
// Function:    CWizard::GetPageIndexFromIID
//
// Purpose:     Set the page index
//
// Parameters:  ulId   [IN] - A page specific value, must be unique amoung
//                            all registering pages
//
// Returns:     nothing
//
UINT  CWizard::GetPageIndexFromIID(LPARAM ulId)
{
   TraceFileFunc(ttidGuiModeSetup);
    
    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            return ulIdx;
        }
    }

    AssertSz(0, "GetPageIndexFromIID: Invalid page of the NCW requested");  // Page not found
    return 0;
}

// Function:    CWizard::GetPageIndexFromHPage
//
// Purpose:     Set the page index
//
// Parameters:  hPage  [IN] - A PROPSHEETPAGE
//
// Returns:     nothing
//
UINT  CWizard::GetPageIndexFromHPage(HPROPSHEETPAGE hPage)
{
   TraceFileFunc(ttidGuiModeSetup);
    
    for (ULONG ulIdx = 0; ulIdx < m_ulPageDataCnt; ulIdx++)
    {
        if (hPage == m_rgPageData[ulIdx].hPage)
        {
            return ulIdx;
        }
    }

    AssertSz(0, "GetPageIndexFromHPage: Invalid page of the NCW requested");  // Page not found
    return 0;
}

//
// Function:    CWizard::GetPageOrigin
//
// Purpose:     Retrieve data cached by a page via the RegisterPage
//
// Parameters:  ulId       [IN] - A page specific value, must be unique amoung
//                                all registering pages
//
// Returns:     LPARAM, the data associated with the registered page
//
LPARAM CWizard::GetPageOrigin(LPARAM ulId, UINT *pOriginIDC)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(m_ulPageDataMRU < m_ulPageDataCnt);
    if (ulId == m_rgPageData[m_ulPageDataMRU].ulId)
    {
        if (pOriginIDC)
        {
            *pOriginIDC = m_rgPageData[m_ulPageDataMRU].PageOriginIDC;
        }
        return (m_rgPageData[m_ulPageDataMRU].PageOrigin);
    }

    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_ulPageDataMRU = ulIdx;
            if (pOriginIDC)
            {
                *pOriginIDC = m_rgPageData[ulIdx].PageOriginIDC;
            }
            return (m_rgPageData[ulIdx].PageOrigin);
        }
    }

    Assert(0);  // PageData not found
    return 0L;
}

//
// Function:    CWizard::SetPageOrigin
//
// Purpose:     Set data value for a page registered via the RegisterPage
//
// Parameters:  ulId    [IN] - A page specific value, must be unique amoung
//                             all registering pages
//              uiOrigin[IN] - Origin of page
//
// Returns:     nothing
//
VOID CWizard::SetPageOrigin(LPARAM ulId, UINT uiOrigin, UINT uiOriginIDC)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_rgPageData[ulIdx].PageOrigin = uiOrigin;
            m_rgPageData[ulIdx].PageOriginIDC = uiOriginIDC;
            return;
        }
    }

    Assert(0);  // Page not found
}


//
// Function:    CWizard::GetPageHandle
//
// Purpose:     Retrieve PropSheet Page handle cached by a page via the
//              RegisterPage
//
// Parameters:  ulId       [IN] - A page specific value, must be unique amoung
//                                all registering pages
//
// Returns:     HPROPSHEETPAGE, the propsheet handle associated with the
//              registered page
//
HPROPSHEETPAGE CWizard::GetPageHandle(LPARAM ulId)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(m_ulPageDataMRU < m_ulPageDataCnt);
    if (ulId == m_rgPageData[m_ulPageDataMRU].ulId)
    {
        return (m_rgPageData[m_ulPageDataMRU].hPage);
    }

    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_ulPageDataMRU = ulIdx;
            return (m_rgPageData[ulIdx].hPage);
        }
    }

    Assert(0);  // Page Handle not found
    return NULL;
}

//
// Function:    CWizard::GetPageDirection
//
// Purpose:     Retrieve page direction associated with a page
//
// Parameters:  ulId       [IN] - A page specific value, must be unique amoung
//                                all registering pages
//
// Returns:     PAGEDIRECTION, the direction of travel associated with the
//              specified page.  Note that the meaning of the direction is
//              up to the page.  The wizard code initializes all the page
//              directions to NWPD_FORWARD before executing a providers pages.
//
PAGEDIRECTION CWizard::GetPageDirection(LPARAM ulId)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(m_ulPageDataMRU < m_ulPageDataCnt);
    if (ulId == m_rgPageData[m_ulPageDataMRU].ulId)
    {
        return (m_rgPageData[m_ulPageDataMRU].PageDirection);
    }

    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_ulPageDataMRU = ulIdx;
            return (m_rgPageData[ulIdx].PageDirection);
        }
    }

    Assert(0);  // PageData not found
    return NWPD_FORWARD;
}

//
// Function:    CWizard::SetPageDirection
//
// Purpose:     Retrieve page direction associated with a page
//
// Parameters:  ulId          [IN] - A page specific value, must be unique amoung
//                                   all registering pages
//              PageDirection [IN] - the new page direction setting
//
// Returns:     nothing
//
VOID CWizard::SetPageDirection(LPARAM ulId, PAGEDIRECTION PageDirection)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    for (ULONG ulIdx=0; ulIdx<m_ulPageDataCnt; ulIdx++)
    {
        if (ulId == m_rgPageData[ulIdx].ulId)
        {
            m_rgPageData[ulIdx].PageDirection = PageDirection;
            return;
        }
    }

    Assert(0);  // PageData not found
}

//
// Function:    CWizardUiContext::AddRef
//
// Purpose:     Increment the reference count on this object
//
// Parameters:  none
//
// Returns:     ULONG
//
STDMETHODIMP_(ULONG) CWizardUiContext::AddRef()
{
    return ++m_cRef;
}

//
// Function:    CWizardUiContext::Release
//
// Purpose:     Decrement the reference count on this object
//
// Parameters:  none
//
// Returns:     ULONG
//
STDMETHODIMP_(ULONG) CWizardUiContext::Release()
{
    ULONG cRef = --m_cRef;

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//
// Function:    CWizardUiContext::QueryInterface
//
// Purpose:     Allows for the querying of alternate interfaces
//
// Parameters:  riid    [IN] - Interface to retrieve
//              ppvObj [OUT] - Retrieved interface if function succeeds
//
// Returns:     HRESULT, S_OK on success E_NOINTERFACE on failure
//
STDMETHODIMP CWizardUiContext::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_INetConnectionWizardUiContext))
    {
        *ppvObj = (LPVOID)this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP CWizardUiContext::GetINetCfg(INetCfg ** ppINetCfg)
{
    HRESULT hr = E_FAIL;

    if (NULL == ppINetCfg)
    {
        hr = E_INVALIDARG;
    }
    else if (NULL != m_pINetCfg)
    {
        *ppINetCfg = m_pINetCfg;
        AddRefObj(*ppINetCfg);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wnetdev.cpp ===
#include "pch.h"
#pragma hdrstop
#include "connutil.h"
#include "resource.h"
#include "ncreg.h"
#include "nsres.h"
#include "wizard.h"
#include "ncsetup.h"
#include "..\lanui\util.h"
#include "ncmisc.h"

// Note: This module needs to touch pWizard as little as possible because it
//       it is deleted before this page is entered.
//


inline BOOL FNetDevPagesAdded(DWORD dw)
{
    return ((dw & 0x10000000) != 0);
}

inline DWORD DwNetDevMarkPagesAdded(DWORD dw)
{
    return (dw | 0x10000000);
}

inline BOOL FNetDevChecked(DWORD dw)
{
    return ((dw & 0x01000000) != 0);
}

inline DWORD NetDevToggleChecked(DWORD dw)
{
    if (dw & 0x01000000)
        return (dw & ~0x01000000);
    else
        return (dw | 0x01000000);
}

typedef struct
{
    SP_CLASSIMAGELIST_DATA cild;
    HIMAGELIST             hImageStateIcons;
    HDEVINFO               hdi;
    HPROPSHEETPAGE         hpsp;        // The wnetdev HPROPSHEETPAGE
    PINTERNAL_SETUP_DATA   pSetupData;
} NetDevInfo;

typedef struct
{
    DWORD            dwFlags;
    DWORD            cPages;
    HPROPSHEETPAGE * phpsp;
    SP_DEVINFO_DATA  deid;
} NetDevItemInfo;

// CHECKED_BY_DEFAULT controls whether the items needing configuration are
// checked by default or not.
//
#define CHECKED_BY_DEFAULT 1

// TRUE if all the devices are selected for configuration.
//
static BOOL bAllSelected=FALSE;

// DevInst of the device whose property page will be displayed after
// the first page on which device selection is shown.
//
static DWORD dwFirstDevInst=0;     

HRESULT HrGetDevicesThatHaveWizardPagesToAdd(HDEVINFO* phdi);
HRESULT HrFillNetDevList(HWND hwndLV, NetDevInfo * pNdi);


// The property page of every isdn device queries if all the
// devices have been selected or not. We return TRUE only if
// all the devices have been selected and the query is from
// the device whose property page is displayed first. This
// is done to prevent the user from coming back to the device
// selection page since there is nothing to do once all the
// devices have been selected.
//

VOID SetSelectedAll (HWND hwndDlg, DWORD dwDevInst)
{
    
    if (dwDevInst == dwFirstDevInst)
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR)bAllSelected );
    }
    else
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (LONG_PTR)FALSE );
    }

    return;

}

HRESULT HrNetDevInitListView(HWND hwndLV, NetDevInfo * pNdi)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    DWORD                       dwStyle;
    RECT                        rc;
    LV_COLUMN                   lvc = {0};
    SP_CLASSIMAGELIST_DATA *    pcild;

    Assert(hwndLV);
    Assert(NULL != pNdi);

    // Set the shared image lists bit so the caller can destroy the class
    // image lists itself
    //
    dwStyle = GetWindowLong(hwndLV, GWL_STYLE);
    SetWindowLong(hwndLV, GWL_STYLE, (dwStyle | LVS_SHAREIMAGELISTS));

    // Create small image lists
    //
    HRESULT hr = HrSetupDiGetClassImageList(&pNdi->cild);
    if (SUCCEEDED(hr))
    {
        AssertSz(pNdi->cild.ImageList, "No class image list data!");
        ListView_SetImageList(hwndLV, pNdi->cild.ImageList, LVSIL_SMALL);
    }
    else
    {
        TraceError("HrSetupDiGetClassImageList returns failure", hr);
        hr = S_OK;
    }

    // Create state image lists
    pNdi->hImageStateIcons = ImageList_LoadBitmapAndMirror(
                                    _Module.GetResourceInstance(),
                                    MAKEINTRESOURCE(IDB_CHECKSTATE),
                                    16,
                                    0,
                                    PALETTEINDEX(6));
    ListView_SetImageList(hwndLV, pNdi->hImageStateIcons, LVSIL_STATE);

    GetClientRect(hwndLV, &rc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rc.right;
    // $REVIEW(tongl 12\22\97): Fix for bug#127472
    // lvc.cx = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    ListView_InsertColumn(hwndLV, 0, &lvc);

    if (SUCCEEDED(hr))
    {
        // Selete the first item
        ListView_SetItemState(hwndLV, 0, LVIS_SELECTED, LVIS_SELECTED);
    }

    TraceError("HrNetDevInitListView", hr);
    return hr;
}

BOOL OnNetDevInitDialog(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    NetDevInfo *   pNdi;
    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    pNdi = reinterpret_cast<NetDevInfo *>(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)pNdi);

    if (NULL != pNdi)
    {
        HWND hwndLV = GetDlgItem(hwndDlg, LVC_NETDEVLIST);
        Assert(hwndLV);

        if (SUCCEEDED(HrNetDevInitListView(hwndLV, pNdi)))
        {
            // Populate the list
            //
            if (NULL != pNdi->hdi)
            {
                (VOID)HrFillNetDevList(hwndLV, pNdi);
            }
        }
    }

    return FALSE;   // We didn't change the default item of focus
}

VOID OnNetDevDestroy(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    NetDevInfo *pNdi = (NetDevInfo *)::GetWindowLongPtr(hwndDlg, DWLP_USER);
    if (NULL != pNdi)
    {
        if (pNdi->cild.ImageList)
        {
            // Destroy the class image list data
            (void) HrSetupDiDestroyClassImageList(&pNdi->cild);
        }

        if (pNdi->hImageStateIcons)
        {
            ImageList_Destroy(pNdi->hImageStateIcons);
        }

        // The cleanup any pages we loaded for the providers
        // but did not add to setup wizard will be done by processing the
        // LVN_DELETEITEM message
        //
    }

    ::SetWindowLongPtr(hwndDlg, DWLP_USER, 0);
    if (NULL != pNdi)
    {
        MemFree(pNdi);
    }
}

//
// Function:    OnNetDevPageNext
//
// Purpose:     Handle the PSN_WIZNEXT notification
//
// Parameters:  hwndDlg - Handle to NetDev dialog
//
// Returns:     BOOL, TRUE if we processed the message
//
BOOL OnNetDevPageNext(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL fRet        = FALSE;      // Accept the default behaviour
    HWND hwndLV      = GetDlgItem(hwndDlg, LVC_NETDEVLIST);
    int nCount       = ListView_GetItemCount(hwndLV);
    int nCountSelected = 0;
    NetDevInfo *pNdi = (NetDevInfo *)::GetWindowLongPtr(hwndDlg, DWLP_USER);

    if ((0 < nCount) && (NULL != pNdi) && (NULL != pNdi->hpsp))
    {
        fRet = TRUE;

        // Loop through the items in the listview if any are checked
        // But have not yet been marked as having their pages added,
        // add the pages and mark the item.
        //

        for (int nIdx=0; nIdx<nCount; nIdx++)
        {
            LV_ITEM          lvi = {0};

            lvi.mask = LVIF_PARAM;
            lvi.iItem = nIdx;

            if (TRUE == ListView_GetItem(hwndLV, &lvi))
            {
                NetDevItemInfo * pndii = (NetDevItemInfo*)lvi.lParam;

                // Add the pages to the wizard if checked in the UI
                // but not already added.
                //

                if (pndii && FNetDevChecked(pndii->dwFlags))
                {

                    // Keep track of how many device have been selected.
                    //
                    nCountSelected++;

                    if (!FNetDevPagesAdded(pndii->dwFlags))
                    {
                        //
                        // Since property pages are added when the device is
                        // selected, any device could end up being the first to
                        // show the property page as the devices could be
                        // selected in a random order. So, we always save the
                        // device instance in case this is the last device
                        // selected.

                        dwFirstDevInst = pndii->deid.DevInst;

                        // Mark the pages as added
                        //
                        pndii->dwFlags = DwNetDevMarkPagesAdded(pndii->dwFlags);

                        for (DWORD nIdx = pndii->cPages; nIdx > 0; nIdx--)
                        {
                            PropSheet_InsertPage(GetParent(hwndDlg),
                                                 (WPARAM)pNdi->hpsp,
                                                 (LPARAM)pndii->phpsp[nIdx - 1]);
                        }

                        // After loading the pages mark the option, uncheckable
                        // (Note: with testing we might be able to support removal)
                        //
                        lvi.state = INDEXTOSTATEIMAGEMASK(SELS_INTERMEDIATE);
                        lvi.mask = LVIF_STATE;
                        lvi.stateMask = LVIS_STATEIMAGEMASK;
                        BOOL ret = ListView_SetItem(hwndLV, &lvi);

                        // Clear the reinstall flag on the device needing configuration
                        //
                        SetupDiSetConfigFlags(pNdi->hdi, &(pndii->deid),
                                              CONFIGFLAG_REINSTALL, SDFBO_XOR);
                    }
                }
            }
        }

        bAllSelected = nCountSelected == nCount;
    }

    return fRet;
}

//
// Function:    OnNetDevPageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification
//
// Parameters:  hwndDlg - Handle to NetDev dialog
//
// Returns:     BOOL, TRUE
//
BOOL OnNetDevPageActivate(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    TraceTag(ttidWizard, "Entering NetDev page...");

    NetDevInfo *pNdi;

    if (0 == ListView_GetItemCount(GetDlgItem(hwndDlg, LVC_NETDEVLIST)))
    {
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
        TraceTag(ttidWizard, "NetDev page refuses activation, no items to display.");
    }
    else
    {
        pNdi = (NetDevInfo *)::GetWindowLongPtr(hwndDlg, DWLP_USER);

        Assert(pNdi);

        if ( pNdi )
        {
            Assert(pNdi->pSetupData);

            if ( pNdi->pSetupData )
            {
                pNdi->pSetupData->ShowHideWizardPage(TRUE);
            }
        }
    }

    // disable the back button (#342922)
    ::SendMessage(GetParent(hwndDlg), PSM_SETWIZBUTTONS, 0, (LPARAM)(PSWIZB_NEXT));

    return TRUE;
}

//
// Function:    OnListViewDeleteItem
//
// Purpose:     Handle the LVN_DELETEITEM notification
//
// Parameters:  hwndList - Handle to listview control
//              pnmh     - Ptr to the NMHDR for this notification
//
// Returns:     none
//
VOID OnListViewDeleteItem(HWND hwndList, LPNMHDR pnmh)
{
    NetDevItemInfo * pndii = NULL;
    NM_LISTVIEW *    pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    LV_ITEM          lvi = {0};

    lvi.mask = LVIF_PARAM;
    lvi.iItem = pnmlv->iItem;

    if (TRUE == ListView_GetItem(hwndList, &lvi))
    {
        NetDevItemInfo * pndii = (NetDevItemInfo*)lvi.lParam;

        // Delete pages held, but that were not added to the wizard
        //
        if (pndii && !FNetDevPagesAdded(pndii->dwFlags))
        {
            for (DWORD nIdx = 0; nIdx < pndii->cPages; nIdx++)
            {
                DestroyPropertySheetPage(pndii->phpsp[nIdx]);
            }

            delete pndii;
        }
    }
}

//
// Function:    OnListViewDeleteItem
//
// Purpose:     Handle the NM_CLICK notification for the listview control
//
// Parameters:  hwndList - Handle to listview control
//              pnmh     - Ptr to the NMHDR for this notification
//
// Returns:     none
//
VOID OnListViewClick(HWND hwndList, LPNMHDR pnmh)
{
    INT iItem;
    DWORD dwpts;
    RECT rc;
    LV_HITTESTINFO lvhti;

    // we have the location
    dwpts = GetMessagePos();

    // translate it relative to the listview
    GetWindowRect(hwndList, &rc);

    lvhti.pt.x = LOWORD(dwpts) - rc.left;
    lvhti.pt.y = HIWORD(dwpts) - rc.top;

    // get currently selected item
    iItem = ListView_HitTest(hwndList, &lvhti);

    // if no selection, or click not on state return false
    if (-1 != iItem)
    {
        // set the current selection
        //
        ListView_SetItemState(hwndList, iItem, LVIS_SELECTED, LVIS_SELECTED);

        if (LVHT_ONITEMSTATEICON != (LVHT_ONITEMSTATEICON & lvhti.flags))
        {
            iItem = -1;
        }

        if (-1 != iItem)
        {
            LV_ITEM lvItem;

            // Get the item
            //
            lvItem.iItem = iItem;
            lvItem.mask = LVIF_PARAM;
            lvItem.iSubItem = 0;

            if (ListView_GetItem(hwndList, &lvItem))
            {
                Assert(lvItem.lParam);
                NetDevItemInfo *pndii = (NetDevItemInfo*)lvItem.lParam;

                // Toggle the state (only if we haven't already added pages)
                //
                if (pndii && !FNetDevPagesAdded(pndii->dwFlags))
                {
                    pndii->dwFlags = NetDevToggleChecked(pndii->dwFlags);
                    if (FNetDevChecked(pndii->dwFlags))
                        lvItem.state = INDEXTOSTATEIMAGEMASK(SELS_CHECKED);
                    else
                        lvItem.state = INDEXTOSTATEIMAGEMASK(SELS_UNCHECKED);

                    lvItem.mask = LVIF_STATE;
                    lvItem.stateMask = LVIS_STATEIMAGEMASK;
                    BOOL ret = ListView_SetItem(hwndList, &lvItem);
                }
            }
        }
    }
}

//
// Function:    dlgprocNetDev
//
// Purpose:     Dialog Procedure for the NetDev wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     INT_PTR
//
INT_PTR CALLBACK dlgprocNetDev( HWND hwndDlg, UINT uMsg,
                                WPARAM wParam, LPARAM lParam )
{
    TraceFileFunc(ttidGuiModeSetup);
    
    BOOL frt = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        OnNetDevInitDialog(hwndDlg, lParam);
        break;

    case WM_DESTROY:
        OnNetDevDestroy(hwndDlg);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            if (LVC_NETDEVLIST == (int)pnmh->idFrom)
            {
                Assert(GetDlgItem(hwndDlg, LVC_NETDEVLIST) == pnmh->hwndFrom);
                if (NM_CLICK == pnmh->code)
                {
                    OnListViewClick(pnmh->hwndFrom, pnmh);
                }
                else if (LVN_DELETEITEM == pnmh->code)
                {
                    OnListViewDeleteItem(pnmh->hwndFrom, pnmh);
                }
            }
            else
            {
                // Must be a property sheet notification
                //
                switch (pnmh->code)
                {
                // propsheet notification
                case PSN_HELP:
                    break;

                case PSN_SETACTIVE:
                    frt = OnNetDevPageActivate(hwndDlg);
                    break;

                case PSN_APPLY:
                    break;

                case PSN_KILLACTIVE:
                    break;

                case PSN_RESET:
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    frt = OnNetDevPageNext(hwndDlg);
                    break;

                default:
                    break;
                }
            }
        }
        break;

    case WM_SELECTED_ALL:

        SetSelectedAll (hwndDlg, (DWORD)lParam);
        frt = TRUE;
    default:
        break;
    }

    return( frt );
}


//
// Function:    NetDevPageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID NetDevPageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    // Nothing to do.  The pNdi is destroyed by the WM_DESTROY message
    // processed above.
}

//
// Function:    CreateNetDevPage
//
// Purpose:     To determine if the NetDev page needs to be shown, and to
//              to create the page if requested.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateNetDevPage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                           BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    HRESULT hr = S_OK;

    if (!IsPostInstall(pWizard) && !IsUnattended(pWizard) && !IsUpgrade(pWizard))
    {
        (*pnPages)++;

        // If not only counting, create and register the page
        if (!fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;
            NetDevInfo * pNdi;

            hr = E_OUTOFMEMORY;

            TraceTag(ttidWizard, "Creating NetDev Page");

            pNdi = reinterpret_cast<NetDevInfo *>(MemAlloc(sizeof(NetDevInfo)));
            if (NULL != pNdi)
            {
                ZeroMemory(pNdi, sizeof(NetDevInfo));

                psp.dwSize = sizeof( PROPSHEETPAGE );
                psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
                psp.pszHeaderTitle = SzLoadIds(IDS_T_NetDev);
                psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_NetDev);
                psp.pszTemplate = MAKEINTRESOURCE(IDD_NetDevSelect);
                psp.hInstance = _Module.GetResourceInstance();
                psp.hIcon = NULL;
                psp.pfnDlgProc = dlgprocNetDev;
                psp.lParam = reinterpret_cast<LPARAM>(pNdi);

                hpsp = CreatePropertySheetPage(&psp);
                if (hpsp)
                {
                    pNdi->pSetupData = pData;
                    pNdi->hpsp = hpsp;
                    pWizard->RegisterPage(IDD_NetDevSelect, hpsp,
                                          NetDevPageCleanup, (LPARAM)pNdi);
                    hr = S_OK;
                }
                else
                {
                    MemFree(pNdi);
                }
            }
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateNetDevPage");
    return hr;
}

//
// Function:    AppendNetDevPage
//
// Purpose:     Add the NetDev page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pWizard     [IN] - Ptr to Wizard Instance
//              pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendNetDevPage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    if (!IsPostInstall(pWizard) && !IsUnattended(pWizard) && !IsUpgrade(pWizard))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_NetDevSelect);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}

//
// Function:    NetDevRetrieveInfo
//
// Purpose:     To retrieve any network device info
//
// Parameters:  pWizard [in] - Contains NetDevInfo blob to populate
//
// Returns:     Nothing
//
VOID NetDevRetrieveInfo(CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(pWizard);

    if (!IsPostInstall(pWizard) && !IsUnattended(pWizard) && !IsUpgrade(pWizard))
    {
        // The pNdi pointer below was cached in two locations.
        // 1) In the HPROPSHEETPAGE lParam for access by the page
        // 2) In the wizard so we can make this NetDevRetrieveInfo call.
        //    This second item was optional and could have been done in the
        //    InitDialog above instead.
        NetDevInfo * pNdi = reinterpret_cast<NetDevInfo *>
                                    (pWizard->GetPageData(IDD_NetDevSelect));

        TraceTag(ttidWizard, "NetDev retrieving info...");

        if (NULL == pNdi)
            return;

        // Query all pages that might be added
        //
        (VOID)HrGetDevicesThatHaveWizardPagesToAdd(&pNdi->hdi);
    }
}


//
// Function:    HrSendFinishInstallWizardFunction
//
// Purpose:     Sends a DIF_NEWDEVICEWIZARD_FINISHINSTALL fcn to the class
//                  installer (and co-installers).  The installers respond
//                  if there are wizard pages to add
//
// Parameters:  hdi [in]        - See Device Installer Api for description
//                                  of the structure.
//              pdeid [in]      - See Device Installer Api
//              pndwd [out]     - See Device Installer Api
//
//
// Returns:     HRESULT. S_OK if successful, or a win32 converted error
//
HRESULT
HrSendFinishInstallWizardFunction(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                  PSP_NEWDEVICEWIZARD_DATA pndwd)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(pndwd);

    ZeroMemory(pndwd, sizeof(*pndwd));

    // Set up the structure to retrieve wizard pages
    //
    pndwd->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pndwd->ClassInstallHeader.InstallFunction =
            DIF_NEWDEVICEWIZARD_FINISHINSTALL;


    // Set up our wizard structure in the device structure
    HRESULT hr = HrSetupDiSetClassInstallParams(hdi, pdeid,
            reinterpret_cast<PSP_CLASSINSTALL_HEADER>(pndwd),
            sizeof(*pndwd));

    if (SUCCEEDED(hr))
    {
        // Call the class installers (and co-installers)
        hr = HrSetupDiCallClassInstaller(DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                hdi, pdeid);

        if (SUCCEEDED(hr) || SPAPI_E_DI_DO_DEFAULT == hr)
        {
            // Get the wizard data
            hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
                        reinterpret_cast<PSP_CLASSINSTALL_HEADER>(pndwd),
                        sizeof(*pndwd));
        }
    }

    TraceError("HrSendFinishInstallWizardFunction", hr);
    return hr;
}

//
// Function:    HrGetDeviceWizardPages
//
// Purpose:     To retrieve wizard pages for a device
//
// Parameters:  hdi [in]        - See Device Installer Api for description
//                                  of the structure.
//              pdeid [in]      - See Device Installer Api
//              pphpsp [out]    - An array of wizard pages for the device
//              pcPages [out]   - The number of pages in pphpsp
//
//
// Returns:     HRESULT. S_OK if successful, or a win32 converted error
//
HRESULT
HrGetDeviceWizardPages(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                       HPROPSHEETPAGE** pphpsp, DWORD* pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(IsValidHandle(hdi));
    Assert(pdeid);
    Assert(pphpsp);
    Assert(pcPages);

    HRESULT hr;
    SP_NEWDEVICEWIZARD_DATA ndwd;

    if (( NULL == pphpsp ) || ( NULL == pcPages ) )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
    else
    {
        *pphpsp = NULL;
        *pcPages = 0;

        // Get the wizard data
        hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
                reinterpret_cast<PSP_CLASSINSTALL_HEADER>(&ndwd),
                sizeof(ndwd));

        // If successful and the correct header is present...
        if (SUCCEEDED(hr) && ndwd.NumDynamicPages &&
           (DIF_NEWDEVICEWIZARD_FINISHINSTALL == ndwd.ClassInstallHeader.InstallFunction))
        {
            // Copy the handles to the out parameter
            //
            *pphpsp = new HPROPSHEETPAGE[ndwd.NumDynamicPages];
            if(pphpsp && *pphpsp)
            {
                CopyMemory(*pphpsp, ndwd.DynamicPages,
                        sizeof(HPROPSHEETPAGE) * ndwd.NumDynamicPages);
                *pcPages = ndwd.NumDynamicPages;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceError("HrGetDeviceWizardPages", hr);
    return hr;
}

//
// Function:    HrFillNetDevList
//
// Purpose:     To populate the listview with text and data of the ISDN
//              cards which need configuration
//
// Parameters:  hwndLV - Handle to the the listview control
//              pNdi   - Net Device Info
//
// Returns:     HRESULT. S_OK if successful, or a win32 converted error
//
HRESULT HrFillNetDevList(HWND hwndLV, NetDevInfo * pNdi)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    SP_DEVINFO_DATA  deid;
    DWORD            dwIndex = 0;
    HRESULT          hr = S_OK;

    Assert(hwndLV);
    Assert(pNdi);
    Assert(pNdi->hdi);
    while (SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(pNdi->hdi, dwIndex, &deid)))
    {
        HPROPSHEETPAGE * phpsp = NULL;
        DWORD            cPages = 0;

        hr = HrGetDeviceWizardPages(pNdi->hdi, &deid, &phpsp, &cPages);
        if (SUCCEEDED(hr) && (cPages > 0))
        {
            NetDevItemInfo * pndii = new NetDevItemInfo;
            if (NULL != pndii)
            {
                ZeroMemory(pndii, sizeof(NetDevItemInfo));
                pndii->phpsp  = phpsp;
                pndii->cPages = cPages;
                pndii->deid   = deid;

#if CHECKED_BY_DEFAULT
                pndii->dwFlags = NetDevToggleChecked(pndii->dwFlags);
#else
                pndii->dwFlags = 0;
#endif

                PWSTR szName = NULL;
                hr = HrSetupDiGetDeviceName(pNdi->hdi, &deid, &szName);
                if (SUCCEEDED(hr))
                {
                    int nIdx;
                    LV_ITEM lvi;
                    int nCount = ListView_GetItemCount(hwndLV);

                    Assert(NULL != szName);
                    Assert(lstrlen(szName));

                    // Add the item info to the list view
                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                    lvi.iItem = nCount;
                    lvi.iSubItem = 0;
#if CHECKED_BY_DEFAULT
                    lvi.state = INDEXTOSTATEIMAGEMASK(SELS_CHECKED);
#else
                    lvi.state = INDEXTOSTATEIMAGEMASK(SELS_UNCHECKED);
#endif
                    lvi.stateMask = LVIS_STATEIMAGEMASK;
                    lvi.pszText = szName;
                    lvi.cchTextMax = lstrlen(lvi.pszText);
                    lvi.iImage = 0;
                    lvi.lParam = (LPARAM)pndii;

                    if (-1 == ListView_InsertItem(hwndLV, &lvi))
                    {
                        TraceError("HrFillNetDevList - ListView_InsertItem", E_OUTOFMEMORY);
                    }

                    delete [](BYTE *)szName;
                }
            }
        }

        dwIndex++;
    }

    // Convert running out of items to S_OK
    //
    if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
    {
        hr = S_OK;
    }

    TraceError("HrFillNetDevList", hr);
    return hr;
}

//
// Function:    HrGetDevicesThatHaveWizardPagesToAdd
//
// Purpose:     To retrieve a list of devices that have wizard pages to add
//                  to the networking wizard
//
// Parameters:  phdi [out] - See Device Install Api for description of the
//                           structure.  This will hold a list of device.
//
// Returns:     HRESULT
//
HRESULT
HrGetDevicesThatHaveWizardPagesToAdd(HDEVINFO* phdi)
{
    TraceFileFunc(ttidGuiModeSetup);
    
    Assert(phdi);

    // initialize out param
    *phdi = NULL;

    // Create a device info list to hold the list of devices
    HRESULT hr = HrSetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL,
            DIGCF_PRESENT, phdi);

    if (SUCCEEDED(hr))
    {
        SP_DEVINFO_DATA         deid;
        DWORD                   dwIndex = 0;
        SP_NEWDEVICEWIZARD_DATA ndwd = {0};
        DWORD                  dwConfigFlags = 0;
        BOOL                    fDeleteDeviceInfo;

        // Enumerate each device in phdi and check if it was a failed install
        // Gui-mode setup marks any device with wizard pages as needing
        // reinstall
        //
        while (SUCCEEDED(hr = HrSetupDiEnumDeviceInfo(*phdi, dwIndex, &deid)))
        {
            fDeleteDeviceInfo = FALSE;
            // Get the current config flags for the device
            // We don't need the return value because we will be checking
            // if pdwConfigFlags is non-null
            (void) HrSetupDiGetDeviceRegistryProperty(*phdi, &deid,
                    SPDRP_CONFIGFLAGS, NULL,
                    (BYTE*)(&dwConfigFlags), sizeof(dwConfigFlags), NULL);


            // Are there any config flags and if so, is the reinstall bit
            // present?
            if (dwConfigFlags & CONFIGFLAG_REINSTALL)
            {
                // Note that we leak this (pdeid) and we don't care because it's
                // only twelve bytes per adapter and only during setup.  Note also
                // that the reason we allocate as opposed to use the stack is so that
                // the data passed lives at least as long as the wizard pages themselves.
                //
                PSP_DEVINFO_DATA pdeid = new SP_DEVINFO_DATA;

                if(pdeid) 
                {
                    CopyMemory(pdeid, &deid, sizeof(SP_DEVINFO_DATA));

                    // Get any wizard pages
                    //
                    hr = HrSendFinishInstallWizardFunction(*phdi, pdeid, &ndwd);

                    if (FAILED(hr) || !ndwd.NumDynamicPages)
                    {
                        // no pages so we will delete this device info from
                        // our list
                        fDeleteDeviceInfo = TRUE;

                        // Clean up because we didn't keep this.
                        //
                        delete pdeid;
                    }
                }

                // clear the config flags for the next pass
                dwConfigFlags = 0;
            }
            else
            {
                // no config flags so there weren't any pages.  We will
                // delete this device info from our list
                fDeleteDeviceInfo = TRUE;
            }

            if (fDeleteDeviceInfo)
            {
                // There were no pages added so remove the device
                // from our list
                (void) SetupDiDeleteDeviceInfo(*phdi, &deid);
            }
            else
            {
                dwIndex++;
            }
        }

        // Failures during this portion should be ignored since we may have
        // successfully added devices to phdi
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    TraceError("HrGetDevicesThatHaveWizardPagesToAdd", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\sipcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       S I P C F G . C P P
//
//  Contents:   The rendering of the UI for the network status monitor's state
//              page. Most of them are ipconfig info
//
//  Notes:
//
//  Author:     NSun   Dec 2000
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "sminc.h"
#include "smpsh.h"
#include "smhelp.h"
#include "ncui.h"
#include "ncreg.h"
#include "ncperms.h"
#include "windutil.h"

extern "C"
{
    #include <dhcpcapi.h>
    extern DWORD DhcpStaticRefreshParams(IN LPWSTR Adapter);
}

#include <dnsapi.h>
#include <nbtioctl.h>
#include "..\lanui\lanui.h"
#include "repair.h"

#define LOCAL_WINS_ADDRESS  0x7f000000  // 127.0.0.0

DWORD WINAPI IPAddrListenProc(
    LPVOID lpParameter   // thread data
);

DWORD WINAPI IPAddrListenProc(
    LPVOID lpParameter   // thread data
);

void DwordToIPAddrString(DWORD dw, tstring * pstr);

const WCHAR c_szTcpipInterfaces[] = L"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\";
const WCHAR c_szAddressType[] = L"AddressType";
const WCHAR c_szActiveConfigurations[] = L"ActiveConfigurations";
const WCHAR c_szAlternate[] = L"Alternate_";
const WCHAR c_szNameServer[] = L"NameServer";
const WCHAR c_szDhcpNameServer[] = L"DhcpNameServer";
const WCHAR c_szNbtDevicePrefix[] = L"\\Device\\NetBT_Tcpip_";

////////////////////////////////////////////////////////////////////////////////////////
// Implementation CPspStatusMonitorIpcfg
//

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::~CPspStatusMonitorIpcfg(
//
//  Purpose:    constructor
//
CPspStatusMonitorIpcfg::CPspStatusMonitorIpcfg(VOID) : 
    m_adwHelpIDs(NULL), 
    m_ncmType(NCM_NONE),
    m_pConn(NULL),
    m_fDhcp(TRUE),
    m_dhcpAddrType(NORMAL_ADDR),
    m_fListenAddrChange(FALSE),
    m_fEnableOpButtons(TRUE),
    m_fIsFirstPage(FALSE)
{
    TraceFileFunc(ttidStatMon);

    ZeroMemory(&m_guidConnection, sizeof(m_guidConnection));

    //Create events that are used to control the thread listening to 
    //address change notifications
    m_hEventAddrListenThreadStopCommand = CreateEvent(NULL, TRUE, FALSE, NULL); 
    m_hEventAddrListenThreadStopNotify = CreateEvent(NULL, TRUE, FALSE, NULL); 
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::~CPspStatusMonitorIpcfg(
//
//  Purpose:    destructor
//
CPspStatusMonitorIpcfg::~CPspStatusMonitorIpcfg(VOID)
{
    if (m_hEventAddrListenThreadStopCommand)
    {
        CloseHandle(m_hEventAddrListenThreadStopCommand);
    }

    if (m_hEventAddrListenThreadStopNotify)
    {
        CloseHandle(m_hEventAddrListenThreadStopNotify);
    }

    CleanupPage();
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::HrInitPage
//
//  Purpose:    Initialize the Network State page class before the page has been
//              created
//
//  Arguments:  pnConnection -   The connection associated with this monitor
//              dwHelpIDs - The context sensitive help ID array 
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorIpcfg::HrInitPage(
            INetConnection * pnConnection,
            const DWORD * adwHelpIDs)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;

    Assert(pnConnection);

    m_adwHelpIDs = adwHelpIDs;

    NETCON_PROPERTIES* pProps;
    hr = pnConnection->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        m_strConnectionName = pProps->pszwName;
        m_guidConnection = pProps->guidId;
        m_ncmType = pProps->MediaType;
        m_dlgAdvanced.InitDialog(m_guidConnection, 
                                g_aHelpIDs_IDD_DIALOG_ADV_IPCFG);
        FreeNetconProperties(pProps);

        if (m_pConn)
        {
            m_pConn->Release();
        }

        m_pConn = pnConnection;
        ::AddRefObj(m_pConn);
    }


    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::CleanupPage
//
//  Purpose:    Cleanup the INetConnection ref count we are holding
//
//  Arguments:  pnConnection -   The connection associated with this monitor
//              dwHelpIDs - The context sensitive help ID array 
//
//  Returns:    Error code
//
VOID CPspStatusMonitorIpcfg::CleanupPage()
{
    TraceFileFunc(ttidStatMon);

    if (m_pConn)
    {
        m_pConn->Release();
        m_pConn = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnInitDialog
//
//  Purpose:    Do the initialization required when the page has just been created
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnInitDialog(
            UINT uMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL & bHandled)
{
    TraceFileFunc(ttidStatMon);

    m_fEnableOpButtons = FHasPermission(NCPERM_Repair);

    if (m_fIsFirstPage)
    {
        // get window handle to propertysheet
        HWND hwndParent=GetParent();
        Assert(hwndParent);

        // center the property sheet on desktop
        FCenterWindow (hwndParent, NULL);
        
        // hide the "ok" button
        //
        ::ShowWindow(::GetDlgItem(hwndParent, IDOK), FALSE);
    }


    //The initialization is in the OnActive method so that we will update the UI
    //when the user active this page

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnActive
//
//  Purpose:    Refresh the UI and start listening to the address change notification
//              when the page has just been created
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    RefreshUI();

    if (m_hEventAddrListenThreadStopCommand && m_hEventAddrListenThreadStopNotify)
    {
        ResetEvent(m_hEventAddrListenThreadStopCommand);
        ResetEvent(m_hEventAddrListenThreadStopNotify);
        QueueUserWorkItem(IPAddrListenProc, this, WT_EXECUTELONGFUNCTION);
        m_fListenAddrChange = TRUE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnKillActive
//
//  Purpose:    Do the operation required when the page is no longer the active one
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    //If the advanced dialog is there, we need to close it
    //This happens when the connection is disabled or media disconnected when
    //we still have the connection status dialog open.
    HWND hwndAdv = m_dlgAdvanced.m_hWnd;
    if (hwndAdv)
    {
        ::SendMessage(hwndAdv, WM_CLOSE, 0, 0);
    }

    //Stop listening to the address change
    if (m_fListenAddrChange)
    {
        StopAddressListenThread();
        m_fListenAddrChange = FALSE;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnDestroy
//
//  Purpose:    Do the operation required when the page is destroyed.
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnDestroy(
            UINT uMsg, 
            WPARAM wParam, 
            LPARAM lParam, 
            BOOL& bHandled)
{
    TraceFileFunc(ttidStatMon);

    //If the advanced dialog is there, we need to close it
    //This happens when the connection is disabled or media disconnected when
    //we still have the connection status dialog open.
    HWND hwndAdv = m_dlgAdvanced.m_hWnd;
    if (hwndAdv)
    {
        ::SendMessage(hwndAdv, WM_CLOSE, 0, 0);
    }

    //Stop listening to the address change
    if (m_fListenAddrChange)
    {
        StopAddressListenThread();
        m_fListenAddrChange = FALSE;
    }
    
    CleanupPage();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnUpdateDisplay
//
//  Purpose:    Handling the user defined PWM_UPDATE_IPCFG_DISPLAY message
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnUpdateDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidStatMon);

    //The thread listening to address changes will post a PWM_UPDATE_IPCFG_DISPLAY
    //message to us once the IP address is changed.
    //We need refresh the UI.
    RefreshUI();
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnRepair
//
//  Purpose:    Repair the connection if the "Repair" button is pressed
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnRepair(
            WORD wNotifyCode, 
            WORD wID, 
            HWND hWndCtl, 
            BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    tstring strMessage = L"";
    HRESULT hr = S_OK;

    {
        CWaitCursor cursorWait;
        CLanConnectionUiDlg dlg;
        HWND hwndDlg = NULL;
        HWND hwndPsh = GetParent();

        Assert(hwndPsh);

        //bring up the dialog to tell the user we're doing the fix
        Assert(m_pConn);
        if (m_pConn)
        {
            dlg.SetConnection(m_pConn);
            hwndDlg = dlg.Create(hwndPsh);

            PCWSTR szw = SzLoadIds(IDS_FIX_REPAIRING);
            ::SetDlgItemText(hwndDlg, IDC_TXT_Caption, szw);
        }

        //do the fix
        hr = HrTryToFix(m_guidConnection, strMessage);

        if (NULL != hwndDlg)
        {
            ::DestroyWindow(hwndDlg);
        }
    }

    //tell users the results
    NcMsgBox(_Module.GetResourceInstance(),
                NULL,
                IDS_FIX_CAPTION,
                IDS_FIX_MESSAGE,
                MB_OK,
                strMessage.c_str());
    
    //We may get new settings. So need to refresh the UI.
    RefreshUI();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnDetails
//
//  Purpose:    Open the Advanced Ipconfig dialog if the "Advanced" button is pressed
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorIpcfg::OnDetails(
            WORD wNotifyCode, 
            WORD wID, 
            HWND hWndCtl, 
            BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    //Since the status dialog will be automatically closed if the connection becomes
    //disconnected or disabled, we also need to force the Advanced dialog to close in 
    //such case.
    //So We cannot launch the Advanced dialog as a modal dialog. Instead, we launch the
    //dialog in another thread.
    QueueUserWorkItem(AdvIpCfgProc, this, WT_EXECUTEDEFAULT);
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorIpcfg::OnContextMenu(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorIpcfg::OnHelp(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::InitializeData
//
//  Purpose:    Cleanup the saved IP settings
//
//  Arguments:  None
//
//  Returns:    None
//
VOID CPspStatusMonitorIpcfg::InitializeData()
{
    TraceFileFunc(ttidStatMon);

    m_strIPAddress = L"";
    m_strSubnetMask = L"";
    m_strGateway = L"";
    m_fDhcp = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::StopAddressListenThread
//
//  Purpose:    Stop the thread that listens to address changes
//
//  Arguments:  None
//
//  Returns:    None
//
VOID CPspStatusMonitorIpcfg::StopAddressListenThread()
{
    TraceFileFunc(ttidStatMon);

    if (m_hEventAddrListenThreadStopCommand && 
        m_hEventAddrListenThreadStopNotify)
    {
        Assert(m_hEventAddrListenThreadStopNotify);

        SetEvent(m_hEventAddrListenThreadStopCommand);
        WaitForSingleObject(m_hEventAddrListenThreadStopNotify, 5000);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::GetIPConfigInfo
//
//  Purpose:    Load the TCP/IP running settings of this connection
//
//  Arguments:  None
//
//  Returns:    error code
//
HRESULT CPspStatusMonitorIpcfg::GetIPConfigInfo()
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    DWORD dwOutBufLen = 0;
    DWORD dwRet = ERROR_SUCCESS;
    
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (dwRet == ERROR_BUFFER_OVERFLOW)
    {
        pAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc(dwOutBufLen);
        if (NULL == pAdapterInfo)
            return E_OUTOFMEMORY;
    }
    else if (ERROR_SUCCESS == dwRet)
    {
        return E_FAIL;
    }
    else
    {
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (ERROR_SUCCESS != dwRet)
    {
        CoTaskMemFree(pAdapterInfo);
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    WCHAR   wszGuid[c_cchGuidWithTerm];
    ::StringFromGUID2(m_guidConnection, wszGuid,
        c_cchGuidWithTerm);

    BOOL fFound = FALSE;
    PIP_ADAPTER_INFO pAdapterInfoEnum = pAdapterInfo;
    while (pAdapterInfoEnum)
    {
        USES_CONVERSION;
        
        if (lstrcmp(wszGuid, A2W(pAdapterInfoEnum->AdapterName)) == 0)
        {
            m_strIPAddress = A2W(pAdapterInfoEnum->IpAddressList.IpAddress.String);
            m_strSubnetMask = A2W(pAdapterInfoEnum->IpAddressList.IpMask.String);
            m_strGateway = A2W(pAdapterInfoEnum->GatewayList.IpAddress.String);
            m_fDhcp = pAdapterInfoEnum->DhcpEnabled;
            fFound = TRUE;
            break;
        }
        
        pAdapterInfoEnum = pAdapterInfoEnum->Next;
    }

    CoTaskMemFree(pAdapterInfo);

    if (!fFound)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    else
    {
        if (m_fDhcp)
        {
            hr = HrGetAutoNetSetting(wszGuid, &m_dhcpAddrType);
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::RefreshUI
//
//  Purpose:    refresh the UI
//
//  Arguments:  none
//
//  Returns:    none
//
VOID CPspStatusMonitorIpcfg::RefreshUI()
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;
    BOOL fZeroIP = FALSE;
    
    InitializeData();
    hr = GetIPConfigInfo();
    if (FAILED(hr))
    {
        ::SetWindowText(GetDlgItem(IDC_STATE_SOURCE), SzLoadString(_Module.GetResourceInstance(), IDS_ADDRESS_UNAVALABLE));
        ::SetWindowText(GetDlgItem(IDC_STATE_IPADDR), SzLoadString(_Module.GetResourceInstance(), IDS_ADDRESS_UNAVALABLE));
        ::SetWindowText(GetDlgItem(IDC_STATE_SUBNET), SzLoadString(_Module.GetResourceInstance(), IDS_ADDRESS_UNAVALABLE));
        ::SetWindowText(GetDlgItem(IDC_STATE_GATEWAY), SzLoadString(_Module.GetResourceInstance(), IDS_ADDRESS_UNAVALABLE));

        ::EnableWindow(GetDlgItem(IDC_STATE_BTN_REPAIR), FALSE);
        ::EnableWindow(GetDlgItem(IDC_STATE_BTN_DETAIL), FALSE);

        return;
    }
    else
    {
        ::EnableWindow(GetDlgItem(IDC_STATE_BTN_REPAIR), TRUE);
        ::EnableWindow(GetDlgItem(IDC_STATE_BTN_DETAIL), TRUE);
    }

    fZeroIP = (m_strIPAddress == L"0.0.0.0");
    
    ::SetWindowText(GetDlgItem(IDC_STATE_IPADDR), m_strIPAddress.c_str());
    ::SetWindowText(GetDlgItem(IDC_STATE_SUBNET), m_strSubnetMask.c_str());
    
    ::SetWindowText(GetDlgItem(IDC_STATE_GATEWAY), m_strGateway.c_str());

    if (!m_fDhcp)
    {
        ::SetWindowText(GetDlgItem(IDC_STATE_SOURCE), 
                    SzLoadString(_Module.GetResourceInstance(), IDS_STATIC_CFG));
    }
    else
    {
        UINT idString = IDS_DHCP;
        switch(m_dhcpAddrType)
        {
        case NORMAL_ADDR:
            idString = IDS_DHCP;
            break;
        case AUTONET_ADDR:
            idString = IDS_AUTONET;
            break;
        case ALTERNATE_ADDR:
            idString = IDS_ALTERNATE_ADDR;
            break;
        }
        ::SetWindowText(GetDlgItem(IDC_STATE_SOURCE), 
                    SzLoadString(_Module.GetResourceInstance(), idString));
                                
    }

    if (fZeroIP)
    {
        ::SetWindowText(GetDlgItem(IDC_STATE_SOURCE), 
                    SzLoadString(_Module.GetResourceInstance(), IDS_INVALID_ADDR));
    }

    if (!m_fEnableOpButtons)
    {
        ::EnableWindow(GetDlgItem(IDC_STATE_BTN_REPAIR), FALSE);
    }
    
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::IPAddrListenProc
//
//  Purpose:    the call back proc to launch the thead to listen to address changes
//
//  Arguments:  lpParameter - the CPspStatusMonitroIpcfg instance
//
//  Returns:    0
//
DWORD WINAPI CPspStatusMonitorIpcfg::IPAddrListenProc(
  LPVOID lpParameter   // thread data
)
{
    TraceFileFunc(ttidStatMon);

    HANDLE hEvents[2];
    OVERLAPPED NotifyAddrOverLapped;
    HANDLE     hNotifyAddr = NULL;
    DWORD dwRet = 0;
    CPspStatusMonitorIpcfg * pDialog = (CPspStatusMonitorIpcfg*) lpParameter;

    hEvents[0] = pDialog->m_hEventAddrListenThreadStopCommand;
    ZeroMemory(&NotifyAddrOverLapped, sizeof(OVERLAPPED));
    NotifyAddrOverLapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL); 
    if (NotifyAddrOverLapped.hEvent)
    {        
        if (ERROR_IO_PENDING == NotifyAddrChange(&hNotifyAddr, &NotifyAddrOverLapped))
        {
            hEvents[1] = NotifyAddrOverLapped.hEvent;

            do
            {
                dwRet = WaitForMultipleObjects(
                                    celems(hEvents),
                                    hEvents,
                                    FALSE,
                                    INFINITE);

                if (WAIT_OBJECT_0 + 1 == dwRet)
                {
                    ResetEvent(hEvents[1]);
                    ::PostMessage(pDialog->m_hWnd, PWM_UPDATE_IPCFG_DISPLAY, 0, 0);

                    HWND hwndAdv = pDialog->m_dlgAdvanced.m_hWnd;

                    if (hwndAdv)
                    {
                        ::PostMessage(hwndAdv, PWM_UPDATE_IPCFG_DISPLAY, 0, 0);
                    }

                    hNotifyAddr = NULL;

                    if (ERROR_IO_PENDING != NotifyAddrChange(&hNotifyAddr, &NotifyAddrOverLapped))
                    {
                        TraceTag(ttidStatMon, "Could not register for IP address change notifications");
                        break;
                    }
                }
                else
                {
                    break;
                }
            }while (TRUE);

        }
        else
        {
            TraceTag(ttidStatMon, "Could not register for IP address change notifications");
        }
    }

    if (hNotifyAddr)
    {
        CancelIo(hNotifyAddr);
    }
    
    SetEvent(pDialog->m_hEventAddrListenThreadStopNotify);

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::AdvIpCfgProc
//
//  Purpose:    the call back proc to launch the advanced dialog in another thread
//
//  Arguments:  lpParameter - the CPspStatusMonitroIpcfg instance
//
//  Returns:    0
//
DWORD WINAPI CPspStatusMonitorIpcfg::AdvIpCfgProc(
  LPVOID lpParameter   // thread data
)
{
    TraceFileFunc(ttidStatMon);

    CPspStatusMonitorIpcfg * pMainDialog = (CPspStatusMonitorIpcfg*) lpParameter;

    Assert(pMainDialog);

    //disable the status propsheet
    HWND hwndPsh = pMainDialog->GetParent();
    Assert(hwndPsh);
    
    pMainDialog->m_dlgAdvanced.DoModal(hwndPsh);

    return 0;
}


///////////////////////////////////////////////////////////////////////
// Implementation of CAdvIpcfgDlg
//

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::CAdvIpcfgDlg
//
//  Purpose:    constructor
//
CAdvIpcfgDlg::CAdvIpcfgDlg() : 
    m_hList(NULL), 
    m_adwHelpIDs(NULL)
{
    TraceFileFunc(ttidStatMon);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::OnInitDialog
//
//  Purpose:    do the initialize required when the dialog is created
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CAdvIpcfgDlg::OnInitDialog(
                UINT uMsg, 
                WPARAM wParam, 
                LPARAM lParam, 
                BOOL& fHandled
                )
{
    TraceFileFunc(ttidStatMon);

    const UINT c_nColumns = 2;

    LV_COLUMN lvCol = {0};
    RECT rect;
    int iIndex = 0;
    int iParamColWidth = 0; 

    m_hList = GetDlgItem(IDC_LIST_IPCFG);
    
    ::GetClientRect(m_hList, &rect);
    iParamColWidth = (rect.right/c_nColumns);
    
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = iParamColWidth;

    lvCol.pszText = (PWSTR) SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_PRAMETER);
    iIndex = ListView_InsertColumn(m_hList, iIndex, &lvCol);
    iIndex++;

    lvCol.cx = rect.right - iParamColWidth;
    lvCol.pszText = (PWSTR) SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_VALUE);
    iIndex = ListView_InsertColumn(m_hList, iIndex, &lvCol);

    ListView_SetExtendedListViewStyle(m_hList, LVS_EX_FULLROWSELECT);
    PopulateListControl();

    return 0;
}

VOID CAdvIpcfgDlg::AddToListControl(int iIndex, LPWSTR szFirst, LPWSTR szSecond)
{
    TraceFileFunc(ttidStatMon);

    LV_ITEM lvi = {0};
    lvi.mask = LVIF_PARAM;
    lvi.lParam = 0;

    lvi.iItem = iIndex;
    ListView_InsertItem(m_hList, &lvi);
    
    ListView_SetItemText(m_hList, 
                        iIndex, 
                        0, 
                        szFirst);

    ListView_SetItemText(m_hList,
                        iIndex,
                        1,
                        szSecond);

}
//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::PopulateListControl
//
//  Purpose:    load the connection running settings and show them up in 
//              the list control
//
//  Arguments:  none
//
//  Returns:    error code
//
HRESULT CAdvIpcfgDlg::PopulateListControl()
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    DWORD dwOutBufLen = 0;
    DWORD dwRet = ERROR_SUCCESS;
    tstring strDns = L"";
    WCHAR   wszGuid[c_cchGuidWithTerm] = {0};
    tstring strTemp = L"";
    tstring strTemp2 = L"";
    BOOL fDisplayDhcpItems = TRUE;

    ListView_DeleteAllItems(m_hList);
    ::StringFromGUID2(m_guidConnection, wszGuid,
                    c_cchGuidWithTerm);

    //Get other settings
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (dwRet == ERROR_BUFFER_OVERFLOW)
    {
        pAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc(dwOutBufLen);
        if (NULL == pAdapterInfo)
            return E_OUTOFMEMORY;
    }
    else if (ERROR_SUCCESS == dwRet)
    {
        return E_FAIL;
    }
    else
    {
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (ERROR_SUCCESS != dwRet)
    {
        CoTaskMemFree(pAdapterInfo);
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    BOOL fFound = FALSE;
    PIP_ADAPTER_INFO pAdapterInfoEnum = pAdapterInfo;
    while (pAdapterInfoEnum)
    {
        USES_CONVERSION;
        
        if (lstrcmp(wszGuid, A2W(pAdapterInfoEnum->AdapterName)) == 0)
        {
            fFound = TRUE;
            break;
        }
        
        pAdapterInfoEnum = pAdapterInfoEnum->Next;
    }

    if (!fFound)
    {
        CoTaskMemFree(pAdapterInfo);
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    
    int iTemp = 0;
    int iIndex = 0;
    struct tm * ptmLocalTime = NULL;
    WCHAR szBuf[8];

    fDisplayDhcpItems = !!pAdapterInfoEnum->DhcpEnabled;
    if (fDisplayDhcpItems)
    {
        DHCP_ADDRESS_TYPE AddrType;
        if (SUCCEEDED(HrGetAutoNetSetting(wszGuid, &AddrType)))
        {
            fDisplayDhcpItems = (AUTONET_ADDR != AddrType && ALTERNATE_ADDR != AddrType);
        }
    }
    
    LV_ITEM lvi = {0};
    lvi.mask = LVIF_PARAM;
    lvi.lParam = 0;

    //Physical Address
    strTemp = L"";
    for (UINT i = 0; i < pAdapterInfoEnum->AddressLength; i++)
    {
        if (i > 0)
        {
            strTemp += L"-";
        }
        
        wsprintf(szBuf, L"%02X", pAdapterInfoEnum->Address[i]);
        strTemp += szBuf;
    }

    AddToListControl(iIndex, 
                    (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_PH_ADDR),
                    (LPWSTR)strTemp.c_str());

    iIndex++;
        

    //IP Address and subnet mask
    iTemp = IPAddrToString(&pAdapterInfoEnum->IpAddressList, &strTemp, &strTemp2);
    //if the ip is zero, don't display DHCP items
    if (L"0.0.0.0" == strTemp)
    {
        fDisplayDhcpItems = FALSE;
    }

    
    iIndex += AddIPAddrToListControl(iIndex,
                                &pAdapterInfoEnum->IpAddressList,
                                (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_IPADDR),
                                (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_SUBNET),
                                TRUE
                                );


    //Default Gateway
    iTemp = IPAddrToString(&pAdapterInfoEnum->GatewayList, &strTemp);
    iIndex += AddIPAddrToListControl(iIndex,
                                &pAdapterInfoEnum->GatewayList,
                                (LPWSTR)SzLoadString(_Module.GetResourceInstance(), 
                                                    (iTemp > 1) ? IDS_IPCFG_DEFGW_PL : IDS_IPCFG_DEFGW)
                                );
    
    //Dhcp Server
    if (fDisplayDhcpItems)
    {
        IPAddrToString(&pAdapterInfoEnum->DhcpServer, &strTemp);
        AddToListControl(iIndex, 
                    (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_DHCP),
                    (LPWSTR)strTemp.c_str());
        iIndex++;
    }

    //Lease Obtain time
    if (fDisplayDhcpItems)
    {
        if (SUCCEEDED(FormatTime(pAdapterInfoEnum->LeaseObtained, strTemp)))
        {
            AddToListControl(iIndex,
                (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_LEASE_OBT),
                (LPWSTR)strTemp.c_str());
            iIndex++;
        }

        //Lease expire time
        if (SUCCEEDED(FormatTime(pAdapterInfoEnum->LeaseExpires, strTemp)))
        {
            AddToListControl(iIndex,
                (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_LEASE_EXP),
                (LPWSTR)strTemp.c_str());
            iIndex++;
        }
    }
    
    //Get the DNS servers
    HKEY hkeyInterface = NULL;
    tstring strInterfaceKey = c_szTcpipInterfaces;

    strInterfaceKey += wszGuid;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    strInterfaceKey.c_str(), 
                    KEY_QUERY_VALUE, 
                    &hkeyInterface);
    if (SUCCEEDED(hr))
    {
        BOOL fStaticDns = TRUE;
        int iPos = 0;
        Assert(hkeyInterface);

        hr = HrRegQueryString(hkeyInterface,
                              c_szNameServer,
                              &strTemp);

        if (0 == strTemp.size() || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            HrRegQueryString(hkeyInterface,
                            c_szDhcpNameServer,
                            &strTemp);

            fStaticDns = FALSE;
        }

        //the static DNS server list is in the format "x.x.x.x,y.y.y.y" and
        //the dhcp DNS server list is in the format "x.x.x.x y.y.y.y". We need to
        //re-format them to the same style

        //fFirst is used to identify whether this is the first DNS server
        int fFirst = TRUE; 
        while(tstring::npos != (iPos = strTemp.find(fStaticDns ? L',' :L' ')))
        {
            strDns = strTemp.substr(0, iPos);
            strTemp = strTemp.erase(0, iPos + 1);

            AddToListControl(iIndex,
                fFirst ? (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_DNS_PL) : L"",
                (LPWSTR)strDns.c_str());;
            iIndex++;
            fFirst = FALSE;
        }

        strDns = strTemp;
        AddToListControl(iIndex,
            fFirst ? (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_DNS) : L"",
            (LPWSTR)strDns.c_str());;

        iIndex++;

        RegCloseKey(hkeyInterface);
    }

    iIndex += AddWinsServersToList(iIndex);

    if (pAdapterInfo)
    {
        CoTaskMemFree(pAdapterInfo);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::OnClose
//
//  Purpose:    handle the WM_CLOSE message
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CAdvIpcfgDlg::OnClose(
                UINT uMsg, 
                WPARAM wParam, 
                LPARAM lParam, 
                BOOL& fHandled
                )
{
    TraceFileFunc(ttidStatMon);

    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::OnOk
//
//  Purpose:    close the dialog when the OK button is pressed
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CAdvIpcfgDlg::OnOk(
                WORD wNotifyCode, 
                WORD wID, 
                HWND hWndCtl, 
                BOOL& fHandled
                )
{
    TraceFileFunc(ttidStatMon);

    EndDialog(IDOK);
    return 0;
}

LRESULT CAdvIpcfgDlg::OnCancel(
                WORD wNotifyCode, 
                WORD wID, 
                HWND hWndCtl, 
                BOOL& fHandled
                )
{
    TraceFileFunc(ttidStatMon);

    EndDialog(IDCANCEL);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::OnUpdateDisplay
//
//  Purpose:    Handling the user defined PWM_UPDATE_IPCFG_DISPLAY message
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CAdvIpcfgDlg::OnUpdateDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidStatMon);

    //The thread listening to address changes will post a PWM_UPDATE_IPCFG_DISPLAY
    //message to us once the IP address is changed.
    //We need refresh the UI.
    PopulateListControl();
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CAdvIpcfgDlg::OnContextMenu(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorIpcfg::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CAdvIpcfgDlg::OnHelp(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

LRESULT 
CAdvIpcfgDlg::OnListKeyDown(int idCtrl, 
                            LPNMHDR pnmh, 
                            BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    LPNMLVKEYDOWN pnmlv = (LPNMLVKEYDOWN) pnmh;

    if (NULL == pnmlv)
        return 0;

    if (IDC_LIST_IPCFG != idCtrl)
        return 0;

    BOOL fControlDown = (GetKeyState(VK_CONTROL) < 0);

    switch (pnmlv->wVKey)
    {
    case VK_INSERT:
    case 'c':
    case 'C':
        CopyListToClipboard();
        break;
    }

    return 0;
}

VOID CAdvIpcfgDlg::CopyListToClipboard()
{
    TraceFileFunc(ttidStatMon);

    WCHAR szBuff[256] = {0};
    int iIndex = -1;
    tstring str = L"";
    BOOL fFirst = TRUE;

    while(-1 != (iIndex = ListView_GetNextItem(m_hList, iIndex, LVNI_ALL)))
    {
        szBuff[0] = 0;
        ListView_GetItemText(m_hList, iIndex, 0, szBuff, celems(szBuff) - 1);

        if (0 == lstrlen(szBuff))
        {
            str += L", ";
        }
        else
        {
            if (!fFirst)
            {
                str += L"\r\n";
            }
            else
            {
                fFirst = FALSE;
            }
            
            str += szBuff;
            str += L": ";
        }

        szBuff[0] = 0;
        ListView_GetItemText(m_hList, iIndex, 1, szBuff, celems(szBuff) -1);
        str += szBuff;
    }

    int nLength = str.length() + 1;
    nLength *= sizeof(WCHAR);

    HLOCAL hMem = LocalAlloc(LPTR, nLength);

    if (hMem)
    {
        memcpy(hMem, str.c_str(), nLength);
        if (!OpenClipboard())
        {
            LocalFree(hMem);
        }
        else
        {
            EmptyClipboard();
            SetClipboardData(CF_UNICODETEXT, hMem);
            CloseClipboard();
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::AddIPAddrToListControl
//
//  Purpose:    helper routine to add a list of IP address/mask pairs to the list control
//
//  Arguments:  iStartIndex         [in] the starting index of the list control
//              pszAddrDescription  [in] the description of the address
//              pszMaskDescription  [in] the description of the mask, this can be null
//              fShowDescriptionForMutliple [in] whether show the description for each entry if we have multiple entris
//              pAddrList           [in] the address/mask pair list
//
//  Returns:    number of IP addresses in the string
//
int CAdvIpcfgDlg::AddIPAddrToListControl(int iStartIndex,
                                         PIP_ADDR_STRING pAddrList,
                                         LPWSTR pszAddrDescription,
                                         LPWSTR pszMaskDescription,
                                         BOOL fShowDescriptionForMutliple
                                         )
{
    TraceFileFunc(ttidStatMon);

    Assert(pAddrList);
    Assert(pszAddrDescription);

    if (NULL == pAddrList || NULL == pszAddrDescription)
        return 0;

    tstring strTmp = L"";
    BOOL fFirst = TRUE;
    int iIndex = iStartIndex;
    PIP_ADDR_STRING pCurrentAddr = NULL;

    for (pCurrentAddr = pAddrList; NULL != pCurrentAddr; pCurrentAddr = pCurrentAddr->Next)
    {
        USES_CONVERSION;

        strTmp = A2W(pCurrentAddr->IpAddress.String);

        AddToListControl(iIndex, 
                        (fFirst || fShowDescriptionForMutliple) ? pszAddrDescription : L"", 
                        (LPWSTR) strTmp.c_str());

        iIndex++;

        if (pszMaskDescription)
        {
            strTmp = A2W(pCurrentAddr->IpMask.String);
            AddToListControl(iIndex,
                            (fFirst || fShowDescriptionForMutliple) ? pszMaskDescription : L"",
                            (LPWSTR) strTmp.c_str());
            iIndex++;
        }

        if (fFirst)
        {
            fFirst = FALSE;
        }
    }
    

    return iIndex - iStartIndex;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::IPAddrToString
//
//  Purpose:    helper routine to convert IP_ADDR_STRING to a string
//
//  Arguments:  pAddrList -     the IP_ADDR_STRING
//              pstrAddr [out]  the string contains the IP address
//              pstrMask [out]  the string contains the Mask
//
//  Returns:    number of IP addresses in the string
//
int CAdvIpcfgDlg::IPAddrToString(
                PIP_ADDR_STRING pAddrList, 
                tstring * pstrAddr, 
                tstring * pstrMask
                )
{
    TraceFileFunc(ttidStatMon);

    int i = 0;
    PIP_ADDR_STRING pCurrentAddr = NULL;

    if (pstrAddr)
    {
        *pstrAddr = L"";
    }

    if (pstrMask)
    {
        *pstrMask = L"";
    }

    for (pCurrentAddr = pAddrList; NULL != pCurrentAddr; pCurrentAddr = pCurrentAddr->Next)
    {
        USES_CONVERSION;

        if (pstrAddr)
        {
            if (0 != i)
            {
                (*pstrAddr) += L", ";
            }

            (*pstrAddr) += A2W(pCurrentAddr->IpAddress.String);
        }

        if (pstrMask)
        {
            if (0 != i)
            {
                (*pstrMask) += L", ";
            }

            (*pstrMask) += A2W(pCurrentAddr->IpMask.String);

        }

        i++;
    }

    return i;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::AddWinsServersToList
//
//  Purpose:    Get the list of WINS servers from the NBT driver and add them
//              into the list control
//
//  Arguments:  iStartIndex [in]  -     the starting index of the list control
//                                      that we should use to add the WINS servers
//
//  Returns:    number of entris added to the list control
//
int CAdvIpcfgDlg::AddWinsServersToList(int iStartIndex)
{
    TraceFileFunc(ttidStatMon);

    int iIndex = iStartIndex;
    WCHAR   wszGuid[c_cchGuidWithTerm] = {0};
    
    ::StringFromGUID2(m_guidConnection, wszGuid,
                    c_cchGuidWithTerm);

    HANDLE hNbt = INVALID_HANDLE_VALUE;
    tWINS_NODE_INFO NodeInfo = {0};
    int nCount = 0;
    tstring strTemp = L"";

    if (FAILED(OpenNbt(wszGuid, &hNbt)))
    {
        AddToListControl(iStartIndex, 
                    (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_WINS),
                    (LPWSTR)L"");
        return 1;
    }

    do
    {
        NTSTATUS status = 0;
        DWORD dwSize = 0;

        if (!DeviceIoControl(hNbt,
                        IOCTL_NETBT_GET_WINS_ADDR,
                        NULL,
                        0,
                        (LPVOID)&NodeInfo,
                        sizeof(NodeInfo),
                        &dwSize,
                        NULL))
        {
            break;
        }

        if( LOCAL_WINS_ADDRESS == NodeInfo.NameServerAddress ||
            INADDR_ANY == NodeInfo.NameServerAddress ||
            INADDR_BROADCAST == NodeInfo.NameServerAddress ) 
        {
            break;  
        }

        BOOL fHaveSecondWins = !(LOCAL_WINS_ADDRESS == NodeInfo.BackupServer ||
                                INADDR_ANY == NodeInfo.BackupServer ||
                                INADDR_BROADCAST == NodeInfo.BackupServer); 
                                
        DwordToIPAddrString(NodeInfo.NameServerAddress, &strTemp);
        AddToListControl(iIndex, 
                    (LPWSTR)SzLoadString(_Module.GetResourceInstance(), 
                                        fHaveSecondWins ? IDS_IPCFG_WINS_PL : IDS_IPCFG_WINS),
                    (LPWSTR)strTemp.c_str());
        iIndex++;

        if (!fHaveSecondWins)
        {
            break;
        }

        DwordToIPAddrString(NodeInfo.BackupServer, &strTemp);
        AddToListControl(iIndex, 
                    (LPWSTR)L"",
                    (LPWSTR)strTemp.c_str());
        iIndex++;

        int NumOfServers = (NodeInfo.NumOtherServers <= MAX_NUM_OTHER_NAME_SERVERS) ? 
                                NodeInfo.NumOtherServers : MAX_NUM_OTHER_NAME_SERVERS;

        for (int i = 0; i < NumOfServers; i++)
        {
            if( LOCAL_WINS_ADDRESS == NodeInfo.Others[i] ||
                INADDR_ANY == NodeInfo.Others[i] ||
                INADDR_BROADCAST == NodeInfo.Others[i] ) 
            {
                break;  
            }

            DwordToIPAddrString(NodeInfo.Others[i], &strTemp);
            AddToListControl(iIndex,
                            (LPWSTR)L"",
                            (LPWSTR)strTemp.c_str());
            iIndex++;
        }

    } while (FALSE);

    
    NtClose(hNbt);

    int iRet = iIndex - iStartIndex;

    //if somehow we didn't add any WINS entris to the list, we need to add an empty "WINS Server" entry to the list 
    if (0 == iRet)
    {
        AddToListControl(iStartIndex, 
                    (LPWSTR)SzLoadString(_Module.GetResourceInstance(), IDS_IPCFG_WINS),
                    (LPWSTR)L"");
        iRet = 1;
    }

    return iRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvIpcfgDlg::FormatTime
//
//  Purpose:    convert time_t to a string. 
//
//  Arguments:  pAddrList -     the IP_ADDR_STRING
//              pstrAddr [out]  the string contains the IP address
//              pstrMask [out]  the string contains the Mask
//
//  Returns:    error code
//
//  Note:       _wasctime has some localization problems. So we do the formatting ourselves
HRESULT CAdvIpcfgDlg::FormatTime(time_t t, tstring & str)
{
    TraceFileFunc(ttidStatMon);

    time_t timeCurrent = time(NULL);
    LONGLONG llTimeDiff = 0;
    FILETIME ftCurrent = {0};
    FILETIME ftLocal = {0};
    SYSTEMTIME SysTime;
    WCHAR szBuff[256] = {0};


    str = L"";

    GetSystemTimeAsFileTime(&ftCurrent);

    llTimeDiff = (LONGLONG)t - (LONGLONG)timeCurrent;

    llTimeDiff *= 10000000; 

    *((LONGLONG UNALIGNED64 *)&ftCurrent) += llTimeDiff;

    if (!FileTimeToLocalFileTime(&ftCurrent, &ftLocal ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!FileTimeToSystemTime( &ftLocal, &SysTime ))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (0 == GetDateFormat(LOCALE_USER_DEFAULT, 
                        0, 
                        &SysTime, 
                        NULL,
                        szBuff, 
                        celems(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    str = szBuff;
    str += L" ";

    ZeroMemory(szBuff, sizeof(szBuff));
    if (0 == GetTimeFormat(LOCALE_USER_DEFAULT,
                        0,
                        &SysTime,
                        NULL,
                        szBuff,
                        celems(szBuff)))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    str += szBuff;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrGetAutoNetSetting
//
//  Purpose:    Query the Autonet settings
//
//  Arguments:  pszGuid  -  guid of the connection
//              pAddrType [out] - contains the type of the address
//
//  Returns:    error code
//
HRESULT HrGetAutoNetSetting(PWSTR pszGuid, DHCP_ADDRESS_TYPE * pAddrType)
{
    TraceFileFunc(ttidStatMon);

    Assert(pszGuid);
    Assert(pAddrType);

    *pAddrType = UNKNOWN_ADDR;

    HRESULT hr = S_OK;
    DWORD dwType = 0;
    HKEY hkeyInterface = NULL;
    tstring strInterfaceKey = c_szTcpipInterfaces;
    strInterfaceKey += pszGuid;

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                    strInterfaceKey.c_str(), 
                    KEY_QUERY_VALUE, 
                    &hkeyInterface);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyInterface);
        
        hr = HrRegQueryDword(hkeyInterface, 
                        c_szAddressType,
                        &dwType);
        if (SUCCEEDED(hr))
        {
            if (0 == dwType)
            {
                *pAddrType = NORMAL_ADDR;
            }
            else
            {
                tstring strConfigurationName = c_szAlternate;
                strConfigurationName += pszGuid;

                //assume default is AUTONET_ADDR
                *pAddrType = AUTONET_ADDR;

                // if ActiveConfigurations contain a string "Alternate_{Interface GUID}"
                // then there is customized fall-back settings, otherwise Autonet
                vector<tstring *> vstrTmp;
                hr = HrRegQueryColString( hkeyInterface,
                                  c_szActiveConfigurations,
                                  &vstrTmp);
                if (SUCCEEDED(hr))
                {
                    for (int i = 0; i < (int)vstrTmp.size(); i++)
                    {
                        if (strConfigurationName == *vstrTmp[i])
                        {
                            *pAddrType = ALTERNATE_ADDR;
                            break;
                        }
                    }
                    DeleteColString(&vstrTmp);
                }
                else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    hr = S_OK;
                }
            }

        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            //if the value is not there, assume the default (No autonet)
            *pAddrType = NORMAL_ADDR;
            hr = S_OK;
        }

        RegSafeCloseKey(hkeyInterface);
    }

    return hr;
}

HRESULT HrGetAutoNetSetting(REFGUID pGuidId, DHCP_ADDRESS_TYPE * pAddrType)
{
    TraceFileFunc(ttidStatMon);

    Assert(pAddrType);
    *pAddrType = UNKNOWN_ADDR;

    WCHAR   wszGuid[MAX_PATH];
    ::StringFromGUID2(pGuidId, wszGuid, MAX_PATH);

    HRESULT hr = S_OK;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    DWORD dwOutBufLen = 0;
    DWORD dwRet = ERROR_SUCCESS;
    
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (dwRet == ERROR_BUFFER_OVERFLOW)
    {
        pAdapterInfo = (PIP_ADAPTER_INFO) CoTaskMemAlloc(dwOutBufLen);
        if (NULL == pAdapterInfo)
            return E_OUTOFMEMORY;
    }
    else if (ERROR_SUCCESS == dwRet)
    {
        return E_FAIL;
    }
    else
    {
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    dwRet = GetAdaptersInfo(pAdapterInfo, &dwOutBufLen);
    if (ERROR_SUCCESS != dwRet)
    {
        CoTaskMemFree(pAdapterInfo);
        return HRESULT_FROM_WIN32(dwRet);
    }
    
    BOOL fFound = FALSE;
    PIP_ADAPTER_INFO pAdapterInfoEnum = pAdapterInfo;
    while (pAdapterInfoEnum)
    {
        USES_CONVERSION;
        
        if (lstrcmp(wszGuid, A2W(pAdapterInfoEnum->AdapterName)) == 0)
        {
            fFound = TRUE;
            break;
        }
        
        pAdapterInfoEnum = pAdapterInfoEnum->Next;
    }
    
    if (fFound)
    {
        if (pAdapterInfoEnum->DhcpEnabled)
        {
            hr = HrGetAutoNetSetting(wszGuid, pAddrType);
        }
        else
        {
            *pAddrType = STATIC_ADDR;
            hr = S_OK;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    CoTaskMemFree(pAdapterInfo);    
        
    return hr;
}

void DwordToIPAddrString(DWORD dw, tstring * pstr)
{
    TraceFileFunc(ttidStatMon);

    WCHAR szBuff[32] = {0};
    Assert(pstr);

    _itow((dw & 0xff000000) >> 24, szBuff, 10);
    *pstr = szBuff;
    *pstr += L".";

    _itow((dw & 0x00ff0000) >> 16, szBuff, 10);
    *pstr += szBuff;
    *pstr += L".";

    _itow((dw & 0x0000ff00) >> 8, szBuff, 10);
    *pstr += szBuff;
    *pstr += L".";

    _itow(dw & 0x000000ff, szBuff, 10);
    *pstr += szBuff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smeng.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M E N G . C P P
//
//  Contents:   The engine that provides statistics to the status monitor
//
//  Notes:
//
//  Author:     CWill   7 Oct 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop
#include "sminc.h"
#include "ncnetcon.h"
#include "ncui.h"
#include "smpsh.h"

#include "smutil.h"
#include "smhelp.h"

extern const WCHAR c_szNetShellDll[];

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::CNetStatisticsEngine
//
//  Purpose:    Initialization
//
//  Arguments:  None
//
//  Returns:    Nothing
//
CNetStatisticsEngine::CNetStatisticsEngine(VOID) :
    m_pnsc(NULL),
    m_psmEngineData(NULL),
    m_ppsmg(NULL),
    m_ppsmt(NULL),
    m_ppsmr(NULL),
    m_ppsms(NULL),
    m_hwndPsh(NULL),
    m_cStatRef(0),
    m_fRefreshIcon(FALSE),
    m_dwChangeFlags(SMDCF_NULL),
    m_fCreatingDialog(FALSE)
{
    TraceFileFunc(ttidStatMon);

    ::ZeroMemory(&m_PersistConn, sizeof(m_PersistConn));
    ::ZeroMemory(&m_guidId, sizeof(m_guidId));
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::~CNetStatisticsEngine
//
//  Purpose:    Cleans up all data before destroying the object
//
//  Arguments:  None
//
//  Returns:    Nothing
//
CNetStatisticsEngine::~CNetStatisticsEngine(VOID)
{
    // Make sure we don't try to update our stats while destroying
    //
    m_cStatRef = 0;

    //  Make sure we are no longer in the global list if we are valid
    //
    if ((GUID_NULL != m_guidId) && (NULL != m_pnsc))
    {
        (VOID) m_pnsc->RemoveNetStatisticsEngine(&m_guidId);
    }

    //
    //  Clear the data
    //

    if (m_psmEngineData)
    {
        delete(m_psmEngineData);
        m_psmEngineData = NULL;
    }

    // Release the object because we AddRefed it
    //
    ::ReleaseObj(m_ppsmg);

    delete m_ppsmt;
    m_ppsmt = NULL;

    delete m_ppsmr;
    m_ppsmr = NULL;

    delete m_ppsms;
    m_ppsms = NULL;

    AssertSz(FImplies(m_PersistConn.pbBuf, m_PersistConn.ulSize),
        "Buffer with no size.");

    MemFree(m_PersistConn.pbBuf);

    ::ReleaseObj(m_pnsc);
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::HrInitStatEngine
//
//  Purpose:    Initilaizes the statistics engine
//
//  Arguments:  ccfe - The connection folder entry associated with this
//                      statistics engine
//
//  Returns:    Error code
//
HRESULT CNetStatisticsEngine::HrInitStatEngine(const CONFOLDENTRY& ccfe)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr;

    Assert(!ccfe.empty());

    ULONG cb = ccfe.GetPersistSize();
    hr = HrMalloc(cb, (PVOID*)&m_PersistConn.pbBuf);
    if (SUCCEEDED(hr))
    {
        CopyMemory(m_PersistConn.pbBuf, ccfe.GetPersistData(), cb);
        m_PersistConn.ulSize = cb;
        m_PersistConn.clsid  = ccfe.GetCLSID();
        m_guidId             = ccfe.GetGuidID();
    }

    TraceError("CNetStatisticsEngine::HrInitStatEngine", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::StartStatistics
//
//  Purpose:    Start retrieving statistics off of the engine
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT CNetStatisticsEngine::StartStatistics(VOID)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr  = S_OK;

    ::InterlockedIncrement(&m_cStatRef);
    m_fRefreshIcon = TRUE;

    TraceError("CNetStatisticsEngine::StartStatistics", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::StopStatistics
//
//  Purpose:    Tell the engine that that statistics are no longer needed
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT CNetStatisticsEngine::StopStatistics(VOID)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr  = S_OK;

    if (0 == ::InterlockedDecrement(&m_cStatRef))
    {
        //$ REVIEW (cwill) 5 Feb 1998: We can stop doing statistics now.
    }

    TraceError("CNetStatisticsEngine::StopStatistics", hr);
    return hr;
}

DWORD CNetStatisticsEngine::MonitorThread(CNetStatisticsEngine * pnse)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr;
    BOOL    fUninitCom = TRUE;
    CWaitCursor WaitCursor;
    BOOL    fHasSupportPage = FALSE;
    int     iIndexSupportPage = 0;
    
    // Initialize COM on this thread
    //
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fUninitCom = FALSE;
    }
    if (SUCCEEDED(hr))
    {
        INetConnection* pncStatEng;
        // Get INetConnection and initialize the pages
        //
        hr = pnse->HrGetConnectionFromBlob(&pncStatEng);
        if (SUCCEEDED(hr))
        {
            // Initialize the general page
            //
            hr = pnse->m_ppsmg->HrInitGenPage(pnse, pncStatEng,
                                              g_aHelpIDs_IDD_STATMON_GENERAL);
            if (SUCCEEDED(hr))
            {
                // Initialize the tool page
                //
                hr = pnse->m_ppsmt->HrInitToolPage(pncStatEng,
                                                   g_aHelpIDs_IDD_STATMON_TOOLS);
                if (SUCCEEDED(hr))
                {
                    if (pnse->m_ppsmr)
                    {
                        // Initialize the RAS page
                        //
                        hr = pnse->m_ppsmr->HrInitRasPage(pncStatEng,
                                                          pnse->m_ppsmg,
                                                          g_aHelpIDs_IDD_STATMON_RAS);
                    }

                    if (SUCCEEDED(hr))
                    {
                        PROPSHEETHEADER pshTemp = { 0 };
                        INT nPages = 1; // Start with only the general page
                        HPROPSHEETPAGE  ahpspTemp[4];

                        // Put together the required property pages

                        // If we have a RAS page
                        //
                        if (pnse->m_ppsmr)
                        {
                            ahpspTemp[0] = pnse->m_ppsmg->CreatePage(IDD_STATMON_GENERAL_RAS,
                                                                     PSP_DEFAULT);

                            // Create the RAS page
                            //
                            ahpspTemp[nPages] = pnse->m_ppsmr->CreatePage(IDD_STATMON_RAS,
                                                                          PSP_DEFAULT);

                            nPages++;
                        }
                        else if(NCM_LAN == pnse->m_ncmType || NCM_BRIDGE == pnse->m_ncmType)
                        {
                            ahpspTemp[0] = pnse->m_ppsmg->CreatePage(IDD_STATMON_GENERAL_LAN,
                                                                     PSP_DEFAULT);
                        }
                        else if(NCM_SHAREDACCESSHOST_LAN == pnse->m_ncmType || NCM_SHAREDACCESSHOST_RAS == pnse->m_ncmType)
                        {
                            ahpspTemp[0] = pnse->m_ppsmg->CreatePage(IDD_STATMON_GENERAL_SHAREDACCESS,
                                                                     PSP_DEFAULT);
                        }
                        else
                        {
                            AssertSz(FALSE, "Unknown media type");
                        }

                        HICON hIcon = NULL;
                        hr = HrGetIconFromMediaType(GetSystemMetrics(SM_CXSMICON), pnse->m_ncmType, pnse->m_ncsmType, 7, 0, &hIcon);

                        if (NCM_LAN == pnse->m_ncmType || NCM_BRIDGE == pnse->m_ncmType)
                        {
                            hr = pnse->m_ppsms->HrInitPage(pncStatEng,
                                                        g_aHelpIDs_IDD_PROPPAGE_IPCFG);

                            if (SUCCEEDED(hr))
                            {
                                ahpspTemp[nPages] = pnse->m_ppsms->CreatePage(IDD_PROPPAGE_IPCFG,
                                                                          PSP_DEFAULT);
                                fHasSupportPage = TRUE;
                                iIndexSupportPage = nPages;
                                nPages++;
                            }
                        }
                        // If we have any tools to display
                        //
                        if (!pnse->m_ppsmt->FToolListEmpty())
                        {
                            ahpspTemp[nPages] = pnse->m_ppsmt->CreatePage(IDD_STATMON_TOOLS,
                                                                          PSP_DEFAULT);
                            nPages++;
                        }

                        // Fill in the property sheet header
                        //
                        pshTemp.dwSize      = sizeof(PROPSHEETHEADER);
                        pshTemp.dwFlags     = PSH_NOAPPLYNOW | PSH_USECALLBACK;
                        pshTemp.hwndParent  = NULL;
                        pshTemp.hInstance   = _Module.GetResourceInstance();
                        pshTemp.hIcon       = NULL;
                        pshTemp.nPages      = nPages;

                        if (hIcon)
                        {
                            pshTemp.dwFlags |= PSH_USEHICON;
                            pshTemp.hIcon    = hIcon;
                        }

                        pshTemp.phpage      = ahpspTemp;
                        pshTemp.pfnCallback = static_cast<PFNPROPSHEETCALLBACK>(
                                                CNetStatisticsEngine::PshCallback);

                        pshTemp.hbmWatermark = NULL;
                        pshTemp.hplWatermark = NULL;
                        pshTemp.hbmHeader    = NULL;

                        // Set propertysheet title
                        PWSTR  pszCaption  = NULL;

                        NETCON_PROPERTIES* pProps;
                        if (SUCCEEDED(pncStatEng->GetProperties(&pProps)))
                        {
                            // Get the title each time in case it has
                            // changed
                            //
                            AssertSz(pProps->pszwName,
                                "We should have a pProps->pszwName");

                            FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                          FORMAT_MESSAGE_FROM_STRING |
                                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          SzLoadIds(IDS_SM_CAPTION),
                                          0, 0, (PWSTR)&pszCaption, 0,
                                          (va_list *)&pProps->pszwName);

                            pshTemp.pszCaption = pszCaption;

                            // Get the connection status. If the status is NCS_INVALID_ADDRESS,
                            // then put the "Support" tab as the start page
                            if (fHasSupportPage && NCS_INVALID_ADDRESS == pProps->Status)
                            {
                                pshTemp.nStartPage = iIndexSupportPage;
                                Assert(pnse->m_ppsms);

                                //set the support tab as the first page and m_ppsms is responsible
                                //for initialize the propsheet
                                pnse->m_ppsms->SetAsFirstPage(TRUE);
                            }
                            else
                            {
                                pshTemp.nStartPage = 0;
                                Assert(pnse->m_ppsmg);

                                //set the support tab as the first page and m_ppsmg is responsible
                                //for initialize the propsheet
                                pnse->m_ppsmg->SetAsFirstPage(TRUE);
                            }

                            FreeNetconProperties(pProps);
                        }
                        else
                        {
                            //$ REVIEW : CWill : 02/17/98 : Better default?
                            pshTemp.pszCaption = SzLoadIds(IDS_SM_ERROR_CAPTION);
                        }

                        // Launch the page
                        //
                        INT iRet = ::PropertySheet(&pshTemp);
                        if (NULL == iRet)
                        {
                            hr = ::HrFromLastWin32Error();
                        }

                        if (hIcon)
                        {
                            DestroyIcon(hIcon);
                        }

                        if (NULL != pszCaption)
                        {
                            LocalFree(pszCaption);
                        }
                    }
                }
            }

            // Make sure the general page clean up correctly.
            // Since the "General" page may not be the first page (support page will be the
            // first one when the address is invalid, the OnDestroy method (which calls HrCleanupGenPage)
            // of the general page may not called in such case. So we always do a cleanup here. It's
            // OK to call HrCleanupGenPage mutliple times.

            // general page
            AssertSz(pnse->m_ppsmg, "We should have a m_ppsmg");
            (VOID) pnse->m_ppsmg->HrCleanupGenPage();

            //also cleanup the Support page if it exists. It's safe to call this routine mutliple times.
            if (fHasSupportPage)
            {
                pnse->m_ppsms->CleanupPage();
            }

            // leaving creating mode
            pnse->m_fCreatingDialog = FALSE;

            ReleaseObj(pncStatEng);
        }

        if (fUninitCom)
        {
            CoUninitialize();
        }
    }   // Initialize com succeeded

    // Release the 'pnse' object because it was addref'd before
    // the thread was created.
    //
    ReleaseObj(static_cast<INetStatisticsEngine *>(pnse));

    // release the dll
    //
    FreeLibraryAndExitThread(GetModuleHandle(c_szNetShellDll), 1);

    return 1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::ShowStatusMonitor
//
//  Purpose:    Create an launch the UI for the status monitor
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT CNetStatisticsEngine::ShowStatusMonitor(VOID)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr  = S_OK;
    CExceptionSafeComObjectLock EsLock(m_pnsc);

    // Create the property sheet pages if they don't already exist
    //
    if (!m_ppsmg)
    {
        CPspStatusMonitorGen* pObj  = NULL;

        // Make sure we have read in the tools
        //
        (VOID) m_pnsc->HrReadTools();

        if (m_ncmType == NCM_LAN || m_ncmType == NCM_BRIDGE)
        {
            CPspLanGen*     pLanObj = NULL;

            // Make the Tool property page
            m_ppsmt = new CPspLanTool;

            // Create the object
            pLanObj = new CComObject <CPspLanGen>;

            if (pLanObj)
            {
                pLanObj->put_MediaType(m_ncmType, m_ncsmType);
            }

            // Give it back to the page
            pObj = pLanObj;

            m_ppsms = new CPspStatusMonitorIpcfg;

        }
        else if(m_ncmType == NCM_SHAREDACCESSHOST_LAN || m_ncmType == NCM_SHAREDACCESSHOST_RAS)
        {
            m_ppsmt = new CPspSharedAccessTool;

            CPspSharedAccessGen* pSharedAccessGen = new CComObject<CPspSharedAccessGen>;
            pSharedAccessGen->put_MediaType(m_ncmType, m_ncsmType);
            pObj = pSharedAccessGen;
            
        }
        else if ((m_dwCharacter & NCCF_INCOMING_ONLY) ||
                 (m_dwCharacter & NCCF_OUTGOING_ONLY))
        {
            // RAS connections

            CPspRasGen* pRasObj = NULL;

            // Make the Tool property page
            //
            m_ppsmt = new CPspRasTool;

            // Make the RAS property page and let it be known there are
            // now three pages
            //
            m_ppsmr = new CPspStatusMonitorRas;

            // Create the object
            //
            pRasObj = new CComObject <CPspRasGen>;

            if (pRasObj)
            {
                pRasObj->put_MediaType(m_ncmType, m_ncsmType);
                pRasObj->put_Character(m_dwCharacter);
            }

            // Give it back to the page
            //
            pObj = pRasObj;
        }
        else
        {
            AssertSz(FALSE, "Unknown connection type.");
        }

        if (NULL != pObj)
        {
            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid(NULL);
            pObj->InternalFinalConstructAddRef();
            hr = pObj->FinalConstruct();
            pObj->InternalFinalConstructRelease();

            if (SUCCEEDED(hr))
            {
                m_ppsmg = static_cast<CPspStatusMonitorGen*>(pObj);

                // Hold on to the interface
                ::AddRefObj(m_ppsmg);
            }

            // Make sure we clean up nicely
            //
            if (FAILED(hr))
            {
                delete pObj;
            }
        }

        // Clean up the other pages on failure
        //
        if (FAILED(hr))
        {
            if (m_ppsmt)
            {
                delete m_ppsmt;
                m_ppsmt = NULL;
            }

            if (m_ppsmr)
            {
                delete m_ppsmr;
                m_ppsmr = NULL;
            }
        }
    }

    //
    // Show the property sheets
    //

    if (SUCCEEDED(hr))
    {
        // NOTE: The variable m_fCreatingDialog is reset to FALSE in the following
        // 3 places, which should cover all senarios:
        //
        // 1) In CPspStatusMonitorGen::OnInitDialog, after m_hWnd is assigned.
        // 2) In CNetStatisticsEngine::ShowStatusMonitor, in case CreateThread failed.
        // 3) In CNetStatisticsEngine::MonitorThread, just before exiting
        //    (in case of failing to create UI).
        //
        if (m_hwndPsh)
        {
            // Bring the existing property sheet page to the foreground
            //
            ::SetForegroundWindow(m_hwndPsh);
        }
        else if (!m_fCreatingDialog)
        {
            // Addref 'this' object
            //
            AddRefObj(static_cast<INetStatisticsEngine *>(this));

            // entering creating mode
            m_fCreatingDialog = TRUE;

            // Create the property sheet on a different thread
            //

            // Make sure the dll don't get unloaded while the thread is active
            HINSTANCE hInst = LoadLibrary(c_szNetShellDll);
            HANDLE hthrd = NULL;

            if (hInst)
            {
                DWORD  dwThreadId;
                hthrd = CreateThread(NULL, STACK_SIZE_TINY,
                                    (LPTHREAD_START_ROUTINE)CNetStatisticsEngine::MonitorThread,
                                    (LPVOID)this, 0, &dwThreadId);
                if (NULL != hthrd)
                {
                    CloseHandle(hthrd);
                }
            }
            
            // clean up on failure
            if (!hthrd) 
            {
                // Release 'this' object on failure
                //
                ReleaseObj(static_cast<INetStatisticsEngine *>(this));

                // Release the dll
                //
                if (hInst)
                    FreeLibrary(hInst);

                // leaving creating mode
                m_fCreatingDialog = FALSE;

                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceError("CNetStatisticsEngine::ShowStatusMonitor", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::GetStatistics
//
//  Purpose:
//
//  Arguments:
//
//  Returns:
//
HRESULT CNetStatisticsEngine::GetStatistics(
    STATMON_ENGINEDATA**  ppseAllData)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr = S_OK;

    // Make sure we have a valid pointer
    if (ppseAllData)
    {
        STATMON_ENGINEDATA * pEngineData = NULL;

        // Allocate space and copy the data ..
        EnterCriticalSection(&g_csStatmonData);

        if (!m_psmEngineData)
        {
            DWORD dwChangeFlags;
            BOOL  fNoLongerConnected;

            hr = HrUpdateData(&dwChangeFlags, &fNoLongerConnected);
        }

        if (m_psmEngineData)
        {
            DWORD dwBytes = sizeof(STATMON_ENGINEDATA);
            PVOID   pbBuf;
            hr = HrCoTaskMemAlloc(dwBytes, &pbBuf);
            if (SUCCEEDED(hr))
            {
                pEngineData = reinterpret_cast<STATMON_ENGINEDATA *>(pbBuf);

                // fill in the data
                *pEngineData = *m_psmEngineData;
            }
        }

        LeaveCriticalSection(&g_csStatmonData);

        *ppseAllData = pEngineData;
    }
    else
    {
        // We should have good data
        hr = E_INVALIDARG;
    }

    TraceError("CNetStatisticsEngine::GetStatistics", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::UpdateStatistics
//
//  Purpose:    Get the new statistics from the devices and notify all the
//              advises that the data has changed
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT
CNetStatisticsEngine::UpdateStatistics (
    BOOL* pfNoLongerConnected)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;

    Assert (pfNoLongerConnected);

    // Initialize the output parameter.
    //
    *pfNoLongerConnected = FALSE;

    // Don't bother doing anything if we don't have any ref count
    //
    if (m_cStatRef)
    {
        // Get the new data
        //
        DWORD dwChangeFlags;

        hr = HrUpdateData(&dwChangeFlags, pfNoLongerConnected);

        // If it represents a change, notify our connection points.
        //
        if (SUCCEEDED(hr) &&
            (m_fRefreshIcon ||  // Bug#319276, force a refresh if new client is added
             (dwChangeFlags != m_dwChangeFlags) ||
             (*pfNoLongerConnected)))
        {
            m_fRefreshIcon = FALSE;

            ULONG       cpUnk;
            IUnknown**  apUnk;

            hr = HrCopyIUnknownArrayWhileLocked (
                    this,
                    &m_vec,
                    &cpUnk,
                    &apUnk);
            if (SUCCEEDED(hr) && cpUnk && apUnk)
            {
                // Notify everyone that we have changed
                //
                for (ULONG i = 0; i < cpUnk; i++)
                {
                    INetConnectionStatisticsNotifySink* pSink =
                        static_cast<INetConnectionStatisticsNotifySink*>(apUnk[i]);

                    hr = pSink->OnStatisticsChanged(dwChangeFlags);

                    ReleaseObj(pSink);
                }

                MemFree(apUnk);
            }

            // Remember the change flags for comparison next time.
            //
            m_dwChangeFlags = dwChangeFlags;
        }
    }

    TraceError("CNetStatisticsEngine::UpdateStatistics", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::UpdateTitle
//
//  Purpose:    If the status monitor UI is up, change the title
//
//  Arguments:  pszwNewName
//
//  Returns:    None
//
HRESULT CNetStatisticsEngine::UpdateTitle (PCWSTR pszwNewName)
{
    TraceFileFunc(ttidStatMon);

    if (m_hwndPsh)
    {
        // Set propertysheet title
        PWSTR  pszCaption  = NULL;

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                      FORMAT_MESSAGE_FROM_STRING |
                      FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      SzLoadIds(IDS_SM_CAPTION),
                      0, 0, (PWSTR)&pszCaption, 0,
                      (va_list *)&pszwNewName);

        PropSheet_SetTitle(m_hwndPsh,0,pszCaption);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::CloseStatusMonitor
//
//  Purpose:    If the status monitor UI is up, close it
//
//  Arguments:  None
//
//  Returns:    None
//
HRESULT CNetStatisticsEngine::CloseStatusMonitor()
{
    TraceFileFunc(ttidStatMon);

    if (m_hwndPsh)
    {
        PropSheet_PressButton(m_hwndPsh, PSBTN_CANCEL);
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::UpdateRasLinkList
//
//  Purpose:    If the status monitor UI is up and on the RAS page, update
//              the multi-link combo-box and button state
//
//  Arguments:  None
//
//  Returns:    Error code
//
HRESULT CNetStatisticsEngine::UpdateRasLinkList()
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;

    if (m_hwndPsh)
    {
        HWND hwndDlg = PropSheet_GetCurrentPageHwnd(m_hwndPsh);

        if (hwndDlg)
        {
            if (GetDlgItem(hwndDlg, IDC_TXT_SM_NUM_DEVICES_VAL))
            {
                // we are on the RAS page, update the combo box, active link count etc.
                ::PostMessage(hwndDlg, PWM_UPDATE_RAS_LINK_LIST, 0, 0);
            }
        }
    }

    TraceError("CNetStatisticsEngine::UpdateRasLinkList", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsEngine::GetGuidId
//
//  Purpose:    Gets the Connection GUID of the engine into a pre-allocated
//              buffer
//
//  Arguments:  pguidId - Location of buffer to hold the GUID
//
//  Returns:    Error code
//
HRESULT CNetStatisticsEngine::GetGuidId(GUID* pguidId)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr  = S_OK;

    // Pass back the GUID
    //
    if (pguidId)
    {
        *pguidId = m_guidId;
    }
    else
    {
        hr = E_POINTER;
    }

    TraceError("CNetStatisticsEngine::GetGuidId", hr);
    return hr;
}


//+------------------------------------------------------------------
//
// CNetStatisticsEngine::PshCallback
//
// Purpose:
//
//
// Parameters:
//     hwndDlg      [in]
//     uMsg         [in]
//     lParam       [in]
//
// Returns:
//     a
//
// Side Effects:
//
INT CALLBACK CNetStatisticsEngine::PshCallback(HWND hwndDlg,
                                               UINT uMsg, LPARAM lParam)
{
    TraceFileFunc(ttidStatMon);

    switch (uMsg)
    {
    // called before the dialog is created, hwndPropSheet = NULL,
    // lParam points to dialog resource
    // This would hide the context help "?" on toolbar
#if 0
    case PSCB_PRECREATE:
      {
      LPDLGTEMPLATE  lpTemplate = (LPDLGTEMPLATE)lParam;

      lpTemplate->style &= ~DS_CONTEXTHELP;
      }
      break;
#endif

    case PSCB_INITIALIZED:
        {
            HWND    hwndTemp    = NULL;

            // Cancel button becomes close
            //
            hwndTemp = ::GetDlgItem(hwndDlg, IDCANCEL);
            if (NULL != hwndTemp)
            {
                ::SetWindowText(hwndTemp, ::SzLoadIds(IDS_SM_PSH_CLOSE));
            }

            HICON  hIcon;
            hIcon = (HICON)SendMessage(hwndDlg, 
                                       WM_GETICON,
                                       ICON_SMALL,
                                       0);
            // Assert(hIcon);

            if (hIcon)
            {
                SendMessage(hwndDlg,
                            WM_SETICON,
                            ICON_BIG,
                            (LPARAM)hIcon);
            }
        }
        break;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smcent.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M C E N T . C P P
//
//  Contents:   The central object that controls statistic engines.
//
//  Notes:
//
//  Author:     CWill   2 Dec 1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop
#include "sminc.h"
#include "ncreg.h"
#include "ncnetcon.h"

//
//  External data
//

extern const WCHAR          c_szDevice[];

extern SM_TOOL_FLAGS        g_asmtfMap[];
extern INT                  c_cAsmtfMap;

//
//  Global Data
//

const UINT  c_uiStatCentralRefreshID    = 7718;
const UINT  c_uiStatCentralRefreshRate  = 1000;  // Refresh rate in milliseconds

CRITICAL_SECTION    g_csStatmonData;

CStatCentralCriticalSection CNetStatisticsCentral::g_csStatCentral;

//
//  Tool Registry Keys
//

//  Required fields
//
static const WCHAR      c_szRegKeyToolsRoot[]           = L"System\\CurrentControlSet\\Control\\Network\\Connections\\StatMon\\Tools";
static const WCHAR      c_szRegKeyToolsDisplayName[]    = L"DisplayName";
static const WCHAR      c_szRegKeyToolsManufacturer[]   = L"Manufacturer";
static const WCHAR      c_szRegKeyToolsCommandLine[]    = L"CommandLine";
static const WCHAR      c_szRegKeyToolsDescription[]    = L"Description";

// Optional fields
//
static const WCHAR      c_szRegKeyToolsCriteria[]       = L"Criteria";
static const WCHAR      c_szRegKeyToolsComponentID[]    = L"ComponentID";
static const WCHAR      c_szRegKeyToolsConnectionType[] = L"ConnectionType";
static const WCHAR      c_szRegKeyToolsMedia[]          = L"MediaType";
static const WCHAR      c_szRegKeyToolsFlags[]          = L"Flags";



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CNetStatisticsCentral                                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////



//
//  Make the global instance
//

CNetStatisticsCentral * g_pnscCentral = NULL;


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::CNetStatisticsCentral
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CNetStatisticsCentral::CNetStatisticsCentral(VOID) :
m_cRef(0),
m_fProcessingTimerEvent(FALSE),
m_unTimerId(0)
{
    TraceFileFunc(ttidStatMon);

    InitializeCriticalSection(&g_csStatmonData);
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::~CNetStatisticsCentral
//
//  Purpose:    Destructor
//
//  Arguments:  None
//
//  Returns:    Nil
//
CNetStatisticsCentral::~CNetStatisticsCentral(VOID)
{
    Assert(0 == m_cRef);
    AssertSz(m_pnselst.empty(), "Someone leaked a INetStatisticsEngine");
    AssertSz(0 == m_unTimerId, "Someone forgot to stop the timer");

    // Get rid of the global pointer
    //
    g_pnscCentral = NULL;

    EnterCriticalSection(&g_csStatmonData);
    __try
    {
        // Release the list of engines
        ::FreeCollectionAndItem(m_lstpsmte);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {

        AssertSz(FALSE, "An exception occurred while freeing the connection list");
    }
    LeaveCriticalSection(&g_csStatmonData);

    // delete the critical section
    DeleteCriticalSection(&g_csStatmonData);
}

//
// Function:    CNetStatisticsCentral::AddRef
//
// Purpose:     Increment the reference count on this object
//
// Parameters:  none
//
// Returns:     ULONG
//
STDMETHODIMP_(ULONG) CNetStatisticsCentral::AddRef()
{
    TraceFileFunc(ttidStatMon);

    return ++m_cRef;
}

//
// Function:    CNetStatisticsCentral::Release
//
// Purpose:     Decrement the reference count on this object
//
// Parameters:  none
//
// Returns:     ULONG
//
STDMETHODIMP_(ULONG) CNetStatisticsCentral::Release()
{
    TraceFileFunc(ttidStatMon);

    ULONG cRef = --m_cRef;

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

//
// Function:    CNetStatisticsCentral::QueryInterface
//
// Purpose:     Allows for the querying of alternate interfaces
//
// Parameters:  riid    [IN] - Interface to retrieve
//              ppvObj [OUT] - Retrieved interface if function succeeds
//
// Returns:     HRESULT, S_OK on success E_NOINTERFACE on failure
//
STDMETHODIMP CNetStatisticsCentral::QueryInterface(REFIID riid, LPVOID FAR *ppvObj)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;

    *ppvObj = NULL;

    if (riid == IID_IUnknown)
    {
        *ppvObj = (LPVOID)this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::HrGetNetStatisticsCentral
//
//  Purpose:    This procedure gets and returns a pointer to the one
//              CNetStatisticsCentral object.  Creating it if both necessary
//              and required.
//
//  Arguments:  ppnsc [OUT]  - Pointer to the CNetStatisticsCentral object
//              fCreate [IN] - If TRUE, and the object does not already
//                             exist, then create it.
//
//  Returns:    S_OK - if the object is returned.
//              E_OUTOFMEMORY - if fCreate==TRUE and creation failed
//              E_NOINTERFACE - if fCreate==FALSE and the object doesn't exist
//
HRESULT
CNetStatisticsCentral::HrGetNetStatisticsCentral(
                                                CNetStatisticsCentral ** ppnsc,
                                                BOOL fCreate)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = E_NOINTERFACE;

    // Note: scottbri - need critical section to protect creation

    #if  DBG
        Assert( g_csStatCentral.Enter() == S_OK );
    #else
        g_csStatCentral.Enter();
    #endif

    if ((NULL == g_pnscCentral) && fCreate)
    {
        g_pnscCentral = new CNetStatisticsCentral;
#if DBG
        // This test is only needed during DBG.  The assert will catch
        // the problem, bringing it to out attention, and the test and
        // return will allow the user to press ignore and not crash
        Assert(g_pnscCentral);
        if (NULL == g_pnscCentral)
        {
            g_csStatCentral.Leave();
            return E_OUTOFMEMORY;
        }
#endif
    }

    g_csStatCentral.Leave();

    AddRefObj(g_pnscCentral);
    *ppnsc = g_pnscCentral;

    return((*ppnsc) ? S_OK : hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::TimerCallback
//
//  Purpose:    This is the procedure that gets called by the timer when it is
//              time to update the statistics
//
//  Arguments:  Standard timer procedure
//
//  Returns:    Nothing
//
VOID
CALLBACK
CNetStatisticsCentral::TimerCallback(
                                    HWND        hwnd,
                                    UINT        uMsg,
                                    UINT_PTR    unEvent,
                                    DWORD       dwTime)
{
    TraceFileFunc(ttidStatMon);
    
    CNetStatisticsCentral* pnsc;

    if (SUCCEEDED(HrGetNetStatisticsCentral(&pnsc, FALSE)))
    {
        // Prevent same-thread re-entrancy.  Any Win32 call made while
        // processing RefreshStatistics that returns control to the message
        // loop may cause this timer callback to be invoked again.
        //
        if ((!pnsc->m_fProcessingTimerEvent) && pnsc->m_unTimerId)
        {
            Assert(pnsc->m_unTimerId == unEvent);
            
            pnsc->m_fProcessingTimerEvent = TRUE;

            pnsc->RefreshStatistics(dwTime);

            pnsc->m_fProcessingTimerEvent = FALSE;
        }
        else
        {
            TraceTag (ttidStatMon, "CNetStatisticsCentral::TimerCallback "
                      "re-entered on same thread.  Ignoring.");
        }

        ReleaseObj(pnsc);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::RefreshStatistics
//
//  Purpose:    To get all the statistics engines held by central to update
//              their statistics
//
//  Arguments:
//
//  Returns:    Nothing
//
VOID CNetStatisticsCentral::RefreshStatistics(DWORD dwTime)
{
    TraceFileFunc(ttidStatMon);

    static BOOL fInRefreshStatistics = FALSE;

    if (fInRefreshStatistics)
        return;

    fInRefreshStatistics = TRUE;

    CExceptionSafeComObjectLock EsLock(this);

    HRESULT hr = S_OK;
    list<INetStatisticsEngine *>::iterator   iterPnse;

    //  Get the statistics to refresh themselves
    //
    INetStatisticsEngine * pnse = NULL;

    iterPnse = m_pnselst.begin();

    while (iterPnse != m_pnselst.end())
    {
        AssertSz (*iterPnse, "Shouldn't we always have non-NULL "
                  "entries in our statistics engine list?");

        pnse = *iterPnse;

        if (pnse)
        {
            BOOL fNoLongerConnected;
            hr = pnse->UpdateStatistics(&fNoLongerConnected);

            if (SUCCEEDED(hr) && fNoLongerConnected)
            {
                TraceTag (ttidStatMon, "CNetStatisticsCentral::RefreshStatistics - "
                          "UpdateStatistics reports that the connection is no longer connected.");
            }
        }

        iterPnse++;
    }

    // Since we possibly removed one or more engines from the list, stop
    // the timer if there are no more engines present.
    //
    if (m_pnselst.empty())
    {
        // Stop the timer
        //
        if (m_unTimerId)
        {
            ::KillTimer(NULL, m_unTimerId);
            m_unTimerId = 0;
        }
    }

    fInRefreshStatistics = FALSE;

    TraceError("CNetStatisticsCentral::RefreshStatistics", hr);
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::UpdateTitle
//
//  Purpose:    To update the title of a renamed connection if the statmon UI
//              is up.
//
//  Arguments:
//
//  Returns:    Nothing
//

VOID CNetStatisticsCentral::UpdateTitle(const GUID * pguidId,
                                        PCWSTR pszNewName)
{
    TraceFileFunc(ttidStatMon);

    CExceptionSafeComObjectLock EsLock(this);

    INetStatisticsEngine * pnse;
    if (FEngineInList(pguidId, &pnse))
    {
        pnse->UpdateTitle(pszNewName);
        ReleaseObj(pnse);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::CloseStatusMonitor
//
//  Purpose:    To close the status monitor UI if the connection is disconnected
//
//  Arguments:
//
//  Returns:    Nothing
//

VOID CNetStatisticsCentral::CloseStatusMonitor(const GUID * pguidId)
{
    TraceFileFunc(ttidStatMon);

    CExceptionSafeComObjectLock EsLock(this);

    INetStatisticsEngine * pnse;
    if (FEngineInList(pguidId, &pnse))
    {
        pnse->CloseStatusMonitor();
        ReleaseObj(pnse);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::UpdateRasLinkList
//
//  Purpose:    To update the RAS connections's multi-link list
//
//  Arguments:
//
//  Returns:    Nothing
//

VOID CNetStatisticsCentral::UpdateRasLinkList(const GUID * pguidId)
{
    TraceFileFunc(ttidStatMon);

    CExceptionSafeComObjectLock EsLock(this);

    INetStatisticsEngine * pnse;
    if (FEngineInList(pguidId, &pnse))
    {
        pnse->UpdateRasLinkList();
        ReleaseObj(pnse);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::HrCreateNewEngineType
//
//  Purpose:    Creates the implementation of each type of statistics engine
//
//  Arguments:  nctNew          -    Type of engine to create
//              ncMediaNew      -    The media type of the connection
//              dwCharacterNew  -    The character of the connection
//              ppStatEngine           -    Where to return the newly created stat engine
//
//  Returns:    Error code
//
HRESULT
CNetStatisticsCentral::HrCreateNewEngineType (
                                             const CONFOLDENTRY&    ccfe,
                                             CNetStatisticsEngine**  ppStatEngine)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr = S_OK;

    // Create the engine of the right type
    //

    if (ccfe.GetNetConMediaType() == NCM_LAN || ccfe.GetNetConMediaType() == NCM_BRIDGE)
    {
        // LAN connection
        Assert(!(ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY));
        Assert(!(ccfe.GetCharacteristics() & NCCF_OUTGOING_ONLY));

        CLanStatEngine*     pLanObj = NULL;
        INetLanConnection*  pnlcNew = NULL;
        tstring             strDeviceName;

        pLanObj = new CComObject <CLanStatEngine>;
        *ppStatEngine = pLanObj;

        if (!pLanObj)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pLanObj->put_MediaType(ccfe.GetNetConMediaType(), ccfe.GetNetConSubMediaType());
            // Get some LAN specific info
            //
            hr = ccfe.HrGetNetCon(IID_INetLanConnection, 
                        reinterpret_cast<VOID**>(&pnlcNew));
    
            if (SUCCEEDED(hr))
            {
                GUID guidDevice;
    
                // Find the interface
                //
                hr = pnlcNew->GetDeviceGuid(&guidDevice);
                if (SUCCEEDED(hr))
                {
                    WCHAR   achGuid[c_cchGuidWithTerm];
    
                    // Make the device name
                    //
                    StringFromGUID2(  guidDevice, achGuid,
                                        c_cchGuidWithTerm);
    
                    strDeviceName = c_szDevice;
                    strDeviceName.append(achGuid);
    
                    hr = pLanObj->put_Device(&strDeviceName);
                }
    
                ReleaseObj(pnlcNew);
            }
        }
    }
    else if (ccfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_LAN || ccfe.GetNetConMediaType() == NCM_SHAREDACCESSHOST_RAS)
    {
        CComObject<CSharedAccessStatEngine>* pEngine;
        hr = CComObject<CSharedAccessStatEngine>::CreateInstance(&pEngine);
        if(pEngine)
        {
            INetSharedAccessConnection* pNetSharedAccessConnection;

            hr = ccfe.HrGetNetCon(IID_INetSharedAccessConnection, reinterpret_cast<void**>(&pNetSharedAccessConnection));
            if(SUCCEEDED(hr))
            {
                hr = pEngine->Initialize(ccfe.GetNetConMediaType(), pNetSharedAccessConnection);
                if(SUCCEEDED(hr))
                {
                    *ppStatEngine = pEngine;
                }
                ReleaseObj(pNetSharedAccessConnection);
            }

            if(FAILED(hr))
            {
                delete pEngine;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // RAS connections ..

        CRasStatEngine* pRasObj = NULL;

        pRasObj = new CComObject <CRasStatEngine>;
        *ppStatEngine = pRasObj;

        if (!pRasObj)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Pass in the specific type
            pRasObj->put_MediaType(ccfe.GetNetConMediaType(), ccfe.GetNetConSubMediaType());
            pRasObj->put_Character(ccfe.GetCharacteristics());

            // Get RAS specific data
            //
            if (ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY)
            {
                // RAS incoming connection
                Assert(ccfe.GetNetConMediaType() != NCM_LAN);
                Assert(!(ccfe.GetCharacteristics() & NCCF_OUTGOING_ONLY));

                INetInboundConnection*  pnicNew;
                hr = ccfe.HrGetNetCon(IID_INetInboundConnection, 
                                        reinterpret_cast<VOID**>(&pnicNew));
                if (SUCCEEDED(hr))
                {
                    HRASCONN hRasConn;
                    hr = pnicNew->GetServerConnectionHandle(
                                    reinterpret_cast<ULONG_PTR*>(&hRasConn));

                    if (SUCCEEDED(hr))
                    {
                        pRasObj->put_RasConn(hRasConn);
                    }

                    ReleaseObj(pnicNew);
                }
            }
            else if (ccfe.GetCharacteristics() & NCCF_OUTGOING_ONLY)
            {
                // RAS outgoing connection
                Assert(ccfe.GetNetConMediaType() != NCM_LAN);
                Assert(!(ccfe.GetCharacteristics() & NCCF_INCOMING_ONLY));

                INetRasConnection*  pnrcNew;
                hr = ccfe.HrGetNetCon(IID_INetRasConnection, 
                                        reinterpret_cast<VOID**>(&pnrcNew));

                if (SUCCEEDED(hr))
                {
                    HRASCONN hRasConn;
                    hr = pnrcNew->GetRasConnectionHandle(
                                                        reinterpret_cast<ULONG_PTR*>(&hRasConn));

                    if (S_OK == hr)
                    {
                        pRasObj->put_RasConn(hRasConn);
                    }
                    else if (S_FALSE == hr)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_CONNECTION_UNAVAIL);
                    }

                    ReleaseObj(pnrcNew);
                }
            }
            else
            {
                AssertSz(FALSE, "Unknown connection type...");
            }
        }
    }


    TraceError("CNetStatisticsCentral::HrCreateNewEngineType", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::HrCreateStatisticsEngineForEntry
//
//  Purpose:    Creates a new statistics engine for the connection
//              represented by the folder entry.
//
//  Arguments:
//      ccfe    [in]   Folder entry to create statistics engine for.
//      ppnseNew [out]  Returned interface.
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   5 Nov 1998
//
//  Notes:      This MUST be called with this object's lock held.
//
HRESULT
CNetStatisticsCentral::HrCreateStatisticsEngineForEntry(
                                                       const CONFOLDENTRY& ccfe,
                                                       INetStatisticsEngine** ppnseNew)
{
    TraceFileFunc(ttidStatMon);

    Assert (!ccfe.empty());
    Assert (ppnseNew);

    HRESULT hr;

    // Initialize the out parameter
    //
    *ppnseNew = NULL;

    // Create the base engine after initializing the different types
    //
    CNetStatisticsEngine* pStatEngine;
    hr = HrCreateNewEngineType(ccfe, &pStatEngine);

    if (SUCCEEDED(hr))
    {
        // Do the standard initialize
        //
        hr = pStatEngine->HrInitStatEngine(ccfe);
        if (SUCCEEDED(hr))
        {
            // Standard CComCreator::CreateInstance stuff
            //
            pStatEngine->SetVoid(NULL);
            pStatEngine->InternalFinalConstructAddRef();
            hr = pStatEngine->FinalConstruct();
            pStatEngine->InternalFinalConstructRelease();

            // If all went well, add it to our list
            //
            if (SUCCEEDED(hr))
            {
                INetStatisticsEngine* pnseInter;

                hr = pStatEngine->GetUnknown()->QueryInterface(
                                                              IID_INetStatisticsEngine,
                                                              reinterpret_cast<VOID**>(&pnseInter));

                // All has gone well, add it to the list
                //
                if (SUCCEEDED(hr))
                {
                    // Add the new entry to our list
                    //
                    m_pnselst.push_back(pnseInter);

                    // Now that the central object owns this
                    // engine, have the engine AddRef the
                    // net statistics central object
                    //
                    pStatEngine->SetParent(this);
                    AddRefObj(*ppnseNew = pStatEngine);
                }
                ReleaseObj(pnseInter);
            }
        }
        // Clean up the object on failure
        //
        if (FAILED(hr))
        {
            delete pStatEngine;
        }
    }

    if (SUCCEEDED(hr))
    {
        g_csStatCentral.Enter();

        // Do the one time initializations
        //
        if (!m_unTimerId)
        {
            // Make sure to start the timer
            //
            m_unTimerId = ::SetTimer(NULL,
                                     c_uiStatCentralRefreshID,
                                     c_uiStatCentralRefreshRate,
                                     TimerCallback);

            TraceTag(ttidStatMon, "Created Statistics Central Timer with ID of 0x%08x", m_unTimerId);
        }

        g_csStatCentral.Leave();
    }

    TraceError("CNetStatisticsCentral::CreateNetStatisticsEngine", hr);
    return hr;
}

HRESULT
HrGetStatisticsEngineForEntry (
                              const CONFOLDENTRY& ccfe,
                              INetStatisticsEngine** ppnse,
                              BOOL fCreate)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr;
    CNetStatisticsCentral* pnsc;

    // Get the central object.  Create if needed.
    //
    hr = CNetStatisticsCentral::HrGetNetStatisticsCentral(&pnsc, fCreate);
    if (SUCCEEDED(hr))
    {
        pnsc->Lock();

        // If the engine is already in the list, FEngineInList will
        // AddRef it for return.  If not, we'll create it.
        //
        if (!pnsc->FEngineInList(&(ccfe.GetGuidID()), ppnse))
        {
            if (fCreate)
            {
                hr = pnsc->HrCreateStatisticsEngineForEntry(ccfe, ppnse);
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }

        pnsc->Unlock();

        ReleaseObj(pnsc);
    }

    TraceError("HrGetStatisticsEngineForEntry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::RemoveNetStatisticsEngine
//
//  Purpose:    Removes a statistics engine from the list
//
//  Arguments:  pguidId - Identifies the engine to remove
//
//  Returns:    Error code
//
HRESULT
CNetStatisticsCentral::RemoveNetStatisticsEngine (
                                                 const GUID* pguidId)
{
    TraceFileFunc(ttidStatMon);

    HRESULT                                 hr      = S_OK;
    BOOL                                    fFound  = FALSE;
    CExceptionSafeComObjectLock             EsLock(this);
    GUID                                    guidTemp = { 0};

    AssertSz(pguidId, "We should have a pguidId");

    // Look for the item in our list
    //
    list<INetStatisticsEngine *>::iterator   iterPnse;
    INetStatisticsEngine*   pnseTemp;

    iterPnse = m_pnselst.begin();
    while ((SUCCEEDED(hr)) && (!fFound) && (iterPnse != m_pnselst.end()))
    {
        pnseTemp = *iterPnse;

        hr = pnseTemp->GetGuidId(&guidTemp);
        if (SUCCEEDED(hr))
        {
            if (guidTemp == *pguidId)
            {
                // We have found a match, so delete it from out list
                //
                fFound = TRUE;

                m_pnselst.erase(iterPnse);
                break;
            }
        }

        iterPnse++;
    }

    if (m_pnselst.empty())
    {
        // Stop the timer
        //
        if (m_unTimerId)
        {
            ::KillTimer(NULL, m_unTimerId);
            m_unTimerId = 0;
        }
    }

#if 0
    // $$REVIEW (jeffspr) - I removed this assert, as it was firing when my
    // tray item had deleted itself (and in return, the statmon object) on
    // disconnect. It's possible that we shouldn't have hit this code on the
    // first Release().
    AssertSz(fFound, "We didn't find the connection in our list");
#endif

    TraceError("CNetStatisticsCentral::RemoveNetStatisticsEngine", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::FEngineInList
//
//  Purpose:    Checks to see if an engine is already in the list
//
//  Arguments:  pguidId -   Guid of the connection trying to be located
//              ppnseRet -  Return location of a connection if it is already
//                          in the list.  NULL is valid
//
//  Returns:    TRUE if it is in the list, FALSE if it is not
//
BOOL
CNetStatisticsCentral::FEngineInList (
                                     const GUID*             pguidId,
                                     INetStatisticsEngine**  ppnseRet)
{
    TraceFileFunc(ttidStatMon);

    HRESULT                                 hr      = S_OK;
    BOOL                                    fRet    = FALSE;
    GUID                                    guidTemp = { 0};

    // Init the out param
    if (ppnseRet)
    {
        *ppnseRet = NULL;
    }

    // Try and find the engine in the list
    //
    list<INetStatisticsEngine *>::iterator   iterPnse;
    INetStatisticsEngine*   pnseTemp;

    iterPnse = m_pnselst.begin();
    while ((SUCCEEDED(hr)) && (!fRet) && (iterPnse != m_pnselst.end()))
    {
        pnseTemp = *iterPnse;
        hr = pnseTemp->GetGuidId(&guidTemp);

        if (SUCCEEDED(hr))
        {
            if (guidTemp == *pguidId)
            {
                // We have found a match
                //
                fRet = TRUE;

                // If we want a result, pass it back
                //
                if (ppnseRet)
                {
                    ::AddRefObj(*ppnseRet = pnseTemp);
                }
                break;
            }
        }

        iterPnse++;
    }

    TraceError("CNetStatisticsCentral::FEngineInList", hr);
    return fRet;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::HrReadTools
//
//  Purpose:    Look througth the registry for all tools that should be
//              entered in the tool list
//
//  Arguments:  None.
//
//  Returns:    Nil
//
HRESULT CNetStatisticsCentral::HrReadTools(VOID)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr              = S_OK;

    // Only read once
    //
    if (m_lstpsmte.empty())
    {
        WCHAR       szToolEntry[MAX_PATH];
        DWORD       dwSize          = celems(szToolEntry);
        DWORD       dwRegIndex      = 0;
        HKEY        hkeyToolsRoot   = NULL;
        FILETIME    ftTemp;

        // Open the existing key and see what is there
        //
        // "System\\CurrentControlSet\\Control\\Network\\Connections\\StatMon\\Tools"
        hr = ::HrRegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             c_szRegKeyToolsRoot,
                             KEY_READ,
                             &hkeyToolsRoot);

        if (SUCCEEDED(hr))
        {
            while (SUCCEEDED(hr = ::HrRegEnumKeyEx(
                                                  hkeyToolsRoot,
                                                  dwRegIndex++,
                                                  szToolEntry,
                                                  &dwSize,
                                                  NULL,
                                                  NULL,
                                                  &ftTemp)))
            {
                HKEY    hkeyToolEntry   = NULL;

                // Open the subkey
                //
                hr = ::HrRegOpenKeyEx(
                                     hkeyToolsRoot,
                                     szToolEntry,
                                     KEY_READ,
                                     &hkeyToolEntry);

                if (SUCCEEDED(hr))
                {
                    CStatMonToolEntry*  psmteTemp   = NULL;

                    // Read in the tool
                    //
                    psmteTemp = new CStatMonToolEntry;

                    TraceTag(ttidStatMon, "Reading parameters for tool %S", szToolEntry);
                    hr = HrReadOneTool(hkeyToolEntry, psmteTemp);

                    if (SUCCEEDED(hr))
                    {
                        // Add it to the list sorted
                        //
                        InsertNewTool(psmteTemp);
                    }
                    else
                    {
                        // Something when wrong, delete the entry
                        //
                        delete psmteTemp;
                    }

                    ::RegSafeCloseKey(hkeyToolEntry);
                }

                // Make sure the buffer entry is reset to it's original size
                //
                dwSize = celems(szToolEntry);
            }

            // Clear up a vaild error case
            //
            if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
            {
                hr = S_OK;
            }

            ::RegSafeCloseKey(hkeyToolsRoot);
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // It is okay if the key is not there
            //
            hr = S_OK;
        }
    }

    TraceError("CNetStatisticsCentral::HrReadTools", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::HrReadOneTool
//
//  Purpose:    Reads from the registry the tools characteristics
//
//  Arguments:  hkeyToolEntry - The root of the tool's registry entry
//              psmteNew -      The entry associated with the tool
//
//  Returns:    Error code.
//
HRESULT CNetStatisticsCentral::HrReadOneTool( HKEY hkeyToolEntry,
                                              CStatMonToolEntry* psmteNew)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr      = S_OK;

    AssertSz(psmteNew, "We should have an entry");

    //
    //  Read what we can out of the registry.
    //

    hr = ::HrRegQueryString(hkeyToolEntry,
                            c_szRegKeyToolsDisplayName,
                            &(psmteNew->strDisplayName));
    TraceError("Statmon Tool registration: failed getting DisplayName", hr);

    if (SUCCEEDED(hr))
    {
        hr = ::HrRegQueryString(hkeyToolEntry,
                                c_szRegKeyToolsManufacturer,
                                &(psmteNew->strManufacturer));
        TraceError("Stamon Tool registration: failed getting Manufacturer", hr);
    }

    if (SUCCEEDED(hr))
    {
        hr = ::HrRegQueryString(hkeyToolEntry,
                                c_szRegKeyToolsCommandLine,
                                &(psmteNew->strCommandLine));
        TraceError("Stamon Tool registration: failed getting CommandLine", hr);
    }

    if (SUCCEEDED(hr))
    {
        hr = ::HrRegQueryString(hkeyToolEntry,
                                c_szRegKeyToolsDescription,
                                &(psmteNew->strDescription));
        TraceError("Stamon Tool registration: failed getting Description", hr);
    }

    //
    // Read non-critical information
    //

    if (SUCCEEDED(hr))
    {
        HKEY    hkeyCriteria = NULL;

        // Open the "Criteria" subkey
        //
        hr = ::HrRegOpenKeyEx(
                             hkeyToolEntry,
                             c_szRegKeyToolsCriteria,
                             KEY_READ,
                             &hkeyCriteria);

        if (SUCCEEDED(hr))
        {
            //1) component list: "ComponentID"
            hr = HrRegQueryColString(hkeyCriteria,
                                     c_szRegKeyToolsComponentID,
                                     &psmteNew->lstpstrComponentID);

            // 2) connecton type: "ConnectionType"
            hr = HrRegQueryColString(hkeyCriteria,
                                     c_szRegKeyToolsConnectionType,
                                     &psmteNew->lstpstrConnectionType);

            // 3) Media type: "MediaType"
            hr = HrRegQueryColString(hkeyCriteria,
                                     c_szRegKeyToolsMedia,
                                     &psmteNew->lstpstrMediaType);

            // Close our handle
            //
            ::RegSafeCloseKey(hkeyCriteria);
        }

        // We don't care if we can't open the optional keys
        //
        hr = S_OK;
    }

    //
    // Read in the command line parameters to be passed to the tool
    //

    if (SUCCEEDED(hr))
    {
        hr = HrReadToolFlags(hkeyToolEntry, psmteNew);
    }

    TraceError("CNetStatisticsCentral::HrReadOneTool", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::HrReadToolFlags
//
//  Purpose:    Reads from the registry what flags are wanted when the tool
//              is launched
//
//  Arguments:  hkeyToolEntry - The registry key associated with the tool
//              psmteNew -      The entry associated with the tool
//
//  Returns:    Error code.
//
HRESULT CNetStatisticsCentral::HrReadToolFlags(HKEY hkeyToolEntry,
                                               CStatMonToolEntry* psmteNew)
{
    TraceFileFunc(ttidStatMon);

    HRESULT     hr              = S_OK;
    HKEY        hkeyToolFlags   = NULL;

    // Open the Flags key and see what is there
    //
    hr = ::HrRegOpenKeyEx(
                         hkeyToolEntry,
                         c_szRegKeyToolsFlags,
                         KEY_READ,
                         &hkeyToolFlags);

    if (SUCCEEDED(hr))
    {
        WCHAR       achBuf[MAX_PATH];
        DWORD       dwSize          = celems(achBuf);
        DWORD       dwType          = REG_SZ;
        DWORD       dwFlagValue     = 0;
        DWORD       dwIndex         = 0;
        DWORD       cbData          = sizeof(dwFlagValue);

        // Look for all the flags
        //
        while (SUCCEEDED(hr = ::HrRegEnumValue(
                                              hkeyToolFlags,
                                              dwIndex,
                                              achBuf,
                                              &dwSize,
                                              &dwType,
                                              reinterpret_cast<BYTE*>(&dwFlagValue),
                                              &cbData)))
        {
            INT     cTemp = 0;

            // Make sure they are registering DWORDs
            //
            if ((REG_DWORD == dwType) && (0 != dwFlagValue))
            {
                // Do a simple search for the flags.  If the list gets long,
                // we should use a better search method.
                //
                for (;c_cAsmtfMap > cTemp; cTemp++)
                {
                    // Look for the flag
                    //
                    if (0 == lstrcmpiW(achBuf, g_asmtfMap[cTemp].pszFlag))
                    {
                        // If we have a match, add it to the list
                        //
                        psmteNew->dwFlags |= g_asmtfMap[cTemp].dwValue;
                        break;
                    }
                }
            }
            else
            {
                AssertSz(FALSE, "Tool writer has registered an invalid flag");
            }

            // Make sure the buffer entry is reset to it's original size
            //
            dwSize = celems(achBuf);

            // Look at the next item
            //
            dwIndex++;
        }

        // Clear up a vaild error case
        //
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        ::RegSafeCloseKey(hkeyToolFlags);
    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // It is okay if the key is not there
        //
        hr = S_OK;
    }

    TraceError("CNetStatisticsCentral::HrReadToolFlags", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::InsertNewTool
//
//  Purpose:    Inserts a new tool to m_lstpsmte sorted in display name
//
//  Arguments:  psmteTemp - the new tool to insert
//
//  Returns:    none
//
VOID CNetStatisticsCentral::InsertNewTool(CStatMonToolEntry* psmteTemp)
{
    TraceFileFunc(ttidStatMon);

    Assert(psmteTemp);

    list<CStatMonToolEntry*>::iterator  iterSmte;
    iterSmte = m_lstpsmte.begin();

    BOOL fInserted = FALSE;
    tstring strDisplayName = psmteTemp->strDisplayName;

    while (iterSmte != m_lstpsmte.end())
    {
        if (strDisplayName < (*iterSmte)->strDisplayName)
        {
            m_lstpsmte.insert(iterSmte, psmteTemp);
            fInserted = TRUE;
            break;
        }
        else
        {
            // Move on the the next item.
            iterSmte++;
        }
    }

    if (!fInserted)
        m_lstpsmte.push_back(psmteTemp);
}


//+---------------------------------------------------------------------------
//
//  Member:     CNetStatisticsCentral::PlstsmteRegEntries
//
//  Purpose:    Hands back a pointer to all the tools found in the registry
//
//  Arguments:  None
//
//  Returns:    The address of the tool list
//
list<CStatMonToolEntry*>* CNetStatisticsCentral::PlstsmteRegEntries(VOID)
{
    return &m_lstpsmte;
}



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CStatMonToolEntry                                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////



//+---------------------------------------------------------------------------
//
//  Member:     CStatMonToolEntry::CStatMonToolEntry
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CStatMonToolEntry::CStatMonToolEntry(VOID) :
dwFlags(0)
{
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStatMonToolEntry::~CStatMonToolEntry
//
//  Purpose:    Destructor
//
//  Arguments:  None
//
//  Returns:    Nil
//
CStatMonToolEntry::~CStatMonToolEntry(VOID)
{
    ::FreeCollectionAndItem(lstpstrComponentID);
    ::FreeCollectionAndItem(lstpstrConnectionType);
    ::FreeCollectionAndItem(lstpstrMediaType);

    return;
}

//
// Critical Section class to protect creation of CNetStatisticsCentral.
//

CStatCentralCriticalSection::CStatCentralCriticalSection()
{
    TraceFileFunc(ttidStatMon);

    __try {
        InitializeCriticalSection( &m_csStatCentral );

        bInitialized = TRUE;
    }

    __except( EXCEPTION_EXECUTE_HANDLER ) {
    
        bInitialized = FALSE;    
    }
}

CStatCentralCriticalSection::~CStatCentralCriticalSection()
{
    if ( bInitialized )
    {
        DeleteCriticalSection( &m_csStatCentral );
    }
}

HRESULT CStatCentralCriticalSection::Enter()
{
    TraceFileFunc(ttidStatMon);

    if ( bInitialized )
    {
        EnterCriticalSection( &m_csStatCentral );
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

VOID CStatCentralCriticalSection::Leave()
{
    TraceFileFunc(ttidStatMon);
    
    if ( bInitialized )
    {
        LeaveCriticalSection( &m_csStatCentral );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smeng.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       S M E N G . H
//
//  Contents:   The engine that provides statistics to the status monitor
//
//  Notes:
//
//  Author:     CWill   7 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "cfpidl.h"
#include "ncnetcon.h"
#include "smutil.h"
#include "hnetbcon.h"

typedef struct tagPersistConn
{
    BYTE*   pbBuf;
    ULONG   ulSize;
    CLSID   clsid;
}  PersistConn;

extern CRITICAL_SECTION    g_csStatmonData;

class CPspStatusMonitorGen;
class CPspStatusMonitorTool;
class CPspStatusMonitorRas;
class CPspStatusMonitorIpcfg;

#define _ATL_DEBUG_INTERFACES

class ATL_NO_VTABLE CNetStatisticsEngine :
    public CComObjectRootEx <CComObjectThreadModel>,
    public IConnectionPointImpl <CNetStatisticsEngine,
                                    &IID_INetConnectionStatisticsNotifySink>,
    public IConnectionPointContainerImpl <CNetStatisticsEngine>,
    public INetStatisticsEngine
{
public:
    ~CNetStatisticsEngine(VOID);

    BEGIN_COM_MAP(CNetStatisticsEngine)
        COM_INTERFACE_ENTRY(INetStatisticsEngine)
        COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    END_COM_MAP()

    BEGIN_CONNECTION_POINT_MAP(CNetStatisticsEngine)
        CONNECTION_POINT_ENTRY(IID_INetConnectionStatisticsNotifySink)
    END_CONNECTION_POINT_MAP()

// INetStatisticsEngine
//
public:
    STDMETHOD(StartStatistics)(VOID);
    STDMETHOD(StopStatistics)(VOID);
    STDMETHOD(ShowStatusMonitor)(VOID);
    STDMETHOD(CloseStatusMonitor)(VOID);
    STDMETHOD(UpdateStatistics)(BOOL* pfNoLongerConnected);
    STDMETHOD(UpdateTitle)(PCWSTR pszwNewName);
    STDMETHOD(UpdateRasLinkList)();
    STDMETHOD(GetGuidId)(GUID* pguidId);
    STDMETHOD(GetStatistics)(STATMON_ENGINEDATA** ppseAllData);

// Secret interfaces
//
public:
    HRESULT     HrInitStatEngine(const CONFOLDENTRY& pccfe);
    VOID        SetParent(CNetStatisticsCentral * pnsc)
                {
                    AssertH(NULL == m_pnsc);
                    m_pnsc = pnsc;
                    ::AddRefObj(m_pnsc);
                }
    VOID        SetPropsheetWindow(HWND hwnd)
                {
                    m_hwndPsh = hwnd;
                }
    VOID        UnSetCreatingDialog()
                {
                    m_fCreatingDialog = FALSE;
                }

    HRESULT HrGetConnectionFromBlob (INetConnection** ppCon)
    {
        return HrGetConnectionFromPersistData(
                    m_PersistConn.clsid,
                    m_PersistConn.pbBuf,
                    m_PersistConn.ulSize,
                    IID_INetConnection,
                    reinterpret_cast<VOID**>(ppCon));
    }

// Callback for the property sheet page
//
public:
    static INT CALLBACK PshCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam);
    static DWORD MonitorThread(CNetStatisticsEngine * pnse);

// Utility functions
//
private:

// Connection class specific functions
//
private:
    virtual HRESULT HrUpdateData(DWORD* pdwChangeFlags, BOOL* pfNoLongerConnected) PURE;

protected:
    CNetStatisticsEngine(VOID);

protected:
    // Net Statistics Central object
    //
    CNetStatisticsCentral * m_pnsc;

    // Property sheet data
    //
    CPspStatusMonitorGen*   m_ppsmg;
    CPspStatusMonitorTool*  m_ppsmt;
    CPspStatusMonitorRas*   m_ppsmr;
    CPspStatusMonitorIpcfg* m_ppsms;

    // Connection data
    //
    STATMON_ENGINEDATA*     m_psmEngineData;

    // Connection identifiers
    //
    GUID                    m_guidId;
    NETCON_MEDIATYPE        m_ncmType;
    NETCON_SUBMEDIATYPE     m_ncsmType;
    DWORD                   m_dwCharacter;

    PersistConn             m_PersistConn;

    LONG                    m_cStatRef;
    BOOL                    m_fRefreshIcon;
    HWND                    m_hwndPsh;
    DWORD                   m_dwChangeFlags;

    // This boolean synchronizes the thread that creates the property sheet
    // in CNetStatisticsEngine::ShowStatusMonitor
    BOOL m_fCreatingDialog;
};

class CRasStatEngine : public CNetStatisticsEngine
{
public:
    CRasStatEngine();
    VOID put_RasConn(HRASCONN hRasConn);

    VOID put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType);
    VOID put_Character(DWORD dwCharacter);

    HRESULT HrUpdateData(DWORD* pdwChangeFlags, BOOL* pfNoLongerConnected);

private:
    HRASCONN   m_hRasConn;
};


class CLanStatEngine : public CNetStatisticsEngine
{
public:
    CLanStatEngine();
    HRESULT put_Device(tstring* pstrName);
    VOID put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType);
    HRESULT HrUpdateData(DWORD* pdwChangeFlags, BOOL* pfNoLongerConnected);
private:
    tstring                 m_strDevice;
    UNICODE_STRING          m_ustrDevice;
};

class CSharedAccessStatEngine : public CNetStatisticsEngine
{
public:
    CSharedAccessStatEngine();
    HRESULT HrUpdateData(DWORD* pdwChangeFlags, BOOL* pfNoLongerConnected);
    HRESULT Initialize(NETCON_MEDIATYPE MediaType, INetSharedAccessConnection* pNetSharedAccessConnection);
    HRESULT FinalConstruct(VOID);
    HRESULT FinalRelease(VOID);

private:

    static HRESULT GetStringStateVariable(IUPnPService* pService, LPWSTR pszVariableName, BSTR* pString);
    static HRESULT InvokeVoidAction(IUPnPService * pService, LPTSTR pszCommand, VARIANT* pOutParams);
    static DWORD WINAPI StaticUpdateStats(LPVOID lpParameter);
    HRESULT UpdateStats();

    WCHAR m_szLocalDeviceGuidStorage[64];  // enough for \Device\{...GUID...}
    UNICODE_STRING          m_LocalDeviceGuid;

    IGlobalInterfaceTable* m_pGlobalInterfaceTable;
    DWORD m_dwCommonInterfaceCookie;
    DWORD m_dwWANConnectionCookie;

    BOOL m_bRequested;
    NETCON_STATUS m_Status;
    ULONG m_ulTotalBytesSent;
    ULONG m_ulTotalBytesReceived;
    ULONG m_ulTotalPacketsSent;
    ULONG m_ulTotalPacketsReceived;
    ULONG m_ulUptime;
    ULONG m_ulSpeedbps;


};

HRESULT HrGetAutoNetSetting(PWSTR pszGuid, DHCP_ADDRESS_TYPE * pAddrType);
HRESULT HrGetAutoNetSetting(REFGUID pGuidId, DHCP_ADDRESS_TYPE * pAddrType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\resource.h ===
#include "nsres.h"

#define IDD_STATMON_GENERAL_LAN         1801
#define IDD_STATMON_GENERAL_RAS         1802
#define IDD_STATMON_TOOLS               1803
#define IDD_STATMON_RAS                 1804
#define IDD_STATMON_GENERAL_SHAREDACCESS 1805
#define IDD_PROPPAGE_IPCFG              1806
#define IDD_DIALOG_ADV_IPCFG            1807
#define IDC_LST_SM_TOOLS                1001
#define IDC_BTN_SM_TOOLS_OPEN           1002
#define IDC_TXT_SM_BYTES_TRANS          1003
#define IDC_TXT_SM_COMP_TRANS           1004
#define IDC_TXT_SM_BYTES_RCVD           1005
#define IDC_TXT_SM_COMP_RCVD            1006
#define IDC_TXT_SM_STATUS               1007
#define IDC_TXT_SM_DURATION             1008
#define IDC_TXT_SM_SPEED                1009
#define IDI_SM_STATUS_ICON              1010
#define IDC_TXT_SM_TOOL_DESC            1011
#define IDC_TXT_SM_ERROR_TRANS          1012
#define IDC_TXT_SM_ERROR_RECV           1013
#define IDC_TXT_SM_TOOL_MAN             1014
#define IDC_TXT_SM_TOOL_COMMAND         1015
#define IDC_LVW_RAS_PROPERTY            1016
#define IDC_BTN_SM_SUSPEND_DEVICE       1019
#define IDC_CMB_SM_RAS_DEVICES          1020
#define IDC_TXT_SM_NUM_DEVICES          1021
#define IDC_TXT_SM_NUM_DEVICES_VAL      1022
#define IDC_TXT_SM_BYTES_LABEL          1023
#define IDC_GB_SM_DEVICES               1024
#define IDC_PSB_DISCONNECT              1025
#define IDC_PSB_PROPERTIES              1026
#define IDC_TXT_ERROR                   1027
#define IDC_FRM_LONG                    1028
#define IDC_FRM_SHORT                   1029
#define IDC_FRM_LEFT                    1030
#define IDC_FRM_RIGHT                   1031
#define IDC_TXT_SM_STATUS_LABEL         1032
#define IDC_TXT_SM_DURATION_LABEL       1033
#define IDC_TXT_SM_SPEED_LABEL          1034
#define IDC_TXT_SENT_LABEL              1035
#define IDC_TXT_RECEIVED_LABEL          1036
#define IDC_TXT_CPMPRESSION_LABEL       1037
#define IDC_TXT_TOOLS_LABEL             1038
#define IDC_TXT_MANUFACTURER_LABEL      1039
#define IDC_TXT_COMMANDLINE_LABEL       1040
#define IDC_TXT_SM_SALOCAL_BYTES_TRANS  1041
#define IDC_TXT_SM_SALOCAL_BYTES_RCVD   1042
#define IDC_TXT_SM_SIGNAL_STRENGTH      1043
#define IDI_SM_SIGNAL_STRENGTH_ICON     1044
#define IDC_TXT_SAINTERNET_LABEL        1045
#define IDC_TXT_SAGATEWAY_LABEL         1046
#define IDC_TXT_SACOMPUTER_LABEL        1047
#define IDC_ICON_SAINTERNET             1048
#define IDC_ICON_SAGATEWAY              1049
#define IDC_STATE_IPADDR                1050
#define IDC_STATE_SUBNET                1051
#define IDC_STATE_GATEWAY               1052
#define IDC_STATE_SOURCE                1053
#define IDC_STATE_STATIC_GROUP          1054
#define IDC_STATIC_STATE_SOURCE         1055
#define IDC_STATE_BTN_REPAIR            1056
#define IDC_STATIC_STATE_IPADDR         1057
#define IDC_STATIC_STATE_SUBNET         1058
#define IDC_STATIC_STATE_GATEWAY        1059
#define IDC_STATE_BTN_DETAIL            1062

#define IDC_LIST_IPCFG                  1070

#define IDC_STATIC                      -1

#define IDS_NC_STATMON                  23000

// Statmon caption

#define IDS_STATMON_CAPTION            (IDS_NC_STATMON +1)

// Connections states
//
#define IDS_SM_CS_DISCONNECTED          (IDS_NC_STATMON + 10)
#define IDS_SM_CS_CONNECTING            (IDS_SM_CS_DISCONNECTED + 1)
#define IDS_SM_CS_CONNECTED             (IDS_SM_CS_DISCONNECTED + 2)
#define IDS_SM_CS_DISCONNECTING         (IDS_SM_CS_DISCONNECTED + 3)
#define IDS_SM_CS_HARDWARE_NOT_PRESENT  (IDS_SM_CS_DISCONNECTED + 4)
#define IDS_SM_CS_HARDWARE_DISABLED     (IDS_SM_CS_DISCONNECTED + 5)
#define IDS_SM_CS_HARDWARE_MALFUNCTION  (IDS_SM_CS_DISCONNECTED + 6) 

#define IDS_SM_PSH_CLOSE                (IDS_NC_STATMON + 20)
#define IDS_SM_PSH_DISCONNECT           (IDS_SM_PSH_CLOSE + 1)

// BPS strings
//
#define IDS_SM_BPS_ZERO                 (IDS_NC_STATMON + 30)
#define IDS_SM_BPS_KILO                 (IDS_SM_BPS_ZERO + 1)
#define IDS_SM_BPS_MEGA                 (IDS_SM_BPS_ZERO + 2)
#define IDS_SM_BPS_GIGA                 (IDS_SM_BPS_ZERO + 3)
#define IDS_SM_BPS_TERA                 (IDS_SM_BPS_ZERO + 4)

// Error messages
//
#define IDS_SM_ERROR_CAPTION            (IDS_NC_STATMON + 40)
#define IDS_SM_CAPTION                  (IDS_SM_ERROR_CAPTION + 1)
#define IDS_SM_ERROR_CANNOT_DISCONNECT  (IDS_SM_CAPTION + 1)

// Dialog strings
//
#define IDS_SM_BYTES                    (IDS_NC_STATMON + 50)
#define IDS_SM_PACKETS                  (IDS_SM_BYTES + 1)
#define IDS_SM_SUSPEND                  (IDS_SM_BYTES + 2)
#define IDS_SM_RESUME                   (IDS_SM_BYTES + 3)
#define IDS_SM_DISCONNECT_PROMPT        (IDS_SM_RESUME + 1)
#define IDS_PROPERTY                    (IDS_SM_RESUME +2)
#define IDS_VALUE                       (IDS_SM_RESUME +3)

#define IDS_PPP                 (IDS_SM_RESUME +4)
#define IDS_SLIP                (IDS_SM_RESUME +5)
#define IDS_TCPIP               (IDS_SM_RESUME +6)
#define IDS_IPX                 (IDS_SM_RESUME +7)
#define IDS_NBF                 (IDS_SM_RESUME +8)
#define IDS_APPLETALK           (IDS_SM_RESUME +9)

#define IDS_ServerType          (IDS_SM_RESUME +10)
#define IDS_Transports          (IDS_SM_RESUME +11)

#define IDS_ServerIP            (IDS_SM_RESUME +12)
#define IDS_ClientIP            (IDS_SM_RESUME +13)
#define IDS_ClientIPX           (IDS_SM_RESUME +14)
#define IDS_ComputerName        (IDS_SM_RESUME +15)   

#define IDS_Day        (IDS_SM_RESUME +16) 
#define IDS_Days       (IDS_SM_RESUME +17) 

#define IDS_Authentication     (IDS_SM_RESUME +19)
#define IDS_Encryption         (IDS_SM_RESUME +20)
#define IDS_IPSECEncryption    (IDS_SM_RESUME +21)
#define IDS_Compression        (IDS_SM_RESUME +22)

#define IDS_PAP        (IDS_SM_RESUME +23) 
#define IDS_SPAP       (IDS_SM_RESUME +24) 
#define IDS_CHAP       (IDS_SM_RESUME +25) 
#define IDS_CHAP_MD5   (IDS_SM_RESUME +26) 
#define IDS_CHAP_V2    (IDS_SM_RESUME +27) 
#define IDS_EAP        (IDS_SM_RESUME +28) 

#define IDS_DeviceName (IDS_SM_RESUME +29) 
#define IDS_DeviceType (IDS_SM_RESUME +30) 

#define IDS_Encryption56bit       (IDS_SM_RESUME +40) 
#define IDS_Encryption40bit       (IDS_SM_RESUME +41) 
#define IDS_Encryption128bit      (IDS_SM_RESUME +42)
#define IDS_EncryptionDES56       (IDS_SM_RESUME +43)
#define IDS_EncryptionDES40       (IDS_SM_RESUME +44)
#define IDS_Encryption3DES        (IDS_SM_RESUME +45)

#define IDS_MPPC        (IDS_SM_RESUME +50) 
#define IDS_STAC        (IDS_SM_RESUME +51) 
#define IDS_NONE        (IDS_SM_RESUME +52) 

#define IDS_ML_Framing  (IDS_SM_RESUME +60)
#define IDS_ON          (IDS_SM_RESUME +61)
#define IDS_OFF         (IDS_SM_RESUME +62)

#define IDS_ADDRESS_UNAVALABLE  (IDS_SM_RESUME + 73)
#define IDS_ADDRESS_NONE        (IDS_SM_RESUME + 74)
#define IDS_INVALID_ADDR        (IDS_SM_RESUME + 75)
#define IDS_SM_MSG_CAPTION      (IDS_SM_RESUME + 76)
#define IDS_SM_SUCCESS_RENEW    (IDS_SM_RESUME + 78)
#define IDS_SM_ERROR_RENEW      (IDS_SM_RESUME + 79)
#define IDS_SM_SUCCESS_FLUSHDNS (IDS_SM_RESUME + 80)
#define IDS_SM_ERROR_FLUSHDNS   (IDS_SM_RESUME + 81)
#define IDS_SM_SUCCESS_REGDNS   (IDS_SM_RESUME + 82)
#define IDS_SM_ERROR_REGDNS     (IDS_SM_RESUME + 83)
#define IDS_WIN32_ERROR_MSG_FORMAT (IDS_SM_RESUME + 84)

#define IDS_IPCFG_PH_ADDR       (IDS_SM_RESUME + 90)
#define IDS_IPCFG_IPADDR        (IDS_SM_RESUME + 92)
#define IDS_IPCFG_IPADDR_PL     (IDS_SM_RESUME + 93)
#define IDS_IPCFG_SUBNET        (IDS_SM_RESUME + 94)
#define IDS_IPCFG_SUBNET_PL     (IDS_SM_RESUME + 95)
#define IDS_IPCFG_DEFGW         (IDS_SM_RESUME + 96)
#define IDS_IPCFG_DEFGW_PL      (IDS_SM_RESUME + 98)
#define IDS_IPCFG_DHCP          (IDS_SM_RESUME + 99)
#define IDS_IPCFG_DNS           (IDS_SM_RESUME + 100)
#define IDS_IPCFG_DNS_PL        (IDS_SM_RESUME + 101)
#define IDS_IPCFG_WINS          (IDS_SM_RESUME + 102)
#define IDS_IPCFG_WINS_PL       (IDS_SM_RESUME + 103)
#define IDS_IPCFG_LEASE_OBT     (IDS_SM_RESUME + 104)
#define IDS_IPCFG_LEASE_EXP     (IDS_SM_RESUME + 105)
#define IDS_IPCFG_PRAMETER      (IDS_SM_RESUME + 106)
#define IDS_IPCFG_VALUE         (IDS_SM_RESUME + 107)

#define IDS_SM_NOTAVAILABLE     (IDS_SM_RESUME + 108)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wsetup.cpp ===
#include "pch.h"
#pragma hdrstop
#include "ncui.h"
#include "ncmisc.h"
#include "netcfgn.h"
#include "netshell.h"
#include "resource.h"
#include "nsres.h"      // For Icon's
#include "wizard.h"
#include "..\folder\foldres.h"
#include "wgenericpage.h"

// Setup Wizard Global - Only used during setup.
CWizard * g_pSetupWizard = NULL;

//
// Function:    HrRequestWizardPages
//
// Purpose:     To supply a max count of wizard pages or to supply and actual
//              count and the actual pages
//
// Parameters:
//
// Returns:     HRESULT, S_OK if the function succeeded
//                       S_FALSE if no pages were returned
//                       otherwise a failure HRESULT
//
HRESULT HrRequestWizardPages(CWizard **ppWizard,
                             BOOL fLanPages,
                             ProviderList * rgpProviders,
                             ULONG  cProviders,
                             HPROPSHEETPAGE* pahpsp,
                             UINT* pcPages,
                             PINTERNAL_SETUP_DATA pData,
                             BOOL fDeferProviderLoad)
{
    HRESULT hr       = S_OK;

    Assert(NULL != pData);

    if ((NULL == pData) ||
        (sizeof(INTERNAL_SETUP_DATA) < pData->dwSizeOf))
    {
        hr = E_INVALIDARG;
    }
    else if (pcPages && pData)
    {
        UINT      cProviderPages = 0;
        BOOL      fCountOnly = (NULL == pahpsp);
        CWizard * pWizard = *ppWizard;

        // Create the Wizard object if not already created
        if (NULL == pWizard)
        {
            // Create the wizard interface
            HRESULT hr = CWizard::HrCreate(&pWizard, fLanPages, pData, fDeferProviderLoad);
            if (FAILED(hr))
            {
                TraceHr(ttidWizard, FAL, hr, FALSE, "HrRequestWizardPages");
                return hr;
            }

            Assert(NULL != pWizard);
            *ppWizard = pWizard;

            // If there is an unattended file, read the options (READONLY, etc)
            //
            ReadAnswerFileSetupOptions(pWizard);
        }

        // Count/Create all necessary pages
        *pcPages = 0;

        Assert(NULL != pWizard);
        Assert(NULL != pData);
        Assert(NULL != pcPages);

        // Load the wizard page providers used in setup
        pWizard->LoadWizProviders(cProviders, rgpProviders);

        if (!pWizard->FDeferredProviderLoad())
        {
            // Count/Create Provider Pages first
            hr = pWizard->HrCreateWizProviderPages(fCountOnly, &cProviderPages);
            if (FAILED(hr))
            {
                goto Error;
            }

            (*pcPages) += cProviderPages;
        }

        // Count/Create all other pages
        hr = HrCreateUpgradePage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateMainIntroPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateMainPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateISPPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateInternetPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }
        
        hr = CGenericFinishPage::HrCreateCGenericFinishPagePage(IDD_FinishOtherWays, pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }
        
        hr = CGenericFinishPage::HrCreateCGenericFinishPagePage(IDD_ISPSoftwareCD, pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = CGenericFinishPage::HrCreateCGenericFinishPagePage(IDD_Broadband_Always_On, pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = CGenericFinishPage::HrCreateCGenericFinishPagePage(IDD_FinishNetworkSetupWizard, pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateConnectPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateAdvancedPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateFinishPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrCreateJoinPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        if (*pcPages)
        {
            hr = HrCreateExitPage(pWizard, pData, fCountOnly, pcPages);
            if (FAILED(hr))
            {
                goto Error;
            }
        }

        hr = HrCreateNetDevPage(pWizard, pData, fCountOnly, pcPages);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Assemble all created pages into the output array
        if (!fCountOnly)
        {
            UINT cExpected = *pcPages;
            *pcPages = 0;

            Assert(NULL != pahpsp);

            AppendUpgradePage(pWizard, pahpsp, pcPages);
            AppendMainIntroPage(pWizard, pahpsp, pcPages);
            AppendMainPage(pWizard, pahpsp, pcPages);
            AppendISPPage(pWizard, pahpsp, pcPages);
            AppendInternetPage(pWizard, pahpsp, pcPages);
            CGenericFinishPage::AppendCGenericFinishPagePage(IDD_FinishOtherWays, pWizard, pahpsp, pcPages);
            CGenericFinishPage::AppendCGenericFinishPagePage(IDD_ISPSoftwareCD, pWizard, pahpsp, pcPages);
            CGenericFinishPage::AppendCGenericFinishPagePage(IDD_Broadband_Always_On, pWizard, pahpsp, pcPages);
            CGenericFinishPage::AppendCGenericFinishPagePage(IDD_FinishNetworkSetupWizard, pWizard, pahpsp, pcPages);
            
            AppendConnectPage(pWizard, pahpsp, pcPages);
            AppendAdvancedPage(pWizard, pahpsp, pcPages);
            pWizard->AppendProviderPages(pahpsp, pcPages);
            AppendFinishPage(pWizard, pahpsp, pcPages);
            AppendJoinPage(pWizard, pahpsp, pcPages);
            if (*pcPages)
            {
                AppendExitPage(pWizard, pahpsp, pcPages);
            }
            AppendNetDevPage(pWizard, pahpsp, pcPages);
            Assert(cExpected == *pcPages);
        }

        if (0 == *pcPages)
        {
            Assert(SUCCEEDED(hr));
            hr = S_FALSE;
        }
    }

Error:
    TraceHr(ttidWizard, FAL, hr,(S_FALSE == hr), "CWizProvider::HrCreate");
    return hr;
}

//
// Function:    FSetupRequestWizardPages
//
// Purpose:     To supply a max count of wizard pages or to supply and actual
//              count and the actual pages
//
// Parameters:
//
// Returns:     BOOL, TRUE if the function succeeded, false on failure
//
BOOL FSetupRequestWizardPages(HPROPSHEETPAGE* pahpsp,
                              UINT* pcPages,
                              PINTERNAL_SETUP_DATA psp)
{
    HRESULT      hr;
    BOOL         fCoUninitialze = TRUE;
    ProviderList rgProviderLan[] = {{&CLSID_LanConnectionUi, 0}};

    Assert(NULL == g_pSetupWizard);

#ifdef DBG
    if (FIsDebugFlagSet (dfidBreakOnWizard))
    {
        ShellExecute(NULL, L"open", L"cmd.exe", NULL, NULL, SW_SHOW);
        AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                 "\"BreakOnWizard\" has been set. Set your breakpoints now.");
    }
#endif // DBG

    // CoInitialize because setup doesn't do it for us
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (RPC_E_CHANGED_MODE == hr)
    {
        // Ignore any change mode error
        hr = S_OK;
        fCoUninitialze =  FALSE;
    }
    if (SUCCEEDED(hr))
    {
        hr = HrRequestWizardPages(&g_pSetupWizard, TRUE, rgProviderLan,
                                  celems(rgProviderLan), pahpsp, pcPages,
                                  psp, FALSE);
        if (S_OK == hr)
        {
            Assert(NULL != g_pSetupWizard);
            g_pSetupWizard->SetCoUninit(fCoUninitialze);
            return TRUE;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrSetWizardTaskbarIcon
//
//  Purpose:    Setup the wizard's taskbar icon.
//
//  Arguments:
//      hwndDlg  [in]  Dialog handle
//      uMsg     [in]  Message value
//      lparam   [in]  Long parameter
//
//  Returns:    0
//
//  Notes:      A standard Win32 commctrl PropSheetProc always return 0.  
//              See MSDN documentation.
//
int CALLBACK HrSetWizardTaskbarIcon(
    IN HWND   hwndDlg,
    IN UINT   uMsg,
    IN LPARAM lparam)

{

    HICON  hIcon;


    switch (uMsg)
    {
        case PSCB_INITIALIZED:

            // Set the dialog window's icon
            hIcon = LoadIcon(_Module.GetResourceInstance(), 
                             MAKEINTRESOURCE(IDI_CONFOLD_WIZARD));

            Assert(hIcon);

            if (hIcon)
            {
                SendMessage(hwndDlg,
                            WM_SETICON,
                            ICON_BIG,
                            (LPARAM)(HICON)hIcon);
            }
            break;

        default:
            break;

    }

    return 0;
}

//
// Function:    FSetupFreeWizardPages
//
// Purpose:     To clean up after the wizard has been used by setup
//
// Parameters:
//
// Returns:     BOOL, TRUE if the function succeeded, false on failure
//
BOOL FSetupFreeWizardPages()
{
    delete g_pSetupWizard;
    g_pSetupWizard = NULL;

    return TRUE;
}

EXTERN_C
HRESULT 
WINAPI
HrRunWizard(HWND hwnd, BOOL fPnpAddAdapter, INetConnection ** ppConn, DWORD dwFirstPage)
{
    DWORD adwTestedPages[] = {0, CHK_MAIN_VPN, IDD_Connect};

    CWizard *           pWizard = NULL;
    PROPSHEETHEADER     psh;
    HRESULT             hr = S_OK;
    HPROPSHEETPAGE *    phPages = NULL;
    INT                 nRet = 0;
    UINT                cPages = 0;
    PRODUCT_FLAVOR      pf;
    ProviderList *      rgpProviders;
    ULONG               culProviders;
    INTERNAL_SETUP_DATA sp = {0};

    BOOL fIsRequestedPageTested = FALSE;

    for (DWORD dwCount = 0; dwCount < celems(adwTestedPages); dwCount++)
    {
        if (adwTestedPages[dwCount] == dwFirstPage)
        {
            fIsRequestedPageTested = TRUE;
        }
    }

    if (!fIsRequestedPageTested)
    {
#ifdef DBG
        AssertSz(NULL, "The requested start page passed to HrRunWizard/StartNCW has not been certified to work through the API. "
                       "If this page indeed works correctly according to your specifications, please update the Requested pages list "
                       "inside this file. In FRE builds this API will open page 0 instead of asserting.")
#else
        dwFirstPage = 0;    
#endif
    }


    if (NULL != ppConn)
    {
        *ppConn = NULL;
    }

    // ISSUE - the order of these is critical.
    // Backup becomes a problem if the last item is not a provider from the
    //  advanced dialog. The problem is that whatever provider is the last
    //  in the list it automatically backs up to the advanced page.
    //  This should be investigated further after Whistler.
    //
    //  Bug 233403: Add an entry for internet connection through dialup. ICW is no longer called.

    ProviderList rgProviderRas[] = {{&CLSID_PPPoEUi, CHK_MAIN_PPPOE},
                                    {&CLSID_VpnConnectionUi, CHK_MAIN_VPN},
                                    {&CLSID_InternetConnectionUi, CHK_MAIN_INTERNET},
                                    {&CLSID_DialupConnectionUi, CHK_MAIN_DIALUP},
                                    {&CLSID_InboundConnectionUi, CHK_MAIN_INBOUND},
                                    {&CLSID_DirectConnectionUi, CHK_MAIN_DIRECT}};

    // Begin the wait cursor
    {
        BOOL fJumpToProviderPage = FALSE;
        CWaitCursor wc;

        if ((dwFirstPage >= CHK_MAIN_DIALUP) &&
            (dwFirstPage <= CHK_MAIN_ADVANCED))
        {
            fJumpToProviderPage = TRUE;
        }
                 
        INITCOMMONCONTROLSEX iccex = {0};
        iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        iccex.dwICC  = ICC_LISTVIEW_CLASSES |
                       ICC_ANIMATE_CLASS |
                       ICC_USEREX_CLASSES;
        SideAssert(InitCommonControlsEx(&iccex));

        sp.OperationFlags = SETUPOPER_POSTSYSINSTALL;
        sp.dwSizeOf = sizeof(INTERNAL_SETUP_DATA);
        sp.SetupMode = SETUPMODE_TYPICAL;
        sp.WizardTitle = SzLoadIds(IDS_WIZARD_CAPTION);
        sp.SourcePath = NULL;
        sp.UnattendFile = NULL;
        sp.LegacySourcePath = NULL;

        GetProductFlavor (NULL, &pf);
        sp.ProductType = (PF_WORKSTATION == pf) ? PRODUCT_WORKSTATION
                                                : PRODUCT_SERVER_STANDALONE;

        Assert(!fPnpAddAdapter);

        culProviders = celems(rgProviderRas);
        rgpProviders = rgProviderRas;

        hr = HrRequestWizardPages(&pWizard, fPnpAddAdapter, rgpProviders,
                                  culProviders, NULL, &cPages, &sp, !fJumpToProviderPage);
        if ((S_OK != hr) || (0 == cPages) || (NULL == pWizard))
        {
            goto Done;
        }

        Assert(pWizard);

        if (dwFirstPage)
        {
            pWizard->SetFirstPage(dwFirstPage);
        }

        // Allocate the requested pages
        phPages = reinterpret_cast<HPROPSHEETPAGE *>
                                (MemAlloc(sizeof(HPROPSHEETPAGE) * cPages));
        if (NULL == phPages)
        {
            hr = E_OUTOFMEMORY;
            TraceHr(ttidWizard, FAL, E_OUTOFMEMORY, FALSE, "HrRunWizard");
            goto Done;
        }

        hr = HrRequestWizardPages(&pWizard, fPnpAddAdapter, rgpProviders,
                                  culProviders, phPages, &cPages, &sp, !fJumpToProviderPage);
        if ((S_OK != hr) || (0 == cPages))
        {
            goto Done;
        }

        ZeroMemory(&psh, sizeof(psh));
        psh.dwSize          = sizeof(PROPSHEETHEADER);
        psh.dwFlags         = PSH_WIZARD | PSH_WIZARD97 | PSH_NOAPPLYNOW | PSH_WATERMARK 
                              | PSH_HEADER | PSH_STRETCHWATERMARK | PSH_USECALLBACK | PSH_USEICONID;
        psh.hwndParent      = hwnd;
        psh.hInstance       = _Module.GetResourceInstance();
        psh.nPages          = cPages;
        psh.phpage          = phPages;
        psh.pszbmWatermark  = MAKEINTRESOURCE(IDB_WIZINTRO);
        psh.pszbmHeader     = MAKEINTRESOURCE(IDB_WIZHDR);
        psh.pszIcon         = MAKEINTRESOURCE(IDI_CONFOLD_WIZARD);
        psh.pfnCallback     = HrSetWizardTaskbarIcon;

        if (pWizard->GetFirstPage())
        {
            if ( fJumpToProviderPage )
            {
                for (ULONG ulIdx = 0; ulIdx < pWizard->UlProviderCount(); ulIdx++)
                {
                    CWizProvider * pWizProvider = pWizard->PWizProviders(ulIdx);
                    Assert(NULL != pWizProvider);

                    if (pWizard->GetFirstPage() == pWizProvider->GetBtnIdc())
                    {
                        pWizard->SetCurrentProvider(ulIdx);
                        Assert(pWizProvider->ULPageCount());
                        
                        HPROPSHEETPAGE hPage = (pWizProvider->PHPropPages())[0];
                        Assert(NULL != hPage);

                        for (DWORD x = 0; x < cPages; x++)
                        {
                            if (phPages[x] == hPage)
                            {
                                psh.nStartPage = x;
                            }
                        }
                    }
                }
                Assert(psh.nStartPage);
            }
            else
            {
                psh.nStartPage = pWizard->GetPageIndexFromIID(dwFirstPage);
            }
        }

    } // end the wait cursor

    // raise frame
    hr = S_FALSE;
    if (-1 != PropertySheet(&psh))
    {
        // Return the request connection
        if (ppConn && pWizard->GetCachedConnection())
        {
            *ppConn = pWizard->GetCachedConnection();
            AddRefObj(*ppConn);
            hr = S_OK;
        }
    }

    MemFree(phPages);

Done:
    delete pWizard;
    TraceHr(ttidWizard, FAL, hr, (S_FALSE == hr), "CWizProvider::HrCreate");
    return hr;
}

VOID SetICWComplete()
{
    static const TCHAR REG_KEY_ICW_SETTINGS[] = TEXT("Software\\Microsoft\\Internet Connection Wizard");
    static const TCHAR REG_VAL_ICWCOMPLETE[]  = TEXT("Completed");
    
    HKEY    hkey          = NULL;
    DWORD   dwValue       = 1;
    DWORD   dwDisposition = 0;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
                                       REG_KEY_ICW_SETTINGS,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE, 
                                       KEY_ALL_ACCESS, 
                                       NULL, 
                                       &hkey, 
                                       &dwDisposition))

    {
        RegSetValueEx(hkey,
                      REG_VAL_ICWCOMPLETE,
                      0,
                      REG_BINARY,
                      (LPBYTE) &dwValue,
                      sizeof(DWORD));                              

        RegCloseKey(hkey);
    }
}

#include "foldinc.h"
#include "..\folder\cmdtable.h"
EXTERN_C INT WINAPI StartNCW( HWND hwndOwner, HINSTANCE hInstance, LPTSTR pszParms, INT nShow )
{
    HRESULT hr = S_OK;
    vector<LPSTR> vecszCmdLine;  // This is ANSI since our Command Line is ANSI.
    const CHAR szSeps[] = ",";
    LPSTR szToken = strtok( reinterpret_cast<LPSTR>(pszParms), szSeps);
    while( szToken != NULL )
    {
        vecszCmdLine.push_back(szToken);
        szToken = strtok( NULL, szSeps);
    }

    DWORD dwFirstPage = 0;
    LPSTR szShellNext = NULL;
    LPSTR szShellNextArg = NULL;
    if (vecszCmdLine.size() >= 1)
    {
        dwFirstPage = atoi(vecszCmdLine[0]);

        if (vecszCmdLine.size() >= 2)
        {
            szShellNext = vecszCmdLine[1];
            Assert(strlen(szShellNext) <= MAX_PATH); // Shell requirement

            if (vecszCmdLine.size() >= 3)
            {
                szShellNextArg = vecszCmdLine[2];
                Assert(strlen(szShellNextArg) <= MAX_PATH);
            }
        }
    }

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (SUCCEEDED(hr))
    {
        {
            // Check permissions
            PCONFOLDPIDLVEC pcfpvEmpty;
            NCCS_STATE nccs = NCCS_ENABLED;
            DWORD dwResourceId;
            
            HrGetCommandState(pcfpvEmpty, CMIDM_NEW_CONNECTION, nccs, &dwResourceId, 0xffffffff, NB_FLAG_ON_TOPMENU);
            if (NCCS_ENABLED == nccs)
            {
                CComPtr<INetConnection> pNetConn;
                // We don't send the owner handle to HrRunWizard,
                // so that the correct Alt-Tab icon can be displayed  
                hr = HrRunWizard(NULL, FALSE , &pNetConn, dwFirstPage);
            }
            else
            {
                NcMsgBox(_Module.GetResourceInstance(), 
                    NULL, 
                    IDS_CONFOLD_WARNING_CAPTION,
                    IDS_ERR_LIMITED_USER, 
                    MB_ICONEXCLAMATION | MB_OK);
				
                hr = S_OK;
            }

            SetICWComplete();
        
            if (szShellNext)
            {
                WCHAR szwShellNext[MAX_PATH];
                WCHAR szwShellNextArg[MAX_PATH];

                mbstowcs(szwShellNext, szShellNext, MAX_PATH);
                if (szShellNextArg)
                {
                    mbstowcs(szwShellNextArg, szShellNextArg, MAX_PATH);
                }
                else
                {
                    szwShellNextArg[0] = 0;
                }

                HINSTANCE hInst = ::ShellExecute(hwndOwner, NULL, szwShellNext, szwShellNextArg, NULL, nShow);
                if (hInst   <= reinterpret_cast<HINSTANCE>(32))
                {
                    hr = HRESULT_FROM_WIN32(static_cast<DWORD>(reinterpret_cast<DWORD_PTR>(hInst)));
                }
            }
        }

        CoUninitialize();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\netsetup\wupgrade.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ndisguid.h>
#include "afilexp.h"
#include "edc.h"
#include "lm.h"
#include "nceh.h"
#include "ncerror.h"
#include "ncmisc.h"
#include "ncnetcfg.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "ncsetup.h"
#include "ncatlui.h"
#include "netcfgn.h"
#include "netsetup.h"
#include "nslog.h"
#include "nsres.h"
#include "resource.h"
#include "upgrade.h"
#include "windns.h"
#include "winstall.h"

#include <hnetcfg.h>

extern const WCHAR c_szInfId_MS_Server[];
extern const WCHAR c_szInfId_MS_NwSapAgent[];
extern const WCHAR c_szInfId_MS_DHCPServer[];
extern const WCHAR c_szInfId_MS_NWClient[];
extern const WCHAR c_szAfSectionNetworking[];     // L"Networking";
extern const WCHAR c_szAfBuildNumber[];           // L"BuildNumber";
extern const WCHAR c_szSvcWorkstation[];          // L"LanmanWorkstation";
extern const WCHAR c_szInfId_MS_NetBIOS[];
extern const WCHAR c_szInfId_MS_MSClient[];             // L"ms_msclient";

const WCHAR PSZ_SPOOLER[]      = L"Spooler";
const WCHAR c_szSamEventName[] = L"\\SAM_SERVICE_STARTED";
const WCHAR c_szLsaEventName[] = L"\\INSTALLATION_SECURITY_HOLD";
const WCHAR c_szActiveComputerNameKey[]  = L"SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName";
const WCHAR c_szComputerNameKey[]  = L"SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName";
const WCHAR c_szComputerNameValue[] = L"ComputerName";
const WCHAR c_szOCMKey[]       = L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\SubComponents";
const WCHAR c_szDHCPServer[]   = L"dhcpserver";
const WCHAR c_szSapAgent[]     = L"nwsapagent";

// Unattended Mode related strings
//
const WCHAR c_szUnattendSection[]   = L"Unattended";
const WCHAR c_szUnattendMode[]      = L"UnattendMode";
const WCHAR c_szUMDefaultHide[]     = L"DefaultHide";
const WCHAR c_szUMGuiAttended[]     = L"GuiAttended";
const WCHAR c_szUMProvideDefault[]  = L"ProvideDefault";
const WCHAR c_szUMReadOnly[]        = L"ReadOnly";
const WCHAR c_szUMFullUnattended[]  = L"FullUnattended";

// Sysprep registry strings
const WCHAR c_szSystemSetupKey[]        = L"SYSTEM\\Setup";
const WCHAR c_szMiniSetupInProgress[]   = L"MiniSetupInProgress";

const DWORD c_cmsWaitForINetCfgWrite = 120000;
const UINT PWM_PROCEED               = WM_USER+1202;
const UINT PWM_EXIT                  = WM_USER+1203;
const UINT c_uiUpgradeRefreshID      = 7719;
const UINT c_uiUpgradeRefreshRate    = 5000;  // Refresh rate in milliseconds

EXTERN_C DWORD InstallUpgradeWorkThrd(InitThreadParam* pitp);


// Setup Wizard Global - Only used during setup.
extern CWizard * g_pSetupWizard;
WNDPROC OldProgressProc;

BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
        case PBM_DELTAPOS:
        case PBM_SETRANGE:
        case PBM_SETRANGE32:
        case PBM_STEPIT:
        case PBM_SETPOS:
        case PBM_SETSTEP:
            // Forward to the billboard progress.
            g_pSetupWizard->PSetupData()->BillboardProgressCallback(msg, wParam, lParam);
            break;
    }
    // Always call the progress on the wizard page.
    return (BOOL)CallWindowProc(OldProgressProc,hdlg,msg,wParam,lParam);
}



//
// Function:    SignalLsa
//
// Purpose:     During initial setup, the winlogon creates a special event
//              (unsignalled) before it starts up Lsa.  During initialization
//              lsa waits on this event. After Gui setup is done with setting
//              the AccountDomain sid it can signal the event. Lsa will then
//              continue initialization.
//
// Parameters:  none
//
// Returns:     nothing
//
BOOL SignalLsa(VOID)
{
    TraceFileFunc(ttidGuiModeSetup);

    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;
    HANDLE Event;
    BOOL b;

    //
    // If the following event exists, it is an indication that
    // LSA is blocked at installation time and that we need to
    // signal this event.
    //
    // Unfortunately we have to use the NT APIs to do this, because
    // all events created/accessed via the Win32 APIs will be in the
    // BaseNamedObjects directory, and LSA doesn't know to look there.
    //
    RtlInitUnicodeString(&UnicodeString,c_szLsaEventName);
    InitializeObjectAttributes(&Attributes,&UnicodeString,0,0,NULL);

    Status = NtOpenEvent(&Event,EVENT_MODIFY_STATE,&Attributes);
    if(NT_SUCCESS(Status))
    {
        Status = NtSetEvent(Event,NULL);
        if(NT_SUCCESS(Status))
        {
            b = TRUE;
        }
        else
        {
            b = FALSE;
        }
        CloseHandle(Event);
    } else {
        b = FALSE;
    }

    return(b);
}

//
// Function:    CreateSamEvent
//
// Purpose:     Create an event that SAM will use to tell us when it's finished
//              initializing.
//
// Parameters:  phSamEvent [OUT] - Handle to the event object created
//
// Returns:     BOOL, TRUE on success
//
BOOL CreateSamEvent(HANDLE * phSamEvent)
{
    TraceFileFunc(ttidGuiModeSetup);

    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    NTSTATUS Status;

    //
    // Unfortunately we have to use the NT APIs to do this, because
    // all events created/accessed via the Win32 APIs will be in the
    // BaseNamedObjects directory, and SAM doesn't know to look there.
    //
    RtlInitUnicodeString(&UnicodeString,c_szSamEventName);
    InitializeObjectAttributes(&Attributes,&UnicodeString,0,0,NULL);

    Status = NtCreateEvent(phSamEvent,SYNCHRONIZE,&Attributes,NotificationEvent,FALSE);
    if(!NT_SUCCESS(Status)) {
        *phSamEvent = NULL;
    }

    return(NT_SUCCESS(Status));
}


//
// Function:    WaitForSam
//
// Purpose:     Wait for SAM to finish initializing. We can tell when it's done
//              because an event we created earlier (see CreateSamEvent()) will
//              become signalled.
//
// Parameters:  hSamEvent - HANDLE to wait for
//
// Returns:     BOOL, TRUE on success
//
BOOL WaitForSam(HANDLE hSamEvent)
{
    DWORD d;
    BOOL b = false;

    if (hSamEvent)
    {
        b = TRUE;
        d = WaitForSingleObject(hSamEvent,INFINITE);
        if(d != WAIT_OBJECT_0) {
            b = FALSE;
            TraceError("WaitForSam",E_UNEXPECTED);
        }
    }
    return(b);
}

//
// Function:    SyncSAM
//
// Purpose:     Sychronize the SAM database and Lsa
//
// Parameters:  pWizard [IN] - Ptr to a Wizard Instance
//
// Returns:     nothing
//
VOID SyncSAM(CWizard *pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    HANDLE hSamEvent = NULL;

    Assert(!IsPostInstall(pWizard));
    TraceTag(ttidWizard,"Beginning SAM/Lsa Sync");

    // Sync the SAM DB
    CreateSamEvent(&hSamEvent);
    SignalLsa();
    if (hSamEvent)
    {
        WaitForSam(hSamEvent);
        CloseHandle(hSamEvent);
    }

    TraceTag(ttidWizard,"Completed SAM/Lsa Sync");
}

//
// Function:    HrSetActiveComputerName
//
// Purpose:     To make sure the active and intended computer names are the same
//
// Parameters:  pszNewName [IN] - the new computer name
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrSetActiveComputerName (
    IN PCWSTR pszNewName )
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr;
    HKEY hkeyActive = NULL;
    HKEY hkeyIntended = NULL;
    tstring str;

    TraceTag(ttidWizard,"Setting the active computer name");

    // open the keys we need
    hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szActiveComputerNameKey,
                         KEY_WRITE, &hkeyActive );
    if (FAILED(hr))
        goto Error;

    hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, c_szComputerNameKey,
                         KEY_READ_WRITE, &hkeyIntended );
    if (FAILED(hr))
        goto Error;

    if (pszNewName == NULL)
    {
        hr = HrRegQueryString(hkeyIntended, c_szComputerNameValue, &str);
        pszNewName = str.c_str();
    }
    else
    {
        // set the intended computer name
        hr = HrRegSetSz(hkeyIntended, c_szComputerNameValue, pszNewName);
    }

    if (FAILED(hr))
        goto Error;

    // set the active computer name
    hr = HrRegSetSz(hkeyActive, c_szComputerNameValue, pszNewName);

Error:
    // close it all up
    RegSafeCloseKey( hkeyActive );
    RegSafeCloseKey( hkeyIntended );

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrSetActiveComputerName");
    return hr;
}

//
// Function:    HrInitAndGetINetCfg
//
// Purpose:     To initialize an INetCfg instance and to do some preliminary
//              answerfile work (if an answer file is being used).
//
// Parameters:  pWizard   [IN] - Ptr to a wizard instance
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrInitAndGetINetCfg(CWizard *pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;

    Assert(NULL != pWizard);

    if (SUCCEEDED(hr))
    {
        PWSTR   pszClientDesc = NULL;
        INetCfg* pNetCfg        = NULL;
        BOOL     fInitCom       = !pWizard->FCoUninit();

        hr = HrCreateAndInitializeINetCfg(&fInitCom, &pNetCfg, TRUE,
                              c_cmsWaitForINetCfgWrite,
                              SzLoadIds(IDS_WIZARD_CAPTION),
                              &pszClientDesc);
        if (SUCCEEDED(hr))
        {
            // Retain our success in initializing COM only if we asked to
            // initialize COM in the first place.
            if (!pWizard->FCoUninit())
            {
                pWizard->SetCoUninit(fInitCom);
            }
            pWizard->SetNetCfg(pNetCfg);

            CoTaskMemFree(pszClientDesc);
        }
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrInitAndGetINetCfg");
    return hr;
}

//
// Function:    OnUpgradeUpdateProgress
//
// Purpose:     Update the progress control during setup
//
// Parameters:  Standard timer callback parameters
//
// Returns:     nothing
//
VOID OnUpgradeUpdateProgress(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    CWizard * pWizard = reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    LPARAM lParam = pWizard->GetPageData(IDD_Upgrade);
    Assert(lParam);
    UpgradeData * pData = reinterpret_cast<UpgradeData *>(lParam);

    if(pData)
    {
        // Get current position
        //
        HWND      hwndProgress = GetDlgItem(hwndDlg, IDC_UPGRADE_PROGRESS);
        Assert(hwndProgress);
        UINT nCurPos = SendMessage(hwndProgress, PBM_GETPOS, 0, 0);

        // If the current position is less then the cap, advance
        //
        if (nCurPos < pData->nCurrentCap)
        {
            SendMessage(hwndProgress, PBM_SETPOS, ++nCurPos, 0);
        }
    }
}

//
// Function:    UpgradeSetProgressCap
//
// Purpose:     Update the current cap for the progress control
//
// Parameters:  hwndDlg - Handle to the current dialog
//              pWizard - Ptr to the wizard data
//              nNewCap - The new maximum progress cap
//
// Returns:     nothing
//
VOID
OnUpgradeUpdateProgressCap (
    HWND hwndDlg,
    CWizard* pWizard,
    UINT nNewCap)
{
    TraceFileFunc(ttidGuiModeSetup);

    LPARAM lParam = pWizard->GetPageData(IDD_Upgrade);
    Assert(lParam);

    UpgradeData * pData = reinterpret_cast<UpgradeData *>(lParam);

    if(pData)
    {
        // Since we're increasing the progress cap, we need to advance the
        // progress indicator to the old cap.
        //
        SendMessage(GetDlgItem(hwndDlg, IDC_UPGRADE_PROGRESS), PBM_SETPOS,
                    pData->nCurrentCap, 0);

        // Retain the new cap
        //
        pData->nCurrentCap = nNewCap;
    }
}

//
// Function:
//
// Purpose:
//
// Parameters:
//
// Returns:
//
VOID ReadAnswerFileSetupOptions(CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    if (IsUnattended(pWizard))
    {
        // Get the unattended flags
        //
        CSetupInfFile csif;

        Assert(pWizard->PSetupData());
        Assert(pWizard->PSetupData()->UnattendFile);

        // Open the answser file
        //
        if (SUCCEEDED(csif.HrOpen(pWizard->PSetupData()->UnattendFile, NULL,
                                  INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL)))
        {
            tstring str;

            // Confirm no one has over written the default
            //
            Assert(UM_DEFAULTHIDE == pWizard->GetUnattendedMode());

            // Locate the UnattendMode string, if it exists
            //
            if (SUCCEEDED(csif.HrGetString(c_szUnattendSection,
                                           c_szUnattendMode, &str)))
            {
                struct
                {
                    PCWSTR pszMode;
                    UM_MODE UMMode;
                } UMModeMap[] = {{c_szUMDefaultHide,UM_DEFAULTHIDE},
                                 {c_szUMGuiAttended,UM_GUIATTENDED},
                                 {c_szUMProvideDefault,UM_PROVIDEDEFAULT},
                                 {c_szUMReadOnly,UM_READONLY},
                                 {c_szUMFullUnattended,UM_FULLUNATTENDED}};

                // Search the map for the unattended flag, note that if
                // we don't find it the default is UM_DEFAULTHIDE
                //
                for (UINT nIdx = 0; nIdx < celems(UMModeMap); nIdx++)
                {
                    if (0 == _wcsicmp(str.c_str(),UMModeMap[nIdx].pszMode))
                    {
                        pWizard->SetUnattendedMode(UMModeMap[nIdx].UMMode);
                        break;
                    }
                }
            }
        }
    }
}

//
// Function:    StartSpooler
//
// Purpose:     Start the spooler process before the components are applied
//              as some of the components want to install print monitors, and
//              the spooler needs to be running for this to succeed.
//
// Parameters:  none
//
// Returns:     nothing
//
VOID StartSpooler()
{
    TraceFileFunc(ttidGuiModeSetup);

    CServiceManager csm;
    TraceTag(ttidWizard, "Attempting to start spooler");

    HRESULT hr = csm.HrStartServiceNoWait(PSZ_SPOOLER);

    TraceHr(ttidWizard, FAL, hr, FALSE,
        "*** StartSpooler - The spooler failed to start, you probably "
        "won't have networking ***");
}

//
// Function:    HrCommitINetCfgChanges
//
// Purpose:     Validate and Commit changes to the INetCfg object
//
// Parameters:  hwnd    [IN] - Handle of the current window
//              pWizard [IN] - Ptr to a wizard instance
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCommitINetCfgChanges(HWND hwnd, CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    INetCfg * pNetCfg = pWizard->PNetCfg();
    Assert(NULL != pNetCfg);

    // Commit the changes
    TraceTag(ttidWizard,"HrCommitINetCfgChanges - Applying changes");

    HRESULT hr = pNetCfg->Apply();

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCommitINetCfgChanges");
    return hr;
}

//
// Function:    IsSBS
//
// Purpose:     Determine if it is SBS version.
//
// Parameters:  None
//
// Returns:     BOOL, TRUE if it is Microsoft Small Business Server
//

BOOL IsSBS (VOID)
{
    TraceFileFunc(ttidGuiModeSetup);

    OSVERSIONINFOEX ose;
    BOOL bVersionRet;

    ZeroMemory(&ose, sizeof(ose));
    ose.dwOSVersionInfoSize = sizeof(ose);
    bVersionRet = GetVersionEx(reinterpret_cast<LPOSVERSIONINFO>(&ose));

    return (bVersionRet && (ose.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED));
}
//
// Function:    IsMSClientInstalled
//
// Purpose:     Determine if MSClient is installed.
//
// Parameters:  hwnd    [IN] - Handle of the current window
//              pWizard [IN] - Ptr to a wizard instance
//
// Returns:     BOOL, TRUE if MS Client is installed, otherwise
//

BOOL IsMSClientInstalled(HWND hwnd, CWizard * pWizard)
{
    INetCfg          *pNetCfg;
    INetCfgComponent *pncc;
    HRESULT          hr;

    TraceFileFunc(ttidGuiModeSetup);

    Assert(NULL != pWizard);

    if ( !pWizard )
    {
        return FALSE;
    }

    pNetCfg = pWizard->PNetCfg();
    Assert(NULL != pNetCfg);

    if ( !pNetCfg )
    {
        return FALSE;
    }

    hr = pNetCfg->FindComponent(c_szInfId_MS_MSClient, &pncc);
    if ( hr == S_OK )
    {
        ReleaseObj(pncc);
    }

    TraceHr(ttidWizard, FAL, hr, FALSE, "IsMSClientInstalled");
    return hr == S_OK;
}

//
// Function:
//
// Purpose:
//
// Parameters:
//
// Returns:
//
BOOL OnProcessPrevAdapterPagePrev(HWND hwndDlg, UINT idd)
{
    TraceFileFunc(ttidGuiModeSetup);

    BOOL           fRet = FALSE;
    CWizard *      pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);
    HPROPSHEETPAGE hPage;

    GUID * pguidAdapter = pWizard->PAdapterQueue()->PrevAdapter();
    if (NULL != pguidAdapter)
    {
        pWizard->SetCurrentProvider(0);
        CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
        Assert(NULL != pWizProvider);
        Assert(pWizProvider->ULPageCount());

        // Reset the providers guard page to point forward
        LPARAM ulId = reinterpret_cast<LPARAM>(pWizProvider);
        pWizard->SetPageDirection(ulId, NWPD_FORWARD);

        // Push the adapter guid onto the provider
        HRESULT hr = pWizProvider->HrSpecifyAdapterGuid(pguidAdapter);
        if (SUCCEEDED(hr))
        {
            // Get the last page from the provider
            TraceTag(ttidWizard, "Jumping to LAN provider last page...");
            hPage = (pWizProvider->PHPropPages())[pWizProvider->ULPageCount() - 1];
            Assert(hPage);

            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                        (LPARAM)(HPROPSHEETPAGE)hPage);
            fRet = TRUE;    // We jumped to a provider page
        }
    }
    else
    {
        if (idd)
        {
            hPage = pWizard->GetPageHandle(idd);
            Assert(hPage);
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                        (LPARAM)(HPROPSHEETPAGE)hPage);
        }
    }

    return fRet;
}

//
// Function:    OBOUserAddRefSpecialCase
//
// Purpose:     Handle a special case where when upgrading from NT351 or NT 4
//              with MS's "File and Print" and GSNW.  In this case we need to
//              AddRef OBOUser F&P, so removal of GSNW does not remove F&P.
//
// Parameters:  pWizard [IN] - Context information
//
// Returns:     Nothing.  (this is basically a do it if we can special case.)
//
VOID OBOUserAddRefSpecialCase(CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    CSetupInfFile csif;
    HRESULT       hr = S_OK;

    Assert(pWizard->PNetCfg());
    Assert(IsUnattended(pWizard));
    TraceTag(ttidWizard, "OBOUserAddRefSpecialCase - Start");

    // if we're upgrading from NT 3.51 or NT 4
    //
    if (pWizard->PSetupData()->UnattendFile)
    {
/*        DWORD dwBuild = 0;
        hr = csif.HrOpen(pWizard->PSetupData()->UnattendFile,
                         NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
        if (SUCCEEDED(hr))
        {
            hr = csif.HrGetDword(c_szAfSectionNetworking, c_szAfBuildNumber, &dwBuild);
        }

        if (SUCCEEDED(hr) && (dwBuild <= wWinNT4BuildNumber))
        {*/
            PRODUCT_FLAVOR pf;

            // If this is an NT server (GSNW is server only)
            //
            GetProductFlavor(NULL, &pf);
            if (PF_WORKSTATION != pf)
            {
                const GUID  * rgguidClass[2] = {&GUID_DEVCLASS_NETSERVICE,
                                                &GUID_DEVCLASS_NETCLIENT};
                const PCWSTR rgpszComponentId[2] = {c_szInfId_MS_Server,
                                                      c_szInfId_MS_NWClient};
                INetCfgComponent* rgpncc[2] = {NULL, NULL};

                hr = HrFindComponents (pWizard->PNetCfg(), 2, rgguidClass,
                                       rgpszComponentId, rgpncc);
                if (SUCCEEDED(hr))
                {
                    // Are both "GSNW" and "File and Print" installed?
                    //
                    if (rgpncc[0] && rgpncc[1])
                    {
                        NETWORK_INSTALL_PARAMS nip = {0};

                        nip.dwSetupFlags = NSF_PRIMARYINSTALL;

                        // re-install OBOUser "File and Print"
                        //
                        TraceTag(ttidWizard, "    OBOUser Install of File and Print Services");
                        TraceTag(ttidWizard, "    On upgrade from NT 3.51 or NT 4");
                        (void)HrInstallComponentsOboUser(pWizard->PNetCfg(), &nip, 1,
                                                         &rgguidClass[0],
                                                         &rgpszComponentId[0]);
                    }

                    ReleaseObj(rgpncc[0]);
                    ReleaseObj(rgpncc[1]);
                }
            }
///     }
    }

    TraceTag(ttidWizard, "OBOUserAddRefSpecialCase - End");
    TraceError("OBOUserAddRefSpecialCase",hr);
}

//
// Function:
//
// Purpose:
//
// Parameters:
//
// Returns:
//
BOOL OnProcessNextAdapterPageNext(HWND hwndDlg, BOOL FOnActivate)
{
    TraceFileFunc(ttidGuiModeSetup);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);
    HRESULT hr = S_OK;
    BOOL    fRet = FALSE;
    HPROPSHEETPAGE hPage;
    GUID * pguidAdapter;

    ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);

    // Refresh the contents of the adapter queue.
    // ATM adapters may have been added or removed
    if (pWizard->FProcessLanPages())
    {
        // Commit changes and look for any new adapters
        (VOID)HrCommitINetCfgChanges(GetParent(hwndDlg), pWizard);
        (VOID)pWizard->PAdapterQueue()->HrQueryUnboundAdapters(pWizard);
    }

    // If there are adapters left to process prime the pump
    pguidAdapter = pWizard->PAdapterQueue()->NextAdapter();
    if (NULL != pguidAdapter)
    {
        pWizard->SetCurrentProvider(0);
        CWizProvider * pWizProvider = pWizard->GetCurrentProvider();
        Assert(NULL != pWizProvider);
        Assert(pWizProvider->ULPageCount());

        // Push the adapter guid onto the provider
        hr = pWizProvider->HrSpecifyAdapterGuid(pguidAdapter);
        if (SUCCEEDED(hr))
        {
#if DBG
            WCHAR szGuid[c_cchGuidWithTerm];
            Assert(pguidAdapter);
            if (SUCCEEDED(StringFromGUID2(*pguidAdapter, szGuid,
                                          c_cchGuidWithTerm)))
            {
                TraceTag(ttidWizard, "  Calling LAN pages for Adapter Guid: %S", szGuid);
            }
#endif
            // Reset the providers guard page to point forward
            LPARAM ulId = reinterpret_cast<LPARAM>(pWizProvider);
            pWizard->SetPageDirection(ulId, NWPD_FORWARD);

            // Get the first page from the provider
            hPage = (pWizProvider->PHPropPages())[0];
            Assert(hPage);
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                        (LPARAM)(HPROPSHEETPAGE)hPage);

            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

            TraceTag(ttidWizard, "Jumping to LAN provider first page...");
            fRet = TRUE;        // We processed it
        }
    }

    // If there are no adapters left to process, or an error occurred
    if ((NULL == pguidAdapter) || FAILED(hr))
    {
        UINT idd = IDD_Exit;

        // Commit any changes to INetCfg.
        if (SUCCEEDED(hr) && pWizard->FProcessLanPages())
        {
            // Commit changes
            (VOID)HrCommitINetCfgChanges(GetParent(hwndDlg), pWizard);
        }

        if (!IsPostInstall(pWizard) && IsMSClientInstalled(GetParent(hwndDlg), pWizard))
        {
            idd = IDD_Join;
            TraceTag(ttidWizard, "Jumping to Join page...");
        }
        else
        {
            TraceTag(ttidWizard, "Jumping to Exit page...");
        }

        if (FOnActivate)
        {
            ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, idd);
        }
        else
        {
            // else goto the appropriate page
            hPage = pWizard->GetPageHandle(idd);
            Assert(hPage);
            PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0, (LPARAM)hPage);
        }
        fRet = TRUE;        // We processed it
    }

    Assert(TRUE == fRet);
    return fRet;
}

//
// Function:    FixupOldOcComponents
//
// Purpose:     Convert SAP and DHCP optional components (if present) into
//              regular networking components.
//
// Parameters:  pWizard
//
// Returns:     nothing
//
void FixupOldOcComponents(CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr;

    static const GUID* c_apguidInstalledComponentClasses [] =
    {
        &GUID_DEVCLASS_NETSERVICE,      // DHCP
        &GUID_DEVCLASS_NETSERVICE,      // SAP Agent
    };

    static const PCWSTR c_apszInstalledComponentIds [] =
    {
        c_szInfId_MS_DHCPServer,
        c_szInfId_MS_NwSapAgent,
    };

    static const PCWSTR c_apszOcNames[] =
    {
        c_szDHCPServer,
        c_szSapAgent,
    };

    // If component was installed as an optional component
    //
    HKEY hkey;
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szOCMKey, KEY_READ_WRITE, &hkey);
    if (SUCCEEDED(hr))
    {
        DWORD dw;

        for (UINT idx=0; idx<celems(c_apszOcNames); idx++)
        {
            // Remove the OC Manager reference
            //
            hr = HrRegQueryDword (hkey, c_apszOcNames[idx], &dw);
            if (SUCCEEDED(hr))
            {
                if (dw)
                {
                    // Install OBO user the component
                    //
                    NETWORK_INSTALL_PARAMS nip = {0};

                    // Note: Claiming it's a server upgrade is a bit bogus,
                    //       but is needed so dhcpsobj.cpp doesn't display
                    //       UI.
                    //
                    nip.dwSetupFlags |= NSF_WINNT_SVR_UPGRADE;
                    nip.dwSetupFlags |= NSF_PRIMARYINSTALL;

                    (void)HrInstallComponentsOboUser(pWizard->PNetCfg(), &nip, 1,
                                                     &c_apguidInstalledComponentClasses[idx],
                                                     &c_apszInstalledComponentIds[idx]);
                }

                // Delete the value
                //
                (VOID)HrRegDeleteValue(hkey, c_apszOcNames[idx]);
            }
        }

        RegCloseKey(hkey);
    }
}


struct NAME_DATA
{
    PCWSTR     pszComputerName;
};

//+---------------------------------------------------------------------------
//
//  Function:   DuplicateNameProc
//
//  Purpose:    Dialog procedure for the duplicate name dialog
//
//  Arguments:
//      hwndDlg []
//      uMsg    [] See MSDN
//      wParam  []
//      lParam  []
//
//  Returns:
//
//  Author:     danielwe   16 Feb 1999
//
//  Notes:
//
INT_PTR
CALLBACK
DuplicateNameProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);

    BOOL        frt = FALSE;
    WCHAR       szBuf[1024];
    WCHAR       szText[1024];
    NAME_DATA * pData;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR)lParam);
        pData = (NAME_DATA *)lParam;

        Assert(pData->pszComputerName);

        GetDlgItemText(hwndDlg, TXT_Caption, szText, celems(szText));

        // add computer name to title
        wsprintfW(szBuf, szText, pData->pszComputerName);
        SetDlgItemText(hwndDlg, TXT_Caption, szBuf);

        // limit text in edit control
        SendDlgItemMessage(hwndDlg, EDT_New_Name, EM_LIMITTEXT,
                           (WPARAM)MAX_COMPUTERNAME_LENGTH, 0);
        return TRUE;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case BN_CLICKED:
            switch (LOWORD(wParam))
            {
            case IDOK:
                NET_API_STATUS  nas;

                GetDlgItemText(hwndDlg, EDT_New_Name, szBuf, celems(szBuf));
                nas = NetValidateName(NULL, szBuf, NULL, NULL,
                                      NetSetupMachine);
                if (nas != NO_ERROR)
                {
                    UINT    ids;

                    if (nas == ERROR_DUP_NAME)
                    {
                        ids = IDS_E_COMPUTER_NAME_DUPE;
                        TraceTag(ttidWizard, "Computer name %S"
                                 " is a dupe.", szBuf);
                    }
                    else
                    {
                        ids = IDS_E_COMPUTER_NAME_INVALID;
                        TraceTag(ttidWizard, "Computer name %S"
                                 " is invalid.", szBuf);
                    }

                    MessageBeep(MB_ICONSTOP);
                    MessageBox(hwndDlg, SzLoadIds(ids),
                               SzLoadIds(IDS_SETUP_CAPTION),
                               MB_ICONSTOP | MB_OK);
                    SetFocus(GetDlgItem(hwndDlg, EDT_New_Name));
                    Edit_SetSel(GetDlgItem(hwndDlg, EDT_New_Name), 0, -1);
                }
                else
                {
                    // 398325/406259 : trying to keep DNS names lowercased
                    //
                    LowerCaseComputerName(szBuf);

                    if (!SetComputerNameEx(ComputerNamePhysicalDnsHostname,
                                           szBuf))
                    {
                        TraceLastWin32Error("SetComputerNameEx");
                    }
                    else
                    {
                        CServiceManager     sm;

                        (VOID)HrSetActiveComputerName(NULL);
                        TraceTag(ttidWizard, "Setting new computer name "
                                 "%S.", szBuf);

                        TraceTag(ttidWizard, "Restarting workstation service"
                                 "...");
                        (VOID) sm.HrStartServiceAndWait(c_szSvcWorkstation);
                    }
                    EndDialog(hwndDlg, 0);
                }
                break;
            }
            break;
        }
        break;

    default:
        frt = FALSE;
        break;
    }

    return frt;
}

//+---------------------------------------------------------------------------
//
//  Function:   GenerateComputerNameBasedOnOrganizationName
//
//  Purpose:    Generate a random computer name based on the register user name
//              and organization name
//
//  Arguments:
//      pszGeneratedStringOut       Generated Computer Name - allocated by caller
//      dwDesiredStrLenIn           Desired length of Computer Name
//
//  Returns:
//
//  Author:     deonb   22 April 2000
//
//  Notes:
//
VOID GenerateComputerNameBasedOnOrganizationName(
    LPWSTR  pszGeneratedStringOut,   // the generated computer name
    DWORD   dwDesiredStrLenIn        // desired length for the computer name
    )
{
    TraceFileFunc(ttidGuiModeSetup);

    static DWORD   dwSeed = 98725757;
    static LPCWSTR UsableChars = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    static LPCWSTR RegKey          = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
    static LPCWSTR RegOwner        = REGSTR_VAL_REGOWNER;
    static LPCWSTR RegOrganization = REGSTR_VAL_REGORGANIZATION;

    WCHAR pszNameOrgNameIn[MAX_PATH];
    WCHAR pszNameOrgOrgIn[MAX_PATH]; // organization the computer is registered to
    pszNameOrgNameIn[0] = NULL;
    pszNameOrgOrgIn[0]  = NULL;

    HKEY hkResult = NULL;
    HRESULT hr;

    hr = HrRegOpenKeyBestAccess(HKEY_LOCAL_MACHINE, RegKey, &hkResult);
    if (SUCCEEDED(hr))
    {
        tstring pstr;
        hr = HrRegQueryString(hkResult, RegOwner, &pstr);
        if (SUCCEEDED(hr))
            wcsncpy(pszNameOrgNameIn, pstr.c_str(), MAX_PATH);

        hr = HrRegQueryString(hkResult, RegOrganization, &pstr);
        if (SUCCEEDED(hr))
            wcsncpy(pszNameOrgOrgIn, pstr.c_str(), MAX_PATH);

        RegCloseKey(hkResult);
    }
    //
    // How many characters will come from the org/name string.
    //
    DWORD   BaseLength = 8;
    DWORD   i,j;
    DWORD   UsableCount;

    if( dwDesiredStrLenIn <= BaseLength )
    {
        BaseLength = dwDesiredStrLenIn - 1;
    }

    if( pszNameOrgOrgIn[0] )
    {
        wcscpy( pszGeneratedStringOut, pszNameOrgOrgIn );
    } else if( pszNameOrgNameIn[0] )
    {
        wcscpy( pszGeneratedStringOut, pszNameOrgNameIn );
    } else
    {
        wcscpy( pszGeneratedStringOut, L"X" );
        for( i = 1; i < BaseLength; i++ )
        {
            wcscat( pszGeneratedStringOut, L"X" );
        }
    }

    //
    // Get him upper-case for our filter...
    //

    CharUpper( pszGeneratedStringOut );

    //
    // Now we want to put a '-' at the end
    // of our pszGeneratedStringOut.  We'd like it to
    // be placed in the BASE_LENGTH character, but
    // the string may be shorter than that, or may
    // even have a ' ' in it.  Figure out where to
    // put the '-' now.
    //

    for( i = 0; i <= BaseLength; i++ )
    {
        //
        // Check for a short string.
        //
        if( ( pszGeneratedStringOut[i] == 0    ) ||
            ( pszGeneratedStringOut[i] == L' ' ) ||
            ( ! wcschr(UsableChars, pszGeneratedStringOut[i] ) ) ||
            ( i == BaseLength )
          )
        {
            pszGeneratedStringOut[i] = L'-';
            pszGeneratedStringOut[i+1] = 0;
            break;
        }
    }

    //
    // Special case the scenario where we had no usable
    // characters.
    //
    if( pszGeneratedStringOut[0] == L'-' )
    {
        pszGeneratedStringOut[0] = 0;
    }

    UsableCount = wcslen(UsableChars);

    GUID gdRandom;
    CoCreateGuid(&gdRandom);
    LPBYTE lpGuid = reinterpret_cast<LPBYTE>(&gdRandom);

    j = wcslen( pszGeneratedStringOut );

    for( i = j; i < dwDesiredStrLenIn; i++ )
    {
        pszGeneratedStringOut[i] = UsableChars[lpGuid[i % sizeof(GUID)] % UsableCount];
    }

    pszGeneratedStringOut[i] = 0;

    CharUpper(pszGeneratedStringOut);

}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureUniqueComputerName
//
//  Purpose:    Ensures that the computer name entered in the first part of
//              GUI mode setup (note: this UI is not owned by NetCfg) is
//              unique. User is prompted to enter a new name if this is not
//              the case.
//
//  Arguments:
//      hwndDlg [in]    Parent window
//      bIsUnattended   Do not pop up dialog box to ask for computer name
//                      - rather generate a random unique name.
//
//  Returns:    Nothing
//
//  Author:     danielwe   16 Feb 1999
//
//  Notes:      Workstation service is stopped and restarted when new name is
//              entered so the change can take effect and domain join can
//              succeed.
//
VOID EnsureUniqueComputerName(HWND hwndDlg, BOOL bIsUnattended)
{
    TraceFileFunc(ttidGuiModeSetup);

    NET_API_STATUS  nas;
    WCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD           cchName = celems(szComputerName);
    NAME_DATA       nd = {0};

    if (GetComputerNameEx(ComputerNameNetBIOS,
                          reinterpret_cast<PWSTR>(&szComputerName),
                          &cchName))
    {
        CServiceManager     sm;
        CService            service;
        BOOL                fRestart = FALSE;
        DWORD               dwState;

        // Open the workstation service and figure out if it is running. If
        // so we'll need to stop it and note that we need to restart it when
        // we're done verifying the computer name.
        //
        if (SUCCEEDED(sm.HrOpenService(&service, c_szSvcWorkstation)))
        {
            if (SUCCEEDED(service.HrQueryState(&dwState)) &&
                (dwState == SERVICE_RUNNING))
            {
                TraceTag(ttidWizard, "Stopping workstation service...");
                (VOID) sm.HrStopServiceAndWait(c_szSvcWorkstation);
                fRestart = TRUE;
            }
        }

        // NetValidateName() should work without the workstation service
        // being started. In fact, it *has* to work like this because otherwise
        // the machine will find itself as a duplicate name.. Not good.
        //
        DWORD dwNumTries = 10;
        do
        {
            nas = NetValidateName(NULL, szComputerName, NULL, NULL,
                                  NetSetupMachine);
            if (nas == ERROR_DUP_NAME)
            {
                INT irt;

                TraceTag(ttidWizard, "Displaying UI to change duplicate computer "
                         "name %S.", szComputerName);

                nd.pszComputerName = szComputerName;
                if (!bIsUnattended)
                {
                    irt = DialogBoxParam(_Module.GetResourceInstance(),
                                         MAKEINTRESOURCE(IDD_Duplicate_Name),
                                         hwndDlg,
                                         (DLGPROC)DuplicateNameProc,
                                         (LPARAM)&nd);
                }
                else
                {
                    WCHAR szOldComputerName[MAX_COMPUTERNAME_LENGTH+1];
                    wcsncpy(szOldComputerName, szComputerName, MAX_COMPUTERNAME_LENGTH);

                    GenerateComputerNameBasedOnOrganizationName(szComputerName, MAX_COMPUTERNAME_LENGTH);

                    NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UNATTENDED_COMPUTER_NAME_CHANGED),
                                    szOldComputerName, szComputerName
                                    );

                    LowerCaseComputerName(szComputerName);
                    if (!SetComputerNameEx(ComputerNamePhysicalDnsHostname, szComputerName))
                    {
                        TraceLastWin32Error("SetComputerNameEx");
                    }
                    else
                    {
                        (VOID)HrSetActiveComputerName(NULL);
                        TraceTag(ttidWizard, "Setting new computer name %S.", szComputerName);
                    }
                }
            }
            else
            {
                TraceTag(ttidWizard, "Name is already unique.");

                // Restart the workstation service if necessary.
                //
                if (fRestart)
                {
                    TraceTag(ttidWizard, "Restarting Workstation service...");
                    (VOID) sm.HrStartServiceAndWait(c_szSvcWorkstation);
                }
            }
        } while ( (ERROR_DUP_NAME == nas) && (dwNumTries--) && (bIsUnattended) );
    }
    else
    {
        TraceLastWin32Error("EnsureUniqueComputerName - GetComputerNameEx");
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidateNetBiosName
//
//  Purpose:    Ensures that the computer name is a valid DNS name e.g. when
//              upgrading from a previous O/S. If not it logs an error to the
//              setuperr.log
//
//  Arguments:  nothing
//
//  Returns:    S_OK if valid
//              S_FALSE if invalid
//              E_FAIL if failed
//
//  Author:     deonb    2 May 2000
//
//  Notes:
HRESULT ValidateNetBiosName()
{
    TraceFileFunc(ttidGuiModeSetup);

    WCHAR           szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD           cchName = celems(szComputerName);

    if (GetComputerNameEx(ComputerNameNetBIOS,
                          reinterpret_cast<PWSTR>(&szComputerName),
                          &cchName))
    {
        DNS_STATUS dnsStatus = DnsValidateName(szComputerName, DnsNameHostnameLabel);
        switch (dnsStatus)
        {
        case ERROR_SUCCESS:
            return S_OK;

        case ERROR_INVALID_NAME:
                NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UPGRADE_DNS_INVALID_NAME));
                return S_FALSE;

        case DNS_ERROR_INVALID_NAME_CHAR:
                NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UPGRADE_DNS_INVALID_NAME_CHAR));
                return S_FALSE;

        case DNS_ERROR_NON_RFC_NAME:
                NetSetupLogStatusV( LogSevError,
                                    SzLoadIds (IDS_E_UPGRADE_DNS_INVALID_NAME_NONRFC));
                return S_FALSE;

        default:
            TraceError("ValidateComputerName - DnsValidateName", dnsStatus);
            return E_FAIL;
        }
    }
    else
    {
        TraceLastWin32Error("ValidateComputerName - GetComputerNameEx");
        return E_FAIL;
    }
}



//
// Function:    HrSetupGetSourceInfo
//
// Purpose:     Allocates, gets, and returns the required Setup info
//
// Parameters:  hinf        [IN] - setup hinf handle
//              SrcId       [IN] - source id obtained from setup
//              InfoDesired [IN] - indicates what info is desired
//              ppsz        [OUT] - ptr to string to be filled and returned
//
// Returns:     HRESULT
//
HRESULT
HrSetupGetSourceInfo(
        IN  HINF    hinf,
        IN  UINT    SrcId,
        IN  UINT    InfoDesired,
        OUT PWSTR * ppsz)
{
    TraceFileFunc(ttidGuiModeSetup);

    Assert(hinf);
    Assert(SRCINFO_PATH        == InfoDesired ||
           SRCINFO_TAGFILE     == InfoDesired ||
           SRCINFO_DESCRIPTION == InfoDesired);
    Assert(ppsz);

    HRESULT hr = S_OK;
    ULONG   cch;

    // first get the size of the string required
    //
    if (SetupGetSourceInfo(hinf, SrcId, InfoDesired, NULL, 0, &cch))
    {
        //  now get the required info
        //
        *ppsz = (PWSTR) MemAlloc(cch * sizeof (WCHAR));

        if (*ppsz)
        {
            if (!SetupGetSourceInfo(hinf, SrcId, InfoDesired, *ppsz, cch, NULL))
            {
                MemFree(*ppsz);
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//
// Function:    UpgradeEtcServicesFile
//
// Purpose:     Performs upgrade of %windir%\system32\drivers\etc\services file
//
// Parameters:  pWizard [IN] - wizard info
//
// Returns:     void
//
VOID
UpgradeEtcServicesFile(CWizard * pWizard)
{
    TraceFileFunc(ttidGuiModeSetup);
    // find etc\services file, and get size and other data
    // compare size/date etc and decide if we should upgrade it.

    HRESULT hr = S_OK;
    DWORD   status;
    BOOL    fShouldUpgradeIt = FALSE;
    WCHAR   szWindowsDir[MAX_PATH+1];
    tstring strServices;
    static const WCHAR c_szServicesFile[] = L"\\system32\\drivers\\etc\\services";
    static const WCHAR c_szServicesDirSuffix[] = L"\\system32\\drivers\\etc";
    static const DWORD c_dwNT4ServicesFileSize = 6007;

    DWORD cNumCharsReturned = GetSystemWindowsDirectory(szWindowsDir, MAX_PATH);
    if (cNumCharsReturned)
    {
        HANDLE  hFile;

        strServices = szWindowsDir;
        strServices += c_szServicesFile;

        // see if file exists
        hFile = CreateFile(strServices.c_str(),
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
        if (hFile)
        {
            // get attributes
            DWORD dwSize = GetFileSize(hFile, NULL);
            if (c_dwNT4ServicesFileSize == dwSize)
            {
                fShouldUpgradeIt = TRUE;
            }
            CloseHandle(hFile);
        }
        else
        {
            TraceTag(ttidWizard, "services files doesn't exist");
        }
    }
    else
    {
        hr = HrFromLastWin32Error();
    }

    static const WCHAR c_szServices[] = L"services";

    //
    // copy over new services file if required
    //
    if (S_OK == hr && fShouldUpgradeIt)
    {
        //  copy the file
        //
        HSPFILEQ    q               = NULL;
        HINF        hinf            = NULL;
        UINT        SrcId;
        PWSTR       pszTagInfo      = NULL;
        PWSTR       pszDescription  = NULL;
        tstring     strServicesDir  = szWindowsDir;
        PVOID       pCtx            = NULL;

        q = SetupOpenFileQueue();
        if (!q)
        {
            TraceTag(ttidWizard, "SetupOpenFileQueue failed");
            goto cleanup;
        }

        //  we need the location of services._ (the compressed file)
        //  first open layout.inf
        //
        hinf = SetupOpenMasterInf();
        if (!hinf)
        {
            TraceTag(ttidWizard, "Failed to open layout.inf");
            goto cleanup;
        }

        //  get size of needed buffer
        //
        if (!SetupGetSourceFileLocation(hinf, NULL, c_szServices, &SrcId, NULL, 0, NULL))
        {
            TraceTag(ttidWizard, "SetupGetSourceFileLocation failed.");
            goto cleanup;
        }

        //  get TagInfo
        //
        if (S_OK != HrSetupGetSourceInfo(hinf, SrcId, SRCINFO_TAGFILE, &pszTagInfo))
        {
            TraceTag(ttidWizard, "Failed to get TagInfo for services file.");
            goto cleanup;
        }

        //  get Description
        //
        if (S_OK != HrSetupGetSourceInfo(hinf, SrcId, SRCINFO_DESCRIPTION, &pszDescription))
        {
            TraceTag(ttidWizard, "Failed to get Description for services file.");
            goto cleanup;
        }

        //  now copy the file using this info
        //
        strServicesDir += c_szServicesDirSuffix;
        if (!SetupQueueCopy(q,
                            pWizard->PSetupData()->LegacySourcePath,
                            NULL,       // don't need this since LegacySourcePath covers it
                            c_szServices,
                            pszDescription,
                            pszTagInfo,
                            strServicesDir.c_str(),
                            NULL,
                            SP_COPY_REPLACEONLY))
        {
            TraceTag(ttidWizard, "SetupQueueCopy failed");
            goto cleanup;
        }

        pCtx = SetupInitDefaultQueueCallbackEx(NULL,
                                               static_cast<HWND>(INVALID_HANDLE_VALUE),
                                               0, 0, NULL);
        if (!pCtx)
        {
            TraceTag(ttidWizard, "SetupInitDefaultQueueCallbackEx failed.");
            goto cleanup;
        }

        if (!SetupCommitFileQueue(NULL, q, &SetupDefaultQueueCallback, pCtx))
        {
            TraceTag(ttidWizard, "SetupCommitFileQueue failed, "
                                 "did not copy over new services file");
            goto cleanup;
        }

        // success!
        TraceTag(ttidWizard, "Copied over new services file");

cleanup:
        if (pCtx)
        {
            SetupTermDefaultQueueCallback(pCtx);
        }
        MemFree(pszDescription);
        MemFree(pszTagInfo);
        if (hinf)
        {
            SetupCloseInfFile(hinf);
        }
        if (q)
        {
            SetupCloseFileQueue(q);
        }
    }
}


void FixWmiServiceDependencies(
    const WCHAR *ServiceName
    );

extern BOOL WINAPI FNetSetupApplySysPrep();
//
// Function:    InstallUpgradeWorkThrd
//
// Purpose:     Perform an network install or upgrade as appropriate
//
// Parameters:  pitp [IN] - Thread data
//
// Returns:     DWORD, Zero always
//
EXTERN_C
DWORD
InstallUpgradeWorkThrd (
    InitThreadParam* pitp)
{
    TraceFileFunc(ttidGuiModeSetup);

    BOOL            fUninitCOM = FALSE;
    BOOL            fLockSCM   = FALSE;
    HRESULT         hr         = S_OK;
    UINT            uMsg       = PWM_EXIT;
    CServiceManager scm;
    const WCHAR     szISACTRL[]  = L"ISACTRL";

    TraceTag(ttidWizard, "Entering InstallUpgradeWorkThrd...");
    Assert(!IsPostInstall(pitp->pWizard));
    Assert(pitp->pWizard->PNetCfg());

#if DBG
    if (FIsDebugFlagSet (dfidBreakOnStartOfUpgrade))
    {
        AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                 "\"BreakOnStartOfUpgrade\" has been set. Set your breakpoints now.");
    }
#endif // DBG

    OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 10);

    // If this is in Mini-Setup mode, we will try to restore adapter specific parameters
    // saved for SysPrep operation. This has to be done before the normal Answer-File processing.
    // There is nothing we can do with any error here, so any error is ignored.
    if ( (pitp->pWizard->PSetupData())->OperationFlags & SETUPOPER_MINISETUP )
    {
        FNetSetupApplySysPrep();
    }

    TraceTag(ttidWizard, "Waiting on Service Controller");
    // Wait until service controller can be locked
    //
    if (SUCCEEDED(scm.HrOpen()))
    {
        while (!fLockSCM)
        {
            if (SUCCEEDED(scm.HrLock()))
            {
                fLockSCM = TRUE;
                scm.Unlock();
                break;
            }

            Sleep( 500 );
        }
    }

    //
    // Fixup ISA service which has a dependency on the WMI
    // extensions to WDM service that needs to be removed
    //
    FixWmiServiceDependencies(szISACTRL);

    // Initialize COM on this thread
    //
    hr = CoInitializeEx(NULL, COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        TraceTag(ttidWizard, "Failed to initialize COM upgrade work thread");
        goto Done;
    }
    else
    {
        // Remember to uninitialize COM on thread exit
        fUninitCOM = TRUE;
    }

#if DBG
    RtlValidateProcessHeaps ();
#endif

    if (!IsUpgrade(pitp->pWizard))
    {
        // Make sure the computer name is the same for both intended and active
        TraceTag(ttidWizard, "Setting Active Computer Name");
        (VOID)HrSetActiveComputerName(NULL);
    }

    // Synchronize the SAM database
    //
    SyncSAM(pitp->pWizard);

    // Retrieve NetDevice info for later use
    //
    NetDevRetrieveInfo(pitp->pWizard);

    // Do answer file processing if it is unattended mode.
    //
    if (IsUnattended(pitp->pWizard))
    {
        hr = HrInitForUnattendedNetSetup(
                pitp->pWizard->PNetCfg(),
                pitp->pWizard->PSetupData());
    }
    else if ( IsUpgrade(pitp->pWizard) )
    {
        // Attended upgrade is really a repair mode.
        hr = HrInitForRepair();
    }

    // Join the default workgroup if necessary
    //
    if (!IsUpgrade(pitp->pWizard))
    {
        // Join the default workgroup only fresh install
        TraceTag(ttidWizard, "Joining Default Workgroup");
        JoinDefaultWorkgroup(pitp->pWizard, pitp->hwndDlg);
    }

    // Now process any problems in loading netcfg
    //
    if (NETSETUP_E_ANS_FILE_ERROR == hr)
    {
        // $REVIEW - LogError ?

        // Disable unattended for networking
        //
        pitp->pWizard->DisableUnattended();
        TraceTag(ttidWizard, "Error In answer file, installing default networking");
        goto InstallDefNetworking;
    }
    else if (NETSETUP_E_NO_ANSWERFILE == hr)
    {
        // $REVIEW(tongl, 4/6/99): Raid #310599, if we are in mini-setup, then
        // do attended install if no networking section is specified
        HKEY hkeySetup = NULL;
        HRESULT hrReg = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       c_szSystemSetupKey,
                                       KEY_READ,
                                       &hkeySetup);
        if (SUCCEEDED(hrReg))
        {
            DWORD dw;
            hrReg = HrRegQueryDword(hkeySetup, c_szMiniSetupInProgress, &dw);
            RegCloseKey(hkeySetup);
        }

        if (SUCCEEDED(hrReg))
        {
            pitp->pWizard->DisableUnattended();
            TraceTag(ttidWizard, "Mini-setup with no networking section, do attended install");
            goto InstallDefNetworking;
        }
        else
        {
            // Per Raid 199750 - Install default networking when no
            // networking is present.
            //
            TraceTag(ttidWizard, "No network answer file section, minimal network component setup");
            InstallDefaultComponents(pitp->pWizard, EDC_DEFAULT, pitp->hwndDlg);
            goto SkipNetworkComponentInstall;
        }
    }
    else if (FAILED(hr))
    {
        // $REVIEW - logerror
        TraceTag(ttidWizard, "Unexpected Error: 0x%08X",(DWORD)hr);
        pitp->pWizard->SetExitNoReturn();
        goto Done;
    }

    if (!IsUpgrade(pitp->pWizard) && !IsUnattended(pitp->pWizard))
    {   // Attended install
InstallDefNetworking:

        StartSpooler();

        if (IsFreshInstall(pitp->pWizard))
        {
            InstallDefaultComponents(pitp->pWizard, EDC_DEFAULT, pitp->hwndDlg);
        }
    }
    else
    {   // Unattended install or upgrade
        //
        HRESULT          hr2;
        EPageDisplayMode i;
        BOOL             j;

        Assert(NULL != pitp->pWizard->PNetCfg());

        StartSpooler();

        // Upgrade installed components
        //
        TraceTag(ttidWizard, "Processing installed adapters...");
        OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 15);
        hr2 = HrDoUnattend(pitp->hwndDlg, pitp->pWizard->PNetCfg(),
                           UAW_NetAdapters, &i, &j);
        TraceHr(ttidWizard, FAL, hr2, FALSE, "Processing installed adapters failed.");

        TraceTag(ttidWizard, "Upgrading Installed Protocols...");
        OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 25);
        hr2 = HrDoUnattend(pitp->hwndDlg, pitp->pWizard->PNetCfg(),
                           UAW_NetProtocols, &i, &j);
        TraceHr(ttidWizard, FAL, hr2, FALSE, "Upgrading Installed Protocols failed.");

        TraceTag(ttidWizard, "Upgrading Installed Clients...");
        OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 40);
        hr2 = HrDoUnattend(pitp->hwndDlg, pitp->pWizard->PNetCfg(),
                                    UAW_NetClients, &i, &j);
        TraceHr(ttidWizard, FAL, hr2, FALSE, "Upgrading Installed Clients failed.");

        TraceTag(ttidWizard, "Upgrading Installed Services...");
        OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 55);
        hr2 = HrDoUnattend(pitp->hwndDlg, pitp->pWizard->PNetCfg(),
                                    UAW_NetServices, &i, &j);
        TraceHr(ttidWizard, FAL, hr2, FALSE, "Upgrading Installed Services failed.");

        TraceTag(ttidWizard, "Restoring pre-upgrade bindings...");
        OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 70);
        hr2 = HrDoUnattend(pitp->hwndDlg, pitp->pWizard->PNetCfg(),
                                    UAW_NetBindings, &i, &j);
        TraceHr(ttidWizard, FAL, hr2, FALSE, "Restoring pre-upgrade bindings failed.");

        TraceTag(ttidWizard, "Removing unsupported components...");
        OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, 85);
        hr2 = HrDoUnattend(pitp->hwndDlg, pitp->pWizard->PNetCfg(),
                           UAW_RemoveNetComponents, &i, &j);
        TraceHr(ttidWizard, FAL, hr2, FALSE, "Removing unsupported components failed.");

        // If we are upgrading and have an answerfile, update lana
        // configuration using the information in the file.
        // Note: This must be done after all the components have been
        // installed (Upgraded), so that all the bindings are present
        // when we update hte configuration.
        //
        if (IsUpgrade (pitp->pWizard) && IsUnattended (pitp->pWizard) &&
                (S_OK == pitp->pWizard->PNetCfg()->FindComponent (
                    c_szInfId_MS_NetBIOS, NULL)))
        {
            PWSTR pszAnswerFile;
            PWSTR pszAnswerSection;
            hr = HrGetAnswerFileParametersForComponent (c_szInfId_MS_NetBIOS,
                    &pszAnswerFile, &pszAnswerSection);

            if (S_OK == hr)
            {
                NC_TRY
                {
                    UpdateLanaConfigUsingAnswerfile (pszAnswerFile,
                            pszAnswerSection);
                }
                NC_CATCH_ALL
                {
                    TraceTag (ttidWizard, "Possible delayload failure of "
                            "netcfgx dll while trying to update lana "
                            "information.");
                }

                CoTaskMemFree (pszAnswerFile);
                CoTaskMemFree (pszAnswerSection);
            }

            // We can't let the error stop us.
            hr = S_OK;
        }

        // Install networking, if no networking is present. "no networking"
        // means no visible LAN-enabled protocol installed.
        //
        // First try to install default components as opposed to
        // mandatory components because TCP/IP is both mandatory
        // and default. So, if we install mandatory first then,
        // default components will never be installed as TCP/IP is
        // a visible LAN-enabled protocol.
        // Raid bug 337827

        InstallDefaultComponentsIfNeeded(pitp->pWizard);

        // Install mandatory components.

        InstallDefaultComponents(pitp->pWizard, EDC_MANDATORY, pitp->hwndDlg);


        // Special Case.  Need an extra OBOUser ref-count for File and Print
        // when upgrading from NT3.51 or NT4 and GSNW is installed.  This is
        // because ref-counting didn't exist pre-NT5
        //
        OBOUserAddRefSpecialCase(pitp->pWizard);

#if DBG
        if (FIsDebugFlagSet (dfidBreakOnEndOfUpgrade))
        {
            AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                     "\"BreakOnEndOfUpgrade\" has been set. Set your breakpoints now.");
        }
#endif // DBG
    }

    // Convert any components which were OC and are now regular networking components
    //
    if (IsUpgrade(pitp->pWizard))
    {
        FixupOldOcComponents(pitp->pWizard);
    }

    //
    // Upgrade system32\drivers\etc\services file if necessary
    //
    if (IsUpgrade(pitp->pWizard))
    {
        UpgradeEtcServicesFile(pitp->pWizard);
    }


SkipNetworkComponentInstall:
    OnUpgradeUpdateProgressCap(pitp->hwndDlg, pitp->pWizard, c_nMaxProgressRange);

    // Commit any changes
    //
    (VOID)HrCommitINetCfgChanges(GetParent(pitp->hwndDlg), pitp->pWizard);

    // Add unbound LAN adapters to the processing queue.  For ATM this will
    // have the side effect of creating virtual LAN adapters but not creating
    // the connections associated with them
    //
    Assert(pitp->pWizard->FProcessLanPages());
    (VOID)pitp->pWizard->PAdapterQueue()->HrQueryUnboundAdapters(pitp->pWizard);

    // Commit the changes caused by processing the unbound adapters
    //
    (VOID)HrCommitINetCfgChanges(GetParent(pitp->hwndDlg), pitp->pWizard);

    // Now for the ATM case create connections for the virtual LAN adapters
    // and commit the changes
    //
    (VOID)pitp->pWizard->PAdapterQueue()->HrQueryUnboundAdapters(pitp->pWizard);
    (VOID)HrCommitINetCfgChanges(GetParent(pitp->hwndDlg), pitp->pWizard);

    uMsg = PWM_PROCEED;

Done:
    // Shutdown the progress timer if it's not already stopped
    //
    {
        LPARAM lParam = pitp->pWizard->GetPageData(IDD_Upgrade);
        Assert(lParam);
        UpgradeData * pData = reinterpret_cast<UpgradeData *>(lParam);
        ::KillTimer(pitp->hwndDlg, c_uiUpgradeRefreshID);

        // Set the progress indicator to its full position
        //
        HWND hwndProgress = GetDlgItem(pitp->hwndDlg, IDC_UPGRADE_PROGRESS);
        SendMessage(hwndProgress, PBM_SETPOS,
                    c_nMaxProgressRange, 0);
        UpdateWindow(hwndProgress);
    }

    // Uninitialize COM for this thread
    //
    if (fUninitCOM)
    {
        CoUninitialize();
    }

    EnsureUniqueComputerName(pitp->hwndDlg, IsUnattended(pitp->pWizard));
    ValidateNetBiosName();

    PostMessage(pitp->hwndDlg, uMsg, (WPARAM)0, (LPARAM)0);

    delete pitp;

#if DBG
    RtlValidateProcessHeaps ();
#endif

    TraceTag(ttidWizard, "Leaving InstallUpgradeWorkThrd...");
    return 0;
}

//
// Function:    OnUpgradePageActivate
//
// Purpose:     Handle the PSN_SETACTIVE notification by either: Creating a
//              thread to process install/upgrade requirements or to just
//              deny activation of the page.
//
// Parameters:  hwndDlg [IN] - Handle to the upgrade child dialog
//
// Returns:     BOOL, TRUE on success
//
BOOL OnUpgradePageActivate( HWND hwndDlg )
{
    TraceFileFunc(ttidGuiModeSetup);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    // Retrieve the page data stashed within the wizard for this page
    LPARAM lParam = pWizard->GetPageData(IDD_Upgrade);
    Assert(lParam);
    UpgradeData * pData = reinterpret_cast<UpgradeData *>(lParam);

    if(!pData)
    {
        return false;
    }

    // Based on the page data decide whether focus is acceptable
    if (pData->fProcessed)
    {
        // Accept focus
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);
        PAGEDIRECTION  PageDir = pWizard->GetPageDirection(IDD_Upgrade);
        if (NWPD_FORWARD == PageDir)
        {
            // Get to this page when the user navigates back and forth
            // and we already processed InstallUpgradeWorkThrd
            if (g_pSetupWizard != NULL)
            {
                g_pSetupWizard->PSetupData()->ShowHideWizardPage(TRUE);
            }
            pWizard->SetPageDirection(IDD_Upgrade, NWPD_BACKWARD);
            PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
        }
        else
        {
            // if there are any adapters previous to the current in the queue
            // jump to them before accepting focus here
            if (!OnProcessPrevAdapterPagePrev(hwndDlg, 0))
            {
                pWizard->SetPageDirection(IDD_Upgrade, NWPD_FORWARD);
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);
            }
        }
    }
    else
    {
        HANDLE hthrd;
        DWORD  dwThreadId = 0;

        PropSheet_SetWizButtons( GetParent( hwndDlg ), 0);

        TraceTag(ttidWizard,"Upgrade/Install Page commencing");

        // Install the Asyncmac software-enumerated device.
        // Important to do this before the INetCfg lock is obtained, because
        // the installation of this device causes or class installer to be
        // invoked which needs to get its own lock to process the installation.
        //
        static const GUID DEVICE_GUID_ASYNCMAC =
            {0xeeab7790,0xc514,0x11d1,{0xb4,0x2b,0x00,0x80,0x5f,0xc1,0x27,0x0e}};

        (VOID) HrInstallSoftwareDeviceOnInterface (
                    &DEVICE_GUID_ASYNCMAC,
                    &GUID_NDIS_LAN_CLASS,
                    L"asyncmac",
                    TRUE,    // force installation since this happens during GUI mode.
                    L"netrasa.inf",
                    hwndDlg);

        // Not processed yet, spin up the thread to do the Install/Upgrade
        pData->fProcessed = TRUE;
        ::SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, 0);

        InitThreadParam * pitp = new InitThreadParam;

        HRESULT hr = S_OK;

        if(pitp)
        {
            pitp->hwndDlg = hwndDlg;
            pitp->pWizard = pWizard;

            TraceTag(ttidWizard, "Creating INetCfg Instance");
            hr = HrInitAndGetINetCfg(pitp->pWizard);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            // We are installing and only show progress, hide the page
            if (g_pSetupWizard != NULL)
            {
                g_pSetupWizard->PSetupData()->ShowHideWizardPage(FALSE);
            }

            // Create the work thread
            hthrd = CreateThread( NULL, STACK_SIZE_TINY,
                                  (LPTHREAD_START_ROUTINE)InstallUpgradeWorkThrd,
                                  (LPVOID)pitp, 0, &dwThreadId );
            if (NULL != hthrd)
            {
                CloseHandle( hthrd );
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                Assert(hr);

                // Kill the timer we created since the thread won't be around
                // to kill it for us.
                //
                ::KillTimer(hwndDlg, c_uiUpgradeRefreshID);
            }
        }

        if (FAILED(hr) || (NULL == hthrd))
        {
            // Failed to create the required netsetup thread
            delete pitp;
            AssertSz(0,"Unable to create netsetup thread.");
            TraceHr(ttidWizard, FAL, hr, FALSE, "OnUpgradePageActivate - Create thread failed");
            pWizard->SetExitNoReturn();
            PostMessage(hwndDlg, PWM_EXIT, (WPARAM)0, (LPARAM)0);
        }
    }

    return( TRUE );
}

//
// Function:    OnUpgradePageExit
//
// Purpose:     Handle the PWN_EXIT notification
//
// Parameters:  hwndDlg [IN] - Handle to the upgrade child dialog
//
// Returns:     BOOL, TRUE if the action was processed internally
//
BOOL OnUpgradePageExit( HWND hwndDlg )
{
    TraceFileFunc(ttidGuiModeSetup);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT);

    // goto the exit page
    HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Exit);
    PostMessage(GetParent(hwndDlg), PSM_SETCURSEL, 0,
                (LPARAM)(HPROPSHEETPAGE)hPage);

    return (TRUE);
}

//
// Function:    OnUpgradePageProceed
//
// Purpose:     Handle the PWN_PROCEED notification
//
// Parameters:  hwndDlg [IN] - Handle to the upgrade child dialog
//
// Returns:     BOOL, TRUE if the action was processed internally
//
BOOL OnUpgradePageProceed( HWND hwndDlg )
{
    TraceFileFunc(ttidGuiModeSetup);

    int nIdx;
    int rgIdcShow[] = { BTN_UPGRADE_TYPICAL, BTN_UPGRADE_CUSTOM,
                        TXT_UPGRADE_TYPICAL_1, TXT_UPGRADE_CUSTOM_1,
                        TXT_UPGRADE_INSTRUCTIONS};
    int rgIdcShowWorkstation[] = { BTN_UPGRADE_TYPICAL, BTN_UPGRADE_CUSTOM,
                        TXT_UPGRADE_TYPICAL_1_WS, TXT_UPGRADE_CUSTOM_1,
                        TXT_UPGRADE_INSTRUCTIONS};
    int rgIdcHide[] = {TXT_UPGRADE_WAIT, IDC_UPGRADE_PROGRESS};

    PRODUCT_FLAVOR pf;
    GetProductFlavor(NULL, &pf);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    // Expose the typical/custom controls on the upgrade page
    // and hide the "working" controls unless there are no adapters
    //
    if (pWizard->PAdapterQueue()->FAdaptersInstalled())
    {
        for (nIdx=0; nIdx < celems(rgIdcHide); nIdx++)
            ShowWindow(GetDlgItem(hwndDlg, rgIdcHide[nIdx]), SW_HIDE);

        if (PF_WORKSTATION == pf)
        {
            for (nIdx=0; nIdx < celems(rgIdcShowWorkstation); nIdx++)
                ShowWindow(GetDlgItem(hwndDlg, rgIdcShowWorkstation[nIdx]), SW_SHOW);
        }
        else
        {
            for (nIdx=0; nIdx < celems(rgIdcShow); nIdx++)
                ShowWindow(GetDlgItem(hwndDlg, rgIdcShow[nIdx]), SW_SHOW);
        }
    }

    ::SetFocus(GetDlgItem(hwndDlg, BTN_UPGRADE_TYPICAL));

    PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_NEXT | PSWIZB_BACK);

    // If upgrading, or we're in one of the interesting unattended mode,
    // or there are no adapters or this is sbs version then automatically
    // advance the UI in "typical" mode. In case of sbs, join page also
    // advances automatically.
    //
    // SBS requires a static IP address for the LAN network card and the
    // networking configuration is done in SBS setup.

    if (IsUpgrade(pWizard) ||
        !pWizard->PAdapterQueue()->FAdaptersInstalled() ||
        (IsUnattended(pWizard) &&
          ((UM_FULLUNATTENDED == pWizard->GetUnattendedMode()) ||
           (UM_DEFAULTHIDE == pWizard->GetUnattendedMode()) ||
           (UM_READONLY == pWizard->GetUnattendedMode()))) ||
            IsSBS())
    {
        PostMessage(GetParent(hwndDlg), PSM_PRESSBUTTON, (WPARAM)(PSBTN_NEXT), 0);
    }
    else
    {
        // make sure the page is visible.
        if (g_pSetupWizard != NULL)
        {
            g_pSetupWizard->PSetupData()->ShowHideWizardPage(TRUE);
            g_pSetupWizard->PSetupData()->BillBoardSetProgressText(TEXT(""));
        }
    }

    return (TRUE);
}

//
// Function:    OnUpgradePageNext
//
// Purpose:     Handle the PWN_WIZNEXT notification
//
// Parameters:  hwndDlg [IN] - Handle to the upgrade child dialog
//
// Returns:     BOOL, TRUE if the action was processed internally
//
BOOL OnUpgradePageNext(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    pWizard->SetPageDirection(IDD_Upgrade, NWPD_BACKWARD);

    // Based on UI selection, hide or unhide new adapters
    //
    if (IsDlgButtonChecked(hwndDlg, BTN_UPGRADE_TYPICAL))
    {
        pWizard->PAdapterQueue()->HideAllAdapters();
    }
    else
    {
        pWizard->PAdapterQueue()->UnhideNewAdapters();
    }

    return OnProcessNextAdapterPageNext(hwndDlg, FALSE);
}

//
// Function:    OnUpgradePagePrev
//
// Purpose:     Handle the PWN_WIZBACK notification
//
// Parameters:  hwndDlg [IN] - Handle to the upgrade child dialog
//
// Returns:     BOOL, TRUE if the action was processed internally
//
BOOL OnUpgradePagePrev(HWND hwndDlg)
{
    TraceFileFunc(ttidGuiModeSetup);

    // Retrieve the CWizard instance from the dialog
    CWizard * pWizard =
        reinterpret_cast<CWizard *>(::GetWindowLongPtr(hwndDlg, DWLP_USER));
    Assert(NULL != pWizard);

    pWizard->SetPageDirection(IDD_Upgrade, NWPD_FORWARD);

    return FALSE;
}

//
// Function:    OnUpgradeInitDialog
//
// Purpose:     Handle the InitDialog message for the upgrade page
//
// Parameters:  hwndDlg [IN] - Handle to the upgrade page window
//              lParam  [IN] - LPARAM value from the WM_INITDIALOG message
//
// Returns:     FALSE (let the dialog proc set focus)
//
BOOL OnUpgradeInitDialog(HWND hwndDlg, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);

    // Initialize our pointers to property sheet info.
    //
    PROPSHEETPAGE* psp = (PROPSHEETPAGE*)lParam;
    Assert(psp->lParam);
    ::SetWindowLongPtr(hwndDlg, DWLP_USER, psp->lParam);

    // Cast the property sheet lParam data into the wizard which it is
    //
    CWizard * pWizard = reinterpret_cast<CWizard *>(psp->lParam);
    Assert(NULL != pWizard);

    // Get the private data we stashed away for this page
    //
    lParam = pWizard->GetPageData(IDD_Upgrade);
    Assert(lParam);
    UpgradeData * pData = reinterpret_cast<UpgradeData *>(lParam);

    // Start the progress
    //
    HWND hwndProgress = GetDlgItem(hwndDlg, IDC_UPGRADE_PROGRESS);

    // Subclass the progress and make it also call the BB callback.
    // Only do this if we are called from GUI mode setup.
    if (g_pSetupWizard != NULL)
    {
        PCWSTR str = SzLoadIds(IDS_BB_NETWORK);
        OldProgressProc = (WNDPROC)SetWindowLongPtr(hwndProgress,GWLP_WNDPROC,(LONG_PTR)NewProgessProc);

        // Set the string for the progress on the billboard.
        g_pSetupWizard->PSetupData()->BillBoardSetProgressText(str);
    }

    SendMessage(hwndProgress, PBM_SETRANGE, 0, MAKELPARAM(0,c_nMaxProgressRange));
    SendMessage(hwndProgress, PBM_SETPOS, 1, 0);
    SetTimer(hwndDlg, c_uiUpgradeRefreshID, c_uiUpgradeRefreshRate, NULL);

    // Disable prev/next until initial work is complete
    //
    PropSheet_SetWizButtons(GetParent(hwndDlg), 0);

    // Default the mode buttons to typical
    //
    CheckRadioButton(hwndDlg, BTN_UPGRADE_TYPICAL,
                     BTN_UPGRADE_CUSTOM, BTN_UPGRADE_TYPICAL);

    // Create the bold font and apply to the mode buttons
    //
    SetupFonts(hwndDlg, &pData->hBoldFont, FALSE);
    if (pData->hBoldFont)
    {
        SetWindowFont(GetDlgItem(hwndDlg, BTN_UPGRADE_TYPICAL),
                      pData->hBoldFont, FALSE);
        SetWindowFont(GetDlgItem(hwndDlg, BTN_UPGRADE_CUSTOM),
                      pData->hBoldFont, FALSE);
    }

    HICON hIcon = LoadIcon(_Module.GetResourceInstance(),
                           MAKEINTRESOURCE(IDI_LB_GEN_M_16));
    if (hIcon)
    {
        SendMessage(GetDlgItem(hwndDlg, TXT_UPGRADE_ICON), STM_SETICON,
                    (WPARAM)hIcon, 0L);
    }

    return FALSE;
}

//
// Function:    dlgprocUpgrade
//
// Purpose:     Dialog Procedure for the Upgrade wizard page
//
// Parameters:  standard dlgproc parameters
//
// Returns:     BOOL
//
INT_PTR CALLBACK dlgprocUpgrade(HWND hwndDlg, UINT uMsg,
                                WPARAM wParam, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);

    BOOL frt = FALSE;

    switch (uMsg)
    {
    case PWM_EXIT:
        frt = OnUpgradePageExit(hwndDlg);
        break;

    case PWM_PROCEED:
        frt = OnUpgradePageProceed(hwndDlg);
        break;

    case WM_INITDIALOG:
        frt = OnUpgradeInitDialog(hwndDlg, lParam);
        break;

    case WM_TIMER:
        OnUpgradeUpdateProgress(hwndDlg);
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch (pnmh->code)
            {
            // propsheet notification
            case PSN_HELP:
                break;

            case PSN_SETACTIVE:
                frt = OnUpgradePageActivate( hwndDlg );
                break;

            case PSN_APPLY:
                break;

            case PSN_KILLACTIVE:
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                frt = OnUpgradePagePrev(hwndDlg);
                break;

            case PSN_WIZFINISH:
                break;

            case PSN_WIZNEXT:
                frt = OnUpgradePageNext(hwndDlg);
                break;

            default:
                break;
            }
        }
        break;

    default:
        break;
    }

    return( frt );
}

//
// Function:    UpgradePageCleanup
//
// Purpose:     As a callback function to allow any page allocated memory
//              to be cleaned up, after the page will no longer be accessed.
//
// Parameters:  pWizard [IN] - The wizard against which the page called
//                             register page
//              lParam  [IN] - The lParam supplied in the RegisterPage call
//
// Returns:     nothing
//
VOID UpgradePageCleanup(CWizard *pWizard, LPARAM lParam)
{
    TraceFileFunc(ttidGuiModeSetup);

    UpgradeData * pData;
    pData = reinterpret_cast<UpgradeData*>(lParam);
    if (NULL != pData)
    {
        DeleteObject(pData->hBoldFont);
        MemFree(pData);
    }
}

//
// Function:    CreateUpgradePage
//
// Purpose:     To determine if the upgrade page needs to be shown, and to
//              to create the page if requested.  Note the upgrade page is
//              responsible for initial installs also.
//
// Parameters:  pWizard     [IN] - Ptr to a Wizard instance
//              pData       [IN] - Context data to describe the world in
//                                 which the Wizard will be run
//              fCountOnly  [IN] - If True, only the maximum number of
//                                 pages this routine will create need
//                                 be determined.
//              pnPages     [IN] - Increment by the number of pages
//                                 to create/created
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrCreateUpgradePage(CWizard *pWizard, PINTERNAL_SETUP_DATA pData,
                    BOOL fCountOnly, UINT *pnPages)
{
    TraceFileFunc(ttidGuiModeSetup);

    HRESULT hr = S_OK;

    // Batch Mode or for fresh install
    if (!IsPostInstall(pWizard))
    {
        hr = E_OUTOFMEMORY;

        UpgradeData * pData = reinterpret_cast<UpgradeData*>
                                (MemAlloc(sizeof(UpgradeData)));
        if (NULL == pData)
        {
            goto Error;
        }

        pData->fProcessed = FALSE;
        pData->hBoldFont = NULL;
        pData->nCurrentCap = 0;

        (*pnPages)++;

        // If not only counting, create and register the page
        if (!fCountOnly)
        {
            HPROPSHEETPAGE hpsp;
            PROPSHEETPAGE psp;

            TraceTag(ttidWizard, "Creating Upgrade Page");
            psp.dwSize = sizeof( PROPSHEETPAGE );
            psp.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
            psp.hInstance = _Module.GetResourceInstance();
            psp.pszTemplate = MAKEINTRESOURCE( IDD_Upgrade );
            psp.hIcon = NULL;
            psp.pfnDlgProc = dlgprocUpgrade;
            psp.lParam = reinterpret_cast<LPARAM>(pWizard);
            psp.pszHeaderTitle = SzLoadIds(IDS_T_Upgrade);
            psp.pszHeaderSubTitle = SzLoadIds(IDS_ST_Upgrade);

            hpsp = CreatePropertySheetPage( &psp );
            if (hpsp)
            {
                pWizard->RegisterPage(IDD_Upgrade, hpsp,
                                      UpgradePageCleanup,
                                      reinterpret_cast<LPARAM>(pData));
                hr = S_OK;
            }
            else
            {
                MemFree(pData);
            }
        }
    }

Error:
    TraceHr(ttidWizard, FAL, hr, FALSE, "HrCreateUpgradePage");
    return hr;
}

//
// Function:    AppendUpgradePage
//
// Purpose:     Add the Upgrade page, if it was created, to the set of pages
//              that will be displayed.
//
// Parameters:  pahpsp  [IN,OUT] - Array of pages to add our page to
//              pcPages [IN,OUT] - Count of pages in pahpsp
//
// Returns:     Nothing
//
VOID AppendUpgradePage(CWizard *pWizard, HPROPSHEETPAGE* pahpsp, UINT *pcPages)
{
    TraceFileFunc(ttidGuiModeSetup);

    if (!IsPostInstall(pWizard))
    {
        HPROPSHEETPAGE hPage = pWizard->GetPageHandle(IDD_Upgrade);
        Assert(hPage);
        pahpsp[*pcPages] = hPage;
        (*pcPages)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\sminc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S M I N C . H
//
//  Contents:   Standard include for the shell\statmon code
//
//  Notes:
//
//  Author:     CWill   10/21/1997
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _SMINC_H_
#define _SMINC_H_

#include "nsbase.h"     // must be first to include atl

#include "ncatlps.h"
#include "ncstl.h"
#include "resource.h"

#include "ras.h"

#include "ncerror.h"
#include "ncnetcon.h"
#include "smcent.h"
#include "smeng.h"

#endif  // _SMINC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smpsh.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S M P S H . H
//
//  Contents:   The property sheets header
//
//  Notes:
//
//  Author:     CWill   10/14/1997
//
//----------------------------------------------------------------------------
//
//  The Status Monitor's General Page
//

extern const WCHAR c_szNetCfgHelpFile[];

const UINT PWM_UPDATE_STATUS_DISPLAY    = WM_USER + 1;
const UINT PWM_UPDATE_RAS_LINK_LIST     = WM_USER + 2;
const UINT PWM_UPDATE_IPCFG_DISPLAY     = WM_USER + 3;

enum StatTrans
{
    Stat_Unknown,
    Stat_Bytes,
    Stat_Packets
};

//
// The Status Monitors General Page
//
class ATL_NO_VTABLE CPspStatusMonitorGen :
    public CComObjectRootEx <CComObjectThreadModel>,
    public CPropSheetPage,
    public INetConnectionStatisticsNotifySink
{
public:
    CPspStatusMonitorGen(VOID);

    BEGIN_COM_MAP(CPspStatusMonitorGen)
        COM_INTERFACE_ENTRY(INetConnectionStatisticsNotifySink)
    END_COM_MAP()

    BEGIN_MSG_MAP(CPspStatusMonitorGen)

        // Windows Messages
        //
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CLOSE, OnClose)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)

        MESSAGE_HANDLER(WM_TIMER, OnTimer)
        MESSAGE_HANDLER(PWM_UPDATE_STATUS_DISPLAY, OnUpdateStatusDisplay)

        MESSAGE_HANDLER(WM_PAINT, OnPaint)

        // Notifications
        //
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnSetActive)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)

        // Command handlers
        COMMAND_ID_HANDLER(IDC_PSB_DISCONNECT, OnDisconnect)
        COMMAND_ID_HANDLER(IDC_PSB_PROPERTIES, OnRaiseProperties)

    END_MSG_MAP()

// Message handlers
//
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUpdateStatusDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetActive(INT idCtrl, LPNMHDR pnmh, BOOL & bHandled);
    LRESULT OnKillActive(INT idCtrl, LPNMHDR pnmh, BOOL & bHandled);

    LRESULT OnDisconnect(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRaiseProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CPspStatusMonitorRas;

public:
    STDMETHOD(OnStatisticsChanged)(DWORD dwChangeFlags);
    VOID FinalRelease ();

// Helper functions
//
public:
    HRESULT HrInitGenPage(CNetStatisticsEngine* pnseNew,
                          INetConnection* pncNew,
                          const DWORD * adwHelpIDs = NULL);
    HRESULT HrCleanupGenPage(VOID);

    HRESULT HrDisconnectConnection(BOOL fConfirmed = FALSE);

    VOID SetAsFirstPage(BOOL fFirst = TRUE)
    {
        m_fIsFirstPage = fFirst;
    }

// Utility Functions
//
protected:
    VOID UpdatePage(
            STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    virtual VOID UpdatePageSpeed(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    VOID UpdatePageConnectionStatus(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    virtual VOID UpdatePageIcon(DWORD dwChangeFlags);

    VOID UpdateSignalStrengthIcon(INT iRSSI);

    virtual VOID UpdatePageDuration(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    virtual VOID UpdatePageBytesTransmitting(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData,
            StatTrans iStat);

    virtual VOID UpdatePageBytesReceiving(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData,
            StatTrans iStat);

    VOID UpdatePageCompTransmitting(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    VOID UpdatePageCompReceiving(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    VOID UpdatePageErrorsTransmitting(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    VOID UpdatePageErrorsReceiving(
            const STATMON_ENGINEDATA* pseOldData,
            const STATMON_ENGINEDATA* pseNewData);

    BOOL FIsShowLanErrorRegKeySet();
    
    virtual BOOL ShouldShowPackets(const STATMON_ENGINEDATA* pseNewData);

protected:
    STATMON_ENGINEDATA*     m_psmEngineData;

    CNetStatisticsEngine*   m_pnseStat;
    DWORD                   m_dwChangeFlags;

    DWORD                   m_dwConPointCookie;
    BOOL                    m_fStats;
    NETCON_MEDIATYPE        m_ncmType;
    NETCON_SUBMEDIATYPE     m_ncsmType;
    DWORD                   m_dwCharacter;

    DWORD                   m_dwLastUpdateStatusDisplayTick;
    BOOL                    m_fProcessingTimerEvent;

    int                     m_iStatTrans;

    const DWORD *           m_adwHelpIDs;

    BOOL                    m_fIsFirstPage;

    INT                     m_iLastSignalStrength;
};

//
// The Status Monitors Tools Page
//
class CPspStatusMonitorTool: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPshStatusMonitorTools)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDC_BTN_SM_TOOLS_OPEN, OnToolOpen)

        NOTIFY_CODE_HANDLER(LVN_ITEMACTIVATE, OnItemActivate)
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)

    END_MSG_MAP()

// Message handlers
//
public:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnToolOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnItemActivate(INT idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnItemChanged(INT idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    CPspStatusMonitorTool(VOID);
    ~CPspStatusMonitorTool(VOID);

public:
    HRESULT HrInitToolPage(INetConnection* pncInit, const DWORD * adwHelpIDs = NULL);
    BOOL FToolListEmpty()
    {
        return (m_lstpsmte.size()==0);
    }

private:
    virtual HRESULT HrInitToolPageType(INetConnection* pncInit) PURE;
    virtual HRESULT HrAddCommandLineFlags(tstring* pstrFlags,
            CStatMonToolEntry* psmteSel) PURE;

    virtual HRESULT HrGetDeviceType(INetConnection* pncInit) PURE;
    virtual HRESULT HrGetComponentList(INetConnection* pncInit) PURE;

// Utility Functions
//
private:
    HRESULT HrCreateToolList(INetConnection* pncInit);
    BOOL FToolToAddToList(CStatMonToolEntry* psmteTest);
    HRESULT HrFillToolList(VOID);
    HRESULT HrAddOneEntryToToolList(
            CStatMonToolEntry* psmteAdd, INT iItem);
    HRESULT HrLaunchTool(VOID);
    HRESULT HrAddAllCommandLineFlags(tstring* pstrFlags,
            CStatMonToolEntry* psmteSel);
    HRESULT HrAddCommonCommandLineFlags(tstring* pstrFlags,
            CStatMonToolEntry* psmteSel);

// Internal data
//
protected:
    HWND                        m_hwndToolList;
    list<CStatMonToolEntry*>    m_lstpsmte;

    NETCON_MEDIATYPE            m_ncmType;
    NETCON_SUBMEDIATYPE         m_ncsmType;
    tstring                     m_strDeviceType;
    list<tstring*>              m_lstpstrCompIds;

    GUID                        m_guidId;
    DWORD                       m_dwCharacter;

    const DWORD *               m_adwHelpIDs;
};

//
// The Status Monitors RAS Page
//

//
//  Data associated with each of the sub devices in a modem connection
//
class CRasDeviceInfo
{
public:
    CRasDeviceInfo()
    {
        m_iSubEntry = -1;
    }

    VOID SetDeviceName(PCWSTR pszDeviceName)
    {
        m_strDeviceName = pszDeviceName;
    }

    VOID SetSubEntry(DWORD iSubEntry)
    {
        m_iSubEntry = iSubEntry;
    }

    PCWSTR PszGetDeviceName(VOID)
    {
        return m_strDeviceName.c_str();
    }

    DWORD DwGetSubEntry(VOID)
    {
        return m_iSubEntry;
    }

private:
    tstring         m_strDeviceName;
    DWORD           m_iSubEntry;
};

//
//  The RAS page
//
class CPspStatusMonitorRas: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPshStatusMonitorRas)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor);
        
        COMMAND_ID_HANDLER(IDC_BTN_SM_SUSPEND_DEVICE, OnSuspendDevice)
        COMMAND_ID_HANDLER(IDC_CMB_SM_RAS_DEVICES, OnDeviceDropDown)

        MESSAGE_HANDLER(PWM_UPDATE_RAS_LINK_LIST, OnUpdateRasLinkList)

    END_MSG_MAP()

// Message handlers
//
public:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnSuspendDevice(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDeviceDropDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnUpdateRasLinkList(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    CPspStatusMonitorRas();
    ~CPspStatusMonitorRas(VOID);

public:
    HRESULT HrInitRasPage(INetConnection* pncInit,
                          CPspStatusMonitorGen * pGenPage,
                          const DWORD * dwHelpIDs = NULL);

// Utility Functions
//
private:
    VOID FillDeviceDropDown();
    VOID FillPropertyList();
    VOID FillRasClientProperty();
    VOID FillRasServerProperty();
    int InsertProperty(int * piItem, UINT unId, tstring& strValue);
    NETCON_STATUS NcsGetDeviceStatus(CRasDeviceInfo* prdiStatus);
    VOID SetButtonStatus(CRasDeviceInfo* prdiSelect);
    UINT GetActiveDeviceCount();

// Internal data
//
protected:
    HRASCONN                m_hRasConn;
    tstring                 m_strPbkFile;
    tstring                 m_strEntryName;

    tstring                 m_strConnectionName;
    list<CRasDeviceInfo*>   m_lstprdi;

    CPspStatusMonitorGen *  m_pGenPage;

    // initialize
    NETCON_MEDIATYPE        m_ncmType;
    DWORD                   m_dwCharacter;

    const DWORD *           m_adwHelpIDs;
};

//
// Implementation of the RAS pages
//
class CPspRasGen: public CPspStatusMonitorGen
{
public:
    CPspRasGen(VOID);
    VOID put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType);
    VOID put_Character(DWORD dwCharacter);
};

class CPspRasTool: public CPspStatusMonitorTool
{
public:
    CPspRasTool(VOID);

    VOID put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType);
    VOID put_Character(DWORD dwCharacter);

    HRESULT HrInitToolPageType(INetConnection* pncInit);
    HRESULT HrAddCommandLineFlags(tstring* pstrFlags,
            CStatMonToolEntry* psmteSel);

    HRESULT HrGetDeviceType(INetConnection* pncInit);
    HRESULT HrGetComponentList(INetConnection* pncInit);
};

//
// Implementation of the LAN pages
//
class CPspLanGen: public CPspStatusMonitorGen
{
public:
    CPspLanGen(VOID);
    VOID put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType);
};

class CPspLanTool: public CPspStatusMonitorTool
{
public:
    CPspLanTool(VOID);

    HRESULT HrInitToolPageType(INetConnection* pncInit);
    HRESULT HrAddCommandLineFlags(tstring* pstrFlags,
            CStatMonToolEntry* psmteSel);

    HRESULT HrGetDeviceType(INetConnection* pncInit);
    HRESULT HrGetComponentList(INetConnection* pncInit);

private:
    tstring m_strDeviceName;
};

//
// Implementation of the Shared Access pages
//
class CPspSharedAccessGen: public CPspStatusMonitorGen
{
public:
    CPspSharedAccessGen(VOID);
    VOID put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType);
protected:
    VOID UpdatePageBytesReceiving(const STATMON_ENGINEDATA* pseOldData, const STATMON_ENGINEDATA* pseNewData, StatTrans    iStat);
    VOID UpdatePageBytesTransmitting(const STATMON_ENGINEDATA* pseOldData, const STATMON_ENGINEDATA* pseNewData, StatTrans    iStat);
    BOOL ShouldShowPackets(const STATMON_ENGINEDATA* pseNewData);
    VOID UpdatePageIcon(DWORD dwChangeFlags);
    VOID UpdatePageSpeed(const STATMON_ENGINEDATA* pseOldData, const STATMON_ENGINEDATA* pseNewData);
    VOID UpdatePageDuration(const STATMON_ENGINEDATA* pseOldData, const STATMON_ENGINEDATA* pseNewData);



};

class CPspSharedAccessTool : public CPspStatusMonitorTool
{
public:
    CPspSharedAccessTool();
    HRESULT HrInitToolPageType(INetConnection* pncInit);
    HRESULT HrAddCommandLineFlags(tstring* pstrFlags,
        CStatMonToolEntry* psmteSel);
    
    HRESULT HrGetDeviceType(INetConnection* pncInit);
    HRESULT HrGetComponentList(INetConnection* pncInit);
    

};
    
class CAdvIpcfgDlg : public CDialogImpl<CAdvIpcfgDlg>
{
public:

    enum { IDD = IDD_DIALOG_ADV_IPCFG };

    BEGIN_MSG_MAP(CAdvIpcfgDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CLOSE, OnClose);

        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        MESSAGE_HANDLER(PWM_UPDATE_IPCFG_DISPLAY, OnUpdateDisplay)

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel);

        NOTIFY_CODE_HANDLER(LVN_KEYDOWN, OnListKeyDown);

    END_MSG_MAP()
//
public:
    CAdvIpcfgDlg();

    ~CAdvIpcfgDlg() {}

    VOID InitDialog(const GUID & guidConnection, const DWORD * dwHelpIDs = NULL)
    {
        m_guidConnection = guidConnection;
        m_adwHelpIDs = dwHelpIDs;
    }

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnUpdateDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnListKeyDown(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
    HRESULT PopulateListControl();
    VOID AddToListControl(int iIndex, LPWSTR szFirst, LPWSTR szSecond);
    int AddIPAddrToListControl(int iStartIndex,
                            PIP_ADDR_STRING pAddrList,
                            LPWSTR pszAddrDescription,
                            LPWSTR pszMaskDescription = NULL,
                            BOOL fShowDescriptionForMutliple = FALSE
                         );
    int AddWinsServersToList(int iStartIndex);

    VOID CopyListToClipboard();

    int IPAddrToString(
                PIP_ADDR_STRING pAddrList, 
                tstring * pstrAddr, 
                tstring * pstrMask = NULL
                );
    HRESULT FormatTime(time_t t, 
                       tstring & str);


protected:
    GUID m_guidConnection;
    HWND m_hList;
    const DWORD *           m_adwHelpIDs;
};

//
//  The State page
//
class CPspStatusMonitorIpcfg: public CPropSheetPage
{
protected:

public: 
    BEGIN_MSG_MAP(CPspStatusMonitorIpcfg)

        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        MESSAGE_HANDLER(PWM_UPDATE_IPCFG_DISPLAY, OnUpdateDisplay)
        COMMAND_ID_HANDLER(IDC_STATE_BTN_REPAIR, OnRepair);
        COMMAND_ID_HANDLER(IDC_STATE_BTN_DETAIL, OnDetails);

        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)

    END_MSG_MAP()

// Message handlers
//
public:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnRepair(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDetails(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnUpdateDisplay(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    CPspStatusMonitorIpcfg();
    ~CPspStatusMonitorIpcfg();

public:
    HRESULT HrInitPage(INetConnection * pnConnection,
                       const DWORD * adwHelpIDs = NULL);

	VOID CleanupPage();

    VOID SetAsFirstPage(BOOL fFirst = TRUE)
    {
        m_fIsFirstPage = fFirst;
    }

    static DWORD WINAPI IPAddrListenProc(LPVOID lpParameter);
    static DWORD WINAPI AdvIpCfgProc(LPVOID lpParameter);

// Utility Functions
//
private:
    HRESULT GetIPConfigInfo();
    VOID InitializeData();
    VOID RefreshUI();
    VOID StopAddressListenThread();

// Internal data
//
protected:

    CAdvIpcfgDlg            m_dlgAdvanced;
    GUID                    m_guidConnection;
    tstring                 m_strConnectionName;
    tstring                 m_strIPAddress;
    tstring                 m_strSubnetMask;
    tstring                 m_strGateway;
    HANDLE                  m_hEventAddrListenThreadStopCommand;
    HANDLE                  m_hEventAddrListenThreadStopNotify;

    DHCP_ADDRESS_TYPE       m_dhcpAddrType;
    BOOL                    m_fDhcp;
    

    // initialize
    NETCON_MEDIATYPE        m_ncmType;

    const DWORD *           m_adwHelpIDs;

    INetConnection *        m_pConn;

    BOOL                    m_fListenAddrChange;
    BOOL                    m_fEnableOpButtons;

    BOOL                    m_fIsFirstPage;
    

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smhelp.h ===
#define IDH_NOHELP                  (DWORD(-1))
#define IDH_BTN_SM_TOOLS_OPEN       100000000
#define IDH_BTN_SM_SUSPEND_DEVICE   100000001
#define IDH_CMB_SM_RAS_DEVICES      100000002
#define IDH_PSB_DISCONNECT          100000003
#define IDH_PSB_PROPERTIES          100000004
#define IDH_PSB_Status              100000005
#define IDH_PSB_Duration            100000006
#define IDH_PSB_Speed               100000007
#define IDH_PSB_Bytes               100000008

#define IDH_STATE_SOURCE            100000011
#define IDH_STATE_IPADDR            100000012
#define IDH_STATE_SUBNET            100000013
#define IDH_STATE_GATEWAY           100000014
#define IDH_STATE_BTN_DETAIL        100000015
#define IDH_STATE_BTN_REPAIR        100000016

#define IDH_LIST_IPCFG              100000020

const DWORD g_aHelpIDs_IDD_STATMON_GENERAL[]=
{

    IDC_PSB_DISCONNECT, IDH_PSB_DISCONNECT,
    IDC_PSB_PROPERTIES, IDH_PSB_PROPERTIES,
    IDC_TXT_SM_STATUS_LABEL,        IDH_PSB_Status,
    IDC_TXT_SM_STATUS,              IDH_PSB_Status,
    IDC_TXT_SM_DURATION_LABEL,      IDH_PSB_Duration,
    IDC_TXT_SM_DURATION,            IDH_PSB_Duration,
    IDC_TXT_SM_SPEED_LABEL,         IDH_PSB_Speed,
    IDC_TXT_SM_SPEED,               IDH_PSB_Speed,
    IDC_TXT_SM_BYTES_LABEL,         IDH_PSB_Bytes,
    IDC_TXT_SM_BYTES_TRANS,         IDH_PSB_Bytes,
    IDC_TXT_RECEIVED_LABEL,         IDH_PSB_Bytes,
    IDC_TXT_SENT_LABEL,             IDH_PSB_Bytes,
    IDC_TXT_SM_BYTES_LABEL,         IDH_PSB_Bytes,
    IDC_TXT_SM_BYTES_RCVD,          IDH_PSB_Bytes,
    IDC_TXT_SM_COMP_TRANS,          IDH_PSB_Bytes,
    IDC_TXT_SM_COMP_RCVD,           IDH_PSB_Bytes,
    IDC_TXT_SM_ERROR_TRANS,         IDH_PSB_Bytes,
    IDC_TXT_SM_ERROR_RECV,          IDH_PSB_Bytes,
    IDC_TXT_ERROR,                  IDH_NOHELP,
    IDI_SM_STATUS_ICON,             IDH_NOHELP,
    IDC_FRM_LONG,                   IDH_NOHELP,
    IDC_FRM_SHORT,                  IDH_NOHELP,
    IDC_FRM_LEFT,                   IDH_NOHELP,
    IDC_FRM_RIGHT,                  IDH_NOHELP,
    IDC_TXT_SAINTERNET_LABEL,       IDH_NOHELP,
    IDC_TXT_SAGATEWAY_LABEL,        IDH_NOHELP,
    IDC_TXT_SACOMPUTER_LABEL,       IDH_NOHELP,
    IDC_ICON_SAINTERNET,            IDH_NOHELP,
    IDC_ICON_SAGATEWAY,             IDH_NOHELP,
    IDC_TXT_CPMPRESSION_LABEL,      IDH_NOHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_STATMON_RAS[]=
{

    IDC_CMB_SM_RAS_DEVICES,         IDH_CMB_SM_RAS_DEVICES,
    IDC_BTN_SM_SUSPEND_DEVICE,      IDH_BTN_SM_SUSPEND_DEVICE,
    IDC_TXT_SM_NUM_DEVICES,         IDH_NOHELP,
    IDC_TXT_SM_NUM_DEVICES_VAL,     IDH_NOHELP,
    IDC_LVW_RAS_PROPERTY,           IDH_NOHELP,

    0, 0
};

const DWORD g_aHelpIDs_IDD_STATMON_TOOLS[]=
{

    IDC_BTN_SM_TOOLS_OPEN,      IDH_BTN_SM_TOOLS_OPEN,
    IDC_LST_SM_TOOLS,           IDH_NOHELP,
    IDC_TXT_SM_TOOL_MAN,        IDH_NOHELP,
    IDC_TXT_SM_TOOL_DESC,       IDH_NOHELP,
    IDC_TXT_SM_TOOL_COMMAND,    IDH_NOHELP,
    IDC_TXT_TOOLS_LABEL,        IDH_NOHELP,
    IDC_TXT_MANUFACTURER_LABEL, IDH_NOHELP,
    IDC_TXT_COMMANDLINE_LABEL,  IDH_NOHELP,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PROPPAGE_IPCFG[]=
{
    IDC_STATE_STATIC_GROUP,     IDH_NOHELP,  
    IDC_STATIC_STATE_SOURCE,    IDH_STATE_SOURCE,       
    IDC_STATE_SOURCE,           IDH_STATE_SOURCE,       
    IDC_STATIC_STATE_IPADDR,    IDH_STATE_IPADDR,       
    IDC_STATE_IPADDR,           IDH_STATE_IPADDR,       
    IDC_STATIC_STATE_SUBNET,    IDH_STATE_SUBNET,       
    IDC_STATE_SUBNET,           IDH_STATE_SUBNET,       
    IDC_STATIC_STATE_GATEWAY,   IDH_STATE_GATEWAY,      
    IDC_STATE_GATEWAY,          IDH_STATE_GATEWAY,      
    IDC_STATE_BTN_DETAIL,       IDH_STATE_BTN_DETAIL,   
    IDC_STATE_BTN_REPAIR,       IDH_STATE_BTN_REPAIR,   
    0, 0
};

const DWORD g_aHelpIDs_IDD_DIALOG_ADV_IPCFG[]=
{
    IDC_LIST_IPCFG, IDH_LIST_IPCFG,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smras.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S M R A S . C P P
//
//  Contents:   The RAS engine that provides statistics to the status monitor
//
//  Notes:
//
//  Author:     CWill   12/02/1997
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "ncras.h"
#include "sminc.h"
#include "netcon.h"
#include "smpsh.h"

#include "mprapi.h"



//+---------------------------------------------------------------------------
//
//  Member:     CRasStatEngine::CRasStatEngine
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CRasStatEngine::CRasStatEngine() :
    m_hRasConn(NULL)
{
    m_ncmType = NCM_PHONE;
    m_dwCharacter = NCCF_OUTGOING_ONLY;
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasStatEngine::put_RasConn
//
//  Purpose:    Pass handles to the RAS engine
//
//  Arguments:  hRasConn - The handle being set
//
//  Returns:    Error code
//
VOID CRasStatEngine::put_RasConn(HRASCONN hRasConn)
{
    AssertSz(hRasConn, "We should have a hRasConn");
    m_hRasConn = hRasConn;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasStatEngine::put_MediaType
//
//  Purpose:    Pass media type of RAS connection type to the RAS engine
//
//  Arguments:  ncmType  - NETCON_MEDIATYPE being set
//              ncsmType - NETCON_SUBMEDIATYPE being set
//
//  Returns:
//
VOID CRasStatEngine::put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType)
{
    m_ncmType   = ncmType;
    m_ncsmType  = ncsmType;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasStatEngine::put_Character
//
//  Purpose:    Character of RAS connection
//
//  Arguments:  dwCharacter - The character being set
//
//  Returns:
//
VOID CRasStatEngine::put_Character(DWORD dwCharacter)
{
    m_dwCharacter = dwCharacter;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRasStatEngine::HrUpdateData
//
//  Purpose:    Get new statistics from the devices.  This data is used to be
//              displayed in the UI.
//
//  Arguments:  pdwChangeFlags -    Where to return for statistics
//
//  Returns:    Error code
//
HRESULT
CRasStatEngine::HrUpdateData (
    DWORD* pdwChangeFlags,
    BOOL*  pfNoLongerConnected)
{
    HRESULT         hr          = S_OK;

    // Initialize the output parameters.
    //
    if (pdwChangeFlags)
    {
        *pdwChangeFlags = SMDCF_NULL;
    }

    *pfNoLongerConnected = FALSE;

    CExceptionSafeComObjectLock EsLock(this);

    // Get a pointer to the elements of the array.
    //
    if (m_dwCharacter & NCCF_OUTGOING_ONLY)
    {
        // Get the status of the connection.
        //
        NETCON_STATUS ncs;
        hr = HrRasGetNetconStatusFromRasConnectStatus (
                m_hRasConn, &ncs);

        // Make sure we have a statistics structure
        //
        EnterCriticalSection(&g_csStatmonData);

        if (!m_psmEngineData)
        {
            m_psmEngineData = new STATMON_ENGINEDATA;

            if (m_psmEngineData)
            {
                ZeroMemory(m_psmEngineData, sizeof(STATMON_ENGINEDATA));
            }
        }

        // Set the status
        //
        if (m_psmEngineData)
        {
            if (SUCCEEDED(hr) && (NCS_DISCONNECTED != ncs))
            {
                m_psmEngineData->SMED_CONNECTIONSTATUS = ncs;
            }
            else if (HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE) == hr)
            {
                *pfNoLongerConnected = TRUE;

                // set the connection status to "disconnected" so we can close the UI
                m_psmEngineData->SMED_CONNECTIONSTATUS = NCS_DISCONNECTED;

                hr = S_OK;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        LeaveCriticalSection(&g_csStatmonData);

        if ((m_psmEngineData) && SUCCEEDED(hr) && (NCS_DISCONNECTED != ncs))
        {
            // Retrieve the statistics of the connection
            //
            RAS_STATS   rsNewData;
            rsNewData.dwSize = sizeof(RAS_STATS);
            DWORD dwErr = RasGetConnectionStatistics(m_hRasConn, &rsNewData);
            hr = HRESULT_FROM_WIN32 (dwErr);
            TraceError ("RasGetConnectionStatistics", hr);

            if (SUCCEEDED(hr))
            {
                // Update the change flags if asked for
                //
                if (pdwChangeFlags)
                {
                    if (m_psmEngineData->SMED_PACKETSTRANSMITTING
                            != rsNewData.dwFramesXmited)
                    {
                        *pdwChangeFlags |= SMDCF_TRANSMITTING;
                    }

                    if (m_psmEngineData->SMED_PACKETSRECEIVING
                            != rsNewData.dwFramesRcved)
                    {
                        *pdwChangeFlags |= SMDCF_RECEIVING;
                    }
                }

                // Get the rest of the data
                //
                m_psmEngineData->SMED_DURATION  = rsNewData.dwConnectDuration/1000;

                // Don't pass out speed info for VPN connections (294953)
                if (NCM_TUNNEL != m_ncmType)
                {
                    m_psmEngineData->SMED_SPEEDTRANSMITTING         = rsNewData.dwBps;
                    m_psmEngineData->SMED_SPEEDRECEIVING            = rsNewData.dwBps;
                }

                m_psmEngineData->SMED_BYTESTRANSMITTING         = rsNewData.dwBytesXmited;
                m_psmEngineData->SMED_BYTESRECEIVING            = rsNewData.dwBytesRcved;

                m_psmEngineData->SMED_COMPRESSIONTRANSMITTING   = rsNewData.dwCompressionRatioOut;
                m_psmEngineData->SMED_COMPRESSIONRECEIVING      = rsNewData.dwCompressionRatioIn;

                m_psmEngineData->SMED_ERRORSTRANSMITTING        = 0;
                m_psmEngineData->SMED_ERRORSRECEIVING           = rsNewData.dwCrcErr +
                                                                   rsNewData.dwTimeoutErr +
                                                                   rsNewData.dwAlignmentErr +
                                                                   rsNewData.dwHardwareOverrunErr +
                                                                   rsNewData.dwFramingErr +
                                                                   rsNewData.dwBufferOverrunErr;

                m_psmEngineData->SMED_PACKETSTRANSMITTING       = rsNewData.dwFramesXmited;
                m_psmEngineData->SMED_PACKETSRECEIVING          = rsNewData.dwFramesRcved;

                HrGetAutoNetSetting(m_guidId, &(m_psmEngineData->SMED_DHCP_ADDRESS_TYPE) );
                m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NOT_SUPPORTED;
            }
        }
    }
    else if (m_dwCharacter & NCCF_INCOMING_ONLY)
    {
        // RAS inbound connection
        EnterCriticalSection(&g_csStatmonData);

        if (!m_psmEngineData)
        {
            m_psmEngineData = new STATMON_ENGINEDATA;
            if(m_psmEngineData) 
            {
                ZeroMemory(m_psmEngineData, sizeof(STATMON_ENGINEDATA));
            }
        }

        // Set the status
        //
        if (m_psmEngineData)
        {
            // Set the status to connected by default
            // Unless we get ERROR_INVALID_PARAMETER on any of the function calls below
            //
            m_psmEngineData->SMED_CONNECTIONSTATUS = NCS_CONNECTED;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        LeaveCriticalSection(&g_csStatmonData);

        if (SUCCEEDED(hr) && m_psmEngineData)
        {
            // Get the server handle
            //
            RAS_SERVER_HANDLE hMprAdmin;
            DWORD dwError = MprAdminServerConnect(NULL, &hMprAdmin);

            if (dwError == NO_ERROR)
            {
                // Get connection duration
                //
                RAS_CONNECTION_0 * pConn0;
                dwError = MprAdminConnectionGetInfo(hMprAdmin,
                                                    0,
                                                    m_hRasConn,
                                                    (LPBYTE*)&pConn0);
                if (dwError == NO_ERROR)
                {
                    // duration needs to be in milliseconds
                    m_psmEngineData->SMED_DURATION  = pConn0->dwConnectDuration;

                    MprAdminBufferFree(pConn0);

                    // Get connection speed

                    // Don't pass out speed info for VPN connections (357758)
                    if (NCM_TUNNEL != m_ncmType)
                    {
                        // Enum all the ports and add up the link speed
                        //
                        RAS_PORT_0 * pPort0;
                        DWORD dwPortCount;
                        DWORD dwTotalEntries;
    
                        dwError = MprAdminPortEnum (hMprAdmin,
                                                    0,
                                                    m_hRasConn,
                                                    (LPBYTE*)&pPort0,
                                                    -1,
                                                    &dwPortCount,
                                                    &dwTotalEntries,
                                                    NULL);
                        if (dwError == NOERROR)
                        {
                            RAS_PORT_0 * pCurPort0 = pPort0;
                            DWORD dwConnSpeed=0;
    
                            while (dwPortCount)
                            {
                                RAS_PORT_1 * pCurPort1;
                                dwError = MprAdminPortGetInfo(hMprAdmin,
                                                              1,
                                                              pCurPort0->hPort,
                                                              (LPBYTE*)&pCurPort1);
                                if (dwError == NO_ERROR)
                                {
                                    dwConnSpeed += pCurPort1->dwLineSpeed;
                                }
                                else
                                {
                                    break;
                                }
    
                                MprAdminBufferFree(pCurPort1);
    
                                dwPortCount--;
                                pCurPort0++;
                            }
    
                            MprAdminBufferFree(pPort0);
    
                            if (dwError == NO_ERROR)
                            {
                                // Get the accumulated connection speed
                                m_psmEngineData->SMED_SPEEDTRANSMITTING = dwConnSpeed;
                                m_psmEngineData->SMED_SPEEDRECEIVING    = dwConnSpeed;
                            }
                        }
                    }

                    if (dwError == NO_ERROR)
                    {
                        // Get Transmitted\Received Bytes, Compression and Bytes
                        RAS_CONNECTION_1 * pConn1;
                        dwError = MprAdminConnectionGetInfo(hMprAdmin,
                                                            1,
                                                            m_hRasConn,
                                                            (LPBYTE*)&pConn1);
                        if (dwError == NO_ERROR)
                        {
                            // Update the change flags if asked for
                            //
                            if (pdwChangeFlags)
                            {
                                if (m_psmEngineData->SMED_BYTESTRANSMITTING
                                        != pConn1->dwBytesXmited)
                                {
                                    *pdwChangeFlags |= SMDCF_TRANSMITTING;
                                }

                                if (m_psmEngineData->SMED_BYTESRECEIVING
                                        != pConn1->dwBytesRcved)
                                {
                                    *pdwChangeFlags |= SMDCF_RECEIVING;
                                }
                            }

                            m_psmEngineData->SMED_BYTESTRANSMITTING         = pConn1->dwBytesXmited;
                            m_psmEngineData->SMED_BYTESRECEIVING            = pConn1->dwBytesRcved;

                            m_psmEngineData->SMED_COMPRESSIONTRANSMITTING   = pConn1->dwCompressionRatioOut;
                            m_psmEngineData->SMED_COMPRESSIONRECEIVING      = pConn1->dwCompressionRatioIn;

                            m_psmEngineData->SMED_ERRORSTRANSMITTING        = 0;
                            m_psmEngineData->SMED_ERRORSRECEIVING           = pConn1->dwCrcErr +
                                                                              pConn1->dwTimeoutErr +
                                                                              pConn1->dwAlignmentErr +
                                                                              pConn1->dwHardwareOverrunErr +
                                                                              pConn1->dwFramingErr +
                                                                              pConn1->dwBufferOverrunErr;
                        }

                        MprAdminBufferFree(pConn1);
                    }
                }

                if (dwError != NO_ERROR)
                {
                    *pfNoLongerConnected = TRUE;

                    // set the connection status to "disconnected" so we can close the UI
                    m_psmEngineData->SMED_CONNECTIONSTATUS = NCS_DISCONNECTED;

                    hr = S_OK;
                }
            }
            MprAdminServerDisconnect (hMprAdmin);
        }
    }

    TraceError("CRasStatEngine::HrUpdateData", hr);
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspRasGen                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

CPspRasGen::CPspRasGen(VOID)
{
    m_ncmType = NCM_PHONE;
    m_dwCharacter = NCCF_OUTGOING_ONLY;

    m_adwHelpIDs = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspRasGen::put_MediaType
//
//  Purpose:    Pass media type of RAS connection type to the RAS engine
//
//  Arguments:  ncmType  - NETCON_MEDIATYPE being set
//              ncsmType - NETCON_SUBMEDIATYPE being set
//
//  Returns:
//
VOID CPspRasGen::put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType)
{
    m_ncmType  = ncmType;
    m_ncsmType = ncsmType;
}

VOID CPspRasGen::put_Character(DWORD dwCharacter)
{
    m_dwCharacter = dwCharacter;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspRasTool                                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////



CPspRasTool::CPspRasTool(VOID)
{
    m_ncmType = NCM_PHONE;
    m_dwCharacter = NCCF_OUTGOING_ONLY;

    m_adwHelpIDs = NULL;
}

VOID CPspRasTool::put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType)
{
    m_ncmType = ncmType;
    m_ncsmType = ncsmType;
}

VOID CPspRasTool::put_Character(DWORD dwCharacter)
{
    m_dwCharacter = dwCharacter;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspRasTool::HrInitToolPageType
//
//  Purpose:    Gets from the connection any information that is relevant to
//              this particular connection type.
//
//  Arguments:  pncInit -   The connection assocatied with this dialog
//
//  Returns:    Error code
//
HRESULT CPspRasTool::HrInitToolPageType(INetConnection* pncInit)
{
    HRESULT hr  = S_OK;

    TraceError("CPspRasTool::HrInitToolPageType", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CPspRasTool::HrAddCommandLineFlags
//
//  Purpose:    Adds the flags for this selection to the command line for the
//              tool being launched.
//
//  Arguments:  pstrFlags - The command line that the flags have to be
//                      appended to
//              psmteSel    - The tool entry associated with this selection
//
//  Returns:    Error code
//
HRESULT CPspRasTool::HrAddCommandLineFlags(tstring* pstrFlags,
        CStatMonToolEntry* psmteSel)
{
    HRESULT hr  = S_OK;

    //
    //  Check what flags are asked for and provide them if we can
    //

    TraceError("CPspRasTool::HrAddCommandLineFlags", hr);
    return hr;
}

HRESULT CPspRasTool::HrGetDeviceType(INetConnection* pncInit)
{
    HRESULT hr = S_OK;

    RASCONN*    aRasConn;
    DWORD       cRasConn;
    hr = HrRasEnumAllActiveConnections (
                    &aRasConn,
                    &cRasConn);

    if (SUCCEEDED(hr))
    {
        for (DWORD i = 0; i < cRasConn; i++)
        {
            if (m_guidId == aRasConn[i].guidEntry)
            {
                // Note: device types in RAS connections are defined
                // as follows in public\sdk\inc ras.h as RASDT_XXX

                m_strDeviceType = aRasConn[i].szDeviceType;
                break;
            }
        }
        MemFree (aRasConn);
    }

    return S_OK;
}

HRESULT CPspRasTool::HrGetComponentList(INetConnection* pncInit)
{
    // Obtain ras handle to this connection
    HRESULT     hr  = S_OK;
    HRASCONN    hRasConn = NULL;

    if (m_dwCharacter & NCCF_OUTGOING_ONLY)
    {
        // for outgoing connection
        INetRasConnection*  pnrcNew     = NULL;

        hr = HrQIAndSetProxyBlanket(pncInit, &pnrcNew);
        if (SUCCEEDED(hr))
        {
            hr = pnrcNew->GetRasConnectionHandle(
                        reinterpret_cast<ULONG_PTR*>(&hRasConn));
            ReleaseObj(pnrcNew);
        }
    }
    else if (m_dwCharacter & NCCF_INCOMING_ONLY)
    {
        // for incoming connection
        INetInboundConnection*  pnicNew;

        hr = HrQIAndSetProxyBlanket(pncInit, &pnicNew);

        if (SUCCEEDED(hr))
        {
            hr = pnicNew->GetServerConnectionHandle(
                    reinterpret_cast<ULONG_PTR*>(&hRasConn));

            ReleaseObj(pnicNew);
        }
    }

    if (SUCCEEDED(hr) && hRasConn)
    {
        // Get protocols list
        DWORD   dwRetCode;
        DWORD   dwSize;

        // RASP_PppIp
        RASPPPIP    RasPppIp;
        RasPppIp.dwSize = sizeof( RasPppIp );

        dwSize = sizeof( RasPppIp );

        dwRetCode = RasGetProjectionInfo (hRasConn, RASP_PppIp, &RasPppIp, &dwSize);
        if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasPppIp.dwError))
        {
            m_lstpstrCompIds.push_back(new tstring(L"MS_TCPIP"));
        }

        // RASP_PppIpx
        RASPPPIPX    RasPppIpx;
        RasPppIpx.dwSize = sizeof( RasPppIpx );

        dwSize = sizeof( RasPppIpx );

        dwRetCode = RasGetProjectionInfo (hRasConn, RASP_PppIpx, &RasPppIpx, &dwSize);
        if ((dwRetCode == NO_ERROR)  && (NO_ERROR == RasPppIpx.dwError))
        {
            m_lstpstrCompIds.push_back(new tstring(L"MS_NWIPX"));
        }

        // RASP_PppNbf
        RASPPPNBF    RasPppNbf;
        RasPppNbf.dwSize = sizeof( RasPppNbf );

        dwSize = sizeof( RasPppNbf );

        dwRetCode = RasGetProjectionInfo (hRasConn, RASP_PppNbf, &RasPppNbf, &dwSize);
        if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasPppNbf.dwError))
        {
            m_lstpstrCompIds.push_back(new tstring(L"MS_NetBEUI"));
        }

        // RASP_Slip
        RASSLIP    RasSlip;
        RasSlip.dwSize = sizeof( RasSlip );

        dwSize = sizeof( RasSlip );

        dwRetCode =  RasGetProjectionInfo (hRasConn, RASP_Slip, &RasSlip, &dwSize);
        if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasSlip.dwError))
        {
            m_lstpstrCompIds.push_back(new tstring(L"MS_TCPIP"));
        }
    }

    // Get client and services
    // $REVIEW(tongl 10/19): checked with Rao, for now we hard code
    // using MSClient and F&P services for all RAS connections
    // (raid #132575)
    m_lstpstrCompIds.push_back(new tstring(L"MS_MSCLIENT"));
    m_lstpstrCompIds.push_back(new tstring(L"MS_SERVER"));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smlan.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S M L A N . C P P
//
//  Contents:   The LAN engine that provides statistics to the status monitor
//
//  Notes:
//
//  Author:     CWill   12/02/1997
//
//----------------------------------------------------------------------------


#include "pch.h"
#pragma hdrstop
#include "sminc.h"
#include "smpsh.h"

#include "ndispnp.h"
#include "ntddndis.h"
#include "ncnetcfg.h"
#include "..\\folder\\cfutils.h"
#include "..\\folder\\shutil.h"
#include "naming.h"

//
//  External data
//

extern const WCHAR          c_szDevice[];
extern const WCHAR          c_szSpace[];
extern SM_TOOL_FLAGS        g_asmtfMap[];
extern WCHAR                c_szCmdLineFlagPrefix[];

const ULONG c_aulConStateMap[] =
{
    NCS_DISCONNECTED,
    NCS_CONNECTED
};

//+---------------------------------------------------------------------------
//
//  Member:     CLanStatEngine::CLanStatEngine
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CLanStatEngine::CLanStatEngine(VOID)
{
    m_ncmType = NCM_LAN;
    m_ncsmType = NCSM_LAN;
    m_dwCharacter = 0;

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanStatEngine::HrUpdateData
//
//  Purpose:    Get new statistics from the devices.  This data is used to be
//              displayed in the UI.
//
//  Arguments:  pdwChangeFlags -    Where to modify the changed flags.  This
//                      param may be NULL.
//
//  Returns:    Error code
//
HRESULT
CLanStatEngine::HrUpdateData (
    DWORD* pdwChangeFlags,
    BOOL*  pfNoLongerConnected)
{
    HRESULT hr  = S_OK;

    // Initialize the output parameter.
    //
    *pfNoLongerConnected = FALSE;

    UINT            uiRet           = 0;
    NIC_STATISTICS  nsNewLanStats   = { 0 };

    // Prime the structure
    //
    nsNewLanStats.Size = sizeof(NIC_STATISTICS);

    // Retrieve the statistics
    //
    uiRet = ::NdisQueryStatistics(&m_ustrDevice, &nsNewLanStats);

    EnterCriticalSection(&g_csStatmonData);

    // Make sure we have a statistics structure
    //
    if (!m_psmEngineData)
    {
        m_psmEngineData = new STATMON_ENGINEDATA;
        if (m_psmEngineData)
        {
            ZeroMemory(m_psmEngineData, sizeof(STATMON_ENGINEDATA));
        }
    }

    if (m_psmEngineData)
    {
        if (uiRet && (MEDIA_STATE_DISCONNECTED != nsNewLanStats.MediaState))
        {
            AssertSz((c_aulConStateMap[MEDIA_STATE_DISCONNECTED] == NCS_DISCONNECTED)
                && (c_aulConStateMap[MEDIA_STATE_CONNECTED] == NCS_CONNECTED),
                    "Someone is messing around with NETCON_STATUS values");

            // Update the change flags if asked for
            //
            if (pdwChangeFlags)
            {
                *pdwChangeFlags = SMDCF_NULL;

                // Bytes Transmitting
                //
                if (m_psmEngineData->SMED_PACKETSTRANSMITTING
                        != nsNewLanStats.PacketsSent)
                {
                    *pdwChangeFlags |= SMDCF_TRANSMITTING;
                }

                // Bytes Received
                //
                if (m_psmEngineData->SMED_PACKETSRECEIVING
                        != nsNewLanStats.DirectedPacketsReceived)
                {
                    *pdwChangeFlags |= SMDCF_RECEIVING;
                }
            }

            // No Compression on LAN devices
            //
            m_psmEngineData->SMED_COMPRESSIONTRANSMITTING   = 0;
            m_psmEngineData->SMED_COMPRESSIONRECEIVING      = 0;

            //
            // Update the LAN statistics
            //

            // LinkSpeed is in 100 bps
            //
            m_psmEngineData->SMED_SPEEDTRANSMITTING         = nsNewLanStats.LinkSpeed * 100;
            m_psmEngineData->SMED_SPEEDRECEIVING            = nsNewLanStats.LinkSpeed * 100;

            Assert((nsNewLanStats.MediaState == MEDIA_STATE_CONNECTED) ||
                   (nsNewLanStats.MediaState == MEDIA_STATE_DISCONNECTED));
            m_psmEngineData->SMED_CONNECTIONSTATUS          = c_aulConStateMap[nsNewLanStats.MediaState];

            m_psmEngineData->SMED_DURATION                  = nsNewLanStats.ConnectTime;
            m_psmEngineData->SMED_BYTESTRANSMITTING         = nsNewLanStats.BytesSent;
            m_psmEngineData->SMED_BYTESRECEIVING            = nsNewLanStats.DirectedBytesReceived;
            m_psmEngineData->SMED_ERRORSTRANSMITTING        = nsNewLanStats.PacketsSendErrors;
            m_psmEngineData->SMED_ERRORSRECEIVING           = nsNewLanStats.PacketsReceiveErrors;
            m_psmEngineData->SMED_PACKETSTRANSMITTING       = nsNewLanStats.PacketsSent;
            m_psmEngineData->SMED_PACKETSRECEIVING          = nsNewLanStats.DirectedPacketsReceived;

            HrGetAutoNetSetting(m_guidId, &(m_psmEngineData->SMED_DHCP_ADDRESS_TYPE) );
            m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NOT_SUPPORTED;

            if (IsMediaWireless(NCM_LAN, m_guidId))
            {
                DWORD dwInfraStructureMode;
                DWORD dwInfraStructureModeSize = sizeof(DWORD);
                HRESULT hrT = HrQueryNDISAdapterOID(m_guidId, 
                                          OID_802_11_INFRASTRUCTURE_MODE, 
                                          &dwInfraStructureModeSize,
                                          &dwInfraStructureMode);
                if (SUCCEEDED(hrT))
                {
                    switch (dwInfraStructureMode)
                    {
                    case Ndis802_11IBSS:
                        m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NDIS802_11IBSS;
                        break;
                    case Ndis802_11Infrastructure:
                        m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NDIS802_11INFRASTRUCTURE;
                        break;
                    case Ndis802_11AutoUnknown:
                        m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NDIS802_11AUTOUNKNOWN;
                        break;
                    default:
                        m_psmEngineData->SMED_INFRASTRUCTURE_MODE = IM_NOT_SUPPORTED;
                    }
                }


                NDIS_802_11_SSID ndisSSID;
                DWORD dwndisSSIDSize = sizeof(NDIS_802_11_SSID);
                hrT = HrQueryNDISAdapterOID(m_guidId, 
                                          OID_802_11_SSID, 
                                          &dwndisSSIDSize,
                                          &ndisSSID);

                if (SUCCEEDED(hrT))
                {
                    if (ndisSSID.SsidLength > 1)
                    {
                        DWORD dwLen = ndisSSID.SsidLength;
                        if (dwLen > sizeof(ndisSSID.Ssid))
                        {
                            dwLen = sizeof(ndisSSID.Ssid);
                            AssertSz(FALSE, "Unexpected SSID encountered");
                        }

                        ndisSSID.Ssid[dwLen] = 0;
                        mbstowcs(m_psmEngineData->SMED_802_11_SSID, reinterpret_cast<LPSTR>(ndisSSID.Ssid), celems(m_psmEngineData->SMED_802_11_SSID));
                    }
                }
                
                DWORD dwWepStatus;
                DWORD dwWepStatusSize = sizeof(DWORD);
                hrT = HrQueryNDISAdapterOID(m_guidId, 
                                          OID_802_11_WEP_STATUS, 
                                          &dwWepStatusSize,
                                          &dwWepStatus);
                if (SUCCEEDED(hrT))
                {
                    if (Ndis802_11WEPEnabled == dwWepStatus)
                    {
                        m_psmEngineData->SMED_802_11_ENCRYPTION_ENABLED = TRUE;
                    }
                }
                
                LONG lSignalStrength;
                DWORD dwSignalStrengthSize = sizeof(DWORD);
                hrT = HrQueryNDISAdapterOID(m_guidId, 
                                          OID_802_11_RSSI, 
                                          &dwSignalStrengthSize,
                                          &lSignalStrength);
                if (SUCCEEDED(hrT))
                {
                    m_psmEngineData->SMED_802_11_SIGNAL_STRENGTH = lSignalStrength;
                }
            }
        }
        else
        {
            *pfNoLongerConnected = TRUE;

            // set the connection status to "disconnected" so we can close the UI
            m_psmEngineData->SMED_CONNECTIONSTATUS = c_aulConStateMap[NCS_DISCONNECTED];

            if (!uiRet)
            {
                TraceTag(ttidStatMon,
                    "NdisQueryStatistics failed on %S. err=%u. "
                    "Treating as disconnected.",
                    m_strDevice.c_str(),
                    GetLastError ());
            }
            else
            {
                TraceTag(ttidStatMon,
                    "NdisQueryStatistics returned MediaState = MEDIA_STATE_DISCONNECTED on %S.",
                    m_strDevice.c_str());
            }

            hr = S_OK;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    LeaveCriticalSection(&g_csStatmonData);

    TraceError("CLanStatEngine::HrUpdateData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanStatEngine::put_Device
//
//  Purpose:    Sets the device that is associated with this device
//
//  Arguments:  pstrDevice -    The name of the device
//
//  Returns:    Error code.
//
HRESULT CLanStatEngine::put_Device(tstring* pstrDevice)
{
    HRESULT     hr  = S_OK;

    // Set the new device name
    if (pstrDevice)
    {
        CExceptionSafeComObjectLock  EsLock(this);

        // Remember the name
        m_strDevice = *pstrDevice;

        // Make sure we have a nice UNICODE string as well
        ::RtlInitUnicodeString(&m_ustrDevice, m_strDevice.c_str());
    }
    else
    {
        hr = E_POINTER;
    }

    TraceError("CLanStatEngine::put_Device", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLanStatEngine::put_MediaType
//
//  Purpose:    Pass media type of LAN connection type to the LAN engine
//
//  Arguments:  ncmType  - NETCON_MEDIATYPE being set
//              ncsmType - NETCON_SUBMEDIATYPE being set
//
//  Returns:
//
VOID CLanStatEngine::put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType)
{
    m_ncmType   = ncmType;
    m_ncsmType  = ncsmType;
}

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspLanGen                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

CPspLanGen::CPspLanGen(VOID)
{
    m_ncmType = NCM_LAN;
    m_ncsmType = NCSM_LAN;
    m_dwCharacter =0;
    m_adwHelpIDs = NULL;

    return;
}


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspLanGen                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID CPspLanGen::put_MediaType(NETCON_MEDIATYPE ncmType, NETCON_SUBMEDIATYPE ncsmType)
{
    m_ncmType = ncmType;
    m_ncsmType = ncsmType;

    return;
}


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  CPspLanTool                                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

CPspLanTool::CPspLanTool(VOID)
{
    m_ncmType = NCM_LAN;
    m_ncsmType = NCSM_LAN;
    m_dwCharacter = 0;

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspLanTool::HrInitToolPageType
//
//  Purpose:    Gets from the connection any information that is relevant to
//              this particular connection type.
//
//  Arguments:  pncInit -   The connection assocatied with this dialog
//
//  Returns:    Error code
//
HRESULT CPspLanTool::HrInitToolPageType(INetConnection* pncInit)
{
    HRESULT hr  = S_OK;

    INetLanConnection*  pnlcInit = NULL;

    // Get some LAN specific info
    //
    hr = HrQIAndSetProxyBlanket(pncInit, &pnlcInit);
    if (SUCCEEDED(hr))
    {
        GUID    guidDevice  = { 0 };

        // Find the component's GUID
        //
        hr = pnlcInit->GetDeviceGuid(&guidDevice);
        if (SUCCEEDED(hr))
        {
            WCHAR   achGuid[c_cchGuidWithTerm];

            // Make the device name
            //
            ::StringFromGUID2(guidDevice, achGuid,
                    c_cchGuidWithTerm);

            m_strDeviceName = c_szDevice;
            m_strDeviceName.append(achGuid);
        }

        ::ReleaseObj(pnlcInit);
    }

    TraceError("CPspLanTool::HrInitToolPageType", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CPspLanTool::HrAddCommandLineFlags
//
//  Purpose:    Adds the flags for this selection to the command line for the
//              tool being launched.
//
//  Arguments:  pstrFlags - The command line that the flags have to be
//                      appended to
//              psmteSel    - The tool entry associated with this selection
//
//  Returns:    Error code
//
HRESULT CPspLanTool::HrAddCommandLineFlags(tstring* pstrFlags,
        CStatMonToolEntry* psmteSel)
{
    HRESULT hr  = S_OK;
    DWORD   dwFlags = 0x0;

    // Same some indirections
    //
    dwFlags = psmteSel->dwFlags;

    //
    //  Check what flags are asked for and provide them if we can
    //

    if (SCLF_ADAPTER & dwFlags)
    {
        pstrFlags->append(c_szCmdLineFlagPrefix);
        pstrFlags->append(g_asmtfMap[STFI_ADAPTER].pszFlag);
        pstrFlags->append(c_szSpace);
        pstrFlags->append(m_strDeviceName);
    }

    TraceError("CPspStatusMonitorTool::HrAddCommandLineFlags", hr);
    return hr;
}

HRESULT CPspLanTool::HrGetDeviceType(INetConnection* pncInit)
{
    TraceFileFunc(ttidStatMon);
    
    UINT            uiRet           = 0;
    NIC_STATISTICS  nsLanStats   = { 0 };

    // Set the default type
    m_strDeviceType = L"Ethernet";

    // Prime the structure
    //
    nsLanStats.Size = sizeof(NIC_STATISTICS);

    // Retrieve the statistics
    //
    WCHAR   szDeviceGuid[c_cchGuidWithTerm];
    ::StringFromGUID2(m_guidId, szDeviceGuid, c_cchGuidWithTerm);

    tstring strDeviceName = c_szDevice;
    strDeviceName.append(szDeviceGuid);

    UNICODE_STRING  ustrDevice;
    ::RtlInitUnicodeString(&ustrDevice, strDeviceName.c_str());

    uiRet = ::NdisQueryStatistics(&ustrDevice, &nsLanStats);

    if (uiRet)
    {
        switch(nsLanStats.MediaType)
        {
        case NdisMedium802_3:
            TraceTag(ttidStatMon, "Medium type: NdisMedium802_3 - Ethernet");
            m_strDeviceType = L"Ethernet";
            break;

        case NdisMedium802_5:
            TraceTag(ttidStatMon, "Medium type: NdisMedium802_5 - Token Ring");
            m_strDeviceType = L"Token ring";
            break;

        case NdisMediumFddi:
            TraceTag(ttidStatMon, "Medium type: NdisMediumFddi - FDDI");
            m_strDeviceType = L"FDDI";
            break;

        case NdisMediumLocalTalk:
            TraceTag(ttidStatMon, "Medium type: NdisMediumLocalTalk - Local Talk");
            m_strDeviceType = L"Local Talk";
            break;

        case NdisMediumAtm:
            TraceTag(ttidStatMon, "Medium type: NdisMediumAtm - Atm");
            m_strDeviceType = L"Atm";
            break;

        case NdisMediumIrda:
            TraceTag(ttidStatMon, "Medium type: NdisMediumIrda - IRDA");
            m_strDeviceType = L"IRDA";
            break;

        case NdisMediumBpc:
            TraceTag(ttidStatMon, "Medium type: NdisMediumBpc - BPC");
            m_strDeviceType = L"BPC";
            break;

        case NdisMediumArcnetRaw:
            TraceTag(ttidStatMon, "Medium type: NdisMediumArcnetRaw - ArcnetRaw");
            m_strDeviceType = L"ArcnetRaw";
            break;

        case NdisMediumArcnet878_2:
            TraceTag(ttidStatMon, "Medium type: NdisMediumArcnet878_2 - MediumArcnet878_2");
            m_strDeviceType = L"MediumArcnet878_2";
            break;

        case NdisMediumWirelessWan:
            TraceTag(ttidStatMon, "Medium type: NdisMediumWirelessWan - WirelessWan");
            m_strDeviceType = L"WirelessWan";
            break;

        case NdisMediumWan:
            TraceTag(ttidStatMon, "Medium type: NdisMediumWan - Wan");
            m_strDeviceType = L"Wan";
            break;

        case NdisMediumCoWan:
            TraceTag(ttidStatMon, "Medium type: NdisMediumCoWan - CoWan");
            m_strDeviceType = L"CoWan";
            break;

        case NdisMediumMax:
            TraceTag(ttidStatMon, "Not real medium type ??? NdisMediumMax");
            break;

        case NdisMediumDix:
            TraceTag(ttidStatMon, "Not real medium type ??? NdisMediumDix");
            break;

        default:
            TraceTag(ttidStatMon, "Unknown medium type ??? %d", nsLanStats.MediaType);
            break;
        }
    }

    return S_OK;
}

HRESULT CPspLanTool::HrGetComponentList(INetConnection* pncInit)
{
    // Get a readonly INetCfg, enumerate components bound to this adapter
    HRESULT   hr = S_OK;
    INetCfg * pNetCfg = NULL;
    PWSTR    pszClientDesc = NULL;

    BOOL      fInitCom = TRUE;
    BOOL      fWriteLock = FALSE;

    // Get a read-only INetCfg
    hr = HrCreateAndInitializeINetCfg(&fInitCom, &pNetCfg, fWriteLock, 0,
                                      SzLoadIds(IDS_STATMON_CAPTION),
                                      &pszClientDesc);
    if (SUCCEEDED(hr))
    {
        Assert(pNetCfg);

        if (pNetCfg)
        {
            // Get the INetCfgComponent for the adapter in this connection

            // ?? Has the GUID been set already ?
            INetCfgComponent * pnccAdapter = NULL;
            BOOL fFound = FALSE;

            CIterNetCfgComponent nccIter(pNetCfg, &GUID_DEVCLASS_NET);
            INetCfgComponent* pnccAdapterTemp = NULL;

            while (!fFound && SUCCEEDED(hr) &&
                   (S_OK == (hr = nccIter.HrNext(&pnccAdapterTemp))))
            {
                GUID guidDev;
                hr = pnccAdapterTemp->GetInstanceGuid(&guidDev);

                if (S_OK == hr)
                {
                    if (m_guidId == guidDev)
                    {
                        fFound = TRUE;
                        pnccAdapter = pnccAdapterTemp;
                        AddRefObj(pnccAdapter);
                    }
                }
                ReleaseObj (pnccAdapterTemp);
            }

            // Enumerate the binding paths from the adapter
            // and fill in the components list m_lstpstrCompIds
            if (pnccAdapter)
            {
                HRESULT hrTmp;
                PWSTR pszCompId;

                // Add the adapter to our list
                hrTmp = pnccAdapter->GetId(&pszCompId);
                if (SUCCEEDED(hrTmp))
                {
                    if (!FIsStringInList(&m_lstpstrCompIds, pszCompId))
                    {
                        m_lstpstrCompIds.push_back(new tstring(pszCompId));
                    }

                    CoTaskMemFree(pszCompId);
                }

                // Add other components to our list
                CIterNetCfgUpperBindingPath     ncbpIter(pnccAdapter);
                INetCfgBindingPath *            pncbp;

                while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
                {
                    // Note: (tongl 9/17/98): should we only consider enabled paths ?
                    // If we do, how does the tool list refresh when component bindings change ?
                    // Also, what about component getting added\removed ? Does the tool list
                    // need to refresh ??

                    // Enumerate components on the path and add to our list
                    CIterNetCfgBindingInterface ncbiIter(pncbp);

                    INetCfgBindingInterface* pncbi;

                    while(SUCCEEDED(hr) && (hr = ncbiIter.HrNext(&pncbi)) == S_OK)
                    {
                        INetCfgComponent * pnccUpper = NULL;
                        hrTmp = pncbi->GetUpperComponent(&pnccUpper);
                        if (SUCCEEDED(hrTmp))
                        {
                            PWSTR pszCompId;
                            hrTmp = pnccUpper->GetId(&pszCompId);
                            if(SUCCEEDED(hrTmp))
                            {
                                if (!FIsStringInList(&m_lstpstrCompIds, pszCompId))
                                {
                                    m_lstpstrCompIds.push_back(new tstring(pszCompId));
                                }

                                CoTaskMemFree(pszCompId);
                            }

                            ReleaseObj(pnccUpper);
                        }

                        ReleaseObj (pncbi);
                    }

                    if (hr == S_FALSE) // We just got to the end of the loop
                        hr = S_OK;

                    ReleaseObj(pncbp);
                }

                if (hr == S_FALSE) // We just got to the end of the loop
                    hr = S_OK;
            }
        }

        // Release the INetCfg
        (VOID) HrUninitializeAndReleaseINetCfg(fInitCom, pNetCfg, fWriteLock);
        CoTaskMemFree(pszClientDesc);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\config\shell\statmon\smraspsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S M R A S P S P . C P P
//
//  Contents:   The rendering of the UI for the network status monitor's RAS
//              property page
//
//  Notes:
//
//  Author:     CWill   02/03/1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "sminc.h"
#include "smpsh.h"
#include "smutil.h"
#include "nsres.h"
#include "ncatlui.h"
#include "ncnetcon.h"
#include "ncras.h"

#include "mprapi.h"



const int c_nColumns=2;

HRESULT HrRasGetSubEntryHandle(HRASCONN hrasconn, DWORD dwSubEntry,
        HRASCONN* prasconnSub);
HRESULT HrRasHangUp(HRASCONN hrasconn);

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::CPspStatusMonitorRas
//
//  Purpose:    Creator
//
//  Arguments:  None
//
//  Returns:    Nil
//
CPspStatusMonitorRas::CPspStatusMonitorRas() :
    m_hRasConn(NULL)
{
    TraceFileFunc(ttidStatMon);

    m_pGenPage = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::~CPspStatusMonitorTool
//
//  Purpose:    Destructor
//
//  Arguments:  None
//
//  Returns:    Nil
//
CPspStatusMonitorRas::~CPspStatusMonitorRas(VOID)
{
    ::FreeCollectionAndItem(m_lstprdi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::HrInitRasPage
//
//  Purpose:    Initialize the RAS page class before the page has been
//              created
//
//  Arguments:  pncInit -   The connection associated with this monitor
//              pGenPage -  The general page that contains the persistent info
//                          for retrieving the INetConnection on disconnect
//
//  Returns:    Error code
//
HRESULT CPspStatusMonitorRas::HrInitRasPage(INetConnection* pncInit,
                                            CPspStatusMonitorGen * pGenPage,
                                            const DWORD * adwHelpIDs)
{
    TraceFileFunc(ttidStatMon);

    HRESULT hr  = S_OK;

    // set context help IDs
    m_adwHelpIDs = adwHelpIDs;

    // Stash the connection name for later use.
    // Note: Failures are handled and are not fatal
    //
    NETCON_PROPERTIES* pProps;
    hr = pncInit->GetProperties(&pProps);
    if (SUCCEEDED(hr))
    {
        m_strConnectionName = pProps->pszwName;
        m_ncmType = pProps->MediaType;
        m_dwCharacter = pProps->dwCharacter;

        FreeNetconProperties(pProps);
    }

    // Get a point to the General page where we can disconnect the connection
    // when suspending the last link in multilink RAS connection
    AssertSz(pGenPage, "We should have a valid pointer to the General page.");
    if (SUCCEEDED(hr))
    {
        m_pGenPage = pGenPage;
    }

    // Get RAS specific data
    //
    if (m_dwCharacter & NCCF_OUTGOING_ONLY)
    {
        INetRasConnection*  pnrcNew     = NULL;

        hr = HrQIAndSetProxyBlanket(pncInit, &pnrcNew);
        if (SUCCEEDED(hr))
        {
            RASCON_INFO     rciPage = { 0 };

            // Find out what entry in what phone book this connection is on
            //
            hr = pnrcNew->GetRasConnectionInfo (&rciPage);
            if (SUCCEEDED(hr))
            {
                RASENTRY*   pRasEntry = NULL;

                AssertSz(rciPage.pszwPbkFile, "We should have a pszwPbkFile");
                AssertSz(rciPage.pszwEntryName, "We should have a pszwEntryName");

                // Save for later use
                //
                m_strPbkFile    = rciPage.pszwPbkFile;
                m_strEntryName  = rciPage.pszwEntryName;

                // Get the handle to the connection
                //
                hr = pnrcNew->GetRasConnectionHandle(
                            reinterpret_cast<ULONG_PTR*>(&m_hRasConn));
                if (SUCCEEDED(hr))
                {
                    // We only allow user to dial/resume individual links
                    // if DialAll is set (i.e. neither "DialAsNeeded" or
                    // "Dial first available device only")
                    //
                    hr = ::HrRasGetEntryProperties(
                            rciPage.pszwPbkFile,
                            rciPage.pszwEntryName,
                            &pRasEntry,
                            NULL);
                    if (SUCCEEDED(hr))
                    {
                        if (pRasEntry->dwDialMode == RASEDM_DialAll)
                        {
                            DWORD   iSubEntry   = 1;

                            // clear up the current list before we add any new new entry
                            // $REVIEW(tongl 5/12): to fix bug # 170789
                            ::FreeCollectionAndItem(m_lstprdi);

                            // This is a one based count, so we have to have less than or
                            // equal to
                            //
                            for (; SUCCEEDED(hr) && iSubEntry <= pRasEntry->dwSubEntries;
                                    iSubEntry++)
                            {
                                RASSUBENTRY*    pRasSubEntry    = NULL;

                                // The name of the subentry
                                //
                                hr = ::HrRasGetSubEntryProperties(
                                        rciPage.pszwPbkFile,
                                        rciPage.pszwEntryName,
                                        iSubEntry,
                                        &pRasSubEntry);
                                if (SUCCEEDED(hr))
                                {
                                    CRasDeviceInfo* prdiNew     = NULL;
                                    // If we have all the info we need, create
                                    // a new entry add it to the list
                                    //
                                    prdiNew = new CRasDeviceInfo;

                                    if (prdiNew)
                                    {
                                        prdiNew->SetSubEntry(iSubEntry);
                                        prdiNew->SetDeviceName(pRasSubEntry->szDeviceName);
                                        
                                        m_lstprdi.push_back(prdiNew);
                                    }

                                    // Free the subentry data
                                    //
                                    MemFree(pRasSubEntry);
                                }
                            }
                        }

                        MemFree(pRasEntry);
                    }
                }

                ::RciFree(&rciPage);
            }

            ::ReleaseObj(pnrcNew);
        }

    }
    else if (m_dwCharacter & NCCF_INCOMING_ONLY)
    {
        // for incoming connection only

        // save the handle
        INetInboundConnection*  pnicNew;

        hr = HrQIAndSetProxyBlanket(pncInit, &pnicNew);

        if (SUCCEEDED(hr))
        {
            hr = pnicNew->GetServerConnectionHandle(
                    reinterpret_cast<ULONG_PTR*>(&m_hRasConn));
            if (SUCCEEDED(hr))
            {
                // Find out what ports are in this connection
                //
                // NTRAID#NTBUG9-84706-2000/09/28-sumeetb
            }

            ReleaseObj(pnicNew);
        }
    }
    else
    {
        AssertSz(FALSE, "Invalid connection type..");
    }

    TraceError("CPspStatusMonitorRas::HrInitRasPage",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnInitDialog
//
//  Purpose:    Do the initialization required when the page has just been created
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorRas::OnInitDialog(UINT uMsg, WPARAM wParam,
        LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidStatMon);

    // Fill the property list view
    //
    FillPropertyList();

    // Fill the device list
    //
    FillDeviceDropDown();

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnDestroy
//
//  Purpose:    Clean up the dialog before the window goes away
//
//  Arguments:  Standard window messsage parameters
//
//  Returns:    Standard window message return value
//
LRESULT CPspStatusMonitorRas::OnDestroy(UINT uMsg, WPARAM wParam,
        LPARAM lParam, BOOL& bHandled)
{
    TraceFileFunc(ttidStatMon);

    ::FreeCollectionAndItem(m_lstprdi);
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnContextMenu
//
//  Purpose:    When right click a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorRas::OnContextMenu(UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam,
                                    BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    if (m_adwHelpIDs != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnHelp
//
//  Purpose:    When drag context help icon over a control, bring up help
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//
LRESULT
CPspStatusMonitorRas::OnHelp(UINT uMsg,
                             WPARAM wParam,
                             LPARAM lParam,
                             BOOL& fHandled)
{
    TraceFileFunc(ttidStatMon);

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((m_adwHelpIDs != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)m_adwHelpIDs);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::OnSetCursor
//
//  Purpose:    Ensure the mouse cursor over the Property Sheet is an Arrow.
//
//  Arguments:  Standard command parameters
//
//  Returns:    Standard return
//

LRESULT
CPspStatusMonitorRas::OnSetCursor (
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam,
    BOOL&   bHandled)
{
    TraceFileFunc(ttidStatMon);

    if (LOWORD(lParam) == HTCLIENT)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
	
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::GetActiveDeviceCount
//
//  Purpose:    Return the number of active devices
//
//  Arguments:  none
//
//  Returns:    UINT
//
UINT CPspStatusMonitorRas::GetActiveDeviceCount()
{
    TraceFileFunc(ttidStatMon);
    
    INT   nCntDevices;
    INT   iCmb;
    INT   nCnt = 0;

    nCntDevices = SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES, CB_GETCOUNT, 0L, 0L);
    if ((CB_ERR != nCntDevices) && (nCntDevices > 1))
    {
        for (iCmb = 0; iCmb < nCntDevices; iCmb++)
        {
            CRasDeviceInfo* prdiSelect  = NULL;
            NETCON_STATUS   ncsTemp     = NCS_DISCONNECTED;

            // Get the object from the selection
            //
            prdiSelect = reinterpret_cast<CRasDeviceInfo*>(
                    SendDlgItemMessage(IDC_CMB_SM_RAS_DEVICES,
                                       CB_GETITEMDATA, iCmb, 0L));

            AssertSz(prdiSelect, "We should have a prdiSelect");

            // Count the connected devices
            //
            ncsTemp = NcsGetDeviceStatus(prdiSelect);
            if (fIsConnectedStatus(ncsTemp))
            {
                nCnt++;
            }
        }
    }

    return nCnt;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::FillPropertyList
//
//  Purpose:    Fill in the list of RAS properties
//
//  Arguments:  None
//
//  Returns:    Nil
//
VOID CPspStatusMonitorRas::FillPropertyList(VOID)
{
    TraceFileFunc(ttidStatMon);

    HWND hList = GetDlgItem(IDC_LVW_RAS_PROPERTY);

    // list view column structure
    RECT rect;
    LV_COLUMN lvCol;
    int index, iNewItem;

    // Calculate column width
    ::GetClientRect(hList, &rect);
    
    int colWidthFirst      = rect.right * 0.4; // First column is 40%
    int colWidthSubsequent = (rect.right-colWidthFirst)/(c_nColumns-1); // Divide remaining space between other columns equally

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0==index) // first column
        {
            lvCol.cx = colWidthFirst;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PROPERTY);
        }
        else
        {
            lvCol.cx = colWidthSubsequent;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_VALUE);
        }

        iNewItem = ListView_InsertColumn(hList, index, &lvCol);

        AssertSz((iNewItem == index), "Invalid item inserted to list view !");
    }

    // Get RAS property data
    if (m_dwCharacter & NCCF_OUTGOING_ONLY)
    {
        FillRasClientProperty();
    }
    else
    {
        FillRasServerProperty();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::FillRasClientProperty
//
//  Purpose:    Fill in the list of RAS properties for a RAS client
//
//  Arguments:  None
//
//  Returns:    Nil
//
VOID CPspStatusMonitorRas::FillRasClientProperty(VOID)
{
    TraceFileFunc(ttidStatMon);
    
    BOOLEAN bSlipConnection = FALSE;
    HWND hList = GetDlgItem(IDC_LVW_RAS_PROPERTY);
    tstring strServerType = (PWSTR) SzLoadIds(IDS_PPP);
    tstring strProtocolList = c_szEmpty;
    tstring strDeviceName = c_szEmpty;
    tstring strDeviceType = c_szEmpty;

    DWORD   dwRetCode;
    DWORD   dwSize;

    
    RASCONNSTATUS rcs;
    rcs.dwSize = sizeof(RASCONNSTATUS);
    dwRetCode = RasGetConnectStatus (m_hRasConn, &rcs);
    if (dwRetCode == NO_ERROR)
    {
        strDeviceName = rcs.szDeviceName;
        strDeviceType = rcs.szDeviceType;
        
        TraceTag(ttidStatMon, "RASCONNSTATUS.szDeviceName = %s", rcs.szDeviceName);
        TraceTag(ttidStatMon, "RASCONNSTATUS.szDeviceType = %s", rcs.szDeviceType);
    }

    // RASP_PppIp
    tstring strServerIp   = c_szEmpty;
    tstring strClientIp   = c_szEmpty;

    RASPPPIP    RasPppIp;
    RasPppIp.dwSize = sizeof( RasPppIp );

    dwSize = sizeof( RasPppIp );

    dwRetCode = RasGetProjectionInfo (m_hRasConn, RASP_PppIp, &RasPppIp, &dwSize);
    if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasPppIp.dwError))
    {
        if (!strProtocolList.empty())
            strProtocolList += SzLoadIds(IDS_COMMA);
        strProtocolList += SzLoadIds(IDS_TCPIP);

        TraceTag(ttidStatMon, "RasPppIp.szServerIpAddress = %S", RasPppIp.szServerIpAddress);
        TraceTag(ttidStatMon, "RasPppIp.szIpAddress = %S", RasPppIp.szIpAddress);

        strServerIp = RasPppIp.szServerIpAddress;
        strClientIp = RasPppIp.szIpAddress;
    }

    // RASP_PppIpx
    tstring strClientIpx = c_szEmpty;

    RASPPPIPX    RasPppIpx;
    RasPppIpx.dwSize = sizeof( RasPppIpx );

    dwSize = sizeof( RasPppIpx );

    dwRetCode = RasGetProjectionInfo (m_hRasConn, RASP_PppIpx, &RasPppIpx, &dwSize);
    if ((dwRetCode == NO_ERROR)  && (NO_ERROR == RasPppIpx.dwError))
    {
        if (!strProtocolList.empty())
            strProtocolList += SzLoadIds(IDS_COMMA);
        strProtocolList += SzLoadIds(IDS_IPX);

        TraceTag(ttidStatMon, "RasPppIpx.szIpxAddress = %S", RasPppIpx.szIpxAddress);
        strClientIpx = RasPppIpx.szIpxAddress;
    }

    // RASP_PppNbf
    tstring strComputerName = c_szEmpty;

    RASPPPNBF    RasPppNbf;
    RasPppNbf.dwSize = sizeof( RasPppNbf );

    dwSize = sizeof( RasPppNbf );

    dwRetCode = RasGetProjectionInfo (m_hRasConn, RASP_PppNbf, &RasPppNbf, &dwSize);
    if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasPppNbf.dwError))
    {
        if (!strProtocolList.empty())
            strProtocolList += SzLoadIds(IDS_COMMA);
        strProtocolList += SzLoadIds(IDS_NBF);

        TraceTag(ttidStatMon, "RasPppNbf.szWorkstationName = %S", RasPppNbf.szWorkstationName);
        strComputerName = RasPppNbf.szWorkstationName;
    }

    // RASP_Slip
    RASSLIP    RasSlip;
    RasSlip.dwSize = sizeof( RasSlip );

    dwSize = sizeof( RasSlip );

    dwRetCode =  RasGetProjectionInfo (m_hRasConn, RASP_Slip, &RasSlip, &dwSize);
    if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasSlip.dwError))
    {
        AssertSz(strProtocolList.empty(), "How could this connection be both PPP and SLIP ?");

        strServerType = SzLoadIds(IDS_SLIP);
        strProtocolList = SzLoadIds(IDS_TCPIP);

        // Get the client IP address. The server IP is not exposed in this 
        // structure.
        strClientIp = RasSlip.szIpAddress;

        // Remember that this is a SLIP connection and not a PPP connection.
        bSlipConnection = TRUE;
    }

    // Authentication, Encryption and Compression info
    tstring strAuthentication   = c_szEmpty;
    tstring strEncryption       = c_szEmpty;
    tstring strIPSECEncryption  = c_szEmpty;
    tstring strCompression      = SzLoadIds(IDS_NONE);
    tstring strFraming          = c_szEmpty;

    // RASP_PppLcp
    RASPPPLCP    RasLcp;
    RasLcp.dwSize = sizeof( RasLcp );

    dwSize = sizeof( RasLcp );

    dwRetCode =  RasGetProjectionInfo (m_hRasConn, RASP_PppLcp, &RasLcp, &dwSize);
    if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasLcp.dwError))
    {
        TraceTag(ttidStatMon, "Getting RASP_PppLcp info");
        TraceTag(ttidStatMon, "RasLcp.dwServerAuthenticationProtocol = %d", RasLcp.dwAuthenticationProtocol);
        TraceTag(ttidStatMon, "RasLcp.dwServerAuthenticationData = %d",     RasLcp.dwAuthenticationData);
        TraceTag(ttidStatMon, "RasLcp.fMultilink = %d", RasLcp.fMultilink);
        TraceTag(ttidStatMon, "RasLcp.dwOptions = %d", RasLcp.dwOptions);

        switch(RasLcp.dwServerAuthenticationProtocol)
        {
        case RASLCPAP_PAP:
            strAuthentication = SzLoadIds(IDS_PAP);
            break;

        case RASLCPAP_SPAP:
            strAuthentication = SzLoadIds(IDS_SPAP);
            break;

        case RASLCPAP_CHAP:
            {
                // get more specifics
                switch(RasLcp.dwServerAuthenticationData)
                {
                case RASLCPAD_CHAP_MS:
                    strAuthentication = SzLoadIds(IDS_CHAP);
                    break;

                case RASLCPAD_CHAP_MD5:
                    strAuthentication = SzLoadIds(IDS_CHAP_MD5);
                    break;

                case RASLCPAD_CHAP_MSV2:
                    strAuthentication = SzLoadIds(IDS_CHAP_V2);
                    break;
                }
            }
            break;

        case RASLCPAP_EAP:
            strAuthentication = SzLoadIds(IDS_EAP);
            break;
        }

        if (bSlipConnection == FALSE )
        {
            // Only PPP connections have the multilink property.
            if (RasLcp.fMultilink)
                strFraming = SzLoadIds(IDS_ON);
            else
                strFraming = SzLoadIds(IDS_OFF);
        }

        if (RasLcp.dwOptions & RASLCPO_DES_56)
        {
            strIPSECEncryption = SzLoadIds(IDS_EncryptionDES56);
        }
        else if (RasLcp.dwOptions & RASLCPO_3_DES)
        {
            strIPSECEncryption = SzLoadIds(IDS_Encryption3DES);
        }
    }

    // RASP_PppCcp
    RASPPPCCP    RasCcp;
    RasCcp.dwSize = sizeof( RasCcp );

    dwSize = sizeof( RasCcp );

    dwRetCode =  RasGetProjectionInfo (m_hRasConn, RASP_PppCcp, &RasCcp, &dwSize);
    if ((dwRetCode == NO_ERROR) && (NO_ERROR == RasCcp.dwError))
    {
        TraceTag(ttidStatMon, "Getting RASP_PppCcp info");
        TraceTag(ttidStatMon, "RasCcp.dwOptions = %x", RasCcp.dwOptions);
        TraceTag(ttidStatMon, "RasCcp.dwCompressionAlgorithm = %d", RasCcp.dwCompressionAlgorithm);

        if (RasCcp.dwOptions & RASCCPO_Encryption56bit)
        {
            strEncryption = SzLoadIds(IDS_Encryption56bit);
        }
        else if (RasCcp.dwOptions & RASCCPO_Encryption40bit)
        {
            strEncryption = SzLoadIds(IDS_Encryption40bit);
        }
        else if (RasCcp.dwOptions & RASCCPO_Encryption128bit)
        {
            strEncryption = SzLoadIds(IDS_Encryption128bit);
        }

        if (RasCcp.dwOptions & RASCCPO_Compression)
        {
            switch(RasCcp.dwCompressionAlgorithm)
            {
            case RASCCPCA_MPPC:
                strCompression = SzLoadIds(IDS_MPPC);
                break;

            case RASCCPCA_STAC:
                strCompression = SzLoadIds(IDS_STAC);
                break;
            }
        }
    }

    // Fill the list view
    ListView_DeleteAllItems(hList);

    int iItem =0;

    // Device name
    int iListviewItem = InsertProperty(&iItem, IDS_DeviceName, strDeviceName);
    if (-1 != iListviewItem)
    {
        ListView_SetItemState(hList, iListviewItem, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }

    // Device type
    InsertProperty(&iItem, IDS_DeviceType, strDeviceType);
    
    // Server type
    InsertProperty(&iItem, IDS_ServerType, strServerType);

    // Transports
    InsertProperty(&iItem, IDS_Transports, strProtocolList);

    // Authentication
    InsertProperty(&iItem, IDS_Authentication, strAuthentication);

    // Encryption
    InsertProperty(&iItem, IDS_Encryption, strEncryption);

    // IPSEC Encryption
    InsertProperty(&iItem, IDS_IPSECEncryption, strIPSECEncryption);

    // Compression
    InsertProperty(&iItem, IDS_Compression, strCompression);

    // PPP Multilink Framing
    InsertProperty(&iItem, IDS_ML_Framing, strFraming);

    // Server IP address
    InsertProperty(&iItem, IDS_ServerIP, strServerIp);

    // Client IP address
    InsertProperty(&iItem, IDS_ClientIP, strClientIp);

    // Client IPX address
    InsertProperty(&iItem, IDS_ClientIPX, strClientIpx);

    // Client computer name
    InsertProperty(&iItem, IDS_ComputerName, strComputerName);

}

//+---------------------------------------------------------------------------
//
//  Member:     CPspStatusMonitorRas::FillRasServerProperty
//
//  Purpose:    Fill in the list of RAS properties for a RAS server
//
//  Arguments:  None
//
//  Returns:    Nil
//
VOID CPspStatusMonitorRas::FillRasServerProperty(VOID)
{
    TraceFileFunc(ttidStatMon);

    HWND hList = GetDlgItem(IDC_LVW_RAS_PROPERTY);

    RAS_SERVER_HANDLE hMprAdmin;
    DWORD dwError = MprAdminServerConnect(NULL, &hMprAdmin);

    if (dwError == NO_ERROR)
    {
        // Initialize the list view
        ListView_DeleteAllItems(hList);
        int iItem =0;

        //
        // Level 1 info
        //

        // Only PPP is supported on the RAS server
        tstring strServerType = (PWSTR) SzLoadIds(IDS_PPP);
        tstring strProtocolList = c_szEmpty;

        // IP info
        tstring strServerIp = c_szEmpty;
        tstring strClientIp = c_szEmpty;

        // IPX info
        tstring strClientIpx = c_szEmpty;

        // Nbf info
        tstring strComputerName = c_szEmpty;


        RAS_CONNECTION_1 * pConn1;
        dwError = MprAdminConnectionGetInfo(hMprAdmin,
                                            1,
                                            m_hRasConn,
                                            (LPBYTE*)&pConn1);
        if (dwError == NO_ERROR)
        {
            PPP_INFO * pInfo = &(pConn1->PppInfo);

            // PPP_IPCP_INFO
            if (!(pInfo->ip).dwError)
            {
                if (!strProtocolList.empty())
                    strProtocolList += SzLoadIds(IDS_COMMA);
                strProtocolList += SzLoadIds(IDS_TCPIP);

                strServerIp = pInfo->ip.wszAddress; 
                strClientIp = pInfo->ip.wszRemoteAddress;
            }

            // PPP_IPXCP_INFO
            if (!pInfo->ipx.dwError)
            {
                if (!strProtocolList.empty())
                    strProtocolList += SzLoadIds(IDS_COMMA);
                strProtocolList += SzLoadIds(IDS_IPX);

                strClientIpx = pInfo->ipx.wszAddress;
            }

            // PPP_NBFCP_INFO
            if (!pInfo->nbf.dwError)
            {
                if (!strProtocolList.empty())
                    strProtocolList += SzLoadIds(IDS_COMMA);
                strProtocolList += SzLoadIds(IDS_NBF);

                strComputerName = pInfo->nbf.wszWksta;
            }

            // PPP_ATCP_INFO
            if (!pInfo->at.dwError)
            {
                if (!strProtocolList.empty())
                    strProtocolList += SzLoadIds(IDS_COMMA);
                strProtocolList += SzLoadIds(IDS_APPLETALK);
            }

            MprAdminBufferFree(p